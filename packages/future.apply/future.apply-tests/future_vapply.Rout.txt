
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:01:00.912] plan(): Setting new future strategy stack:
[17:01:00.912] List of future strategies:
[17:01:00.912] 1. sequential:
[17:01:00.912]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:00.912]    - tweaked: FALSE
[17:01:00.912]    - call: future::plan("sequential")
[17:01:00.926] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:01:01.032] plan(): Setting new future strategy stack:
[17:01:01.032] List of future strategies:
[17:01:01.032] 1. sequential:
[17:01:01.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.032]    - tweaked: FALSE
[17:01:01.032]    - call: plan(strategy)
[17:01:01.043] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:01:01.050] future_lapply() ...
[17:01:01.056] Number of chunks: 1
[17:01:01.057] getGlobalsAndPackagesXApply() ...
[17:01:01.057]  - future.globals: TRUE
[17:01:01.057] getGlobalsAndPackages() ...
[17:01:01.057] Searching for globals...
[17:01:01.061] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.062] Searching for globals ... DONE
[17:01:01.062] Resolving globals: FALSE
[17:01:01.063] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:01:01.064] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.064] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.064] - packages: [1] ‘future.apply’
[17:01:01.064] getGlobalsAndPackages() ... DONE
[17:01:01.064]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.064]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.064] Finding globals ... DONE
[17:01:01.064]  - use_args: TRUE
[17:01:01.065]  - Getting '...' globals ...
[17:01:01.065] resolve() on list ...
[17:01:01.065]  recursive: 0
[17:01:01.066]  length: 1
[17:01:01.066]  elements: ‘...’
[17:01:01.066]  length: 0 (resolved future 1)
[17:01:01.066] resolve() on list ... DONE
[17:01:01.066]    - '...' content: [n=0] 
[17:01:01.066] List of 1
[17:01:01.066]  $ ...: list()
[17:01:01.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.066]  - attr(*, "where")=List of 1
[17:01:01.066]   ..$ ...:<environment: 0x55aada8d5ad8> 
[17:01:01.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.066]  - attr(*, "resolved")= logi TRUE
[17:01:01.066]  - attr(*, "total_size")= num NA
[17:01:01.069]  - Getting '...' globals ... DONE
[17:01:01.069] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.069] List of 8
[17:01:01.069]  $ ...future.FUN:function (x, ...)  
[17:01:01.069]  $ x_FUN        :function (x)  
[17:01:01.069]  $ times        : int 1
[17:01:01.069]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.069]  $ stop_if_not  :function (...)  
[17:01:01.069]  $ dim          : NULL
[17:01:01.069]  $ valid_types  : chr "character"
[17:01:01.069]  $ ...          : list()
[17:01:01.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.069]  - attr(*, "where")=List of 8
[17:01:01.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.069]   ..$ ...          :<environment: 0x55aada8d5ad8> 
[17:01:01.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.069]  - attr(*, "resolved")= logi FALSE
[17:01:01.069]  - attr(*, "total_size")= num 94208
[17:01:01.074] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.074] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.075] Number of futures (= number of chunks): 1
[17:01:01.075] Launching 1 futures (chunks) ...
[17:01:01.075] Chunk #1 of 1 ...
[17:01:01.075]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.075] getGlobalsAndPackages() ...
[17:01:01.075] Searching for globals...
[17:01:01.076] 
[17:01:01.076] Searching for globals ... DONE
[17:01:01.076] - globals: [0] <none>
[17:01:01.076] getGlobalsAndPackages() ... DONE
[17:01:01.076]    + additional globals found: [n=0] 
[17:01:01.076]    + additional namespaces needed: [n=0] 
[17:01:01.076]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.076]  - seeds: <none>
[17:01:01.076]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.077] getGlobalsAndPackages() ...
[17:01:01.077] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.077] Resolving globals: FALSE
[17:01:01.077] Tweak future expression to call with '...' arguments ...
[17:01:01.077] {
[17:01:01.077]     do.call(function(...) {
[17:01:01.077]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.077]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.077]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.077]             on.exit(options(oopts), add = TRUE)
[17:01:01.077]         }
[17:01:01.077]         {
[17:01:01.077]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.077]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.077]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.077]             })
[17:01:01.077]         }
[17:01:01.077]     }, args = future.call.arguments)
[17:01:01.077] }
[17:01:01.077] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.078] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.078] - packages: [1] ‘future.apply’
[17:01:01.078] getGlobalsAndPackages() ... DONE
[17:01:01.079] run() for ‘Future’ ...
[17:01:01.079] - state: ‘created’
[17:01:01.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.080]   - Field: ‘label’
[17:01:01.080]   - Field: ‘local’
[17:01:01.080]   - Field: ‘owner’
[17:01:01.080]   - Field: ‘envir’
[17:01:01.080]   - Field: ‘packages’
[17:01:01.080]   - Field: ‘gc’
[17:01:01.080]   - Field: ‘conditions’
[17:01:01.080]   - Field: ‘expr’
[17:01:01.080]   - Field: ‘uuid’
[17:01:01.080]   - Field: ‘seed’
[17:01:01.081]   - Field: ‘version’
[17:01:01.081]   - Field: ‘result’
[17:01:01.081]   - Field: ‘asynchronous’
[17:01:01.081]   - Field: ‘calls’
[17:01:01.081]   - Field: ‘globals’
[17:01:01.081]   - Field: ‘stdout’
[17:01:01.081]   - Field: ‘earlySignal’
[17:01:01.081]   - Field: ‘lazy’
[17:01:01.081]   - Field: ‘state’
[17:01:01.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.081] - Launch lazy future ...
[17:01:01.082] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.085] Packages needed by future strategies (n = 0): <none>
[17:01:01.086] {
[17:01:01.086]     {
[17:01:01.086]         {
[17:01:01.086]             ...future.startTime <- base::Sys.time()
[17:01:01.086]             {
[17:01:01.086]                 {
[17:01:01.086]                   {
[17:01:01.086]                     {
[17:01:01.086]                       base::local({
[17:01:01.086]                         has_future <- base::requireNamespace("future", 
[17:01:01.086]                           quietly = TRUE)
[17:01:01.086]                         if (has_future) {
[17:01:01.086]                           ns <- base::getNamespace("future")
[17:01:01.086]                           version <- ns[[".package"]][["version"]]
[17:01:01.086]                           if (is.null(version)) 
[17:01:01.086]                             version <- utils::packageVersion("future")
[17:01:01.086]                         }
[17:01:01.086]                         else {
[17:01:01.086]                           version <- NULL
[17:01:01.086]                         }
[17:01:01.086]                         if (!has_future || version < "1.8.0") {
[17:01:01.086]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.086]                             "", base::R.version$version.string), 
[17:01:01.086]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.086]                               "release", "version")], collapse = " "), 
[17:01:01.086]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.086]                             info)
[17:01:01.086]                           info <- base::paste(info, collapse = "; ")
[17:01:01.086]                           if (!has_future) {
[17:01:01.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.086]                               info)
[17:01:01.086]                           }
[17:01:01.086]                           else {
[17:01:01.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.086]                               info, version)
[17:01:01.086]                           }
[17:01:01.086]                           base::stop(msg)
[17:01:01.086]                         }
[17:01:01.086]                       })
[17:01:01.086]                     }
[17:01:01.086]                     base::local({
[17:01:01.086]                       for (pkg in "future.apply") {
[17:01:01.086]                         base::loadNamespace(pkg)
[17:01:01.086]                         base::library(pkg, character.only = TRUE)
[17:01:01.086]                       }
[17:01:01.086]                     })
[17:01:01.086]                   }
[17:01:01.086]                   ...future.strategy.old <- future::plan("list")
[17:01:01.086]                   options(future.plan = NULL)
[17:01:01.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.086]                 }
[17:01:01.086]                 ...future.workdir <- getwd()
[17:01:01.086]             }
[17:01:01.086]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.086]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.086]         }
[17:01:01.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.086]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.086]             base::names(...future.oldOptions))
[17:01:01.086]     }
[17:01:01.086]     if (FALSE) {
[17:01:01.086]     }
[17:01:01.086]     else {
[17:01:01.086]         if (TRUE) {
[17:01:01.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.086]                 open = "w")
[17:01:01.086]         }
[17:01:01.086]         else {
[17:01:01.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.086]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.086]         }
[17:01:01.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.086]             base::sink(type = "output", split = FALSE)
[17:01:01.086]             base::close(...future.stdout)
[17:01:01.086]         }, add = TRUE)
[17:01:01.086]     }
[17:01:01.086]     ...future.frame <- base::sys.nframe()
[17:01:01.086]     ...future.conditions <- base::list()
[17:01:01.086]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.086]     if (FALSE) {
[17:01:01.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.086]     }
[17:01:01.086]     ...future.result <- base::tryCatch({
[17:01:01.086]         base::withCallingHandlers({
[17:01:01.086]             ...future.value <- base::withVisible(base::local({
[17:01:01.086]                 do.call(function(...) {
[17:01:01.086]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.086]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.086]                     ...future.globals.maxSize)) {
[17:01:01.086]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.086]                     on.exit(options(oopts), add = TRUE)
[17:01:01.086]                   }
[17:01:01.086]                   {
[17:01:01.086]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.086]                       FUN = function(jj) {
[17:01:01.086]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.086]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.086]                       })
[17:01:01.086]                   }
[17:01:01.086]                 }, args = future.call.arguments)
[17:01:01.086]             }))
[17:01:01.086]             future::FutureResult(value = ...future.value$value, 
[17:01:01.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.086]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.086]                     ...future.globalenv.names))
[17:01:01.086]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.086]         }, condition = base::local({
[17:01:01.086]             c <- base::c
[17:01:01.086]             inherits <- base::inherits
[17:01:01.086]             invokeRestart <- base::invokeRestart
[17:01:01.086]             length <- base::length
[17:01:01.086]             list <- base::list
[17:01:01.086]             seq.int <- base::seq.int
[17:01:01.086]             signalCondition <- base::signalCondition
[17:01:01.086]             sys.calls <- base::sys.calls
[17:01:01.086]             `[[` <- base::`[[`
[17:01:01.086]             `+` <- base::`+`
[17:01:01.086]             `<<-` <- base::`<<-`
[17:01:01.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.086]                   3L)]
[17:01:01.086]             }
[17:01:01.086]             function(cond) {
[17:01:01.086]                 is_error <- inherits(cond, "error")
[17:01:01.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.086]                   NULL)
[17:01:01.086]                 if (is_error) {
[17:01:01.086]                   sessionInformation <- function() {
[17:01:01.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.086]                       search = base::search(), system = base::Sys.info())
[17:01:01.086]                   }
[17:01:01.086]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.086]                     cond$call), session = sessionInformation(), 
[17:01:01.086]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.086]                   signalCondition(cond)
[17:01:01.086]                 }
[17:01:01.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.086]                 "immediateCondition"))) {
[17:01:01.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.086]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.086]                   if (TRUE && !signal) {
[17:01:01.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.086]                     {
[17:01:01.086]                       inherits <- base::inherits
[17:01:01.086]                       invokeRestart <- base::invokeRestart
[17:01:01.086]                       is.null <- base::is.null
[17:01:01.086]                       muffled <- FALSE
[17:01:01.086]                       if (inherits(cond, "message")) {
[17:01:01.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.086]                         if (muffled) 
[17:01:01.086]                           invokeRestart("muffleMessage")
[17:01:01.086]                       }
[17:01:01.086]                       else if (inherits(cond, "warning")) {
[17:01:01.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.086]                         if (muffled) 
[17:01:01.086]                           invokeRestart("muffleWarning")
[17:01:01.086]                       }
[17:01:01.086]                       else if (inherits(cond, "condition")) {
[17:01:01.086]                         if (!is.null(pattern)) {
[17:01:01.086]                           computeRestarts <- base::computeRestarts
[17:01:01.086]                           grepl <- base::grepl
[17:01:01.086]                           restarts <- computeRestarts(cond)
[17:01:01.086]                           for (restart in restarts) {
[17:01:01.086]                             name <- restart$name
[17:01:01.086]                             if (is.null(name)) 
[17:01:01.086]                               next
[17:01:01.086]                             if (!grepl(pattern, name)) 
[17:01:01.086]                               next
[17:01:01.086]                             invokeRestart(restart)
[17:01:01.086]                             muffled <- TRUE
[17:01:01.086]                             break
[17:01:01.086]                           }
[17:01:01.086]                         }
[17:01:01.086]                       }
[17:01:01.086]                       invisible(muffled)
[17:01:01.086]                     }
[17:01:01.086]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.086]                   }
[17:01:01.086]                 }
[17:01:01.086]                 else {
[17:01:01.086]                   if (TRUE) {
[17:01:01.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.086]                     {
[17:01:01.086]                       inherits <- base::inherits
[17:01:01.086]                       invokeRestart <- base::invokeRestart
[17:01:01.086]                       is.null <- base::is.null
[17:01:01.086]                       muffled <- FALSE
[17:01:01.086]                       if (inherits(cond, "message")) {
[17:01:01.086]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.086]                         if (muffled) 
[17:01:01.086]                           invokeRestart("muffleMessage")
[17:01:01.086]                       }
[17:01:01.086]                       else if (inherits(cond, "warning")) {
[17:01:01.086]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.086]                         if (muffled) 
[17:01:01.086]                           invokeRestart("muffleWarning")
[17:01:01.086]                       }
[17:01:01.086]                       else if (inherits(cond, "condition")) {
[17:01:01.086]                         if (!is.null(pattern)) {
[17:01:01.086]                           computeRestarts <- base::computeRestarts
[17:01:01.086]                           grepl <- base::grepl
[17:01:01.086]                           restarts <- computeRestarts(cond)
[17:01:01.086]                           for (restart in restarts) {
[17:01:01.086]                             name <- restart$name
[17:01:01.086]                             if (is.null(name)) 
[17:01:01.086]                               next
[17:01:01.086]                             if (!grepl(pattern, name)) 
[17:01:01.086]                               next
[17:01:01.086]                             invokeRestart(restart)
[17:01:01.086]                             muffled <- TRUE
[17:01:01.086]                             break
[17:01:01.086]                           }
[17:01:01.086]                         }
[17:01:01.086]                       }
[17:01:01.086]                       invisible(muffled)
[17:01:01.086]                     }
[17:01:01.086]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.086]                   }
[17:01:01.086]                 }
[17:01:01.086]             }
[17:01:01.086]         }))
[17:01:01.086]     }, error = function(ex) {
[17:01:01.086]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.086]                 ...future.rng), started = ...future.startTime, 
[17:01:01.086]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.086]             version = "1.8"), class = "FutureResult")
[17:01:01.086]     }, finally = {
[17:01:01.086]         if (!identical(...future.workdir, getwd())) 
[17:01:01.086]             setwd(...future.workdir)
[17:01:01.086]         {
[17:01:01.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.086]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.086]             }
[17:01:01.086]             base::options(...future.oldOptions)
[17:01:01.086]             if (.Platform$OS.type == "windows") {
[17:01:01.086]                 old_names <- names(...future.oldEnvVars)
[17:01:01.086]                 envs <- base::Sys.getenv()
[17:01:01.086]                 names <- names(envs)
[17:01:01.086]                 common <- intersect(names, old_names)
[17:01:01.086]                 added <- setdiff(names, old_names)
[17:01:01.086]                 removed <- setdiff(old_names, names)
[17:01:01.086]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.086]                   envs[common]]
[17:01:01.086]                 NAMES <- toupper(changed)
[17:01:01.086]                 args <- list()
[17:01:01.086]                 for (kk in seq_along(NAMES)) {
[17:01:01.086]                   name <- changed[[kk]]
[17:01:01.086]                   NAME <- NAMES[[kk]]
[17:01:01.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.086]                     next
[17:01:01.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.086]                 }
[17:01:01.086]                 NAMES <- toupper(added)
[17:01:01.086]                 for (kk in seq_along(NAMES)) {
[17:01:01.086]                   name <- added[[kk]]
[17:01:01.086]                   NAME <- NAMES[[kk]]
[17:01:01.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.086]                     next
[17:01:01.086]                   args[[name]] <- ""
[17:01:01.086]                 }
[17:01:01.086]                 NAMES <- toupper(removed)
[17:01:01.086]                 for (kk in seq_along(NAMES)) {
[17:01:01.086]                   name <- removed[[kk]]
[17:01:01.086]                   NAME <- NAMES[[kk]]
[17:01:01.086]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.086]                     next
[17:01:01.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.086]                 }
[17:01:01.086]                 if (length(args) > 0) 
[17:01:01.086]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.086]             }
[17:01:01.086]             else {
[17:01:01.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.086]             }
[17:01:01.086]             {
[17:01:01.086]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.086]                   0L) {
[17:01:01.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.086]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.086]                   base::options(opts)
[17:01:01.086]                 }
[17:01:01.086]                 {
[17:01:01.086]                   {
[17:01:01.086]                     NULL
[17:01:01.086]                     RNGkind("Mersenne-Twister")
[17:01:01.086]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.086]                       inherits = FALSE)
[17:01:01.086]                   }
[17:01:01.086]                   options(future.plan = NULL)
[17:01:01.086]                   if (is.na(NA_character_)) 
[17:01:01.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.086]                     .init = FALSE)
[17:01:01.086]                 }
[17:01:01.086]             }
[17:01:01.086]         }
[17:01:01.086]     })
[17:01:01.086]     if (TRUE) {
[17:01:01.086]         base::sink(type = "output", split = FALSE)
[17:01:01.086]         if (TRUE) {
[17:01:01.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.086]         }
[17:01:01.086]         else {
[17:01:01.086]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.086]         }
[17:01:01.086]         base::close(...future.stdout)
[17:01:01.086]         ...future.stdout <- NULL
[17:01:01.086]     }
[17:01:01.086]     ...future.result$conditions <- ...future.conditions
[17:01:01.086]     ...future.result$finished <- base::Sys.time()
[17:01:01.086]     ...future.result
[17:01:01.086] }
[17:01:01.088] assign_globals() ...
[17:01:01.088] List of 11
[17:01:01.088]  $ ...future.FUN            :function (x, ...)  
[17:01:01.088]  $ x_FUN                    :function (x)  
[17:01:01.088]  $ times                    : int 1
[17:01:01.088]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.088]  $ stop_if_not              :function (...)  
[17:01:01.088]  $ dim                      : NULL
[17:01:01.088]  $ valid_types              : chr "character"
[17:01:01.088]  $ future.call.arguments    : list()
[17:01:01.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.088]  $ ...future.elements_ii    :List of 2
[17:01:01.088]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:01:01.088]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:01:01.088]  $ ...future.seeds_ii       : NULL
[17:01:01.088]  $ ...future.globals.maxSize: NULL
[17:01:01.088]  - attr(*, "where")=List of 11
[17:01:01.088]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.088]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.088]  - attr(*, "resolved")= logi FALSE
[17:01:01.088]  - attr(*, "total_size")= num 94208
[17:01:01.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.088]  - attr(*, "already-done")= logi TRUE
[17:01:01.096] - copied ‘...future.FUN’ to environment
[17:01:01.096] - copied ‘x_FUN’ to environment
[17:01:01.096] - copied ‘times’ to environment
[17:01:01.096] - copied ‘stopf’ to environment
[17:01:01.096] - copied ‘stop_if_not’ to environment
[17:01:01.096] - copied ‘dim’ to environment
[17:01:01.096] - copied ‘valid_types’ to environment
[17:01:01.096] - copied ‘future.call.arguments’ to environment
[17:01:01.096] - copied ‘...future.elements_ii’ to environment
[17:01:01.096] - copied ‘...future.seeds_ii’ to environment
[17:01:01.097] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.097] assign_globals() ... done
[17:01:01.097] plan(): Setting new future strategy stack:
[17:01:01.097] List of future strategies:
[17:01:01.097] 1. sequential:
[17:01:01.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.097]    - tweaked: FALSE
[17:01:01.097]    - call: NULL
[17:01:01.098] plan(): nbrOfWorkers() = 1
[17:01:01.099] plan(): Setting new future strategy stack:
[17:01:01.099] List of future strategies:
[17:01:01.099] 1. sequential:
[17:01:01.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.099]    - tweaked: FALSE
[17:01:01.099]    - call: plan(strategy)
[17:01:01.099] plan(): nbrOfWorkers() = 1
[17:01:01.100] SequentialFuture started (and completed)
[17:01:01.100] - Launch lazy future ... done
[17:01:01.100] run() for ‘SequentialFuture’ ... done
[17:01:01.100] Created future:
[17:01:01.100] SequentialFuture:
[17:01:01.100] Label: ‘future_vapply-1’
[17:01:01.100] Expression:
[17:01:01.100] {
[17:01:01.100]     do.call(function(...) {
[17:01:01.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.100]             on.exit(options(oopts), add = TRUE)
[17:01:01.100]         }
[17:01:01.100]         {
[17:01:01.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.100]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.100]             })
[17:01:01.100]         }
[17:01:01.100]     }, args = future.call.arguments)
[17:01:01.100] }
[17:01:01.100] Lazy evaluation: FALSE
[17:01:01.100] Asynchronous evaluation: FALSE
[17:01:01.100] Local evaluation: TRUE
[17:01:01.100] Environment: R_GlobalEnv
[17:01:01.100] Capture standard output: TRUE
[17:01:01.100] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.100] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.100] Packages: 1 packages (‘future.apply’)
[17:01:01.100] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.100] Resolved: TRUE
[17:01:01.100] Value: 232 bytes of class ‘list’
[17:01:01.100] Early signaling: FALSE
[17:01:01.100] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.100] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.102] Chunk #1 of 1 ... DONE
[17:01:01.102] Launching 1 futures (chunks) ... DONE
[17:01:01.102] Resolving 1 futures (chunks) ...
[17:01:01.102] resolve() on list ...
[17:01:01.102]  recursive: 0
[17:01:01.102]  length: 1
[17:01:01.103] 
[17:01:01.103] resolved() for ‘SequentialFuture’ ...
[17:01:01.103] - state: ‘finished’
[17:01:01.103] - run: TRUE
[17:01:01.103] - result: ‘FutureResult’
[17:01:01.103] resolved() for ‘SequentialFuture’ ... done
[17:01:01.103] Future #1
[17:01:01.104] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.104] - nx: 1
[17:01:01.104] - relay: TRUE
[17:01:01.104] - stdout: TRUE
[17:01:01.104] - signal: TRUE
[17:01:01.104] - resignal: FALSE
[17:01:01.104] - force: TRUE
[17:01:01.104] - relayed: [n=1] FALSE
[17:01:01.104] - queued futures: [n=1] FALSE
[17:01:01.104]  - until=1
[17:01:01.105]  - relaying element #1
[17:01:01.105] - relayed: [n=1] TRUE
[17:01:01.105] - queued futures: [n=1] TRUE
[17:01:01.105] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.105]  length: 0 (resolved future 1)
[17:01:01.105] Relaying remaining futures
[17:01:01.105] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.105] - nx: 1
[17:01:01.105] - relay: TRUE
[17:01:01.106] - stdout: TRUE
[17:01:01.106] - signal: TRUE
[17:01:01.106] - resignal: FALSE
[17:01:01.106] - force: TRUE
[17:01:01.106] - relayed: [n=1] TRUE
[17:01:01.106] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.106] - relayed: [n=1] TRUE
[17:01:01.106] - queued futures: [n=1] TRUE
[17:01:01.106] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.106] resolve() on list ... DONE
[17:01:01.106]  - Number of value chunks collected: 1
[17:01:01.107] Resolving 1 futures (chunks) ... DONE
[17:01:01.107] Reducing values from 1 chunks ...
[17:01:01.107]  - Number of values collected after concatenation: 2
[17:01:01.107]  - Number of values expected: 2
[17:01:01.107] Reducing values from 1 chunks ... DONE
[17:01:01.107] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:01:01.108] future_lapply() ...
[17:01:01.110] Number of chunks: 1
[17:01:01.111] getGlobalsAndPackagesXApply() ...
[17:01:01.111]  - future.globals: TRUE
[17:01:01.111] getGlobalsAndPackages() ...
[17:01:01.111] Searching for globals...
[17:01:01.116] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:01:01.117] Searching for globals ... DONE
[17:01:01.117] Resolving globals: FALSE
[17:01:01.117] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:01:01.118] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.118] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.118] - packages: [1] ‘future.apply’
[17:01:01.118] getGlobalsAndPackages() ... DONE
[17:01:01.118]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.118]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.119] Finding globals ... DONE
[17:01:01.119]  - use_args: TRUE
[17:01:01.119]  - Getting '...' globals ...
[17:01:01.119] resolve() on list ...
[17:01:01.119]  recursive: 0
[17:01:01.119]  length: 1
[17:01:01.119]  elements: ‘...’
[17:01:01.119]  length: 0 (resolved future 1)
[17:01:01.120] resolve() on list ... DONE
[17:01:01.120]    - '...' content: [n=0] 
[17:01:01.120] List of 1
[17:01:01.120]  $ ...: list()
[17:01:01.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.120]  - attr(*, "where")=List of 1
[17:01:01.120]   ..$ ...:<environment: 0x55aadb6f9768> 
[17:01:01.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.120]  - attr(*, "resolved")= logi TRUE
[17:01:01.120]  - attr(*, "total_size")= num NA
[17:01:01.122]  - Getting '...' globals ... DONE
[17:01:01.122] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.122] List of 8
[17:01:01.122]  $ ...future.FUN:function (x, ...)  
[17:01:01.122]  $ x_FUN        :function (x)  
[17:01:01.122]  $ times        : int 0
[17:01:01.122]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.122]  $ stop_if_not  :function (...)  
[17:01:01.122]  $ dim          : NULL
[17:01:01.122]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.122]  $ ...          : list()
[17:01:01.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.122]  - attr(*, "where")=List of 8
[17:01:01.122]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.122]   ..$ ...          :<environment: 0x55aadb6f9768> 
[17:01:01.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.122]  - attr(*, "resolved")= logi FALSE
[17:01:01.122]  - attr(*, "total_size")= num 95472
[17:01:01.128] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.128] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.128] Number of futures (= number of chunks): 1
[17:01:01.128] Launching 1 futures (chunks) ...
[17:01:01.128] Chunk #1 of 1 ...
[17:01:01.128]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.128] getGlobalsAndPackages() ...
[17:01:01.128] Searching for globals...
[17:01:01.129] 
[17:01:01.129] Searching for globals ... DONE
[17:01:01.129] - globals: [0] <none>
[17:01:01.129] getGlobalsAndPackages() ... DONE
[17:01:01.129]    + additional globals found: [n=0] 
[17:01:01.129]    + additional namespaces needed: [n=0] 
[17:01:01.129]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.129]  - seeds: <none>
[17:01:01.129]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.130] getGlobalsAndPackages() ...
[17:01:01.130] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.130] Resolving globals: FALSE
[17:01:01.130] Tweak future expression to call with '...' arguments ...
[17:01:01.130] {
[17:01:01.130]     do.call(function(...) {
[17:01:01.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.130]             on.exit(options(oopts), add = TRUE)
[17:01:01.130]         }
[17:01:01.130]         {
[17:01:01.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.130]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.130]             })
[17:01:01.130]         }
[17:01:01.130]     }, args = future.call.arguments)
[17:01:01.130] }
[17:01:01.130] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.131] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.131] - packages: [1] ‘future.apply’
[17:01:01.131] getGlobalsAndPackages() ... DONE
[17:01:01.131] run() for ‘Future’ ...
[17:01:01.131] - state: ‘created’
[17:01:01.131] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.132]   - Field: ‘label’
[17:01:01.132]   - Field: ‘local’
[17:01:01.132]   - Field: ‘owner’
[17:01:01.132]   - Field: ‘envir’
[17:01:01.132]   - Field: ‘packages’
[17:01:01.133]   - Field: ‘gc’
[17:01:01.133]   - Field: ‘conditions’
[17:01:01.133]   - Field: ‘expr’
[17:01:01.133]   - Field: ‘uuid’
[17:01:01.133]   - Field: ‘seed’
[17:01:01.133]   - Field: ‘version’
[17:01:01.133]   - Field: ‘result’
[17:01:01.133]   - Field: ‘asynchronous’
[17:01:01.133]   - Field: ‘calls’
[17:01:01.133]   - Field: ‘globals’
[17:01:01.133]   - Field: ‘stdout’
[17:01:01.134]   - Field: ‘earlySignal’
[17:01:01.134]   - Field: ‘lazy’
[17:01:01.134]   - Field: ‘state’
[17:01:01.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.134] - Launch lazy future ...
[17:01:01.134] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.134] Packages needed by future strategies (n = 0): <none>
[17:01:01.135] {
[17:01:01.135]     {
[17:01:01.135]         {
[17:01:01.135]             ...future.startTime <- base::Sys.time()
[17:01:01.135]             {
[17:01:01.135]                 {
[17:01:01.135]                   {
[17:01:01.135]                     {
[17:01:01.135]                       base::local({
[17:01:01.135]                         has_future <- base::requireNamespace("future", 
[17:01:01.135]                           quietly = TRUE)
[17:01:01.135]                         if (has_future) {
[17:01:01.135]                           ns <- base::getNamespace("future")
[17:01:01.135]                           version <- ns[[".package"]][["version"]]
[17:01:01.135]                           if (is.null(version)) 
[17:01:01.135]                             version <- utils::packageVersion("future")
[17:01:01.135]                         }
[17:01:01.135]                         else {
[17:01:01.135]                           version <- NULL
[17:01:01.135]                         }
[17:01:01.135]                         if (!has_future || version < "1.8.0") {
[17:01:01.135]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.135]                             "", base::R.version$version.string), 
[17:01:01.135]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.135]                               "release", "version")], collapse = " "), 
[17:01:01.135]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.135]                             info)
[17:01:01.135]                           info <- base::paste(info, collapse = "; ")
[17:01:01.135]                           if (!has_future) {
[17:01:01.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.135]                               info)
[17:01:01.135]                           }
[17:01:01.135]                           else {
[17:01:01.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.135]                               info, version)
[17:01:01.135]                           }
[17:01:01.135]                           base::stop(msg)
[17:01:01.135]                         }
[17:01:01.135]                       })
[17:01:01.135]                     }
[17:01:01.135]                     base::local({
[17:01:01.135]                       for (pkg in "future.apply") {
[17:01:01.135]                         base::loadNamespace(pkg)
[17:01:01.135]                         base::library(pkg, character.only = TRUE)
[17:01:01.135]                       }
[17:01:01.135]                     })
[17:01:01.135]                   }
[17:01:01.135]                   ...future.strategy.old <- future::plan("list")
[17:01:01.135]                   options(future.plan = NULL)
[17:01:01.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.135]                 }
[17:01:01.135]                 ...future.workdir <- getwd()
[17:01:01.135]             }
[17:01:01.135]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.135]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.135]         }
[17:01:01.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.135]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.135]             base::names(...future.oldOptions))
[17:01:01.135]     }
[17:01:01.135]     if (FALSE) {
[17:01:01.135]     }
[17:01:01.135]     else {
[17:01:01.135]         if (TRUE) {
[17:01:01.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.135]                 open = "w")
[17:01:01.135]         }
[17:01:01.135]         else {
[17:01:01.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.135]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.135]         }
[17:01:01.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.135]             base::sink(type = "output", split = FALSE)
[17:01:01.135]             base::close(...future.stdout)
[17:01:01.135]         }, add = TRUE)
[17:01:01.135]     }
[17:01:01.135]     ...future.frame <- base::sys.nframe()
[17:01:01.135]     ...future.conditions <- base::list()
[17:01:01.135]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.135]     if (FALSE) {
[17:01:01.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.135]     }
[17:01:01.135]     ...future.result <- base::tryCatch({
[17:01:01.135]         base::withCallingHandlers({
[17:01:01.135]             ...future.value <- base::withVisible(base::local({
[17:01:01.135]                 do.call(function(...) {
[17:01:01.135]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.135]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.135]                     ...future.globals.maxSize)) {
[17:01:01.135]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.135]                     on.exit(options(oopts), add = TRUE)
[17:01:01.135]                   }
[17:01:01.135]                   {
[17:01:01.135]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.135]                       FUN = function(jj) {
[17:01:01.135]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.135]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.135]                       })
[17:01:01.135]                   }
[17:01:01.135]                 }, args = future.call.arguments)
[17:01:01.135]             }))
[17:01:01.135]             future::FutureResult(value = ...future.value$value, 
[17:01:01.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.135]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.135]                     ...future.globalenv.names))
[17:01:01.135]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.135]         }, condition = base::local({
[17:01:01.135]             c <- base::c
[17:01:01.135]             inherits <- base::inherits
[17:01:01.135]             invokeRestart <- base::invokeRestart
[17:01:01.135]             length <- base::length
[17:01:01.135]             list <- base::list
[17:01:01.135]             seq.int <- base::seq.int
[17:01:01.135]             signalCondition <- base::signalCondition
[17:01:01.135]             sys.calls <- base::sys.calls
[17:01:01.135]             `[[` <- base::`[[`
[17:01:01.135]             `+` <- base::`+`
[17:01:01.135]             `<<-` <- base::`<<-`
[17:01:01.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.135]                   3L)]
[17:01:01.135]             }
[17:01:01.135]             function(cond) {
[17:01:01.135]                 is_error <- inherits(cond, "error")
[17:01:01.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.135]                   NULL)
[17:01:01.135]                 if (is_error) {
[17:01:01.135]                   sessionInformation <- function() {
[17:01:01.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.135]                       search = base::search(), system = base::Sys.info())
[17:01:01.135]                   }
[17:01:01.135]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.135]                     cond$call), session = sessionInformation(), 
[17:01:01.135]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.135]                   signalCondition(cond)
[17:01:01.135]                 }
[17:01:01.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.135]                 "immediateCondition"))) {
[17:01:01.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.135]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.135]                   if (TRUE && !signal) {
[17:01:01.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.135]                     {
[17:01:01.135]                       inherits <- base::inherits
[17:01:01.135]                       invokeRestart <- base::invokeRestart
[17:01:01.135]                       is.null <- base::is.null
[17:01:01.135]                       muffled <- FALSE
[17:01:01.135]                       if (inherits(cond, "message")) {
[17:01:01.135]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.135]                         if (muffled) 
[17:01:01.135]                           invokeRestart("muffleMessage")
[17:01:01.135]                       }
[17:01:01.135]                       else if (inherits(cond, "warning")) {
[17:01:01.135]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.135]                         if (muffled) 
[17:01:01.135]                           invokeRestart("muffleWarning")
[17:01:01.135]                       }
[17:01:01.135]                       else if (inherits(cond, "condition")) {
[17:01:01.135]                         if (!is.null(pattern)) {
[17:01:01.135]                           computeRestarts <- base::computeRestarts
[17:01:01.135]                           grepl <- base::grepl
[17:01:01.135]                           restarts <- computeRestarts(cond)
[17:01:01.135]                           for (restart in restarts) {
[17:01:01.135]                             name <- restart$name
[17:01:01.135]                             if (is.null(name)) 
[17:01:01.135]                               next
[17:01:01.135]                             if (!grepl(pattern, name)) 
[17:01:01.135]                               next
[17:01:01.135]                             invokeRestart(restart)
[17:01:01.135]                             muffled <- TRUE
[17:01:01.135]                             break
[17:01:01.135]                           }
[17:01:01.135]                         }
[17:01:01.135]                       }
[17:01:01.135]                       invisible(muffled)
[17:01:01.135]                     }
[17:01:01.135]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.135]                   }
[17:01:01.135]                 }
[17:01:01.135]                 else {
[17:01:01.135]                   if (TRUE) {
[17:01:01.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.135]                     {
[17:01:01.135]                       inherits <- base::inherits
[17:01:01.135]                       invokeRestart <- base::invokeRestart
[17:01:01.135]                       is.null <- base::is.null
[17:01:01.135]                       muffled <- FALSE
[17:01:01.135]                       if (inherits(cond, "message")) {
[17:01:01.135]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.135]                         if (muffled) 
[17:01:01.135]                           invokeRestart("muffleMessage")
[17:01:01.135]                       }
[17:01:01.135]                       else if (inherits(cond, "warning")) {
[17:01:01.135]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.135]                         if (muffled) 
[17:01:01.135]                           invokeRestart("muffleWarning")
[17:01:01.135]                       }
[17:01:01.135]                       else if (inherits(cond, "condition")) {
[17:01:01.135]                         if (!is.null(pattern)) {
[17:01:01.135]                           computeRestarts <- base::computeRestarts
[17:01:01.135]                           grepl <- base::grepl
[17:01:01.135]                           restarts <- computeRestarts(cond)
[17:01:01.135]                           for (restart in restarts) {
[17:01:01.135]                             name <- restart$name
[17:01:01.135]                             if (is.null(name)) 
[17:01:01.135]                               next
[17:01:01.135]                             if (!grepl(pattern, name)) 
[17:01:01.135]                               next
[17:01:01.135]                             invokeRestart(restart)
[17:01:01.135]                             muffled <- TRUE
[17:01:01.135]                             break
[17:01:01.135]                           }
[17:01:01.135]                         }
[17:01:01.135]                       }
[17:01:01.135]                       invisible(muffled)
[17:01:01.135]                     }
[17:01:01.135]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.135]                   }
[17:01:01.135]                 }
[17:01:01.135]             }
[17:01:01.135]         }))
[17:01:01.135]     }, error = function(ex) {
[17:01:01.135]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.135]                 ...future.rng), started = ...future.startTime, 
[17:01:01.135]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.135]             version = "1.8"), class = "FutureResult")
[17:01:01.135]     }, finally = {
[17:01:01.135]         if (!identical(...future.workdir, getwd())) 
[17:01:01.135]             setwd(...future.workdir)
[17:01:01.135]         {
[17:01:01.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.135]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.135]             }
[17:01:01.135]             base::options(...future.oldOptions)
[17:01:01.135]             if (.Platform$OS.type == "windows") {
[17:01:01.135]                 old_names <- names(...future.oldEnvVars)
[17:01:01.135]                 envs <- base::Sys.getenv()
[17:01:01.135]                 names <- names(envs)
[17:01:01.135]                 common <- intersect(names, old_names)
[17:01:01.135]                 added <- setdiff(names, old_names)
[17:01:01.135]                 removed <- setdiff(old_names, names)
[17:01:01.135]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.135]                   envs[common]]
[17:01:01.135]                 NAMES <- toupper(changed)
[17:01:01.135]                 args <- list()
[17:01:01.135]                 for (kk in seq_along(NAMES)) {
[17:01:01.135]                   name <- changed[[kk]]
[17:01:01.135]                   NAME <- NAMES[[kk]]
[17:01:01.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.135]                     next
[17:01:01.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.135]                 }
[17:01:01.135]                 NAMES <- toupper(added)
[17:01:01.135]                 for (kk in seq_along(NAMES)) {
[17:01:01.135]                   name <- added[[kk]]
[17:01:01.135]                   NAME <- NAMES[[kk]]
[17:01:01.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.135]                     next
[17:01:01.135]                   args[[name]] <- ""
[17:01:01.135]                 }
[17:01:01.135]                 NAMES <- toupper(removed)
[17:01:01.135]                 for (kk in seq_along(NAMES)) {
[17:01:01.135]                   name <- removed[[kk]]
[17:01:01.135]                   NAME <- NAMES[[kk]]
[17:01:01.135]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.135]                     next
[17:01:01.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.135]                 }
[17:01:01.135]                 if (length(args) > 0) 
[17:01:01.135]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.135]             }
[17:01:01.135]             else {
[17:01:01.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.135]             }
[17:01:01.135]             {
[17:01:01.135]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.135]                   0L) {
[17:01:01.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.135]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.135]                   base::options(opts)
[17:01:01.135]                 }
[17:01:01.135]                 {
[17:01:01.135]                   {
[17:01:01.135]                     NULL
[17:01:01.135]                     RNGkind("Mersenne-Twister")
[17:01:01.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.135]                       inherits = FALSE)
[17:01:01.135]                   }
[17:01:01.135]                   options(future.plan = NULL)
[17:01:01.135]                   if (is.na(NA_character_)) 
[17:01:01.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.135]                     .init = FALSE)
[17:01:01.135]                 }
[17:01:01.135]             }
[17:01:01.135]         }
[17:01:01.135]     })
[17:01:01.135]     if (TRUE) {
[17:01:01.135]         base::sink(type = "output", split = FALSE)
[17:01:01.135]         if (TRUE) {
[17:01:01.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.135]         }
[17:01:01.135]         else {
[17:01:01.135]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.135]         }
[17:01:01.135]         base::close(...future.stdout)
[17:01:01.135]         ...future.stdout <- NULL
[17:01:01.135]     }
[17:01:01.135]     ...future.result$conditions <- ...future.conditions
[17:01:01.135]     ...future.result$finished <- base::Sys.time()
[17:01:01.135]     ...future.result
[17:01:01.135] }
[17:01:01.136] assign_globals() ...
[17:01:01.137] List of 11
[17:01:01.137]  $ ...future.FUN            :function (x, ...)  
[17:01:01.137]  $ x_FUN                    :function (x)  
[17:01:01.137]  $ times                    : int 0
[17:01:01.137]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.137]  $ stop_if_not              :function (...)  
[17:01:01.137]  $ dim                      : NULL
[17:01:01.137]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.137]  $ future.call.arguments    : list()
[17:01:01.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.137]  $ ...future.elements_ii    :List of 10
[17:01:01.137]   ..$ : int 1
[17:01:01.137]   ..$ : int 2
[17:01:01.137]   ..$ : int 3
[17:01:01.137]   ..$ : int 4
[17:01:01.137]   ..$ : int 5
[17:01:01.137]   ..$ : int 6
[17:01:01.137]   ..$ : int 7
[17:01:01.137]   ..$ : int 8
[17:01:01.137]   ..$ : int 9
[17:01:01.137]   ..$ : int 10
[17:01:01.137]  $ ...future.seeds_ii       : NULL
[17:01:01.137]  $ ...future.globals.maxSize: NULL
[17:01:01.137]  - attr(*, "where")=List of 11
[17:01:01.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.137]  - attr(*, "resolved")= logi FALSE
[17:01:01.137]  - attr(*, "total_size")= num 95472
[17:01:01.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.137]  - attr(*, "already-done")= logi TRUE
[17:01:01.148] - copied ‘...future.FUN’ to environment
[17:01:01.148] - reassign environment for ‘x_FUN’
[17:01:01.148] - copied ‘x_FUN’ to environment
[17:01:01.148] - copied ‘times’ to environment
[17:01:01.148] - copied ‘stopf’ to environment
[17:01:01.148] - copied ‘stop_if_not’ to environment
[17:01:01.148] - copied ‘dim’ to environment
[17:01:01.148] - copied ‘valid_types’ to environment
[17:01:01.149] - copied ‘future.call.arguments’ to environment
[17:01:01.149] - copied ‘...future.elements_ii’ to environment
[17:01:01.149] - copied ‘...future.seeds_ii’ to environment
[17:01:01.149] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.149] assign_globals() ... done
[17:01:01.149] plan(): Setting new future strategy stack:
[17:01:01.149] List of future strategies:
[17:01:01.149] 1. sequential:
[17:01:01.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.149]    - tweaked: FALSE
[17:01:01.149]    - call: NULL
[17:01:01.150] plan(): nbrOfWorkers() = 1
[17:01:01.151] plan(): Setting new future strategy stack:
[17:01:01.151] List of future strategies:
[17:01:01.151] 1. sequential:
[17:01:01.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.151]    - tweaked: FALSE
[17:01:01.151]    - call: plan(strategy)
[17:01:01.151] plan(): nbrOfWorkers() = 1
[17:01:01.151] SequentialFuture started (and completed)
[17:01:01.151] - Launch lazy future ... done
[17:01:01.152] run() for ‘SequentialFuture’ ... done
[17:01:01.152] Created future:
[17:01:01.152] SequentialFuture:
[17:01:01.152] Label: ‘future_vapply-1’
[17:01:01.152] Expression:
[17:01:01.152] {
[17:01:01.152]     do.call(function(...) {
[17:01:01.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.152]             on.exit(options(oopts), add = TRUE)
[17:01:01.152]         }
[17:01:01.152]         {
[17:01:01.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.152]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.152]             })
[17:01:01.152]         }
[17:01:01.152]     }, args = future.call.arguments)
[17:01:01.152] }
[17:01:01.152] Lazy evaluation: FALSE
[17:01:01.152] Asynchronous evaluation: FALSE
[17:01:01.152] Local evaluation: TRUE
[17:01:01.152] Environment: R_GlobalEnv
[17:01:01.152] Capture standard output: TRUE
[17:01:01.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.152] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.152] Packages: 1 packages (‘future.apply’)
[17:01:01.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.152] Resolved: TRUE
[17:01:01.152] Value: 480 bytes of class ‘list’
[17:01:01.152] Early signaling: FALSE
[17:01:01.152] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.152] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.153] Chunk #1 of 1 ... DONE
[17:01:01.153] Launching 1 futures (chunks) ... DONE
[17:01:01.153] Resolving 1 futures (chunks) ...
[17:01:01.153] resolve() on list ...
[17:01:01.153]  recursive: 0
[17:01:01.153]  length: 1
[17:01:01.154] 
[17:01:01.154] resolved() for ‘SequentialFuture’ ...
[17:01:01.154] - state: ‘finished’
[17:01:01.154] - run: TRUE
[17:01:01.154] - result: ‘FutureResult’
[17:01:01.154] resolved() for ‘SequentialFuture’ ... done
[17:01:01.154] Future #1
[17:01:01.154] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.154] - nx: 1
[17:01:01.154] - relay: TRUE
[17:01:01.155] - stdout: TRUE
[17:01:01.155] - signal: TRUE
[17:01:01.155] - resignal: FALSE
[17:01:01.155] - force: TRUE
[17:01:01.155] - relayed: [n=1] FALSE
[17:01:01.155] - queued futures: [n=1] FALSE
[17:01:01.155]  - until=1
[17:01:01.155]  - relaying element #1
[17:01:01.155] - relayed: [n=1] TRUE
[17:01:01.155] - queued futures: [n=1] TRUE
[17:01:01.156] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.156]  length: 0 (resolved future 1)
[17:01:01.156] Relaying remaining futures
[17:01:01.156] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.156] - nx: 1
[17:01:01.156] - relay: TRUE
[17:01:01.156] - stdout: TRUE
[17:01:01.156] - signal: TRUE
[17:01:01.156] - resignal: FALSE
[17:01:01.156] - force: TRUE
[17:01:01.156] - relayed: [n=1] TRUE
[17:01:01.157] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.157] - relayed: [n=1] TRUE
[17:01:01.157] - queued futures: [n=1] TRUE
[17:01:01.157] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.157] resolve() on list ... DONE
[17:01:01.157]  - Number of value chunks collected: 1
[17:01:01.157] Resolving 1 futures (chunks) ... DONE
[17:01:01.157] Reducing values from 1 chunks ...
[17:01:01.157]  - Number of values collected after concatenation: 10
[17:01:01.157]  - Number of values expected: 10
[17:01:01.158] Reducing values from 1 chunks ... DONE
[17:01:01.158] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:01:01.159] future_lapply() ...
[17:01:01.160] Number of chunks: 1
[17:01:01.160] getGlobalsAndPackagesXApply() ...
[17:01:01.160]  - future.globals: TRUE
[17:01:01.161] getGlobalsAndPackages() ...
[17:01:01.161] Searching for globals...
[17:01:01.166] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:01:01.166] Searching for globals ... DONE
[17:01:01.166] Resolving globals: FALSE
[17:01:01.167] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:01:01.167] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.167] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.167] - packages: [1] ‘future.apply’
[17:01:01.167] getGlobalsAndPackages() ... DONE
[17:01:01.168]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.168]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.168] Finding globals ... DONE
[17:01:01.168]  - use_args: TRUE
[17:01:01.168]  - Getting '...' globals ...
[17:01:01.168] resolve() on list ...
[17:01:01.168]  recursive: 0
[17:01:01.168]  length: 1
[17:01:01.168]  elements: ‘...’
[17:01:01.169]  length: 0 (resolved future 1)
[17:01:01.169] resolve() on list ... DONE
[17:01:01.169]    - '...' content: [n=0] 
[17:01:01.169] List of 1
[17:01:01.169]  $ ...: list()
[17:01:01.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.169]  - attr(*, "where")=List of 1
[17:01:01.169]   ..$ ...:<environment: 0x55aadb6f2e70> 
[17:01:01.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.169]  - attr(*, "resolved")= logi TRUE
[17:01:01.169]  - attr(*, "total_size")= num NA
[17:01:01.171]  - Getting '...' globals ... DONE
[17:01:01.171] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.172] List of 8
[17:01:01.172]  $ ...future.FUN:function (x, ...)  
[17:01:01.172]  $ x_FUN        :function (x)  
[17:01:01.172]  $ times        : int 0
[17:01:01.172]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.172]  $ stop_if_not  :function (...)  
[17:01:01.172]  $ dim          : NULL
[17:01:01.172]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:01.172]  $ ...          : list()
[17:01:01.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.172]  - attr(*, "where")=List of 8
[17:01:01.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.172]   ..$ ...          :<environment: 0x55aadb6f2e70> 
[17:01:01.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.172]  - attr(*, "resolved")= logi FALSE
[17:01:01.172]  - attr(*, "total_size")= num 95400
[17:01:01.177] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.177] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.177] Number of futures (= number of chunks): 1
[17:01:01.177] Launching 1 futures (chunks) ...
[17:01:01.177] Chunk #1 of 1 ...
[17:01:01.177]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.177] getGlobalsAndPackages() ...
[17:01:01.178] Searching for globals...
[17:01:01.178] 
[17:01:01.178] Searching for globals ... DONE
[17:01:01.178] - globals: [0] <none>
[17:01:01.178] getGlobalsAndPackages() ... DONE
[17:01:01.178]    + additional globals found: [n=0] 
[17:01:01.178]    + additional namespaces needed: [n=0] 
[17:01:01.178]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.178]  - seeds: <none>
[17:01:01.178]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.179] getGlobalsAndPackages() ...
[17:01:01.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.179] Resolving globals: FALSE
[17:01:01.179] Tweak future expression to call with '...' arguments ...
[17:01:01.179] {
[17:01:01.179]     do.call(function(...) {
[17:01:01.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.179]             on.exit(options(oopts), add = TRUE)
[17:01:01.179]         }
[17:01:01.179]         {
[17:01:01.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.179]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.179]             })
[17:01:01.179]         }
[17:01:01.179]     }, args = future.call.arguments)
[17:01:01.179] }
[17:01:01.179] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.180] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.180] - packages: [1] ‘future.apply’
[17:01:01.180] getGlobalsAndPackages() ... DONE
[17:01:01.180] run() for ‘Future’ ...
[17:01:01.180] - state: ‘created’
[17:01:01.181] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.181] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.181]   - Field: ‘label’
[17:01:01.181]   - Field: ‘local’
[17:01:01.181]   - Field: ‘owner’
[17:01:01.181]   - Field: ‘envir’
[17:01:01.181]   - Field: ‘packages’
[17:01:01.181]   - Field: ‘gc’
[17:01:01.182]   - Field: ‘conditions’
[17:01:01.182]   - Field: ‘expr’
[17:01:01.182]   - Field: ‘uuid’
[17:01:01.182]   - Field: ‘seed’
[17:01:01.182]   - Field: ‘version’
[17:01:01.182]   - Field: ‘result’
[17:01:01.182]   - Field: ‘asynchronous’
[17:01:01.182]   - Field: ‘calls’
[17:01:01.182]   - Field: ‘globals’
[17:01:01.182]   - Field: ‘stdout’
[17:01:01.182]   - Field: ‘earlySignal’
[17:01:01.183]   - Field: ‘lazy’
[17:01:01.183]   - Field: ‘state’
[17:01:01.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.183] - Launch lazy future ...
[17:01:01.183] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.183] Packages needed by future strategies (n = 0): <none>
[17:01:01.184] {
[17:01:01.184]     {
[17:01:01.184]         {
[17:01:01.184]             ...future.startTime <- base::Sys.time()
[17:01:01.184]             {
[17:01:01.184]                 {
[17:01:01.184]                   {
[17:01:01.184]                     {
[17:01:01.184]                       base::local({
[17:01:01.184]                         has_future <- base::requireNamespace("future", 
[17:01:01.184]                           quietly = TRUE)
[17:01:01.184]                         if (has_future) {
[17:01:01.184]                           ns <- base::getNamespace("future")
[17:01:01.184]                           version <- ns[[".package"]][["version"]]
[17:01:01.184]                           if (is.null(version)) 
[17:01:01.184]                             version <- utils::packageVersion("future")
[17:01:01.184]                         }
[17:01:01.184]                         else {
[17:01:01.184]                           version <- NULL
[17:01:01.184]                         }
[17:01:01.184]                         if (!has_future || version < "1.8.0") {
[17:01:01.184]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.184]                             "", base::R.version$version.string), 
[17:01:01.184]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.184]                               "release", "version")], collapse = " "), 
[17:01:01.184]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.184]                             info)
[17:01:01.184]                           info <- base::paste(info, collapse = "; ")
[17:01:01.184]                           if (!has_future) {
[17:01:01.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.184]                               info)
[17:01:01.184]                           }
[17:01:01.184]                           else {
[17:01:01.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.184]                               info, version)
[17:01:01.184]                           }
[17:01:01.184]                           base::stop(msg)
[17:01:01.184]                         }
[17:01:01.184]                       })
[17:01:01.184]                     }
[17:01:01.184]                     base::local({
[17:01:01.184]                       for (pkg in "future.apply") {
[17:01:01.184]                         base::loadNamespace(pkg)
[17:01:01.184]                         base::library(pkg, character.only = TRUE)
[17:01:01.184]                       }
[17:01:01.184]                     })
[17:01:01.184]                   }
[17:01:01.184]                   ...future.strategy.old <- future::plan("list")
[17:01:01.184]                   options(future.plan = NULL)
[17:01:01.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.184]                 }
[17:01:01.184]                 ...future.workdir <- getwd()
[17:01:01.184]             }
[17:01:01.184]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.184]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.184]         }
[17:01:01.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.184]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.184]             base::names(...future.oldOptions))
[17:01:01.184]     }
[17:01:01.184]     if (FALSE) {
[17:01:01.184]     }
[17:01:01.184]     else {
[17:01:01.184]         if (TRUE) {
[17:01:01.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.184]                 open = "w")
[17:01:01.184]         }
[17:01:01.184]         else {
[17:01:01.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.184]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.184]         }
[17:01:01.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.184]             base::sink(type = "output", split = FALSE)
[17:01:01.184]             base::close(...future.stdout)
[17:01:01.184]         }, add = TRUE)
[17:01:01.184]     }
[17:01:01.184]     ...future.frame <- base::sys.nframe()
[17:01:01.184]     ...future.conditions <- base::list()
[17:01:01.184]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.184]     if (FALSE) {
[17:01:01.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.184]     }
[17:01:01.184]     ...future.result <- base::tryCatch({
[17:01:01.184]         base::withCallingHandlers({
[17:01:01.184]             ...future.value <- base::withVisible(base::local({
[17:01:01.184]                 do.call(function(...) {
[17:01:01.184]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.184]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.184]                     ...future.globals.maxSize)) {
[17:01:01.184]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.184]                     on.exit(options(oopts), add = TRUE)
[17:01:01.184]                   }
[17:01:01.184]                   {
[17:01:01.184]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.184]                       FUN = function(jj) {
[17:01:01.184]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.184]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.184]                       })
[17:01:01.184]                   }
[17:01:01.184]                 }, args = future.call.arguments)
[17:01:01.184]             }))
[17:01:01.184]             future::FutureResult(value = ...future.value$value, 
[17:01:01.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.184]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.184]                     ...future.globalenv.names))
[17:01:01.184]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.184]         }, condition = base::local({
[17:01:01.184]             c <- base::c
[17:01:01.184]             inherits <- base::inherits
[17:01:01.184]             invokeRestart <- base::invokeRestart
[17:01:01.184]             length <- base::length
[17:01:01.184]             list <- base::list
[17:01:01.184]             seq.int <- base::seq.int
[17:01:01.184]             signalCondition <- base::signalCondition
[17:01:01.184]             sys.calls <- base::sys.calls
[17:01:01.184]             `[[` <- base::`[[`
[17:01:01.184]             `+` <- base::`+`
[17:01:01.184]             `<<-` <- base::`<<-`
[17:01:01.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.184]                   3L)]
[17:01:01.184]             }
[17:01:01.184]             function(cond) {
[17:01:01.184]                 is_error <- inherits(cond, "error")
[17:01:01.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.184]                   NULL)
[17:01:01.184]                 if (is_error) {
[17:01:01.184]                   sessionInformation <- function() {
[17:01:01.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.184]                       search = base::search(), system = base::Sys.info())
[17:01:01.184]                   }
[17:01:01.184]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.184]                     cond$call), session = sessionInformation(), 
[17:01:01.184]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.184]                   signalCondition(cond)
[17:01:01.184]                 }
[17:01:01.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.184]                 "immediateCondition"))) {
[17:01:01.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.184]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.184]                   if (TRUE && !signal) {
[17:01:01.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.184]                     {
[17:01:01.184]                       inherits <- base::inherits
[17:01:01.184]                       invokeRestart <- base::invokeRestart
[17:01:01.184]                       is.null <- base::is.null
[17:01:01.184]                       muffled <- FALSE
[17:01:01.184]                       if (inherits(cond, "message")) {
[17:01:01.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.184]                         if (muffled) 
[17:01:01.184]                           invokeRestart("muffleMessage")
[17:01:01.184]                       }
[17:01:01.184]                       else if (inherits(cond, "warning")) {
[17:01:01.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.184]                         if (muffled) 
[17:01:01.184]                           invokeRestart("muffleWarning")
[17:01:01.184]                       }
[17:01:01.184]                       else if (inherits(cond, "condition")) {
[17:01:01.184]                         if (!is.null(pattern)) {
[17:01:01.184]                           computeRestarts <- base::computeRestarts
[17:01:01.184]                           grepl <- base::grepl
[17:01:01.184]                           restarts <- computeRestarts(cond)
[17:01:01.184]                           for (restart in restarts) {
[17:01:01.184]                             name <- restart$name
[17:01:01.184]                             if (is.null(name)) 
[17:01:01.184]                               next
[17:01:01.184]                             if (!grepl(pattern, name)) 
[17:01:01.184]                               next
[17:01:01.184]                             invokeRestart(restart)
[17:01:01.184]                             muffled <- TRUE
[17:01:01.184]                             break
[17:01:01.184]                           }
[17:01:01.184]                         }
[17:01:01.184]                       }
[17:01:01.184]                       invisible(muffled)
[17:01:01.184]                     }
[17:01:01.184]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.184]                   }
[17:01:01.184]                 }
[17:01:01.184]                 else {
[17:01:01.184]                   if (TRUE) {
[17:01:01.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.184]                     {
[17:01:01.184]                       inherits <- base::inherits
[17:01:01.184]                       invokeRestart <- base::invokeRestart
[17:01:01.184]                       is.null <- base::is.null
[17:01:01.184]                       muffled <- FALSE
[17:01:01.184]                       if (inherits(cond, "message")) {
[17:01:01.184]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.184]                         if (muffled) 
[17:01:01.184]                           invokeRestart("muffleMessage")
[17:01:01.184]                       }
[17:01:01.184]                       else if (inherits(cond, "warning")) {
[17:01:01.184]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.184]                         if (muffled) 
[17:01:01.184]                           invokeRestart("muffleWarning")
[17:01:01.184]                       }
[17:01:01.184]                       else if (inherits(cond, "condition")) {
[17:01:01.184]                         if (!is.null(pattern)) {
[17:01:01.184]                           computeRestarts <- base::computeRestarts
[17:01:01.184]                           grepl <- base::grepl
[17:01:01.184]                           restarts <- computeRestarts(cond)
[17:01:01.184]                           for (restart in restarts) {
[17:01:01.184]                             name <- restart$name
[17:01:01.184]                             if (is.null(name)) 
[17:01:01.184]                               next
[17:01:01.184]                             if (!grepl(pattern, name)) 
[17:01:01.184]                               next
[17:01:01.184]                             invokeRestart(restart)
[17:01:01.184]                             muffled <- TRUE
[17:01:01.184]                             break
[17:01:01.184]                           }
[17:01:01.184]                         }
[17:01:01.184]                       }
[17:01:01.184]                       invisible(muffled)
[17:01:01.184]                     }
[17:01:01.184]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.184]                   }
[17:01:01.184]                 }
[17:01:01.184]             }
[17:01:01.184]         }))
[17:01:01.184]     }, error = function(ex) {
[17:01:01.184]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.184]                 ...future.rng), started = ...future.startTime, 
[17:01:01.184]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.184]             version = "1.8"), class = "FutureResult")
[17:01:01.184]     }, finally = {
[17:01:01.184]         if (!identical(...future.workdir, getwd())) 
[17:01:01.184]             setwd(...future.workdir)
[17:01:01.184]         {
[17:01:01.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.184]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.184]             }
[17:01:01.184]             base::options(...future.oldOptions)
[17:01:01.184]             if (.Platform$OS.type == "windows") {
[17:01:01.184]                 old_names <- names(...future.oldEnvVars)
[17:01:01.184]                 envs <- base::Sys.getenv()
[17:01:01.184]                 names <- names(envs)
[17:01:01.184]                 common <- intersect(names, old_names)
[17:01:01.184]                 added <- setdiff(names, old_names)
[17:01:01.184]                 removed <- setdiff(old_names, names)
[17:01:01.184]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.184]                   envs[common]]
[17:01:01.184]                 NAMES <- toupper(changed)
[17:01:01.184]                 args <- list()
[17:01:01.184]                 for (kk in seq_along(NAMES)) {
[17:01:01.184]                   name <- changed[[kk]]
[17:01:01.184]                   NAME <- NAMES[[kk]]
[17:01:01.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.184]                     next
[17:01:01.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.184]                 }
[17:01:01.184]                 NAMES <- toupper(added)
[17:01:01.184]                 for (kk in seq_along(NAMES)) {
[17:01:01.184]                   name <- added[[kk]]
[17:01:01.184]                   NAME <- NAMES[[kk]]
[17:01:01.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.184]                     next
[17:01:01.184]                   args[[name]] <- ""
[17:01:01.184]                 }
[17:01:01.184]                 NAMES <- toupper(removed)
[17:01:01.184]                 for (kk in seq_along(NAMES)) {
[17:01:01.184]                   name <- removed[[kk]]
[17:01:01.184]                   NAME <- NAMES[[kk]]
[17:01:01.184]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.184]                     next
[17:01:01.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.184]                 }
[17:01:01.184]                 if (length(args) > 0) 
[17:01:01.184]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.184]             }
[17:01:01.184]             else {
[17:01:01.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.184]             }
[17:01:01.184]             {
[17:01:01.184]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.184]                   0L) {
[17:01:01.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.184]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.184]                   base::options(opts)
[17:01:01.184]                 }
[17:01:01.184]                 {
[17:01:01.184]                   {
[17:01:01.184]                     NULL
[17:01:01.184]                     RNGkind("Mersenne-Twister")
[17:01:01.184]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.184]                       inherits = FALSE)
[17:01:01.184]                   }
[17:01:01.184]                   options(future.plan = NULL)
[17:01:01.184]                   if (is.na(NA_character_)) 
[17:01:01.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.184]                     .init = FALSE)
[17:01:01.184]                 }
[17:01:01.184]             }
[17:01:01.184]         }
[17:01:01.184]     })
[17:01:01.184]     if (TRUE) {
[17:01:01.184]         base::sink(type = "output", split = FALSE)
[17:01:01.184]         if (TRUE) {
[17:01:01.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.184]         }
[17:01:01.184]         else {
[17:01:01.184]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.184]         }
[17:01:01.184]         base::close(...future.stdout)
[17:01:01.184]         ...future.stdout <- NULL
[17:01:01.184]     }
[17:01:01.184]     ...future.result$conditions <- ...future.conditions
[17:01:01.184]     ...future.result$finished <- base::Sys.time()
[17:01:01.184]     ...future.result
[17:01:01.184] }
[17:01:01.185] assign_globals() ...
[17:01:01.185] List of 11
[17:01:01.185]  $ ...future.FUN            :function (x, ...)  
[17:01:01.185]  $ x_FUN                    :function (x)  
[17:01:01.185]  $ times                    : int 0
[17:01:01.185]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.185]  $ stop_if_not              :function (...)  
[17:01:01.185]  $ dim                      : NULL
[17:01:01.185]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:01.185]  $ future.call.arguments    : list()
[17:01:01.185]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.185]  $ ...future.elements_ii    :List of 10
[17:01:01.185]   ..$ : int 1
[17:01:01.185]   ..$ : int 2
[17:01:01.185]   ..$ : int 3
[17:01:01.185]   ..$ : int 4
[17:01:01.185]   ..$ : int 5
[17:01:01.185]   ..$ : int 6
[17:01:01.185]   ..$ : int 7
[17:01:01.185]   ..$ : int 8
[17:01:01.185]   ..$ : int 9
[17:01:01.185]   ..$ : int 10
[17:01:01.185]  $ ...future.seeds_ii       : NULL
[17:01:01.185]  $ ...future.globals.maxSize: NULL
[17:01:01.185]  - attr(*, "where")=List of 11
[17:01:01.185]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.185]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.185]  - attr(*, "resolved")= logi FALSE
[17:01:01.185]  - attr(*, "total_size")= num 95400
[17:01:01.185]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.185]  - attr(*, "already-done")= logi TRUE
[17:01:01.197] - copied ‘...future.FUN’ to environment
[17:01:01.197] - reassign environment for ‘x_FUN’
[17:01:01.197] - copied ‘x_FUN’ to environment
[17:01:01.197] - copied ‘times’ to environment
[17:01:01.197] - copied ‘stopf’ to environment
[17:01:01.197] - copied ‘stop_if_not’ to environment
[17:01:01.197] - copied ‘dim’ to environment
[17:01:01.197] - copied ‘valid_types’ to environment
[17:01:01.197] - copied ‘future.call.arguments’ to environment
[17:01:01.197] - copied ‘...future.elements_ii’ to environment
[17:01:01.198] - copied ‘...future.seeds_ii’ to environment
[17:01:01.198] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.198] assign_globals() ... done
[17:01:01.198] plan(): Setting new future strategy stack:
[17:01:01.198] List of future strategies:
[17:01:01.198] 1. sequential:
[17:01:01.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.198]    - tweaked: FALSE
[17:01:01.198]    - call: NULL
[17:01:01.199] plan(): nbrOfWorkers() = 1
[17:01:01.200] plan(): Setting new future strategy stack:
[17:01:01.200] List of future strategies:
[17:01:01.200] 1. sequential:
[17:01:01.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.200]    - tweaked: FALSE
[17:01:01.200]    - call: plan(strategy)
[17:01:01.200] plan(): nbrOfWorkers() = 1
[17:01:01.200] SequentialFuture started (and completed)
[17:01:01.200] - Launch lazy future ... done
[17:01:01.200] run() for ‘SequentialFuture’ ... done
[17:01:01.201] Created future:
[17:01:01.201] SequentialFuture:
[17:01:01.201] Label: ‘future_vapply-1’
[17:01:01.201] Expression:
[17:01:01.201] {
[17:01:01.201]     do.call(function(...) {
[17:01:01.201]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.201]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.201]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.201]             on.exit(options(oopts), add = TRUE)
[17:01:01.201]         }
[17:01:01.201]         {
[17:01:01.201]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.201]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.201]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.201]             })
[17:01:01.201]         }
[17:01:01.201]     }, args = future.call.arguments)
[17:01:01.201] }
[17:01:01.201] Lazy evaluation: FALSE
[17:01:01.201] Asynchronous evaluation: FALSE
[17:01:01.201] Local evaluation: TRUE
[17:01:01.201] Environment: R_GlobalEnv
[17:01:01.201] Capture standard output: TRUE
[17:01:01.201] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.201] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.201] Packages: 1 packages (‘future.apply’)
[17:01:01.201] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.201] Resolved: TRUE
[17:01:01.201] Value: 480 bytes of class ‘list’
[17:01:01.201] Early signaling: FALSE
[17:01:01.201] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.201] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.202] Chunk #1 of 1 ... DONE
[17:01:01.202] Launching 1 futures (chunks) ... DONE
[17:01:01.202] Resolving 1 futures (chunks) ...
[17:01:01.202] resolve() on list ...
[17:01:01.202]  recursive: 0
[17:01:01.202]  length: 1
[17:01:01.202] 
[17:01:01.202] resolved() for ‘SequentialFuture’ ...
[17:01:01.203] - state: ‘finished’
[17:01:01.203] - run: TRUE
[17:01:01.203] - result: ‘FutureResult’
[17:01:01.203] resolved() for ‘SequentialFuture’ ... done
[17:01:01.203] Future #1
[17:01:01.203] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.203] - nx: 1
[17:01:01.203] - relay: TRUE
[17:01:01.203] - stdout: TRUE
[17:01:01.203] - signal: TRUE
[17:01:01.204] - resignal: FALSE
[17:01:01.204] - force: TRUE
[17:01:01.204] - relayed: [n=1] FALSE
[17:01:01.204] - queued futures: [n=1] FALSE
[17:01:01.204]  - until=1
[17:01:01.204]  - relaying element #1
[17:01:01.204] - relayed: [n=1] TRUE
[17:01:01.204] - queued futures: [n=1] TRUE
[17:01:01.204] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.205]  length: 0 (resolved future 1)
[17:01:01.205] Relaying remaining futures
[17:01:01.205] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.205] - nx: 1
[17:01:01.205] - relay: TRUE
[17:01:01.205] - stdout: TRUE
[17:01:01.205] - signal: TRUE
[17:01:01.205] - resignal: FALSE
[17:01:01.205] - force: TRUE
[17:01:01.205] - relayed: [n=1] TRUE
[17:01:01.205] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.205] - relayed: [n=1] TRUE
[17:01:01.206] - queued futures: [n=1] TRUE
[17:01:01.206] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.206] resolve() on list ... DONE
[17:01:01.206]  - Number of value chunks collected: 1
[17:01:01.206] Resolving 1 futures (chunks) ... DONE
[17:01:01.206] Reducing values from 1 chunks ...
[17:01:01.206]  - Number of values collected after concatenation: 10
[17:01:01.206]  - Number of values expected: 10
[17:01:01.206] Reducing values from 1 chunks ... DONE
[17:01:01.206] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:01:01.207] future_lapply() ...
[17:01:01.209] Number of chunks: 1
[17:01:01.209] getGlobalsAndPackagesXApply() ...
[17:01:01.209]  - future.globals: TRUE
[17:01:01.209] getGlobalsAndPackages() ...
[17:01:01.209] Searching for globals...
[17:01:01.214] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.214] Searching for globals ... DONE
[17:01:01.214] Resolving globals: FALSE
[17:01:01.215] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:01:01.215] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.215] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.216] - packages: [1] ‘future.apply’
[17:01:01.216] getGlobalsAndPackages() ... DONE
[17:01:01.216]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.216]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.216] Finding globals ... DONE
[17:01:01.216]  - use_args: TRUE
[17:01:01.216]  - Getting '...' globals ...
[17:01:01.216] resolve() on list ...
[17:01:01.216]  recursive: 0
[17:01:01.217]  length: 1
[17:01:01.217]  elements: ‘...’
[17:01:01.217]  length: 0 (resolved future 1)
[17:01:01.217] resolve() on list ... DONE
[17:01:01.217]    - '...' content: [n=0] 
[17:01:01.217] List of 1
[17:01:01.217]  $ ...: list()
[17:01:01.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.217]  - attr(*, "where")=List of 1
[17:01:01.217]   ..$ ...:<environment: 0x55aadb73ab88> 
[17:01:01.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.217]  - attr(*, "resolved")= logi TRUE
[17:01:01.217]  - attr(*, "total_size")= num NA
[17:01:01.220]  - Getting '...' globals ... DONE
[17:01:01.220] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.220] List of 8
[17:01:01.220]  $ ...future.FUN:function (x, ...)  
[17:01:01.220]  $ x_FUN        :function (x)  
[17:01:01.220]  $ times        : int 1
[17:01:01.220]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.220]  $ stop_if_not  :function (...)  
[17:01:01.220]  $ dim          : NULL
[17:01:01.220]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.220]  $ ...          : list()
[17:01:01.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.220]  - attr(*, "where")=List of 8
[17:01:01.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.220]   ..$ ...          :<environment: 0x55aadb73ab88> 
[17:01:01.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.220]  - attr(*, "resolved")= logi FALSE
[17:01:01.220]  - attr(*, "total_size")= num 94336
[17:01:01.225] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.225] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.225] Number of futures (= number of chunks): 1
[17:01:01.225] Launching 1 futures (chunks) ...
[17:01:01.225] Chunk #1 of 1 ...
[17:01:01.226]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.226] getGlobalsAndPackages() ...
[17:01:01.226] Searching for globals...
[17:01:01.226] 
[17:01:01.226] Searching for globals ... DONE
[17:01:01.226] - globals: [0] <none>
[17:01:01.226] getGlobalsAndPackages() ... DONE
[17:01:01.226]    + additional globals found: [n=0] 
[17:01:01.226]    + additional namespaces needed: [n=0] 
[17:01:01.227]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.227]  - seeds: <none>
[17:01:01.227]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.227] getGlobalsAndPackages() ...
[17:01:01.227] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.227] Resolving globals: FALSE
[17:01:01.227] Tweak future expression to call with '...' arguments ...
[17:01:01.227] {
[17:01:01.227]     do.call(function(...) {
[17:01:01.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.227]             on.exit(options(oopts), add = TRUE)
[17:01:01.227]         }
[17:01:01.227]         {
[17:01:01.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.227]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.227]             })
[17:01:01.227]         }
[17:01:01.227]     }, args = future.call.arguments)
[17:01:01.227] }
[17:01:01.228] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.228] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.228] - packages: [1] ‘future.apply’
[17:01:01.228] getGlobalsAndPackages() ... DONE
[17:01:01.229] run() for ‘Future’ ...
[17:01:01.229] - state: ‘created’
[17:01:01.229] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.229]   - Field: ‘label’
[17:01:01.229]   - Field: ‘local’
[17:01:01.229]   - Field: ‘owner’
[17:01:01.230]   - Field: ‘envir’
[17:01:01.230]   - Field: ‘packages’
[17:01:01.230]   - Field: ‘gc’
[17:01:01.230]   - Field: ‘conditions’
[17:01:01.230]   - Field: ‘expr’
[17:01:01.230]   - Field: ‘uuid’
[17:01:01.230]   - Field: ‘seed’
[17:01:01.230]   - Field: ‘version’
[17:01:01.230]   - Field: ‘result’
[17:01:01.230]   - Field: ‘asynchronous’
[17:01:01.230]   - Field: ‘calls’
[17:01:01.230]   - Field: ‘globals’
[17:01:01.231]   - Field: ‘stdout’
[17:01:01.231]   - Field: ‘earlySignal’
[17:01:01.231]   - Field: ‘lazy’
[17:01:01.231]   - Field: ‘state’
[17:01:01.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.231] - Launch lazy future ...
[17:01:01.231] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.231] Packages needed by future strategies (n = 0): <none>
[17:01:01.232] {
[17:01:01.232]     {
[17:01:01.232]         {
[17:01:01.232]             ...future.startTime <- base::Sys.time()
[17:01:01.232]             {
[17:01:01.232]                 {
[17:01:01.232]                   {
[17:01:01.232]                     {
[17:01:01.232]                       base::local({
[17:01:01.232]                         has_future <- base::requireNamespace("future", 
[17:01:01.232]                           quietly = TRUE)
[17:01:01.232]                         if (has_future) {
[17:01:01.232]                           ns <- base::getNamespace("future")
[17:01:01.232]                           version <- ns[[".package"]][["version"]]
[17:01:01.232]                           if (is.null(version)) 
[17:01:01.232]                             version <- utils::packageVersion("future")
[17:01:01.232]                         }
[17:01:01.232]                         else {
[17:01:01.232]                           version <- NULL
[17:01:01.232]                         }
[17:01:01.232]                         if (!has_future || version < "1.8.0") {
[17:01:01.232]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.232]                             "", base::R.version$version.string), 
[17:01:01.232]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.232]                               "release", "version")], collapse = " "), 
[17:01:01.232]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.232]                             info)
[17:01:01.232]                           info <- base::paste(info, collapse = "; ")
[17:01:01.232]                           if (!has_future) {
[17:01:01.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.232]                               info)
[17:01:01.232]                           }
[17:01:01.232]                           else {
[17:01:01.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.232]                               info, version)
[17:01:01.232]                           }
[17:01:01.232]                           base::stop(msg)
[17:01:01.232]                         }
[17:01:01.232]                       })
[17:01:01.232]                     }
[17:01:01.232]                     base::local({
[17:01:01.232]                       for (pkg in "future.apply") {
[17:01:01.232]                         base::loadNamespace(pkg)
[17:01:01.232]                         base::library(pkg, character.only = TRUE)
[17:01:01.232]                       }
[17:01:01.232]                     })
[17:01:01.232]                   }
[17:01:01.232]                   ...future.strategy.old <- future::plan("list")
[17:01:01.232]                   options(future.plan = NULL)
[17:01:01.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.232]                 }
[17:01:01.232]                 ...future.workdir <- getwd()
[17:01:01.232]             }
[17:01:01.232]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.232]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.232]         }
[17:01:01.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.232]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.232]             base::names(...future.oldOptions))
[17:01:01.232]     }
[17:01:01.232]     if (FALSE) {
[17:01:01.232]     }
[17:01:01.232]     else {
[17:01:01.232]         if (TRUE) {
[17:01:01.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.232]                 open = "w")
[17:01:01.232]         }
[17:01:01.232]         else {
[17:01:01.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.232]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.232]         }
[17:01:01.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.232]             base::sink(type = "output", split = FALSE)
[17:01:01.232]             base::close(...future.stdout)
[17:01:01.232]         }, add = TRUE)
[17:01:01.232]     }
[17:01:01.232]     ...future.frame <- base::sys.nframe()
[17:01:01.232]     ...future.conditions <- base::list()
[17:01:01.232]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.232]     if (FALSE) {
[17:01:01.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.232]     }
[17:01:01.232]     ...future.result <- base::tryCatch({
[17:01:01.232]         base::withCallingHandlers({
[17:01:01.232]             ...future.value <- base::withVisible(base::local({
[17:01:01.232]                 do.call(function(...) {
[17:01:01.232]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.232]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.232]                     ...future.globals.maxSize)) {
[17:01:01.232]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.232]                     on.exit(options(oopts), add = TRUE)
[17:01:01.232]                   }
[17:01:01.232]                   {
[17:01:01.232]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.232]                       FUN = function(jj) {
[17:01:01.232]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.232]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.232]                       })
[17:01:01.232]                   }
[17:01:01.232]                 }, args = future.call.arguments)
[17:01:01.232]             }))
[17:01:01.232]             future::FutureResult(value = ...future.value$value, 
[17:01:01.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.232]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.232]                     ...future.globalenv.names))
[17:01:01.232]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.232]         }, condition = base::local({
[17:01:01.232]             c <- base::c
[17:01:01.232]             inherits <- base::inherits
[17:01:01.232]             invokeRestart <- base::invokeRestart
[17:01:01.232]             length <- base::length
[17:01:01.232]             list <- base::list
[17:01:01.232]             seq.int <- base::seq.int
[17:01:01.232]             signalCondition <- base::signalCondition
[17:01:01.232]             sys.calls <- base::sys.calls
[17:01:01.232]             `[[` <- base::`[[`
[17:01:01.232]             `+` <- base::`+`
[17:01:01.232]             `<<-` <- base::`<<-`
[17:01:01.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.232]                   3L)]
[17:01:01.232]             }
[17:01:01.232]             function(cond) {
[17:01:01.232]                 is_error <- inherits(cond, "error")
[17:01:01.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.232]                   NULL)
[17:01:01.232]                 if (is_error) {
[17:01:01.232]                   sessionInformation <- function() {
[17:01:01.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.232]                       search = base::search(), system = base::Sys.info())
[17:01:01.232]                   }
[17:01:01.232]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.232]                     cond$call), session = sessionInformation(), 
[17:01:01.232]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.232]                   signalCondition(cond)
[17:01:01.232]                 }
[17:01:01.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.232]                 "immediateCondition"))) {
[17:01:01.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.232]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.232]                   if (TRUE && !signal) {
[17:01:01.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.232]                     {
[17:01:01.232]                       inherits <- base::inherits
[17:01:01.232]                       invokeRestart <- base::invokeRestart
[17:01:01.232]                       is.null <- base::is.null
[17:01:01.232]                       muffled <- FALSE
[17:01:01.232]                       if (inherits(cond, "message")) {
[17:01:01.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.232]                         if (muffled) 
[17:01:01.232]                           invokeRestart("muffleMessage")
[17:01:01.232]                       }
[17:01:01.232]                       else if (inherits(cond, "warning")) {
[17:01:01.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.232]                         if (muffled) 
[17:01:01.232]                           invokeRestart("muffleWarning")
[17:01:01.232]                       }
[17:01:01.232]                       else if (inherits(cond, "condition")) {
[17:01:01.232]                         if (!is.null(pattern)) {
[17:01:01.232]                           computeRestarts <- base::computeRestarts
[17:01:01.232]                           grepl <- base::grepl
[17:01:01.232]                           restarts <- computeRestarts(cond)
[17:01:01.232]                           for (restart in restarts) {
[17:01:01.232]                             name <- restart$name
[17:01:01.232]                             if (is.null(name)) 
[17:01:01.232]                               next
[17:01:01.232]                             if (!grepl(pattern, name)) 
[17:01:01.232]                               next
[17:01:01.232]                             invokeRestart(restart)
[17:01:01.232]                             muffled <- TRUE
[17:01:01.232]                             break
[17:01:01.232]                           }
[17:01:01.232]                         }
[17:01:01.232]                       }
[17:01:01.232]                       invisible(muffled)
[17:01:01.232]                     }
[17:01:01.232]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.232]                   }
[17:01:01.232]                 }
[17:01:01.232]                 else {
[17:01:01.232]                   if (TRUE) {
[17:01:01.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.232]                     {
[17:01:01.232]                       inherits <- base::inherits
[17:01:01.232]                       invokeRestart <- base::invokeRestart
[17:01:01.232]                       is.null <- base::is.null
[17:01:01.232]                       muffled <- FALSE
[17:01:01.232]                       if (inherits(cond, "message")) {
[17:01:01.232]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.232]                         if (muffled) 
[17:01:01.232]                           invokeRestart("muffleMessage")
[17:01:01.232]                       }
[17:01:01.232]                       else if (inherits(cond, "warning")) {
[17:01:01.232]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.232]                         if (muffled) 
[17:01:01.232]                           invokeRestart("muffleWarning")
[17:01:01.232]                       }
[17:01:01.232]                       else if (inherits(cond, "condition")) {
[17:01:01.232]                         if (!is.null(pattern)) {
[17:01:01.232]                           computeRestarts <- base::computeRestarts
[17:01:01.232]                           grepl <- base::grepl
[17:01:01.232]                           restarts <- computeRestarts(cond)
[17:01:01.232]                           for (restart in restarts) {
[17:01:01.232]                             name <- restart$name
[17:01:01.232]                             if (is.null(name)) 
[17:01:01.232]                               next
[17:01:01.232]                             if (!grepl(pattern, name)) 
[17:01:01.232]                               next
[17:01:01.232]                             invokeRestart(restart)
[17:01:01.232]                             muffled <- TRUE
[17:01:01.232]                             break
[17:01:01.232]                           }
[17:01:01.232]                         }
[17:01:01.232]                       }
[17:01:01.232]                       invisible(muffled)
[17:01:01.232]                     }
[17:01:01.232]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.232]                   }
[17:01:01.232]                 }
[17:01:01.232]             }
[17:01:01.232]         }))
[17:01:01.232]     }, error = function(ex) {
[17:01:01.232]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.232]                 ...future.rng), started = ...future.startTime, 
[17:01:01.232]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.232]             version = "1.8"), class = "FutureResult")
[17:01:01.232]     }, finally = {
[17:01:01.232]         if (!identical(...future.workdir, getwd())) 
[17:01:01.232]             setwd(...future.workdir)
[17:01:01.232]         {
[17:01:01.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.232]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.232]             }
[17:01:01.232]             base::options(...future.oldOptions)
[17:01:01.232]             if (.Platform$OS.type == "windows") {
[17:01:01.232]                 old_names <- names(...future.oldEnvVars)
[17:01:01.232]                 envs <- base::Sys.getenv()
[17:01:01.232]                 names <- names(envs)
[17:01:01.232]                 common <- intersect(names, old_names)
[17:01:01.232]                 added <- setdiff(names, old_names)
[17:01:01.232]                 removed <- setdiff(old_names, names)
[17:01:01.232]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.232]                   envs[common]]
[17:01:01.232]                 NAMES <- toupper(changed)
[17:01:01.232]                 args <- list()
[17:01:01.232]                 for (kk in seq_along(NAMES)) {
[17:01:01.232]                   name <- changed[[kk]]
[17:01:01.232]                   NAME <- NAMES[[kk]]
[17:01:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.232]                     next
[17:01:01.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.232]                 }
[17:01:01.232]                 NAMES <- toupper(added)
[17:01:01.232]                 for (kk in seq_along(NAMES)) {
[17:01:01.232]                   name <- added[[kk]]
[17:01:01.232]                   NAME <- NAMES[[kk]]
[17:01:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.232]                     next
[17:01:01.232]                   args[[name]] <- ""
[17:01:01.232]                 }
[17:01:01.232]                 NAMES <- toupper(removed)
[17:01:01.232]                 for (kk in seq_along(NAMES)) {
[17:01:01.232]                   name <- removed[[kk]]
[17:01:01.232]                   NAME <- NAMES[[kk]]
[17:01:01.232]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.232]                     next
[17:01:01.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.232]                 }
[17:01:01.232]                 if (length(args) > 0) 
[17:01:01.232]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.232]             }
[17:01:01.232]             else {
[17:01:01.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.232]             }
[17:01:01.232]             {
[17:01:01.232]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.232]                   0L) {
[17:01:01.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.232]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.232]                   base::options(opts)
[17:01:01.232]                 }
[17:01:01.232]                 {
[17:01:01.232]                   {
[17:01:01.232]                     NULL
[17:01:01.232]                     RNGkind("Mersenne-Twister")
[17:01:01.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.232]                       inherits = FALSE)
[17:01:01.232]                   }
[17:01:01.232]                   options(future.plan = NULL)
[17:01:01.232]                   if (is.na(NA_character_)) 
[17:01:01.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.232]                     .init = FALSE)
[17:01:01.232]                 }
[17:01:01.232]             }
[17:01:01.232]         }
[17:01:01.232]     })
[17:01:01.232]     if (TRUE) {
[17:01:01.232]         base::sink(type = "output", split = FALSE)
[17:01:01.232]         if (TRUE) {
[17:01:01.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.232]         }
[17:01:01.232]         else {
[17:01:01.232]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.232]         }
[17:01:01.232]         base::close(...future.stdout)
[17:01:01.232]         ...future.stdout <- NULL
[17:01:01.232]     }
[17:01:01.232]     ...future.result$conditions <- ...future.conditions
[17:01:01.232]     ...future.result$finished <- base::Sys.time()
[17:01:01.232]     ...future.result
[17:01:01.232] }
[17:01:01.234] assign_globals() ...
[17:01:01.234] List of 11
[17:01:01.234]  $ ...future.FUN            :function (x, ...)  
[17:01:01.234]  $ x_FUN                    :function (x)  
[17:01:01.234]  $ times                    : int 1
[17:01:01.234]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.234]  $ stop_if_not              :function (...)  
[17:01:01.234]  $ dim                      : NULL
[17:01:01.234]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.234]  $ future.call.arguments    : list()
[17:01:01.234]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.234]  $ ...future.elements_ii    :List of 10
[17:01:01.234]   ..$ : int 1
[17:01:01.234]   ..$ : int 2
[17:01:01.234]   ..$ : int 3
[17:01:01.234]   ..$ : int 4
[17:01:01.234]   ..$ : int 5
[17:01:01.234]   ..$ : int 6
[17:01:01.234]   ..$ : int 7
[17:01:01.234]   ..$ : int 8
[17:01:01.234]   ..$ : int 9
[17:01:01.234]   ..$ : int 10
[17:01:01.234]  $ ...future.seeds_ii       : NULL
[17:01:01.234]  $ ...future.globals.maxSize: NULL
[17:01:01.234]  - attr(*, "where")=List of 11
[17:01:01.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.234]  - attr(*, "resolved")= logi FALSE
[17:01:01.234]  - attr(*, "total_size")= num 94336
[17:01:01.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.234]  - attr(*, "already-done")= logi TRUE
[17:01:01.245] - copied ‘...future.FUN’ to environment
[17:01:01.245] - copied ‘x_FUN’ to environment
[17:01:01.245] - copied ‘times’ to environment
[17:01:01.245] - copied ‘stopf’ to environment
[17:01:01.245] - copied ‘stop_if_not’ to environment
[17:01:01.245] - copied ‘dim’ to environment
[17:01:01.245] - copied ‘valid_types’ to environment
[17:01:01.245] - copied ‘future.call.arguments’ to environment
[17:01:01.246] - copied ‘...future.elements_ii’ to environment
[17:01:01.246] - copied ‘...future.seeds_ii’ to environment
[17:01:01.246] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.246] assign_globals() ... done
[17:01:01.246] plan(): Setting new future strategy stack:
[17:01:01.246] List of future strategies:
[17:01:01.246] 1. sequential:
[17:01:01.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.246]    - tweaked: FALSE
[17:01:01.246]    - call: NULL
[17:01:01.247] plan(): nbrOfWorkers() = 1
[17:01:01.248] plan(): Setting new future strategy stack:
[17:01:01.248] List of future strategies:
[17:01:01.248] 1. sequential:
[17:01:01.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.248]    - tweaked: FALSE
[17:01:01.248]    - call: plan(strategy)
[17:01:01.248] plan(): nbrOfWorkers() = 1
[17:01:01.248] SequentialFuture started (and completed)
[17:01:01.248] - Launch lazy future ... done
[17:01:01.248] run() for ‘SequentialFuture’ ... done
[17:01:01.249] Created future:
[17:01:01.249] SequentialFuture:
[17:01:01.249] Label: ‘future_vapply-1’
[17:01:01.249] Expression:
[17:01:01.249] {
[17:01:01.249]     do.call(function(...) {
[17:01:01.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.249]             on.exit(options(oopts), add = TRUE)
[17:01:01.249]         }
[17:01:01.249]         {
[17:01:01.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.249]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.249]             })
[17:01:01.249]         }
[17:01:01.249]     }, args = future.call.arguments)
[17:01:01.249] }
[17:01:01.249] Lazy evaluation: FALSE
[17:01:01.249] Asynchronous evaluation: FALSE
[17:01:01.249] Local evaluation: TRUE
[17:01:01.249] Environment: R_GlobalEnv
[17:01:01.249] Capture standard output: TRUE
[17:01:01.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.249] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.249] Packages: 1 packages (‘future.apply’)
[17:01:01.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.249] Resolved: TRUE
[17:01:01.249] Value: 560 bytes of class ‘list’
[17:01:01.249] Early signaling: FALSE
[17:01:01.249] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.249] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.250] Chunk #1 of 1 ... DONE
[17:01:01.250] Launching 1 futures (chunks) ... DONE
[17:01:01.250] Resolving 1 futures (chunks) ...
[17:01:01.250] resolve() on list ...
[17:01:01.250]  recursive: 0
[17:01:01.250]  length: 1
[17:01:01.250] 
[17:01:01.251] resolved() for ‘SequentialFuture’ ...
[17:01:01.251] - state: ‘finished’
[17:01:01.251] - run: TRUE
[17:01:01.251] - result: ‘FutureResult’
[17:01:01.251] resolved() for ‘SequentialFuture’ ... done
[17:01:01.251] Future #1
[17:01:01.251] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.251] - nx: 1
[17:01:01.251] - relay: TRUE
[17:01:01.252] - stdout: TRUE
[17:01:01.252] - signal: TRUE
[17:01:01.252] - resignal: FALSE
[17:01:01.252] - force: TRUE
[17:01:01.252] - relayed: [n=1] FALSE
[17:01:01.252] - queued futures: [n=1] FALSE
[17:01:01.252]  - until=1
[17:01:01.252]  - relaying element #1
[17:01:01.252] - relayed: [n=1] TRUE
[17:01:01.252] - queued futures: [n=1] TRUE
[17:01:01.253] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.253]  length: 0 (resolved future 1)
[17:01:01.253] Relaying remaining futures
[17:01:01.253] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.253] - nx: 1
[17:01:01.253] - relay: TRUE
[17:01:01.253] - stdout: TRUE
[17:01:01.253] - signal: TRUE
[17:01:01.253] - resignal: FALSE
[17:01:01.253] - force: TRUE
[17:01:01.253] - relayed: [n=1] TRUE
[17:01:01.253] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.254] - relayed: [n=1] TRUE
[17:01:01.254] - queued futures: [n=1] TRUE
[17:01:01.254] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.254] resolve() on list ... DONE
[17:01:01.254]  - Number of value chunks collected: 1
[17:01:01.254] Resolving 1 futures (chunks) ... DONE
[17:01:01.254] Reducing values from 1 chunks ...
[17:01:01.254]  - Number of values collected after concatenation: 10
[17:01:01.254]  - Number of values expected: 10
[17:01:01.254] Reducing values from 1 chunks ... DONE
[17:01:01.255] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:01:01.255] future_lapply() ...
[17:01:01.257] Number of chunks: 1
[17:01:01.257] getGlobalsAndPackagesXApply() ...
[17:01:01.257]  - future.globals: TRUE
[17:01:01.257] getGlobalsAndPackages() ...
[17:01:01.257] Searching for globals...
[17:01:01.263] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:01:01.263] Searching for globals ... DONE
[17:01:01.263] Resolving globals: FALSE
[17:01:01.264] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:01:01.264] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.264] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.265] - packages: [1] ‘future.apply’
[17:01:01.265] getGlobalsAndPackages() ... DONE
[17:01:01.265]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.265]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.265] Finding globals ... DONE
[17:01:01.265]  - use_args: TRUE
[17:01:01.265]  - Getting '...' globals ...
[17:01:01.265] resolve() on list ...
[17:01:01.266]  recursive: 0
[17:01:01.266]  length: 1
[17:01:01.266]  elements: ‘...’
[17:01:01.266]  length: 0 (resolved future 1)
[17:01:01.266] resolve() on list ... DONE
[17:01:01.266]    - '...' content: [n=0] 
[17:01:01.266] List of 1
[17:01:01.266]  $ ...: list()
[17:01:01.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.266]  - attr(*, "where")=List of 1
[17:01:01.266]   ..$ ...:<environment: 0x55aadb766070> 
[17:01:01.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.266]  - attr(*, "resolved")= logi TRUE
[17:01:01.266]  - attr(*, "total_size")= num NA
[17:01:01.269]  - Getting '...' globals ... DONE
[17:01:01.269] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.269] List of 8
[17:01:01.269]  $ ...future.FUN:function (x, ...)  
[17:01:01.269]  $ x_FUN        :function (x)  
[17:01:01.269]  $ times        : int 2
[17:01:01.269]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.269]  $ stop_if_not  :function (...)  
[17:01:01.269]  $ dim          : NULL
[17:01:01.269]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.269]  $ ...          : list()
[17:01:01.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.269]  - attr(*, "where")=List of 8
[17:01:01.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.269]   ..$ ...          :<environment: 0x55aadb766070> 
[17:01:01.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.269]  - attr(*, "resolved")= logi FALSE
[17:01:01.269]  - attr(*, "total_size")= num 96456
[17:01:01.274] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.274] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.274] Number of futures (= number of chunks): 1
[17:01:01.275] Launching 1 futures (chunks) ...
[17:01:01.275] Chunk #1 of 1 ...
[17:01:01.275]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.275] getGlobalsAndPackages() ...
[17:01:01.275] Searching for globals...
[17:01:01.275] 
[17:01:01.275] Searching for globals ... DONE
[17:01:01.275] - globals: [0] <none>
[17:01:01.276] getGlobalsAndPackages() ... DONE
[17:01:01.276]    + additional globals found: [n=0] 
[17:01:01.276]    + additional namespaces needed: [n=0] 
[17:01:01.276]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.276]  - seeds: <none>
[17:01:01.276]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.276] getGlobalsAndPackages() ...
[17:01:01.276] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.276] Resolving globals: FALSE
[17:01:01.276] Tweak future expression to call with '...' arguments ...
[17:01:01.277] {
[17:01:01.277]     do.call(function(...) {
[17:01:01.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.277]             on.exit(options(oopts), add = TRUE)
[17:01:01.277]         }
[17:01:01.277]         {
[17:01:01.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.277]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.277]             })
[17:01:01.277]         }
[17:01:01.277]     }, args = future.call.arguments)
[17:01:01.277] }
[17:01:01.277] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.277] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.277] - packages: [1] ‘future.apply’
[17:01:01.278] getGlobalsAndPackages() ... DONE
[17:01:01.278] run() for ‘Future’ ...
[17:01:01.278] - state: ‘created’
[17:01:01.278] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.278] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.279]   - Field: ‘label’
[17:01:01.279]   - Field: ‘local’
[17:01:01.279]   - Field: ‘owner’
[17:01:01.279]   - Field: ‘envir’
[17:01:01.279]   - Field: ‘packages’
[17:01:01.279]   - Field: ‘gc’
[17:01:01.279]   - Field: ‘conditions’
[17:01:01.279]   - Field: ‘expr’
[17:01:01.279]   - Field: ‘uuid’
[17:01:01.279]   - Field: ‘seed’
[17:01:01.279]   - Field: ‘version’
[17:01:01.280]   - Field: ‘result’
[17:01:01.280]   - Field: ‘asynchronous’
[17:01:01.280]   - Field: ‘calls’
[17:01:01.280]   - Field: ‘globals’
[17:01:01.280]   - Field: ‘stdout’
[17:01:01.280]   - Field: ‘earlySignal’
[17:01:01.280]   - Field: ‘lazy’
[17:01:01.280]   - Field: ‘state’
[17:01:01.280] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.280] - Launch lazy future ...
[17:01:01.281] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.281] Packages needed by future strategies (n = 0): <none>
[17:01:01.283] {
[17:01:01.283]     {
[17:01:01.283]         {
[17:01:01.283]             ...future.startTime <- base::Sys.time()
[17:01:01.283]             {
[17:01:01.283]                 {
[17:01:01.283]                   {
[17:01:01.283]                     {
[17:01:01.283]                       base::local({
[17:01:01.283]                         has_future <- base::requireNamespace("future", 
[17:01:01.283]                           quietly = TRUE)
[17:01:01.283]                         if (has_future) {
[17:01:01.283]                           ns <- base::getNamespace("future")
[17:01:01.283]                           version <- ns[[".package"]][["version"]]
[17:01:01.283]                           if (is.null(version)) 
[17:01:01.283]                             version <- utils::packageVersion("future")
[17:01:01.283]                         }
[17:01:01.283]                         else {
[17:01:01.283]                           version <- NULL
[17:01:01.283]                         }
[17:01:01.283]                         if (!has_future || version < "1.8.0") {
[17:01:01.283]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.283]                             "", base::R.version$version.string), 
[17:01:01.283]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.283]                               "release", "version")], collapse = " "), 
[17:01:01.283]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.283]                             info)
[17:01:01.283]                           info <- base::paste(info, collapse = "; ")
[17:01:01.283]                           if (!has_future) {
[17:01:01.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.283]                               info)
[17:01:01.283]                           }
[17:01:01.283]                           else {
[17:01:01.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.283]                               info, version)
[17:01:01.283]                           }
[17:01:01.283]                           base::stop(msg)
[17:01:01.283]                         }
[17:01:01.283]                       })
[17:01:01.283]                     }
[17:01:01.283]                     base::local({
[17:01:01.283]                       for (pkg in "future.apply") {
[17:01:01.283]                         base::loadNamespace(pkg)
[17:01:01.283]                         base::library(pkg, character.only = TRUE)
[17:01:01.283]                       }
[17:01:01.283]                     })
[17:01:01.283]                   }
[17:01:01.283]                   ...future.strategy.old <- future::plan("list")
[17:01:01.283]                   options(future.plan = NULL)
[17:01:01.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.283]                 }
[17:01:01.283]                 ...future.workdir <- getwd()
[17:01:01.283]             }
[17:01:01.283]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.283]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.283]         }
[17:01:01.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.283]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.283]             base::names(...future.oldOptions))
[17:01:01.283]     }
[17:01:01.283]     if (FALSE) {
[17:01:01.283]     }
[17:01:01.283]     else {
[17:01:01.283]         if (TRUE) {
[17:01:01.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.283]                 open = "w")
[17:01:01.283]         }
[17:01:01.283]         else {
[17:01:01.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.283]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.283]         }
[17:01:01.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.283]             base::sink(type = "output", split = FALSE)
[17:01:01.283]             base::close(...future.stdout)
[17:01:01.283]         }, add = TRUE)
[17:01:01.283]     }
[17:01:01.283]     ...future.frame <- base::sys.nframe()
[17:01:01.283]     ...future.conditions <- base::list()
[17:01:01.283]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.283]     if (FALSE) {
[17:01:01.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.283]     }
[17:01:01.283]     ...future.result <- base::tryCatch({
[17:01:01.283]         base::withCallingHandlers({
[17:01:01.283]             ...future.value <- base::withVisible(base::local({
[17:01:01.283]                 do.call(function(...) {
[17:01:01.283]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.283]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.283]                     ...future.globals.maxSize)) {
[17:01:01.283]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.283]                     on.exit(options(oopts), add = TRUE)
[17:01:01.283]                   }
[17:01:01.283]                   {
[17:01:01.283]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.283]                       FUN = function(jj) {
[17:01:01.283]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.283]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.283]                       })
[17:01:01.283]                   }
[17:01:01.283]                 }, args = future.call.arguments)
[17:01:01.283]             }))
[17:01:01.283]             future::FutureResult(value = ...future.value$value, 
[17:01:01.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.283]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.283]                     ...future.globalenv.names))
[17:01:01.283]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.283]         }, condition = base::local({
[17:01:01.283]             c <- base::c
[17:01:01.283]             inherits <- base::inherits
[17:01:01.283]             invokeRestart <- base::invokeRestart
[17:01:01.283]             length <- base::length
[17:01:01.283]             list <- base::list
[17:01:01.283]             seq.int <- base::seq.int
[17:01:01.283]             signalCondition <- base::signalCondition
[17:01:01.283]             sys.calls <- base::sys.calls
[17:01:01.283]             `[[` <- base::`[[`
[17:01:01.283]             `+` <- base::`+`
[17:01:01.283]             `<<-` <- base::`<<-`
[17:01:01.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.283]                   3L)]
[17:01:01.283]             }
[17:01:01.283]             function(cond) {
[17:01:01.283]                 is_error <- inherits(cond, "error")
[17:01:01.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.283]                   NULL)
[17:01:01.283]                 if (is_error) {
[17:01:01.283]                   sessionInformation <- function() {
[17:01:01.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.283]                       search = base::search(), system = base::Sys.info())
[17:01:01.283]                   }
[17:01:01.283]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.283]                     cond$call), session = sessionInformation(), 
[17:01:01.283]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.283]                   signalCondition(cond)
[17:01:01.283]                 }
[17:01:01.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.283]                 "immediateCondition"))) {
[17:01:01.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.283]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.283]                   if (TRUE && !signal) {
[17:01:01.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.283]                     {
[17:01:01.283]                       inherits <- base::inherits
[17:01:01.283]                       invokeRestart <- base::invokeRestart
[17:01:01.283]                       is.null <- base::is.null
[17:01:01.283]                       muffled <- FALSE
[17:01:01.283]                       if (inherits(cond, "message")) {
[17:01:01.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.283]                         if (muffled) 
[17:01:01.283]                           invokeRestart("muffleMessage")
[17:01:01.283]                       }
[17:01:01.283]                       else if (inherits(cond, "warning")) {
[17:01:01.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.283]                         if (muffled) 
[17:01:01.283]                           invokeRestart("muffleWarning")
[17:01:01.283]                       }
[17:01:01.283]                       else if (inherits(cond, "condition")) {
[17:01:01.283]                         if (!is.null(pattern)) {
[17:01:01.283]                           computeRestarts <- base::computeRestarts
[17:01:01.283]                           grepl <- base::grepl
[17:01:01.283]                           restarts <- computeRestarts(cond)
[17:01:01.283]                           for (restart in restarts) {
[17:01:01.283]                             name <- restart$name
[17:01:01.283]                             if (is.null(name)) 
[17:01:01.283]                               next
[17:01:01.283]                             if (!grepl(pattern, name)) 
[17:01:01.283]                               next
[17:01:01.283]                             invokeRestart(restart)
[17:01:01.283]                             muffled <- TRUE
[17:01:01.283]                             break
[17:01:01.283]                           }
[17:01:01.283]                         }
[17:01:01.283]                       }
[17:01:01.283]                       invisible(muffled)
[17:01:01.283]                     }
[17:01:01.283]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.283]                   }
[17:01:01.283]                 }
[17:01:01.283]                 else {
[17:01:01.283]                   if (TRUE) {
[17:01:01.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.283]                     {
[17:01:01.283]                       inherits <- base::inherits
[17:01:01.283]                       invokeRestart <- base::invokeRestart
[17:01:01.283]                       is.null <- base::is.null
[17:01:01.283]                       muffled <- FALSE
[17:01:01.283]                       if (inherits(cond, "message")) {
[17:01:01.283]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.283]                         if (muffled) 
[17:01:01.283]                           invokeRestart("muffleMessage")
[17:01:01.283]                       }
[17:01:01.283]                       else if (inherits(cond, "warning")) {
[17:01:01.283]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.283]                         if (muffled) 
[17:01:01.283]                           invokeRestart("muffleWarning")
[17:01:01.283]                       }
[17:01:01.283]                       else if (inherits(cond, "condition")) {
[17:01:01.283]                         if (!is.null(pattern)) {
[17:01:01.283]                           computeRestarts <- base::computeRestarts
[17:01:01.283]                           grepl <- base::grepl
[17:01:01.283]                           restarts <- computeRestarts(cond)
[17:01:01.283]                           for (restart in restarts) {
[17:01:01.283]                             name <- restart$name
[17:01:01.283]                             if (is.null(name)) 
[17:01:01.283]                               next
[17:01:01.283]                             if (!grepl(pattern, name)) 
[17:01:01.283]                               next
[17:01:01.283]                             invokeRestart(restart)
[17:01:01.283]                             muffled <- TRUE
[17:01:01.283]                             break
[17:01:01.283]                           }
[17:01:01.283]                         }
[17:01:01.283]                       }
[17:01:01.283]                       invisible(muffled)
[17:01:01.283]                     }
[17:01:01.283]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.283]                   }
[17:01:01.283]                 }
[17:01:01.283]             }
[17:01:01.283]         }))
[17:01:01.283]     }, error = function(ex) {
[17:01:01.283]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.283]                 ...future.rng), started = ...future.startTime, 
[17:01:01.283]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.283]             version = "1.8"), class = "FutureResult")
[17:01:01.283]     }, finally = {
[17:01:01.283]         if (!identical(...future.workdir, getwd())) 
[17:01:01.283]             setwd(...future.workdir)
[17:01:01.283]         {
[17:01:01.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.283]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.283]             }
[17:01:01.283]             base::options(...future.oldOptions)
[17:01:01.283]             if (.Platform$OS.type == "windows") {
[17:01:01.283]                 old_names <- names(...future.oldEnvVars)
[17:01:01.283]                 envs <- base::Sys.getenv()
[17:01:01.283]                 names <- names(envs)
[17:01:01.283]                 common <- intersect(names, old_names)
[17:01:01.283]                 added <- setdiff(names, old_names)
[17:01:01.283]                 removed <- setdiff(old_names, names)
[17:01:01.283]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.283]                   envs[common]]
[17:01:01.283]                 NAMES <- toupper(changed)
[17:01:01.283]                 args <- list()
[17:01:01.283]                 for (kk in seq_along(NAMES)) {
[17:01:01.283]                   name <- changed[[kk]]
[17:01:01.283]                   NAME <- NAMES[[kk]]
[17:01:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.283]                     next
[17:01:01.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.283]                 }
[17:01:01.283]                 NAMES <- toupper(added)
[17:01:01.283]                 for (kk in seq_along(NAMES)) {
[17:01:01.283]                   name <- added[[kk]]
[17:01:01.283]                   NAME <- NAMES[[kk]]
[17:01:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.283]                     next
[17:01:01.283]                   args[[name]] <- ""
[17:01:01.283]                 }
[17:01:01.283]                 NAMES <- toupper(removed)
[17:01:01.283]                 for (kk in seq_along(NAMES)) {
[17:01:01.283]                   name <- removed[[kk]]
[17:01:01.283]                   NAME <- NAMES[[kk]]
[17:01:01.283]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.283]                     next
[17:01:01.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.283]                 }
[17:01:01.283]                 if (length(args) > 0) 
[17:01:01.283]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.283]             }
[17:01:01.283]             else {
[17:01:01.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.283]             }
[17:01:01.283]             {
[17:01:01.283]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.283]                   0L) {
[17:01:01.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.283]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.283]                   base::options(opts)
[17:01:01.283]                 }
[17:01:01.283]                 {
[17:01:01.283]                   {
[17:01:01.283]                     NULL
[17:01:01.283]                     RNGkind("Mersenne-Twister")
[17:01:01.283]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.283]                       inherits = FALSE)
[17:01:01.283]                   }
[17:01:01.283]                   options(future.plan = NULL)
[17:01:01.283]                   if (is.na(NA_character_)) 
[17:01:01.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.283]                     .init = FALSE)
[17:01:01.283]                 }
[17:01:01.283]             }
[17:01:01.283]         }
[17:01:01.283]     })
[17:01:01.283]     if (TRUE) {
[17:01:01.283]         base::sink(type = "output", split = FALSE)
[17:01:01.283]         if (TRUE) {
[17:01:01.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.283]         }
[17:01:01.283]         else {
[17:01:01.283]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.283]         }
[17:01:01.283]         base::close(...future.stdout)
[17:01:01.283]         ...future.stdout <- NULL
[17:01:01.283]     }
[17:01:01.283]     ...future.result$conditions <- ...future.conditions
[17:01:01.283]     ...future.result$finished <- base::Sys.time()
[17:01:01.283]     ...future.result
[17:01:01.283] }
[17:01:01.285] assign_globals() ...
[17:01:01.285] List of 11
[17:01:01.285]  $ ...future.FUN            :function (x, ...)  
[17:01:01.285]  $ x_FUN                    :function (x)  
[17:01:01.285]  $ times                    : int 2
[17:01:01.285]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.285]  $ stop_if_not              :function (...)  
[17:01:01.285]  $ dim                      : NULL
[17:01:01.285]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.285]  $ future.call.arguments    : list()
[17:01:01.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.285]  $ ...future.elements_ii    :List of 10
[17:01:01.285]   ..$ : int 1
[17:01:01.285]   ..$ : int 2
[17:01:01.285]   ..$ : int 3
[17:01:01.285]   ..$ : int 4
[17:01:01.285]   ..$ : int 5
[17:01:01.285]   ..$ : int 6
[17:01:01.285]   ..$ : int 7
[17:01:01.285]   ..$ : int 8
[17:01:01.285]   ..$ : int 9
[17:01:01.285]   ..$ : int 10
[17:01:01.285]  $ ...future.seeds_ii       : NULL
[17:01:01.285]  $ ...future.globals.maxSize: NULL
[17:01:01.285]  - attr(*, "where")=List of 11
[17:01:01.285]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.285]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.285]  - attr(*, "resolved")= logi FALSE
[17:01:01.285]  - attr(*, "total_size")= num 96456
[17:01:01.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.285]  - attr(*, "already-done")= logi TRUE
[17:01:01.294] - copied ‘...future.FUN’ to environment
[17:01:01.294] - reassign environment for ‘x_FUN’
[17:01:01.295] - copied ‘x_FUN’ to environment
[17:01:01.295] - copied ‘times’ to environment
[17:01:01.295] - copied ‘stopf’ to environment
[17:01:01.295] - copied ‘stop_if_not’ to environment
[17:01:01.295] - copied ‘dim’ to environment
[17:01:01.295] - copied ‘valid_types’ to environment
[17:01:01.295] - copied ‘future.call.arguments’ to environment
[17:01:01.295] - copied ‘...future.elements_ii’ to environment
[17:01:01.295] - copied ‘...future.seeds_ii’ to environment
[17:01:01.295] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.295] assign_globals() ... done
[17:01:01.296] plan(): Setting new future strategy stack:
[17:01:01.296] List of future strategies:
[17:01:01.296] 1. sequential:
[17:01:01.296]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.296]    - tweaked: FALSE
[17:01:01.296]    - call: NULL
[17:01:01.296] plan(): nbrOfWorkers() = 1
[17:01:01.297] plan(): Setting new future strategy stack:
[17:01:01.297] List of future strategies:
[17:01:01.297] 1. sequential:
[17:01:01.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.297]    - tweaked: FALSE
[17:01:01.297]    - call: plan(strategy)
[17:01:01.298] plan(): nbrOfWorkers() = 1
[17:01:01.298] SequentialFuture started (and completed)
[17:01:01.298] - Launch lazy future ... done
[17:01:01.298] run() for ‘SequentialFuture’ ... done
[17:01:01.298] Created future:
[17:01:01.298] SequentialFuture:
[17:01:01.298] Label: ‘future_vapply-1’
[17:01:01.298] Expression:
[17:01:01.298] {
[17:01:01.298]     do.call(function(...) {
[17:01:01.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.298]             on.exit(options(oopts), add = TRUE)
[17:01:01.298]         }
[17:01:01.298]         {
[17:01:01.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.298]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.298]             })
[17:01:01.298]         }
[17:01:01.298]     }, args = future.call.arguments)
[17:01:01.298] }
[17:01:01.298] Lazy evaluation: FALSE
[17:01:01.298] Asynchronous evaluation: FALSE
[17:01:01.298] Local evaluation: TRUE
[17:01:01.298] Environment: R_GlobalEnv
[17:01:01.298] Capture standard output: TRUE
[17:01:01.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.298] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.298] Packages: 1 packages (‘future.apply’)
[17:01:01.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.298] Resolved: TRUE
[17:01:01.298] Value: 640 bytes of class ‘list’
[17:01:01.298] Early signaling: FALSE
[17:01:01.298] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.298] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.300] Chunk #1 of 1 ... DONE
[17:01:01.300] Launching 1 futures (chunks) ... DONE
[17:01:01.300] Resolving 1 futures (chunks) ...
[17:01:01.300] resolve() on list ...
[17:01:01.300]  recursive: 0
[17:01:01.300]  length: 1
[17:01:01.300] 
[17:01:01.300] resolved() for ‘SequentialFuture’ ...
[17:01:01.300] - state: ‘finished’
[17:01:01.300] - run: TRUE
[17:01:01.301] - result: ‘FutureResult’
[17:01:01.301] resolved() for ‘SequentialFuture’ ... done
[17:01:01.301] Future #1
[17:01:01.301] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.301] - nx: 1
[17:01:01.301] - relay: TRUE
[17:01:01.301] - stdout: TRUE
[17:01:01.301] - signal: TRUE
[17:01:01.301] - resignal: FALSE
[17:01:01.301] - force: TRUE
[17:01:01.301] - relayed: [n=1] FALSE
[17:01:01.302] - queued futures: [n=1] FALSE
[17:01:01.302]  - until=1
[17:01:01.302]  - relaying element #1
[17:01:01.302] - relayed: [n=1] TRUE
[17:01:01.302] - queued futures: [n=1] TRUE
[17:01:01.302] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.302]  length: 0 (resolved future 1)
[17:01:01.302] Relaying remaining futures
[17:01:01.302] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.302] - nx: 1
[17:01:01.303] - relay: TRUE
[17:01:01.303] - stdout: TRUE
[17:01:01.303] - signal: TRUE
[17:01:01.303] - resignal: FALSE
[17:01:01.303] - force: TRUE
[17:01:01.303] - relayed: [n=1] TRUE
[17:01:01.303] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.303] - relayed: [n=1] TRUE
[17:01:01.303] - queued futures: [n=1] TRUE
[17:01:01.303] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.303] resolve() on list ... DONE
[17:01:01.304]  - Number of value chunks collected: 1
[17:01:01.304] Resolving 1 futures (chunks) ... DONE
[17:01:01.304] Reducing values from 1 chunks ...
[17:01:01.304]  - Number of values collected after concatenation: 10
[17:01:01.304]  - Number of values expected: 10
[17:01:01.304] Reducing values from 1 chunks ... DONE
[17:01:01.304] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:01.305] future_lapply() ...
[17:01:01.308] Number of chunks: 1
[17:01:01.309] getGlobalsAndPackagesXApply() ...
[17:01:01.309]  - future.globals: TRUE
[17:01:01.309] getGlobalsAndPackages() ...
[17:01:01.309] Searching for globals...
[17:01:01.312] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:01.312] Searching for globals ... DONE
[17:01:01.312] Resolving globals: FALSE
[17:01:01.313] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:01:01.314] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.314] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.314] - packages: [1] ‘future.apply’
[17:01:01.314] getGlobalsAndPackages() ... DONE
[17:01:01.314]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.314]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.314] Finding globals ... DONE
[17:01:01.314]  - use_args: TRUE
[17:01:01.315]  - Getting '...' globals ...
[17:01:01.315] resolve() on list ...
[17:01:01.315]  recursive: 0
[17:01:01.315]  length: 1
[17:01:01.315]  elements: ‘...’
[17:01:01.315]  length: 0 (resolved future 1)
[17:01:01.315] resolve() on list ... DONE
[17:01:01.315]    - '...' content: [n=0] 
[17:01:01.316] List of 1
[17:01:01.316]  $ ...: list()
[17:01:01.316]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.316]  - attr(*, "where")=List of 1
[17:01:01.316]   ..$ ...:<environment: 0x55aadb9165f8> 
[17:01:01.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.316]  - attr(*, "resolved")= logi TRUE
[17:01:01.316]  - attr(*, "total_size")= num NA
[17:01:01.318]  - Getting '...' globals ... DONE
[17:01:01.318] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.318] List of 8
[17:01:01.318]  $ ...future.FUN:function (x, ...)  
[17:01:01.318]  $ x_FUN        :function (x)  
[17:01:01.318]  $ times        : int 4
[17:01:01.318]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.318]  $ stop_if_not  :function (...)  
[17:01:01.318]  $ dim          : int [1:2] 2 2
[17:01:01.318]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:01.318]  $ ...          : list()
[17:01:01.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.318]  - attr(*, "where")=List of 8
[17:01:01.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.318]   ..$ ...          :<environment: 0x55aadb9165f8> 
[17:01:01.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.318]  - attr(*, "resolved")= logi FALSE
[17:01:01.318]  - attr(*, "total_size")= num 97232
[17:01:01.324] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.324] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.324] Number of futures (= number of chunks): 1
[17:01:01.324] Launching 1 futures (chunks) ...
[17:01:01.324] Chunk #1 of 1 ...
[17:01:01.324]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.324] getGlobalsAndPackages() ...
[17:01:01.324] Searching for globals...
[17:01:01.325] 
[17:01:01.325] Searching for globals ... DONE
[17:01:01.325] - globals: [0] <none>
[17:01:01.325] getGlobalsAndPackages() ... DONE
[17:01:01.325]    + additional globals found: [n=0] 
[17:01:01.325]    + additional namespaces needed: [n=0] 
[17:01:01.325]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.325]  - seeds: <none>
[17:01:01.325]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.326] getGlobalsAndPackages() ...
[17:01:01.326] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.326] Resolving globals: FALSE
[17:01:01.326] Tweak future expression to call with '...' arguments ...
[17:01:01.326] {
[17:01:01.326]     do.call(function(...) {
[17:01:01.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.326]             on.exit(options(oopts), add = TRUE)
[17:01:01.326]         }
[17:01:01.326]         {
[17:01:01.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.326]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.326]             })
[17:01:01.326]         }
[17:01:01.326]     }, args = future.call.arguments)
[17:01:01.326] }
[17:01:01.326] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.327] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.327] - packages: [1] ‘future.apply’
[17:01:01.327] getGlobalsAndPackages() ... DONE
[17:01:01.327] run() for ‘Future’ ...
[17:01:01.327] - state: ‘created’
[17:01:01.327] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.329]   - Field: ‘label’
[17:01:01.330]   - Field: ‘local’
[17:01:01.330]   - Field: ‘owner’
[17:01:01.330]   - Field: ‘envir’
[17:01:01.330]   - Field: ‘packages’
[17:01:01.330]   - Field: ‘gc’
[17:01:01.330]   - Field: ‘conditions’
[17:01:01.330]   - Field: ‘expr’
[17:01:01.330]   - Field: ‘uuid’
[17:01:01.330]   - Field: ‘seed’
[17:01:01.330]   - Field: ‘version’
[17:01:01.331]   - Field: ‘result’
[17:01:01.331]   - Field: ‘asynchronous’
[17:01:01.331]   - Field: ‘calls’
[17:01:01.331]   - Field: ‘globals’
[17:01:01.331]   - Field: ‘stdout’
[17:01:01.331]   - Field: ‘earlySignal’
[17:01:01.331]   - Field: ‘lazy’
[17:01:01.331]   - Field: ‘state’
[17:01:01.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.331] - Launch lazy future ...
[17:01:01.332] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.332] Packages needed by future strategies (n = 0): <none>
[17:01:01.332] {
[17:01:01.332]     {
[17:01:01.332]         {
[17:01:01.332]             ...future.startTime <- base::Sys.time()
[17:01:01.332]             {
[17:01:01.332]                 {
[17:01:01.332]                   {
[17:01:01.332]                     {
[17:01:01.332]                       base::local({
[17:01:01.332]                         has_future <- base::requireNamespace("future", 
[17:01:01.332]                           quietly = TRUE)
[17:01:01.332]                         if (has_future) {
[17:01:01.332]                           ns <- base::getNamespace("future")
[17:01:01.332]                           version <- ns[[".package"]][["version"]]
[17:01:01.332]                           if (is.null(version)) 
[17:01:01.332]                             version <- utils::packageVersion("future")
[17:01:01.332]                         }
[17:01:01.332]                         else {
[17:01:01.332]                           version <- NULL
[17:01:01.332]                         }
[17:01:01.332]                         if (!has_future || version < "1.8.0") {
[17:01:01.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.332]                             "", base::R.version$version.string), 
[17:01:01.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.332]                               "release", "version")], collapse = " "), 
[17:01:01.332]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.332]                             info)
[17:01:01.332]                           info <- base::paste(info, collapse = "; ")
[17:01:01.332]                           if (!has_future) {
[17:01:01.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.332]                               info)
[17:01:01.332]                           }
[17:01:01.332]                           else {
[17:01:01.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.332]                               info, version)
[17:01:01.332]                           }
[17:01:01.332]                           base::stop(msg)
[17:01:01.332]                         }
[17:01:01.332]                       })
[17:01:01.332]                     }
[17:01:01.332]                     base::local({
[17:01:01.332]                       for (pkg in "future.apply") {
[17:01:01.332]                         base::loadNamespace(pkg)
[17:01:01.332]                         base::library(pkg, character.only = TRUE)
[17:01:01.332]                       }
[17:01:01.332]                     })
[17:01:01.332]                   }
[17:01:01.332]                   ...future.strategy.old <- future::plan("list")
[17:01:01.332]                   options(future.plan = NULL)
[17:01:01.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.332]                 }
[17:01:01.332]                 ...future.workdir <- getwd()
[17:01:01.332]             }
[17:01:01.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.332]         }
[17:01:01.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.332]             base::names(...future.oldOptions))
[17:01:01.332]     }
[17:01:01.332]     if (FALSE) {
[17:01:01.332]     }
[17:01:01.332]     else {
[17:01:01.332]         if (TRUE) {
[17:01:01.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.332]                 open = "w")
[17:01:01.332]         }
[17:01:01.332]         else {
[17:01:01.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.332]         }
[17:01:01.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.332]             base::sink(type = "output", split = FALSE)
[17:01:01.332]             base::close(...future.stdout)
[17:01:01.332]         }, add = TRUE)
[17:01:01.332]     }
[17:01:01.332]     ...future.frame <- base::sys.nframe()
[17:01:01.332]     ...future.conditions <- base::list()
[17:01:01.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.332]     if (FALSE) {
[17:01:01.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.332]     }
[17:01:01.332]     ...future.result <- base::tryCatch({
[17:01:01.332]         base::withCallingHandlers({
[17:01:01.332]             ...future.value <- base::withVisible(base::local({
[17:01:01.332]                 do.call(function(...) {
[17:01:01.332]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.332]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.332]                     ...future.globals.maxSize)) {
[17:01:01.332]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.332]                     on.exit(options(oopts), add = TRUE)
[17:01:01.332]                   }
[17:01:01.332]                   {
[17:01:01.332]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.332]                       FUN = function(jj) {
[17:01:01.332]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.332]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.332]                       })
[17:01:01.332]                   }
[17:01:01.332]                 }, args = future.call.arguments)
[17:01:01.332]             }))
[17:01:01.332]             future::FutureResult(value = ...future.value$value, 
[17:01:01.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.332]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.332]                     ...future.globalenv.names))
[17:01:01.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.332]         }, condition = base::local({
[17:01:01.332]             c <- base::c
[17:01:01.332]             inherits <- base::inherits
[17:01:01.332]             invokeRestart <- base::invokeRestart
[17:01:01.332]             length <- base::length
[17:01:01.332]             list <- base::list
[17:01:01.332]             seq.int <- base::seq.int
[17:01:01.332]             signalCondition <- base::signalCondition
[17:01:01.332]             sys.calls <- base::sys.calls
[17:01:01.332]             `[[` <- base::`[[`
[17:01:01.332]             `+` <- base::`+`
[17:01:01.332]             `<<-` <- base::`<<-`
[17:01:01.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.332]                   3L)]
[17:01:01.332]             }
[17:01:01.332]             function(cond) {
[17:01:01.332]                 is_error <- inherits(cond, "error")
[17:01:01.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.332]                   NULL)
[17:01:01.332]                 if (is_error) {
[17:01:01.332]                   sessionInformation <- function() {
[17:01:01.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.332]                       search = base::search(), system = base::Sys.info())
[17:01:01.332]                   }
[17:01:01.332]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.332]                     cond$call), session = sessionInformation(), 
[17:01:01.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.332]                   signalCondition(cond)
[17:01:01.332]                 }
[17:01:01.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.332]                 "immediateCondition"))) {
[17:01:01.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.332]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.332]                   if (TRUE && !signal) {
[17:01:01.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.332]                     {
[17:01:01.332]                       inherits <- base::inherits
[17:01:01.332]                       invokeRestart <- base::invokeRestart
[17:01:01.332]                       is.null <- base::is.null
[17:01:01.332]                       muffled <- FALSE
[17:01:01.332]                       if (inherits(cond, "message")) {
[17:01:01.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.332]                         if (muffled) 
[17:01:01.332]                           invokeRestart("muffleMessage")
[17:01:01.332]                       }
[17:01:01.332]                       else if (inherits(cond, "warning")) {
[17:01:01.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.332]                         if (muffled) 
[17:01:01.332]                           invokeRestart("muffleWarning")
[17:01:01.332]                       }
[17:01:01.332]                       else if (inherits(cond, "condition")) {
[17:01:01.332]                         if (!is.null(pattern)) {
[17:01:01.332]                           computeRestarts <- base::computeRestarts
[17:01:01.332]                           grepl <- base::grepl
[17:01:01.332]                           restarts <- computeRestarts(cond)
[17:01:01.332]                           for (restart in restarts) {
[17:01:01.332]                             name <- restart$name
[17:01:01.332]                             if (is.null(name)) 
[17:01:01.332]                               next
[17:01:01.332]                             if (!grepl(pattern, name)) 
[17:01:01.332]                               next
[17:01:01.332]                             invokeRestart(restart)
[17:01:01.332]                             muffled <- TRUE
[17:01:01.332]                             break
[17:01:01.332]                           }
[17:01:01.332]                         }
[17:01:01.332]                       }
[17:01:01.332]                       invisible(muffled)
[17:01:01.332]                     }
[17:01:01.332]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.332]                   }
[17:01:01.332]                 }
[17:01:01.332]                 else {
[17:01:01.332]                   if (TRUE) {
[17:01:01.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.332]                     {
[17:01:01.332]                       inherits <- base::inherits
[17:01:01.332]                       invokeRestart <- base::invokeRestart
[17:01:01.332]                       is.null <- base::is.null
[17:01:01.332]                       muffled <- FALSE
[17:01:01.332]                       if (inherits(cond, "message")) {
[17:01:01.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.332]                         if (muffled) 
[17:01:01.332]                           invokeRestart("muffleMessage")
[17:01:01.332]                       }
[17:01:01.332]                       else if (inherits(cond, "warning")) {
[17:01:01.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.332]                         if (muffled) 
[17:01:01.332]                           invokeRestart("muffleWarning")
[17:01:01.332]                       }
[17:01:01.332]                       else if (inherits(cond, "condition")) {
[17:01:01.332]                         if (!is.null(pattern)) {
[17:01:01.332]                           computeRestarts <- base::computeRestarts
[17:01:01.332]                           grepl <- base::grepl
[17:01:01.332]                           restarts <- computeRestarts(cond)
[17:01:01.332]                           for (restart in restarts) {
[17:01:01.332]                             name <- restart$name
[17:01:01.332]                             if (is.null(name)) 
[17:01:01.332]                               next
[17:01:01.332]                             if (!grepl(pattern, name)) 
[17:01:01.332]                               next
[17:01:01.332]                             invokeRestart(restart)
[17:01:01.332]                             muffled <- TRUE
[17:01:01.332]                             break
[17:01:01.332]                           }
[17:01:01.332]                         }
[17:01:01.332]                       }
[17:01:01.332]                       invisible(muffled)
[17:01:01.332]                     }
[17:01:01.332]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.332]                   }
[17:01:01.332]                 }
[17:01:01.332]             }
[17:01:01.332]         }))
[17:01:01.332]     }, error = function(ex) {
[17:01:01.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.332]                 ...future.rng), started = ...future.startTime, 
[17:01:01.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.332]             version = "1.8"), class = "FutureResult")
[17:01:01.332]     }, finally = {
[17:01:01.332]         if (!identical(...future.workdir, getwd())) 
[17:01:01.332]             setwd(...future.workdir)
[17:01:01.332]         {
[17:01:01.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.332]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.332]             }
[17:01:01.332]             base::options(...future.oldOptions)
[17:01:01.332]             if (.Platform$OS.type == "windows") {
[17:01:01.332]                 old_names <- names(...future.oldEnvVars)
[17:01:01.332]                 envs <- base::Sys.getenv()
[17:01:01.332]                 names <- names(envs)
[17:01:01.332]                 common <- intersect(names, old_names)
[17:01:01.332]                 added <- setdiff(names, old_names)
[17:01:01.332]                 removed <- setdiff(old_names, names)
[17:01:01.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.332]                   envs[common]]
[17:01:01.332]                 NAMES <- toupper(changed)
[17:01:01.332]                 args <- list()
[17:01:01.332]                 for (kk in seq_along(NAMES)) {
[17:01:01.332]                   name <- changed[[kk]]
[17:01:01.332]                   NAME <- NAMES[[kk]]
[17:01:01.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.332]                     next
[17:01:01.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.332]                 }
[17:01:01.332]                 NAMES <- toupper(added)
[17:01:01.332]                 for (kk in seq_along(NAMES)) {
[17:01:01.332]                   name <- added[[kk]]
[17:01:01.332]                   NAME <- NAMES[[kk]]
[17:01:01.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.332]                     next
[17:01:01.332]                   args[[name]] <- ""
[17:01:01.332]                 }
[17:01:01.332]                 NAMES <- toupper(removed)
[17:01:01.332]                 for (kk in seq_along(NAMES)) {
[17:01:01.332]                   name <- removed[[kk]]
[17:01:01.332]                   NAME <- NAMES[[kk]]
[17:01:01.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.332]                     next
[17:01:01.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.332]                 }
[17:01:01.332]                 if (length(args) > 0) 
[17:01:01.332]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.332]             }
[17:01:01.332]             else {
[17:01:01.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.332]             }
[17:01:01.332]             {
[17:01:01.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.332]                   0L) {
[17:01:01.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.332]                   base::options(opts)
[17:01:01.332]                 }
[17:01:01.332]                 {
[17:01:01.332]                   {
[17:01:01.332]                     NULL
[17:01:01.332]                     RNGkind("Mersenne-Twister")
[17:01:01.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.332]                       inherits = FALSE)
[17:01:01.332]                   }
[17:01:01.332]                   options(future.plan = NULL)
[17:01:01.332]                   if (is.na(NA_character_)) 
[17:01:01.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.332]                     .init = FALSE)
[17:01:01.332]                 }
[17:01:01.332]             }
[17:01:01.332]         }
[17:01:01.332]     })
[17:01:01.332]     if (TRUE) {
[17:01:01.332]         base::sink(type = "output", split = FALSE)
[17:01:01.332]         if (TRUE) {
[17:01:01.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.332]         }
[17:01:01.332]         else {
[17:01:01.332]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.332]         }
[17:01:01.332]         base::close(...future.stdout)
[17:01:01.332]         ...future.stdout <- NULL
[17:01:01.332]     }
[17:01:01.332]     ...future.result$conditions <- ...future.conditions
[17:01:01.332]     ...future.result$finished <- base::Sys.time()
[17:01:01.332]     ...future.result
[17:01:01.332] }
[17:01:01.334] assign_globals() ...
[17:01:01.334] List of 11
[17:01:01.334]  $ ...future.FUN            :function (x, ...)  
[17:01:01.334]  $ x_FUN                    :function (x)  
[17:01:01.334]  $ times                    : int 4
[17:01:01.334]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.334]  $ stop_if_not              :function (...)  
[17:01:01.334]  $ dim                      : int [1:2] 2 2
[17:01:01.334]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:01.334]  $ future.call.arguments    : list()
[17:01:01.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.334]  $ ...future.elements_ii    :List of 10
[17:01:01.334]   ..$ : int 1
[17:01:01.334]   ..$ : int 2
[17:01:01.334]   ..$ : int 3
[17:01:01.334]   ..$ : int 4
[17:01:01.334]   ..$ : int 5
[17:01:01.334]   ..$ : int 6
[17:01:01.334]   ..$ : int 7
[17:01:01.334]   ..$ : int 8
[17:01:01.334]   ..$ : int 9
[17:01:01.334]   ..$ : int 10
[17:01:01.334]  $ ...future.seeds_ii       : NULL
[17:01:01.334]  $ ...future.globals.maxSize: NULL
[17:01:01.334]  - attr(*, "where")=List of 11
[17:01:01.334]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.334]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.334]  - attr(*, "resolved")= logi FALSE
[17:01:01.334]  - attr(*, "total_size")= num 97232
[17:01:01.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.334]  - attr(*, "already-done")= logi TRUE
[17:01:01.344] - copied ‘...future.FUN’ to environment
[17:01:01.344] - reassign environment for ‘x_FUN’
[17:01:01.344] - copied ‘x_FUN’ to environment
[17:01:01.344] - copied ‘times’ to environment
[17:01:01.344] - copied ‘stopf’ to environment
[17:01:01.344] - copied ‘stop_if_not’ to environment
[17:01:01.344] - copied ‘dim’ to environment
[17:01:01.344] - copied ‘valid_types’ to environment
[17:01:01.344] - copied ‘future.call.arguments’ to environment
[17:01:01.345] - copied ‘...future.elements_ii’ to environment
[17:01:01.345] - copied ‘...future.seeds_ii’ to environment
[17:01:01.345] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.345] assign_globals() ... done
[17:01:01.345] plan(): Setting new future strategy stack:
[17:01:01.345] List of future strategies:
[17:01:01.345] 1. sequential:
[17:01:01.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.345]    - tweaked: FALSE
[17:01:01.345]    - call: NULL
[17:01:01.346] plan(): nbrOfWorkers() = 1
[17:01:01.347] plan(): Setting new future strategy stack:
[17:01:01.347] List of future strategies:
[17:01:01.347] 1. sequential:
[17:01:01.347]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.347]    - tweaked: FALSE
[17:01:01.347]    - call: plan(strategy)
[17:01:01.347] plan(): nbrOfWorkers() = 1
[17:01:01.347] SequentialFuture started (and completed)
[17:01:01.347] - Launch lazy future ... done
[17:01:01.348] run() for ‘SequentialFuture’ ... done
[17:01:01.348] Created future:
[17:01:01.348] SequentialFuture:
[17:01:01.348] Label: ‘future_vapply-1’
[17:01:01.348] Expression:
[17:01:01.348] {
[17:01:01.348]     do.call(function(...) {
[17:01:01.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.348]             on.exit(options(oopts), add = TRUE)
[17:01:01.348]         }
[17:01:01.348]         {
[17:01:01.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.348]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.348]             })
[17:01:01.348]         }
[17:01:01.348]     }, args = future.call.arguments)
[17:01:01.348] }
[17:01:01.348] Lazy evaluation: FALSE
[17:01:01.348] Asynchronous evaluation: FALSE
[17:01:01.348] Local evaluation: TRUE
[17:01:01.348] Environment: R_GlobalEnv
[17:01:01.348] Capture standard output: TRUE
[17:01:01.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.348] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.348] Packages: 1 packages (‘future.apply’)
[17:01:01.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.348] Resolved: TRUE
[17:01:01.348] Value: 2.27 KiB of class ‘list’
[17:01:01.348] Early signaling: FALSE
[17:01:01.348] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.348] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.349] Chunk #1 of 1 ... DONE
[17:01:01.349] Launching 1 futures (chunks) ... DONE
[17:01:01.349] Resolving 1 futures (chunks) ...
[17:01:01.349] resolve() on list ...
[17:01:01.349]  recursive: 0
[17:01:01.349]  length: 1
[17:01:01.350] 
[17:01:01.350] resolved() for ‘SequentialFuture’ ...
[17:01:01.350] - state: ‘finished’
[17:01:01.350] - run: TRUE
[17:01:01.350] - result: ‘FutureResult’
[17:01:01.350] resolved() for ‘SequentialFuture’ ... done
[17:01:01.350] Future #1
[17:01:01.350] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.350] - nx: 1
[17:01:01.350] - relay: TRUE
[17:01:01.351] - stdout: TRUE
[17:01:01.351] - signal: TRUE
[17:01:01.351] - resignal: FALSE
[17:01:01.351] - force: TRUE
[17:01:01.351] - relayed: [n=1] FALSE
[17:01:01.351] - queued futures: [n=1] FALSE
[17:01:01.351]  - until=1
[17:01:01.351]  - relaying element #1
[17:01:01.351] - relayed: [n=1] TRUE
[17:01:01.351] - queued futures: [n=1] TRUE
[17:01:01.352] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.352]  length: 0 (resolved future 1)
[17:01:01.352] Relaying remaining futures
[17:01:01.352] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.354] - nx: 1
[17:01:01.354] - relay: TRUE
[17:01:01.354] - stdout: TRUE
[17:01:01.354] - signal: TRUE
[17:01:01.354] - resignal: FALSE
[17:01:01.354] - force: TRUE
[17:01:01.354] - relayed: [n=1] TRUE
[17:01:01.354] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.354] - relayed: [n=1] TRUE
[17:01:01.354] - queued futures: [n=1] TRUE
[17:01:01.354] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.355] resolve() on list ... DONE
[17:01:01.355]  - Number of value chunks collected: 1
[17:01:01.355] Resolving 1 futures (chunks) ... DONE
[17:01:01.355] Reducing values from 1 chunks ...
[17:01:01.355]  - Number of values collected after concatenation: 10
[17:01:01.355]  - Number of values expected: 10
[17:01:01.355] Reducing values from 1 chunks ... DONE
[17:01:01.355] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:01.356] future_lapply() ...
[17:01:01.358] Number of chunks: 1
[17:01:01.358] getGlobalsAndPackagesXApply() ...
[17:01:01.358]  - future.globals: TRUE
[17:01:01.358] getGlobalsAndPackages() ...
[17:01:01.358] Searching for globals...
[17:01:01.362] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:01.362] Searching for globals ... DONE
[17:01:01.362] Resolving globals: FALSE
[17:01:01.363] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:01:01.363] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.363] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.363] - packages: [1] ‘future.apply’
[17:01:01.363] getGlobalsAndPackages() ... DONE
[17:01:01.364]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.364]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.364] Finding globals ... DONE
[17:01:01.364]  - use_args: TRUE
[17:01:01.364]  - Getting '...' globals ...
[17:01:01.364] resolve() on list ...
[17:01:01.364]  recursive: 0
[17:01:01.364]  length: 1
[17:01:01.364]  elements: ‘...’
[17:01:01.365]  length: 0 (resolved future 1)
[17:01:01.365] resolve() on list ... DONE
[17:01:01.365]    - '...' content: [n=0] 
[17:01:01.365] List of 1
[17:01:01.365]  $ ...: list()
[17:01:01.365]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.365]  - attr(*, "where")=List of 1
[17:01:01.365]   ..$ ...:<environment: 0x55aad9200a90> 
[17:01:01.365]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.365]  - attr(*, "resolved")= logi TRUE
[17:01:01.365]  - attr(*, "total_size")= num NA
[17:01:01.367]  - Getting '...' globals ... DONE
[17:01:01.368] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.368] List of 8
[17:01:01.368]  $ ...future.FUN:function (x, ...)  
[17:01:01.368]  $ x_FUN        :function (x)  
[17:01:01.368]  $ times        : int 4
[17:01:01.368]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.368]  $ stop_if_not  :function (...)  
[17:01:01.368]  $ dim          : int [1:2] 2 2
[17:01:01.368]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.368]  $ ...          : list()
[17:01:01.368]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.368]  - attr(*, "where")=List of 8
[17:01:01.368]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.368]   ..$ ...          :<environment: 0x55aad9200a90> 
[17:01:01.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.368]  - attr(*, "resolved")= logi FALSE
[17:01:01.368]  - attr(*, "total_size")= num 97304
[17:01:01.373] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.373] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.373] Number of futures (= number of chunks): 1
[17:01:01.373] Launching 1 futures (chunks) ...
[17:01:01.373] Chunk #1 of 1 ...
[17:01:01.374]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.374] getGlobalsAndPackages() ...
[17:01:01.374] Searching for globals...
[17:01:01.376] 
[17:01:01.376] Searching for globals ... DONE
[17:01:01.376] - globals: [0] <none>
[17:01:01.376] getGlobalsAndPackages() ... DONE
[17:01:01.376]    + additional globals found: [n=0] 
[17:01:01.376]    + additional namespaces needed: [n=0] 
[17:01:01.376]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.376]  - seeds: <none>
[17:01:01.376]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.376] getGlobalsAndPackages() ...
[17:01:01.377] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.377] Resolving globals: FALSE
[17:01:01.377] Tweak future expression to call with '...' arguments ...
[17:01:01.377] {
[17:01:01.377]     do.call(function(...) {
[17:01:01.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.377]             on.exit(options(oopts), add = TRUE)
[17:01:01.377]         }
[17:01:01.377]         {
[17:01:01.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.377]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.377]             })
[17:01:01.377]         }
[17:01:01.377]     }, args = future.call.arguments)
[17:01:01.377] }
[17:01:01.377] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.378] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.378] - packages: [1] ‘future.apply’
[17:01:01.378] getGlobalsAndPackages() ... DONE
[17:01:01.378] run() for ‘Future’ ...
[17:01:01.378] - state: ‘created’
[17:01:01.378] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.379] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.379] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.379]   - Field: ‘label’
[17:01:01.379]   - Field: ‘local’
[17:01:01.379]   - Field: ‘owner’
[17:01:01.379]   - Field: ‘envir’
[17:01:01.379]   - Field: ‘packages’
[17:01:01.379]   - Field: ‘gc’
[17:01:01.379]   - Field: ‘conditions’
[17:01:01.380]   - Field: ‘expr’
[17:01:01.380]   - Field: ‘uuid’
[17:01:01.380]   - Field: ‘seed’
[17:01:01.380]   - Field: ‘version’
[17:01:01.380]   - Field: ‘result’
[17:01:01.380]   - Field: ‘asynchronous’
[17:01:01.380]   - Field: ‘calls’
[17:01:01.380]   - Field: ‘globals’
[17:01:01.380]   - Field: ‘stdout’
[17:01:01.380]   - Field: ‘earlySignal’
[17:01:01.380]   - Field: ‘lazy’
[17:01:01.381]   - Field: ‘state’
[17:01:01.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.381] - Launch lazy future ...
[17:01:01.381] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.381] Packages needed by future strategies (n = 0): <none>
[17:01:01.382] {
[17:01:01.382]     {
[17:01:01.382]         {
[17:01:01.382]             ...future.startTime <- base::Sys.time()
[17:01:01.382]             {
[17:01:01.382]                 {
[17:01:01.382]                   {
[17:01:01.382]                     {
[17:01:01.382]                       base::local({
[17:01:01.382]                         has_future <- base::requireNamespace("future", 
[17:01:01.382]                           quietly = TRUE)
[17:01:01.382]                         if (has_future) {
[17:01:01.382]                           ns <- base::getNamespace("future")
[17:01:01.382]                           version <- ns[[".package"]][["version"]]
[17:01:01.382]                           if (is.null(version)) 
[17:01:01.382]                             version <- utils::packageVersion("future")
[17:01:01.382]                         }
[17:01:01.382]                         else {
[17:01:01.382]                           version <- NULL
[17:01:01.382]                         }
[17:01:01.382]                         if (!has_future || version < "1.8.0") {
[17:01:01.382]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.382]                             "", base::R.version$version.string), 
[17:01:01.382]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.382]                               "release", "version")], collapse = " "), 
[17:01:01.382]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.382]                             info)
[17:01:01.382]                           info <- base::paste(info, collapse = "; ")
[17:01:01.382]                           if (!has_future) {
[17:01:01.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.382]                               info)
[17:01:01.382]                           }
[17:01:01.382]                           else {
[17:01:01.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.382]                               info, version)
[17:01:01.382]                           }
[17:01:01.382]                           base::stop(msg)
[17:01:01.382]                         }
[17:01:01.382]                       })
[17:01:01.382]                     }
[17:01:01.382]                     base::local({
[17:01:01.382]                       for (pkg in "future.apply") {
[17:01:01.382]                         base::loadNamespace(pkg)
[17:01:01.382]                         base::library(pkg, character.only = TRUE)
[17:01:01.382]                       }
[17:01:01.382]                     })
[17:01:01.382]                   }
[17:01:01.382]                   ...future.strategy.old <- future::plan("list")
[17:01:01.382]                   options(future.plan = NULL)
[17:01:01.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.382]                 }
[17:01:01.382]                 ...future.workdir <- getwd()
[17:01:01.382]             }
[17:01:01.382]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.382]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.382]         }
[17:01:01.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.382]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.382]             base::names(...future.oldOptions))
[17:01:01.382]     }
[17:01:01.382]     if (FALSE) {
[17:01:01.382]     }
[17:01:01.382]     else {
[17:01:01.382]         if (TRUE) {
[17:01:01.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.382]                 open = "w")
[17:01:01.382]         }
[17:01:01.382]         else {
[17:01:01.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.382]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.382]         }
[17:01:01.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.382]             base::sink(type = "output", split = FALSE)
[17:01:01.382]             base::close(...future.stdout)
[17:01:01.382]         }, add = TRUE)
[17:01:01.382]     }
[17:01:01.382]     ...future.frame <- base::sys.nframe()
[17:01:01.382]     ...future.conditions <- base::list()
[17:01:01.382]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.382]     if (FALSE) {
[17:01:01.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.382]     }
[17:01:01.382]     ...future.result <- base::tryCatch({
[17:01:01.382]         base::withCallingHandlers({
[17:01:01.382]             ...future.value <- base::withVisible(base::local({
[17:01:01.382]                 do.call(function(...) {
[17:01:01.382]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.382]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.382]                     ...future.globals.maxSize)) {
[17:01:01.382]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.382]                     on.exit(options(oopts), add = TRUE)
[17:01:01.382]                   }
[17:01:01.382]                   {
[17:01:01.382]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.382]                       FUN = function(jj) {
[17:01:01.382]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.382]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.382]                       })
[17:01:01.382]                   }
[17:01:01.382]                 }, args = future.call.arguments)
[17:01:01.382]             }))
[17:01:01.382]             future::FutureResult(value = ...future.value$value, 
[17:01:01.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.382]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.382]                     ...future.globalenv.names))
[17:01:01.382]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.382]         }, condition = base::local({
[17:01:01.382]             c <- base::c
[17:01:01.382]             inherits <- base::inherits
[17:01:01.382]             invokeRestart <- base::invokeRestart
[17:01:01.382]             length <- base::length
[17:01:01.382]             list <- base::list
[17:01:01.382]             seq.int <- base::seq.int
[17:01:01.382]             signalCondition <- base::signalCondition
[17:01:01.382]             sys.calls <- base::sys.calls
[17:01:01.382]             `[[` <- base::`[[`
[17:01:01.382]             `+` <- base::`+`
[17:01:01.382]             `<<-` <- base::`<<-`
[17:01:01.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.382]                   3L)]
[17:01:01.382]             }
[17:01:01.382]             function(cond) {
[17:01:01.382]                 is_error <- inherits(cond, "error")
[17:01:01.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.382]                   NULL)
[17:01:01.382]                 if (is_error) {
[17:01:01.382]                   sessionInformation <- function() {
[17:01:01.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.382]                       search = base::search(), system = base::Sys.info())
[17:01:01.382]                   }
[17:01:01.382]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.382]                     cond$call), session = sessionInformation(), 
[17:01:01.382]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.382]                   signalCondition(cond)
[17:01:01.382]                 }
[17:01:01.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.382]                 "immediateCondition"))) {
[17:01:01.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.382]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.382]                   if (TRUE && !signal) {
[17:01:01.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.382]                     {
[17:01:01.382]                       inherits <- base::inherits
[17:01:01.382]                       invokeRestart <- base::invokeRestart
[17:01:01.382]                       is.null <- base::is.null
[17:01:01.382]                       muffled <- FALSE
[17:01:01.382]                       if (inherits(cond, "message")) {
[17:01:01.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.382]                         if (muffled) 
[17:01:01.382]                           invokeRestart("muffleMessage")
[17:01:01.382]                       }
[17:01:01.382]                       else if (inherits(cond, "warning")) {
[17:01:01.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.382]                         if (muffled) 
[17:01:01.382]                           invokeRestart("muffleWarning")
[17:01:01.382]                       }
[17:01:01.382]                       else if (inherits(cond, "condition")) {
[17:01:01.382]                         if (!is.null(pattern)) {
[17:01:01.382]                           computeRestarts <- base::computeRestarts
[17:01:01.382]                           grepl <- base::grepl
[17:01:01.382]                           restarts <- computeRestarts(cond)
[17:01:01.382]                           for (restart in restarts) {
[17:01:01.382]                             name <- restart$name
[17:01:01.382]                             if (is.null(name)) 
[17:01:01.382]                               next
[17:01:01.382]                             if (!grepl(pattern, name)) 
[17:01:01.382]                               next
[17:01:01.382]                             invokeRestart(restart)
[17:01:01.382]                             muffled <- TRUE
[17:01:01.382]                             break
[17:01:01.382]                           }
[17:01:01.382]                         }
[17:01:01.382]                       }
[17:01:01.382]                       invisible(muffled)
[17:01:01.382]                     }
[17:01:01.382]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.382]                   }
[17:01:01.382]                 }
[17:01:01.382]                 else {
[17:01:01.382]                   if (TRUE) {
[17:01:01.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.382]                     {
[17:01:01.382]                       inherits <- base::inherits
[17:01:01.382]                       invokeRestart <- base::invokeRestart
[17:01:01.382]                       is.null <- base::is.null
[17:01:01.382]                       muffled <- FALSE
[17:01:01.382]                       if (inherits(cond, "message")) {
[17:01:01.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.382]                         if (muffled) 
[17:01:01.382]                           invokeRestart("muffleMessage")
[17:01:01.382]                       }
[17:01:01.382]                       else if (inherits(cond, "warning")) {
[17:01:01.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.382]                         if (muffled) 
[17:01:01.382]                           invokeRestart("muffleWarning")
[17:01:01.382]                       }
[17:01:01.382]                       else if (inherits(cond, "condition")) {
[17:01:01.382]                         if (!is.null(pattern)) {
[17:01:01.382]                           computeRestarts <- base::computeRestarts
[17:01:01.382]                           grepl <- base::grepl
[17:01:01.382]                           restarts <- computeRestarts(cond)
[17:01:01.382]                           for (restart in restarts) {
[17:01:01.382]                             name <- restart$name
[17:01:01.382]                             if (is.null(name)) 
[17:01:01.382]                               next
[17:01:01.382]                             if (!grepl(pattern, name)) 
[17:01:01.382]                               next
[17:01:01.382]                             invokeRestart(restart)
[17:01:01.382]                             muffled <- TRUE
[17:01:01.382]                             break
[17:01:01.382]                           }
[17:01:01.382]                         }
[17:01:01.382]                       }
[17:01:01.382]                       invisible(muffled)
[17:01:01.382]                     }
[17:01:01.382]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.382]                   }
[17:01:01.382]                 }
[17:01:01.382]             }
[17:01:01.382]         }))
[17:01:01.382]     }, error = function(ex) {
[17:01:01.382]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.382]                 ...future.rng), started = ...future.startTime, 
[17:01:01.382]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.382]             version = "1.8"), class = "FutureResult")
[17:01:01.382]     }, finally = {
[17:01:01.382]         if (!identical(...future.workdir, getwd())) 
[17:01:01.382]             setwd(...future.workdir)
[17:01:01.382]         {
[17:01:01.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.382]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.382]             }
[17:01:01.382]             base::options(...future.oldOptions)
[17:01:01.382]             if (.Platform$OS.type == "windows") {
[17:01:01.382]                 old_names <- names(...future.oldEnvVars)
[17:01:01.382]                 envs <- base::Sys.getenv()
[17:01:01.382]                 names <- names(envs)
[17:01:01.382]                 common <- intersect(names, old_names)
[17:01:01.382]                 added <- setdiff(names, old_names)
[17:01:01.382]                 removed <- setdiff(old_names, names)
[17:01:01.382]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.382]                   envs[common]]
[17:01:01.382]                 NAMES <- toupper(changed)
[17:01:01.382]                 args <- list()
[17:01:01.382]                 for (kk in seq_along(NAMES)) {
[17:01:01.382]                   name <- changed[[kk]]
[17:01:01.382]                   NAME <- NAMES[[kk]]
[17:01:01.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.382]                     next
[17:01:01.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.382]                 }
[17:01:01.382]                 NAMES <- toupper(added)
[17:01:01.382]                 for (kk in seq_along(NAMES)) {
[17:01:01.382]                   name <- added[[kk]]
[17:01:01.382]                   NAME <- NAMES[[kk]]
[17:01:01.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.382]                     next
[17:01:01.382]                   args[[name]] <- ""
[17:01:01.382]                 }
[17:01:01.382]                 NAMES <- toupper(removed)
[17:01:01.382]                 for (kk in seq_along(NAMES)) {
[17:01:01.382]                   name <- removed[[kk]]
[17:01:01.382]                   NAME <- NAMES[[kk]]
[17:01:01.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.382]                     next
[17:01:01.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.382]                 }
[17:01:01.382]                 if (length(args) > 0) 
[17:01:01.382]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.382]             }
[17:01:01.382]             else {
[17:01:01.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.382]             }
[17:01:01.382]             {
[17:01:01.382]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.382]                   0L) {
[17:01:01.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.382]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.382]                   base::options(opts)
[17:01:01.382]                 }
[17:01:01.382]                 {
[17:01:01.382]                   {
[17:01:01.382]                     NULL
[17:01:01.382]                     RNGkind("Mersenne-Twister")
[17:01:01.382]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.382]                       inherits = FALSE)
[17:01:01.382]                   }
[17:01:01.382]                   options(future.plan = NULL)
[17:01:01.382]                   if (is.na(NA_character_)) 
[17:01:01.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.382]                     .init = FALSE)
[17:01:01.382]                 }
[17:01:01.382]             }
[17:01:01.382]         }
[17:01:01.382]     })
[17:01:01.382]     if (TRUE) {
[17:01:01.382]         base::sink(type = "output", split = FALSE)
[17:01:01.382]         if (TRUE) {
[17:01:01.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.382]         }
[17:01:01.382]         else {
[17:01:01.382]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.382]         }
[17:01:01.382]         base::close(...future.stdout)
[17:01:01.382]         ...future.stdout <- NULL
[17:01:01.382]     }
[17:01:01.382]     ...future.result$conditions <- ...future.conditions
[17:01:01.382]     ...future.result$finished <- base::Sys.time()
[17:01:01.382]     ...future.result
[17:01:01.382] }
[17:01:01.383] assign_globals() ...
[17:01:01.383] List of 11
[17:01:01.383]  $ ...future.FUN            :function (x, ...)  
[17:01:01.383]  $ x_FUN                    :function (x)  
[17:01:01.383]  $ times                    : int 4
[17:01:01.383]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.383]  $ stop_if_not              :function (...)  
[17:01:01.383]  $ dim                      : int [1:2] 2 2
[17:01:01.383]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.383]  $ future.call.arguments    : list()
[17:01:01.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.383]  $ ...future.elements_ii    :List of 10
[17:01:01.383]   ..$ : int 1
[17:01:01.383]   ..$ : int 2
[17:01:01.383]   ..$ : int 3
[17:01:01.383]   ..$ : int 4
[17:01:01.383]   ..$ : int 5
[17:01:01.383]   ..$ : int 6
[17:01:01.383]   ..$ : int 7
[17:01:01.383]   ..$ : int 8
[17:01:01.383]   ..$ : int 9
[17:01:01.383]   ..$ : int 10
[17:01:01.383]  $ ...future.seeds_ii       : NULL
[17:01:01.383]  $ ...future.globals.maxSize: NULL
[17:01:01.383]  - attr(*, "where")=List of 11
[17:01:01.383]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.383]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.383]  - attr(*, "resolved")= logi FALSE
[17:01:01.383]  - attr(*, "total_size")= num 97304
[17:01:01.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.383]  - attr(*, "already-done")= logi TRUE
[17:01:01.393] - copied ‘...future.FUN’ to environment
[17:01:01.393] - reassign environment for ‘x_FUN’
[17:01:01.393] - copied ‘x_FUN’ to environment
[17:01:01.393] - copied ‘times’ to environment
[17:01:01.393] - copied ‘stopf’ to environment
[17:01:01.393] - copied ‘stop_if_not’ to environment
[17:01:01.394] - copied ‘dim’ to environment
[17:01:01.394] - copied ‘valid_types’ to environment
[17:01:01.394] - copied ‘future.call.arguments’ to environment
[17:01:01.394] - copied ‘...future.elements_ii’ to environment
[17:01:01.394] - copied ‘...future.seeds_ii’ to environment
[17:01:01.394] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.394] assign_globals() ... done
[17:01:01.394] plan(): Setting new future strategy stack:
[17:01:01.395] List of future strategies:
[17:01:01.395] 1. sequential:
[17:01:01.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.395]    - tweaked: FALSE
[17:01:01.395]    - call: NULL
[17:01:01.395] plan(): nbrOfWorkers() = 1
[17:01:01.396] plan(): Setting new future strategy stack:
[17:01:01.396] List of future strategies:
[17:01:01.396] 1. sequential:
[17:01:01.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.396]    - tweaked: FALSE
[17:01:01.396]    - call: plan(strategy)
[17:01:01.396] plan(): nbrOfWorkers() = 1
[17:01:01.397] SequentialFuture started (and completed)
[17:01:01.397] - Launch lazy future ... done
[17:01:01.397] run() for ‘SequentialFuture’ ... done
[17:01:01.397] Created future:
[17:01:01.397] SequentialFuture:
[17:01:01.397] Label: ‘future_vapply-1’
[17:01:01.397] Expression:
[17:01:01.397] {
[17:01:01.397]     do.call(function(...) {
[17:01:01.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.397]             on.exit(options(oopts), add = TRUE)
[17:01:01.397]         }
[17:01:01.397]         {
[17:01:01.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.397]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.397]             })
[17:01:01.397]         }
[17:01:01.397]     }, args = future.call.arguments)
[17:01:01.397] }
[17:01:01.397] Lazy evaluation: FALSE
[17:01:01.397] Asynchronous evaluation: FALSE
[17:01:01.397] Local evaluation: TRUE
[17:01:01.397] Environment: R_GlobalEnv
[17:01:01.397] Capture standard output: TRUE
[17:01:01.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.397] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.397] Packages: 1 packages (‘future.apply’)
[17:01:01.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.397] Resolved: TRUE
[17:01:01.397] Value: 2.27 KiB of class ‘list’
[17:01:01.397] Early signaling: FALSE
[17:01:01.397] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.397] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.400] Chunk #1 of 1 ... DONE
[17:01:01.400] Launching 1 futures (chunks) ... DONE
[17:01:01.400] Resolving 1 futures (chunks) ...
[17:01:01.400] resolve() on list ...
[17:01:01.400]  recursive: 0
[17:01:01.400]  length: 1
[17:01:01.401] 
[17:01:01.401] resolved() for ‘SequentialFuture’ ...
[17:01:01.401] - state: ‘finished’
[17:01:01.401] - run: TRUE
[17:01:01.401] - result: ‘FutureResult’
[17:01:01.401] resolved() for ‘SequentialFuture’ ... done
[17:01:01.401] Future #1
[17:01:01.401] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.401] - nx: 1
[17:01:01.401] - relay: TRUE
[17:01:01.401] - stdout: TRUE
[17:01:01.402] - signal: TRUE
[17:01:01.402] - resignal: FALSE
[17:01:01.402] - force: TRUE
[17:01:01.402] - relayed: [n=1] FALSE
[17:01:01.402] - queued futures: [n=1] FALSE
[17:01:01.402]  - until=1
[17:01:01.402]  - relaying element #1
[17:01:01.402] - relayed: [n=1] TRUE
[17:01:01.402] - queued futures: [n=1] TRUE
[17:01:01.402] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.403]  length: 0 (resolved future 1)
[17:01:01.403] Relaying remaining futures
[17:01:01.403] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.403] - nx: 1
[17:01:01.403] - relay: TRUE
[17:01:01.403] - stdout: TRUE
[17:01:01.403] - signal: TRUE
[17:01:01.403] - resignal: FALSE
[17:01:01.403] - force: TRUE
[17:01:01.403] - relayed: [n=1] TRUE
[17:01:01.403] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.404] - relayed: [n=1] TRUE
[17:01:01.404] - queued futures: [n=1] TRUE
[17:01:01.404] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.404] resolve() on list ... DONE
[17:01:01.404]  - Number of value chunks collected: 1
[17:01:01.404] Resolving 1 futures (chunks) ... DONE
[17:01:01.404] Reducing values from 1 chunks ...
[17:01:01.404]  - Number of values collected after concatenation: 10
[17:01:01.404]  - Number of values expected: 10
[17:01:01.404] Reducing values from 1 chunks ... DONE
[17:01:01.404] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:01:01.406] future_lapply() ...
[17:01:01.408] Number of chunks: 1
[17:01:01.408] getGlobalsAndPackagesXApply() ...
[17:01:01.408]  - future.globals: TRUE
[17:01:01.408] getGlobalsAndPackages() ...
[17:01:01.408] Searching for globals...
[17:01:01.412] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:01:01.412] Searching for globals ... DONE
[17:01:01.412] Resolving globals: FALSE
[17:01:01.413] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:01:01.414] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.414] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.414] - packages: [1] ‘future.apply’
[17:01:01.414] getGlobalsAndPackages() ... DONE
[17:01:01.414]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.414]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.414] Finding globals ... DONE
[17:01:01.414]  - use_args: TRUE
[17:01:01.415]  - Getting '...' globals ...
[17:01:01.415] resolve() on list ...
[17:01:01.415]  recursive: 0
[17:01:01.415]  length: 1
[17:01:01.415]  elements: ‘...’
[17:01:01.415]  length: 0 (resolved future 1)
[17:01:01.415] resolve() on list ... DONE
[17:01:01.415]    - '...' content: [n=0] 
[17:01:01.416] List of 1
[17:01:01.416]  $ ...: list()
[17:01:01.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.416]  - attr(*, "where")=List of 1
[17:01:01.416]   ..$ ...:<environment: 0x55aad9c1a678> 
[17:01:01.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.416]  - attr(*, "resolved")= logi TRUE
[17:01:01.416]  - attr(*, "total_size")= num NA
[17:01:01.418]  - Getting '...' globals ... DONE
[17:01:01.418] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.418] List of 8
[17:01:01.418]  $ ...future.FUN:function (x, ...)  
[17:01:01.418]  $ x_FUN        :function (x)  
[17:01:01.418]  $ times        : int 4
[17:01:01.418]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.418]  $ stop_if_not  :function (...)  
[17:01:01.418]  $ dim          : int [1:2] 2 2
[17:01:01.418]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.418]  $ ...          : list()
[17:01:01.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.418]  - attr(*, "where")=List of 8
[17:01:01.418]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.418]   ..$ ...          :<environment: 0x55aad9c1a678> 
[17:01:01.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.418]  - attr(*, "resolved")= logi FALSE
[17:01:01.418]  - attr(*, "total_size")= num 105552
[17:01:01.453] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.453] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.453] Number of futures (= number of chunks): 1
[17:01:01.453] Launching 1 futures (chunks) ...
[17:01:01.453] Chunk #1 of 1 ...
[17:01:01.454]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.454] getGlobalsAndPackages() ...
[17:01:01.454] Searching for globals...
[17:01:01.454] 
[17:01:01.454] Searching for globals ... DONE
[17:01:01.454] - globals: [0] <none>
[17:01:01.454] getGlobalsAndPackages() ... DONE
[17:01:01.454]    + additional globals found: [n=0] 
[17:01:01.454]    + additional namespaces needed: [n=0] 
[17:01:01.454]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.455]  - seeds: <none>
[17:01:01.455]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.455] getGlobalsAndPackages() ...
[17:01:01.455] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.455] Resolving globals: FALSE
[17:01:01.455] Tweak future expression to call with '...' arguments ...
[17:01:01.455] {
[17:01:01.455]     do.call(function(...) {
[17:01:01.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.455]             on.exit(options(oopts), add = TRUE)
[17:01:01.455]         }
[17:01:01.455]         {
[17:01:01.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.455]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.455]             })
[17:01:01.455]         }
[17:01:01.455]     }, args = future.call.arguments)
[17:01:01.455] }
[17:01:01.455] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.456] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.456] - packages: [1] ‘future.apply’
[17:01:01.456] getGlobalsAndPackages() ... DONE
[17:01:01.457] run() for ‘Future’ ...
[17:01:01.457] - state: ‘created’
[17:01:01.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.457]   - Field: ‘label’
[17:01:01.457]   - Field: ‘local’
[17:01:01.457]   - Field: ‘owner’
[17:01:01.458]   - Field: ‘envir’
[17:01:01.458]   - Field: ‘packages’
[17:01:01.458]   - Field: ‘gc’
[17:01:01.458]   - Field: ‘conditions’
[17:01:01.458]   - Field: ‘expr’
[17:01:01.458]   - Field: ‘uuid’
[17:01:01.458]   - Field: ‘seed’
[17:01:01.458]   - Field: ‘version’
[17:01:01.458]   - Field: ‘result’
[17:01:01.458]   - Field: ‘asynchronous’
[17:01:01.458]   - Field: ‘calls’
[17:01:01.459]   - Field: ‘globals’
[17:01:01.459]   - Field: ‘stdout’
[17:01:01.459]   - Field: ‘earlySignal’
[17:01:01.459]   - Field: ‘lazy’
[17:01:01.459]   - Field: ‘state’
[17:01:01.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.459] - Launch lazy future ...
[17:01:01.459] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.459] Packages needed by future strategies (n = 0): <none>
[17:01:01.460] {
[17:01:01.460]     {
[17:01:01.460]         {
[17:01:01.460]             ...future.startTime <- base::Sys.time()
[17:01:01.460]             {
[17:01:01.460]                 {
[17:01:01.460]                   {
[17:01:01.460]                     {
[17:01:01.460]                       base::local({
[17:01:01.460]                         has_future <- base::requireNamespace("future", 
[17:01:01.460]                           quietly = TRUE)
[17:01:01.460]                         if (has_future) {
[17:01:01.460]                           ns <- base::getNamespace("future")
[17:01:01.460]                           version <- ns[[".package"]][["version"]]
[17:01:01.460]                           if (is.null(version)) 
[17:01:01.460]                             version <- utils::packageVersion("future")
[17:01:01.460]                         }
[17:01:01.460]                         else {
[17:01:01.460]                           version <- NULL
[17:01:01.460]                         }
[17:01:01.460]                         if (!has_future || version < "1.8.0") {
[17:01:01.460]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.460]                             "", base::R.version$version.string), 
[17:01:01.460]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.460]                               "release", "version")], collapse = " "), 
[17:01:01.460]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.460]                             info)
[17:01:01.460]                           info <- base::paste(info, collapse = "; ")
[17:01:01.460]                           if (!has_future) {
[17:01:01.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.460]                               info)
[17:01:01.460]                           }
[17:01:01.460]                           else {
[17:01:01.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.460]                               info, version)
[17:01:01.460]                           }
[17:01:01.460]                           base::stop(msg)
[17:01:01.460]                         }
[17:01:01.460]                       })
[17:01:01.460]                     }
[17:01:01.460]                     base::local({
[17:01:01.460]                       for (pkg in "future.apply") {
[17:01:01.460]                         base::loadNamespace(pkg)
[17:01:01.460]                         base::library(pkg, character.only = TRUE)
[17:01:01.460]                       }
[17:01:01.460]                     })
[17:01:01.460]                   }
[17:01:01.460]                   ...future.strategy.old <- future::plan("list")
[17:01:01.460]                   options(future.plan = NULL)
[17:01:01.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.460]                 }
[17:01:01.460]                 ...future.workdir <- getwd()
[17:01:01.460]             }
[17:01:01.460]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.460]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.460]         }
[17:01:01.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.460]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.460]             base::names(...future.oldOptions))
[17:01:01.460]     }
[17:01:01.460]     if (FALSE) {
[17:01:01.460]     }
[17:01:01.460]     else {
[17:01:01.460]         if (TRUE) {
[17:01:01.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.460]                 open = "w")
[17:01:01.460]         }
[17:01:01.460]         else {
[17:01:01.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.460]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.460]         }
[17:01:01.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.460]             base::sink(type = "output", split = FALSE)
[17:01:01.460]             base::close(...future.stdout)
[17:01:01.460]         }, add = TRUE)
[17:01:01.460]     }
[17:01:01.460]     ...future.frame <- base::sys.nframe()
[17:01:01.460]     ...future.conditions <- base::list()
[17:01:01.460]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.460]     if (FALSE) {
[17:01:01.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.460]     }
[17:01:01.460]     ...future.result <- base::tryCatch({
[17:01:01.460]         base::withCallingHandlers({
[17:01:01.460]             ...future.value <- base::withVisible(base::local({
[17:01:01.460]                 do.call(function(...) {
[17:01:01.460]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.460]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.460]                     ...future.globals.maxSize)) {
[17:01:01.460]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.460]                     on.exit(options(oopts), add = TRUE)
[17:01:01.460]                   }
[17:01:01.460]                   {
[17:01:01.460]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.460]                       FUN = function(jj) {
[17:01:01.460]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.460]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.460]                       })
[17:01:01.460]                   }
[17:01:01.460]                 }, args = future.call.arguments)
[17:01:01.460]             }))
[17:01:01.460]             future::FutureResult(value = ...future.value$value, 
[17:01:01.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.460]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.460]                     ...future.globalenv.names))
[17:01:01.460]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.460]         }, condition = base::local({
[17:01:01.460]             c <- base::c
[17:01:01.460]             inherits <- base::inherits
[17:01:01.460]             invokeRestart <- base::invokeRestart
[17:01:01.460]             length <- base::length
[17:01:01.460]             list <- base::list
[17:01:01.460]             seq.int <- base::seq.int
[17:01:01.460]             signalCondition <- base::signalCondition
[17:01:01.460]             sys.calls <- base::sys.calls
[17:01:01.460]             `[[` <- base::`[[`
[17:01:01.460]             `+` <- base::`+`
[17:01:01.460]             `<<-` <- base::`<<-`
[17:01:01.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.460]                   3L)]
[17:01:01.460]             }
[17:01:01.460]             function(cond) {
[17:01:01.460]                 is_error <- inherits(cond, "error")
[17:01:01.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.460]                   NULL)
[17:01:01.460]                 if (is_error) {
[17:01:01.460]                   sessionInformation <- function() {
[17:01:01.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.460]                       search = base::search(), system = base::Sys.info())
[17:01:01.460]                   }
[17:01:01.460]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.460]                     cond$call), session = sessionInformation(), 
[17:01:01.460]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.460]                   signalCondition(cond)
[17:01:01.460]                 }
[17:01:01.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.460]                 "immediateCondition"))) {
[17:01:01.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.460]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.460]                   if (TRUE && !signal) {
[17:01:01.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.460]                     {
[17:01:01.460]                       inherits <- base::inherits
[17:01:01.460]                       invokeRestart <- base::invokeRestart
[17:01:01.460]                       is.null <- base::is.null
[17:01:01.460]                       muffled <- FALSE
[17:01:01.460]                       if (inherits(cond, "message")) {
[17:01:01.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.460]                         if (muffled) 
[17:01:01.460]                           invokeRestart("muffleMessage")
[17:01:01.460]                       }
[17:01:01.460]                       else if (inherits(cond, "warning")) {
[17:01:01.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.460]                         if (muffled) 
[17:01:01.460]                           invokeRestart("muffleWarning")
[17:01:01.460]                       }
[17:01:01.460]                       else if (inherits(cond, "condition")) {
[17:01:01.460]                         if (!is.null(pattern)) {
[17:01:01.460]                           computeRestarts <- base::computeRestarts
[17:01:01.460]                           grepl <- base::grepl
[17:01:01.460]                           restarts <- computeRestarts(cond)
[17:01:01.460]                           for (restart in restarts) {
[17:01:01.460]                             name <- restart$name
[17:01:01.460]                             if (is.null(name)) 
[17:01:01.460]                               next
[17:01:01.460]                             if (!grepl(pattern, name)) 
[17:01:01.460]                               next
[17:01:01.460]                             invokeRestart(restart)
[17:01:01.460]                             muffled <- TRUE
[17:01:01.460]                             break
[17:01:01.460]                           }
[17:01:01.460]                         }
[17:01:01.460]                       }
[17:01:01.460]                       invisible(muffled)
[17:01:01.460]                     }
[17:01:01.460]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.460]                   }
[17:01:01.460]                 }
[17:01:01.460]                 else {
[17:01:01.460]                   if (TRUE) {
[17:01:01.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.460]                     {
[17:01:01.460]                       inherits <- base::inherits
[17:01:01.460]                       invokeRestart <- base::invokeRestart
[17:01:01.460]                       is.null <- base::is.null
[17:01:01.460]                       muffled <- FALSE
[17:01:01.460]                       if (inherits(cond, "message")) {
[17:01:01.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.460]                         if (muffled) 
[17:01:01.460]                           invokeRestart("muffleMessage")
[17:01:01.460]                       }
[17:01:01.460]                       else if (inherits(cond, "warning")) {
[17:01:01.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.460]                         if (muffled) 
[17:01:01.460]                           invokeRestart("muffleWarning")
[17:01:01.460]                       }
[17:01:01.460]                       else if (inherits(cond, "condition")) {
[17:01:01.460]                         if (!is.null(pattern)) {
[17:01:01.460]                           computeRestarts <- base::computeRestarts
[17:01:01.460]                           grepl <- base::grepl
[17:01:01.460]                           restarts <- computeRestarts(cond)
[17:01:01.460]                           for (restart in restarts) {
[17:01:01.460]                             name <- restart$name
[17:01:01.460]                             if (is.null(name)) 
[17:01:01.460]                               next
[17:01:01.460]                             if (!grepl(pattern, name)) 
[17:01:01.460]                               next
[17:01:01.460]                             invokeRestart(restart)
[17:01:01.460]                             muffled <- TRUE
[17:01:01.460]                             break
[17:01:01.460]                           }
[17:01:01.460]                         }
[17:01:01.460]                       }
[17:01:01.460]                       invisible(muffled)
[17:01:01.460]                     }
[17:01:01.460]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.460]                   }
[17:01:01.460]                 }
[17:01:01.460]             }
[17:01:01.460]         }))
[17:01:01.460]     }, error = function(ex) {
[17:01:01.460]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.460]                 ...future.rng), started = ...future.startTime, 
[17:01:01.460]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.460]             version = "1.8"), class = "FutureResult")
[17:01:01.460]     }, finally = {
[17:01:01.460]         if (!identical(...future.workdir, getwd())) 
[17:01:01.460]             setwd(...future.workdir)
[17:01:01.460]         {
[17:01:01.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.460]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.460]             }
[17:01:01.460]             base::options(...future.oldOptions)
[17:01:01.460]             if (.Platform$OS.type == "windows") {
[17:01:01.460]                 old_names <- names(...future.oldEnvVars)
[17:01:01.460]                 envs <- base::Sys.getenv()
[17:01:01.460]                 names <- names(envs)
[17:01:01.460]                 common <- intersect(names, old_names)
[17:01:01.460]                 added <- setdiff(names, old_names)
[17:01:01.460]                 removed <- setdiff(old_names, names)
[17:01:01.460]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.460]                   envs[common]]
[17:01:01.460]                 NAMES <- toupper(changed)
[17:01:01.460]                 args <- list()
[17:01:01.460]                 for (kk in seq_along(NAMES)) {
[17:01:01.460]                   name <- changed[[kk]]
[17:01:01.460]                   NAME <- NAMES[[kk]]
[17:01:01.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.460]                     next
[17:01:01.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.460]                 }
[17:01:01.460]                 NAMES <- toupper(added)
[17:01:01.460]                 for (kk in seq_along(NAMES)) {
[17:01:01.460]                   name <- added[[kk]]
[17:01:01.460]                   NAME <- NAMES[[kk]]
[17:01:01.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.460]                     next
[17:01:01.460]                   args[[name]] <- ""
[17:01:01.460]                 }
[17:01:01.460]                 NAMES <- toupper(removed)
[17:01:01.460]                 for (kk in seq_along(NAMES)) {
[17:01:01.460]                   name <- removed[[kk]]
[17:01:01.460]                   NAME <- NAMES[[kk]]
[17:01:01.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.460]                     next
[17:01:01.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.460]                 }
[17:01:01.460]                 if (length(args) > 0) 
[17:01:01.460]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.460]             }
[17:01:01.460]             else {
[17:01:01.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.460]             }
[17:01:01.460]             {
[17:01:01.460]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.460]                   0L) {
[17:01:01.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.460]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.460]                   base::options(opts)
[17:01:01.460]                 }
[17:01:01.460]                 {
[17:01:01.460]                   {
[17:01:01.460]                     NULL
[17:01:01.460]                     RNGkind("Mersenne-Twister")
[17:01:01.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.460]                       inherits = FALSE)
[17:01:01.460]                   }
[17:01:01.460]                   options(future.plan = NULL)
[17:01:01.460]                   if (is.na(NA_character_)) 
[17:01:01.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.460]                     .init = FALSE)
[17:01:01.460]                 }
[17:01:01.460]             }
[17:01:01.460]         }
[17:01:01.460]     })
[17:01:01.460]     if (TRUE) {
[17:01:01.460]         base::sink(type = "output", split = FALSE)
[17:01:01.460]         if (TRUE) {
[17:01:01.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.460]         }
[17:01:01.460]         else {
[17:01:01.460]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.460]         }
[17:01:01.460]         base::close(...future.stdout)
[17:01:01.460]         ...future.stdout <- NULL
[17:01:01.460]     }
[17:01:01.460]     ...future.result$conditions <- ...future.conditions
[17:01:01.460]     ...future.result$finished <- base::Sys.time()
[17:01:01.460]     ...future.result
[17:01:01.460] }
[17:01:01.462] assign_globals() ...
[17:01:01.462] List of 11
[17:01:01.462]  $ ...future.FUN            :function (x, ...)  
[17:01:01.462]  $ x_FUN                    :function (x)  
[17:01:01.462]  $ times                    : int 4
[17:01:01.462]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.462]  $ stop_if_not              :function (...)  
[17:01:01.462]  $ dim                      : int [1:2] 2 2
[17:01:01.462]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.462]  $ future.call.arguments    : list()
[17:01:01.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.462]  $ ...future.elements_ii    :List of 10
[17:01:01.462]   ..$ : int 1
[17:01:01.462]   ..$ : int 2
[17:01:01.462]   ..$ : int 3
[17:01:01.462]   ..$ : int 4
[17:01:01.462]   ..$ : int 5
[17:01:01.462]   ..$ : int 6
[17:01:01.462]   ..$ : int 7
[17:01:01.462]   ..$ : int 8
[17:01:01.462]   ..$ : int 9
[17:01:01.462]   ..$ : int 10
[17:01:01.462]  $ ...future.seeds_ii       : NULL
[17:01:01.462]  $ ...future.globals.maxSize: NULL
[17:01:01.462]  - attr(*, "where")=List of 11
[17:01:01.462]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.462]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.462]  - attr(*, "resolved")= logi FALSE
[17:01:01.462]  - attr(*, "total_size")= num 105552
[17:01:01.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.462]  - attr(*, "already-done")= logi TRUE
[17:01:01.471] - copied ‘...future.FUN’ to environment
[17:01:01.472] - reassign environment for ‘x_FUN’
[17:01:01.472] - copied ‘x_FUN’ to environment
[17:01:01.472] - copied ‘times’ to environment
[17:01:01.472] - copied ‘stopf’ to environment
[17:01:01.472] - copied ‘stop_if_not’ to environment
[17:01:01.472] - copied ‘dim’ to environment
[17:01:01.472] - copied ‘valid_types’ to environment
[17:01:01.472] - copied ‘future.call.arguments’ to environment
[17:01:01.472] - copied ‘...future.elements_ii’ to environment
[17:01:01.472] - copied ‘...future.seeds_ii’ to environment
[17:01:01.473] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.473] assign_globals() ... done
[17:01:01.473] plan(): Setting new future strategy stack:
[17:01:01.473] List of future strategies:
[17:01:01.473] 1. sequential:
[17:01:01.473]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.473]    - tweaked: FALSE
[17:01:01.473]    - call: NULL
[17:01:01.474] plan(): nbrOfWorkers() = 1
[17:01:01.476] plan(): Setting new future strategy stack:
[17:01:01.476] List of future strategies:
[17:01:01.476] 1. sequential:
[17:01:01.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.476]    - tweaked: FALSE
[17:01:01.476]    - call: plan(strategy)
[17:01:01.477] plan(): nbrOfWorkers() = 1
[17:01:01.477] SequentialFuture started (and completed)
[17:01:01.477] - Launch lazy future ... done
[17:01:01.477] run() for ‘SequentialFuture’ ... done
[17:01:01.477] Created future:
[17:01:01.477] SequentialFuture:
[17:01:01.477] Label: ‘future_vapply-1’
[17:01:01.477] Expression:
[17:01:01.477] {
[17:01:01.477]     do.call(function(...) {
[17:01:01.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.477]             on.exit(options(oopts), add = TRUE)
[17:01:01.477]         }
[17:01:01.477]         {
[17:01:01.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.477]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.477]             })
[17:01:01.477]         }
[17:01:01.477]     }, args = future.call.arguments)
[17:01:01.477] }
[17:01:01.477] Lazy evaluation: FALSE
[17:01:01.477] Asynchronous evaluation: FALSE
[17:01:01.477] Local evaluation: TRUE
[17:01:01.477] Environment: R_GlobalEnv
[17:01:01.477] Capture standard output: TRUE
[17:01:01.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.477] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.477] Packages: 1 packages (‘future.apply’)
[17:01:01.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.477] Resolved: TRUE
[17:01:01.477] Value: 7.42 KiB of class ‘list’
[17:01:01.477] Early signaling: FALSE
[17:01:01.477] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.477] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.479] Chunk #1 of 1 ... DONE
[17:01:01.479] Launching 1 futures (chunks) ... DONE
[17:01:01.479] Resolving 1 futures (chunks) ...
[17:01:01.479] resolve() on list ...
[17:01:01.479]  recursive: 0
[17:01:01.479]  length: 1
[17:01:01.479] 
[17:01:01.479] resolved() for ‘SequentialFuture’ ...
[17:01:01.479] - state: ‘finished’
[17:01:01.479] - run: TRUE
[17:01:01.480] - result: ‘FutureResult’
[17:01:01.480] resolved() for ‘SequentialFuture’ ... done
[17:01:01.480] Future #1
[17:01:01.480] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.480] - nx: 1
[17:01:01.480] - relay: TRUE
[17:01:01.480] - stdout: TRUE
[17:01:01.480] - signal: TRUE
[17:01:01.480] - resignal: FALSE
[17:01:01.480] - force: TRUE
[17:01:01.481] - relayed: [n=1] FALSE
[17:01:01.481] - queued futures: [n=1] FALSE
[17:01:01.481]  - until=1
[17:01:01.481]  - relaying element #1
[17:01:01.481] - relayed: [n=1] TRUE
[17:01:01.481] - queued futures: [n=1] TRUE
[17:01:01.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.481]  length: 0 (resolved future 1)
[17:01:01.481] Relaying remaining futures
[17:01:01.481] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.482] - nx: 1
[17:01:01.482] - relay: TRUE
[17:01:01.482] - stdout: TRUE
[17:01:01.482] - signal: TRUE
[17:01:01.482] - resignal: FALSE
[17:01:01.482] - force: TRUE
[17:01:01.482] - relayed: [n=1] TRUE
[17:01:01.482] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.482] - relayed: [n=1] TRUE
[17:01:01.482] - queued futures: [n=1] TRUE
[17:01:01.482] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.482] resolve() on list ... DONE
[17:01:01.483]  - Number of value chunks collected: 1
[17:01:01.483] Resolving 1 futures (chunks) ... DONE
[17:01:01.483] Reducing values from 1 chunks ...
[17:01:01.483]  - Number of values collected after concatenation: 10
[17:01:01.483]  - Number of values expected: 10
[17:01:01.483] Reducing values from 1 chunks ... DONE
[17:01:01.483] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:01:01.487] future_lapply() ...
[17:01:01.489] Number of chunks: 1
[17:01:01.489] getGlobalsAndPackagesXApply() ...
[17:01:01.489]  - future.globals: TRUE
[17:01:01.489] getGlobalsAndPackages() ...
[17:01:01.489] Searching for globals...
[17:01:01.492] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:01:01.492] Searching for globals ... DONE
[17:01:01.493] Resolving globals: FALSE
[17:01:01.493] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:01:01.494] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.494] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.494] - packages: [2] ‘stats’, ‘future.apply’
[17:01:01.494] getGlobalsAndPackages() ... DONE
[17:01:01.494]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.494]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:01.494] Finding globals ... DONE
[17:01:01.495]  - use_args: TRUE
[17:01:01.495]  - Getting '...' globals ...
[17:01:01.495] resolve() on list ...
[17:01:01.495]  recursive: 0
[17:01:01.495]  length: 1
[17:01:01.495]  elements: ‘...’
[17:01:01.495]  length: 0 (resolved future 1)
[17:01:01.495] resolve() on list ... DONE
[17:01:01.496]    - '...' content: [n=0] 
[17:01:01.496] List of 1
[17:01:01.496]  $ ...: list()
[17:01:01.496]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.496]  - attr(*, "where")=List of 1
[17:01:01.496]   ..$ ...:<environment: 0x55aadac455e0> 
[17:01:01.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.496]  - attr(*, "resolved")= logi TRUE
[17:01:01.496]  - attr(*, "total_size")= num NA
[17:01:01.498]  - Getting '...' globals ... DONE
[17:01:01.498] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.498] List of 8
[17:01:01.498]  $ ...future.FUN:function (x, ...)  
[17:01:01.498]  $ x_FUN        :function (x, ...)  
[17:01:01.498]  $ times        : int 5
[17:01:01.498]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.498]  $ stop_if_not  :function (...)  
[17:01:01.498]  $ dim          : NULL
[17:01:01.498]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.498]  $ ...          : list()
[17:01:01.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.498]  - attr(*, "where")=List of 8
[17:01:01.498]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.498]   ..$ ...          :<environment: 0x55aadac455e0> 
[17:01:01.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.498]  - attr(*, "resolved")= logi FALSE
[17:01:01.498]  - attr(*, "total_size")= num 95528
[17:01:01.506] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:01.506] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.506] Number of futures (= number of chunks): 1
[17:01:01.506] Launching 1 futures (chunks) ...
[17:01:01.506] Chunk #1 of 1 ...
[17:01:01.506]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.506] getGlobalsAndPackages() ...
[17:01:01.507] Searching for globals...
[17:01:01.507] 
[17:01:01.507] Searching for globals ... DONE
[17:01:01.507] - globals: [0] <none>
[17:01:01.507] getGlobalsAndPackages() ... DONE
[17:01:01.507]    + additional globals found: [n=0] 
[17:01:01.507]    + additional namespaces needed: [n=0] 
[17:01:01.507]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.507]  - seeds: <none>
[17:01:01.508]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.508] getGlobalsAndPackages() ...
[17:01:01.508] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.508] Resolving globals: FALSE
[17:01:01.508] Tweak future expression to call with '...' arguments ...
[17:01:01.508] {
[17:01:01.508]     do.call(function(...) {
[17:01:01.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.508]             on.exit(options(oopts), add = TRUE)
[17:01:01.508]         }
[17:01:01.508]         {
[17:01:01.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.508]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.508]             })
[17:01:01.508]         }
[17:01:01.508]     }, args = future.call.arguments)
[17:01:01.508] }
[17:01:01.508] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.509] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.509] - packages: [2] ‘stats’, ‘future.apply’
[17:01:01.509] getGlobalsAndPackages() ... DONE
[17:01:01.509] run() for ‘Future’ ...
[17:01:01.509] - state: ‘created’
[17:01:01.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.510]   - Field: ‘label’
[17:01:01.510]   - Field: ‘local’
[17:01:01.510]   - Field: ‘owner’
[17:01:01.510]   - Field: ‘envir’
[17:01:01.510]   - Field: ‘packages’
[17:01:01.511]   - Field: ‘gc’
[17:01:01.511]   - Field: ‘conditions’
[17:01:01.511]   - Field: ‘expr’
[17:01:01.511]   - Field: ‘uuid’
[17:01:01.511]   - Field: ‘seed’
[17:01:01.511]   - Field: ‘version’
[17:01:01.511]   - Field: ‘result’
[17:01:01.511]   - Field: ‘asynchronous’
[17:01:01.511]   - Field: ‘calls’
[17:01:01.511]   - Field: ‘globals’
[17:01:01.511]   - Field: ‘stdout’
[17:01:01.512]   - Field: ‘earlySignal’
[17:01:01.512]   - Field: ‘lazy’
[17:01:01.512]   - Field: ‘state’
[17:01:01.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.512] - Launch lazy future ...
[17:01:01.512] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:01.512] Packages needed by future strategies (n = 0): <none>
[17:01:01.513] {
[17:01:01.513]     {
[17:01:01.513]         {
[17:01:01.513]             ...future.startTime <- base::Sys.time()
[17:01:01.513]             {
[17:01:01.513]                 {
[17:01:01.513]                   {
[17:01:01.513]                     {
[17:01:01.513]                       base::local({
[17:01:01.513]                         has_future <- base::requireNamespace("future", 
[17:01:01.513]                           quietly = TRUE)
[17:01:01.513]                         if (has_future) {
[17:01:01.513]                           ns <- base::getNamespace("future")
[17:01:01.513]                           version <- ns[[".package"]][["version"]]
[17:01:01.513]                           if (is.null(version)) 
[17:01:01.513]                             version <- utils::packageVersion("future")
[17:01:01.513]                         }
[17:01:01.513]                         else {
[17:01:01.513]                           version <- NULL
[17:01:01.513]                         }
[17:01:01.513]                         if (!has_future || version < "1.8.0") {
[17:01:01.513]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.513]                             "", base::R.version$version.string), 
[17:01:01.513]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.513]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.513]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.513]                               "release", "version")], collapse = " "), 
[17:01:01.513]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.513]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.513]                             info)
[17:01:01.513]                           info <- base::paste(info, collapse = "; ")
[17:01:01.513]                           if (!has_future) {
[17:01:01.513]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.513]                               info)
[17:01:01.513]                           }
[17:01:01.513]                           else {
[17:01:01.513]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.513]                               info, version)
[17:01:01.513]                           }
[17:01:01.513]                           base::stop(msg)
[17:01:01.513]                         }
[17:01:01.513]                       })
[17:01:01.513]                     }
[17:01:01.513]                     base::local({
[17:01:01.513]                       for (pkg in c("stats", "future.apply")) {
[17:01:01.513]                         base::loadNamespace(pkg)
[17:01:01.513]                         base::library(pkg, character.only = TRUE)
[17:01:01.513]                       }
[17:01:01.513]                     })
[17:01:01.513]                   }
[17:01:01.513]                   ...future.strategy.old <- future::plan("list")
[17:01:01.513]                   options(future.plan = NULL)
[17:01:01.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.513]                 }
[17:01:01.513]                 ...future.workdir <- getwd()
[17:01:01.513]             }
[17:01:01.513]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.513]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.513]         }
[17:01:01.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.513]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.513]             base::names(...future.oldOptions))
[17:01:01.513]     }
[17:01:01.513]     if (FALSE) {
[17:01:01.513]     }
[17:01:01.513]     else {
[17:01:01.513]         if (TRUE) {
[17:01:01.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.513]                 open = "w")
[17:01:01.513]         }
[17:01:01.513]         else {
[17:01:01.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.513]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.513]         }
[17:01:01.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.513]             base::sink(type = "output", split = FALSE)
[17:01:01.513]             base::close(...future.stdout)
[17:01:01.513]         }, add = TRUE)
[17:01:01.513]     }
[17:01:01.513]     ...future.frame <- base::sys.nframe()
[17:01:01.513]     ...future.conditions <- base::list()
[17:01:01.513]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.513]     if (FALSE) {
[17:01:01.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.513]     }
[17:01:01.513]     ...future.result <- base::tryCatch({
[17:01:01.513]         base::withCallingHandlers({
[17:01:01.513]             ...future.value <- base::withVisible(base::local({
[17:01:01.513]                 do.call(function(...) {
[17:01:01.513]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.513]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.513]                     ...future.globals.maxSize)) {
[17:01:01.513]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.513]                     on.exit(options(oopts), add = TRUE)
[17:01:01.513]                   }
[17:01:01.513]                   {
[17:01:01.513]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.513]                       FUN = function(jj) {
[17:01:01.513]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.513]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.513]                       })
[17:01:01.513]                   }
[17:01:01.513]                 }, args = future.call.arguments)
[17:01:01.513]             }))
[17:01:01.513]             future::FutureResult(value = ...future.value$value, 
[17:01:01.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.513]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.513]                     ...future.globalenv.names))
[17:01:01.513]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.513]         }, condition = base::local({
[17:01:01.513]             c <- base::c
[17:01:01.513]             inherits <- base::inherits
[17:01:01.513]             invokeRestart <- base::invokeRestart
[17:01:01.513]             length <- base::length
[17:01:01.513]             list <- base::list
[17:01:01.513]             seq.int <- base::seq.int
[17:01:01.513]             signalCondition <- base::signalCondition
[17:01:01.513]             sys.calls <- base::sys.calls
[17:01:01.513]             `[[` <- base::`[[`
[17:01:01.513]             `+` <- base::`+`
[17:01:01.513]             `<<-` <- base::`<<-`
[17:01:01.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.513]                   3L)]
[17:01:01.513]             }
[17:01:01.513]             function(cond) {
[17:01:01.513]                 is_error <- inherits(cond, "error")
[17:01:01.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.513]                   NULL)
[17:01:01.513]                 if (is_error) {
[17:01:01.513]                   sessionInformation <- function() {
[17:01:01.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.513]                       search = base::search(), system = base::Sys.info())
[17:01:01.513]                   }
[17:01:01.513]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.513]                     cond$call), session = sessionInformation(), 
[17:01:01.513]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.513]                   signalCondition(cond)
[17:01:01.513]                 }
[17:01:01.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.513]                 "immediateCondition"))) {
[17:01:01.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.513]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.513]                   if (TRUE && !signal) {
[17:01:01.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.513]                     {
[17:01:01.513]                       inherits <- base::inherits
[17:01:01.513]                       invokeRestart <- base::invokeRestart
[17:01:01.513]                       is.null <- base::is.null
[17:01:01.513]                       muffled <- FALSE
[17:01:01.513]                       if (inherits(cond, "message")) {
[17:01:01.513]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.513]                         if (muffled) 
[17:01:01.513]                           invokeRestart("muffleMessage")
[17:01:01.513]                       }
[17:01:01.513]                       else if (inherits(cond, "warning")) {
[17:01:01.513]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.513]                         if (muffled) 
[17:01:01.513]                           invokeRestart("muffleWarning")
[17:01:01.513]                       }
[17:01:01.513]                       else if (inherits(cond, "condition")) {
[17:01:01.513]                         if (!is.null(pattern)) {
[17:01:01.513]                           computeRestarts <- base::computeRestarts
[17:01:01.513]                           grepl <- base::grepl
[17:01:01.513]                           restarts <- computeRestarts(cond)
[17:01:01.513]                           for (restart in restarts) {
[17:01:01.513]                             name <- restart$name
[17:01:01.513]                             if (is.null(name)) 
[17:01:01.513]                               next
[17:01:01.513]                             if (!grepl(pattern, name)) 
[17:01:01.513]                               next
[17:01:01.513]                             invokeRestart(restart)
[17:01:01.513]                             muffled <- TRUE
[17:01:01.513]                             break
[17:01:01.513]                           }
[17:01:01.513]                         }
[17:01:01.513]                       }
[17:01:01.513]                       invisible(muffled)
[17:01:01.513]                     }
[17:01:01.513]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.513]                   }
[17:01:01.513]                 }
[17:01:01.513]                 else {
[17:01:01.513]                   if (TRUE) {
[17:01:01.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.513]                     {
[17:01:01.513]                       inherits <- base::inherits
[17:01:01.513]                       invokeRestart <- base::invokeRestart
[17:01:01.513]                       is.null <- base::is.null
[17:01:01.513]                       muffled <- FALSE
[17:01:01.513]                       if (inherits(cond, "message")) {
[17:01:01.513]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.513]                         if (muffled) 
[17:01:01.513]                           invokeRestart("muffleMessage")
[17:01:01.513]                       }
[17:01:01.513]                       else if (inherits(cond, "warning")) {
[17:01:01.513]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.513]                         if (muffled) 
[17:01:01.513]                           invokeRestart("muffleWarning")
[17:01:01.513]                       }
[17:01:01.513]                       else if (inherits(cond, "condition")) {
[17:01:01.513]                         if (!is.null(pattern)) {
[17:01:01.513]                           computeRestarts <- base::computeRestarts
[17:01:01.513]                           grepl <- base::grepl
[17:01:01.513]                           restarts <- computeRestarts(cond)
[17:01:01.513]                           for (restart in restarts) {
[17:01:01.513]                             name <- restart$name
[17:01:01.513]                             if (is.null(name)) 
[17:01:01.513]                               next
[17:01:01.513]                             if (!grepl(pattern, name)) 
[17:01:01.513]                               next
[17:01:01.513]                             invokeRestart(restart)
[17:01:01.513]                             muffled <- TRUE
[17:01:01.513]                             break
[17:01:01.513]                           }
[17:01:01.513]                         }
[17:01:01.513]                       }
[17:01:01.513]                       invisible(muffled)
[17:01:01.513]                     }
[17:01:01.513]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.513]                   }
[17:01:01.513]                 }
[17:01:01.513]             }
[17:01:01.513]         }))
[17:01:01.513]     }, error = function(ex) {
[17:01:01.513]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.513]                 ...future.rng), started = ...future.startTime, 
[17:01:01.513]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.513]             version = "1.8"), class = "FutureResult")
[17:01:01.513]     }, finally = {
[17:01:01.513]         if (!identical(...future.workdir, getwd())) 
[17:01:01.513]             setwd(...future.workdir)
[17:01:01.513]         {
[17:01:01.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.513]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.513]             }
[17:01:01.513]             base::options(...future.oldOptions)
[17:01:01.513]             if (.Platform$OS.type == "windows") {
[17:01:01.513]                 old_names <- names(...future.oldEnvVars)
[17:01:01.513]                 envs <- base::Sys.getenv()
[17:01:01.513]                 names <- names(envs)
[17:01:01.513]                 common <- intersect(names, old_names)
[17:01:01.513]                 added <- setdiff(names, old_names)
[17:01:01.513]                 removed <- setdiff(old_names, names)
[17:01:01.513]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.513]                   envs[common]]
[17:01:01.513]                 NAMES <- toupper(changed)
[17:01:01.513]                 args <- list()
[17:01:01.513]                 for (kk in seq_along(NAMES)) {
[17:01:01.513]                   name <- changed[[kk]]
[17:01:01.513]                   NAME <- NAMES[[kk]]
[17:01:01.513]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.513]                     next
[17:01:01.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.513]                 }
[17:01:01.513]                 NAMES <- toupper(added)
[17:01:01.513]                 for (kk in seq_along(NAMES)) {
[17:01:01.513]                   name <- added[[kk]]
[17:01:01.513]                   NAME <- NAMES[[kk]]
[17:01:01.513]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.513]                     next
[17:01:01.513]                   args[[name]] <- ""
[17:01:01.513]                 }
[17:01:01.513]                 NAMES <- toupper(removed)
[17:01:01.513]                 for (kk in seq_along(NAMES)) {
[17:01:01.513]                   name <- removed[[kk]]
[17:01:01.513]                   NAME <- NAMES[[kk]]
[17:01:01.513]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.513]                     next
[17:01:01.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.513]                 }
[17:01:01.513]                 if (length(args) > 0) 
[17:01:01.513]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.513]             }
[17:01:01.513]             else {
[17:01:01.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.513]             }
[17:01:01.513]             {
[17:01:01.513]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.513]                   0L) {
[17:01:01.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.513]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.513]                   base::options(opts)
[17:01:01.513]                 }
[17:01:01.513]                 {
[17:01:01.513]                   {
[17:01:01.513]                     NULL
[17:01:01.513]                     RNGkind("Mersenne-Twister")
[17:01:01.513]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.513]                       inherits = FALSE)
[17:01:01.513]                   }
[17:01:01.513]                   options(future.plan = NULL)
[17:01:01.513]                   if (is.na(NA_character_)) 
[17:01:01.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.513]                     .init = FALSE)
[17:01:01.513]                 }
[17:01:01.513]             }
[17:01:01.513]         }
[17:01:01.513]     })
[17:01:01.513]     if (TRUE) {
[17:01:01.513]         base::sink(type = "output", split = FALSE)
[17:01:01.513]         if (TRUE) {
[17:01:01.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.513]         }
[17:01:01.513]         else {
[17:01:01.513]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.513]         }
[17:01:01.513]         base::close(...future.stdout)
[17:01:01.513]         ...future.stdout <- NULL
[17:01:01.513]     }
[17:01:01.513]     ...future.result$conditions <- ...future.conditions
[17:01:01.513]     ...future.result$finished <- base::Sys.time()
[17:01:01.513]     ...future.result
[17:01:01.513] }
[17:01:01.515] assign_globals() ...
[17:01:01.515] List of 11
[17:01:01.515]  $ ...future.FUN            :function (x, ...)  
[17:01:01.515]  $ x_FUN                    :function (x, ...)  
[17:01:01.515]  $ times                    : int 5
[17:01:01.515]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.515]  $ stop_if_not              :function (...)  
[17:01:01.515]  $ dim                      : NULL
[17:01:01.515]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.515]  $ future.call.arguments    : list()
[17:01:01.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.515]  $ ...future.elements_ii    :List of 3
[17:01:01.515]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:01:01.515]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:01:01.515]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:01:01.515]  $ ...future.seeds_ii       : NULL
[17:01:01.515]  $ ...future.globals.maxSize: NULL
[17:01:01.515]  - attr(*, "where")=List of 11
[17:01:01.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.515]  - attr(*, "resolved")= logi FALSE
[17:01:01.515]  - attr(*, "total_size")= num 95528
[17:01:01.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.515]  - attr(*, "already-done")= logi TRUE
[17:01:01.522] - copied ‘...future.FUN’ to environment
[17:01:01.522] - copied ‘x_FUN’ to environment
[17:01:01.523] - copied ‘times’ to environment
[17:01:01.523] - copied ‘stopf’ to environment
[17:01:01.523] - copied ‘stop_if_not’ to environment
[17:01:01.523] - copied ‘dim’ to environment
[17:01:01.523] - copied ‘valid_types’ to environment
[17:01:01.523] - copied ‘future.call.arguments’ to environment
[17:01:01.523] - copied ‘...future.elements_ii’ to environment
[17:01:01.523] - copied ‘...future.seeds_ii’ to environment
[17:01:01.523] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.523] assign_globals() ... done
[17:01:01.524] plan(): Setting new future strategy stack:
[17:01:01.524] List of future strategies:
[17:01:01.524] 1. sequential:
[17:01:01.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.524]    - tweaked: FALSE
[17:01:01.524]    - call: NULL
[17:01:01.524] plan(): nbrOfWorkers() = 1
[17:01:01.527] plan(): Setting new future strategy stack:
[17:01:01.527] List of future strategies:
[17:01:01.527] 1. sequential:
[17:01:01.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.527]    - tweaked: FALSE
[17:01:01.527]    - call: plan(strategy)
[17:01:01.528] plan(): nbrOfWorkers() = 1
[17:01:01.528] SequentialFuture started (and completed)
[17:01:01.528] - Launch lazy future ... done
[17:01:01.528] run() for ‘SequentialFuture’ ... done
[17:01:01.529] Created future:
[17:01:01.529] SequentialFuture:
[17:01:01.529] Label: ‘future_vapply-1’
[17:01:01.529] Expression:
[17:01:01.529] {
[17:01:01.529]     do.call(function(...) {
[17:01:01.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.529]             on.exit(options(oopts), add = TRUE)
[17:01:01.529]         }
[17:01:01.529]         {
[17:01:01.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.529]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.529]             })
[17:01:01.529]         }
[17:01:01.529]     }, args = future.call.arguments)
[17:01:01.529] }
[17:01:01.529] Lazy evaluation: FALSE
[17:01:01.529] Asynchronous evaluation: FALSE
[17:01:01.529] Local evaluation: TRUE
[17:01:01.529] Environment: R_GlobalEnv
[17:01:01.529] Capture standard output: TRUE
[17:01:01.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.529] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.529] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:01.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.529] Resolved: TRUE
[17:01:01.529] Value: 1.71 KiB of class ‘list’
[17:01:01.529] Early signaling: FALSE
[17:01:01.529] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.529] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.530] Chunk #1 of 1 ... DONE
[17:01:01.530] Launching 1 futures (chunks) ... DONE
[17:01:01.530] Resolving 1 futures (chunks) ...
[17:01:01.530] resolve() on list ...
[17:01:01.530]  recursive: 0
[17:01:01.530]  length: 1
[17:01:01.530] 
[17:01:01.531] resolved() for ‘SequentialFuture’ ...
[17:01:01.531] - state: ‘finished’
[17:01:01.531] - run: TRUE
[17:01:01.531] - result: ‘FutureResult’
[17:01:01.531] resolved() for ‘SequentialFuture’ ... done
[17:01:01.531] Future #1
[17:01:01.531] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.531] - nx: 1
[17:01:01.531] - relay: TRUE
[17:01:01.532] - stdout: TRUE
[17:01:01.532] - signal: TRUE
[17:01:01.532] - resignal: FALSE
[17:01:01.532] - force: TRUE
[17:01:01.532] - relayed: [n=1] FALSE
[17:01:01.532] - queued futures: [n=1] FALSE
[17:01:01.532]  - until=1
[17:01:01.532]  - relaying element #1
[17:01:01.532] - relayed: [n=1] TRUE
[17:01:01.532] - queued futures: [n=1] TRUE
[17:01:01.533] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.533]  length: 0 (resolved future 1)
[17:01:01.533] Relaying remaining futures
[17:01:01.533] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.533] - nx: 1
[17:01:01.533] - relay: TRUE
[17:01:01.533] - stdout: TRUE
[17:01:01.533] - signal: TRUE
[17:01:01.533] - resignal: FALSE
[17:01:01.533] - force: TRUE
[17:01:01.533] - relayed: [n=1] TRUE
[17:01:01.533] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.534] - relayed: [n=1] TRUE
[17:01:01.534] - queued futures: [n=1] TRUE
[17:01:01.534] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.534] resolve() on list ... DONE
[17:01:01.534]  - Number of value chunks collected: 1
[17:01:01.534] Resolving 1 futures (chunks) ... DONE
[17:01:01.534] Reducing values from 1 chunks ...
[17:01:01.534]  - Number of values collected after concatenation: 3
[17:01:01.534]  - Number of values expected: 3
[17:01:01.534] Reducing values from 1 chunks ... DONE
[17:01:01.535] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:01:01.536] future_lapply() ...
[17:01:01.540] Number of chunks: 1
[17:01:01.540] getGlobalsAndPackagesXApply() ...
[17:01:01.540]  - future.globals: TRUE
[17:01:01.540] getGlobalsAndPackages() ...
[17:01:01.540] Searching for globals...
[17:01:01.545] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:01.545] Searching for globals ... DONE
[17:01:01.545] Resolving globals: FALSE
[17:01:01.546] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:01:01.546] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:01:01.546] - globals: [1] ‘FUN’
[17:01:01.546] - packages: [1] ‘stats’
[17:01:01.547] getGlobalsAndPackages() ... DONE
[17:01:01.547]  - globals found/used: [n=1] ‘FUN’
[17:01:01.547]  - needed namespaces: [n=1] ‘stats’
[17:01:01.547] Finding globals ... DONE
[17:01:01.547]  - use_args: TRUE
[17:01:01.547]  - Getting '...' globals ...
[17:01:01.547] resolve() on list ...
[17:01:01.547]  recursive: 0
[17:01:01.548]  length: 1
[17:01:01.548]  elements: ‘...’
[17:01:01.548]  length: 0 (resolved future 1)
[17:01:01.548] resolve() on list ... DONE
[17:01:01.548]    - '...' content: [n=0] 
[17:01:01.548] List of 1
[17:01:01.548]  $ ...: list()
[17:01:01.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.548]  - attr(*, "where")=List of 1
[17:01:01.548]   ..$ ...:<environment: 0x55aad9880980> 
[17:01:01.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.548]  - attr(*, "resolved")= logi TRUE
[17:01:01.548]  - attr(*, "total_size")= num NA
[17:01:01.552]  - Getting '...' globals ... DONE
[17:01:01.553] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:01.553] List of 2
[17:01:01.553]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:01:01.553]  $ ...          : list()
[17:01:01.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.553]  - attr(*, "where")=List of 2
[17:01:01.553]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.553]   ..$ ...          :<environment: 0x55aad9880980> 
[17:01:01.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.553]  - attr(*, "resolved")= logi FALSE
[17:01:01.553]  - attr(*, "total_size")= num 46960
[17:01:01.555] Packages to be attached in all futures: [n=1] ‘stats’
[17:01:01.555] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.556] Number of futures (= number of chunks): 1
[17:01:01.556] Launching 1 futures (chunks) ...
[17:01:01.556] Chunk #1 of 1 ...
[17:01:01.556]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.556] getGlobalsAndPackages() ...
[17:01:01.556] Searching for globals...
[17:01:01.556] 
[17:01:01.557] Searching for globals ... DONE
[17:01:01.557] - globals: [0] <none>
[17:01:01.557] getGlobalsAndPackages() ... DONE
[17:01:01.557]    + additional globals found: [n=0] 
[17:01:01.557]    + additional namespaces needed: [n=0] 
[17:01:01.557]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.557]  - seeds: <none>
[17:01:01.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.557] getGlobalsAndPackages() ...
[17:01:01.557] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.557] Resolving globals: FALSE
[17:01:01.558] Tweak future expression to call with '...' arguments ...
[17:01:01.558] {
[17:01:01.558]     do.call(function(...) {
[17:01:01.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.558]             on.exit(options(oopts), add = TRUE)
[17:01:01.558]         }
[17:01:01.558]         {
[17:01:01.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.558]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.558]             })
[17:01:01.558]         }
[17:01:01.558]     }, args = future.call.arguments)
[17:01:01.558] }
[17:01:01.558] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.558] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.558] - packages: [1] ‘stats’
[17:01:01.559] getGlobalsAndPackages() ... DONE
[17:01:01.559] run() for ‘Future’ ...
[17:01:01.559] - state: ‘created’
[17:01:01.559] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.560]   - Field: ‘label’
[17:01:01.560]   - Field: ‘local’
[17:01:01.560]   - Field: ‘owner’
[17:01:01.560]   - Field: ‘envir’
[17:01:01.560]   - Field: ‘packages’
[17:01:01.560]   - Field: ‘gc’
[17:01:01.560]   - Field: ‘conditions’
[17:01:01.560]   - Field: ‘expr’
[17:01:01.560]   - Field: ‘uuid’
[17:01:01.560]   - Field: ‘seed’
[17:01:01.560]   - Field: ‘version’
[17:01:01.561]   - Field: ‘result’
[17:01:01.561]   - Field: ‘asynchronous’
[17:01:01.561]   - Field: ‘calls’
[17:01:01.561]   - Field: ‘globals’
[17:01:01.561]   - Field: ‘stdout’
[17:01:01.561]   - Field: ‘earlySignal’
[17:01:01.561]   - Field: ‘lazy’
[17:01:01.561]   - Field: ‘state’
[17:01:01.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.561] - Launch lazy future ...
[17:01:01.562] Packages needed by the future expression (n = 1): ‘stats’
[17:01:01.562] Packages needed by future strategies (n = 0): <none>
[17:01:01.562] {
[17:01:01.562]     {
[17:01:01.562]         {
[17:01:01.562]             ...future.startTime <- base::Sys.time()
[17:01:01.562]             {
[17:01:01.562]                 {
[17:01:01.562]                   {
[17:01:01.562]                     {
[17:01:01.562]                       base::local({
[17:01:01.562]                         has_future <- base::requireNamespace("future", 
[17:01:01.562]                           quietly = TRUE)
[17:01:01.562]                         if (has_future) {
[17:01:01.562]                           ns <- base::getNamespace("future")
[17:01:01.562]                           version <- ns[[".package"]][["version"]]
[17:01:01.562]                           if (is.null(version)) 
[17:01:01.562]                             version <- utils::packageVersion("future")
[17:01:01.562]                         }
[17:01:01.562]                         else {
[17:01:01.562]                           version <- NULL
[17:01:01.562]                         }
[17:01:01.562]                         if (!has_future || version < "1.8.0") {
[17:01:01.562]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.562]                             "", base::R.version$version.string), 
[17:01:01.562]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.562]                               "release", "version")], collapse = " "), 
[17:01:01.562]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.562]                             info)
[17:01:01.562]                           info <- base::paste(info, collapse = "; ")
[17:01:01.562]                           if (!has_future) {
[17:01:01.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.562]                               info)
[17:01:01.562]                           }
[17:01:01.562]                           else {
[17:01:01.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.562]                               info, version)
[17:01:01.562]                           }
[17:01:01.562]                           base::stop(msg)
[17:01:01.562]                         }
[17:01:01.562]                       })
[17:01:01.562]                     }
[17:01:01.562]                     base::local({
[17:01:01.562]                       for (pkg in "stats") {
[17:01:01.562]                         base::loadNamespace(pkg)
[17:01:01.562]                         base::library(pkg, character.only = TRUE)
[17:01:01.562]                       }
[17:01:01.562]                     })
[17:01:01.562]                   }
[17:01:01.562]                   ...future.strategy.old <- future::plan("list")
[17:01:01.562]                   options(future.plan = NULL)
[17:01:01.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.562]                 }
[17:01:01.562]                 ...future.workdir <- getwd()
[17:01:01.562]             }
[17:01:01.562]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.562]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.562]         }
[17:01:01.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.562]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.562]             base::names(...future.oldOptions))
[17:01:01.562]     }
[17:01:01.562]     if (FALSE) {
[17:01:01.562]     }
[17:01:01.562]     else {
[17:01:01.562]         if (TRUE) {
[17:01:01.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.562]                 open = "w")
[17:01:01.562]         }
[17:01:01.562]         else {
[17:01:01.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.562]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.562]         }
[17:01:01.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.562]             base::sink(type = "output", split = FALSE)
[17:01:01.562]             base::close(...future.stdout)
[17:01:01.562]         }, add = TRUE)
[17:01:01.562]     }
[17:01:01.562]     ...future.frame <- base::sys.nframe()
[17:01:01.562]     ...future.conditions <- base::list()
[17:01:01.562]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.562]     if (FALSE) {
[17:01:01.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.562]     }
[17:01:01.562]     ...future.result <- base::tryCatch({
[17:01:01.562]         base::withCallingHandlers({
[17:01:01.562]             ...future.value <- base::withVisible(base::local({
[17:01:01.562]                 do.call(function(...) {
[17:01:01.562]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.562]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.562]                     ...future.globals.maxSize)) {
[17:01:01.562]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.562]                     on.exit(options(oopts), add = TRUE)
[17:01:01.562]                   }
[17:01:01.562]                   {
[17:01:01.562]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.562]                       FUN = function(jj) {
[17:01:01.562]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.562]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.562]                       })
[17:01:01.562]                   }
[17:01:01.562]                 }, args = future.call.arguments)
[17:01:01.562]             }))
[17:01:01.562]             future::FutureResult(value = ...future.value$value, 
[17:01:01.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.562]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.562]                     ...future.globalenv.names))
[17:01:01.562]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.562]         }, condition = base::local({
[17:01:01.562]             c <- base::c
[17:01:01.562]             inherits <- base::inherits
[17:01:01.562]             invokeRestart <- base::invokeRestart
[17:01:01.562]             length <- base::length
[17:01:01.562]             list <- base::list
[17:01:01.562]             seq.int <- base::seq.int
[17:01:01.562]             signalCondition <- base::signalCondition
[17:01:01.562]             sys.calls <- base::sys.calls
[17:01:01.562]             `[[` <- base::`[[`
[17:01:01.562]             `+` <- base::`+`
[17:01:01.562]             `<<-` <- base::`<<-`
[17:01:01.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.562]                   3L)]
[17:01:01.562]             }
[17:01:01.562]             function(cond) {
[17:01:01.562]                 is_error <- inherits(cond, "error")
[17:01:01.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.562]                   NULL)
[17:01:01.562]                 if (is_error) {
[17:01:01.562]                   sessionInformation <- function() {
[17:01:01.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.562]                       search = base::search(), system = base::Sys.info())
[17:01:01.562]                   }
[17:01:01.562]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.562]                     cond$call), session = sessionInformation(), 
[17:01:01.562]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.562]                   signalCondition(cond)
[17:01:01.562]                 }
[17:01:01.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.562]                 "immediateCondition"))) {
[17:01:01.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.562]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.562]                   if (TRUE && !signal) {
[17:01:01.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.562]                     {
[17:01:01.562]                       inherits <- base::inherits
[17:01:01.562]                       invokeRestart <- base::invokeRestart
[17:01:01.562]                       is.null <- base::is.null
[17:01:01.562]                       muffled <- FALSE
[17:01:01.562]                       if (inherits(cond, "message")) {
[17:01:01.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.562]                         if (muffled) 
[17:01:01.562]                           invokeRestart("muffleMessage")
[17:01:01.562]                       }
[17:01:01.562]                       else if (inherits(cond, "warning")) {
[17:01:01.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.562]                         if (muffled) 
[17:01:01.562]                           invokeRestart("muffleWarning")
[17:01:01.562]                       }
[17:01:01.562]                       else if (inherits(cond, "condition")) {
[17:01:01.562]                         if (!is.null(pattern)) {
[17:01:01.562]                           computeRestarts <- base::computeRestarts
[17:01:01.562]                           grepl <- base::grepl
[17:01:01.562]                           restarts <- computeRestarts(cond)
[17:01:01.562]                           for (restart in restarts) {
[17:01:01.562]                             name <- restart$name
[17:01:01.562]                             if (is.null(name)) 
[17:01:01.562]                               next
[17:01:01.562]                             if (!grepl(pattern, name)) 
[17:01:01.562]                               next
[17:01:01.562]                             invokeRestart(restart)
[17:01:01.562]                             muffled <- TRUE
[17:01:01.562]                             break
[17:01:01.562]                           }
[17:01:01.562]                         }
[17:01:01.562]                       }
[17:01:01.562]                       invisible(muffled)
[17:01:01.562]                     }
[17:01:01.562]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.562]                   }
[17:01:01.562]                 }
[17:01:01.562]                 else {
[17:01:01.562]                   if (TRUE) {
[17:01:01.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.562]                     {
[17:01:01.562]                       inherits <- base::inherits
[17:01:01.562]                       invokeRestart <- base::invokeRestart
[17:01:01.562]                       is.null <- base::is.null
[17:01:01.562]                       muffled <- FALSE
[17:01:01.562]                       if (inherits(cond, "message")) {
[17:01:01.562]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.562]                         if (muffled) 
[17:01:01.562]                           invokeRestart("muffleMessage")
[17:01:01.562]                       }
[17:01:01.562]                       else if (inherits(cond, "warning")) {
[17:01:01.562]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.562]                         if (muffled) 
[17:01:01.562]                           invokeRestart("muffleWarning")
[17:01:01.562]                       }
[17:01:01.562]                       else if (inherits(cond, "condition")) {
[17:01:01.562]                         if (!is.null(pattern)) {
[17:01:01.562]                           computeRestarts <- base::computeRestarts
[17:01:01.562]                           grepl <- base::grepl
[17:01:01.562]                           restarts <- computeRestarts(cond)
[17:01:01.562]                           for (restart in restarts) {
[17:01:01.562]                             name <- restart$name
[17:01:01.562]                             if (is.null(name)) 
[17:01:01.562]                               next
[17:01:01.562]                             if (!grepl(pattern, name)) 
[17:01:01.562]                               next
[17:01:01.562]                             invokeRestart(restart)
[17:01:01.562]                             muffled <- TRUE
[17:01:01.562]                             break
[17:01:01.562]                           }
[17:01:01.562]                         }
[17:01:01.562]                       }
[17:01:01.562]                       invisible(muffled)
[17:01:01.562]                     }
[17:01:01.562]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.562]                   }
[17:01:01.562]                 }
[17:01:01.562]             }
[17:01:01.562]         }))
[17:01:01.562]     }, error = function(ex) {
[17:01:01.562]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.562]                 ...future.rng), started = ...future.startTime, 
[17:01:01.562]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.562]             version = "1.8"), class = "FutureResult")
[17:01:01.562]     }, finally = {
[17:01:01.562]         if (!identical(...future.workdir, getwd())) 
[17:01:01.562]             setwd(...future.workdir)
[17:01:01.562]         {
[17:01:01.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.562]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.562]             }
[17:01:01.562]             base::options(...future.oldOptions)
[17:01:01.562]             if (.Platform$OS.type == "windows") {
[17:01:01.562]                 old_names <- names(...future.oldEnvVars)
[17:01:01.562]                 envs <- base::Sys.getenv()
[17:01:01.562]                 names <- names(envs)
[17:01:01.562]                 common <- intersect(names, old_names)
[17:01:01.562]                 added <- setdiff(names, old_names)
[17:01:01.562]                 removed <- setdiff(old_names, names)
[17:01:01.562]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.562]                   envs[common]]
[17:01:01.562]                 NAMES <- toupper(changed)
[17:01:01.562]                 args <- list()
[17:01:01.562]                 for (kk in seq_along(NAMES)) {
[17:01:01.562]                   name <- changed[[kk]]
[17:01:01.562]                   NAME <- NAMES[[kk]]
[17:01:01.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.562]                     next
[17:01:01.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.562]                 }
[17:01:01.562]                 NAMES <- toupper(added)
[17:01:01.562]                 for (kk in seq_along(NAMES)) {
[17:01:01.562]                   name <- added[[kk]]
[17:01:01.562]                   NAME <- NAMES[[kk]]
[17:01:01.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.562]                     next
[17:01:01.562]                   args[[name]] <- ""
[17:01:01.562]                 }
[17:01:01.562]                 NAMES <- toupper(removed)
[17:01:01.562]                 for (kk in seq_along(NAMES)) {
[17:01:01.562]                   name <- removed[[kk]]
[17:01:01.562]                   NAME <- NAMES[[kk]]
[17:01:01.562]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.562]                     next
[17:01:01.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.562]                 }
[17:01:01.562]                 if (length(args) > 0) 
[17:01:01.562]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.562]             }
[17:01:01.562]             else {
[17:01:01.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.562]             }
[17:01:01.562]             {
[17:01:01.562]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.562]                   0L) {
[17:01:01.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.562]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.562]                   base::options(opts)
[17:01:01.562]                 }
[17:01:01.562]                 {
[17:01:01.562]                   {
[17:01:01.562]                     NULL
[17:01:01.562]                     RNGkind("Mersenne-Twister")
[17:01:01.562]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.562]                       inherits = FALSE)
[17:01:01.562]                   }
[17:01:01.562]                   options(future.plan = NULL)
[17:01:01.562]                   if (is.na(NA_character_)) 
[17:01:01.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.562]                     .init = FALSE)
[17:01:01.562]                 }
[17:01:01.562]             }
[17:01:01.562]         }
[17:01:01.562]     })
[17:01:01.562]     if (TRUE) {
[17:01:01.562]         base::sink(type = "output", split = FALSE)
[17:01:01.562]         if (TRUE) {
[17:01:01.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.562]         }
[17:01:01.562]         else {
[17:01:01.562]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.562]         }
[17:01:01.562]         base::close(...future.stdout)
[17:01:01.562]         ...future.stdout <- NULL
[17:01:01.562]     }
[17:01:01.562]     ...future.result$conditions <- ...future.conditions
[17:01:01.562]     ...future.result$finished <- base::Sys.time()
[17:01:01.562]     ...future.result
[17:01:01.562] }
[17:01:01.564] assign_globals() ...
[17:01:01.564] List of 5
[17:01:01.564]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:01:01.564]  $ future.call.arguments    : list()
[17:01:01.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.564]  $ ...future.elements_ii    :List of 7
[17:01:01.564]   ..$ : int [1:3] 1 2 3
[17:01:01.564]   ..$ : int [1:4] 1 2 3 4
[17:01:01.564]   ..$ : int [1:5] 1 2 3 4 5
[17:01:01.564]   ..$ : int [1:6] 1 2 3 4 5 6
[17:01:01.564]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:01:01.564]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:01:01.564]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:01:01.564]  $ ...future.seeds_ii       : NULL
[17:01:01.564]  $ ...future.globals.maxSize: NULL
[17:01:01.564]  - attr(*, "where")=List of 5
[17:01:01.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.564]  - attr(*, "resolved")= logi FALSE
[17:01:01.564]  - attr(*, "total_size")= num 46960
[17:01:01.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.564]  - attr(*, "already-done")= logi TRUE
[17:01:01.570] - copied ‘...future.FUN’ to environment
[17:01:01.570] - copied ‘future.call.arguments’ to environment
[17:01:01.570] - copied ‘...future.elements_ii’ to environment
[17:01:01.571] - copied ‘...future.seeds_ii’ to environment
[17:01:01.571] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.571] assign_globals() ... done
[17:01:01.571] plan(): Setting new future strategy stack:
[17:01:01.571] List of future strategies:
[17:01:01.571] 1. sequential:
[17:01:01.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.571]    - tweaked: FALSE
[17:01:01.571]    - call: NULL
[17:01:01.572] plan(): nbrOfWorkers() = 1
[17:01:01.573] plan(): Setting new future strategy stack:
[17:01:01.573] List of future strategies:
[17:01:01.573] 1. sequential:
[17:01:01.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.573]    - tweaked: FALSE
[17:01:01.573]    - call: plan(strategy)
[17:01:01.573] plan(): nbrOfWorkers() = 1
[17:01:01.573] SequentialFuture started (and completed)
[17:01:01.573] - Launch lazy future ... done
[17:01:01.574] run() for ‘SequentialFuture’ ... done
[17:01:01.574] Created future:
[17:01:01.574] SequentialFuture:
[17:01:01.574] Label: ‘future_sapply-1’
[17:01:01.574] Expression:
[17:01:01.574] {
[17:01:01.574]     do.call(function(...) {
[17:01:01.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.574]             on.exit(options(oopts), add = TRUE)
[17:01:01.574]         }
[17:01:01.574]         {
[17:01:01.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.574]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.574]             })
[17:01:01.574]         }
[17:01:01.574]     }, args = future.call.arguments)
[17:01:01.574] }
[17:01:01.574] Lazy evaluation: FALSE
[17:01:01.574] Asynchronous evaluation: FALSE
[17:01:01.574] Local evaluation: TRUE
[17:01:01.574] Environment: R_GlobalEnv
[17:01:01.574] Capture standard output: TRUE
[17:01:01.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.574] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:01.574] Packages: 1 packages (‘stats’)
[17:01:01.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.574] Resolved: TRUE
[17:01:01.574] Value: 672 bytes of class ‘list’
[17:01:01.574] Early signaling: FALSE
[17:01:01.574] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.574] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.576] Chunk #1 of 1 ... DONE
[17:01:01.576] Launching 1 futures (chunks) ... DONE
[17:01:01.577] Resolving 1 futures (chunks) ...
[17:01:01.577] resolve() on list ...
[17:01:01.577]  recursive: 0
[17:01:01.577]  length: 1
[17:01:01.577] 
[17:01:01.577] resolved() for ‘SequentialFuture’ ...
[17:01:01.577] - state: ‘finished’
[17:01:01.577] - run: TRUE
[17:01:01.578] - result: ‘FutureResult’
[17:01:01.578] resolved() for ‘SequentialFuture’ ... done
[17:01:01.578] Future #1
[17:01:01.578] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.578] - nx: 1
[17:01:01.578] - relay: TRUE
[17:01:01.578] - stdout: TRUE
[17:01:01.578] - signal: TRUE
[17:01:01.578] - resignal: FALSE
[17:01:01.578] - force: TRUE
[17:01:01.579] - relayed: [n=1] FALSE
[17:01:01.579] - queued futures: [n=1] FALSE
[17:01:01.579]  - until=1
[17:01:01.579]  - relaying element #1
[17:01:01.579] - relayed: [n=1] TRUE
[17:01:01.579] - queued futures: [n=1] TRUE
[17:01:01.579] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.579]  length: 0 (resolved future 1)
[17:01:01.579] Relaying remaining futures
[17:01:01.580] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.580] - nx: 1
[17:01:01.580] - relay: TRUE
[17:01:01.580] - stdout: TRUE
[17:01:01.580] - signal: TRUE
[17:01:01.580] - resignal: FALSE
[17:01:01.580] - force: TRUE
[17:01:01.580] - relayed: [n=1] TRUE
[17:01:01.580] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.580] - relayed: [n=1] TRUE
[17:01:01.580] - queued futures: [n=1] TRUE
[17:01:01.580] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.581] resolve() on list ... DONE
[17:01:01.581]  - Number of value chunks collected: 1
[17:01:01.581] Resolving 1 futures (chunks) ... DONE
[17:01:01.581] Reducing values from 1 chunks ...
[17:01:01.581]  - Number of values collected after concatenation: 7
[17:01:01.581]  - Number of values expected: 7
[17:01:01.581] Reducing values from 1 chunks ... DONE
[17:01:01.581] future_lapply() ... DONE
[17:01:01.582] future_lapply() ...
[17:01:01.583] Number of chunks: 1
[17:01:01.583] getGlobalsAndPackagesXApply() ...
[17:01:01.584]  - future.globals: TRUE
[17:01:01.584] getGlobalsAndPackages() ...
[17:01:01.584] Searching for globals...
[17:01:01.590] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:01.591] Searching for globals ... DONE
[17:01:01.591] Resolving globals: FALSE
[17:01:01.592] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:01:01.592] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:01:01.592] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.593] - packages: [2] ‘stats’, ‘future.apply’
[17:01:01.593] getGlobalsAndPackages() ... DONE
[17:01:01.593]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.593]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:01.593] Finding globals ... DONE
[17:01:01.593]  - use_args: TRUE
[17:01:01.593]  - Getting '...' globals ...
[17:01:01.593] resolve() on list ...
[17:01:01.594]  recursive: 0
[17:01:01.594]  length: 1
[17:01:01.594]  elements: ‘...’
[17:01:01.594]  length: 0 (resolved future 1)
[17:01:01.594] resolve() on list ... DONE
[17:01:01.594]    - '...' content: [n=0] 
[17:01:01.594] List of 1
[17:01:01.594]  $ ...: list()
[17:01:01.594]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.594]  - attr(*, "where")=List of 1
[17:01:01.594]   ..$ ...:<environment: 0x55aad907a290> 
[17:01:01.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.594]  - attr(*, "resolved")= logi TRUE
[17:01:01.594]  - attr(*, "total_size")= num NA
[17:01:01.597]  - Getting '...' globals ... DONE
[17:01:01.598] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.598] List of 8
[17:01:01.598]  $ ...future.FUN:function (x, ...)  
[17:01:01.598]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:01:01.598]  $ times        : int 5
[17:01:01.598]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.598]  $ stop_if_not  :function (...)  
[17:01:01.598]  $ dim          : NULL
[17:01:01.598]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.598]  $ ...          : list()
[17:01:01.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.598]  - attr(*, "where")=List of 8
[17:01:01.598]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.598]   ..$ ...          :<environment: 0x55aad907a290> 
[17:01:01.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.598]  - attr(*, "resolved")= logi FALSE
[17:01:01.598]  - attr(*, "total_size")= num 141240
[17:01:01.604] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:01.604] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.604] Number of futures (= number of chunks): 1
[17:01:01.604] Launching 1 futures (chunks) ...
[17:01:01.605] Chunk #1 of 1 ...
[17:01:01.605]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.605] getGlobalsAndPackages() ...
[17:01:01.605] Searching for globals...
[17:01:01.605] 
[17:01:01.605] Searching for globals ... DONE
[17:01:01.605] - globals: [0] <none>
[17:01:01.605] getGlobalsAndPackages() ... DONE
[17:01:01.605]    + additional globals found: [n=0] 
[17:01:01.606]    + additional namespaces needed: [n=0] 
[17:01:01.606]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.606]  - seeds: <none>
[17:01:01.606]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.606] getGlobalsAndPackages() ...
[17:01:01.606] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.606] Resolving globals: FALSE
[17:01:01.606] Tweak future expression to call with '...' arguments ...
[17:01:01.606] {
[17:01:01.606]     do.call(function(...) {
[17:01:01.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.606]             on.exit(options(oopts), add = TRUE)
[17:01:01.606]         }
[17:01:01.606]         {
[17:01:01.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.606]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.606]             })
[17:01:01.606]         }
[17:01:01.606]     }, args = future.call.arguments)
[17:01:01.606] }
[17:01:01.607] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.607] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.607] - packages: [2] ‘stats’, ‘future.apply’
[17:01:01.607] getGlobalsAndPackages() ... DONE
[17:01:01.608] run() for ‘Future’ ...
[17:01:01.608] - state: ‘created’
[17:01:01.608] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.608] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.608]   - Field: ‘label’
[17:01:01.609]   - Field: ‘local’
[17:01:01.609]   - Field: ‘owner’
[17:01:01.609]   - Field: ‘envir’
[17:01:01.609]   - Field: ‘packages’
[17:01:01.609]   - Field: ‘gc’
[17:01:01.609]   - Field: ‘conditions’
[17:01:01.609]   - Field: ‘expr’
[17:01:01.609]   - Field: ‘uuid’
[17:01:01.609]   - Field: ‘seed’
[17:01:01.609]   - Field: ‘version’
[17:01:01.609]   - Field: ‘result’
[17:01:01.610]   - Field: ‘asynchronous’
[17:01:01.610]   - Field: ‘calls’
[17:01:01.610]   - Field: ‘globals’
[17:01:01.610]   - Field: ‘stdout’
[17:01:01.610]   - Field: ‘earlySignal’
[17:01:01.610]   - Field: ‘lazy’
[17:01:01.610]   - Field: ‘state’
[17:01:01.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.610] - Launch lazy future ...
[17:01:01.610] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:01.611] Packages needed by future strategies (n = 0): <none>
[17:01:01.611] {
[17:01:01.611]     {
[17:01:01.611]         {
[17:01:01.611]             ...future.startTime <- base::Sys.time()
[17:01:01.611]             {
[17:01:01.611]                 {
[17:01:01.611]                   {
[17:01:01.611]                     {
[17:01:01.611]                       base::local({
[17:01:01.611]                         has_future <- base::requireNamespace("future", 
[17:01:01.611]                           quietly = TRUE)
[17:01:01.611]                         if (has_future) {
[17:01:01.611]                           ns <- base::getNamespace("future")
[17:01:01.611]                           version <- ns[[".package"]][["version"]]
[17:01:01.611]                           if (is.null(version)) 
[17:01:01.611]                             version <- utils::packageVersion("future")
[17:01:01.611]                         }
[17:01:01.611]                         else {
[17:01:01.611]                           version <- NULL
[17:01:01.611]                         }
[17:01:01.611]                         if (!has_future || version < "1.8.0") {
[17:01:01.611]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.611]                             "", base::R.version$version.string), 
[17:01:01.611]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.611]                               "release", "version")], collapse = " "), 
[17:01:01.611]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.611]                             info)
[17:01:01.611]                           info <- base::paste(info, collapse = "; ")
[17:01:01.611]                           if (!has_future) {
[17:01:01.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.611]                               info)
[17:01:01.611]                           }
[17:01:01.611]                           else {
[17:01:01.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.611]                               info, version)
[17:01:01.611]                           }
[17:01:01.611]                           base::stop(msg)
[17:01:01.611]                         }
[17:01:01.611]                       })
[17:01:01.611]                     }
[17:01:01.611]                     base::local({
[17:01:01.611]                       for (pkg in c("stats", "future.apply")) {
[17:01:01.611]                         base::loadNamespace(pkg)
[17:01:01.611]                         base::library(pkg, character.only = TRUE)
[17:01:01.611]                       }
[17:01:01.611]                     })
[17:01:01.611]                   }
[17:01:01.611]                   ...future.strategy.old <- future::plan("list")
[17:01:01.611]                   options(future.plan = NULL)
[17:01:01.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.611]                 }
[17:01:01.611]                 ...future.workdir <- getwd()
[17:01:01.611]             }
[17:01:01.611]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.611]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.611]         }
[17:01:01.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.611]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.611]             base::names(...future.oldOptions))
[17:01:01.611]     }
[17:01:01.611]     if (FALSE) {
[17:01:01.611]     }
[17:01:01.611]     else {
[17:01:01.611]         if (TRUE) {
[17:01:01.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.611]                 open = "w")
[17:01:01.611]         }
[17:01:01.611]         else {
[17:01:01.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.611]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.611]         }
[17:01:01.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.611]             base::sink(type = "output", split = FALSE)
[17:01:01.611]             base::close(...future.stdout)
[17:01:01.611]         }, add = TRUE)
[17:01:01.611]     }
[17:01:01.611]     ...future.frame <- base::sys.nframe()
[17:01:01.611]     ...future.conditions <- base::list()
[17:01:01.611]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.611]     if (FALSE) {
[17:01:01.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.611]     }
[17:01:01.611]     ...future.result <- base::tryCatch({
[17:01:01.611]         base::withCallingHandlers({
[17:01:01.611]             ...future.value <- base::withVisible(base::local({
[17:01:01.611]                 do.call(function(...) {
[17:01:01.611]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.611]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.611]                     ...future.globals.maxSize)) {
[17:01:01.611]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.611]                     on.exit(options(oopts), add = TRUE)
[17:01:01.611]                   }
[17:01:01.611]                   {
[17:01:01.611]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.611]                       FUN = function(jj) {
[17:01:01.611]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.611]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.611]                       })
[17:01:01.611]                   }
[17:01:01.611]                 }, args = future.call.arguments)
[17:01:01.611]             }))
[17:01:01.611]             future::FutureResult(value = ...future.value$value, 
[17:01:01.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.611]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.611]                     ...future.globalenv.names))
[17:01:01.611]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.611]         }, condition = base::local({
[17:01:01.611]             c <- base::c
[17:01:01.611]             inherits <- base::inherits
[17:01:01.611]             invokeRestart <- base::invokeRestart
[17:01:01.611]             length <- base::length
[17:01:01.611]             list <- base::list
[17:01:01.611]             seq.int <- base::seq.int
[17:01:01.611]             signalCondition <- base::signalCondition
[17:01:01.611]             sys.calls <- base::sys.calls
[17:01:01.611]             `[[` <- base::`[[`
[17:01:01.611]             `+` <- base::`+`
[17:01:01.611]             `<<-` <- base::`<<-`
[17:01:01.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.611]                   3L)]
[17:01:01.611]             }
[17:01:01.611]             function(cond) {
[17:01:01.611]                 is_error <- inherits(cond, "error")
[17:01:01.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.611]                   NULL)
[17:01:01.611]                 if (is_error) {
[17:01:01.611]                   sessionInformation <- function() {
[17:01:01.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.611]                       search = base::search(), system = base::Sys.info())
[17:01:01.611]                   }
[17:01:01.611]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.611]                     cond$call), session = sessionInformation(), 
[17:01:01.611]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.611]                   signalCondition(cond)
[17:01:01.611]                 }
[17:01:01.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.611]                 "immediateCondition"))) {
[17:01:01.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.611]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.611]                   if (TRUE && !signal) {
[17:01:01.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.611]                     {
[17:01:01.611]                       inherits <- base::inherits
[17:01:01.611]                       invokeRestart <- base::invokeRestart
[17:01:01.611]                       is.null <- base::is.null
[17:01:01.611]                       muffled <- FALSE
[17:01:01.611]                       if (inherits(cond, "message")) {
[17:01:01.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.611]                         if (muffled) 
[17:01:01.611]                           invokeRestart("muffleMessage")
[17:01:01.611]                       }
[17:01:01.611]                       else if (inherits(cond, "warning")) {
[17:01:01.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.611]                         if (muffled) 
[17:01:01.611]                           invokeRestart("muffleWarning")
[17:01:01.611]                       }
[17:01:01.611]                       else if (inherits(cond, "condition")) {
[17:01:01.611]                         if (!is.null(pattern)) {
[17:01:01.611]                           computeRestarts <- base::computeRestarts
[17:01:01.611]                           grepl <- base::grepl
[17:01:01.611]                           restarts <- computeRestarts(cond)
[17:01:01.611]                           for (restart in restarts) {
[17:01:01.611]                             name <- restart$name
[17:01:01.611]                             if (is.null(name)) 
[17:01:01.611]                               next
[17:01:01.611]                             if (!grepl(pattern, name)) 
[17:01:01.611]                               next
[17:01:01.611]                             invokeRestart(restart)
[17:01:01.611]                             muffled <- TRUE
[17:01:01.611]                             break
[17:01:01.611]                           }
[17:01:01.611]                         }
[17:01:01.611]                       }
[17:01:01.611]                       invisible(muffled)
[17:01:01.611]                     }
[17:01:01.611]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.611]                   }
[17:01:01.611]                 }
[17:01:01.611]                 else {
[17:01:01.611]                   if (TRUE) {
[17:01:01.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.611]                     {
[17:01:01.611]                       inherits <- base::inherits
[17:01:01.611]                       invokeRestart <- base::invokeRestart
[17:01:01.611]                       is.null <- base::is.null
[17:01:01.611]                       muffled <- FALSE
[17:01:01.611]                       if (inherits(cond, "message")) {
[17:01:01.611]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.611]                         if (muffled) 
[17:01:01.611]                           invokeRestart("muffleMessage")
[17:01:01.611]                       }
[17:01:01.611]                       else if (inherits(cond, "warning")) {
[17:01:01.611]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.611]                         if (muffled) 
[17:01:01.611]                           invokeRestart("muffleWarning")
[17:01:01.611]                       }
[17:01:01.611]                       else if (inherits(cond, "condition")) {
[17:01:01.611]                         if (!is.null(pattern)) {
[17:01:01.611]                           computeRestarts <- base::computeRestarts
[17:01:01.611]                           grepl <- base::grepl
[17:01:01.611]                           restarts <- computeRestarts(cond)
[17:01:01.611]                           for (restart in restarts) {
[17:01:01.611]                             name <- restart$name
[17:01:01.611]                             if (is.null(name)) 
[17:01:01.611]                               next
[17:01:01.611]                             if (!grepl(pattern, name)) 
[17:01:01.611]                               next
[17:01:01.611]                             invokeRestart(restart)
[17:01:01.611]                             muffled <- TRUE
[17:01:01.611]                             break
[17:01:01.611]                           }
[17:01:01.611]                         }
[17:01:01.611]                       }
[17:01:01.611]                       invisible(muffled)
[17:01:01.611]                     }
[17:01:01.611]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.611]                   }
[17:01:01.611]                 }
[17:01:01.611]             }
[17:01:01.611]         }))
[17:01:01.611]     }, error = function(ex) {
[17:01:01.611]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.611]                 ...future.rng), started = ...future.startTime, 
[17:01:01.611]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.611]             version = "1.8"), class = "FutureResult")
[17:01:01.611]     }, finally = {
[17:01:01.611]         if (!identical(...future.workdir, getwd())) 
[17:01:01.611]             setwd(...future.workdir)
[17:01:01.611]         {
[17:01:01.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.611]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.611]             }
[17:01:01.611]             base::options(...future.oldOptions)
[17:01:01.611]             if (.Platform$OS.type == "windows") {
[17:01:01.611]                 old_names <- names(...future.oldEnvVars)
[17:01:01.611]                 envs <- base::Sys.getenv()
[17:01:01.611]                 names <- names(envs)
[17:01:01.611]                 common <- intersect(names, old_names)
[17:01:01.611]                 added <- setdiff(names, old_names)
[17:01:01.611]                 removed <- setdiff(old_names, names)
[17:01:01.611]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.611]                   envs[common]]
[17:01:01.611]                 NAMES <- toupper(changed)
[17:01:01.611]                 args <- list()
[17:01:01.611]                 for (kk in seq_along(NAMES)) {
[17:01:01.611]                   name <- changed[[kk]]
[17:01:01.611]                   NAME <- NAMES[[kk]]
[17:01:01.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.611]                     next
[17:01:01.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.611]                 }
[17:01:01.611]                 NAMES <- toupper(added)
[17:01:01.611]                 for (kk in seq_along(NAMES)) {
[17:01:01.611]                   name <- added[[kk]]
[17:01:01.611]                   NAME <- NAMES[[kk]]
[17:01:01.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.611]                     next
[17:01:01.611]                   args[[name]] <- ""
[17:01:01.611]                 }
[17:01:01.611]                 NAMES <- toupper(removed)
[17:01:01.611]                 for (kk in seq_along(NAMES)) {
[17:01:01.611]                   name <- removed[[kk]]
[17:01:01.611]                   NAME <- NAMES[[kk]]
[17:01:01.611]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.611]                     next
[17:01:01.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.611]                 }
[17:01:01.611]                 if (length(args) > 0) 
[17:01:01.611]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.611]             }
[17:01:01.611]             else {
[17:01:01.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.611]             }
[17:01:01.611]             {
[17:01:01.611]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.611]                   0L) {
[17:01:01.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.611]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.611]                   base::options(opts)
[17:01:01.611]                 }
[17:01:01.611]                 {
[17:01:01.611]                   {
[17:01:01.611]                     NULL
[17:01:01.611]                     RNGkind("Mersenne-Twister")
[17:01:01.611]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.611]                       inherits = FALSE)
[17:01:01.611]                   }
[17:01:01.611]                   options(future.plan = NULL)
[17:01:01.611]                   if (is.na(NA_character_)) 
[17:01:01.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.611]                     .init = FALSE)
[17:01:01.611]                 }
[17:01:01.611]             }
[17:01:01.611]         }
[17:01:01.611]     })
[17:01:01.611]     if (TRUE) {
[17:01:01.611]         base::sink(type = "output", split = FALSE)
[17:01:01.611]         if (TRUE) {
[17:01:01.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.611]         }
[17:01:01.611]         else {
[17:01:01.611]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.611]         }
[17:01:01.611]         base::close(...future.stdout)
[17:01:01.611]         ...future.stdout <- NULL
[17:01:01.611]     }
[17:01:01.611]     ...future.result$conditions <- ...future.conditions
[17:01:01.611]     ...future.result$finished <- base::Sys.time()
[17:01:01.611]     ...future.result
[17:01:01.611] }
[17:01:01.613] assign_globals() ...
[17:01:01.613] List of 11
[17:01:01.613]  $ ...future.FUN            :function (x, ...)  
[17:01:01.613]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:01:01.613]  $ times                    : int 5
[17:01:01.613]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.613]  $ stop_if_not              :function (...)  
[17:01:01.613]  $ dim                      : NULL
[17:01:01.613]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.613]  $ future.call.arguments    : list()
[17:01:01.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.613]  $ ...future.elements_ii    :List of 7
[17:01:01.613]   ..$ : int [1:3] 1 2 3
[17:01:01.613]   ..$ : int [1:4] 1 2 3 4
[17:01:01.613]   ..$ : int [1:5] 1 2 3 4 5
[17:01:01.613]   ..$ : int [1:6] 1 2 3 4 5 6
[17:01:01.613]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:01:01.613]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:01:01.613]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:01:01.613]  $ ...future.seeds_ii       : NULL
[17:01:01.613]  $ ...future.globals.maxSize: NULL
[17:01:01.613]  - attr(*, "where")=List of 11
[17:01:01.613]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.613]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.613]  - attr(*, "resolved")= logi FALSE
[17:01:01.613]  - attr(*, "total_size")= num 141240
[17:01:01.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.613]  - attr(*, "already-done")= logi TRUE
[17:01:01.623] - copied ‘...future.FUN’ to environment
[17:01:01.624] - copied ‘x_FUN’ to environment
[17:01:01.624] - copied ‘times’ to environment
[17:01:01.624] - copied ‘stopf’ to environment
[17:01:01.624] - copied ‘stop_if_not’ to environment
[17:01:01.624] - copied ‘dim’ to environment
[17:01:01.624] - copied ‘valid_types’ to environment
[17:01:01.624] - copied ‘future.call.arguments’ to environment
[17:01:01.624] - copied ‘...future.elements_ii’ to environment
[17:01:01.624] - copied ‘...future.seeds_ii’ to environment
[17:01:01.625] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.625] assign_globals() ... done
[17:01:01.625] plan(): Setting new future strategy stack:
[17:01:01.625] List of future strategies:
[17:01:01.625] 1. sequential:
[17:01:01.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.625]    - tweaked: FALSE
[17:01:01.625]    - call: NULL
[17:01:01.626] plan(): nbrOfWorkers() = 1
[17:01:01.627] plan(): Setting new future strategy stack:
[17:01:01.627] List of future strategies:
[17:01:01.627] 1. sequential:
[17:01:01.627]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.627]    - tweaked: FALSE
[17:01:01.627]    - call: plan(strategy)
[17:01:01.627] plan(): nbrOfWorkers() = 1
[17:01:01.627] SequentialFuture started (and completed)
[17:01:01.627] - Launch lazy future ... done
[17:01:01.628] run() for ‘SequentialFuture’ ... done
[17:01:01.628] Created future:
[17:01:01.628] SequentialFuture:
[17:01:01.628] Label: ‘future_vapply-1’
[17:01:01.628] Expression:
[17:01:01.628] {
[17:01:01.628]     do.call(function(...) {
[17:01:01.628]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.628]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.628]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.628]             on.exit(options(oopts), add = TRUE)
[17:01:01.628]         }
[17:01:01.628]         {
[17:01:01.628]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.628]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.628]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.628]             })
[17:01:01.628]         }
[17:01:01.628]     }, args = future.call.arguments)
[17:01:01.628] }
[17:01:01.628] Lazy evaluation: FALSE
[17:01:01.628] Asynchronous evaluation: FALSE
[17:01:01.628] Local evaluation: TRUE
[17:01:01.628] Environment: R_GlobalEnv
[17:01:01.628] Capture standard output: TRUE
[17:01:01.628] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.628] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.628] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:01.628] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.628] Resolved: TRUE
[17:01:01.628] Value: 672 bytes of class ‘list’
[17:01:01.628] Early signaling: FALSE
[17:01:01.628] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.628] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.629] Chunk #1 of 1 ... DONE
[17:01:01.629] Launching 1 futures (chunks) ... DONE
[17:01:01.629] Resolving 1 futures (chunks) ...
[17:01:01.629] resolve() on list ...
[17:01:01.629]  recursive: 0
[17:01:01.629]  length: 1
[17:01:01.629] 
[17:01:01.630] resolved() for ‘SequentialFuture’ ...
[17:01:01.630] - state: ‘finished’
[17:01:01.630] - run: TRUE
[17:01:01.630] - result: ‘FutureResult’
[17:01:01.630] resolved() for ‘SequentialFuture’ ... done
[17:01:01.630] Future #1
[17:01:01.630] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.630] - nx: 1
[17:01:01.630] - relay: TRUE
[17:01:01.630] - stdout: TRUE
[17:01:01.631] - signal: TRUE
[17:01:01.631] - resignal: FALSE
[17:01:01.631] - force: TRUE
[17:01:01.631] - relayed: [n=1] FALSE
[17:01:01.631] - queued futures: [n=1] FALSE
[17:01:01.631]  - until=1
[17:01:01.631]  - relaying element #1
[17:01:01.631] - relayed: [n=1] TRUE
[17:01:01.631] - queued futures: [n=1] TRUE
[17:01:01.631] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.632]  length: 0 (resolved future 1)
[17:01:01.632] Relaying remaining futures
[17:01:01.632] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.632] - nx: 1
[17:01:01.632] - relay: TRUE
[17:01:01.632] - stdout: TRUE
[17:01:01.632] - signal: TRUE
[17:01:01.632] - resignal: FALSE
[17:01:01.632] - force: TRUE
[17:01:01.632] - relayed: [n=1] TRUE
[17:01:01.632] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.632] - relayed: [n=1] TRUE
[17:01:01.633] - queued futures: [n=1] TRUE
[17:01:01.633] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.633] resolve() on list ... DONE
[17:01:01.633]  - Number of value chunks collected: 1
[17:01:01.633] Resolving 1 futures (chunks) ... DONE
[17:01:01.633] Reducing values from 1 chunks ...
[17:01:01.633]  - Number of values collected after concatenation: 7
[17:01:01.633]  - Number of values expected: 7
[17:01:01.633] Reducing values from 1 chunks ... DONE
[17:01:01.634] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:01:01.635] future_lapply() ...
[17:01:01.636] Number of chunks: 1
[17:01:01.636] getGlobalsAndPackagesXApply() ...
[17:01:01.636]  - future.globals: TRUE
[17:01:01.636] getGlobalsAndPackages() ...
[17:01:01.636] Searching for globals...
[17:01:01.637] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:01:01.638] Searching for globals ... DONE
[17:01:01.638] Resolving globals: FALSE
[17:01:01.638] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:01:01.638] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:01:01.638] - globals: [1] ‘FUN’
[17:01:01.639] 
[17:01:01.639] getGlobalsAndPackages() ... DONE
[17:01:01.639]  - globals found/used: [n=1] ‘FUN’
[17:01:01.639]  - needed namespaces: [n=0] 
[17:01:01.639] Finding globals ... DONE
[17:01:01.639]  - use_args: TRUE
[17:01:01.639]  - Getting '...' globals ...
[17:01:01.639] resolve() on list ...
[17:01:01.640]  recursive: 0
[17:01:01.640]  length: 1
[17:01:01.640]  elements: ‘...’
[17:01:01.640]  length: 0 (resolved future 1)
[17:01:01.640] resolve() on list ... DONE
[17:01:01.640]    - '...' content: [n=1] ‘y’
[17:01:01.640] List of 1
[17:01:01.640]  $ ...:List of 1
[17:01:01.640]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.640]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.640]  - attr(*, "where")=List of 1
[17:01:01.640]   ..$ ...:<environment: 0x55aadb170060> 
[17:01:01.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.640]  - attr(*, "resolved")= logi TRUE
[17:01:01.640]  - attr(*, "total_size")= num NA
[17:01:01.643]  - Getting '...' globals ... DONE
[17:01:01.643] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:01.643] List of 2
[17:01:01.643]  $ ...future.FUN:function (x, y)  
[17:01:01.643]  $ ...          :List of 1
[17:01:01.643]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.643]  - attr(*, "where")=List of 2
[17:01:01.643]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.643]   ..$ ...          :<environment: 0x55aadb170060> 
[17:01:01.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.643]  - attr(*, "resolved")= logi FALSE
[17:01:01.643]  - attr(*, "total_size")= num 4264
[17:01:01.648] Packages to be attached in all futures: [n=0] 
[17:01:01.648] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.648] Number of futures (= number of chunks): 1
[17:01:01.649] Launching 1 futures (chunks) ...
[17:01:01.649] Chunk #1 of 1 ...
[17:01:01.649]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.649] getGlobalsAndPackages() ...
[17:01:01.649] Searching for globals...
[17:01:01.649] 
[17:01:01.649] Searching for globals ... DONE
[17:01:01.650] - globals: [0] <none>
[17:01:01.650] getGlobalsAndPackages() ... DONE
[17:01:01.650]    + additional globals found: [n=0] 
[17:01:01.650]    + additional namespaces needed: [n=0] 
[17:01:01.650]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.650]  - seeds: <none>
[17:01:01.650]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.650] getGlobalsAndPackages() ...
[17:01:01.650] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.650] Resolving globals: FALSE
[17:01:01.651] Tweak future expression to call with '...' arguments ...
[17:01:01.651] {
[17:01:01.651]     do.call(function(...) {
[17:01:01.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.651]             on.exit(options(oopts), add = TRUE)
[17:01:01.651]         }
[17:01:01.651]         {
[17:01:01.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.651]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.651]             })
[17:01:01.651]         }
[17:01:01.651]     }, args = future.call.arguments)
[17:01:01.651] }
[17:01:01.651] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.651] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.651] 
[17:01:01.652] getGlobalsAndPackages() ... DONE
[17:01:01.652] run() for ‘Future’ ...
[17:01:01.652] - state: ‘created’
[17:01:01.652] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.652] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.653]   - Field: ‘label’
[17:01:01.653]   - Field: ‘local’
[17:01:01.653]   - Field: ‘owner’
[17:01:01.653]   - Field: ‘envir’
[17:01:01.653]   - Field: ‘packages’
[17:01:01.653]   - Field: ‘gc’
[17:01:01.653]   - Field: ‘conditions’
[17:01:01.653]   - Field: ‘expr’
[17:01:01.653]   - Field: ‘uuid’
[17:01:01.653]   - Field: ‘seed’
[17:01:01.654]   - Field: ‘version’
[17:01:01.654]   - Field: ‘result’
[17:01:01.654]   - Field: ‘asynchronous’
[17:01:01.654]   - Field: ‘calls’
[17:01:01.654]   - Field: ‘globals’
[17:01:01.654]   - Field: ‘stdout’
[17:01:01.654]   - Field: ‘earlySignal’
[17:01:01.654]   - Field: ‘lazy’
[17:01:01.654]   - Field: ‘state’
[17:01:01.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.654] - Launch lazy future ...
[17:01:01.655] Packages needed by the future expression (n = 0): <none>
[17:01:01.655] Packages needed by future strategies (n = 0): <none>
[17:01:01.655] {
[17:01:01.655]     {
[17:01:01.655]         {
[17:01:01.655]             ...future.startTime <- base::Sys.time()
[17:01:01.655]             {
[17:01:01.655]                 {
[17:01:01.655]                   {
[17:01:01.655]                     base::local({
[17:01:01.655]                       has_future <- base::requireNamespace("future", 
[17:01:01.655]                         quietly = TRUE)
[17:01:01.655]                       if (has_future) {
[17:01:01.655]                         ns <- base::getNamespace("future")
[17:01:01.655]                         version <- ns[[".package"]][["version"]]
[17:01:01.655]                         if (is.null(version)) 
[17:01:01.655]                           version <- utils::packageVersion("future")
[17:01:01.655]                       }
[17:01:01.655]                       else {
[17:01:01.655]                         version <- NULL
[17:01:01.655]                       }
[17:01:01.655]                       if (!has_future || version < "1.8.0") {
[17:01:01.655]                         info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.655]                           "", base::R.version$version.string), 
[17:01:01.655]                           platform = base::sprintf("%s (%s-bit)", 
[17:01:01.655]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.655]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.655]                             "release", "version")], collapse = " "), 
[17:01:01.655]                           hostname = base::Sys.info()[["nodename"]])
[17:01:01.655]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.655]                           info)
[17:01:01.655]                         info <- base::paste(info, collapse = "; ")
[17:01:01.655]                         if (!has_future) {
[17:01:01.655]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.655]                             info)
[17:01:01.655]                         }
[17:01:01.655]                         else {
[17:01:01.655]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.655]                             info, version)
[17:01:01.655]                         }
[17:01:01.655]                         base::stop(msg)
[17:01:01.655]                       }
[17:01:01.655]                     })
[17:01:01.655]                   }
[17:01:01.655]                   ...future.strategy.old <- future::plan("list")
[17:01:01.655]                   options(future.plan = NULL)
[17:01:01.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.655]                 }
[17:01:01.655]                 ...future.workdir <- getwd()
[17:01:01.655]             }
[17:01:01.655]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.655]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.655]         }
[17:01:01.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.655]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.655]             base::names(...future.oldOptions))
[17:01:01.655]     }
[17:01:01.655]     if (FALSE) {
[17:01:01.655]     }
[17:01:01.655]     else {
[17:01:01.655]         if (TRUE) {
[17:01:01.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.655]                 open = "w")
[17:01:01.655]         }
[17:01:01.655]         else {
[17:01:01.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.655]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.655]         }
[17:01:01.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.655]             base::sink(type = "output", split = FALSE)
[17:01:01.655]             base::close(...future.stdout)
[17:01:01.655]         }, add = TRUE)
[17:01:01.655]     }
[17:01:01.655]     ...future.frame <- base::sys.nframe()
[17:01:01.655]     ...future.conditions <- base::list()
[17:01:01.655]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.655]     if (FALSE) {
[17:01:01.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.655]     }
[17:01:01.655]     ...future.result <- base::tryCatch({
[17:01:01.655]         base::withCallingHandlers({
[17:01:01.655]             ...future.value <- base::withVisible(base::local({
[17:01:01.655]                 do.call(function(...) {
[17:01:01.655]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.655]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.655]                     ...future.globals.maxSize)) {
[17:01:01.655]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.655]                     on.exit(options(oopts), add = TRUE)
[17:01:01.655]                   }
[17:01:01.655]                   {
[17:01:01.655]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.655]                       FUN = function(jj) {
[17:01:01.655]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.655]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.655]                       })
[17:01:01.655]                   }
[17:01:01.655]                 }, args = future.call.arguments)
[17:01:01.655]             }))
[17:01:01.655]             future::FutureResult(value = ...future.value$value, 
[17:01:01.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.655]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.655]                     ...future.globalenv.names))
[17:01:01.655]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.655]         }, condition = base::local({
[17:01:01.655]             c <- base::c
[17:01:01.655]             inherits <- base::inherits
[17:01:01.655]             invokeRestart <- base::invokeRestart
[17:01:01.655]             length <- base::length
[17:01:01.655]             list <- base::list
[17:01:01.655]             seq.int <- base::seq.int
[17:01:01.655]             signalCondition <- base::signalCondition
[17:01:01.655]             sys.calls <- base::sys.calls
[17:01:01.655]             `[[` <- base::`[[`
[17:01:01.655]             `+` <- base::`+`
[17:01:01.655]             `<<-` <- base::`<<-`
[17:01:01.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.655]                   3L)]
[17:01:01.655]             }
[17:01:01.655]             function(cond) {
[17:01:01.655]                 is_error <- inherits(cond, "error")
[17:01:01.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.655]                   NULL)
[17:01:01.655]                 if (is_error) {
[17:01:01.655]                   sessionInformation <- function() {
[17:01:01.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.655]                       search = base::search(), system = base::Sys.info())
[17:01:01.655]                   }
[17:01:01.655]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.655]                     cond$call), session = sessionInformation(), 
[17:01:01.655]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.655]                   signalCondition(cond)
[17:01:01.655]                 }
[17:01:01.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.655]                 "immediateCondition"))) {
[17:01:01.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.655]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.655]                   if (TRUE && !signal) {
[17:01:01.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.655]                     {
[17:01:01.655]                       inherits <- base::inherits
[17:01:01.655]                       invokeRestart <- base::invokeRestart
[17:01:01.655]                       is.null <- base::is.null
[17:01:01.655]                       muffled <- FALSE
[17:01:01.655]                       if (inherits(cond, "message")) {
[17:01:01.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.655]                         if (muffled) 
[17:01:01.655]                           invokeRestart("muffleMessage")
[17:01:01.655]                       }
[17:01:01.655]                       else if (inherits(cond, "warning")) {
[17:01:01.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.655]                         if (muffled) 
[17:01:01.655]                           invokeRestart("muffleWarning")
[17:01:01.655]                       }
[17:01:01.655]                       else if (inherits(cond, "condition")) {
[17:01:01.655]                         if (!is.null(pattern)) {
[17:01:01.655]                           computeRestarts <- base::computeRestarts
[17:01:01.655]                           grepl <- base::grepl
[17:01:01.655]                           restarts <- computeRestarts(cond)
[17:01:01.655]                           for (restart in restarts) {
[17:01:01.655]                             name <- restart$name
[17:01:01.655]                             if (is.null(name)) 
[17:01:01.655]                               next
[17:01:01.655]                             if (!grepl(pattern, name)) 
[17:01:01.655]                               next
[17:01:01.655]                             invokeRestart(restart)
[17:01:01.655]                             muffled <- TRUE
[17:01:01.655]                             break
[17:01:01.655]                           }
[17:01:01.655]                         }
[17:01:01.655]                       }
[17:01:01.655]                       invisible(muffled)
[17:01:01.655]                     }
[17:01:01.655]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.655]                   }
[17:01:01.655]                 }
[17:01:01.655]                 else {
[17:01:01.655]                   if (TRUE) {
[17:01:01.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.655]                     {
[17:01:01.655]                       inherits <- base::inherits
[17:01:01.655]                       invokeRestart <- base::invokeRestart
[17:01:01.655]                       is.null <- base::is.null
[17:01:01.655]                       muffled <- FALSE
[17:01:01.655]                       if (inherits(cond, "message")) {
[17:01:01.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.655]                         if (muffled) 
[17:01:01.655]                           invokeRestart("muffleMessage")
[17:01:01.655]                       }
[17:01:01.655]                       else if (inherits(cond, "warning")) {
[17:01:01.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.655]                         if (muffled) 
[17:01:01.655]                           invokeRestart("muffleWarning")
[17:01:01.655]                       }
[17:01:01.655]                       else if (inherits(cond, "condition")) {
[17:01:01.655]                         if (!is.null(pattern)) {
[17:01:01.655]                           computeRestarts <- base::computeRestarts
[17:01:01.655]                           grepl <- base::grepl
[17:01:01.655]                           restarts <- computeRestarts(cond)
[17:01:01.655]                           for (restart in restarts) {
[17:01:01.655]                             name <- restart$name
[17:01:01.655]                             if (is.null(name)) 
[17:01:01.655]                               next
[17:01:01.655]                             if (!grepl(pattern, name)) 
[17:01:01.655]                               next
[17:01:01.655]                             invokeRestart(restart)
[17:01:01.655]                             muffled <- TRUE
[17:01:01.655]                             break
[17:01:01.655]                           }
[17:01:01.655]                         }
[17:01:01.655]                       }
[17:01:01.655]                       invisible(muffled)
[17:01:01.655]                     }
[17:01:01.655]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.655]                   }
[17:01:01.655]                 }
[17:01:01.655]             }
[17:01:01.655]         }))
[17:01:01.655]     }, error = function(ex) {
[17:01:01.655]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.655]                 ...future.rng), started = ...future.startTime, 
[17:01:01.655]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.655]             version = "1.8"), class = "FutureResult")
[17:01:01.655]     }, finally = {
[17:01:01.655]         if (!identical(...future.workdir, getwd())) 
[17:01:01.655]             setwd(...future.workdir)
[17:01:01.655]         {
[17:01:01.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.655]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.655]             }
[17:01:01.655]             base::options(...future.oldOptions)
[17:01:01.655]             if (.Platform$OS.type == "windows") {
[17:01:01.655]                 old_names <- names(...future.oldEnvVars)
[17:01:01.655]                 envs <- base::Sys.getenv()
[17:01:01.655]                 names <- names(envs)
[17:01:01.655]                 common <- intersect(names, old_names)
[17:01:01.655]                 added <- setdiff(names, old_names)
[17:01:01.655]                 removed <- setdiff(old_names, names)
[17:01:01.655]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.655]                   envs[common]]
[17:01:01.655]                 NAMES <- toupper(changed)
[17:01:01.655]                 args <- list()
[17:01:01.655]                 for (kk in seq_along(NAMES)) {
[17:01:01.655]                   name <- changed[[kk]]
[17:01:01.655]                   NAME <- NAMES[[kk]]
[17:01:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.655]                     next
[17:01:01.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.655]                 }
[17:01:01.655]                 NAMES <- toupper(added)
[17:01:01.655]                 for (kk in seq_along(NAMES)) {
[17:01:01.655]                   name <- added[[kk]]
[17:01:01.655]                   NAME <- NAMES[[kk]]
[17:01:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.655]                     next
[17:01:01.655]                   args[[name]] <- ""
[17:01:01.655]                 }
[17:01:01.655]                 NAMES <- toupper(removed)
[17:01:01.655]                 for (kk in seq_along(NAMES)) {
[17:01:01.655]                   name <- removed[[kk]]
[17:01:01.655]                   NAME <- NAMES[[kk]]
[17:01:01.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.655]                     next
[17:01:01.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.655]                 }
[17:01:01.655]                 if (length(args) > 0) 
[17:01:01.655]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.655]             }
[17:01:01.655]             else {
[17:01:01.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.655]             }
[17:01:01.655]             {
[17:01:01.655]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.655]                   0L) {
[17:01:01.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.655]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.655]                   base::options(opts)
[17:01:01.655]                 }
[17:01:01.655]                 {
[17:01:01.655]                   {
[17:01:01.655]                     NULL
[17:01:01.655]                     RNGkind("Mersenne-Twister")
[17:01:01.655]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.655]                       inherits = FALSE)
[17:01:01.655]                   }
[17:01:01.655]                   options(future.plan = NULL)
[17:01:01.655]                   if (is.na(NA_character_)) 
[17:01:01.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.655]                     .init = FALSE)
[17:01:01.655]                 }
[17:01:01.655]             }
[17:01:01.655]         }
[17:01:01.655]     })
[17:01:01.655]     if (TRUE) {
[17:01:01.655]         base::sink(type = "output", split = FALSE)
[17:01:01.655]         if (TRUE) {
[17:01:01.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.655]         }
[17:01:01.655]         else {
[17:01:01.655]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.655]         }
[17:01:01.655]         base::close(...future.stdout)
[17:01:01.655]         ...future.stdout <- NULL
[17:01:01.655]     }
[17:01:01.655]     ...future.result$conditions <- ...future.conditions
[17:01:01.655]     ...future.result$finished <- base::Sys.time()
[17:01:01.655]     ...future.result
[17:01:01.655] }
[17:01:01.657] assign_globals() ...
[17:01:01.657] List of 5
[17:01:01.657]  $ ...future.FUN            :function (x, y)  
[17:01:01.657]  $ future.call.arguments    :List of 1
[17:01:01.657]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.657]  $ ...future.elements_ii    :List of 4
[17:01:01.657]   ..$ A: num 50
[17:01:01.657]   ..$ B: num 60
[17:01:01.657]   ..$ C: num 70
[17:01:01.657]   ..$ D: num 80
[17:01:01.657]  $ ...future.seeds_ii       : NULL
[17:01:01.657]  $ ...future.globals.maxSize: NULL
[17:01:01.657]  - attr(*, "where")=List of 5
[17:01:01.657]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.657]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.657]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.657]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.657]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.657]  - attr(*, "resolved")= logi FALSE
[17:01:01.657]  - attr(*, "total_size")= num 4264
[17:01:01.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.657]  - attr(*, "already-done")= logi TRUE
[17:01:01.663] - reassign environment for ‘...future.FUN’
[17:01:01.663] - copied ‘...future.FUN’ to environment
[17:01:01.663] - copied ‘future.call.arguments’ to environment
[17:01:01.663] - copied ‘...future.elements_ii’ to environment
[17:01:01.663] - copied ‘...future.seeds_ii’ to environment
[17:01:01.663] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.663] assign_globals() ... done
[17:01:01.664] plan(): Setting new future strategy stack:
[17:01:01.664] List of future strategies:
[17:01:01.664] 1. sequential:
[17:01:01.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.664]    - tweaked: FALSE
[17:01:01.664]    - call: NULL
[17:01:01.664] plan(): nbrOfWorkers() = 1
[17:01:01.665] plan(): Setting new future strategy stack:
[17:01:01.665] List of future strategies:
[17:01:01.665] 1. sequential:
[17:01:01.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.665]    - tweaked: FALSE
[17:01:01.665]    - call: plan(strategy)
[17:01:01.666] plan(): nbrOfWorkers() = 1
[17:01:01.666] SequentialFuture started (and completed)
[17:01:01.666] - Launch lazy future ... done
[17:01:01.666] run() for ‘SequentialFuture’ ... done
[17:01:01.666] Created future:
[17:01:01.666] SequentialFuture:
[17:01:01.666] Label: ‘future_sapply-1’
[17:01:01.666] Expression:
[17:01:01.666] {
[17:01:01.666]     do.call(function(...) {
[17:01:01.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.666]             on.exit(options(oopts), add = TRUE)
[17:01:01.666]         }
[17:01:01.666]         {
[17:01:01.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.666]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.666]             })
[17:01:01.666]         }
[17:01:01.666]     }, args = future.call.arguments)
[17:01:01.666] }
[17:01:01.666] Lazy evaluation: FALSE
[17:01:01.666] Asynchronous evaluation: FALSE
[17:01:01.666] Local evaluation: TRUE
[17:01:01.666] Environment: R_GlobalEnv
[17:01:01.666] Capture standard output: TRUE
[17:01:01.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.666] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:01.666] Packages: <none>
[17:01:01.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.666] Resolved: TRUE
[17:01:01.666] Value: 1.34 KiB of class ‘list’
[17:01:01.666] Early signaling: FALSE
[17:01:01.666] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.666] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.667] Chunk #1 of 1 ... DONE
[17:01:01.667] Launching 1 futures (chunks) ... DONE
[17:01:01.668] Resolving 1 futures (chunks) ...
[17:01:01.668] resolve() on list ...
[17:01:01.668]  recursive: 0
[17:01:01.668]  length: 1
[17:01:01.668] 
[17:01:01.668] resolved() for ‘SequentialFuture’ ...
[17:01:01.668] - state: ‘finished’
[17:01:01.668] - run: TRUE
[17:01:01.668] - result: ‘FutureResult’
[17:01:01.668] resolved() for ‘SequentialFuture’ ... done
[17:01:01.669] Future #1
[17:01:01.669] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.669] - nx: 1
[17:01:01.669] - relay: TRUE
[17:01:01.669] - stdout: TRUE
[17:01:01.669] - signal: TRUE
[17:01:01.669] - resignal: FALSE
[17:01:01.669] - force: TRUE
[17:01:01.669] - relayed: [n=1] FALSE
[17:01:01.669] - queued futures: [n=1] FALSE
[17:01:01.669]  - until=1
[17:01:01.670]  - relaying element #1
[17:01:01.670] - relayed: [n=1] TRUE
[17:01:01.670] - queued futures: [n=1] TRUE
[17:01:01.670] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.670]  length: 0 (resolved future 1)
[17:01:01.670] Relaying remaining futures
[17:01:01.670] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.670] - nx: 1
[17:01:01.670] - relay: TRUE
[17:01:01.670] - stdout: TRUE
[17:01:01.670] - signal: TRUE
[17:01:01.671] - resignal: FALSE
[17:01:01.671] - force: TRUE
[17:01:01.671] - relayed: [n=1] TRUE
[17:01:01.671] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.671] - relayed: [n=1] TRUE
[17:01:01.671] - queued futures: [n=1] TRUE
[17:01:01.671] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.671] resolve() on list ... DONE
[17:01:01.671]  - Number of value chunks collected: 1
[17:01:01.671] Resolving 1 futures (chunks) ... DONE
[17:01:01.672] Reducing values from 1 chunks ...
[17:01:01.672]  - Number of values collected after concatenation: 4
[17:01:01.672]  - Number of values expected: 4
[17:01:01.672] Reducing values from 1 chunks ... DONE
[17:01:01.672] future_lapply() ... DONE
[17:01:01.674] future_lapply() ...
[17:01:01.676] Number of chunks: 1
[17:01:01.676] getGlobalsAndPackagesXApply() ...
[17:01:01.676]  - future.globals: TRUE
[17:01:01.676] getGlobalsAndPackages() ...
[17:01:01.676] Searching for globals...
[17:01:01.680] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:01:01.680] Searching for globals ... DONE
[17:01:01.680] Resolving globals: FALSE
[17:01:01.681] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:01:01.681] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.682] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.682] - packages: [1] ‘future.apply’
[17:01:01.682] getGlobalsAndPackages() ... DONE
[17:01:01.682]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.682]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.682] Finding globals ... DONE
[17:01:01.682]  - use_args: TRUE
[17:01:01.682]  - Getting '...' globals ...
[17:01:01.683] resolve() on list ...
[17:01:01.683]  recursive: 0
[17:01:01.683]  length: 1
[17:01:01.683]  elements: ‘...’
[17:01:01.683]  length: 0 (resolved future 1)
[17:01:01.683] resolve() on list ... DONE
[17:01:01.683]    - '...' content: [n=1] ‘y’
[17:01:01.683] List of 1
[17:01:01.683]  $ ...:List of 1
[17:01:01.683]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.683]  - attr(*, "where")=List of 1
[17:01:01.683]   ..$ ...:<environment: 0x55aadb42a3d0> 
[17:01:01.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.683]  - attr(*, "resolved")= logi TRUE
[17:01:01.683]  - attr(*, "total_size")= num NA
[17:01:01.686]  - Getting '...' globals ... DONE
[17:01:01.686] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.687] List of 8
[17:01:01.687]  $ ...future.FUN:function (x, ...)  
[17:01:01.687]  $ x_FUN        :function (x, y)  
[17:01:01.687]  $ times        : int 15
[17:01:01.687]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.687]  $ stop_if_not  :function (...)  
[17:01:01.687]  $ dim          : int [1:2] 3 5
[17:01:01.687]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.687]  $ ...          :List of 1
[17:01:01.687]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.687]  - attr(*, "where")=List of 8
[17:01:01.687]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.687]   ..$ ...          :<environment: 0x55aadb42a3d0> 
[17:01:01.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.687]  - attr(*, "resolved")= logi FALSE
[17:01:01.687]  - attr(*, "total_size")= num 98600
[17:01:01.692] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.692] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.693] Number of futures (= number of chunks): 1
[17:01:01.693] Launching 1 futures (chunks) ...
[17:01:01.693] Chunk #1 of 1 ...
[17:01:01.693]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.693] getGlobalsAndPackages() ...
[17:01:01.693] Searching for globals...
[17:01:01.693] 
[17:01:01.694] Searching for globals ... DONE
[17:01:01.694] - globals: [0] <none>
[17:01:01.694] getGlobalsAndPackages() ... DONE
[17:01:01.694]    + additional globals found: [n=0] 
[17:01:01.694]    + additional namespaces needed: [n=0] 
[17:01:01.694]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.694]  - seeds: <none>
[17:01:01.694]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.694] getGlobalsAndPackages() ...
[17:01:01.694] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.695] Resolving globals: FALSE
[17:01:01.695] Tweak future expression to call with '...' arguments ...
[17:01:01.695] {
[17:01:01.695]     do.call(function(...) {
[17:01:01.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.695]             on.exit(options(oopts), add = TRUE)
[17:01:01.695]         }
[17:01:01.695]         {
[17:01:01.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.695]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.695]             })
[17:01:01.695]         }
[17:01:01.695]     }, args = future.call.arguments)
[17:01:01.695] }
[17:01:01.697] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.697] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.697] - packages: [1] ‘future.apply’
[17:01:01.697] getGlobalsAndPackages() ... DONE
[17:01:01.698] run() for ‘Future’ ...
[17:01:01.698] - state: ‘created’
[17:01:01.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.699]   - Field: ‘label’
[17:01:01.699]   - Field: ‘local’
[17:01:01.699]   - Field: ‘owner’
[17:01:01.699]   - Field: ‘envir’
[17:01:01.699]   - Field: ‘packages’
[17:01:01.699]   - Field: ‘gc’
[17:01:01.699]   - Field: ‘conditions’
[17:01:01.699]   - Field: ‘expr’
[17:01:01.699]   - Field: ‘uuid’
[17:01:01.699]   - Field: ‘seed’
[17:01:01.700]   - Field: ‘version’
[17:01:01.700]   - Field: ‘result’
[17:01:01.700]   - Field: ‘asynchronous’
[17:01:01.700]   - Field: ‘calls’
[17:01:01.700]   - Field: ‘globals’
[17:01:01.700]   - Field: ‘stdout’
[17:01:01.700]   - Field: ‘earlySignal’
[17:01:01.700]   - Field: ‘lazy’
[17:01:01.700]   - Field: ‘state’
[17:01:01.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.700] - Launch lazy future ...
[17:01:01.701] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.701] Packages needed by future strategies (n = 0): <none>
[17:01:01.701] {
[17:01:01.701]     {
[17:01:01.701]         {
[17:01:01.701]             ...future.startTime <- base::Sys.time()
[17:01:01.701]             {
[17:01:01.701]                 {
[17:01:01.701]                   {
[17:01:01.701]                     {
[17:01:01.701]                       base::local({
[17:01:01.701]                         has_future <- base::requireNamespace("future", 
[17:01:01.701]                           quietly = TRUE)
[17:01:01.701]                         if (has_future) {
[17:01:01.701]                           ns <- base::getNamespace("future")
[17:01:01.701]                           version <- ns[[".package"]][["version"]]
[17:01:01.701]                           if (is.null(version)) 
[17:01:01.701]                             version <- utils::packageVersion("future")
[17:01:01.701]                         }
[17:01:01.701]                         else {
[17:01:01.701]                           version <- NULL
[17:01:01.701]                         }
[17:01:01.701]                         if (!has_future || version < "1.8.0") {
[17:01:01.701]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.701]                             "", base::R.version$version.string), 
[17:01:01.701]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.701]                               "release", "version")], collapse = " "), 
[17:01:01.701]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.701]                             info)
[17:01:01.701]                           info <- base::paste(info, collapse = "; ")
[17:01:01.701]                           if (!has_future) {
[17:01:01.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.701]                               info)
[17:01:01.701]                           }
[17:01:01.701]                           else {
[17:01:01.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.701]                               info, version)
[17:01:01.701]                           }
[17:01:01.701]                           base::stop(msg)
[17:01:01.701]                         }
[17:01:01.701]                       })
[17:01:01.701]                     }
[17:01:01.701]                     base::local({
[17:01:01.701]                       for (pkg in "future.apply") {
[17:01:01.701]                         base::loadNamespace(pkg)
[17:01:01.701]                         base::library(pkg, character.only = TRUE)
[17:01:01.701]                       }
[17:01:01.701]                     })
[17:01:01.701]                   }
[17:01:01.701]                   ...future.strategy.old <- future::plan("list")
[17:01:01.701]                   options(future.plan = NULL)
[17:01:01.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.701]                 }
[17:01:01.701]                 ...future.workdir <- getwd()
[17:01:01.701]             }
[17:01:01.701]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.701]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.701]         }
[17:01:01.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.701]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.701]             base::names(...future.oldOptions))
[17:01:01.701]     }
[17:01:01.701]     if (FALSE) {
[17:01:01.701]     }
[17:01:01.701]     else {
[17:01:01.701]         if (TRUE) {
[17:01:01.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.701]                 open = "w")
[17:01:01.701]         }
[17:01:01.701]         else {
[17:01:01.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.701]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.701]         }
[17:01:01.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.701]             base::sink(type = "output", split = FALSE)
[17:01:01.701]             base::close(...future.stdout)
[17:01:01.701]         }, add = TRUE)
[17:01:01.701]     }
[17:01:01.701]     ...future.frame <- base::sys.nframe()
[17:01:01.701]     ...future.conditions <- base::list()
[17:01:01.701]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.701]     if (FALSE) {
[17:01:01.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.701]     }
[17:01:01.701]     ...future.result <- base::tryCatch({
[17:01:01.701]         base::withCallingHandlers({
[17:01:01.701]             ...future.value <- base::withVisible(base::local({
[17:01:01.701]                 do.call(function(...) {
[17:01:01.701]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.701]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.701]                     ...future.globals.maxSize)) {
[17:01:01.701]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.701]                     on.exit(options(oopts), add = TRUE)
[17:01:01.701]                   }
[17:01:01.701]                   {
[17:01:01.701]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.701]                       FUN = function(jj) {
[17:01:01.701]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.701]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.701]                       })
[17:01:01.701]                   }
[17:01:01.701]                 }, args = future.call.arguments)
[17:01:01.701]             }))
[17:01:01.701]             future::FutureResult(value = ...future.value$value, 
[17:01:01.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.701]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.701]                     ...future.globalenv.names))
[17:01:01.701]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.701]         }, condition = base::local({
[17:01:01.701]             c <- base::c
[17:01:01.701]             inherits <- base::inherits
[17:01:01.701]             invokeRestart <- base::invokeRestart
[17:01:01.701]             length <- base::length
[17:01:01.701]             list <- base::list
[17:01:01.701]             seq.int <- base::seq.int
[17:01:01.701]             signalCondition <- base::signalCondition
[17:01:01.701]             sys.calls <- base::sys.calls
[17:01:01.701]             `[[` <- base::`[[`
[17:01:01.701]             `+` <- base::`+`
[17:01:01.701]             `<<-` <- base::`<<-`
[17:01:01.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.701]                   3L)]
[17:01:01.701]             }
[17:01:01.701]             function(cond) {
[17:01:01.701]                 is_error <- inherits(cond, "error")
[17:01:01.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.701]                   NULL)
[17:01:01.701]                 if (is_error) {
[17:01:01.701]                   sessionInformation <- function() {
[17:01:01.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.701]                       search = base::search(), system = base::Sys.info())
[17:01:01.701]                   }
[17:01:01.701]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.701]                     cond$call), session = sessionInformation(), 
[17:01:01.701]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.701]                   signalCondition(cond)
[17:01:01.701]                 }
[17:01:01.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.701]                 "immediateCondition"))) {
[17:01:01.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.701]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.701]                   if (TRUE && !signal) {
[17:01:01.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.701]                     {
[17:01:01.701]                       inherits <- base::inherits
[17:01:01.701]                       invokeRestart <- base::invokeRestart
[17:01:01.701]                       is.null <- base::is.null
[17:01:01.701]                       muffled <- FALSE
[17:01:01.701]                       if (inherits(cond, "message")) {
[17:01:01.701]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.701]                         if (muffled) 
[17:01:01.701]                           invokeRestart("muffleMessage")
[17:01:01.701]                       }
[17:01:01.701]                       else if (inherits(cond, "warning")) {
[17:01:01.701]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.701]                         if (muffled) 
[17:01:01.701]                           invokeRestart("muffleWarning")
[17:01:01.701]                       }
[17:01:01.701]                       else if (inherits(cond, "condition")) {
[17:01:01.701]                         if (!is.null(pattern)) {
[17:01:01.701]                           computeRestarts <- base::computeRestarts
[17:01:01.701]                           grepl <- base::grepl
[17:01:01.701]                           restarts <- computeRestarts(cond)
[17:01:01.701]                           for (restart in restarts) {
[17:01:01.701]                             name <- restart$name
[17:01:01.701]                             if (is.null(name)) 
[17:01:01.701]                               next
[17:01:01.701]                             if (!grepl(pattern, name)) 
[17:01:01.701]                               next
[17:01:01.701]                             invokeRestart(restart)
[17:01:01.701]                             muffled <- TRUE
[17:01:01.701]                             break
[17:01:01.701]                           }
[17:01:01.701]                         }
[17:01:01.701]                       }
[17:01:01.701]                       invisible(muffled)
[17:01:01.701]                     }
[17:01:01.701]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.701]                   }
[17:01:01.701]                 }
[17:01:01.701]                 else {
[17:01:01.701]                   if (TRUE) {
[17:01:01.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.701]                     {
[17:01:01.701]                       inherits <- base::inherits
[17:01:01.701]                       invokeRestart <- base::invokeRestart
[17:01:01.701]                       is.null <- base::is.null
[17:01:01.701]                       muffled <- FALSE
[17:01:01.701]                       if (inherits(cond, "message")) {
[17:01:01.701]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.701]                         if (muffled) 
[17:01:01.701]                           invokeRestart("muffleMessage")
[17:01:01.701]                       }
[17:01:01.701]                       else if (inherits(cond, "warning")) {
[17:01:01.701]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.701]                         if (muffled) 
[17:01:01.701]                           invokeRestart("muffleWarning")
[17:01:01.701]                       }
[17:01:01.701]                       else if (inherits(cond, "condition")) {
[17:01:01.701]                         if (!is.null(pattern)) {
[17:01:01.701]                           computeRestarts <- base::computeRestarts
[17:01:01.701]                           grepl <- base::grepl
[17:01:01.701]                           restarts <- computeRestarts(cond)
[17:01:01.701]                           for (restart in restarts) {
[17:01:01.701]                             name <- restart$name
[17:01:01.701]                             if (is.null(name)) 
[17:01:01.701]                               next
[17:01:01.701]                             if (!grepl(pattern, name)) 
[17:01:01.701]                               next
[17:01:01.701]                             invokeRestart(restart)
[17:01:01.701]                             muffled <- TRUE
[17:01:01.701]                             break
[17:01:01.701]                           }
[17:01:01.701]                         }
[17:01:01.701]                       }
[17:01:01.701]                       invisible(muffled)
[17:01:01.701]                     }
[17:01:01.701]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.701]                   }
[17:01:01.701]                 }
[17:01:01.701]             }
[17:01:01.701]         }))
[17:01:01.701]     }, error = function(ex) {
[17:01:01.701]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.701]                 ...future.rng), started = ...future.startTime, 
[17:01:01.701]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.701]             version = "1.8"), class = "FutureResult")
[17:01:01.701]     }, finally = {
[17:01:01.701]         if (!identical(...future.workdir, getwd())) 
[17:01:01.701]             setwd(...future.workdir)
[17:01:01.701]         {
[17:01:01.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.701]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.701]             }
[17:01:01.701]             base::options(...future.oldOptions)
[17:01:01.701]             if (.Platform$OS.type == "windows") {
[17:01:01.701]                 old_names <- names(...future.oldEnvVars)
[17:01:01.701]                 envs <- base::Sys.getenv()
[17:01:01.701]                 names <- names(envs)
[17:01:01.701]                 common <- intersect(names, old_names)
[17:01:01.701]                 added <- setdiff(names, old_names)
[17:01:01.701]                 removed <- setdiff(old_names, names)
[17:01:01.701]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.701]                   envs[common]]
[17:01:01.701]                 NAMES <- toupper(changed)
[17:01:01.701]                 args <- list()
[17:01:01.701]                 for (kk in seq_along(NAMES)) {
[17:01:01.701]                   name <- changed[[kk]]
[17:01:01.701]                   NAME <- NAMES[[kk]]
[17:01:01.701]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.701]                     next
[17:01:01.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.701]                 }
[17:01:01.701]                 NAMES <- toupper(added)
[17:01:01.701]                 for (kk in seq_along(NAMES)) {
[17:01:01.701]                   name <- added[[kk]]
[17:01:01.701]                   NAME <- NAMES[[kk]]
[17:01:01.701]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.701]                     next
[17:01:01.701]                   args[[name]] <- ""
[17:01:01.701]                 }
[17:01:01.701]                 NAMES <- toupper(removed)
[17:01:01.701]                 for (kk in seq_along(NAMES)) {
[17:01:01.701]                   name <- removed[[kk]]
[17:01:01.701]                   NAME <- NAMES[[kk]]
[17:01:01.701]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.701]                     next
[17:01:01.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.701]                 }
[17:01:01.701]                 if (length(args) > 0) 
[17:01:01.701]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.701]             }
[17:01:01.701]             else {
[17:01:01.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.701]             }
[17:01:01.701]             {
[17:01:01.701]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.701]                   0L) {
[17:01:01.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.701]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.701]                   base::options(opts)
[17:01:01.701]                 }
[17:01:01.701]                 {
[17:01:01.701]                   {
[17:01:01.701]                     NULL
[17:01:01.701]                     RNGkind("Mersenne-Twister")
[17:01:01.701]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.701]                       inherits = FALSE)
[17:01:01.701]                   }
[17:01:01.701]                   options(future.plan = NULL)
[17:01:01.701]                   if (is.na(NA_character_)) 
[17:01:01.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.701]                     .init = FALSE)
[17:01:01.701]                 }
[17:01:01.701]             }
[17:01:01.701]         }
[17:01:01.701]     })
[17:01:01.701]     if (TRUE) {
[17:01:01.701]         base::sink(type = "output", split = FALSE)
[17:01:01.701]         if (TRUE) {
[17:01:01.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.701]         }
[17:01:01.701]         else {
[17:01:01.701]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.701]         }
[17:01:01.701]         base::close(...future.stdout)
[17:01:01.701]         ...future.stdout <- NULL
[17:01:01.701]     }
[17:01:01.701]     ...future.result$conditions <- ...future.conditions
[17:01:01.701]     ...future.result$finished <- base::Sys.time()
[17:01:01.701]     ...future.result
[17:01:01.701] }
[17:01:01.703] assign_globals() ...
[17:01:01.703] List of 11
[17:01:01.703]  $ ...future.FUN            :function (x, ...)  
[17:01:01.703]  $ x_FUN                    :function (x, y)  
[17:01:01.703]  $ times                    : int 15
[17:01:01.703]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.703]  $ stop_if_not              :function (...)  
[17:01:01.703]  $ dim                      : int [1:2] 3 5
[17:01:01.703]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.703]  $ future.call.arguments    :List of 1
[17:01:01.703]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:01.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.703]  $ ...future.elements_ii    :List of 4
[17:01:01.703]   ..$ A: num 50
[17:01:01.703]   ..$ B: num 60
[17:01:01.703]   ..$ C: num 70
[17:01:01.703]   ..$ D: num 80
[17:01:01.703]  $ ...future.seeds_ii       : NULL
[17:01:01.703]  $ ...future.globals.maxSize: NULL
[17:01:01.703]  - attr(*, "where")=List of 11
[17:01:01.703]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.703]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.703]  - attr(*, "resolved")= logi FALSE
[17:01:01.703]  - attr(*, "total_size")= num 98600
[17:01:01.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.703]  - attr(*, "already-done")= logi TRUE
[17:01:01.712] - copied ‘...future.FUN’ to environment
[17:01:01.712] - reassign environment for ‘x_FUN’
[17:01:01.712] - copied ‘x_FUN’ to environment
[17:01:01.712] - copied ‘times’ to environment
[17:01:01.712] - copied ‘stopf’ to environment
[17:01:01.712] - copied ‘stop_if_not’ to environment
[17:01:01.712] - copied ‘dim’ to environment
[17:01:01.712] - copied ‘valid_types’ to environment
[17:01:01.712] - copied ‘future.call.arguments’ to environment
[17:01:01.712] - copied ‘...future.elements_ii’ to environment
[17:01:01.713] - copied ‘...future.seeds_ii’ to environment
[17:01:01.713] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.713] assign_globals() ... done
[17:01:01.713] plan(): Setting new future strategy stack:
[17:01:01.713] List of future strategies:
[17:01:01.713] 1. sequential:
[17:01:01.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.713]    - tweaked: FALSE
[17:01:01.713]    - call: NULL
[17:01:01.714] plan(): nbrOfWorkers() = 1
[17:01:01.715] plan(): Setting new future strategy stack:
[17:01:01.715] List of future strategies:
[17:01:01.715] 1. sequential:
[17:01:01.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.715]    - tweaked: FALSE
[17:01:01.715]    - call: plan(strategy)
[17:01:01.715] plan(): nbrOfWorkers() = 1
[17:01:01.715] SequentialFuture started (and completed)
[17:01:01.715] - Launch lazy future ... done
[17:01:01.715] run() for ‘SequentialFuture’ ... done
[17:01:01.716] Created future:
[17:01:01.716] SequentialFuture:
[17:01:01.716] Label: ‘future_vapply-1’
[17:01:01.716] Expression:
[17:01:01.716] {
[17:01:01.716]     do.call(function(...) {
[17:01:01.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.716]             on.exit(options(oopts), add = TRUE)
[17:01:01.716]         }
[17:01:01.716]         {
[17:01:01.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.716]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.716]             })
[17:01:01.716]         }
[17:01:01.716]     }, args = future.call.arguments)
[17:01:01.716] }
[17:01:01.716] Lazy evaluation: FALSE
[17:01:01.716] Asynchronous evaluation: FALSE
[17:01:01.716] Local evaluation: TRUE
[17:01:01.716] Environment: R_GlobalEnv
[17:01:01.716] Capture standard output: TRUE
[17:01:01.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.716] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.716] Packages: 1 packages (‘future.apply’)
[17:01:01.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.716] Resolved: TRUE
[17:01:01.716] Value: 1.34 KiB of class ‘list’
[17:01:01.716] Early signaling: FALSE
[17:01:01.716] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.716] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.717] Chunk #1 of 1 ... DONE
[17:01:01.717] Launching 1 futures (chunks) ... DONE
[17:01:01.717] Resolving 1 futures (chunks) ...
[17:01:01.717] resolve() on list ...
[17:01:01.717]  recursive: 0
[17:01:01.717]  length: 1
[17:01:01.717] 
[17:01:01.718] resolved() for ‘SequentialFuture’ ...
[17:01:01.718] - state: ‘finished’
[17:01:01.718] - run: TRUE
[17:01:01.718] - result: ‘FutureResult’
[17:01:01.718] resolved() for ‘SequentialFuture’ ... done
[17:01:01.718] Future #1
[17:01:01.718] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.718] - nx: 1
[17:01:01.718] - relay: TRUE
[17:01:01.718] - stdout: TRUE
[17:01:01.718] - signal: TRUE
[17:01:01.719] - resignal: FALSE
[17:01:01.719] - force: TRUE
[17:01:01.719] - relayed: [n=1] FALSE
[17:01:01.719] - queued futures: [n=1] FALSE
[17:01:01.719]  - until=1
[17:01:01.719]  - relaying element #1
[17:01:01.719] - relayed: [n=1] TRUE
[17:01:01.719] - queued futures: [n=1] TRUE
[17:01:01.719] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.719]  length: 0 (resolved future 1)
[17:01:01.720] Relaying remaining futures
[17:01:01.720] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.720] - nx: 1
[17:01:01.720] - relay: TRUE
[17:01:01.721] - stdout: TRUE
[17:01:01.722] - signal: TRUE
[17:01:01.722] - resignal: FALSE
[17:01:01.722] - force: TRUE
[17:01:01.722] - relayed: [n=1] TRUE
[17:01:01.722] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.722] - relayed: [n=1] TRUE
[17:01:01.722] - queued futures: [n=1] TRUE
[17:01:01.722] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.722] resolve() on list ... DONE
[17:01:01.723]  - Number of value chunks collected: 1
[17:01:01.723] Resolving 1 futures (chunks) ... DONE
[17:01:01.723] Reducing values from 1 chunks ...
[17:01:01.723]  - Number of values collected after concatenation: 4
[17:01:01.723]  - Number of values expected: 4
[17:01:01.723] Reducing values from 1 chunks ... DONE
[17:01:01.723] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:01:01.725] future_lapply() ...
[17:01:01.727] Number of chunks: 1
[17:01:01.727] getGlobalsAndPackagesXApply() ...
[17:01:01.727]  - future.globals: TRUE
[17:01:01.727] getGlobalsAndPackages() ...
[17:01:01.727] Searching for globals...
[17:01:01.730] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.730] Searching for globals ... DONE
[17:01:01.730] Resolving globals: FALSE
[17:01:01.731] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:01:01.732] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.732] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.732] - packages: [1] ‘future.apply’
[17:01:01.732] getGlobalsAndPackages() ... DONE
[17:01:01.732]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.732]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.732] Finding globals ... DONE
[17:01:01.732]  - use_args: TRUE
[17:01:01.732]  - Getting '...' globals ...
[17:01:01.733] resolve() on list ...
[17:01:01.733]  recursive: 0
[17:01:01.733]  length: 1
[17:01:01.733]  elements: ‘...’
[17:01:01.733]  length: 0 (resolved future 1)
[17:01:01.733] resolve() on list ... DONE
[17:01:01.733]    - '...' content: [n=0] 
[17:01:01.733] List of 1
[17:01:01.733]  $ ...: list()
[17:01:01.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.733]  - attr(*, "where")=List of 1
[17:01:01.733]   ..$ ...:<environment: 0x55aad9b45018> 
[17:01:01.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.733]  - attr(*, "resolved")= logi TRUE
[17:01:01.733]  - attr(*, "total_size")= num NA
[17:01:01.736]  - Getting '...' globals ... DONE
[17:01:01.736] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.736] List of 8
[17:01:01.736]  $ ...future.FUN:function (x, ...)  
[17:01:01.736]  $ x_FUN        :function (x)  
[17:01:01.736]  $ times        : int 1
[17:01:01.736]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.736]  $ stop_if_not  :function (...)  
[17:01:01.736]  $ dim          : NULL
[17:01:01.736]  $ valid_types  : chr "logical"
[17:01:01.736]  $ ...          : list()
[17:01:01.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.736]  - attr(*, "where")=List of 8
[17:01:01.736]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.736]   ..$ ...          :<environment: 0x55aad9b45018> 
[17:01:01.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.736]  - attr(*, "resolved")= logi FALSE
[17:01:01.736]  - attr(*, "total_size")= num 94200
[17:01:01.741] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.741] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.742] Number of futures (= number of chunks): 1
[17:01:01.742] Launching 1 futures (chunks) ...
[17:01:01.742] Chunk #1 of 1 ...
[17:01:01.742]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.742] getGlobalsAndPackages() ...
[17:01:01.742] Searching for globals...
[17:01:01.742] 
[17:01:01.744] Searching for globals ... DONE
[17:01:01.744] - globals: [0] <none>
[17:01:01.744] getGlobalsAndPackages() ... DONE
[17:01:01.744]    + additional globals found: [n=0] 
[17:01:01.744]    + additional namespaces needed: [n=0] 
[17:01:01.745]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.745]  - seeds: <none>
[17:01:01.745]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.745] getGlobalsAndPackages() ...
[17:01:01.745] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.745] Resolving globals: FALSE
[17:01:01.745] Tweak future expression to call with '...' arguments ...
[17:01:01.745] {
[17:01:01.745]     do.call(function(...) {
[17:01:01.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.745]             on.exit(options(oopts), add = TRUE)
[17:01:01.745]         }
[17:01:01.745]         {
[17:01:01.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.745]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.745]             })
[17:01:01.745]         }
[17:01:01.745]     }, args = future.call.arguments)
[17:01:01.745] }
[17:01:01.746] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.746] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.746] - packages: [1] ‘future.apply’
[17:01:01.747] getGlobalsAndPackages() ... DONE
[17:01:01.747] run() for ‘Future’ ...
[17:01:01.747] - state: ‘created’
[17:01:01.747] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.747] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.748]   - Field: ‘label’
[17:01:01.748]   - Field: ‘local’
[17:01:01.748]   - Field: ‘owner’
[17:01:01.748]   - Field: ‘envir’
[17:01:01.748]   - Field: ‘packages’
[17:01:01.748]   - Field: ‘gc’
[17:01:01.748]   - Field: ‘conditions’
[17:01:01.748]   - Field: ‘expr’
[17:01:01.748]   - Field: ‘uuid’
[17:01:01.748]   - Field: ‘seed’
[17:01:01.748]   - Field: ‘version’
[17:01:01.749]   - Field: ‘result’
[17:01:01.749]   - Field: ‘asynchronous’
[17:01:01.749]   - Field: ‘calls’
[17:01:01.749]   - Field: ‘globals’
[17:01:01.749]   - Field: ‘stdout’
[17:01:01.749]   - Field: ‘earlySignal’
[17:01:01.749]   - Field: ‘lazy’
[17:01:01.749]   - Field: ‘state’
[17:01:01.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.749] - Launch lazy future ...
[17:01:01.750] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.750] Packages needed by future strategies (n = 0): <none>
[17:01:01.750] {
[17:01:01.750]     {
[17:01:01.750]         {
[17:01:01.750]             ...future.startTime <- base::Sys.time()
[17:01:01.750]             {
[17:01:01.750]                 {
[17:01:01.750]                   {
[17:01:01.750]                     {
[17:01:01.750]                       base::local({
[17:01:01.750]                         has_future <- base::requireNamespace("future", 
[17:01:01.750]                           quietly = TRUE)
[17:01:01.750]                         if (has_future) {
[17:01:01.750]                           ns <- base::getNamespace("future")
[17:01:01.750]                           version <- ns[[".package"]][["version"]]
[17:01:01.750]                           if (is.null(version)) 
[17:01:01.750]                             version <- utils::packageVersion("future")
[17:01:01.750]                         }
[17:01:01.750]                         else {
[17:01:01.750]                           version <- NULL
[17:01:01.750]                         }
[17:01:01.750]                         if (!has_future || version < "1.8.0") {
[17:01:01.750]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.750]                             "", base::R.version$version.string), 
[17:01:01.750]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.750]                               "release", "version")], collapse = " "), 
[17:01:01.750]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.750]                             info)
[17:01:01.750]                           info <- base::paste(info, collapse = "; ")
[17:01:01.750]                           if (!has_future) {
[17:01:01.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.750]                               info)
[17:01:01.750]                           }
[17:01:01.750]                           else {
[17:01:01.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.750]                               info, version)
[17:01:01.750]                           }
[17:01:01.750]                           base::stop(msg)
[17:01:01.750]                         }
[17:01:01.750]                       })
[17:01:01.750]                     }
[17:01:01.750]                     base::local({
[17:01:01.750]                       for (pkg in "future.apply") {
[17:01:01.750]                         base::loadNamespace(pkg)
[17:01:01.750]                         base::library(pkg, character.only = TRUE)
[17:01:01.750]                       }
[17:01:01.750]                     })
[17:01:01.750]                   }
[17:01:01.750]                   ...future.strategy.old <- future::plan("list")
[17:01:01.750]                   options(future.plan = NULL)
[17:01:01.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.750]                 }
[17:01:01.750]                 ...future.workdir <- getwd()
[17:01:01.750]             }
[17:01:01.750]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.750]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.750]         }
[17:01:01.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.750]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.750]             base::names(...future.oldOptions))
[17:01:01.750]     }
[17:01:01.750]     if (FALSE) {
[17:01:01.750]     }
[17:01:01.750]     else {
[17:01:01.750]         if (TRUE) {
[17:01:01.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.750]                 open = "w")
[17:01:01.750]         }
[17:01:01.750]         else {
[17:01:01.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.750]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.750]         }
[17:01:01.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.750]             base::sink(type = "output", split = FALSE)
[17:01:01.750]             base::close(...future.stdout)
[17:01:01.750]         }, add = TRUE)
[17:01:01.750]     }
[17:01:01.750]     ...future.frame <- base::sys.nframe()
[17:01:01.750]     ...future.conditions <- base::list()
[17:01:01.750]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.750]     if (FALSE) {
[17:01:01.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.750]     }
[17:01:01.750]     ...future.result <- base::tryCatch({
[17:01:01.750]         base::withCallingHandlers({
[17:01:01.750]             ...future.value <- base::withVisible(base::local({
[17:01:01.750]                 do.call(function(...) {
[17:01:01.750]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.750]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.750]                     ...future.globals.maxSize)) {
[17:01:01.750]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.750]                     on.exit(options(oopts), add = TRUE)
[17:01:01.750]                   }
[17:01:01.750]                   {
[17:01:01.750]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.750]                       FUN = function(jj) {
[17:01:01.750]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.750]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.750]                       })
[17:01:01.750]                   }
[17:01:01.750]                 }, args = future.call.arguments)
[17:01:01.750]             }))
[17:01:01.750]             future::FutureResult(value = ...future.value$value, 
[17:01:01.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.750]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.750]                     ...future.globalenv.names))
[17:01:01.750]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.750]         }, condition = base::local({
[17:01:01.750]             c <- base::c
[17:01:01.750]             inherits <- base::inherits
[17:01:01.750]             invokeRestart <- base::invokeRestart
[17:01:01.750]             length <- base::length
[17:01:01.750]             list <- base::list
[17:01:01.750]             seq.int <- base::seq.int
[17:01:01.750]             signalCondition <- base::signalCondition
[17:01:01.750]             sys.calls <- base::sys.calls
[17:01:01.750]             `[[` <- base::`[[`
[17:01:01.750]             `+` <- base::`+`
[17:01:01.750]             `<<-` <- base::`<<-`
[17:01:01.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.750]                   3L)]
[17:01:01.750]             }
[17:01:01.750]             function(cond) {
[17:01:01.750]                 is_error <- inherits(cond, "error")
[17:01:01.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.750]                   NULL)
[17:01:01.750]                 if (is_error) {
[17:01:01.750]                   sessionInformation <- function() {
[17:01:01.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.750]                       search = base::search(), system = base::Sys.info())
[17:01:01.750]                   }
[17:01:01.750]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.750]                     cond$call), session = sessionInformation(), 
[17:01:01.750]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.750]                   signalCondition(cond)
[17:01:01.750]                 }
[17:01:01.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.750]                 "immediateCondition"))) {
[17:01:01.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.750]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.750]                   if (TRUE && !signal) {
[17:01:01.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.750]                     {
[17:01:01.750]                       inherits <- base::inherits
[17:01:01.750]                       invokeRestart <- base::invokeRestart
[17:01:01.750]                       is.null <- base::is.null
[17:01:01.750]                       muffled <- FALSE
[17:01:01.750]                       if (inherits(cond, "message")) {
[17:01:01.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.750]                         if (muffled) 
[17:01:01.750]                           invokeRestart("muffleMessage")
[17:01:01.750]                       }
[17:01:01.750]                       else if (inherits(cond, "warning")) {
[17:01:01.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.750]                         if (muffled) 
[17:01:01.750]                           invokeRestart("muffleWarning")
[17:01:01.750]                       }
[17:01:01.750]                       else if (inherits(cond, "condition")) {
[17:01:01.750]                         if (!is.null(pattern)) {
[17:01:01.750]                           computeRestarts <- base::computeRestarts
[17:01:01.750]                           grepl <- base::grepl
[17:01:01.750]                           restarts <- computeRestarts(cond)
[17:01:01.750]                           for (restart in restarts) {
[17:01:01.750]                             name <- restart$name
[17:01:01.750]                             if (is.null(name)) 
[17:01:01.750]                               next
[17:01:01.750]                             if (!grepl(pattern, name)) 
[17:01:01.750]                               next
[17:01:01.750]                             invokeRestart(restart)
[17:01:01.750]                             muffled <- TRUE
[17:01:01.750]                             break
[17:01:01.750]                           }
[17:01:01.750]                         }
[17:01:01.750]                       }
[17:01:01.750]                       invisible(muffled)
[17:01:01.750]                     }
[17:01:01.750]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.750]                   }
[17:01:01.750]                 }
[17:01:01.750]                 else {
[17:01:01.750]                   if (TRUE) {
[17:01:01.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.750]                     {
[17:01:01.750]                       inherits <- base::inherits
[17:01:01.750]                       invokeRestart <- base::invokeRestart
[17:01:01.750]                       is.null <- base::is.null
[17:01:01.750]                       muffled <- FALSE
[17:01:01.750]                       if (inherits(cond, "message")) {
[17:01:01.750]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.750]                         if (muffled) 
[17:01:01.750]                           invokeRestart("muffleMessage")
[17:01:01.750]                       }
[17:01:01.750]                       else if (inherits(cond, "warning")) {
[17:01:01.750]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.750]                         if (muffled) 
[17:01:01.750]                           invokeRestart("muffleWarning")
[17:01:01.750]                       }
[17:01:01.750]                       else if (inherits(cond, "condition")) {
[17:01:01.750]                         if (!is.null(pattern)) {
[17:01:01.750]                           computeRestarts <- base::computeRestarts
[17:01:01.750]                           grepl <- base::grepl
[17:01:01.750]                           restarts <- computeRestarts(cond)
[17:01:01.750]                           for (restart in restarts) {
[17:01:01.750]                             name <- restart$name
[17:01:01.750]                             if (is.null(name)) 
[17:01:01.750]                               next
[17:01:01.750]                             if (!grepl(pattern, name)) 
[17:01:01.750]                               next
[17:01:01.750]                             invokeRestart(restart)
[17:01:01.750]                             muffled <- TRUE
[17:01:01.750]                             break
[17:01:01.750]                           }
[17:01:01.750]                         }
[17:01:01.750]                       }
[17:01:01.750]                       invisible(muffled)
[17:01:01.750]                     }
[17:01:01.750]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.750]                   }
[17:01:01.750]                 }
[17:01:01.750]             }
[17:01:01.750]         }))
[17:01:01.750]     }, error = function(ex) {
[17:01:01.750]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.750]                 ...future.rng), started = ...future.startTime, 
[17:01:01.750]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.750]             version = "1.8"), class = "FutureResult")
[17:01:01.750]     }, finally = {
[17:01:01.750]         if (!identical(...future.workdir, getwd())) 
[17:01:01.750]             setwd(...future.workdir)
[17:01:01.750]         {
[17:01:01.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.750]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.750]             }
[17:01:01.750]             base::options(...future.oldOptions)
[17:01:01.750]             if (.Platform$OS.type == "windows") {
[17:01:01.750]                 old_names <- names(...future.oldEnvVars)
[17:01:01.750]                 envs <- base::Sys.getenv()
[17:01:01.750]                 names <- names(envs)
[17:01:01.750]                 common <- intersect(names, old_names)
[17:01:01.750]                 added <- setdiff(names, old_names)
[17:01:01.750]                 removed <- setdiff(old_names, names)
[17:01:01.750]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.750]                   envs[common]]
[17:01:01.750]                 NAMES <- toupper(changed)
[17:01:01.750]                 args <- list()
[17:01:01.750]                 for (kk in seq_along(NAMES)) {
[17:01:01.750]                   name <- changed[[kk]]
[17:01:01.750]                   NAME <- NAMES[[kk]]
[17:01:01.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.750]                     next
[17:01:01.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.750]                 }
[17:01:01.750]                 NAMES <- toupper(added)
[17:01:01.750]                 for (kk in seq_along(NAMES)) {
[17:01:01.750]                   name <- added[[kk]]
[17:01:01.750]                   NAME <- NAMES[[kk]]
[17:01:01.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.750]                     next
[17:01:01.750]                   args[[name]] <- ""
[17:01:01.750]                 }
[17:01:01.750]                 NAMES <- toupper(removed)
[17:01:01.750]                 for (kk in seq_along(NAMES)) {
[17:01:01.750]                   name <- removed[[kk]]
[17:01:01.750]                   NAME <- NAMES[[kk]]
[17:01:01.750]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.750]                     next
[17:01:01.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.750]                 }
[17:01:01.750]                 if (length(args) > 0) 
[17:01:01.750]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.750]             }
[17:01:01.750]             else {
[17:01:01.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.750]             }
[17:01:01.750]             {
[17:01:01.750]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.750]                   0L) {
[17:01:01.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.750]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.750]                   base::options(opts)
[17:01:01.750]                 }
[17:01:01.750]                 {
[17:01:01.750]                   {
[17:01:01.750]                     NULL
[17:01:01.750]                     RNGkind("Mersenne-Twister")
[17:01:01.750]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.750]                       inherits = FALSE)
[17:01:01.750]                   }
[17:01:01.750]                   options(future.plan = NULL)
[17:01:01.750]                   if (is.na(NA_character_)) 
[17:01:01.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.750]                     .init = FALSE)
[17:01:01.750]                 }
[17:01:01.750]             }
[17:01:01.750]         }
[17:01:01.750]     })
[17:01:01.750]     if (TRUE) {
[17:01:01.750]         base::sink(type = "output", split = FALSE)
[17:01:01.750]         if (TRUE) {
[17:01:01.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.750]         }
[17:01:01.750]         else {
[17:01:01.750]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.750]         }
[17:01:01.750]         base::close(...future.stdout)
[17:01:01.750]         ...future.stdout <- NULL
[17:01:01.750]     }
[17:01:01.750]     ...future.result$conditions <- ...future.conditions
[17:01:01.750]     ...future.result$finished <- base::Sys.time()
[17:01:01.750]     ...future.result
[17:01:01.750] }
[17:01:01.752] assign_globals() ...
[17:01:01.752] List of 11
[17:01:01.752]  $ ...future.FUN            :function (x, ...)  
[17:01:01.752]  $ x_FUN                    :function (x)  
[17:01:01.752]  $ times                    : int 1
[17:01:01.752]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.752]  $ stop_if_not              :function (...)  
[17:01:01.752]  $ dim                      : NULL
[17:01:01.752]  $ valid_types              : chr "logical"
[17:01:01.752]  $ future.call.arguments    : list()
[17:01:01.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.752]  $ ...future.elements_ii    :List of 11
[17:01:01.752]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:01:01.752]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:01:01.752]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:01:01.752]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:01:01.752]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:01:01.752]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:01:01.752]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:01:01.752]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:01:01.752]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:01:01.752]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:01:01.752]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:01:01.752]  $ ...future.seeds_ii       : NULL
[17:01:01.752]  $ ...future.globals.maxSize: NULL
[17:01:01.752]  - attr(*, "where")=List of 11
[17:01:01.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.752]  - attr(*, "resolved")= logi FALSE
[17:01:01.752]  - attr(*, "total_size")= num 94200
[17:01:01.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.752]  - attr(*, "already-done")= logi TRUE
[17:01:01.762] - copied ‘...future.FUN’ to environment
[17:01:01.763] - copied ‘x_FUN’ to environment
[17:01:01.763] - copied ‘times’ to environment
[17:01:01.763] - copied ‘stopf’ to environment
[17:01:01.763] - copied ‘stop_if_not’ to environment
[17:01:01.763] - copied ‘dim’ to environment
[17:01:01.763] - copied ‘valid_types’ to environment
[17:01:01.763] - copied ‘future.call.arguments’ to environment
[17:01:01.763] - copied ‘...future.elements_ii’ to environment
[17:01:01.763] - copied ‘...future.seeds_ii’ to environment
[17:01:01.763] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.764] assign_globals() ... done
[17:01:01.764] plan(): Setting new future strategy stack:
[17:01:01.764] List of future strategies:
[17:01:01.764] 1. sequential:
[17:01:01.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.764]    - tweaked: FALSE
[17:01:01.764]    - call: NULL
[17:01:01.764] plan(): nbrOfWorkers() = 1
[17:01:01.765] plan(): Setting new future strategy stack:
[17:01:01.765] List of future strategies:
[17:01:01.765] 1. sequential:
[17:01:01.765]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.765]    - tweaked: FALSE
[17:01:01.765]    - call: plan(strategy)
[17:01:01.766] plan(): nbrOfWorkers() = 1
[17:01:01.766] SequentialFuture started (and completed)
[17:01:01.766] - Launch lazy future ... done
[17:01:01.766] run() for ‘SequentialFuture’ ... done
[17:01:01.766] Created future:
[17:01:01.766] SequentialFuture:
[17:01:01.766] Label: ‘future_vapply-1’
[17:01:01.766] Expression:
[17:01:01.766] {
[17:01:01.766]     do.call(function(...) {
[17:01:01.766]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.766]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.766]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.766]             on.exit(options(oopts), add = TRUE)
[17:01:01.766]         }
[17:01:01.766]         {
[17:01:01.766]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.766]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.766]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.766]             })
[17:01:01.766]         }
[17:01:01.766]     }, args = future.call.arguments)
[17:01:01.766] }
[17:01:01.766] Lazy evaluation: FALSE
[17:01:01.766] Asynchronous evaluation: FALSE
[17:01:01.766] Local evaluation: TRUE
[17:01:01.766] Environment: R_GlobalEnv
[17:01:01.766] Capture standard output: TRUE
[17:01:01.766] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.766] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.766] Packages: 1 packages (‘future.apply’)
[17:01:01.766] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.766] Resolved: TRUE
[17:01:01.766] Value: 616 bytes of class ‘list’
[17:01:01.766] Early signaling: FALSE
[17:01:01.766] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.766] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.769] Chunk #1 of 1 ... DONE
[17:01:01.770] Launching 1 futures (chunks) ... DONE
[17:01:01.770] Resolving 1 futures (chunks) ...
[17:01:01.770] resolve() on list ...
[17:01:01.770]  recursive: 0
[17:01:01.770]  length: 1
[17:01:01.770] 
[17:01:01.770] resolved() for ‘SequentialFuture’ ...
[17:01:01.770] - state: ‘finished’
[17:01:01.770] - run: TRUE
[17:01:01.771] - result: ‘FutureResult’
[17:01:01.771] resolved() for ‘SequentialFuture’ ... done
[17:01:01.771] Future #1
[17:01:01.771] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.771] - nx: 1
[17:01:01.771] - relay: TRUE
[17:01:01.771] - stdout: TRUE
[17:01:01.771] - signal: TRUE
[17:01:01.771] - resignal: FALSE
[17:01:01.772] - force: TRUE
[17:01:01.772] - relayed: [n=1] FALSE
[17:01:01.772] - queued futures: [n=1] FALSE
[17:01:01.772]  - until=1
[17:01:01.772]  - relaying element #1
[17:01:01.772] - relayed: [n=1] TRUE
[17:01:01.772] - queued futures: [n=1] TRUE
[17:01:01.772] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.772]  length: 0 (resolved future 1)
[17:01:01.773] Relaying remaining futures
[17:01:01.773] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.773] - nx: 1
[17:01:01.773] - relay: TRUE
[17:01:01.773] - stdout: TRUE
[17:01:01.773] - signal: TRUE
[17:01:01.773] - resignal: FALSE
[17:01:01.773] - force: TRUE
[17:01:01.773] - relayed: [n=1] TRUE
[17:01:01.773] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.773] - relayed: [n=1] TRUE
[17:01:01.774] - queued futures: [n=1] TRUE
[17:01:01.774] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.774] resolve() on list ... DONE
[17:01:01.774]  - Number of value chunks collected: 1
[17:01:01.774] Resolving 1 futures (chunks) ... DONE
[17:01:01.774] Reducing values from 1 chunks ...
[17:01:01.774]  - Number of values collected after concatenation: 11
[17:01:01.774]  - Number of values expected: 11
[17:01:01.774] Reducing values from 1 chunks ... DONE
[17:01:01.774] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:01:01.775] future_lapply() ...
[17:01:01.777] Number of chunks: 1
[17:01:01.777] getGlobalsAndPackagesXApply() ...
[17:01:01.777]  - future.globals: TRUE
[17:01:01.777] getGlobalsAndPackages() ...
[17:01:01.777] Searching for globals...
[17:01:01.780] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.781] Searching for globals ... DONE
[17:01:01.781] Resolving globals: FALSE
[17:01:01.781] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:01:01.782] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.782] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.782] - packages: [1] ‘future.apply’
[17:01:01.782] getGlobalsAndPackages() ... DONE
[17:01:01.782]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.782]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.782] Finding globals ... DONE
[17:01:01.783]  - use_args: TRUE
[17:01:01.783]  - Getting '...' globals ...
[17:01:01.783] resolve() on list ...
[17:01:01.783]  recursive: 0
[17:01:01.783]  length: 1
[17:01:01.783]  elements: ‘...’
[17:01:01.783]  length: 0 (resolved future 1)
[17:01:01.783] resolve() on list ... DONE
[17:01:01.784]    - '...' content: [n=0] 
[17:01:01.784] List of 1
[17:01:01.784]  $ ...: list()
[17:01:01.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.784]  - attr(*, "where")=List of 1
[17:01:01.784]   ..$ ...:<environment: 0x55aad9d01f58> 
[17:01:01.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.784]  - attr(*, "resolved")= logi TRUE
[17:01:01.784]  - attr(*, "total_size")= num NA
[17:01:01.786]  - Getting '...' globals ... DONE
[17:01:01.786] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.786] List of 8
[17:01:01.786]  $ ...future.FUN:function (x, ...)  
[17:01:01.786]  $ x_FUN        :function (x)  
[17:01:01.786]  $ times        : int 1
[17:01:01.786]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.786]  $ stop_if_not  :function (...)  
[17:01:01.786]  $ dim          : NULL
[17:01:01.786]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:01.786]  $ ...          : list()
[17:01:01.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.786]  - attr(*, "where")=List of 8
[17:01:01.786]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.786]   ..$ ...          :<environment: 0x55aad9d01f58> 
[17:01:01.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.786]  - attr(*, "resolved")= logi FALSE
[17:01:01.786]  - attr(*, "total_size")= num 94264
[17:01:01.794] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.794] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.794] Number of futures (= number of chunks): 1
[17:01:01.794] Launching 1 futures (chunks) ...
[17:01:01.794] Chunk #1 of 1 ...
[17:01:01.794]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.794] getGlobalsAndPackages() ...
[17:01:01.794] Searching for globals...
[17:01:01.795] 
[17:01:01.795] Searching for globals ... DONE
[17:01:01.795] - globals: [0] <none>
[17:01:01.795] getGlobalsAndPackages() ... DONE
[17:01:01.795]    + additional globals found: [n=0] 
[17:01:01.795]    + additional namespaces needed: [n=0] 
[17:01:01.795]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.795]  - seeds: <none>
[17:01:01.795]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.796] getGlobalsAndPackages() ...
[17:01:01.796] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.796] Resolving globals: FALSE
[17:01:01.796] Tweak future expression to call with '...' arguments ...
[17:01:01.796] {
[17:01:01.796]     do.call(function(...) {
[17:01:01.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.796]             on.exit(options(oopts), add = TRUE)
[17:01:01.796]         }
[17:01:01.796]         {
[17:01:01.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.796]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.796]             })
[17:01:01.796]         }
[17:01:01.796]     }, args = future.call.arguments)
[17:01:01.796] }
[17:01:01.796] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.797] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.797] - packages: [1] ‘future.apply’
[17:01:01.797] getGlobalsAndPackages() ... DONE
[17:01:01.797] run() for ‘Future’ ...
[17:01:01.797] - state: ‘created’
[17:01:01.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.798] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.798]   - Field: ‘label’
[17:01:01.798]   - Field: ‘local’
[17:01:01.798]   - Field: ‘owner’
[17:01:01.798]   - Field: ‘envir’
[17:01:01.798]   - Field: ‘packages’
[17:01:01.798]   - Field: ‘gc’
[17:01:01.799]   - Field: ‘conditions’
[17:01:01.799]   - Field: ‘expr’
[17:01:01.799]   - Field: ‘uuid’
[17:01:01.799]   - Field: ‘seed’
[17:01:01.799]   - Field: ‘version’
[17:01:01.799]   - Field: ‘result’
[17:01:01.799]   - Field: ‘asynchronous’
[17:01:01.799]   - Field: ‘calls’
[17:01:01.799]   - Field: ‘globals’
[17:01:01.799]   - Field: ‘stdout’
[17:01:01.799]   - Field: ‘earlySignal’
[17:01:01.800]   - Field: ‘lazy’
[17:01:01.800]   - Field: ‘state’
[17:01:01.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.800] - Launch lazy future ...
[17:01:01.800] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.800] Packages needed by future strategies (n = 0): <none>
[17:01:01.801] {
[17:01:01.801]     {
[17:01:01.801]         {
[17:01:01.801]             ...future.startTime <- base::Sys.time()
[17:01:01.801]             {
[17:01:01.801]                 {
[17:01:01.801]                   {
[17:01:01.801]                     {
[17:01:01.801]                       base::local({
[17:01:01.801]                         has_future <- base::requireNamespace("future", 
[17:01:01.801]                           quietly = TRUE)
[17:01:01.801]                         if (has_future) {
[17:01:01.801]                           ns <- base::getNamespace("future")
[17:01:01.801]                           version <- ns[[".package"]][["version"]]
[17:01:01.801]                           if (is.null(version)) 
[17:01:01.801]                             version <- utils::packageVersion("future")
[17:01:01.801]                         }
[17:01:01.801]                         else {
[17:01:01.801]                           version <- NULL
[17:01:01.801]                         }
[17:01:01.801]                         if (!has_future || version < "1.8.0") {
[17:01:01.801]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.801]                             "", base::R.version$version.string), 
[17:01:01.801]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.801]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.801]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.801]                               "release", "version")], collapse = " "), 
[17:01:01.801]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.801]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.801]                             info)
[17:01:01.801]                           info <- base::paste(info, collapse = "; ")
[17:01:01.801]                           if (!has_future) {
[17:01:01.801]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.801]                               info)
[17:01:01.801]                           }
[17:01:01.801]                           else {
[17:01:01.801]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.801]                               info, version)
[17:01:01.801]                           }
[17:01:01.801]                           base::stop(msg)
[17:01:01.801]                         }
[17:01:01.801]                       })
[17:01:01.801]                     }
[17:01:01.801]                     base::local({
[17:01:01.801]                       for (pkg in "future.apply") {
[17:01:01.801]                         base::loadNamespace(pkg)
[17:01:01.801]                         base::library(pkg, character.only = TRUE)
[17:01:01.801]                       }
[17:01:01.801]                     })
[17:01:01.801]                   }
[17:01:01.801]                   ...future.strategy.old <- future::plan("list")
[17:01:01.801]                   options(future.plan = NULL)
[17:01:01.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.801]                 }
[17:01:01.801]                 ...future.workdir <- getwd()
[17:01:01.801]             }
[17:01:01.801]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.801]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.801]         }
[17:01:01.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.801]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.801]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.801]             base::names(...future.oldOptions))
[17:01:01.801]     }
[17:01:01.801]     if (FALSE) {
[17:01:01.801]     }
[17:01:01.801]     else {
[17:01:01.801]         if (TRUE) {
[17:01:01.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.801]                 open = "w")
[17:01:01.801]         }
[17:01:01.801]         else {
[17:01:01.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.801]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.801]         }
[17:01:01.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.801]             base::sink(type = "output", split = FALSE)
[17:01:01.801]             base::close(...future.stdout)
[17:01:01.801]         }, add = TRUE)
[17:01:01.801]     }
[17:01:01.801]     ...future.frame <- base::sys.nframe()
[17:01:01.801]     ...future.conditions <- base::list()
[17:01:01.801]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.801]     if (FALSE) {
[17:01:01.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.801]     }
[17:01:01.801]     ...future.result <- base::tryCatch({
[17:01:01.801]         base::withCallingHandlers({
[17:01:01.801]             ...future.value <- base::withVisible(base::local({
[17:01:01.801]                 do.call(function(...) {
[17:01:01.801]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.801]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.801]                     ...future.globals.maxSize)) {
[17:01:01.801]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.801]                     on.exit(options(oopts), add = TRUE)
[17:01:01.801]                   }
[17:01:01.801]                   {
[17:01:01.801]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.801]                       FUN = function(jj) {
[17:01:01.801]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.801]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.801]                       })
[17:01:01.801]                   }
[17:01:01.801]                 }, args = future.call.arguments)
[17:01:01.801]             }))
[17:01:01.801]             future::FutureResult(value = ...future.value$value, 
[17:01:01.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.801]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.801]                     ...future.globalenv.names))
[17:01:01.801]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.801]         }, condition = base::local({
[17:01:01.801]             c <- base::c
[17:01:01.801]             inherits <- base::inherits
[17:01:01.801]             invokeRestart <- base::invokeRestart
[17:01:01.801]             length <- base::length
[17:01:01.801]             list <- base::list
[17:01:01.801]             seq.int <- base::seq.int
[17:01:01.801]             signalCondition <- base::signalCondition
[17:01:01.801]             sys.calls <- base::sys.calls
[17:01:01.801]             `[[` <- base::`[[`
[17:01:01.801]             `+` <- base::`+`
[17:01:01.801]             `<<-` <- base::`<<-`
[17:01:01.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.801]                   3L)]
[17:01:01.801]             }
[17:01:01.801]             function(cond) {
[17:01:01.801]                 is_error <- inherits(cond, "error")
[17:01:01.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.801]                   NULL)
[17:01:01.801]                 if (is_error) {
[17:01:01.801]                   sessionInformation <- function() {
[17:01:01.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.801]                       search = base::search(), system = base::Sys.info())
[17:01:01.801]                   }
[17:01:01.801]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.801]                     cond$call), session = sessionInformation(), 
[17:01:01.801]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.801]                   signalCondition(cond)
[17:01:01.801]                 }
[17:01:01.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.801]                 "immediateCondition"))) {
[17:01:01.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.801]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.801]                   if (TRUE && !signal) {
[17:01:01.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.801]                     {
[17:01:01.801]                       inherits <- base::inherits
[17:01:01.801]                       invokeRestart <- base::invokeRestart
[17:01:01.801]                       is.null <- base::is.null
[17:01:01.801]                       muffled <- FALSE
[17:01:01.801]                       if (inherits(cond, "message")) {
[17:01:01.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.801]                         if (muffled) 
[17:01:01.801]                           invokeRestart("muffleMessage")
[17:01:01.801]                       }
[17:01:01.801]                       else if (inherits(cond, "warning")) {
[17:01:01.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.801]                         if (muffled) 
[17:01:01.801]                           invokeRestart("muffleWarning")
[17:01:01.801]                       }
[17:01:01.801]                       else if (inherits(cond, "condition")) {
[17:01:01.801]                         if (!is.null(pattern)) {
[17:01:01.801]                           computeRestarts <- base::computeRestarts
[17:01:01.801]                           grepl <- base::grepl
[17:01:01.801]                           restarts <- computeRestarts(cond)
[17:01:01.801]                           for (restart in restarts) {
[17:01:01.801]                             name <- restart$name
[17:01:01.801]                             if (is.null(name)) 
[17:01:01.801]                               next
[17:01:01.801]                             if (!grepl(pattern, name)) 
[17:01:01.801]                               next
[17:01:01.801]                             invokeRestart(restart)
[17:01:01.801]                             muffled <- TRUE
[17:01:01.801]                             break
[17:01:01.801]                           }
[17:01:01.801]                         }
[17:01:01.801]                       }
[17:01:01.801]                       invisible(muffled)
[17:01:01.801]                     }
[17:01:01.801]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.801]                   }
[17:01:01.801]                 }
[17:01:01.801]                 else {
[17:01:01.801]                   if (TRUE) {
[17:01:01.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.801]                     {
[17:01:01.801]                       inherits <- base::inherits
[17:01:01.801]                       invokeRestart <- base::invokeRestart
[17:01:01.801]                       is.null <- base::is.null
[17:01:01.801]                       muffled <- FALSE
[17:01:01.801]                       if (inherits(cond, "message")) {
[17:01:01.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.801]                         if (muffled) 
[17:01:01.801]                           invokeRestart("muffleMessage")
[17:01:01.801]                       }
[17:01:01.801]                       else if (inherits(cond, "warning")) {
[17:01:01.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.801]                         if (muffled) 
[17:01:01.801]                           invokeRestart("muffleWarning")
[17:01:01.801]                       }
[17:01:01.801]                       else if (inherits(cond, "condition")) {
[17:01:01.801]                         if (!is.null(pattern)) {
[17:01:01.801]                           computeRestarts <- base::computeRestarts
[17:01:01.801]                           grepl <- base::grepl
[17:01:01.801]                           restarts <- computeRestarts(cond)
[17:01:01.801]                           for (restart in restarts) {
[17:01:01.801]                             name <- restart$name
[17:01:01.801]                             if (is.null(name)) 
[17:01:01.801]                               next
[17:01:01.801]                             if (!grepl(pattern, name)) 
[17:01:01.801]                               next
[17:01:01.801]                             invokeRestart(restart)
[17:01:01.801]                             muffled <- TRUE
[17:01:01.801]                             break
[17:01:01.801]                           }
[17:01:01.801]                         }
[17:01:01.801]                       }
[17:01:01.801]                       invisible(muffled)
[17:01:01.801]                     }
[17:01:01.801]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.801]                   }
[17:01:01.801]                 }
[17:01:01.801]             }
[17:01:01.801]         }))
[17:01:01.801]     }, error = function(ex) {
[17:01:01.801]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.801]                 ...future.rng), started = ...future.startTime, 
[17:01:01.801]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.801]             version = "1.8"), class = "FutureResult")
[17:01:01.801]     }, finally = {
[17:01:01.801]         if (!identical(...future.workdir, getwd())) 
[17:01:01.801]             setwd(...future.workdir)
[17:01:01.801]         {
[17:01:01.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.801]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.801]             }
[17:01:01.801]             base::options(...future.oldOptions)
[17:01:01.801]             if (.Platform$OS.type == "windows") {
[17:01:01.801]                 old_names <- names(...future.oldEnvVars)
[17:01:01.801]                 envs <- base::Sys.getenv()
[17:01:01.801]                 names <- names(envs)
[17:01:01.801]                 common <- intersect(names, old_names)
[17:01:01.801]                 added <- setdiff(names, old_names)
[17:01:01.801]                 removed <- setdiff(old_names, names)
[17:01:01.801]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.801]                   envs[common]]
[17:01:01.801]                 NAMES <- toupper(changed)
[17:01:01.801]                 args <- list()
[17:01:01.801]                 for (kk in seq_along(NAMES)) {
[17:01:01.801]                   name <- changed[[kk]]
[17:01:01.801]                   NAME <- NAMES[[kk]]
[17:01:01.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.801]                     next
[17:01:01.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.801]                 }
[17:01:01.801]                 NAMES <- toupper(added)
[17:01:01.801]                 for (kk in seq_along(NAMES)) {
[17:01:01.801]                   name <- added[[kk]]
[17:01:01.801]                   NAME <- NAMES[[kk]]
[17:01:01.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.801]                     next
[17:01:01.801]                   args[[name]] <- ""
[17:01:01.801]                 }
[17:01:01.801]                 NAMES <- toupper(removed)
[17:01:01.801]                 for (kk in seq_along(NAMES)) {
[17:01:01.801]                   name <- removed[[kk]]
[17:01:01.801]                   NAME <- NAMES[[kk]]
[17:01:01.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.801]                     next
[17:01:01.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.801]                 }
[17:01:01.801]                 if (length(args) > 0) 
[17:01:01.801]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.801]             }
[17:01:01.801]             else {
[17:01:01.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.801]             }
[17:01:01.801]             {
[17:01:01.801]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.801]                   0L) {
[17:01:01.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.801]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.801]                   base::options(opts)
[17:01:01.801]                 }
[17:01:01.801]                 {
[17:01:01.801]                   {
[17:01:01.801]                     NULL
[17:01:01.801]                     RNGkind("Mersenne-Twister")
[17:01:01.801]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.801]                       inherits = FALSE)
[17:01:01.801]                   }
[17:01:01.801]                   options(future.plan = NULL)
[17:01:01.801]                   if (is.na(NA_character_)) 
[17:01:01.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.801]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.801]                     .init = FALSE)
[17:01:01.801]                 }
[17:01:01.801]             }
[17:01:01.801]         }
[17:01:01.801]     })
[17:01:01.801]     if (TRUE) {
[17:01:01.801]         base::sink(type = "output", split = FALSE)
[17:01:01.801]         if (TRUE) {
[17:01:01.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.801]         }
[17:01:01.801]         else {
[17:01:01.801]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.801]         }
[17:01:01.801]         base::close(...future.stdout)
[17:01:01.801]         ...future.stdout <- NULL
[17:01:01.801]     }
[17:01:01.801]     ...future.result$conditions <- ...future.conditions
[17:01:01.801]     ...future.result$finished <- base::Sys.time()
[17:01:01.801]     ...future.result
[17:01:01.801] }
[17:01:01.802] assign_globals() ...
[17:01:01.802] List of 11
[17:01:01.802]  $ ...future.FUN            :function (x, ...)  
[17:01:01.802]  $ x_FUN                    :function (x)  
[17:01:01.802]  $ times                    : int 1
[17:01:01.802]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.802]  $ stop_if_not              :function (...)  
[17:01:01.802]  $ dim                      : NULL
[17:01:01.802]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:01.802]  $ future.call.arguments    : list()
[17:01:01.802]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.802]  $ ...future.elements_ii    :List of 3
[17:01:01.802]   ..$ a: num 1
[17:01:01.802]   ..$ b: num 2
[17:01:01.802]   ..$ c: num 3
[17:01:01.802]  $ ...future.seeds_ii       : NULL
[17:01:01.802]  $ ...future.globals.maxSize: NULL
[17:01:01.802]  - attr(*, "where")=List of 11
[17:01:01.802]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.802]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.802]  - attr(*, "resolved")= logi FALSE
[17:01:01.802]  - attr(*, "total_size")= num 94264
[17:01:01.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.802]  - attr(*, "already-done")= logi TRUE
[17:01:01.810] - copied ‘...future.FUN’ to environment
[17:01:01.810] - copied ‘x_FUN’ to environment
[17:01:01.810] - copied ‘times’ to environment
[17:01:01.810] - copied ‘stopf’ to environment
[17:01:01.811] - copied ‘stop_if_not’ to environment
[17:01:01.811] - copied ‘dim’ to environment
[17:01:01.811] - copied ‘valid_types’ to environment
[17:01:01.811] - copied ‘future.call.arguments’ to environment
[17:01:01.811] - copied ‘...future.elements_ii’ to environment
[17:01:01.811] - copied ‘...future.seeds_ii’ to environment
[17:01:01.811] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.811] assign_globals() ... done
[17:01:01.812] plan(): Setting new future strategy stack:
[17:01:01.812] List of future strategies:
[17:01:01.812] 1. sequential:
[17:01:01.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.812]    - tweaked: FALSE
[17:01:01.812]    - call: NULL
[17:01:01.812] plan(): nbrOfWorkers() = 1
[17:01:01.813] plan(): Setting new future strategy stack:
[17:01:01.813] List of future strategies:
[17:01:01.813] 1. sequential:
[17:01:01.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.813]    - tweaked: FALSE
[17:01:01.813]    - call: plan(strategy)
[17:01:01.813] plan(): nbrOfWorkers() = 1
[17:01:01.814] SequentialFuture started (and completed)
[17:01:01.814] - Launch lazy future ... done
[17:01:01.814] run() for ‘SequentialFuture’ ... done
[17:01:01.814] Created future:
[17:01:01.814] SequentialFuture:
[17:01:01.814] Label: ‘future_vapply-1’
[17:01:01.814] Expression:
[17:01:01.814] {
[17:01:01.814]     do.call(function(...) {
[17:01:01.814]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.814]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.814]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.814]             on.exit(options(oopts), add = TRUE)
[17:01:01.814]         }
[17:01:01.814]         {
[17:01:01.814]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.814]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.814]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.814]             })
[17:01:01.814]         }
[17:01:01.814]     }, args = future.call.arguments)
[17:01:01.814] }
[17:01:01.814] Lazy evaluation: FALSE
[17:01:01.814] Asynchronous evaluation: FALSE
[17:01:01.814] Local evaluation: TRUE
[17:01:01.814] Environment: R_GlobalEnv
[17:01:01.814] Capture standard output: TRUE
[17:01:01.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.814] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.814] Packages: 1 packages (‘future.apply’)
[17:01:01.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.814] Resolved: TRUE
[17:01:01.814] Value: 168 bytes of class ‘list’
[17:01:01.814] Early signaling: FALSE
[17:01:01.814] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.814] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.817] Chunk #1 of 1 ... DONE
[17:01:01.817] Launching 1 futures (chunks) ... DONE
[17:01:01.817] Resolving 1 futures (chunks) ...
[17:01:01.817] resolve() on list ...
[17:01:01.817]  recursive: 0
[17:01:01.817]  length: 1
[17:01:01.818] 
[17:01:01.818] resolved() for ‘SequentialFuture’ ...
[17:01:01.818] - state: ‘finished’
[17:01:01.818] - run: TRUE
[17:01:01.818] - result: ‘FutureResult’
[17:01:01.818] resolved() for ‘SequentialFuture’ ... done
[17:01:01.818] Future #1
[17:01:01.818] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.819] - nx: 1
[17:01:01.819] - relay: TRUE
[17:01:01.819] - stdout: TRUE
[17:01:01.819] - signal: TRUE
[17:01:01.819] - resignal: FALSE
[17:01:01.819] - force: TRUE
[17:01:01.819] - relayed: [n=1] FALSE
[17:01:01.819] - queued futures: [n=1] FALSE
[17:01:01.819]  - until=1
[17:01:01.819]  - relaying element #1
[17:01:01.820] - relayed: [n=1] TRUE
[17:01:01.820] - queued futures: [n=1] TRUE
[17:01:01.820] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.820]  length: 0 (resolved future 1)
[17:01:01.820] Relaying remaining futures
[17:01:01.820] signalConditionsASAP(NULL, pos=0) ...
[17:01:01.820] - nx: 1
[17:01:01.820] - relay: TRUE
[17:01:01.820] - stdout: TRUE
[17:01:01.820] - signal: TRUE
[17:01:01.820] - resignal: FALSE
[17:01:01.821] - force: TRUE
[17:01:01.821] - relayed: [n=1] TRUE
[17:01:01.821] - queued futures: [n=1] TRUE
 - flush all
[17:01:01.821] - relayed: [n=1] TRUE
[17:01:01.821] - queued futures: [n=1] TRUE
[17:01:01.821] signalConditionsASAP(NULL, pos=0) ... done
[17:01:01.821] resolve() on list ... DONE
[17:01:01.821]  - Number of value chunks collected: 1
[17:01:01.821] Resolving 1 futures (chunks) ... DONE
[17:01:01.821] Reducing values from 1 chunks ...
[17:01:01.821]  - Number of values collected after concatenation: 3
[17:01:01.822]  - Number of values expected: 3
[17:01:01.822] Reducing values from 1 chunks ... DONE
[17:01:01.822] future_lapply() ... DONE
- exceptions ...
[17:01:01.822] future_lapply() ...
[17:01:01.824] Number of chunks: 1
[17:01:01.824] getGlobalsAndPackagesXApply() ...
[17:01:01.824]  - future.globals: TRUE
[17:01:01.824] getGlobalsAndPackages() ...
[17:01:01.824] Searching for globals...
[17:01:01.827] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.828] Searching for globals ... DONE
[17:01:01.828] Resolving globals: FALSE
[17:01:01.828] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:01:01.829] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.829] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.829] - packages: [1] ‘future.apply’
[17:01:01.829] getGlobalsAndPackages() ... DONE
[17:01:01.829]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.829]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.830] Finding globals ... DONE
[17:01:01.830]  - use_args: TRUE
[17:01:01.830]  - Getting '...' globals ...
[17:01:01.830] resolve() on list ...
[17:01:01.830]  recursive: 0
[17:01:01.830]  length: 1
[17:01:01.830]  elements: ‘...’
[17:01:01.830]  length: 0 (resolved future 1)
[17:01:01.831] resolve() on list ... DONE
[17:01:01.831]    - '...' content: [n=0] 
[17:01:01.831] List of 1
[17:01:01.831]  $ ...: list()
[17:01:01.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.831]  - attr(*, "where")=List of 1
[17:01:01.831]   ..$ ...:<environment: 0x55aad905ec38> 
[17:01:01.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.831]  - attr(*, "resolved")= logi TRUE
[17:01:01.831]  - attr(*, "total_size")= num NA
[17:01:01.833]  - Getting '...' globals ... DONE
[17:01:01.833] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.834] List of 8
[17:01:01.834]  $ ...future.FUN:function (x, ...)  
[17:01:01.834]  $ x_FUN        :function (x)  
[17:01:01.834]  $ times        : int 2
[17:01:01.834]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.834]  $ stop_if_not  :function (...)  
[17:01:01.834]  $ dim          : NULL
[17:01:01.834]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:01.834]  $ ...          : list()
[17:01:01.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.834]  - attr(*, "where")=List of 8
[17:01:01.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.834]   ..$ ...          :<environment: 0x55aad905ec38> 
[17:01:01.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.834]  - attr(*, "resolved")= logi FALSE
[17:01:01.834]  - attr(*, "total_size")= num 95128
[17:01:01.841] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.841] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.841] Number of futures (= number of chunks): 1
[17:01:01.841] Launching 1 futures (chunks) ...
[17:01:01.841] Chunk #1 of 1 ...
[17:01:01.841]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.842] getGlobalsAndPackages() ...
[17:01:01.842] Searching for globals...
[17:01:01.842] 
[17:01:01.842] Searching for globals ... DONE
[17:01:01.842] - globals: [0] <none>
[17:01:01.842] getGlobalsAndPackages() ... DONE
[17:01:01.842]    + additional globals found: [n=0] 
[17:01:01.842]    + additional namespaces needed: [n=0] 
[17:01:01.843]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.843]  - seeds: <none>
[17:01:01.843]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.843] getGlobalsAndPackages() ...
[17:01:01.843] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.843] Resolving globals: FALSE
[17:01:01.843] Tweak future expression to call with '...' arguments ...
[17:01:01.843] {
[17:01:01.843]     do.call(function(...) {
[17:01:01.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.843]             on.exit(options(oopts), add = TRUE)
[17:01:01.843]         }
[17:01:01.843]         {
[17:01:01.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.843]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.843]             })
[17:01:01.843]         }
[17:01:01.843]     }, args = future.call.arguments)
[17:01:01.843] }
[17:01:01.844] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.844] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.844] - packages: [1] ‘future.apply’
[17:01:01.844] getGlobalsAndPackages() ... DONE
[17:01:01.845] run() for ‘Future’ ...
[17:01:01.845] - state: ‘created’
[17:01:01.845] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:01:01.845] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:01:01.845]   - Field: ‘label’
[17:01:01.845]   - Field: ‘local’
[17:01:01.845]   - Field: ‘owner’
[17:01:01.846]   - Field: ‘envir’
[17:01:01.846]   - Field: ‘packages’
[17:01:01.846]   - Field: ‘gc’
[17:01:01.846]   - Field: ‘conditions’
[17:01:01.846]   - Field: ‘expr’
[17:01:01.846]   - Field: ‘uuid’
[17:01:01.846]   - Field: ‘seed’
[17:01:01.846]   - Field: ‘version’
[17:01:01.846]   - Field: ‘result’
[17:01:01.846]   - Field: ‘asynchronous’
[17:01:01.846]   - Field: ‘calls’
[17:01:01.847]   - Field: ‘globals’
[17:01:01.847]   - Field: ‘stdout’
[17:01:01.847]   - Field: ‘earlySignal’
[17:01:01.847]   - Field: ‘lazy’
[17:01:01.847]   - Field: ‘state’
[17:01:01.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:01:01.847] - Launch lazy future ...
[17:01:01.847] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.847] Packages needed by future strategies (n = 0): <none>
[17:01:01.848] {
[17:01:01.848]     {
[17:01:01.848]         {
[17:01:01.848]             ...future.startTime <- base::Sys.time()
[17:01:01.848]             {
[17:01:01.848]                 {
[17:01:01.848]                   {
[17:01:01.848]                     {
[17:01:01.848]                       base::local({
[17:01:01.848]                         has_future <- base::requireNamespace("future", 
[17:01:01.848]                           quietly = TRUE)
[17:01:01.848]                         if (has_future) {
[17:01:01.848]                           ns <- base::getNamespace("future")
[17:01:01.848]                           version <- ns[[".package"]][["version"]]
[17:01:01.848]                           if (is.null(version)) 
[17:01:01.848]                             version <- utils::packageVersion("future")
[17:01:01.848]                         }
[17:01:01.848]                         else {
[17:01:01.848]                           version <- NULL
[17:01:01.848]                         }
[17:01:01.848]                         if (!has_future || version < "1.8.0") {
[17:01:01.848]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.848]                             "", base::R.version$version.string), 
[17:01:01.848]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:01.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:01.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.848]                               "release", "version")], collapse = " "), 
[17:01:01.848]                             hostname = base::Sys.info()[["nodename"]])
[17:01:01.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.848]                             info)
[17:01:01.848]                           info <- base::paste(info, collapse = "; ")
[17:01:01.848]                           if (!has_future) {
[17:01:01.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.848]                               info)
[17:01:01.848]                           }
[17:01:01.848]                           else {
[17:01:01.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.848]                               info, version)
[17:01:01.848]                           }
[17:01:01.848]                           base::stop(msg)
[17:01:01.848]                         }
[17:01:01.848]                       })
[17:01:01.848]                     }
[17:01:01.848]                     base::local({
[17:01:01.848]                       for (pkg in "future.apply") {
[17:01:01.848]                         base::loadNamespace(pkg)
[17:01:01.848]                         base::library(pkg, character.only = TRUE)
[17:01:01.848]                       }
[17:01:01.848]                     })
[17:01:01.848]                   }
[17:01:01.848]                   ...future.strategy.old <- future::plan("list")
[17:01:01.848]                   options(future.plan = NULL)
[17:01:01.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.848]                 }
[17:01:01.848]                 ...future.workdir <- getwd()
[17:01:01.848]             }
[17:01:01.848]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.848]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.848]         }
[17:01:01.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:01.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.848]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.848]             base::names(...future.oldOptions))
[17:01:01.848]     }
[17:01:01.848]     if (FALSE) {
[17:01:01.848]     }
[17:01:01.848]     else {
[17:01:01.848]         if (TRUE) {
[17:01:01.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.848]                 open = "w")
[17:01:01.848]         }
[17:01:01.848]         else {
[17:01:01.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.848]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.848]         }
[17:01:01.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.848]             base::sink(type = "output", split = FALSE)
[17:01:01.848]             base::close(...future.stdout)
[17:01:01.848]         }, add = TRUE)
[17:01:01.848]     }
[17:01:01.848]     ...future.frame <- base::sys.nframe()
[17:01:01.848]     ...future.conditions <- base::list()
[17:01:01.848]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.848]     if (FALSE) {
[17:01:01.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.848]     }
[17:01:01.848]     ...future.result <- base::tryCatch({
[17:01:01.848]         base::withCallingHandlers({
[17:01:01.848]             ...future.value <- base::withVisible(base::local({
[17:01:01.848]                 do.call(function(...) {
[17:01:01.848]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.848]                   if (!identical(...future.globals.maxSize.org, 
[17:01:01.848]                     ...future.globals.maxSize)) {
[17:01:01.848]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.848]                     on.exit(options(oopts), add = TRUE)
[17:01:01.848]                   }
[17:01:01.848]                   {
[17:01:01.848]                     lapply(seq_along(...future.elements_ii), 
[17:01:01.848]                       FUN = function(jj) {
[17:01:01.848]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.848]                         ...future.FUN(...future.X_jj, ...)
[17:01:01.848]                       })
[17:01:01.848]                   }
[17:01:01.848]                 }, args = future.call.arguments)
[17:01:01.848]             }))
[17:01:01.848]             future::FutureResult(value = ...future.value$value, 
[17:01:01.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.848]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.848]                     ...future.globalenv.names))
[17:01:01.848]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.848]         }, condition = base::local({
[17:01:01.848]             c <- base::c
[17:01:01.848]             inherits <- base::inherits
[17:01:01.848]             invokeRestart <- base::invokeRestart
[17:01:01.848]             length <- base::length
[17:01:01.848]             list <- base::list
[17:01:01.848]             seq.int <- base::seq.int
[17:01:01.848]             signalCondition <- base::signalCondition
[17:01:01.848]             sys.calls <- base::sys.calls
[17:01:01.848]             `[[` <- base::`[[`
[17:01:01.848]             `+` <- base::`+`
[17:01:01.848]             `<<-` <- base::`<<-`
[17:01:01.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.848]                   3L)]
[17:01:01.848]             }
[17:01:01.848]             function(cond) {
[17:01:01.848]                 is_error <- inherits(cond, "error")
[17:01:01.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.848]                   NULL)
[17:01:01.848]                 if (is_error) {
[17:01:01.848]                   sessionInformation <- function() {
[17:01:01.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.848]                       search = base::search(), system = base::Sys.info())
[17:01:01.848]                   }
[17:01:01.848]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.848]                     cond$call), session = sessionInformation(), 
[17:01:01.848]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.848]                   signalCondition(cond)
[17:01:01.848]                 }
[17:01:01.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.848]                 "immediateCondition"))) {
[17:01:01.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.848]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.848]                   if (TRUE && !signal) {
[17:01:01.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.848]                     {
[17:01:01.848]                       inherits <- base::inherits
[17:01:01.848]                       invokeRestart <- base::invokeRestart
[17:01:01.848]                       is.null <- base::is.null
[17:01:01.848]                       muffled <- FALSE
[17:01:01.848]                       if (inherits(cond, "message")) {
[17:01:01.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.848]                         if (muffled) 
[17:01:01.848]                           invokeRestart("muffleMessage")
[17:01:01.848]                       }
[17:01:01.848]                       else if (inherits(cond, "warning")) {
[17:01:01.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.848]                         if (muffled) 
[17:01:01.848]                           invokeRestart("muffleWarning")
[17:01:01.848]                       }
[17:01:01.848]                       else if (inherits(cond, "condition")) {
[17:01:01.848]                         if (!is.null(pattern)) {
[17:01:01.848]                           computeRestarts <- base::computeRestarts
[17:01:01.848]                           grepl <- base::grepl
[17:01:01.848]                           restarts <- computeRestarts(cond)
[17:01:01.848]                           for (restart in restarts) {
[17:01:01.848]                             name <- restart$name
[17:01:01.848]                             if (is.null(name)) 
[17:01:01.848]                               next
[17:01:01.848]                             if (!grepl(pattern, name)) 
[17:01:01.848]                               next
[17:01:01.848]                             invokeRestart(restart)
[17:01:01.848]                             muffled <- TRUE
[17:01:01.848]                             break
[17:01:01.848]                           }
[17:01:01.848]                         }
[17:01:01.848]                       }
[17:01:01.848]                       invisible(muffled)
[17:01:01.848]                     }
[17:01:01.848]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.848]                   }
[17:01:01.848]                 }
[17:01:01.848]                 else {
[17:01:01.848]                   if (TRUE) {
[17:01:01.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.848]                     {
[17:01:01.848]                       inherits <- base::inherits
[17:01:01.848]                       invokeRestart <- base::invokeRestart
[17:01:01.848]                       is.null <- base::is.null
[17:01:01.848]                       muffled <- FALSE
[17:01:01.848]                       if (inherits(cond, "message")) {
[17:01:01.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.848]                         if (muffled) 
[17:01:01.848]                           invokeRestart("muffleMessage")
[17:01:01.848]                       }
[17:01:01.848]                       else if (inherits(cond, "warning")) {
[17:01:01.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.848]                         if (muffled) 
[17:01:01.848]                           invokeRestart("muffleWarning")
[17:01:01.848]                       }
[17:01:01.848]                       else if (inherits(cond, "condition")) {
[17:01:01.848]                         if (!is.null(pattern)) {
[17:01:01.848]                           computeRestarts <- base::computeRestarts
[17:01:01.848]                           grepl <- base::grepl
[17:01:01.848]                           restarts <- computeRestarts(cond)
[17:01:01.848]                           for (restart in restarts) {
[17:01:01.848]                             name <- restart$name
[17:01:01.848]                             if (is.null(name)) 
[17:01:01.848]                               next
[17:01:01.848]                             if (!grepl(pattern, name)) 
[17:01:01.848]                               next
[17:01:01.848]                             invokeRestart(restart)
[17:01:01.848]                             muffled <- TRUE
[17:01:01.848]                             break
[17:01:01.848]                           }
[17:01:01.848]                         }
[17:01:01.848]                       }
[17:01:01.848]                       invisible(muffled)
[17:01:01.848]                     }
[17:01:01.848]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.848]                   }
[17:01:01.848]                 }
[17:01:01.848]             }
[17:01:01.848]         }))
[17:01:01.848]     }, error = function(ex) {
[17:01:01.848]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.848]                 ...future.rng), started = ...future.startTime, 
[17:01:01.848]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.848]             version = "1.8"), class = "FutureResult")
[17:01:01.848]     }, finally = {
[17:01:01.848]         if (!identical(...future.workdir, getwd())) 
[17:01:01.848]             setwd(...future.workdir)
[17:01:01.848]         {
[17:01:01.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.848]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.848]             }
[17:01:01.848]             base::options(...future.oldOptions)
[17:01:01.848]             if (.Platform$OS.type == "windows") {
[17:01:01.848]                 old_names <- names(...future.oldEnvVars)
[17:01:01.848]                 envs <- base::Sys.getenv()
[17:01:01.848]                 names <- names(envs)
[17:01:01.848]                 common <- intersect(names, old_names)
[17:01:01.848]                 added <- setdiff(names, old_names)
[17:01:01.848]                 removed <- setdiff(old_names, names)
[17:01:01.848]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.848]                   envs[common]]
[17:01:01.848]                 NAMES <- toupper(changed)
[17:01:01.848]                 args <- list()
[17:01:01.848]                 for (kk in seq_along(NAMES)) {
[17:01:01.848]                   name <- changed[[kk]]
[17:01:01.848]                   NAME <- NAMES[[kk]]
[17:01:01.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.848]                     next
[17:01:01.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.848]                 }
[17:01:01.848]                 NAMES <- toupper(added)
[17:01:01.848]                 for (kk in seq_along(NAMES)) {
[17:01:01.848]                   name <- added[[kk]]
[17:01:01.848]                   NAME <- NAMES[[kk]]
[17:01:01.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.848]                     next
[17:01:01.848]                   args[[name]] <- ""
[17:01:01.848]                 }
[17:01:01.848]                 NAMES <- toupper(removed)
[17:01:01.848]                 for (kk in seq_along(NAMES)) {
[17:01:01.848]                   name <- removed[[kk]]
[17:01:01.848]                   NAME <- NAMES[[kk]]
[17:01:01.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.848]                     next
[17:01:01.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.848]                 }
[17:01:01.848]                 if (length(args) > 0) 
[17:01:01.848]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.848]             }
[17:01:01.848]             else {
[17:01:01.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.848]             }
[17:01:01.848]             {
[17:01:01.848]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.848]                   0L) {
[17:01:01.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.848]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.848]                   base::options(opts)
[17:01:01.848]                 }
[17:01:01.848]                 {
[17:01:01.848]                   {
[17:01:01.848]                     NULL
[17:01:01.848]                     RNGkind("Mersenne-Twister")
[17:01:01.848]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:01:01.848]                       inherits = FALSE)
[17:01:01.848]                   }
[17:01:01.848]                   options(future.plan = NULL)
[17:01:01.848]                   if (is.na(NA_character_)) 
[17:01:01.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.848]                     .init = FALSE)
[17:01:01.848]                 }
[17:01:01.848]             }
[17:01:01.848]         }
[17:01:01.848]     })
[17:01:01.848]     if (TRUE) {
[17:01:01.848]         base::sink(type = "output", split = FALSE)
[17:01:01.848]         if (TRUE) {
[17:01:01.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.848]         }
[17:01:01.848]         else {
[17:01:01.848]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.848]         }
[17:01:01.848]         base::close(...future.stdout)
[17:01:01.848]         ...future.stdout <- NULL
[17:01:01.848]     }
[17:01:01.848]     ...future.result$conditions <- ...future.conditions
[17:01:01.848]     ...future.result$finished <- base::Sys.time()
[17:01:01.848]     ...future.result
[17:01:01.848] }
[17:01:01.850] assign_globals() ...
[17:01:01.850] List of 11
[17:01:01.850]  $ ...future.FUN            :function (x, ...)  
[17:01:01.850]  $ x_FUN                    :function (x)  
[17:01:01.850]  $ times                    : int 2
[17:01:01.850]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.850]  $ stop_if_not              :function (...)  
[17:01:01.850]  $ dim                      : NULL
[17:01:01.850]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:01.850]  $ future.call.arguments    : list()
[17:01:01.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.850]  $ ...future.elements_ii    :List of 3
[17:01:01.850]   ..$ : int 1
[17:01:01.850]   ..$ : int 2
[17:01:01.850]   ..$ : int 3
[17:01:01.850]  $ ...future.seeds_ii       : NULL
[17:01:01.850]  $ ...future.globals.maxSize: NULL
[17:01:01.850]  - attr(*, "where")=List of 11
[17:01:01.850]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.850]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.850]  - attr(*, "resolved")= logi FALSE
[17:01:01.850]  - attr(*, "total_size")= num 95128
[17:01:01.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.850]  - attr(*, "already-done")= logi TRUE
[17:01:01.858] - copied ‘...future.FUN’ to environment
[17:01:01.858] - copied ‘x_FUN’ to environment
[17:01:01.858] - copied ‘times’ to environment
[17:01:01.858] - copied ‘stopf’ to environment
[17:01:01.858] - copied ‘stop_if_not’ to environment
[17:01:01.858] - copied ‘dim’ to environment
[17:01:01.858] - copied ‘valid_types’ to environment
[17:01:01.858] - copied ‘future.call.arguments’ to environment
[17:01:01.858] - copied ‘...future.elements_ii’ to environment
[17:01:01.858] - copied ‘...future.seeds_ii’ to environment
[17:01:01.859] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.859] assign_globals() ... done
[17:01:01.859] plan(): Setting new future strategy stack:
[17:01:01.859] List of future strategies:
[17:01:01.859] 1. sequential:
[17:01:01.859]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.859]    - tweaked: FALSE
[17:01:01.859]    - call: NULL
[17:01:01.860] plan(): nbrOfWorkers() = 1
[17:01:01.861] plan(): Setting new future strategy stack:
[17:01:01.861] List of future strategies:
[17:01:01.861] 1. sequential:
[17:01:01.861]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.861]    - tweaked: FALSE
[17:01:01.861]    - call: plan(strategy)
[17:01:01.861] plan(): nbrOfWorkers() = 1
[17:01:01.861] SequentialFuture started (and completed)
[17:01:01.861] signalConditions() ...
[17:01:01.862]  - include = ‘immediateCondition’
[17:01:01.862]  - exclude = 
[17:01:01.863]  - resignal = FALSE
[17:01:01.864]  - Number of conditions: 1
[17:01:01.864] signalConditions() ... done
[17:01:01.864] - Launch lazy future ... done
[17:01:01.864] run() for ‘SequentialFuture’ ... done
[17:01:01.864] Created future:
[17:01:01.864] SequentialFuture:
[17:01:01.864] Label: ‘future_vapply-1’
[17:01:01.864] Expression:
[17:01:01.864] {
[17:01:01.864]     do.call(function(...) {
[17:01:01.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.864]             on.exit(options(oopts), add = TRUE)
[17:01:01.864]         }
[17:01:01.864]         {
[17:01:01.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.864]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.864]             })
[17:01:01.864]         }
[17:01:01.864]     }, args = future.call.arguments)
[17:01:01.864] }
[17:01:01.864] Lazy evaluation: FALSE
[17:01:01.864] Asynchronous evaluation: FALSE
[17:01:01.864] Local evaluation: TRUE
[17:01:01.864] Environment: R_GlobalEnv
[17:01:01.864] Capture standard output: TRUE
[17:01:01.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.864] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.864] Packages: 1 packages (‘future.apply’)
[17:01:01.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.864] Resolved: TRUE
[17:01:01.864] Value: 0 bytes of class ‘NULL’
[17:01:01.864] Conditions captured: [n=1] ‘simpleError’
[17:01:01.864] Early signaling: FALSE
[17:01:01.864] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.864] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:01:01.866] Chunk #1 of 1 ... DONE
[17:01:01.866] Launching 1 futures (chunks) ... DONE
[17:01:01.866] Resolving 1 futures (chunks) ...
[17:01:01.866] resolve() on list ...
[17:01:01.866]  recursive: 0
[17:01:01.866]  length: 1
[17:01:01.866] 
[17:01:01.866] resolved() for ‘SequentialFuture’ ...
[17:01:01.866] - state: ‘finished’
[17:01:01.866] - run: TRUE
[17:01:01.867] - result: ‘FutureResult’
[17:01:01.867] resolved() for ‘SequentialFuture’ ... done
[17:01:01.867] Future #1
[17:01:01.867] signalConditions() ...
[17:01:01.867]  - include = ‘immediateCondition’
[17:01:01.867]  - exclude = 
[17:01:01.867]  - resignal = FALSE
[17:01:01.867]  - Number of conditions: 1
[17:01:01.867] signalConditions() ... done
[17:01:01.867] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:01:01.868] - nx: 1
[17:01:01.868] - relay: TRUE
[17:01:01.868] - stdout: TRUE
[17:01:01.868] - signal: TRUE
[17:01:01.868] - resignal: FALSE
[17:01:01.868] - force: TRUE
[17:01:01.868] - relayed: [n=1] FALSE
[17:01:01.868] - queued futures: [n=1] FALSE
[17:01:01.868]  - until=1
[17:01:01.868]  - relaying element #1
[17:01:01.868] signalConditions() ...
[17:01:01.869]  - include = ‘immediateCondition’
[17:01:01.869]  - exclude = 
[17:01:01.869]  - resignal = FALSE
[17:01:01.869]  - Number of conditions: 1
[17:01:01.869] signalConditions() ... done
[17:01:01.869] signalConditions() ...
[17:01:01.869]  - include = ‘immediateCondition’
[17:01:01.869]  - exclude = 
[17:01:01.869]  - resignal = FALSE
[17:01:01.869]  - Number of conditions: 1
[17:01:01.869] signalConditions() ... done
[17:01:01.870] signalConditions() ...
[17:01:01.870]  - include = ‘condition’
[17:01:01.870]  - exclude = ‘immediateCondition’
[17:01:01.870]  - resignal = TRUE
[17:01:01.870]  - Number of conditions: 1
[17:01:01.870]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:01:01.870] signalConditions() ... done
[17:01:01.870] - relayed: [n=1] FALSE
[17:01:01.870] - queued futures: [n=1] TRUE
[17:01:01.870] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:01:01.871] plan(): Setting new future strategy stack:
[17:01:01.871] List of future strategies:
[17:01:01.871] 1. sequential:
[17:01:01.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.871]    - tweaked: FALSE
[17:01:01.871]    - call: plan(sequential)
[17:01:01.871] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:01:01.872] plan(): Setting new future strategy stack:
[17:01:01.872] List of future strategies:
[17:01:01.872] 1. multicore:
[17:01:01.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:01.872]    - tweaked: FALSE
[17:01:01.872]    - call: plan(strategy)
[17:01:01.875] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:01:01.878] future_lapply() ...
[17:01:01.883] Number of chunks: 2
[17:01:01.883] getGlobalsAndPackagesXApply() ...
[17:01:01.884]  - future.globals: TRUE
[17:01:01.884] getGlobalsAndPackages() ...
[17:01:01.884] Searching for globals...
[17:01:01.887] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:01.887] Searching for globals ... DONE
[17:01:01.887] Resolving globals: FALSE
[17:01:01.888] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:01:01.888] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:01.888] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.888] - packages: [1] ‘future.apply’
[17:01:01.888] getGlobalsAndPackages() ... DONE
[17:01:01.889]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:01.889]  - needed namespaces: [n=1] ‘future.apply’
[17:01:01.889] Finding globals ... DONE
[17:01:01.889]  - use_args: TRUE
[17:01:01.889]  - Getting '...' globals ...
[17:01:01.889] resolve() on list ...
[17:01:01.889]  recursive: 0
[17:01:01.889]  length: 1
[17:01:01.890]  elements: ‘...’
[17:01:01.890]  length: 0 (resolved future 1)
[17:01:01.890] resolve() on list ... DONE
[17:01:01.892]    - '...' content: [n=0] 
[17:01:01.892] List of 1
[17:01:01.892]  $ ...: list()
[17:01:01.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.892]  - attr(*, "where")=List of 1
[17:01:01.892]   ..$ ...:<environment: 0x55aadb15ab88> 
[17:01:01.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.892]  - attr(*, "resolved")= logi TRUE
[17:01:01.892]  - attr(*, "total_size")= num NA
[17:01:01.895]  - Getting '...' globals ... DONE
[17:01:01.895] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:01.895] List of 8
[17:01:01.895]  $ ...future.FUN:function (x, ...)  
[17:01:01.895]  $ x_FUN        :function (x)  
[17:01:01.895]  $ times        : int 1
[17:01:01.895]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.895]  $ stop_if_not  :function (...)  
[17:01:01.895]  $ dim          : NULL
[17:01:01.895]  $ valid_types  : chr "character"
[17:01:01.895]  $ ...          : list()
[17:01:01.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.895]  - attr(*, "where")=List of 8
[17:01:01.895]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:01.895]   ..$ ...          :<environment: 0x55aadb15ab88> 
[17:01:01.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.895]  - attr(*, "resolved")= logi FALSE
[17:01:01.895]  - attr(*, "total_size")= num 94208
[17:01:01.900] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:01.900] getGlobalsAndPackagesXApply() ... DONE
[17:01:01.901] Number of futures (= number of chunks): 2
[17:01:01.901] Launching 2 futures (chunks) ...
[17:01:01.901] Chunk #1 of 2 ...
[17:01:01.901]  - Finding globals in 'X' for chunk #1 ...
[17:01:01.901] getGlobalsAndPackages() ...
[17:01:01.901] Searching for globals...
[17:01:01.901] 
[17:01:01.901] Searching for globals ... DONE
[17:01:01.902] - globals: [0] <none>
[17:01:01.902] getGlobalsAndPackages() ... DONE
[17:01:01.902]    + additional globals found: [n=0] 
[17:01:01.902]    + additional namespaces needed: [n=0] 
[17:01:01.902]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:01.902]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:01.902]  - seeds: <none>
[17:01:01.902]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.902] getGlobalsAndPackages() ...
[17:01:01.902] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.903] Resolving globals: FALSE
[17:01:01.903] Tweak future expression to call with '...' arguments ...
[17:01:01.903] {
[17:01:01.903]     do.call(function(...) {
[17:01:01.903]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.903]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.903]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.903]             on.exit(options(oopts), add = TRUE)
[17:01:01.903]         }
[17:01:01.903]         {
[17:01:01.903]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.903]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.903]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.903]             })
[17:01:01.903]         }
[17:01:01.903]     }, args = future.call.arguments)
[17:01:01.903] }
[17:01:01.903] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.904] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.904] - packages: [1] ‘future.apply’
[17:01:01.904] getGlobalsAndPackages() ... DONE
[17:01:01.904] run() for ‘Future’ ...
[17:01:01.904] - state: ‘created’
[17:01:01.904] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:01.908] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:01.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:01.908]   - Field: ‘label’
[17:01:01.908]   - Field: ‘local’
[17:01:01.908]   - Field: ‘owner’
[17:01:01.909]   - Field: ‘envir’
[17:01:01.909]   - Field: ‘workers’
[17:01:01.909]   - Field: ‘packages’
[17:01:01.909]   - Field: ‘gc’
[17:01:01.909]   - Field: ‘job’
[17:01:01.909]   - Field: ‘conditions’
[17:01:01.909]   - Field: ‘expr’
[17:01:01.909]   - Field: ‘uuid’
[17:01:01.909]   - Field: ‘seed’
[17:01:01.909]   - Field: ‘version’
[17:01:01.909]   - Field: ‘result’
[17:01:01.910]   - Field: ‘asynchronous’
[17:01:01.910]   - Field: ‘calls’
[17:01:01.910]   - Field: ‘globals’
[17:01:01.910]   - Field: ‘stdout’
[17:01:01.910]   - Field: ‘earlySignal’
[17:01:01.910]   - Field: ‘lazy’
[17:01:01.910]   - Field: ‘state’
[17:01:01.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:01.910] - Launch lazy future ...
[17:01:01.911] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.912] Packages needed by future strategies (n = 0): <none>
[17:01:01.912] {
[17:01:01.912]     {
[17:01:01.912]         {
[17:01:01.912]             ...future.startTime <- base::Sys.time()
[17:01:01.912]             {
[17:01:01.912]                 {
[17:01:01.912]                   {
[17:01:01.912]                     {
[17:01:01.912]                       {
[17:01:01.912]                         base::local({
[17:01:01.912]                           has_future <- base::requireNamespace("future", 
[17:01:01.912]                             quietly = TRUE)
[17:01:01.912]                           if (has_future) {
[17:01:01.912]                             ns <- base::getNamespace("future")
[17:01:01.912]                             version <- ns[[".package"]][["version"]]
[17:01:01.912]                             if (is.null(version)) 
[17:01:01.912]                               version <- utils::packageVersion("future")
[17:01:01.912]                           }
[17:01:01.912]                           else {
[17:01:01.912]                             version <- NULL
[17:01:01.912]                           }
[17:01:01.912]                           if (!has_future || version < "1.8.0") {
[17:01:01.912]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.912]                               "", base::R.version$version.string), 
[17:01:01.912]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:01.912]                                 base::R.version$platform, 8 * 
[17:01:01.912]                                   base::.Machine$sizeof.pointer), 
[17:01:01.912]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.912]                                 "release", "version")], collapse = " "), 
[17:01:01.912]                               hostname = base::Sys.info()[["nodename"]])
[17:01:01.912]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.912]                               info)
[17:01:01.912]                             info <- base::paste(info, collapse = "; ")
[17:01:01.912]                             if (!has_future) {
[17:01:01.912]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.912]                                 info)
[17:01:01.912]                             }
[17:01:01.912]                             else {
[17:01:01.912]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.912]                                 info, version)
[17:01:01.912]                             }
[17:01:01.912]                             base::stop(msg)
[17:01:01.912]                           }
[17:01:01.912]                         })
[17:01:01.912]                       }
[17:01:01.912]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:01.912]                       base::options(mc.cores = 1L)
[17:01:01.912]                     }
[17:01:01.912]                     base::local({
[17:01:01.912]                       for (pkg in "future.apply") {
[17:01:01.912]                         base::loadNamespace(pkg)
[17:01:01.912]                         base::library(pkg, character.only = TRUE)
[17:01:01.912]                       }
[17:01:01.912]                     })
[17:01:01.912]                   }
[17:01:01.912]                   ...future.strategy.old <- future::plan("list")
[17:01:01.912]                   options(future.plan = NULL)
[17:01:01.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.912]                 }
[17:01:01.912]                 ...future.workdir <- getwd()
[17:01:01.912]             }
[17:01:01.912]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.912]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.912]         }
[17:01:01.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.912]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:01.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.912]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.912]             base::names(...future.oldOptions))
[17:01:01.912]     }
[17:01:01.912]     if (FALSE) {
[17:01:01.912]     }
[17:01:01.912]     else {
[17:01:01.912]         if (TRUE) {
[17:01:01.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.912]                 open = "w")
[17:01:01.912]         }
[17:01:01.912]         else {
[17:01:01.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.912]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.912]         }
[17:01:01.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.912]             base::sink(type = "output", split = FALSE)
[17:01:01.912]             base::close(...future.stdout)
[17:01:01.912]         }, add = TRUE)
[17:01:01.912]     }
[17:01:01.912]     ...future.frame <- base::sys.nframe()
[17:01:01.912]     ...future.conditions <- base::list()
[17:01:01.912]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.912]     if (FALSE) {
[17:01:01.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.912]     }
[17:01:01.912]     ...future.result <- base::tryCatch({
[17:01:01.912]         base::withCallingHandlers({
[17:01:01.912]             ...future.value <- base::withVisible(base::local({
[17:01:01.912]                 withCallingHandlers({
[17:01:01.912]                   {
[17:01:01.912]                     do.call(function(...) {
[17:01:01.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.912]                       if (!identical(...future.globals.maxSize.org, 
[17:01:01.912]                         ...future.globals.maxSize)) {
[17:01:01.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.912]                         on.exit(options(oopts), add = TRUE)
[17:01:01.912]                       }
[17:01:01.912]                       {
[17:01:01.912]                         lapply(seq_along(...future.elements_ii), 
[17:01:01.912]                           FUN = function(jj) {
[17:01:01.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.912]                             ...future.FUN(...future.X_jj, ...)
[17:01:01.912]                           })
[17:01:01.912]                       }
[17:01:01.912]                     }, args = future.call.arguments)
[17:01:01.912]                   }
[17:01:01.912]                 }, immediateCondition = function(cond) {
[17:01:01.912]                   save_rds <- function (object, pathname, ...) 
[17:01:01.912]                   {
[17:01:01.912]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:01.912]                     if (file_test("-f", pathname_tmp)) {
[17:01:01.912]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.912]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:01.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.912]                         fi_tmp[["mtime"]])
[17:01:01.912]                     }
[17:01:01.912]                     tryCatch({
[17:01:01.912]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:01.912]                     }, error = function(ex) {
[17:01:01.912]                       msg <- conditionMessage(ex)
[17:01:01.912]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.912]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:01.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.912]                         fi_tmp[["mtime"]], msg)
[17:01:01.912]                       ex$message <- msg
[17:01:01.912]                       stop(ex)
[17:01:01.912]                     })
[17:01:01.912]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:01.912]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:01.912]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:01.912]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.912]                       fi <- file.info(pathname)
[17:01:01.912]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:01.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.912]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:01.912]                         fi[["size"]], fi[["mtime"]])
[17:01:01.912]                       stop(msg)
[17:01:01.912]                     }
[17:01:01.912]                     invisible(pathname)
[17:01:01.912]                   }
[17:01:01.912]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:01.912]                     rootPath = tempdir()) 
[17:01:01.912]                   {
[17:01:01.912]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:01.912]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:01.912]                       tmpdir = path, fileext = ".rds")
[17:01:01.912]                     save_rds(obj, file)
[17:01:01.912]                   }
[17:01:01.912]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:01.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.912]                   {
[17:01:01.912]                     inherits <- base::inherits
[17:01:01.912]                     invokeRestart <- base::invokeRestart
[17:01:01.912]                     is.null <- base::is.null
[17:01:01.912]                     muffled <- FALSE
[17:01:01.912]                     if (inherits(cond, "message")) {
[17:01:01.912]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:01.912]                       if (muffled) 
[17:01:01.912]                         invokeRestart("muffleMessage")
[17:01:01.912]                     }
[17:01:01.912]                     else if (inherits(cond, "warning")) {
[17:01:01.912]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:01.912]                       if (muffled) 
[17:01:01.912]                         invokeRestart("muffleWarning")
[17:01:01.912]                     }
[17:01:01.912]                     else if (inherits(cond, "condition")) {
[17:01:01.912]                       if (!is.null(pattern)) {
[17:01:01.912]                         computeRestarts <- base::computeRestarts
[17:01:01.912]                         grepl <- base::grepl
[17:01:01.912]                         restarts <- computeRestarts(cond)
[17:01:01.912]                         for (restart in restarts) {
[17:01:01.912]                           name <- restart$name
[17:01:01.912]                           if (is.null(name)) 
[17:01:01.912]                             next
[17:01:01.912]                           if (!grepl(pattern, name)) 
[17:01:01.912]                             next
[17:01:01.912]                           invokeRestart(restart)
[17:01:01.912]                           muffled <- TRUE
[17:01:01.912]                           break
[17:01:01.912]                         }
[17:01:01.912]                       }
[17:01:01.912]                     }
[17:01:01.912]                     invisible(muffled)
[17:01:01.912]                   }
[17:01:01.912]                   muffleCondition(cond)
[17:01:01.912]                 })
[17:01:01.912]             }))
[17:01:01.912]             future::FutureResult(value = ...future.value$value, 
[17:01:01.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.912]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.912]                     ...future.globalenv.names))
[17:01:01.912]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.912]         }, condition = base::local({
[17:01:01.912]             c <- base::c
[17:01:01.912]             inherits <- base::inherits
[17:01:01.912]             invokeRestart <- base::invokeRestart
[17:01:01.912]             length <- base::length
[17:01:01.912]             list <- base::list
[17:01:01.912]             seq.int <- base::seq.int
[17:01:01.912]             signalCondition <- base::signalCondition
[17:01:01.912]             sys.calls <- base::sys.calls
[17:01:01.912]             `[[` <- base::`[[`
[17:01:01.912]             `+` <- base::`+`
[17:01:01.912]             `<<-` <- base::`<<-`
[17:01:01.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.912]                   3L)]
[17:01:01.912]             }
[17:01:01.912]             function(cond) {
[17:01:01.912]                 is_error <- inherits(cond, "error")
[17:01:01.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.912]                   NULL)
[17:01:01.912]                 if (is_error) {
[17:01:01.912]                   sessionInformation <- function() {
[17:01:01.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.912]                       search = base::search(), system = base::Sys.info())
[17:01:01.912]                   }
[17:01:01.912]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.912]                     cond$call), session = sessionInformation(), 
[17:01:01.912]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.912]                   signalCondition(cond)
[17:01:01.912]                 }
[17:01:01.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.912]                 "immediateCondition"))) {
[17:01:01.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.912]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.912]                   if (TRUE && !signal) {
[17:01:01.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.912]                     {
[17:01:01.912]                       inherits <- base::inherits
[17:01:01.912]                       invokeRestart <- base::invokeRestart
[17:01:01.912]                       is.null <- base::is.null
[17:01:01.912]                       muffled <- FALSE
[17:01:01.912]                       if (inherits(cond, "message")) {
[17:01:01.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.912]                         if (muffled) 
[17:01:01.912]                           invokeRestart("muffleMessage")
[17:01:01.912]                       }
[17:01:01.912]                       else if (inherits(cond, "warning")) {
[17:01:01.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.912]                         if (muffled) 
[17:01:01.912]                           invokeRestart("muffleWarning")
[17:01:01.912]                       }
[17:01:01.912]                       else if (inherits(cond, "condition")) {
[17:01:01.912]                         if (!is.null(pattern)) {
[17:01:01.912]                           computeRestarts <- base::computeRestarts
[17:01:01.912]                           grepl <- base::grepl
[17:01:01.912]                           restarts <- computeRestarts(cond)
[17:01:01.912]                           for (restart in restarts) {
[17:01:01.912]                             name <- restart$name
[17:01:01.912]                             if (is.null(name)) 
[17:01:01.912]                               next
[17:01:01.912]                             if (!grepl(pattern, name)) 
[17:01:01.912]                               next
[17:01:01.912]                             invokeRestart(restart)
[17:01:01.912]                             muffled <- TRUE
[17:01:01.912]                             break
[17:01:01.912]                           }
[17:01:01.912]                         }
[17:01:01.912]                       }
[17:01:01.912]                       invisible(muffled)
[17:01:01.912]                     }
[17:01:01.912]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.912]                   }
[17:01:01.912]                 }
[17:01:01.912]                 else {
[17:01:01.912]                   if (TRUE) {
[17:01:01.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.912]                     {
[17:01:01.912]                       inherits <- base::inherits
[17:01:01.912]                       invokeRestart <- base::invokeRestart
[17:01:01.912]                       is.null <- base::is.null
[17:01:01.912]                       muffled <- FALSE
[17:01:01.912]                       if (inherits(cond, "message")) {
[17:01:01.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.912]                         if (muffled) 
[17:01:01.912]                           invokeRestart("muffleMessage")
[17:01:01.912]                       }
[17:01:01.912]                       else if (inherits(cond, "warning")) {
[17:01:01.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.912]                         if (muffled) 
[17:01:01.912]                           invokeRestart("muffleWarning")
[17:01:01.912]                       }
[17:01:01.912]                       else if (inherits(cond, "condition")) {
[17:01:01.912]                         if (!is.null(pattern)) {
[17:01:01.912]                           computeRestarts <- base::computeRestarts
[17:01:01.912]                           grepl <- base::grepl
[17:01:01.912]                           restarts <- computeRestarts(cond)
[17:01:01.912]                           for (restart in restarts) {
[17:01:01.912]                             name <- restart$name
[17:01:01.912]                             if (is.null(name)) 
[17:01:01.912]                               next
[17:01:01.912]                             if (!grepl(pattern, name)) 
[17:01:01.912]                               next
[17:01:01.912]                             invokeRestart(restart)
[17:01:01.912]                             muffled <- TRUE
[17:01:01.912]                             break
[17:01:01.912]                           }
[17:01:01.912]                         }
[17:01:01.912]                       }
[17:01:01.912]                       invisible(muffled)
[17:01:01.912]                     }
[17:01:01.912]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.912]                   }
[17:01:01.912]                 }
[17:01:01.912]             }
[17:01:01.912]         }))
[17:01:01.912]     }, error = function(ex) {
[17:01:01.912]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.912]                 ...future.rng), started = ...future.startTime, 
[17:01:01.912]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.912]             version = "1.8"), class = "FutureResult")
[17:01:01.912]     }, finally = {
[17:01:01.912]         if (!identical(...future.workdir, getwd())) 
[17:01:01.912]             setwd(...future.workdir)
[17:01:01.912]         {
[17:01:01.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.912]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.912]             }
[17:01:01.912]             base::options(...future.oldOptions)
[17:01:01.912]             if (.Platform$OS.type == "windows") {
[17:01:01.912]                 old_names <- names(...future.oldEnvVars)
[17:01:01.912]                 envs <- base::Sys.getenv()
[17:01:01.912]                 names <- names(envs)
[17:01:01.912]                 common <- intersect(names, old_names)
[17:01:01.912]                 added <- setdiff(names, old_names)
[17:01:01.912]                 removed <- setdiff(old_names, names)
[17:01:01.912]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.912]                   envs[common]]
[17:01:01.912]                 NAMES <- toupper(changed)
[17:01:01.912]                 args <- list()
[17:01:01.912]                 for (kk in seq_along(NAMES)) {
[17:01:01.912]                   name <- changed[[kk]]
[17:01:01.912]                   NAME <- NAMES[[kk]]
[17:01:01.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.912]                     next
[17:01:01.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.912]                 }
[17:01:01.912]                 NAMES <- toupper(added)
[17:01:01.912]                 for (kk in seq_along(NAMES)) {
[17:01:01.912]                   name <- added[[kk]]
[17:01:01.912]                   NAME <- NAMES[[kk]]
[17:01:01.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.912]                     next
[17:01:01.912]                   args[[name]] <- ""
[17:01:01.912]                 }
[17:01:01.912]                 NAMES <- toupper(removed)
[17:01:01.912]                 for (kk in seq_along(NAMES)) {
[17:01:01.912]                   name <- removed[[kk]]
[17:01:01.912]                   NAME <- NAMES[[kk]]
[17:01:01.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.912]                     next
[17:01:01.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.912]                 }
[17:01:01.912]                 if (length(args) > 0) 
[17:01:01.912]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.912]             }
[17:01:01.912]             else {
[17:01:01.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.912]             }
[17:01:01.912]             {
[17:01:01.912]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.912]                   0L) {
[17:01:01.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.912]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.912]                   base::options(opts)
[17:01:01.912]                 }
[17:01:01.912]                 {
[17:01:01.912]                   {
[17:01:01.912]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:01.912]                     NULL
[17:01:01.912]                   }
[17:01:01.912]                   options(future.plan = NULL)
[17:01:01.912]                   if (is.na(NA_character_)) 
[17:01:01.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.912]                     .init = FALSE)
[17:01:01.912]                 }
[17:01:01.912]             }
[17:01:01.912]         }
[17:01:01.912]     })
[17:01:01.912]     if (TRUE) {
[17:01:01.912]         base::sink(type = "output", split = FALSE)
[17:01:01.912]         if (TRUE) {
[17:01:01.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.912]         }
[17:01:01.912]         else {
[17:01:01.912]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.912]         }
[17:01:01.912]         base::close(...future.stdout)
[17:01:01.912]         ...future.stdout <- NULL
[17:01:01.912]     }
[17:01:01.912]     ...future.result$conditions <- ...future.conditions
[17:01:01.912]     ...future.result$finished <- base::Sys.time()
[17:01:01.912]     ...future.result
[17:01:01.912] }
[17:01:01.914] assign_globals() ...
[17:01:01.914] List of 11
[17:01:01.914]  $ ...future.FUN            :function (x, ...)  
[17:01:01.914]  $ x_FUN                    :function (x)  
[17:01:01.914]  $ times                    : int 1
[17:01:01.914]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.914]  $ stop_if_not              :function (...)  
[17:01:01.914]  $ dim                      : NULL
[17:01:01.914]  $ valid_types              : chr "character"
[17:01:01.914]  $ future.call.arguments    : list()
[17:01:01.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.914]  $ ...future.elements_ii    :List of 1
[17:01:01.914]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:01:01.914]  $ ...future.seeds_ii       : NULL
[17:01:01.914]  $ ...future.globals.maxSize: NULL
[17:01:01.914]  - attr(*, "where")=List of 11
[17:01:01.914]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.914]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.914]  - attr(*, "resolved")= logi FALSE
[17:01:01.914]  - attr(*, "total_size")= num 94208
[17:01:01.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.914]  - attr(*, "already-done")= logi TRUE
[17:01:01.924] - copied ‘...future.FUN’ to environment
[17:01:01.924] - copied ‘x_FUN’ to environment
[17:01:01.924] - copied ‘times’ to environment
[17:01:01.925] - copied ‘stopf’ to environment
[17:01:01.925] - copied ‘stop_if_not’ to environment
[17:01:01.925] - copied ‘dim’ to environment
[17:01:01.925] - copied ‘valid_types’ to environment
[17:01:01.925] - copied ‘future.call.arguments’ to environment
[17:01:01.925] - copied ‘...future.elements_ii’ to environment
[17:01:01.925] - copied ‘...future.seeds_ii’ to environment
[17:01:01.925] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.925] assign_globals() ... done
[17:01:01.926] requestCore(): workers = 2
[17:01:01.929] MulticoreFuture started
[17:01:01.929] - Launch lazy future ... done
[17:01:01.929] run() for ‘MulticoreFuture’ ... done
[17:01:01.930] Created future:
[17:01:01.930] plan(): Setting new future strategy stack:
[17:01:01.930] List of future strategies:
[17:01:01.930] 1. sequential:
[17:01:01.930]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.930]    - tweaked: FALSE
[17:01:01.930]    - call: NULL
[17:01:01.931] plan(): nbrOfWorkers() = 1
[17:01:01.933] plan(): Setting new future strategy stack:
[17:01:01.933] List of future strategies:
[17:01:01.933] 1. multicore:
[17:01:01.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:01.933]    - tweaked: FALSE
[17:01:01.933]    - call: plan(strategy)
[17:01:01.938] plan(): nbrOfWorkers() = 2
[17:01:01.930] MulticoreFuture:
[17:01:01.930] Label: ‘future_vapply-1’
[17:01:01.930] Expression:
[17:01:01.930] {
[17:01:01.930]     do.call(function(...) {
[17:01:01.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.930]             on.exit(options(oopts), add = TRUE)
[17:01:01.930]         }
[17:01:01.930]         {
[17:01:01.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.930]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.930]             })
[17:01:01.930]         }
[17:01:01.930]     }, args = future.call.arguments)
[17:01:01.930] }
[17:01:01.930] Lazy evaluation: FALSE
[17:01:01.930] Asynchronous evaluation: TRUE
[17:01:01.930] Local evaluation: TRUE
[17:01:01.930] Environment: R_GlobalEnv
[17:01:01.930] Capture standard output: TRUE
[17:01:01.930] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.930] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.930] Packages: 1 packages (‘future.apply’)
[17:01:01.930] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.930] Resolved: TRUE
[17:01:01.930] Value: <not collected>
[17:01:01.930] Conditions captured: <none>
[17:01:01.930] Early signaling: FALSE
[17:01:01.930] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.930] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:01.940] Chunk #1 of 2 ... DONE
[17:01:01.940] Chunk #2 of 2 ...
[17:01:01.940]  - Finding globals in 'X' for chunk #2 ...
[17:01:01.940] getGlobalsAndPackages() ...
[17:01:01.940] Searching for globals...
[17:01:01.941] 
[17:01:01.941] Searching for globals ... DONE
[17:01:01.941] - globals: [0] <none>
[17:01:01.941] getGlobalsAndPackages() ... DONE
[17:01:01.941]    + additional globals found: [n=0] 
[17:01:01.941]    + additional namespaces needed: [n=0] 
[17:01:01.941]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:01.942]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:01.942]  - seeds: <none>
[17:01:01.942]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.942] getGlobalsAndPackages() ...
[17:01:01.942] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.942] Resolving globals: FALSE
[17:01:01.943] Tweak future expression to call with '...' arguments ...
[17:01:01.943] {
[17:01:01.943]     do.call(function(...) {
[17:01:01.943]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.943]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.943]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.943]             on.exit(options(oopts), add = TRUE)
[17:01:01.943]         }
[17:01:01.943]         {
[17:01:01.943]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.943]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.943]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.943]             })
[17:01:01.943]         }
[17:01:01.943]     }, args = future.call.arguments)
[17:01:01.943] }
[17:01:01.943] Tweak future expression to call with '...' arguments ... DONE
[17:01:01.944] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:01.944] - packages: [1] ‘future.apply’
[17:01:01.944] getGlobalsAndPackages() ... DONE
[17:01:01.945] run() for ‘Future’ ...
[17:01:01.945] - state: ‘created’
[17:01:01.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:01.950] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:01.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:01.950]   - Field: ‘label’
[17:01:01.950]   - Field: ‘local’
[17:01:01.951]   - Field: ‘owner’
[17:01:01.951]   - Field: ‘envir’
[17:01:01.951]   - Field: ‘workers’
[17:01:01.951]   - Field: ‘packages’
[17:01:01.951]   - Field: ‘gc’
[17:01:01.951]   - Field: ‘job’
[17:01:01.951]   - Field: ‘conditions’
[17:01:01.952]   - Field: ‘expr’
[17:01:01.952]   - Field: ‘uuid’
[17:01:01.952]   - Field: ‘seed’
[17:01:01.952]   - Field: ‘version’
[17:01:01.952]   - Field: ‘result’
[17:01:01.952]   - Field: ‘asynchronous’
[17:01:01.952]   - Field: ‘calls’
[17:01:01.953]   - Field: ‘globals’
[17:01:01.953]   - Field: ‘stdout’
[17:01:01.953]   - Field: ‘earlySignal’
[17:01:01.953]   - Field: ‘lazy’
[17:01:01.953]   - Field: ‘state’
[17:01:01.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:01.953] - Launch lazy future ...
[17:01:01.954] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:01.954] Packages needed by future strategies (n = 0): <none>
[17:01:01.955] {
[17:01:01.955]     {
[17:01:01.955]         {
[17:01:01.955]             ...future.startTime <- base::Sys.time()
[17:01:01.955]             {
[17:01:01.955]                 {
[17:01:01.955]                   {
[17:01:01.955]                     {
[17:01:01.955]                       {
[17:01:01.955]                         base::local({
[17:01:01.955]                           has_future <- base::requireNamespace("future", 
[17:01:01.955]                             quietly = TRUE)
[17:01:01.955]                           if (has_future) {
[17:01:01.955]                             ns <- base::getNamespace("future")
[17:01:01.955]                             version <- ns[[".package"]][["version"]]
[17:01:01.955]                             if (is.null(version)) 
[17:01:01.955]                               version <- utils::packageVersion("future")
[17:01:01.955]                           }
[17:01:01.955]                           else {
[17:01:01.955]                             version <- NULL
[17:01:01.955]                           }
[17:01:01.955]                           if (!has_future || version < "1.8.0") {
[17:01:01.955]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:01.955]                               "", base::R.version$version.string), 
[17:01:01.955]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:01.955]                                 base::R.version$platform, 8 * 
[17:01:01.955]                                   base::.Machine$sizeof.pointer), 
[17:01:01.955]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:01.955]                                 "release", "version")], collapse = " "), 
[17:01:01.955]                               hostname = base::Sys.info()[["nodename"]])
[17:01:01.955]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:01.955]                               info)
[17:01:01.955]                             info <- base::paste(info, collapse = "; ")
[17:01:01.955]                             if (!has_future) {
[17:01:01.955]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:01.955]                                 info)
[17:01:01.955]                             }
[17:01:01.955]                             else {
[17:01:01.955]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:01.955]                                 info, version)
[17:01:01.955]                             }
[17:01:01.955]                             base::stop(msg)
[17:01:01.955]                           }
[17:01:01.955]                         })
[17:01:01.955]                       }
[17:01:01.955]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:01.955]                       base::options(mc.cores = 1L)
[17:01:01.955]                     }
[17:01:01.955]                     base::local({
[17:01:01.955]                       for (pkg in "future.apply") {
[17:01:01.955]                         base::loadNamespace(pkg)
[17:01:01.955]                         base::library(pkg, character.only = TRUE)
[17:01:01.955]                       }
[17:01:01.955]                     })
[17:01:01.955]                   }
[17:01:01.955]                   ...future.strategy.old <- future::plan("list")
[17:01:01.955]                   options(future.plan = NULL)
[17:01:01.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:01.955]                 }
[17:01:01.955]                 ...future.workdir <- getwd()
[17:01:01.955]             }
[17:01:01.955]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:01.955]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:01.955]         }
[17:01:01.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:01.955]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:01.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:01.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:01.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:01.955]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:01.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:01.955]             base::names(...future.oldOptions))
[17:01:01.955]     }
[17:01:01.955]     if (FALSE) {
[17:01:01.955]     }
[17:01:01.955]     else {
[17:01:01.955]         if (TRUE) {
[17:01:01.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:01.955]                 open = "w")
[17:01:01.955]         }
[17:01:01.955]         else {
[17:01:01.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:01.955]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:01.955]         }
[17:01:01.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:01.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:01.955]             base::sink(type = "output", split = FALSE)
[17:01:01.955]             base::close(...future.stdout)
[17:01:01.955]         }, add = TRUE)
[17:01:01.955]     }
[17:01:01.955]     ...future.frame <- base::sys.nframe()
[17:01:01.955]     ...future.conditions <- base::list()
[17:01:01.955]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:01.955]     if (FALSE) {
[17:01:01.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:01.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:01.955]     }
[17:01:01.955]     ...future.result <- base::tryCatch({
[17:01:01.955]         base::withCallingHandlers({
[17:01:01.955]             ...future.value <- base::withVisible(base::local({
[17:01:01.955]                 withCallingHandlers({
[17:01:01.955]                   {
[17:01:01.955]                     do.call(function(...) {
[17:01:01.955]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.955]                       if (!identical(...future.globals.maxSize.org, 
[17:01:01.955]                         ...future.globals.maxSize)) {
[17:01:01.955]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.955]                         on.exit(options(oopts), add = TRUE)
[17:01:01.955]                       }
[17:01:01.955]                       {
[17:01:01.955]                         lapply(seq_along(...future.elements_ii), 
[17:01:01.955]                           FUN = function(jj) {
[17:01:01.955]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.955]                             ...future.FUN(...future.X_jj, ...)
[17:01:01.955]                           })
[17:01:01.955]                       }
[17:01:01.955]                     }, args = future.call.arguments)
[17:01:01.955]                   }
[17:01:01.955]                 }, immediateCondition = function(cond) {
[17:01:01.955]                   save_rds <- function (object, pathname, ...) 
[17:01:01.955]                   {
[17:01:01.955]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:01.955]                     if (file_test("-f", pathname_tmp)) {
[17:01:01.955]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.955]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:01.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.955]                         fi_tmp[["mtime"]])
[17:01:01.955]                     }
[17:01:01.955]                     tryCatch({
[17:01:01.955]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:01.955]                     }, error = function(ex) {
[17:01:01.955]                       msg <- conditionMessage(ex)
[17:01:01.955]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.955]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:01.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.955]                         fi_tmp[["mtime"]], msg)
[17:01:01.955]                       ex$message <- msg
[17:01:01.955]                       stop(ex)
[17:01:01.955]                     })
[17:01:01.955]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:01.955]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:01.955]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:01.955]                       fi_tmp <- file.info(pathname_tmp)
[17:01:01.955]                       fi <- file.info(pathname)
[17:01:01.955]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:01.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:01.955]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:01.955]                         fi[["size"]], fi[["mtime"]])
[17:01:01.955]                       stop(msg)
[17:01:01.955]                     }
[17:01:01.955]                     invisible(pathname)
[17:01:01.955]                   }
[17:01:01.955]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:01.955]                     rootPath = tempdir()) 
[17:01:01.955]                   {
[17:01:01.955]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:01.955]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:01.955]                       tmpdir = path, fileext = ".rds")
[17:01:01.955]                     save_rds(obj, file)
[17:01:01.955]                   }
[17:01:01.955]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:01.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.955]                   {
[17:01:01.955]                     inherits <- base::inherits
[17:01:01.955]                     invokeRestart <- base::invokeRestart
[17:01:01.955]                     is.null <- base::is.null
[17:01:01.955]                     muffled <- FALSE
[17:01:01.955]                     if (inherits(cond, "message")) {
[17:01:01.955]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:01.955]                       if (muffled) 
[17:01:01.955]                         invokeRestart("muffleMessage")
[17:01:01.955]                     }
[17:01:01.955]                     else if (inherits(cond, "warning")) {
[17:01:01.955]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:01.955]                       if (muffled) 
[17:01:01.955]                         invokeRestart("muffleWarning")
[17:01:01.955]                     }
[17:01:01.955]                     else if (inherits(cond, "condition")) {
[17:01:01.955]                       if (!is.null(pattern)) {
[17:01:01.955]                         computeRestarts <- base::computeRestarts
[17:01:01.955]                         grepl <- base::grepl
[17:01:01.955]                         restarts <- computeRestarts(cond)
[17:01:01.955]                         for (restart in restarts) {
[17:01:01.955]                           name <- restart$name
[17:01:01.955]                           if (is.null(name)) 
[17:01:01.955]                             next
[17:01:01.955]                           if (!grepl(pattern, name)) 
[17:01:01.955]                             next
[17:01:01.955]                           invokeRestart(restart)
[17:01:01.955]                           muffled <- TRUE
[17:01:01.955]                           break
[17:01:01.955]                         }
[17:01:01.955]                       }
[17:01:01.955]                     }
[17:01:01.955]                     invisible(muffled)
[17:01:01.955]                   }
[17:01:01.955]                   muffleCondition(cond)
[17:01:01.955]                 })
[17:01:01.955]             }))
[17:01:01.955]             future::FutureResult(value = ...future.value$value, 
[17:01:01.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.955]                   ...future.rng), globalenv = if (FALSE) 
[17:01:01.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:01.955]                     ...future.globalenv.names))
[17:01:01.955]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:01.955]         }, condition = base::local({
[17:01:01.955]             c <- base::c
[17:01:01.955]             inherits <- base::inherits
[17:01:01.955]             invokeRestart <- base::invokeRestart
[17:01:01.955]             length <- base::length
[17:01:01.955]             list <- base::list
[17:01:01.955]             seq.int <- base::seq.int
[17:01:01.955]             signalCondition <- base::signalCondition
[17:01:01.955]             sys.calls <- base::sys.calls
[17:01:01.955]             `[[` <- base::`[[`
[17:01:01.955]             `+` <- base::`+`
[17:01:01.955]             `<<-` <- base::`<<-`
[17:01:01.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:01.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:01.955]                   3L)]
[17:01:01.955]             }
[17:01:01.955]             function(cond) {
[17:01:01.955]                 is_error <- inherits(cond, "error")
[17:01:01.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:01.955]                   NULL)
[17:01:01.955]                 if (is_error) {
[17:01:01.955]                   sessionInformation <- function() {
[17:01:01.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:01.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:01.955]                       search = base::search(), system = base::Sys.info())
[17:01:01.955]                   }
[17:01:01.955]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:01.955]                     cond$call), session = sessionInformation(), 
[17:01:01.955]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:01.955]                   signalCondition(cond)
[17:01:01.955]                 }
[17:01:01.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:01.955]                 "immediateCondition"))) {
[17:01:01.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:01.955]                   ...future.conditions[[length(...future.conditions) + 
[17:01:01.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:01.955]                   if (TRUE && !signal) {
[17:01:01.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.955]                     {
[17:01:01.955]                       inherits <- base::inherits
[17:01:01.955]                       invokeRestart <- base::invokeRestart
[17:01:01.955]                       is.null <- base::is.null
[17:01:01.955]                       muffled <- FALSE
[17:01:01.955]                       if (inherits(cond, "message")) {
[17:01:01.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.955]                         if (muffled) 
[17:01:01.955]                           invokeRestart("muffleMessage")
[17:01:01.955]                       }
[17:01:01.955]                       else if (inherits(cond, "warning")) {
[17:01:01.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.955]                         if (muffled) 
[17:01:01.955]                           invokeRestart("muffleWarning")
[17:01:01.955]                       }
[17:01:01.955]                       else if (inherits(cond, "condition")) {
[17:01:01.955]                         if (!is.null(pattern)) {
[17:01:01.955]                           computeRestarts <- base::computeRestarts
[17:01:01.955]                           grepl <- base::grepl
[17:01:01.955]                           restarts <- computeRestarts(cond)
[17:01:01.955]                           for (restart in restarts) {
[17:01:01.955]                             name <- restart$name
[17:01:01.955]                             if (is.null(name)) 
[17:01:01.955]                               next
[17:01:01.955]                             if (!grepl(pattern, name)) 
[17:01:01.955]                               next
[17:01:01.955]                             invokeRestart(restart)
[17:01:01.955]                             muffled <- TRUE
[17:01:01.955]                             break
[17:01:01.955]                           }
[17:01:01.955]                         }
[17:01:01.955]                       }
[17:01:01.955]                       invisible(muffled)
[17:01:01.955]                     }
[17:01:01.955]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.955]                   }
[17:01:01.955]                 }
[17:01:01.955]                 else {
[17:01:01.955]                   if (TRUE) {
[17:01:01.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:01.955]                     {
[17:01:01.955]                       inherits <- base::inherits
[17:01:01.955]                       invokeRestart <- base::invokeRestart
[17:01:01.955]                       is.null <- base::is.null
[17:01:01.955]                       muffled <- FALSE
[17:01:01.955]                       if (inherits(cond, "message")) {
[17:01:01.955]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:01.955]                         if (muffled) 
[17:01:01.955]                           invokeRestart("muffleMessage")
[17:01:01.955]                       }
[17:01:01.955]                       else if (inherits(cond, "warning")) {
[17:01:01.955]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:01.955]                         if (muffled) 
[17:01:01.955]                           invokeRestart("muffleWarning")
[17:01:01.955]                       }
[17:01:01.955]                       else if (inherits(cond, "condition")) {
[17:01:01.955]                         if (!is.null(pattern)) {
[17:01:01.955]                           computeRestarts <- base::computeRestarts
[17:01:01.955]                           grepl <- base::grepl
[17:01:01.955]                           restarts <- computeRestarts(cond)
[17:01:01.955]                           for (restart in restarts) {
[17:01:01.955]                             name <- restart$name
[17:01:01.955]                             if (is.null(name)) 
[17:01:01.955]                               next
[17:01:01.955]                             if (!grepl(pattern, name)) 
[17:01:01.955]                               next
[17:01:01.955]                             invokeRestart(restart)
[17:01:01.955]                             muffled <- TRUE
[17:01:01.955]                             break
[17:01:01.955]                           }
[17:01:01.955]                         }
[17:01:01.955]                       }
[17:01:01.955]                       invisible(muffled)
[17:01:01.955]                     }
[17:01:01.955]                     muffleCondition(cond, pattern = "^muffle")
[17:01:01.955]                   }
[17:01:01.955]                 }
[17:01:01.955]             }
[17:01:01.955]         }))
[17:01:01.955]     }, error = function(ex) {
[17:01:01.955]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:01.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:01.955]                 ...future.rng), started = ...future.startTime, 
[17:01:01.955]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:01.955]             version = "1.8"), class = "FutureResult")
[17:01:01.955]     }, finally = {
[17:01:01.955]         if (!identical(...future.workdir, getwd())) 
[17:01:01.955]             setwd(...future.workdir)
[17:01:01.955]         {
[17:01:01.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:01.955]                 ...future.oldOptions$nwarnings <- NULL
[17:01:01.955]             }
[17:01:01.955]             base::options(...future.oldOptions)
[17:01:01.955]             if (.Platform$OS.type == "windows") {
[17:01:01.955]                 old_names <- names(...future.oldEnvVars)
[17:01:01.955]                 envs <- base::Sys.getenv()
[17:01:01.955]                 names <- names(envs)
[17:01:01.955]                 common <- intersect(names, old_names)
[17:01:01.955]                 added <- setdiff(names, old_names)
[17:01:01.955]                 removed <- setdiff(old_names, names)
[17:01:01.955]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:01.955]                   envs[common]]
[17:01:01.955]                 NAMES <- toupper(changed)
[17:01:01.955]                 args <- list()
[17:01:01.955]                 for (kk in seq_along(NAMES)) {
[17:01:01.955]                   name <- changed[[kk]]
[17:01:01.955]                   NAME <- NAMES[[kk]]
[17:01:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.955]                     next
[17:01:01.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.955]                 }
[17:01:01.955]                 NAMES <- toupper(added)
[17:01:01.955]                 for (kk in seq_along(NAMES)) {
[17:01:01.955]                   name <- added[[kk]]
[17:01:01.955]                   NAME <- NAMES[[kk]]
[17:01:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.955]                     next
[17:01:01.955]                   args[[name]] <- ""
[17:01:01.955]                 }
[17:01:01.955]                 NAMES <- toupper(removed)
[17:01:01.955]                 for (kk in seq_along(NAMES)) {
[17:01:01.955]                   name <- removed[[kk]]
[17:01:01.955]                   NAME <- NAMES[[kk]]
[17:01:01.955]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:01.955]                     next
[17:01:01.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:01.955]                 }
[17:01:01.955]                 if (length(args) > 0) 
[17:01:01.955]                   base::do.call(base::Sys.setenv, args = args)
[17:01:01.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:01.955]             }
[17:01:01.955]             else {
[17:01:01.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:01.955]             }
[17:01:01.955]             {
[17:01:01.955]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:01.955]                   0L) {
[17:01:01.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:01.955]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:01.955]                   base::options(opts)
[17:01:01.955]                 }
[17:01:01.955]                 {
[17:01:01.955]                   {
[17:01:01.955]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:01.955]                     NULL
[17:01:01.955]                   }
[17:01:01.955]                   options(future.plan = NULL)
[17:01:01.955]                   if (is.na(NA_character_)) 
[17:01:01.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:01.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:01.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:01.955]                     .init = FALSE)
[17:01:01.955]                 }
[17:01:01.955]             }
[17:01:01.955]         }
[17:01:01.955]     })
[17:01:01.955]     if (TRUE) {
[17:01:01.955]         base::sink(type = "output", split = FALSE)
[17:01:01.955]         if (TRUE) {
[17:01:01.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:01.955]         }
[17:01:01.955]         else {
[17:01:01.955]             ...future.result["stdout"] <- base::list(NULL)
[17:01:01.955]         }
[17:01:01.955]         base::close(...future.stdout)
[17:01:01.955]         ...future.stdout <- NULL
[17:01:01.955]     }
[17:01:01.955]     ...future.result$conditions <- ...future.conditions
[17:01:01.955]     ...future.result$finished <- base::Sys.time()
[17:01:01.955]     ...future.result
[17:01:01.955] }
[17:01:01.958] assign_globals() ...
[17:01:01.959] List of 11
[17:01:01.959]  $ ...future.FUN            :function (x, ...)  
[17:01:01.959]  $ x_FUN                    :function (x)  
[17:01:01.959]  $ times                    : int 1
[17:01:01.959]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:01.959]  $ stop_if_not              :function (...)  
[17:01:01.959]  $ dim                      : NULL
[17:01:01.959]  $ valid_types              : chr "character"
[17:01:01.959]  $ future.call.arguments    : list()
[17:01:01.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:01.959]  $ ...future.elements_ii    :List of 1
[17:01:01.959]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:01:01.959]  $ ...future.seeds_ii       : NULL
[17:01:01.959]  $ ...future.globals.maxSize: NULL
[17:01:01.959]  - attr(*, "where")=List of 11
[17:01:01.959]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:01.959]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:01.959]  - attr(*, "resolved")= logi FALSE
[17:01:01.959]  - attr(*, "total_size")= num 94208
[17:01:01.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:01.959]  - attr(*, "already-done")= logi TRUE
[17:01:01.974] - copied ‘...future.FUN’ to environment
[17:01:01.974] - copied ‘x_FUN’ to environment
[17:01:01.974] - copied ‘times’ to environment
[17:01:01.974] - copied ‘stopf’ to environment
[17:01:01.975] - copied ‘stop_if_not’ to environment
[17:01:01.975] - copied ‘dim’ to environment
[17:01:01.975] - copied ‘valid_types’ to environment
[17:01:01.975] - copied ‘future.call.arguments’ to environment
[17:01:01.975] - copied ‘...future.elements_ii’ to environment
[17:01:01.975] - copied ‘...future.seeds_ii’ to environment
[17:01:01.975] - copied ‘...future.globals.maxSize’ to environment
[17:01:01.976] assign_globals() ... done
[17:01:01.976] requestCore(): workers = 2
[17:01:01.981] MulticoreFuture started
[17:01:01.981] - Launch lazy future ... done
[17:01:01.981] run() for ‘MulticoreFuture’ ... done
[17:01:01.982] Created future:
[17:01:01.982] plan(): Setting new future strategy stack:
[17:01:01.982] List of future strategies:
[17:01:01.982] 1. sequential:
[17:01:01.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:01.982]    - tweaked: FALSE
[17:01:01.982]    - call: NULL
[17:01:01.983] plan(): nbrOfWorkers() = 1
[17:01:01.985] plan(): Setting new future strategy stack:
[17:01:01.986] List of future strategies:
[17:01:01.986] 1. multicore:
[17:01:01.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:01.986]    - tweaked: FALSE
[17:01:01.986]    - call: plan(strategy)
[17:01:01.991] plan(): nbrOfWorkers() = 2
[17:01:01.982] MulticoreFuture:
[17:01:01.982] Label: ‘future_vapply-2’
[17:01:01.982] Expression:
[17:01:01.982] {
[17:01:01.982]     do.call(function(...) {
[17:01:01.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:01.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:01.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:01.982]             on.exit(options(oopts), add = TRUE)
[17:01:01.982]         }
[17:01:01.982]         {
[17:01:01.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:01.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:01.982]                 ...future.FUN(...future.X_jj, ...)
[17:01:01.982]             })
[17:01:01.982]         }
[17:01:01.982]     }, args = future.call.arguments)
[17:01:01.982] }
[17:01:01.982] Lazy evaluation: FALSE
[17:01:01.982] Asynchronous evaluation: TRUE
[17:01:01.982] Local evaluation: TRUE
[17:01:01.982] Environment: R_GlobalEnv
[17:01:01.982] Capture standard output: TRUE
[17:01:01.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:01.982] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:01.982] Packages: 1 packages (‘future.apply’)
[17:01:01.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:01.982] Resolved: TRUE
[17:01:01.982] Value: <not collected>
[17:01:01.982] Conditions captured: <none>
[17:01:01.982] Early signaling: FALSE
[17:01:01.982] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:01.982] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:01.992] Chunk #2 of 2 ... DONE
[17:01:01.992] Launching 2 futures (chunks) ... DONE
[17:01:01.992] Resolving 2 futures (chunks) ...
[17:01:01.992] resolve() on list ...
[17:01:01.992]  recursive: 0
[17:01:01.992]  length: 2
[17:01:01.992] 
[17:01:01.993] Future #1
[17:01:01.993] result() for MulticoreFuture ...
[17:01:01.995] result() for MulticoreFuture ...
[17:01:01.995] result() for MulticoreFuture ... done
[17:01:01.996] result() for MulticoreFuture ... done
[17:01:01.996] result() for MulticoreFuture ...
[17:01:01.996] result() for MulticoreFuture ... done
[17:01:01.996] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:01.996] - nx: 2
[17:01:01.996] - relay: TRUE
[17:01:01.997] - stdout: TRUE
[17:01:01.997] - signal: TRUE
[17:01:01.997] - resignal: FALSE
[17:01:01.997] - force: TRUE
[17:01:01.997] - relayed: [n=2] FALSE, FALSE
[17:01:01.997] - queued futures: [n=2] FALSE, FALSE
[17:01:01.997]  - until=1
[17:01:01.997]  - relaying element #1
[17:01:01.998] result() for MulticoreFuture ...
[17:01:01.998] result() for MulticoreFuture ... done
[17:01:01.998] result() for MulticoreFuture ...
[17:01:01.998] result() for MulticoreFuture ... done
[17:01:01.998] result() for MulticoreFuture ...
[17:01:01.998] result() for MulticoreFuture ... done
[17:01:01.999] result() for MulticoreFuture ...
[17:01:01.999] result() for MulticoreFuture ... done
[17:01:01.999] - relayed: [n=2] TRUE, FALSE
[17:01:01.999] - queued futures: [n=2] TRUE, FALSE
[17:01:01.999] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:01.999]  length: 1 (resolved future 1)
[17:01:02.000] Future #2
[17:01:02.000] result() for MulticoreFuture ...
[17:01:02.000] result() for MulticoreFuture ...
[17:01:02.001] result() for MulticoreFuture ... done
[17:01:02.001] result() for MulticoreFuture ... done
[17:01:02.001] result() for MulticoreFuture ...
[17:01:02.001] result() for MulticoreFuture ... done
[17:01:02.001] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.002] - nx: 2
[17:01:02.002] - relay: TRUE
[17:01:02.002] - stdout: TRUE
[17:01:02.002] - signal: TRUE
[17:01:02.002] - resignal: FALSE
[17:01:02.002] - force: TRUE
[17:01:02.003] - relayed: [n=2] TRUE, FALSE
[17:01:02.003] - queued futures: [n=2] TRUE, FALSE
[17:01:02.003]  - until=2
[17:01:02.003]  - relaying element #2
[17:01:02.003] result() for MulticoreFuture ...
[17:01:02.003] result() for MulticoreFuture ... done
[17:01:02.004] result() for MulticoreFuture ...
[17:01:02.004] result() for MulticoreFuture ... done
[17:01:02.004] result() for MulticoreFuture ...
[17:01:02.004] result() for MulticoreFuture ... done
[17:01:02.004] result() for MulticoreFuture ...
[17:01:02.004] result() for MulticoreFuture ... done
[17:01:02.004] - relayed: [n=2] TRUE, TRUE
[17:01:02.004] - queued futures: [n=2] TRUE, TRUE
[17:01:02.004] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.005]  length: 0 (resolved future 2)
[17:01:02.005] Relaying remaining futures
[17:01:02.005] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.005] - nx: 2
[17:01:02.005] - relay: TRUE
[17:01:02.005] - stdout: TRUE
[17:01:02.005] - signal: TRUE
[17:01:02.005] - resignal: FALSE
[17:01:02.005] - force: TRUE
[17:01:02.005] - relayed: [n=2] TRUE, TRUE
[17:01:02.006] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.006] - relayed: [n=2] TRUE, TRUE
[17:01:02.006] - queued futures: [n=2] TRUE, TRUE
[17:01:02.006] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.006] resolve() on list ... DONE
[17:01:02.006] result() for MulticoreFuture ...
[17:01:02.006] result() for MulticoreFuture ... done
[17:01:02.006] result() for MulticoreFuture ...
[17:01:02.007] result() for MulticoreFuture ... done
[17:01:02.007] result() for MulticoreFuture ...
[17:01:02.007] result() for MulticoreFuture ... done
[17:01:02.007] result() for MulticoreFuture ...
[17:01:02.007] result() for MulticoreFuture ... done
[17:01:02.007]  - Number of value chunks collected: 2
[17:01:02.007] Resolving 2 futures (chunks) ... DONE
[17:01:02.007] Reducing values from 2 chunks ...
[17:01:02.007]  - Number of values collected after concatenation: 2
[17:01:02.008]  - Number of values expected: 2
[17:01:02.014] Reducing values from 2 chunks ... DONE
[17:01:02.014] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:01:02.015] future_lapply() ...
[17:01:02.021] Number of chunks: 2
[17:01:02.022] getGlobalsAndPackagesXApply() ...
[17:01:02.022]  - future.globals: TRUE
[17:01:02.022] getGlobalsAndPackages() ...
[17:01:02.022] Searching for globals...
[17:01:02.026] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:01:02.026] Searching for globals ... DONE
[17:01:02.026] Resolving globals: FALSE
[17:01:02.027] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:01:02.028] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.028] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.028] - packages: [1] ‘future.apply’
[17:01:02.028] getGlobalsAndPackages() ... DONE
[17:01:02.028]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.028]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.028] Finding globals ... DONE
[17:01:02.028]  - use_args: TRUE
[17:01:02.028]  - Getting '...' globals ...
[17:01:02.029] resolve() on list ...
[17:01:02.029]  recursive: 0
[17:01:02.029]  length: 1
[17:01:02.029]  elements: ‘...’
[17:01:02.029]  length: 0 (resolved future 1)
[17:01:02.029] resolve() on list ... DONE
[17:01:02.029]    - '...' content: [n=0] 
[17:01:02.029] List of 1
[17:01:02.029]  $ ...: list()
[17:01:02.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.029]  - attr(*, "where")=List of 1
[17:01:02.029]   ..$ ...:<environment: 0x55aadb5d7dd8> 
[17:01:02.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.029]  - attr(*, "resolved")= logi TRUE
[17:01:02.029]  - attr(*, "total_size")= num NA
[17:01:02.032]  - Getting '...' globals ... DONE
[17:01:02.032] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.032] List of 8
[17:01:02.032]  $ ...future.FUN:function (x, ...)  
[17:01:02.032]  $ x_FUN        :function (x)  
[17:01:02.032]  $ times        : int 0
[17:01:02.032]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.032]  $ stop_if_not  :function (...)  
[17:01:02.032]  $ dim          : NULL
[17:01:02.032]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.032]  $ ...          : list()
[17:01:02.032]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.032]  - attr(*, "where")=List of 8
[17:01:02.032]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.032]   ..$ ...          :<environment: 0x55aadb5d7dd8> 
[17:01:02.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.032]  - attr(*, "resolved")= logi FALSE
[17:01:02.032]  - attr(*, "total_size")= num 95472
[17:01:02.038] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.038] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.038] Number of futures (= number of chunks): 2
[17:01:02.038] Launching 2 futures (chunks) ...
[17:01:02.038] Chunk #1 of 2 ...
[17:01:02.038]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.038] getGlobalsAndPackages() ...
[17:01:02.038] Searching for globals...
[17:01:02.040] 
[17:01:02.040] Searching for globals ... DONE
[17:01:02.041] - globals: [0] <none>
[17:01:02.041] getGlobalsAndPackages() ... DONE
[17:01:02.041]    + additional globals found: [n=0] 
[17:01:02.041]    + additional namespaces needed: [n=0] 
[17:01:02.041]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.041]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.041]  - seeds: <none>
[17:01:02.041]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.042] getGlobalsAndPackages() ...
[17:01:02.042] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.042] Resolving globals: FALSE
[17:01:02.042] Tweak future expression to call with '...' arguments ...
[17:01:02.042] {
[17:01:02.042]     do.call(function(...) {
[17:01:02.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.042]             on.exit(options(oopts), add = TRUE)
[17:01:02.042]         }
[17:01:02.042]         {
[17:01:02.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.042]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.042]             })
[17:01:02.042]         }
[17:01:02.042]     }, args = future.call.arguments)
[17:01:02.042] }
[17:01:02.042] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.043] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.043] - packages: [1] ‘future.apply’
[17:01:02.043] getGlobalsAndPackages() ... DONE
[17:01:02.044] run() for ‘Future’ ...
[17:01:02.044] - state: ‘created’
[17:01:02.044] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.048] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.048]   - Field: ‘label’
[17:01:02.048]   - Field: ‘local’
[17:01:02.048]   - Field: ‘owner’
[17:01:02.048]   - Field: ‘envir’
[17:01:02.048]   - Field: ‘workers’
[17:01:02.048]   - Field: ‘packages’
[17:01:02.049]   - Field: ‘gc’
[17:01:02.049]   - Field: ‘job’
[17:01:02.049]   - Field: ‘conditions’
[17:01:02.049]   - Field: ‘expr’
[17:01:02.049]   - Field: ‘uuid’
[17:01:02.049]   - Field: ‘seed’
[17:01:02.049]   - Field: ‘version’
[17:01:02.049]   - Field: ‘result’
[17:01:02.049]   - Field: ‘asynchronous’
[17:01:02.049]   - Field: ‘calls’
[17:01:02.049]   - Field: ‘globals’
[17:01:02.050]   - Field: ‘stdout’
[17:01:02.050]   - Field: ‘earlySignal’
[17:01:02.050]   - Field: ‘lazy’
[17:01:02.050]   - Field: ‘state’
[17:01:02.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.050] - Launch lazy future ...
[17:01:02.050] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.050] Packages needed by future strategies (n = 0): <none>
[17:01:02.051] {
[17:01:02.051]     {
[17:01:02.051]         {
[17:01:02.051]             ...future.startTime <- base::Sys.time()
[17:01:02.051]             {
[17:01:02.051]                 {
[17:01:02.051]                   {
[17:01:02.051]                     {
[17:01:02.051]                       {
[17:01:02.051]                         base::local({
[17:01:02.051]                           has_future <- base::requireNamespace("future", 
[17:01:02.051]                             quietly = TRUE)
[17:01:02.051]                           if (has_future) {
[17:01:02.051]                             ns <- base::getNamespace("future")
[17:01:02.051]                             version <- ns[[".package"]][["version"]]
[17:01:02.051]                             if (is.null(version)) 
[17:01:02.051]                               version <- utils::packageVersion("future")
[17:01:02.051]                           }
[17:01:02.051]                           else {
[17:01:02.051]                             version <- NULL
[17:01:02.051]                           }
[17:01:02.051]                           if (!has_future || version < "1.8.0") {
[17:01:02.051]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.051]                               "", base::R.version$version.string), 
[17:01:02.051]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.051]                                 base::R.version$platform, 8 * 
[17:01:02.051]                                   base::.Machine$sizeof.pointer), 
[17:01:02.051]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.051]                                 "release", "version")], collapse = " "), 
[17:01:02.051]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.051]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.051]                               info)
[17:01:02.051]                             info <- base::paste(info, collapse = "; ")
[17:01:02.051]                             if (!has_future) {
[17:01:02.051]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.051]                                 info)
[17:01:02.051]                             }
[17:01:02.051]                             else {
[17:01:02.051]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.051]                                 info, version)
[17:01:02.051]                             }
[17:01:02.051]                             base::stop(msg)
[17:01:02.051]                           }
[17:01:02.051]                         })
[17:01:02.051]                       }
[17:01:02.051]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.051]                       base::options(mc.cores = 1L)
[17:01:02.051]                     }
[17:01:02.051]                     base::local({
[17:01:02.051]                       for (pkg in "future.apply") {
[17:01:02.051]                         base::loadNamespace(pkg)
[17:01:02.051]                         base::library(pkg, character.only = TRUE)
[17:01:02.051]                       }
[17:01:02.051]                     })
[17:01:02.051]                   }
[17:01:02.051]                   ...future.strategy.old <- future::plan("list")
[17:01:02.051]                   options(future.plan = NULL)
[17:01:02.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.051]                 }
[17:01:02.051]                 ...future.workdir <- getwd()
[17:01:02.051]             }
[17:01:02.051]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.051]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.051]         }
[17:01:02.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.051]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.051]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.051]             base::names(...future.oldOptions))
[17:01:02.051]     }
[17:01:02.051]     if (FALSE) {
[17:01:02.051]     }
[17:01:02.051]     else {
[17:01:02.051]         if (TRUE) {
[17:01:02.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.051]                 open = "w")
[17:01:02.051]         }
[17:01:02.051]         else {
[17:01:02.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.051]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.051]         }
[17:01:02.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.051]             base::sink(type = "output", split = FALSE)
[17:01:02.051]             base::close(...future.stdout)
[17:01:02.051]         }, add = TRUE)
[17:01:02.051]     }
[17:01:02.051]     ...future.frame <- base::sys.nframe()
[17:01:02.051]     ...future.conditions <- base::list()
[17:01:02.051]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.051]     if (FALSE) {
[17:01:02.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.051]     }
[17:01:02.051]     ...future.result <- base::tryCatch({
[17:01:02.051]         base::withCallingHandlers({
[17:01:02.051]             ...future.value <- base::withVisible(base::local({
[17:01:02.051]                 withCallingHandlers({
[17:01:02.051]                   {
[17:01:02.051]                     do.call(function(...) {
[17:01:02.051]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.051]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.051]                         ...future.globals.maxSize)) {
[17:01:02.051]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.051]                         on.exit(options(oopts), add = TRUE)
[17:01:02.051]                       }
[17:01:02.051]                       {
[17:01:02.051]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.051]                           FUN = function(jj) {
[17:01:02.051]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.051]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.051]                           })
[17:01:02.051]                       }
[17:01:02.051]                     }, args = future.call.arguments)
[17:01:02.051]                   }
[17:01:02.051]                 }, immediateCondition = function(cond) {
[17:01:02.051]                   save_rds <- function (object, pathname, ...) 
[17:01:02.051]                   {
[17:01:02.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.051]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.051]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.051]                         fi_tmp[["mtime"]])
[17:01:02.051]                     }
[17:01:02.051]                     tryCatch({
[17:01:02.051]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.051]                     }, error = function(ex) {
[17:01:02.051]                       msg <- conditionMessage(ex)
[17:01:02.051]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.051]                         fi_tmp[["mtime"]], msg)
[17:01:02.051]                       ex$message <- msg
[17:01:02.051]                       stop(ex)
[17:01:02.051]                     })
[17:01:02.051]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.051]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.051]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.051]                       fi <- file.info(pathname)
[17:01:02.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.051]                         fi[["size"]], fi[["mtime"]])
[17:01:02.051]                       stop(msg)
[17:01:02.051]                     }
[17:01:02.051]                     invisible(pathname)
[17:01:02.051]                   }
[17:01:02.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.051]                     rootPath = tempdir()) 
[17:01:02.051]                   {
[17:01:02.051]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.051]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.051]                       tmpdir = path, fileext = ".rds")
[17:01:02.051]                     save_rds(obj, file)
[17:01:02.051]                   }
[17:01:02.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.051]                   {
[17:01:02.051]                     inherits <- base::inherits
[17:01:02.051]                     invokeRestart <- base::invokeRestart
[17:01:02.051]                     is.null <- base::is.null
[17:01:02.051]                     muffled <- FALSE
[17:01:02.051]                     if (inherits(cond, "message")) {
[17:01:02.051]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.051]                       if (muffled) 
[17:01:02.051]                         invokeRestart("muffleMessage")
[17:01:02.051]                     }
[17:01:02.051]                     else if (inherits(cond, "warning")) {
[17:01:02.051]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.051]                       if (muffled) 
[17:01:02.051]                         invokeRestart("muffleWarning")
[17:01:02.051]                     }
[17:01:02.051]                     else if (inherits(cond, "condition")) {
[17:01:02.051]                       if (!is.null(pattern)) {
[17:01:02.051]                         computeRestarts <- base::computeRestarts
[17:01:02.051]                         grepl <- base::grepl
[17:01:02.051]                         restarts <- computeRestarts(cond)
[17:01:02.051]                         for (restart in restarts) {
[17:01:02.051]                           name <- restart$name
[17:01:02.051]                           if (is.null(name)) 
[17:01:02.051]                             next
[17:01:02.051]                           if (!grepl(pattern, name)) 
[17:01:02.051]                             next
[17:01:02.051]                           invokeRestart(restart)
[17:01:02.051]                           muffled <- TRUE
[17:01:02.051]                           break
[17:01:02.051]                         }
[17:01:02.051]                       }
[17:01:02.051]                     }
[17:01:02.051]                     invisible(muffled)
[17:01:02.051]                   }
[17:01:02.051]                   muffleCondition(cond)
[17:01:02.051]                 })
[17:01:02.051]             }))
[17:01:02.051]             future::FutureResult(value = ...future.value$value, 
[17:01:02.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.051]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.051]                     ...future.globalenv.names))
[17:01:02.051]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.051]         }, condition = base::local({
[17:01:02.051]             c <- base::c
[17:01:02.051]             inherits <- base::inherits
[17:01:02.051]             invokeRestart <- base::invokeRestart
[17:01:02.051]             length <- base::length
[17:01:02.051]             list <- base::list
[17:01:02.051]             seq.int <- base::seq.int
[17:01:02.051]             signalCondition <- base::signalCondition
[17:01:02.051]             sys.calls <- base::sys.calls
[17:01:02.051]             `[[` <- base::`[[`
[17:01:02.051]             `+` <- base::`+`
[17:01:02.051]             `<<-` <- base::`<<-`
[17:01:02.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.051]                   3L)]
[17:01:02.051]             }
[17:01:02.051]             function(cond) {
[17:01:02.051]                 is_error <- inherits(cond, "error")
[17:01:02.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.051]                   NULL)
[17:01:02.051]                 if (is_error) {
[17:01:02.051]                   sessionInformation <- function() {
[17:01:02.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.051]                       search = base::search(), system = base::Sys.info())
[17:01:02.051]                   }
[17:01:02.051]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.051]                     cond$call), session = sessionInformation(), 
[17:01:02.051]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.051]                   signalCondition(cond)
[17:01:02.051]                 }
[17:01:02.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.051]                 "immediateCondition"))) {
[17:01:02.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.051]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.051]                   if (TRUE && !signal) {
[17:01:02.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.051]                     {
[17:01:02.051]                       inherits <- base::inherits
[17:01:02.051]                       invokeRestart <- base::invokeRestart
[17:01:02.051]                       is.null <- base::is.null
[17:01:02.051]                       muffled <- FALSE
[17:01:02.051]                       if (inherits(cond, "message")) {
[17:01:02.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.051]                         if (muffled) 
[17:01:02.051]                           invokeRestart("muffleMessage")
[17:01:02.051]                       }
[17:01:02.051]                       else if (inherits(cond, "warning")) {
[17:01:02.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.051]                         if (muffled) 
[17:01:02.051]                           invokeRestart("muffleWarning")
[17:01:02.051]                       }
[17:01:02.051]                       else if (inherits(cond, "condition")) {
[17:01:02.051]                         if (!is.null(pattern)) {
[17:01:02.051]                           computeRestarts <- base::computeRestarts
[17:01:02.051]                           grepl <- base::grepl
[17:01:02.051]                           restarts <- computeRestarts(cond)
[17:01:02.051]                           for (restart in restarts) {
[17:01:02.051]                             name <- restart$name
[17:01:02.051]                             if (is.null(name)) 
[17:01:02.051]                               next
[17:01:02.051]                             if (!grepl(pattern, name)) 
[17:01:02.051]                               next
[17:01:02.051]                             invokeRestart(restart)
[17:01:02.051]                             muffled <- TRUE
[17:01:02.051]                             break
[17:01:02.051]                           }
[17:01:02.051]                         }
[17:01:02.051]                       }
[17:01:02.051]                       invisible(muffled)
[17:01:02.051]                     }
[17:01:02.051]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.051]                   }
[17:01:02.051]                 }
[17:01:02.051]                 else {
[17:01:02.051]                   if (TRUE) {
[17:01:02.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.051]                     {
[17:01:02.051]                       inherits <- base::inherits
[17:01:02.051]                       invokeRestart <- base::invokeRestart
[17:01:02.051]                       is.null <- base::is.null
[17:01:02.051]                       muffled <- FALSE
[17:01:02.051]                       if (inherits(cond, "message")) {
[17:01:02.051]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.051]                         if (muffled) 
[17:01:02.051]                           invokeRestart("muffleMessage")
[17:01:02.051]                       }
[17:01:02.051]                       else if (inherits(cond, "warning")) {
[17:01:02.051]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.051]                         if (muffled) 
[17:01:02.051]                           invokeRestart("muffleWarning")
[17:01:02.051]                       }
[17:01:02.051]                       else if (inherits(cond, "condition")) {
[17:01:02.051]                         if (!is.null(pattern)) {
[17:01:02.051]                           computeRestarts <- base::computeRestarts
[17:01:02.051]                           grepl <- base::grepl
[17:01:02.051]                           restarts <- computeRestarts(cond)
[17:01:02.051]                           for (restart in restarts) {
[17:01:02.051]                             name <- restart$name
[17:01:02.051]                             if (is.null(name)) 
[17:01:02.051]                               next
[17:01:02.051]                             if (!grepl(pattern, name)) 
[17:01:02.051]                               next
[17:01:02.051]                             invokeRestart(restart)
[17:01:02.051]                             muffled <- TRUE
[17:01:02.051]                             break
[17:01:02.051]                           }
[17:01:02.051]                         }
[17:01:02.051]                       }
[17:01:02.051]                       invisible(muffled)
[17:01:02.051]                     }
[17:01:02.051]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.051]                   }
[17:01:02.051]                 }
[17:01:02.051]             }
[17:01:02.051]         }))
[17:01:02.051]     }, error = function(ex) {
[17:01:02.051]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.051]                 ...future.rng), started = ...future.startTime, 
[17:01:02.051]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.051]             version = "1.8"), class = "FutureResult")
[17:01:02.051]     }, finally = {
[17:01:02.051]         if (!identical(...future.workdir, getwd())) 
[17:01:02.051]             setwd(...future.workdir)
[17:01:02.051]         {
[17:01:02.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.051]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.051]             }
[17:01:02.051]             base::options(...future.oldOptions)
[17:01:02.051]             if (.Platform$OS.type == "windows") {
[17:01:02.051]                 old_names <- names(...future.oldEnvVars)
[17:01:02.051]                 envs <- base::Sys.getenv()
[17:01:02.051]                 names <- names(envs)
[17:01:02.051]                 common <- intersect(names, old_names)
[17:01:02.051]                 added <- setdiff(names, old_names)
[17:01:02.051]                 removed <- setdiff(old_names, names)
[17:01:02.051]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.051]                   envs[common]]
[17:01:02.051]                 NAMES <- toupper(changed)
[17:01:02.051]                 args <- list()
[17:01:02.051]                 for (kk in seq_along(NAMES)) {
[17:01:02.051]                   name <- changed[[kk]]
[17:01:02.051]                   NAME <- NAMES[[kk]]
[17:01:02.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.051]                     next
[17:01:02.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.051]                 }
[17:01:02.051]                 NAMES <- toupper(added)
[17:01:02.051]                 for (kk in seq_along(NAMES)) {
[17:01:02.051]                   name <- added[[kk]]
[17:01:02.051]                   NAME <- NAMES[[kk]]
[17:01:02.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.051]                     next
[17:01:02.051]                   args[[name]] <- ""
[17:01:02.051]                 }
[17:01:02.051]                 NAMES <- toupper(removed)
[17:01:02.051]                 for (kk in seq_along(NAMES)) {
[17:01:02.051]                   name <- removed[[kk]]
[17:01:02.051]                   NAME <- NAMES[[kk]]
[17:01:02.051]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.051]                     next
[17:01:02.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.051]                 }
[17:01:02.051]                 if (length(args) > 0) 
[17:01:02.051]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.051]             }
[17:01:02.051]             else {
[17:01:02.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.051]             }
[17:01:02.051]             {
[17:01:02.051]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.051]                   0L) {
[17:01:02.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.051]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.051]                   base::options(opts)
[17:01:02.051]                 }
[17:01:02.051]                 {
[17:01:02.051]                   {
[17:01:02.051]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.051]                     NULL
[17:01:02.051]                   }
[17:01:02.051]                   options(future.plan = NULL)
[17:01:02.051]                   if (is.na(NA_character_)) 
[17:01:02.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.051]                     .init = FALSE)
[17:01:02.051]                 }
[17:01:02.051]             }
[17:01:02.051]         }
[17:01:02.051]     })
[17:01:02.051]     if (TRUE) {
[17:01:02.051]         base::sink(type = "output", split = FALSE)
[17:01:02.051]         if (TRUE) {
[17:01:02.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.051]         }
[17:01:02.051]         else {
[17:01:02.051]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.051]         }
[17:01:02.051]         base::close(...future.stdout)
[17:01:02.051]         ...future.stdout <- NULL
[17:01:02.051]     }
[17:01:02.051]     ...future.result$conditions <- ...future.conditions
[17:01:02.051]     ...future.result$finished <- base::Sys.time()
[17:01:02.051]     ...future.result
[17:01:02.051] }
[17:01:02.053] assign_globals() ...
[17:01:02.054] List of 11
[17:01:02.054]  $ ...future.FUN            :function (x, ...)  
[17:01:02.054]  $ x_FUN                    :function (x)  
[17:01:02.054]  $ times                    : int 0
[17:01:02.054]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.054]  $ stop_if_not              :function (...)  
[17:01:02.054]  $ dim                      : NULL
[17:01:02.054]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.054]  $ future.call.arguments    : list()
[17:01:02.054]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.054]  $ ...future.elements_ii    :List of 5
[17:01:02.054]   ..$ : int 1
[17:01:02.054]   ..$ : int 2
[17:01:02.054]   ..$ : int 3
[17:01:02.054]   ..$ : int 4
[17:01:02.054]   ..$ : int 5
[17:01:02.054]  $ ...future.seeds_ii       : NULL
[17:01:02.054]  $ ...future.globals.maxSize: NULL
[17:01:02.054]  - attr(*, "where")=List of 11
[17:01:02.054]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.054]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.054]  - attr(*, "resolved")= logi FALSE
[17:01:02.054]  - attr(*, "total_size")= num 95472
[17:01:02.054]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.054]  - attr(*, "already-done")= logi TRUE
[17:01:02.062] - copied ‘...future.FUN’ to environment
[17:01:02.062] - reassign environment for ‘x_FUN’
[17:01:02.062] - copied ‘x_FUN’ to environment
[17:01:02.062] - copied ‘times’ to environment
[17:01:02.062] - copied ‘stopf’ to environment
[17:01:02.062] - copied ‘stop_if_not’ to environment
[17:01:02.063] - copied ‘dim’ to environment
[17:01:02.063] - copied ‘valid_types’ to environment
[17:01:02.063] - copied ‘future.call.arguments’ to environment
[17:01:02.063] - copied ‘...future.elements_ii’ to environment
[17:01:02.063] - copied ‘...future.seeds_ii’ to environment
[17:01:02.063] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.063] assign_globals() ... done
[17:01:02.063] requestCore(): workers = 2
[17:01:02.065] MulticoreFuture started
[17:01:02.066] - Launch lazy future ... done
[17:01:02.066] run() for ‘MulticoreFuture’ ... done
[17:01:02.066] Created future:
[17:01:02.067] plan(): Setting new future strategy stack:
[17:01:02.067] List of future strategies:
[17:01:02.067] 1. sequential:
[17:01:02.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.067]    - tweaked: FALSE
[17:01:02.067]    - call: NULL
[17:01:02.068] plan(): nbrOfWorkers() = 1
[17:01:02.070] plan(): Setting new future strategy stack:
[17:01:02.070] List of future strategies:
[17:01:02.070] 1. multicore:
[17:01:02.070]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.070]    - tweaked: FALSE
[17:01:02.070]    - call: plan(strategy)
[17:01:02.076] plan(): nbrOfWorkers() = 2
[17:01:02.067] MulticoreFuture:
[17:01:02.067] Label: ‘future_vapply-1’
[17:01:02.067] Expression:
[17:01:02.067] {
[17:01:02.067]     do.call(function(...) {
[17:01:02.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.067]             on.exit(options(oopts), add = TRUE)
[17:01:02.067]         }
[17:01:02.067]         {
[17:01:02.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.067]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.067]             })
[17:01:02.067]         }
[17:01:02.067]     }, args = future.call.arguments)
[17:01:02.067] }
[17:01:02.067] Lazy evaluation: FALSE
[17:01:02.067] Asynchronous evaluation: TRUE
[17:01:02.067] Local evaluation: TRUE
[17:01:02.067] Environment: R_GlobalEnv
[17:01:02.067] Capture standard output: TRUE
[17:01:02.067] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.067] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.067] Packages: 1 packages (‘future.apply’)
[17:01:02.067] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.067] Resolved: TRUE
[17:01:02.067] Value: <not collected>
[17:01:02.067] Conditions captured: <none>
[17:01:02.067] Early signaling: FALSE
[17:01:02.067] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.067] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.076] Chunk #1 of 2 ... DONE
[17:01:02.077] Chunk #2 of 2 ...
[17:01:02.077]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.077] getGlobalsAndPackages() ...
[17:01:02.077] Searching for globals...
[17:01:02.078] 
[17:01:02.078] Searching for globals ... DONE
[17:01:02.078] - globals: [0] <none>
[17:01:02.078] getGlobalsAndPackages() ... DONE
[17:01:02.078]    + additional globals found: [n=0] 
[17:01:02.078]    + additional namespaces needed: [n=0] 
[17:01:02.078]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.079]  - seeds: <none>
[17:01:02.082]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.083] getGlobalsAndPackages() ...
[17:01:02.083] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.084] Resolving globals: FALSE
[17:01:02.084] Tweak future expression to call with '...' arguments ...
[17:01:02.085] {
[17:01:02.085]     do.call(function(...) {
[17:01:02.085]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.085]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.085]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.085]             on.exit(options(oopts), add = TRUE)
[17:01:02.085]         }
[17:01:02.085]         {
[17:01:02.085]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.085]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.085]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.085]             })
[17:01:02.085]         }
[17:01:02.085]     }, args = future.call.arguments)
[17:01:02.085] }
[17:01:02.085] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.087] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.087] - packages: [1] ‘future.apply’
[17:01:02.087] getGlobalsAndPackages() ... DONE
[17:01:02.088] run() for ‘Future’ ...
[17:01:02.088] - state: ‘created’
[17:01:02.089] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.095] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.096]   - Field: ‘label’
[17:01:02.096]   - Field: ‘local’
[17:01:02.096]   - Field: ‘owner’
[17:01:02.096]   - Field: ‘envir’
[17:01:02.096]   - Field: ‘workers’
[17:01:02.096]   - Field: ‘packages’
[17:01:02.096]   - Field: ‘gc’
[17:01:02.097]   - Field: ‘job’
[17:01:02.097]   - Field: ‘conditions’
[17:01:02.097]   - Field: ‘expr’
[17:01:02.097]   - Field: ‘uuid’
[17:01:02.097]   - Field: ‘seed’
[17:01:02.097]   - Field: ‘version’
[17:01:02.098]   - Field: ‘result’
[17:01:02.098]   - Field: ‘asynchronous’
[17:01:02.098]   - Field: ‘calls’
[17:01:02.098]   - Field: ‘globals’
[17:01:02.098]   - Field: ‘stdout’
[17:01:02.098]   - Field: ‘earlySignal’
[17:01:02.098]   - Field: ‘lazy’
[17:01:02.099]   - Field: ‘state’
[17:01:02.099] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.099] - Launch lazy future ...
[17:01:02.099] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.099] Packages needed by future strategies (n = 0): <none>
[17:01:02.100] {
[17:01:02.100]     {
[17:01:02.100]         {
[17:01:02.100]             ...future.startTime <- base::Sys.time()
[17:01:02.100]             {
[17:01:02.100]                 {
[17:01:02.100]                   {
[17:01:02.100]                     {
[17:01:02.100]                       {
[17:01:02.100]                         base::local({
[17:01:02.100]                           has_future <- base::requireNamespace("future", 
[17:01:02.100]                             quietly = TRUE)
[17:01:02.100]                           if (has_future) {
[17:01:02.100]                             ns <- base::getNamespace("future")
[17:01:02.100]                             version <- ns[[".package"]][["version"]]
[17:01:02.100]                             if (is.null(version)) 
[17:01:02.100]                               version <- utils::packageVersion("future")
[17:01:02.100]                           }
[17:01:02.100]                           else {
[17:01:02.100]                             version <- NULL
[17:01:02.100]                           }
[17:01:02.100]                           if (!has_future || version < "1.8.0") {
[17:01:02.100]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.100]                               "", base::R.version$version.string), 
[17:01:02.100]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.100]                                 base::R.version$platform, 8 * 
[17:01:02.100]                                   base::.Machine$sizeof.pointer), 
[17:01:02.100]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.100]                                 "release", "version")], collapse = " "), 
[17:01:02.100]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.100]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.100]                               info)
[17:01:02.100]                             info <- base::paste(info, collapse = "; ")
[17:01:02.100]                             if (!has_future) {
[17:01:02.100]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.100]                                 info)
[17:01:02.100]                             }
[17:01:02.100]                             else {
[17:01:02.100]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.100]                                 info, version)
[17:01:02.100]                             }
[17:01:02.100]                             base::stop(msg)
[17:01:02.100]                           }
[17:01:02.100]                         })
[17:01:02.100]                       }
[17:01:02.100]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.100]                       base::options(mc.cores = 1L)
[17:01:02.100]                     }
[17:01:02.100]                     base::local({
[17:01:02.100]                       for (pkg in "future.apply") {
[17:01:02.100]                         base::loadNamespace(pkg)
[17:01:02.100]                         base::library(pkg, character.only = TRUE)
[17:01:02.100]                       }
[17:01:02.100]                     })
[17:01:02.100]                   }
[17:01:02.100]                   ...future.strategy.old <- future::plan("list")
[17:01:02.100]                   options(future.plan = NULL)
[17:01:02.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.100]                 }
[17:01:02.100]                 ...future.workdir <- getwd()
[17:01:02.100]             }
[17:01:02.100]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.100]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.100]         }
[17:01:02.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.100]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.100]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.100]             base::names(...future.oldOptions))
[17:01:02.100]     }
[17:01:02.100]     if (FALSE) {
[17:01:02.100]     }
[17:01:02.100]     else {
[17:01:02.100]         if (TRUE) {
[17:01:02.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.100]                 open = "w")
[17:01:02.100]         }
[17:01:02.100]         else {
[17:01:02.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.100]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.100]         }
[17:01:02.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.100]             base::sink(type = "output", split = FALSE)
[17:01:02.100]             base::close(...future.stdout)
[17:01:02.100]         }, add = TRUE)
[17:01:02.100]     }
[17:01:02.100]     ...future.frame <- base::sys.nframe()
[17:01:02.100]     ...future.conditions <- base::list()
[17:01:02.100]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.100]     if (FALSE) {
[17:01:02.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.100]     }
[17:01:02.100]     ...future.result <- base::tryCatch({
[17:01:02.100]         base::withCallingHandlers({
[17:01:02.100]             ...future.value <- base::withVisible(base::local({
[17:01:02.100]                 withCallingHandlers({
[17:01:02.100]                   {
[17:01:02.100]                     do.call(function(...) {
[17:01:02.100]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.100]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.100]                         ...future.globals.maxSize)) {
[17:01:02.100]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.100]                         on.exit(options(oopts), add = TRUE)
[17:01:02.100]                       }
[17:01:02.100]                       {
[17:01:02.100]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.100]                           FUN = function(jj) {
[17:01:02.100]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.100]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.100]                           })
[17:01:02.100]                       }
[17:01:02.100]                     }, args = future.call.arguments)
[17:01:02.100]                   }
[17:01:02.100]                 }, immediateCondition = function(cond) {
[17:01:02.100]                   save_rds <- function (object, pathname, ...) 
[17:01:02.100]                   {
[17:01:02.100]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.100]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.100]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.100]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.100]                         fi_tmp[["mtime"]])
[17:01:02.100]                     }
[17:01:02.100]                     tryCatch({
[17:01:02.100]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.100]                     }, error = function(ex) {
[17:01:02.100]                       msg <- conditionMessage(ex)
[17:01:02.100]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.100]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.100]                         fi_tmp[["mtime"]], msg)
[17:01:02.100]                       ex$message <- msg
[17:01:02.100]                       stop(ex)
[17:01:02.100]                     })
[17:01:02.100]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.100]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.100]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.100]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.100]                       fi <- file.info(pathname)
[17:01:02.100]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.100]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.100]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.100]                         fi[["size"]], fi[["mtime"]])
[17:01:02.100]                       stop(msg)
[17:01:02.100]                     }
[17:01:02.100]                     invisible(pathname)
[17:01:02.100]                   }
[17:01:02.100]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.100]                     rootPath = tempdir()) 
[17:01:02.100]                   {
[17:01:02.100]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.100]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.100]                       tmpdir = path, fileext = ".rds")
[17:01:02.100]                     save_rds(obj, file)
[17:01:02.100]                   }
[17:01:02.100]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.100]                   {
[17:01:02.100]                     inherits <- base::inherits
[17:01:02.100]                     invokeRestart <- base::invokeRestart
[17:01:02.100]                     is.null <- base::is.null
[17:01:02.100]                     muffled <- FALSE
[17:01:02.100]                     if (inherits(cond, "message")) {
[17:01:02.100]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.100]                       if (muffled) 
[17:01:02.100]                         invokeRestart("muffleMessage")
[17:01:02.100]                     }
[17:01:02.100]                     else if (inherits(cond, "warning")) {
[17:01:02.100]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.100]                       if (muffled) 
[17:01:02.100]                         invokeRestart("muffleWarning")
[17:01:02.100]                     }
[17:01:02.100]                     else if (inherits(cond, "condition")) {
[17:01:02.100]                       if (!is.null(pattern)) {
[17:01:02.100]                         computeRestarts <- base::computeRestarts
[17:01:02.100]                         grepl <- base::grepl
[17:01:02.100]                         restarts <- computeRestarts(cond)
[17:01:02.100]                         for (restart in restarts) {
[17:01:02.100]                           name <- restart$name
[17:01:02.100]                           if (is.null(name)) 
[17:01:02.100]                             next
[17:01:02.100]                           if (!grepl(pattern, name)) 
[17:01:02.100]                             next
[17:01:02.100]                           invokeRestart(restart)
[17:01:02.100]                           muffled <- TRUE
[17:01:02.100]                           break
[17:01:02.100]                         }
[17:01:02.100]                       }
[17:01:02.100]                     }
[17:01:02.100]                     invisible(muffled)
[17:01:02.100]                   }
[17:01:02.100]                   muffleCondition(cond)
[17:01:02.100]                 })
[17:01:02.100]             }))
[17:01:02.100]             future::FutureResult(value = ...future.value$value, 
[17:01:02.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.100]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.100]                     ...future.globalenv.names))
[17:01:02.100]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.100]         }, condition = base::local({
[17:01:02.100]             c <- base::c
[17:01:02.100]             inherits <- base::inherits
[17:01:02.100]             invokeRestart <- base::invokeRestart
[17:01:02.100]             length <- base::length
[17:01:02.100]             list <- base::list
[17:01:02.100]             seq.int <- base::seq.int
[17:01:02.100]             signalCondition <- base::signalCondition
[17:01:02.100]             sys.calls <- base::sys.calls
[17:01:02.100]             `[[` <- base::`[[`
[17:01:02.100]             `+` <- base::`+`
[17:01:02.100]             `<<-` <- base::`<<-`
[17:01:02.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.100]                   3L)]
[17:01:02.100]             }
[17:01:02.100]             function(cond) {
[17:01:02.100]                 is_error <- inherits(cond, "error")
[17:01:02.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.100]                   NULL)
[17:01:02.100]                 if (is_error) {
[17:01:02.100]                   sessionInformation <- function() {
[17:01:02.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.100]                       search = base::search(), system = base::Sys.info())
[17:01:02.100]                   }
[17:01:02.100]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.100]                     cond$call), session = sessionInformation(), 
[17:01:02.100]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.100]                   signalCondition(cond)
[17:01:02.100]                 }
[17:01:02.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.100]                 "immediateCondition"))) {
[17:01:02.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.100]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.100]                   if (TRUE && !signal) {
[17:01:02.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.100]                     {
[17:01:02.100]                       inherits <- base::inherits
[17:01:02.100]                       invokeRestart <- base::invokeRestart
[17:01:02.100]                       is.null <- base::is.null
[17:01:02.100]                       muffled <- FALSE
[17:01:02.100]                       if (inherits(cond, "message")) {
[17:01:02.100]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.100]                         if (muffled) 
[17:01:02.100]                           invokeRestart("muffleMessage")
[17:01:02.100]                       }
[17:01:02.100]                       else if (inherits(cond, "warning")) {
[17:01:02.100]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.100]                         if (muffled) 
[17:01:02.100]                           invokeRestart("muffleWarning")
[17:01:02.100]                       }
[17:01:02.100]                       else if (inherits(cond, "condition")) {
[17:01:02.100]                         if (!is.null(pattern)) {
[17:01:02.100]                           computeRestarts <- base::computeRestarts
[17:01:02.100]                           grepl <- base::grepl
[17:01:02.100]                           restarts <- computeRestarts(cond)
[17:01:02.100]                           for (restart in restarts) {
[17:01:02.100]                             name <- restart$name
[17:01:02.100]                             if (is.null(name)) 
[17:01:02.100]                               next
[17:01:02.100]                             if (!grepl(pattern, name)) 
[17:01:02.100]                               next
[17:01:02.100]                             invokeRestart(restart)
[17:01:02.100]                             muffled <- TRUE
[17:01:02.100]                             break
[17:01:02.100]                           }
[17:01:02.100]                         }
[17:01:02.100]                       }
[17:01:02.100]                       invisible(muffled)
[17:01:02.100]                     }
[17:01:02.100]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.100]                   }
[17:01:02.100]                 }
[17:01:02.100]                 else {
[17:01:02.100]                   if (TRUE) {
[17:01:02.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.100]                     {
[17:01:02.100]                       inherits <- base::inherits
[17:01:02.100]                       invokeRestart <- base::invokeRestart
[17:01:02.100]                       is.null <- base::is.null
[17:01:02.100]                       muffled <- FALSE
[17:01:02.100]                       if (inherits(cond, "message")) {
[17:01:02.100]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.100]                         if (muffled) 
[17:01:02.100]                           invokeRestart("muffleMessage")
[17:01:02.100]                       }
[17:01:02.100]                       else if (inherits(cond, "warning")) {
[17:01:02.100]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.100]                         if (muffled) 
[17:01:02.100]                           invokeRestart("muffleWarning")
[17:01:02.100]                       }
[17:01:02.100]                       else if (inherits(cond, "condition")) {
[17:01:02.100]                         if (!is.null(pattern)) {
[17:01:02.100]                           computeRestarts <- base::computeRestarts
[17:01:02.100]                           grepl <- base::grepl
[17:01:02.100]                           restarts <- computeRestarts(cond)
[17:01:02.100]                           for (restart in restarts) {
[17:01:02.100]                             name <- restart$name
[17:01:02.100]                             if (is.null(name)) 
[17:01:02.100]                               next
[17:01:02.100]                             if (!grepl(pattern, name)) 
[17:01:02.100]                               next
[17:01:02.100]                             invokeRestart(restart)
[17:01:02.100]                             muffled <- TRUE
[17:01:02.100]                             break
[17:01:02.100]                           }
[17:01:02.100]                         }
[17:01:02.100]                       }
[17:01:02.100]                       invisible(muffled)
[17:01:02.100]                     }
[17:01:02.100]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.100]                   }
[17:01:02.100]                 }
[17:01:02.100]             }
[17:01:02.100]         }))
[17:01:02.100]     }, error = function(ex) {
[17:01:02.100]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.100]                 ...future.rng), started = ...future.startTime, 
[17:01:02.100]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.100]             version = "1.8"), class = "FutureResult")
[17:01:02.100]     }, finally = {
[17:01:02.100]         if (!identical(...future.workdir, getwd())) 
[17:01:02.100]             setwd(...future.workdir)
[17:01:02.100]         {
[17:01:02.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.100]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.100]             }
[17:01:02.100]             base::options(...future.oldOptions)
[17:01:02.100]             if (.Platform$OS.type == "windows") {
[17:01:02.100]                 old_names <- names(...future.oldEnvVars)
[17:01:02.100]                 envs <- base::Sys.getenv()
[17:01:02.100]                 names <- names(envs)
[17:01:02.100]                 common <- intersect(names, old_names)
[17:01:02.100]                 added <- setdiff(names, old_names)
[17:01:02.100]                 removed <- setdiff(old_names, names)
[17:01:02.100]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.100]                   envs[common]]
[17:01:02.100]                 NAMES <- toupper(changed)
[17:01:02.100]                 args <- list()
[17:01:02.100]                 for (kk in seq_along(NAMES)) {
[17:01:02.100]                   name <- changed[[kk]]
[17:01:02.100]                   NAME <- NAMES[[kk]]
[17:01:02.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.100]                     next
[17:01:02.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.100]                 }
[17:01:02.100]                 NAMES <- toupper(added)
[17:01:02.100]                 for (kk in seq_along(NAMES)) {
[17:01:02.100]                   name <- added[[kk]]
[17:01:02.100]                   NAME <- NAMES[[kk]]
[17:01:02.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.100]                     next
[17:01:02.100]                   args[[name]] <- ""
[17:01:02.100]                 }
[17:01:02.100]                 NAMES <- toupper(removed)
[17:01:02.100]                 for (kk in seq_along(NAMES)) {
[17:01:02.100]                   name <- removed[[kk]]
[17:01:02.100]                   NAME <- NAMES[[kk]]
[17:01:02.100]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.100]                     next
[17:01:02.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.100]                 }
[17:01:02.100]                 if (length(args) > 0) 
[17:01:02.100]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.100]             }
[17:01:02.100]             else {
[17:01:02.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.100]             }
[17:01:02.100]             {
[17:01:02.100]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.100]                   0L) {
[17:01:02.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.100]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.100]                   base::options(opts)
[17:01:02.100]                 }
[17:01:02.100]                 {
[17:01:02.100]                   {
[17:01:02.100]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.100]                     NULL
[17:01:02.100]                   }
[17:01:02.100]                   options(future.plan = NULL)
[17:01:02.100]                   if (is.na(NA_character_)) 
[17:01:02.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.100]                     .init = FALSE)
[17:01:02.100]                 }
[17:01:02.100]             }
[17:01:02.100]         }
[17:01:02.100]     })
[17:01:02.100]     if (TRUE) {
[17:01:02.100]         base::sink(type = "output", split = FALSE)
[17:01:02.100]         if (TRUE) {
[17:01:02.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.100]         }
[17:01:02.100]         else {
[17:01:02.100]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.100]         }
[17:01:02.100]         base::close(...future.stdout)
[17:01:02.100]         ...future.stdout <- NULL
[17:01:02.100]     }
[17:01:02.100]     ...future.result$conditions <- ...future.conditions
[17:01:02.100]     ...future.result$finished <- base::Sys.time()
[17:01:02.100]     ...future.result
[17:01:02.100] }
[17:01:02.103] assign_globals() ...
[17:01:02.103] List of 11
[17:01:02.103]  $ ...future.FUN            :function (x, ...)  
[17:01:02.103]  $ x_FUN                    :function (x)  
[17:01:02.103]  $ times                    : int 0
[17:01:02.103]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.103]  $ stop_if_not              :function (...)  
[17:01:02.103]  $ dim                      : NULL
[17:01:02.103]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.103]  $ future.call.arguments    : list()
[17:01:02.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.103]  $ ...future.elements_ii    :List of 5
[17:01:02.103]   ..$ : int 6
[17:01:02.103]   ..$ : int 7
[17:01:02.103]   ..$ : int 8
[17:01:02.103]   ..$ : int 9
[17:01:02.103]   ..$ : int 10
[17:01:02.103]  $ ...future.seeds_ii       : NULL
[17:01:02.103]  $ ...future.globals.maxSize: NULL
[17:01:02.103]  - attr(*, "where")=List of 11
[17:01:02.103]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.103]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.103]  - attr(*, "resolved")= logi FALSE
[17:01:02.103]  - attr(*, "total_size")= num 95472
[17:01:02.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.103]  - attr(*, "already-done")= logi TRUE
[17:01:02.115] - copied ‘...future.FUN’ to environment
[17:01:02.115] - reassign environment for ‘x_FUN’
[17:01:02.115] - copied ‘x_FUN’ to environment
[17:01:02.115] - copied ‘times’ to environment
[17:01:02.115] - copied ‘stopf’ to environment
[17:01:02.115] - copied ‘stop_if_not’ to environment
[17:01:02.115] - copied ‘dim’ to environment
[17:01:02.116] - copied ‘valid_types’ to environment
[17:01:02.116] - copied ‘future.call.arguments’ to environment
[17:01:02.116] - copied ‘...future.elements_ii’ to environment
[17:01:02.116] - copied ‘...future.seeds_ii’ to environment
[17:01:02.116] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.116] assign_globals() ... done
[17:01:02.116] requestCore(): workers = 2
[17:01:02.118] MulticoreFuture started
[17:01:02.119] - Launch lazy future ... done
[17:01:02.119] run() for ‘MulticoreFuture’ ... done
[17:01:02.119] Created future:
[17:01:02.120] plan(): Setting new future strategy stack:
[17:01:02.120] List of future strategies:
[17:01:02.120] 1. sequential:
[17:01:02.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.120]    - tweaked: FALSE
[17:01:02.120]    - call: NULL
[17:01:02.121] plan(): nbrOfWorkers() = 1
[17:01:02.123] plan(): Setting new future strategy stack:
[17:01:02.123] List of future strategies:
[17:01:02.123] 1. multicore:
[17:01:02.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.123]    - tweaked: FALSE
[17:01:02.123]    - call: plan(strategy)
[17:01:02.129] plan(): nbrOfWorkers() = 2
[17:01:02.119] MulticoreFuture:
[17:01:02.119] Label: ‘future_vapply-2’
[17:01:02.119] Expression:
[17:01:02.119] {
[17:01:02.119]     do.call(function(...) {
[17:01:02.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.119]             on.exit(options(oopts), add = TRUE)
[17:01:02.119]         }
[17:01:02.119]         {
[17:01:02.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.119]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.119]             })
[17:01:02.119]         }
[17:01:02.119]     }, args = future.call.arguments)
[17:01:02.119] }
[17:01:02.119] Lazy evaluation: FALSE
[17:01:02.119] Asynchronous evaluation: TRUE
[17:01:02.119] Local evaluation: TRUE
[17:01:02.119] Environment: R_GlobalEnv
[17:01:02.119] Capture standard output: TRUE
[17:01:02.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.119] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.119] Packages: 1 packages (‘future.apply’)
[17:01:02.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.119] Resolved: TRUE
[17:01:02.119] Value: <not collected>
[17:01:02.119] Conditions captured: <none>
[17:01:02.119] Early signaling: FALSE
[17:01:02.119] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.119] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.130] Chunk #2 of 2 ... DONE
[17:01:02.130] Launching 2 futures (chunks) ... DONE
[17:01:02.130] Resolving 2 futures (chunks) ...
[17:01:02.130] resolve() on list ...
[17:01:02.130]  recursive: 0
[17:01:02.130]  length: 2
[17:01:02.131] 
[17:01:02.131] Future #1
[17:01:02.131] result() for MulticoreFuture ...
[17:01:02.132] result() for MulticoreFuture ...
[17:01:02.132] result() for MulticoreFuture ... done
[17:01:02.132] result() for MulticoreFuture ... done
[17:01:02.132] result() for MulticoreFuture ...
[17:01:02.132] result() for MulticoreFuture ... done
[17:01:02.133] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.133] - nx: 2
[17:01:02.133] - relay: TRUE
[17:01:02.133] - stdout: TRUE
[17:01:02.133] - signal: TRUE
[17:01:02.133] - resignal: FALSE
[17:01:02.134] - force: TRUE
[17:01:02.137] - relayed: [n=2] FALSE, FALSE
[17:01:02.138] - queued futures: [n=2] FALSE, FALSE
[17:01:02.138]  - until=1
[17:01:02.139]  - relaying element #1
[17:01:02.139] result() for MulticoreFuture ...
[17:01:02.139] result() for MulticoreFuture ... done
[17:01:02.140] result() for MulticoreFuture ...
[17:01:02.140] result() for MulticoreFuture ... done
[17:01:02.140] result() for MulticoreFuture ...
[17:01:02.141] result() for MulticoreFuture ... done
[17:01:02.141] result() for MulticoreFuture ...
[17:01:02.141] result() for MulticoreFuture ... done
[17:01:02.141] - relayed: [n=2] TRUE, FALSE
[17:01:02.142] - queued futures: [n=2] TRUE, FALSE
[17:01:02.142] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.142]  length: 1 (resolved future 1)
[17:01:02.143] Future #2
[17:01:02.143] result() for MulticoreFuture ...
[17:01:02.144] result() for MulticoreFuture ...
[17:01:02.144] result() for MulticoreFuture ... done
[17:01:02.145] result() for MulticoreFuture ... done
[17:01:02.145] result() for MulticoreFuture ...
[17:01:02.145] result() for MulticoreFuture ... done
[17:01:02.145] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.146] - nx: 2
[17:01:02.146] - relay: TRUE
[17:01:02.146] - stdout: TRUE
[17:01:02.146] - signal: TRUE
[17:01:02.146] - resignal: FALSE
[17:01:02.146] - force: TRUE
[17:01:02.147] - relayed: [n=2] TRUE, FALSE
[17:01:02.147] - queued futures: [n=2] TRUE, FALSE
[17:01:02.147]  - until=2
[17:01:02.147]  - relaying element #2
[17:01:02.147] result() for MulticoreFuture ...
[17:01:02.147] result() for MulticoreFuture ... done
[17:01:02.147] result() for MulticoreFuture ...
[17:01:02.147] result() for MulticoreFuture ... done
[17:01:02.148] result() for MulticoreFuture ...
[17:01:02.148] result() for MulticoreFuture ... done
[17:01:02.148] result() for MulticoreFuture ...
[17:01:02.148] result() for MulticoreFuture ... done
[17:01:02.148] - relayed: [n=2] TRUE, TRUE
[17:01:02.148] - queued futures: [n=2] TRUE, TRUE
[17:01:02.148] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.148]  length: 0 (resolved future 2)
[17:01:02.149] Relaying remaining futures
[17:01:02.149] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.149] - nx: 2
[17:01:02.149] - relay: TRUE
[17:01:02.149] - stdout: TRUE
[17:01:02.149] - signal: TRUE
[17:01:02.149] - resignal: FALSE
[17:01:02.149] - force: TRUE
[17:01:02.149] - relayed: [n=2] TRUE, TRUE
[17:01:02.149] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.150] - relayed: [n=2] TRUE, TRUE
[17:01:02.150] - queued futures: [n=2] TRUE, TRUE
[17:01:02.150] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.150] resolve() on list ... DONE
[17:01:02.150] result() for MulticoreFuture ...
[17:01:02.150] result() for MulticoreFuture ... done
[17:01:02.150] result() for MulticoreFuture ...
[17:01:02.150] result() for MulticoreFuture ... done
[17:01:02.150] result() for MulticoreFuture ...
[17:01:02.150] result() for MulticoreFuture ... done
[17:01:02.151] result() for MulticoreFuture ...
[17:01:02.151] result() for MulticoreFuture ... done
[17:01:02.151]  - Number of value chunks collected: 2
[17:01:02.151] Resolving 2 futures (chunks) ... DONE
[17:01:02.151] Reducing values from 2 chunks ...
[17:01:02.151]  - Number of values collected after concatenation: 10
[17:01:02.151]  - Number of values expected: 10
[17:01:02.151] Reducing values from 2 chunks ... DONE
[17:01:02.151] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:01:02.153] future_lapply() ...
[17:01:02.159] Number of chunks: 2
[17:01:02.159] getGlobalsAndPackagesXApply() ...
[17:01:02.159]  - future.globals: TRUE
[17:01:02.159] getGlobalsAndPackages() ...
[17:01:02.159] Searching for globals...
[17:01:02.163] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:01:02.163] Searching for globals ... DONE
[17:01:02.163] Resolving globals: FALSE
[17:01:02.164] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:01:02.164] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.165] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.165] - packages: [1] ‘future.apply’
[17:01:02.165] getGlobalsAndPackages() ... DONE
[17:01:02.165]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.165]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.165] Finding globals ... DONE
[17:01:02.165]  - use_args: TRUE
[17:01:02.165]  - Getting '...' globals ...
[17:01:02.166] resolve() on list ...
[17:01:02.166]  recursive: 0
[17:01:02.166]  length: 1
[17:01:02.166]  elements: ‘...’
[17:01:02.166]  length: 0 (resolved future 1)
[17:01:02.166] resolve() on list ... DONE
[17:01:02.166]    - '...' content: [n=0] 
[17:01:02.166] List of 1
[17:01:02.166]  $ ...: list()
[17:01:02.166]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.166]  - attr(*, "where")=List of 1
[17:01:02.166]   ..$ ...:<environment: 0x55aad92b8208> 
[17:01:02.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.166]  - attr(*, "resolved")= logi TRUE
[17:01:02.166]  - attr(*, "total_size")= num NA
[17:01:02.171]  - Getting '...' globals ... DONE
[17:01:02.171] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.171] List of 8
[17:01:02.171]  $ ...future.FUN:function (x, ...)  
[17:01:02.171]  $ x_FUN        :function (x)  
[17:01:02.171]  $ times        : int 0
[17:01:02.171]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.171]  $ stop_if_not  :function (...)  
[17:01:02.171]  $ dim          : NULL
[17:01:02.171]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:02.171]  $ ...          : list()
[17:01:02.171]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.171]  - attr(*, "where")=List of 8
[17:01:02.171]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.171]   ..$ ...          :<environment: 0x55aad92b8208> 
[17:01:02.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.171]  - attr(*, "resolved")= logi FALSE
[17:01:02.171]  - attr(*, "total_size")= num 95400
[17:01:02.177] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.177] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.178] Number of futures (= number of chunks): 2
[17:01:02.178] Launching 2 futures (chunks) ...
[17:01:02.178] Chunk #1 of 2 ...
[17:01:02.178]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.178] getGlobalsAndPackages() ...
[17:01:02.178] Searching for globals...
[17:01:02.178] 
[17:01:02.178] Searching for globals ... DONE
[17:01:02.179] - globals: [0] <none>
[17:01:02.179] getGlobalsAndPackages() ... DONE
[17:01:02.179]    + additional globals found: [n=0] 
[17:01:02.179]    + additional namespaces needed: [n=0] 
[17:01:02.179]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.179]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.179]  - seeds: <none>
[17:01:02.179]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.179] getGlobalsAndPackages() ...
[17:01:02.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.180] Resolving globals: FALSE
[17:01:02.180] Tweak future expression to call with '...' arguments ...
[17:01:02.180] {
[17:01:02.180]     do.call(function(...) {
[17:01:02.180]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.180]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.180]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.180]             on.exit(options(oopts), add = TRUE)
[17:01:02.180]         }
[17:01:02.180]         {
[17:01:02.180]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.180]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.180]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.180]             })
[17:01:02.180]         }
[17:01:02.180]     }, args = future.call.arguments)
[17:01:02.180] }
[17:01:02.180] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.181] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.181] - packages: [1] ‘future.apply’
[17:01:02.181] getGlobalsAndPackages() ... DONE
[17:01:02.181] run() for ‘Future’ ...
[17:01:02.181] - state: ‘created’
[17:01:02.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.185] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.185]   - Field: ‘label’
[17:01:02.186]   - Field: ‘local’
[17:01:02.186]   - Field: ‘owner’
[17:01:02.186]   - Field: ‘envir’
[17:01:02.186]   - Field: ‘workers’
[17:01:02.186]   - Field: ‘packages’
[17:01:02.186]   - Field: ‘gc’
[17:01:02.186]   - Field: ‘job’
[17:01:02.186]   - Field: ‘conditions’
[17:01:02.186]   - Field: ‘expr’
[17:01:02.186]   - Field: ‘uuid’
[17:01:02.186]   - Field: ‘seed’
[17:01:02.187]   - Field: ‘version’
[17:01:02.187]   - Field: ‘result’
[17:01:02.187]   - Field: ‘asynchronous’
[17:01:02.187]   - Field: ‘calls’
[17:01:02.187]   - Field: ‘globals’
[17:01:02.187]   - Field: ‘stdout’
[17:01:02.187]   - Field: ‘earlySignal’
[17:01:02.187]   - Field: ‘lazy’
[17:01:02.187]   - Field: ‘state’
[17:01:02.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.188] - Launch lazy future ...
[17:01:02.188] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.188] Packages needed by future strategies (n = 0): <none>
[17:01:02.188] {
[17:01:02.188]     {
[17:01:02.188]         {
[17:01:02.188]             ...future.startTime <- base::Sys.time()
[17:01:02.188]             {
[17:01:02.188]                 {
[17:01:02.188]                   {
[17:01:02.188]                     {
[17:01:02.188]                       {
[17:01:02.188]                         base::local({
[17:01:02.188]                           has_future <- base::requireNamespace("future", 
[17:01:02.188]                             quietly = TRUE)
[17:01:02.188]                           if (has_future) {
[17:01:02.188]                             ns <- base::getNamespace("future")
[17:01:02.188]                             version <- ns[[".package"]][["version"]]
[17:01:02.188]                             if (is.null(version)) 
[17:01:02.188]                               version <- utils::packageVersion("future")
[17:01:02.188]                           }
[17:01:02.188]                           else {
[17:01:02.188]                             version <- NULL
[17:01:02.188]                           }
[17:01:02.188]                           if (!has_future || version < "1.8.0") {
[17:01:02.188]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.188]                               "", base::R.version$version.string), 
[17:01:02.188]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.188]                                 base::R.version$platform, 8 * 
[17:01:02.188]                                   base::.Machine$sizeof.pointer), 
[17:01:02.188]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.188]                                 "release", "version")], collapse = " "), 
[17:01:02.188]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.188]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.188]                               info)
[17:01:02.188]                             info <- base::paste(info, collapse = "; ")
[17:01:02.188]                             if (!has_future) {
[17:01:02.188]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.188]                                 info)
[17:01:02.188]                             }
[17:01:02.188]                             else {
[17:01:02.188]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.188]                                 info, version)
[17:01:02.188]                             }
[17:01:02.188]                             base::stop(msg)
[17:01:02.188]                           }
[17:01:02.188]                         })
[17:01:02.188]                       }
[17:01:02.188]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.188]                       base::options(mc.cores = 1L)
[17:01:02.188]                     }
[17:01:02.188]                     base::local({
[17:01:02.188]                       for (pkg in "future.apply") {
[17:01:02.188]                         base::loadNamespace(pkg)
[17:01:02.188]                         base::library(pkg, character.only = TRUE)
[17:01:02.188]                       }
[17:01:02.188]                     })
[17:01:02.188]                   }
[17:01:02.188]                   ...future.strategy.old <- future::plan("list")
[17:01:02.188]                   options(future.plan = NULL)
[17:01:02.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.188]                 }
[17:01:02.188]                 ...future.workdir <- getwd()
[17:01:02.188]             }
[17:01:02.188]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.188]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.188]         }
[17:01:02.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.188]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.188]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.188]             base::names(...future.oldOptions))
[17:01:02.188]     }
[17:01:02.188]     if (FALSE) {
[17:01:02.188]     }
[17:01:02.188]     else {
[17:01:02.188]         if (TRUE) {
[17:01:02.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.188]                 open = "w")
[17:01:02.188]         }
[17:01:02.188]         else {
[17:01:02.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.188]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.188]         }
[17:01:02.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.188]             base::sink(type = "output", split = FALSE)
[17:01:02.188]             base::close(...future.stdout)
[17:01:02.188]         }, add = TRUE)
[17:01:02.188]     }
[17:01:02.188]     ...future.frame <- base::sys.nframe()
[17:01:02.188]     ...future.conditions <- base::list()
[17:01:02.188]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.188]     if (FALSE) {
[17:01:02.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.188]     }
[17:01:02.188]     ...future.result <- base::tryCatch({
[17:01:02.188]         base::withCallingHandlers({
[17:01:02.188]             ...future.value <- base::withVisible(base::local({
[17:01:02.188]                 withCallingHandlers({
[17:01:02.188]                   {
[17:01:02.188]                     do.call(function(...) {
[17:01:02.188]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.188]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.188]                         ...future.globals.maxSize)) {
[17:01:02.188]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.188]                         on.exit(options(oopts), add = TRUE)
[17:01:02.188]                       }
[17:01:02.188]                       {
[17:01:02.188]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.188]                           FUN = function(jj) {
[17:01:02.188]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.188]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.188]                           })
[17:01:02.188]                       }
[17:01:02.188]                     }, args = future.call.arguments)
[17:01:02.188]                   }
[17:01:02.188]                 }, immediateCondition = function(cond) {
[17:01:02.188]                   save_rds <- function (object, pathname, ...) 
[17:01:02.188]                   {
[17:01:02.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.188]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.188]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.188]                         fi_tmp[["mtime"]])
[17:01:02.188]                     }
[17:01:02.188]                     tryCatch({
[17:01:02.188]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.188]                     }, error = function(ex) {
[17:01:02.188]                       msg <- conditionMessage(ex)
[17:01:02.188]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.188]                         fi_tmp[["mtime"]], msg)
[17:01:02.188]                       ex$message <- msg
[17:01:02.188]                       stop(ex)
[17:01:02.188]                     })
[17:01:02.188]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.188]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.188]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.188]                       fi <- file.info(pathname)
[17:01:02.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.188]                         fi[["size"]], fi[["mtime"]])
[17:01:02.188]                       stop(msg)
[17:01:02.188]                     }
[17:01:02.188]                     invisible(pathname)
[17:01:02.188]                   }
[17:01:02.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.188]                     rootPath = tempdir()) 
[17:01:02.188]                   {
[17:01:02.188]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.188]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.188]                       tmpdir = path, fileext = ".rds")
[17:01:02.188]                     save_rds(obj, file)
[17:01:02.188]                   }
[17:01:02.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.188]                   {
[17:01:02.188]                     inherits <- base::inherits
[17:01:02.188]                     invokeRestart <- base::invokeRestart
[17:01:02.188]                     is.null <- base::is.null
[17:01:02.188]                     muffled <- FALSE
[17:01:02.188]                     if (inherits(cond, "message")) {
[17:01:02.188]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.188]                       if (muffled) 
[17:01:02.188]                         invokeRestart("muffleMessage")
[17:01:02.188]                     }
[17:01:02.188]                     else if (inherits(cond, "warning")) {
[17:01:02.188]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.188]                       if (muffled) 
[17:01:02.188]                         invokeRestart("muffleWarning")
[17:01:02.188]                     }
[17:01:02.188]                     else if (inherits(cond, "condition")) {
[17:01:02.188]                       if (!is.null(pattern)) {
[17:01:02.188]                         computeRestarts <- base::computeRestarts
[17:01:02.188]                         grepl <- base::grepl
[17:01:02.188]                         restarts <- computeRestarts(cond)
[17:01:02.188]                         for (restart in restarts) {
[17:01:02.188]                           name <- restart$name
[17:01:02.188]                           if (is.null(name)) 
[17:01:02.188]                             next
[17:01:02.188]                           if (!grepl(pattern, name)) 
[17:01:02.188]                             next
[17:01:02.188]                           invokeRestart(restart)
[17:01:02.188]                           muffled <- TRUE
[17:01:02.188]                           break
[17:01:02.188]                         }
[17:01:02.188]                       }
[17:01:02.188]                     }
[17:01:02.188]                     invisible(muffled)
[17:01:02.188]                   }
[17:01:02.188]                   muffleCondition(cond)
[17:01:02.188]                 })
[17:01:02.188]             }))
[17:01:02.188]             future::FutureResult(value = ...future.value$value, 
[17:01:02.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.188]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.188]                     ...future.globalenv.names))
[17:01:02.188]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.188]         }, condition = base::local({
[17:01:02.188]             c <- base::c
[17:01:02.188]             inherits <- base::inherits
[17:01:02.188]             invokeRestart <- base::invokeRestart
[17:01:02.188]             length <- base::length
[17:01:02.188]             list <- base::list
[17:01:02.188]             seq.int <- base::seq.int
[17:01:02.188]             signalCondition <- base::signalCondition
[17:01:02.188]             sys.calls <- base::sys.calls
[17:01:02.188]             `[[` <- base::`[[`
[17:01:02.188]             `+` <- base::`+`
[17:01:02.188]             `<<-` <- base::`<<-`
[17:01:02.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.188]                   3L)]
[17:01:02.188]             }
[17:01:02.188]             function(cond) {
[17:01:02.188]                 is_error <- inherits(cond, "error")
[17:01:02.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.188]                   NULL)
[17:01:02.188]                 if (is_error) {
[17:01:02.188]                   sessionInformation <- function() {
[17:01:02.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.188]                       search = base::search(), system = base::Sys.info())
[17:01:02.188]                   }
[17:01:02.188]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.188]                     cond$call), session = sessionInformation(), 
[17:01:02.188]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.188]                   signalCondition(cond)
[17:01:02.188]                 }
[17:01:02.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.188]                 "immediateCondition"))) {
[17:01:02.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.188]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.188]                   if (TRUE && !signal) {
[17:01:02.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.188]                     {
[17:01:02.188]                       inherits <- base::inherits
[17:01:02.188]                       invokeRestart <- base::invokeRestart
[17:01:02.188]                       is.null <- base::is.null
[17:01:02.188]                       muffled <- FALSE
[17:01:02.188]                       if (inherits(cond, "message")) {
[17:01:02.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.188]                         if (muffled) 
[17:01:02.188]                           invokeRestart("muffleMessage")
[17:01:02.188]                       }
[17:01:02.188]                       else if (inherits(cond, "warning")) {
[17:01:02.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.188]                         if (muffled) 
[17:01:02.188]                           invokeRestart("muffleWarning")
[17:01:02.188]                       }
[17:01:02.188]                       else if (inherits(cond, "condition")) {
[17:01:02.188]                         if (!is.null(pattern)) {
[17:01:02.188]                           computeRestarts <- base::computeRestarts
[17:01:02.188]                           grepl <- base::grepl
[17:01:02.188]                           restarts <- computeRestarts(cond)
[17:01:02.188]                           for (restart in restarts) {
[17:01:02.188]                             name <- restart$name
[17:01:02.188]                             if (is.null(name)) 
[17:01:02.188]                               next
[17:01:02.188]                             if (!grepl(pattern, name)) 
[17:01:02.188]                               next
[17:01:02.188]                             invokeRestart(restart)
[17:01:02.188]                             muffled <- TRUE
[17:01:02.188]                             break
[17:01:02.188]                           }
[17:01:02.188]                         }
[17:01:02.188]                       }
[17:01:02.188]                       invisible(muffled)
[17:01:02.188]                     }
[17:01:02.188]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.188]                   }
[17:01:02.188]                 }
[17:01:02.188]                 else {
[17:01:02.188]                   if (TRUE) {
[17:01:02.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.188]                     {
[17:01:02.188]                       inherits <- base::inherits
[17:01:02.188]                       invokeRestart <- base::invokeRestart
[17:01:02.188]                       is.null <- base::is.null
[17:01:02.188]                       muffled <- FALSE
[17:01:02.188]                       if (inherits(cond, "message")) {
[17:01:02.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.188]                         if (muffled) 
[17:01:02.188]                           invokeRestart("muffleMessage")
[17:01:02.188]                       }
[17:01:02.188]                       else if (inherits(cond, "warning")) {
[17:01:02.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.188]                         if (muffled) 
[17:01:02.188]                           invokeRestart("muffleWarning")
[17:01:02.188]                       }
[17:01:02.188]                       else if (inherits(cond, "condition")) {
[17:01:02.188]                         if (!is.null(pattern)) {
[17:01:02.188]                           computeRestarts <- base::computeRestarts
[17:01:02.188]                           grepl <- base::grepl
[17:01:02.188]                           restarts <- computeRestarts(cond)
[17:01:02.188]                           for (restart in restarts) {
[17:01:02.188]                             name <- restart$name
[17:01:02.188]                             if (is.null(name)) 
[17:01:02.188]                               next
[17:01:02.188]                             if (!grepl(pattern, name)) 
[17:01:02.188]                               next
[17:01:02.188]                             invokeRestart(restart)
[17:01:02.188]                             muffled <- TRUE
[17:01:02.188]                             break
[17:01:02.188]                           }
[17:01:02.188]                         }
[17:01:02.188]                       }
[17:01:02.188]                       invisible(muffled)
[17:01:02.188]                     }
[17:01:02.188]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.188]                   }
[17:01:02.188]                 }
[17:01:02.188]             }
[17:01:02.188]         }))
[17:01:02.188]     }, error = function(ex) {
[17:01:02.188]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.188]                 ...future.rng), started = ...future.startTime, 
[17:01:02.188]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.188]             version = "1.8"), class = "FutureResult")
[17:01:02.188]     }, finally = {
[17:01:02.188]         if (!identical(...future.workdir, getwd())) 
[17:01:02.188]             setwd(...future.workdir)
[17:01:02.188]         {
[17:01:02.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.188]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.188]             }
[17:01:02.188]             base::options(...future.oldOptions)
[17:01:02.188]             if (.Platform$OS.type == "windows") {
[17:01:02.188]                 old_names <- names(...future.oldEnvVars)
[17:01:02.188]                 envs <- base::Sys.getenv()
[17:01:02.188]                 names <- names(envs)
[17:01:02.188]                 common <- intersect(names, old_names)
[17:01:02.188]                 added <- setdiff(names, old_names)
[17:01:02.188]                 removed <- setdiff(old_names, names)
[17:01:02.188]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.188]                   envs[common]]
[17:01:02.188]                 NAMES <- toupper(changed)
[17:01:02.188]                 args <- list()
[17:01:02.188]                 for (kk in seq_along(NAMES)) {
[17:01:02.188]                   name <- changed[[kk]]
[17:01:02.188]                   NAME <- NAMES[[kk]]
[17:01:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.188]                     next
[17:01:02.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.188]                 }
[17:01:02.188]                 NAMES <- toupper(added)
[17:01:02.188]                 for (kk in seq_along(NAMES)) {
[17:01:02.188]                   name <- added[[kk]]
[17:01:02.188]                   NAME <- NAMES[[kk]]
[17:01:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.188]                     next
[17:01:02.188]                   args[[name]] <- ""
[17:01:02.188]                 }
[17:01:02.188]                 NAMES <- toupper(removed)
[17:01:02.188]                 for (kk in seq_along(NAMES)) {
[17:01:02.188]                   name <- removed[[kk]]
[17:01:02.188]                   NAME <- NAMES[[kk]]
[17:01:02.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.188]                     next
[17:01:02.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.188]                 }
[17:01:02.188]                 if (length(args) > 0) 
[17:01:02.188]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.188]             }
[17:01:02.188]             else {
[17:01:02.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.188]             }
[17:01:02.188]             {
[17:01:02.188]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.188]                   0L) {
[17:01:02.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.188]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.188]                   base::options(opts)
[17:01:02.188]                 }
[17:01:02.188]                 {
[17:01:02.188]                   {
[17:01:02.188]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.188]                     NULL
[17:01:02.188]                   }
[17:01:02.188]                   options(future.plan = NULL)
[17:01:02.188]                   if (is.na(NA_character_)) 
[17:01:02.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.188]                     .init = FALSE)
[17:01:02.188]                 }
[17:01:02.188]             }
[17:01:02.188]         }
[17:01:02.188]     })
[17:01:02.188]     if (TRUE) {
[17:01:02.188]         base::sink(type = "output", split = FALSE)
[17:01:02.188]         if (TRUE) {
[17:01:02.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.188]         }
[17:01:02.188]         else {
[17:01:02.188]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.188]         }
[17:01:02.188]         base::close(...future.stdout)
[17:01:02.188]         ...future.stdout <- NULL
[17:01:02.188]     }
[17:01:02.188]     ...future.result$conditions <- ...future.conditions
[17:01:02.188]     ...future.result$finished <- base::Sys.time()
[17:01:02.188]     ...future.result
[17:01:02.188] }
[17:01:02.191] assign_globals() ...
[17:01:02.191] List of 11
[17:01:02.191]  $ ...future.FUN            :function (x, ...)  
[17:01:02.191]  $ x_FUN                    :function (x)  
[17:01:02.191]  $ times                    : int 0
[17:01:02.191]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.191]  $ stop_if_not              :function (...)  
[17:01:02.191]  $ dim                      : NULL
[17:01:02.191]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:02.191]  $ future.call.arguments    : list()
[17:01:02.191]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.191]  $ ...future.elements_ii    :List of 5
[17:01:02.191]   ..$ : int 1
[17:01:02.191]   ..$ : int 2
[17:01:02.191]   ..$ : int 3
[17:01:02.191]   ..$ : int 4
[17:01:02.191]   ..$ : int 5
[17:01:02.191]  $ ...future.seeds_ii       : NULL
[17:01:02.191]  $ ...future.globals.maxSize: NULL
[17:01:02.191]  - attr(*, "where")=List of 11
[17:01:02.191]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.191]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.191]  - attr(*, "resolved")= logi FALSE
[17:01:02.191]  - attr(*, "total_size")= num 95400
[17:01:02.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.191]  - attr(*, "already-done")= logi TRUE
[17:01:02.202] - copied ‘...future.FUN’ to environment
[17:01:02.202] - reassign environment for ‘x_FUN’
[17:01:02.202] - copied ‘x_FUN’ to environment
[17:01:02.202] - copied ‘times’ to environment
[17:01:02.202] - copied ‘stopf’ to environment
[17:01:02.202] - copied ‘stop_if_not’ to environment
[17:01:02.202] - copied ‘dim’ to environment
[17:01:02.203] - copied ‘valid_types’ to environment
[17:01:02.203] - copied ‘future.call.arguments’ to environment
[17:01:02.203] - copied ‘...future.elements_ii’ to environment
[17:01:02.203] - copied ‘...future.seeds_ii’ to environment
[17:01:02.203] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.203] assign_globals() ... done
[17:01:02.203] requestCore(): workers = 2
[17:01:02.205] MulticoreFuture started
[17:01:02.206] - Launch lazy future ... done
[17:01:02.206] run() for ‘MulticoreFuture’ ... done
[17:01:02.207] Created future:
[17:01:02.207] plan(): Setting new future strategy stack:
[17:01:02.208] List of future strategies:
[17:01:02.208] 1. sequential:
[17:01:02.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.208]    - tweaked: FALSE
[17:01:02.208]    - call: NULL
[17:01:02.209] plan(): nbrOfWorkers() = 1
[17:01:02.211] plan(): Setting new future strategy stack:
[17:01:02.211] List of future strategies:
[17:01:02.211] 1. multicore:
[17:01:02.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.211]    - tweaked: FALSE
[17:01:02.211]    - call: plan(strategy)
[17:01:02.216] plan(): nbrOfWorkers() = 2
[17:01:02.207] MulticoreFuture:
[17:01:02.207] Label: ‘future_vapply-1’
[17:01:02.207] Expression:
[17:01:02.207] {
[17:01:02.207]     do.call(function(...) {
[17:01:02.207]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.207]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.207]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.207]             on.exit(options(oopts), add = TRUE)
[17:01:02.207]         }
[17:01:02.207]         {
[17:01:02.207]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.207]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.207]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.207]             })
[17:01:02.207]         }
[17:01:02.207]     }, args = future.call.arguments)
[17:01:02.207] }
[17:01:02.207] Lazy evaluation: FALSE
[17:01:02.207] Asynchronous evaluation: TRUE
[17:01:02.207] Local evaluation: TRUE
[17:01:02.207] Environment: R_GlobalEnv
[17:01:02.207] Capture standard output: TRUE
[17:01:02.207] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.207] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.207] Packages: 1 packages (‘future.apply’)
[17:01:02.207] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.207] Resolved: TRUE
[17:01:02.207] Value: <not collected>
[17:01:02.207] Conditions captured: <none>
[17:01:02.207] Early signaling: FALSE
[17:01:02.207] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.207] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.218] Chunk #1 of 2 ... DONE
[17:01:02.218] Chunk #2 of 2 ...
[17:01:02.218]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.218] getGlobalsAndPackages() ...
[17:01:02.218] Searching for globals...
[17:01:02.219] 
[17:01:02.219] Searching for globals ... DONE
[17:01:02.219] - globals: [0] <none>
[17:01:02.219] getGlobalsAndPackages() ... DONE
[17:01:02.219]    + additional globals found: [n=0] 
[17:01:02.219]    + additional namespaces needed: [n=0] 
[17:01:02.220]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.220]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.220]  - seeds: <none>
[17:01:02.220]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.220] getGlobalsAndPackages() ...
[17:01:02.220] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.221] Resolving globals: FALSE
[17:01:02.221] Tweak future expression to call with '...' arguments ...
[17:01:02.221] {
[17:01:02.221]     do.call(function(...) {
[17:01:02.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.221]             on.exit(options(oopts), add = TRUE)
[17:01:02.221]         }
[17:01:02.221]         {
[17:01:02.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.221]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.221]             })
[17:01:02.221]         }
[17:01:02.221]     }, args = future.call.arguments)
[17:01:02.221] }
[17:01:02.221] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.222] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.222] - packages: [1] ‘future.apply’
[17:01:02.223] getGlobalsAndPackages() ... DONE
[17:01:02.223] run() for ‘Future’ ...
[17:01:02.223] - state: ‘created’
[17:01:02.224] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.228]   - Field: ‘label’
[17:01:02.229]   - Field: ‘local’
[17:01:02.229]   - Field: ‘owner’
[17:01:02.229]   - Field: ‘envir’
[17:01:02.229]   - Field: ‘workers’
[17:01:02.229]   - Field: ‘packages’
[17:01:02.229]   - Field: ‘gc’
[17:01:02.229]   - Field: ‘job’
[17:01:02.230]   - Field: ‘conditions’
[17:01:02.230]   - Field: ‘expr’
[17:01:02.230]   - Field: ‘uuid’
[17:01:02.230]   - Field: ‘seed’
[17:01:02.230]   - Field: ‘version’
[17:01:02.230]   - Field: ‘result’
[17:01:02.230]   - Field: ‘asynchronous’
[17:01:02.231]   - Field: ‘calls’
[17:01:02.231]   - Field: ‘globals’
[17:01:02.231]   - Field: ‘stdout’
[17:01:02.231]   - Field: ‘earlySignal’
[17:01:02.231]   - Field: ‘lazy’
[17:01:02.231]   - Field: ‘state’
[17:01:02.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.232] - Launch lazy future ...
[17:01:02.232] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.232] Packages needed by future strategies (n = 0): <none>
[17:01:02.233] {
[17:01:02.233]     {
[17:01:02.233]         {
[17:01:02.233]             ...future.startTime <- base::Sys.time()
[17:01:02.233]             {
[17:01:02.233]                 {
[17:01:02.233]                   {
[17:01:02.233]                     {
[17:01:02.233]                       {
[17:01:02.233]                         base::local({
[17:01:02.233]                           has_future <- base::requireNamespace("future", 
[17:01:02.233]                             quietly = TRUE)
[17:01:02.233]                           if (has_future) {
[17:01:02.233]                             ns <- base::getNamespace("future")
[17:01:02.233]                             version <- ns[[".package"]][["version"]]
[17:01:02.233]                             if (is.null(version)) 
[17:01:02.233]                               version <- utils::packageVersion("future")
[17:01:02.233]                           }
[17:01:02.233]                           else {
[17:01:02.233]                             version <- NULL
[17:01:02.233]                           }
[17:01:02.233]                           if (!has_future || version < "1.8.0") {
[17:01:02.233]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.233]                               "", base::R.version$version.string), 
[17:01:02.233]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.233]                                 base::R.version$platform, 8 * 
[17:01:02.233]                                   base::.Machine$sizeof.pointer), 
[17:01:02.233]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.233]                                 "release", "version")], collapse = " "), 
[17:01:02.233]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.233]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.233]                               info)
[17:01:02.233]                             info <- base::paste(info, collapse = "; ")
[17:01:02.233]                             if (!has_future) {
[17:01:02.233]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.233]                                 info)
[17:01:02.233]                             }
[17:01:02.233]                             else {
[17:01:02.233]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.233]                                 info, version)
[17:01:02.233]                             }
[17:01:02.233]                             base::stop(msg)
[17:01:02.233]                           }
[17:01:02.233]                         })
[17:01:02.233]                       }
[17:01:02.233]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.233]                       base::options(mc.cores = 1L)
[17:01:02.233]                     }
[17:01:02.233]                     base::local({
[17:01:02.233]                       for (pkg in "future.apply") {
[17:01:02.233]                         base::loadNamespace(pkg)
[17:01:02.233]                         base::library(pkg, character.only = TRUE)
[17:01:02.233]                       }
[17:01:02.233]                     })
[17:01:02.233]                   }
[17:01:02.233]                   ...future.strategy.old <- future::plan("list")
[17:01:02.233]                   options(future.plan = NULL)
[17:01:02.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.233]                 }
[17:01:02.233]                 ...future.workdir <- getwd()
[17:01:02.233]             }
[17:01:02.233]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.233]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.233]         }
[17:01:02.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.233]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.233]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.233]             base::names(...future.oldOptions))
[17:01:02.233]     }
[17:01:02.233]     if (FALSE) {
[17:01:02.233]     }
[17:01:02.233]     else {
[17:01:02.233]         if (TRUE) {
[17:01:02.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.233]                 open = "w")
[17:01:02.233]         }
[17:01:02.233]         else {
[17:01:02.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.233]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.233]         }
[17:01:02.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.233]             base::sink(type = "output", split = FALSE)
[17:01:02.233]             base::close(...future.stdout)
[17:01:02.233]         }, add = TRUE)
[17:01:02.233]     }
[17:01:02.233]     ...future.frame <- base::sys.nframe()
[17:01:02.233]     ...future.conditions <- base::list()
[17:01:02.233]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.233]     if (FALSE) {
[17:01:02.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.233]     }
[17:01:02.233]     ...future.result <- base::tryCatch({
[17:01:02.233]         base::withCallingHandlers({
[17:01:02.233]             ...future.value <- base::withVisible(base::local({
[17:01:02.233]                 withCallingHandlers({
[17:01:02.233]                   {
[17:01:02.233]                     do.call(function(...) {
[17:01:02.233]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.233]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.233]                         ...future.globals.maxSize)) {
[17:01:02.233]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.233]                         on.exit(options(oopts), add = TRUE)
[17:01:02.233]                       }
[17:01:02.233]                       {
[17:01:02.233]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.233]                           FUN = function(jj) {
[17:01:02.233]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.233]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.233]                           })
[17:01:02.233]                       }
[17:01:02.233]                     }, args = future.call.arguments)
[17:01:02.233]                   }
[17:01:02.233]                 }, immediateCondition = function(cond) {
[17:01:02.233]                   save_rds <- function (object, pathname, ...) 
[17:01:02.233]                   {
[17:01:02.233]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.233]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.233]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.233]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.233]                         fi_tmp[["mtime"]])
[17:01:02.233]                     }
[17:01:02.233]                     tryCatch({
[17:01:02.233]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.233]                     }, error = function(ex) {
[17:01:02.233]                       msg <- conditionMessage(ex)
[17:01:02.233]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.233]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.233]                         fi_tmp[["mtime"]], msg)
[17:01:02.233]                       ex$message <- msg
[17:01:02.233]                       stop(ex)
[17:01:02.233]                     })
[17:01:02.233]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.233]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.233]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.233]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.233]                       fi <- file.info(pathname)
[17:01:02.233]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.233]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.233]                         fi[["size"]], fi[["mtime"]])
[17:01:02.233]                       stop(msg)
[17:01:02.233]                     }
[17:01:02.233]                     invisible(pathname)
[17:01:02.233]                   }
[17:01:02.233]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.233]                     rootPath = tempdir()) 
[17:01:02.233]                   {
[17:01:02.233]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.233]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.233]                       tmpdir = path, fileext = ".rds")
[17:01:02.233]                     save_rds(obj, file)
[17:01:02.233]                   }
[17:01:02.233]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.233]                   {
[17:01:02.233]                     inherits <- base::inherits
[17:01:02.233]                     invokeRestart <- base::invokeRestart
[17:01:02.233]                     is.null <- base::is.null
[17:01:02.233]                     muffled <- FALSE
[17:01:02.233]                     if (inherits(cond, "message")) {
[17:01:02.233]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.233]                       if (muffled) 
[17:01:02.233]                         invokeRestart("muffleMessage")
[17:01:02.233]                     }
[17:01:02.233]                     else if (inherits(cond, "warning")) {
[17:01:02.233]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.233]                       if (muffled) 
[17:01:02.233]                         invokeRestart("muffleWarning")
[17:01:02.233]                     }
[17:01:02.233]                     else if (inherits(cond, "condition")) {
[17:01:02.233]                       if (!is.null(pattern)) {
[17:01:02.233]                         computeRestarts <- base::computeRestarts
[17:01:02.233]                         grepl <- base::grepl
[17:01:02.233]                         restarts <- computeRestarts(cond)
[17:01:02.233]                         for (restart in restarts) {
[17:01:02.233]                           name <- restart$name
[17:01:02.233]                           if (is.null(name)) 
[17:01:02.233]                             next
[17:01:02.233]                           if (!grepl(pattern, name)) 
[17:01:02.233]                             next
[17:01:02.233]                           invokeRestart(restart)
[17:01:02.233]                           muffled <- TRUE
[17:01:02.233]                           break
[17:01:02.233]                         }
[17:01:02.233]                       }
[17:01:02.233]                     }
[17:01:02.233]                     invisible(muffled)
[17:01:02.233]                   }
[17:01:02.233]                   muffleCondition(cond)
[17:01:02.233]                 })
[17:01:02.233]             }))
[17:01:02.233]             future::FutureResult(value = ...future.value$value, 
[17:01:02.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.233]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.233]                     ...future.globalenv.names))
[17:01:02.233]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.233]         }, condition = base::local({
[17:01:02.233]             c <- base::c
[17:01:02.233]             inherits <- base::inherits
[17:01:02.233]             invokeRestart <- base::invokeRestart
[17:01:02.233]             length <- base::length
[17:01:02.233]             list <- base::list
[17:01:02.233]             seq.int <- base::seq.int
[17:01:02.233]             signalCondition <- base::signalCondition
[17:01:02.233]             sys.calls <- base::sys.calls
[17:01:02.233]             `[[` <- base::`[[`
[17:01:02.233]             `+` <- base::`+`
[17:01:02.233]             `<<-` <- base::`<<-`
[17:01:02.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.233]                   3L)]
[17:01:02.233]             }
[17:01:02.233]             function(cond) {
[17:01:02.233]                 is_error <- inherits(cond, "error")
[17:01:02.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.233]                   NULL)
[17:01:02.233]                 if (is_error) {
[17:01:02.233]                   sessionInformation <- function() {
[17:01:02.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.233]                       search = base::search(), system = base::Sys.info())
[17:01:02.233]                   }
[17:01:02.233]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.233]                     cond$call), session = sessionInformation(), 
[17:01:02.233]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.233]                   signalCondition(cond)
[17:01:02.233]                 }
[17:01:02.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.233]                 "immediateCondition"))) {
[17:01:02.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.233]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.233]                   if (TRUE && !signal) {
[17:01:02.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.233]                     {
[17:01:02.233]                       inherits <- base::inherits
[17:01:02.233]                       invokeRestart <- base::invokeRestart
[17:01:02.233]                       is.null <- base::is.null
[17:01:02.233]                       muffled <- FALSE
[17:01:02.233]                       if (inherits(cond, "message")) {
[17:01:02.233]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.233]                         if (muffled) 
[17:01:02.233]                           invokeRestart("muffleMessage")
[17:01:02.233]                       }
[17:01:02.233]                       else if (inherits(cond, "warning")) {
[17:01:02.233]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.233]                         if (muffled) 
[17:01:02.233]                           invokeRestart("muffleWarning")
[17:01:02.233]                       }
[17:01:02.233]                       else if (inherits(cond, "condition")) {
[17:01:02.233]                         if (!is.null(pattern)) {
[17:01:02.233]                           computeRestarts <- base::computeRestarts
[17:01:02.233]                           grepl <- base::grepl
[17:01:02.233]                           restarts <- computeRestarts(cond)
[17:01:02.233]                           for (restart in restarts) {
[17:01:02.233]                             name <- restart$name
[17:01:02.233]                             if (is.null(name)) 
[17:01:02.233]                               next
[17:01:02.233]                             if (!grepl(pattern, name)) 
[17:01:02.233]                               next
[17:01:02.233]                             invokeRestart(restart)
[17:01:02.233]                             muffled <- TRUE
[17:01:02.233]                             break
[17:01:02.233]                           }
[17:01:02.233]                         }
[17:01:02.233]                       }
[17:01:02.233]                       invisible(muffled)
[17:01:02.233]                     }
[17:01:02.233]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.233]                   }
[17:01:02.233]                 }
[17:01:02.233]                 else {
[17:01:02.233]                   if (TRUE) {
[17:01:02.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.233]                     {
[17:01:02.233]                       inherits <- base::inherits
[17:01:02.233]                       invokeRestart <- base::invokeRestart
[17:01:02.233]                       is.null <- base::is.null
[17:01:02.233]                       muffled <- FALSE
[17:01:02.233]                       if (inherits(cond, "message")) {
[17:01:02.233]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.233]                         if (muffled) 
[17:01:02.233]                           invokeRestart("muffleMessage")
[17:01:02.233]                       }
[17:01:02.233]                       else if (inherits(cond, "warning")) {
[17:01:02.233]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.233]                         if (muffled) 
[17:01:02.233]                           invokeRestart("muffleWarning")
[17:01:02.233]                       }
[17:01:02.233]                       else if (inherits(cond, "condition")) {
[17:01:02.233]                         if (!is.null(pattern)) {
[17:01:02.233]                           computeRestarts <- base::computeRestarts
[17:01:02.233]                           grepl <- base::grepl
[17:01:02.233]                           restarts <- computeRestarts(cond)
[17:01:02.233]                           for (restart in restarts) {
[17:01:02.233]                             name <- restart$name
[17:01:02.233]                             if (is.null(name)) 
[17:01:02.233]                               next
[17:01:02.233]                             if (!grepl(pattern, name)) 
[17:01:02.233]                               next
[17:01:02.233]                             invokeRestart(restart)
[17:01:02.233]                             muffled <- TRUE
[17:01:02.233]                             break
[17:01:02.233]                           }
[17:01:02.233]                         }
[17:01:02.233]                       }
[17:01:02.233]                       invisible(muffled)
[17:01:02.233]                     }
[17:01:02.233]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.233]                   }
[17:01:02.233]                 }
[17:01:02.233]             }
[17:01:02.233]         }))
[17:01:02.233]     }, error = function(ex) {
[17:01:02.233]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.233]                 ...future.rng), started = ...future.startTime, 
[17:01:02.233]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.233]             version = "1.8"), class = "FutureResult")
[17:01:02.233]     }, finally = {
[17:01:02.233]         if (!identical(...future.workdir, getwd())) 
[17:01:02.233]             setwd(...future.workdir)
[17:01:02.233]         {
[17:01:02.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.233]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.233]             }
[17:01:02.233]             base::options(...future.oldOptions)
[17:01:02.233]             if (.Platform$OS.type == "windows") {
[17:01:02.233]                 old_names <- names(...future.oldEnvVars)
[17:01:02.233]                 envs <- base::Sys.getenv()
[17:01:02.233]                 names <- names(envs)
[17:01:02.233]                 common <- intersect(names, old_names)
[17:01:02.233]                 added <- setdiff(names, old_names)
[17:01:02.233]                 removed <- setdiff(old_names, names)
[17:01:02.233]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.233]                   envs[common]]
[17:01:02.233]                 NAMES <- toupper(changed)
[17:01:02.233]                 args <- list()
[17:01:02.233]                 for (kk in seq_along(NAMES)) {
[17:01:02.233]                   name <- changed[[kk]]
[17:01:02.233]                   NAME <- NAMES[[kk]]
[17:01:02.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.233]                     next
[17:01:02.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.233]                 }
[17:01:02.233]                 NAMES <- toupper(added)
[17:01:02.233]                 for (kk in seq_along(NAMES)) {
[17:01:02.233]                   name <- added[[kk]]
[17:01:02.233]                   NAME <- NAMES[[kk]]
[17:01:02.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.233]                     next
[17:01:02.233]                   args[[name]] <- ""
[17:01:02.233]                 }
[17:01:02.233]                 NAMES <- toupper(removed)
[17:01:02.233]                 for (kk in seq_along(NAMES)) {
[17:01:02.233]                   name <- removed[[kk]]
[17:01:02.233]                   NAME <- NAMES[[kk]]
[17:01:02.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.233]                     next
[17:01:02.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.233]                 }
[17:01:02.233]                 if (length(args) > 0) 
[17:01:02.233]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.233]             }
[17:01:02.233]             else {
[17:01:02.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.233]             }
[17:01:02.233]             {
[17:01:02.233]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.233]                   0L) {
[17:01:02.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.233]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.233]                   base::options(opts)
[17:01:02.233]                 }
[17:01:02.233]                 {
[17:01:02.233]                   {
[17:01:02.233]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.233]                     NULL
[17:01:02.233]                   }
[17:01:02.233]                   options(future.plan = NULL)
[17:01:02.233]                   if (is.na(NA_character_)) 
[17:01:02.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.233]                     .init = FALSE)
[17:01:02.233]                 }
[17:01:02.233]             }
[17:01:02.233]         }
[17:01:02.233]     })
[17:01:02.233]     if (TRUE) {
[17:01:02.233]         base::sink(type = "output", split = FALSE)
[17:01:02.233]         if (TRUE) {
[17:01:02.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.233]         }
[17:01:02.233]         else {
[17:01:02.233]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.233]         }
[17:01:02.233]         base::close(...future.stdout)
[17:01:02.233]         ...future.stdout <- NULL
[17:01:02.233]     }
[17:01:02.233]     ...future.result$conditions <- ...future.conditions
[17:01:02.233]     ...future.result$finished <- base::Sys.time()
[17:01:02.233]     ...future.result
[17:01:02.233] }
[17:01:02.237] assign_globals() ...
[17:01:02.237] List of 11
[17:01:02.237]  $ ...future.FUN            :function (x, ...)  
[17:01:02.237]  $ x_FUN                    :function (x)  
[17:01:02.237]  $ times                    : int 0
[17:01:02.237]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.237]  $ stop_if_not              :function (...)  
[17:01:02.237]  $ dim                      : NULL
[17:01:02.237]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:02.237]  $ future.call.arguments    : list()
[17:01:02.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.237]  $ ...future.elements_ii    :List of 5
[17:01:02.237]   ..$ : int 6
[17:01:02.237]   ..$ : int 7
[17:01:02.237]   ..$ : int 8
[17:01:02.237]   ..$ : int 9
[17:01:02.237]   ..$ : int 10
[17:01:02.237]  $ ...future.seeds_ii       : NULL
[17:01:02.237]  $ ...future.globals.maxSize: NULL
[17:01:02.237]  - attr(*, "where")=List of 11
[17:01:02.237]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.237]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.237]  - attr(*, "resolved")= logi FALSE
[17:01:02.237]  - attr(*, "total_size")= num 95400
[17:01:02.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.237]  - attr(*, "already-done")= logi TRUE
[17:01:02.253] - copied ‘...future.FUN’ to environment
[17:01:02.254] - reassign environment for ‘x_FUN’
[17:01:02.254] - copied ‘x_FUN’ to environment
[17:01:02.254] - copied ‘times’ to environment
[17:01:02.254] - copied ‘stopf’ to environment
[17:01:02.254] - copied ‘stop_if_not’ to environment
[17:01:02.254] - copied ‘dim’ to environment
[17:01:02.254] - copied ‘valid_types’ to environment
[17:01:02.255] - copied ‘future.call.arguments’ to environment
[17:01:02.255] - copied ‘...future.elements_ii’ to environment
[17:01:02.255] - copied ‘...future.seeds_ii’ to environment
[17:01:02.255] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.255] assign_globals() ... done
[17:01:02.255] requestCore(): workers = 2
[17:01:02.258] MulticoreFuture started
[17:01:02.258] - Launch lazy future ... done
[17:01:02.259] run() for ‘MulticoreFuture’ ... done
[17:01:02.259] Created future:
[17:01:02.260] plan(): Setting new future strategy stack:
[17:01:02.260] List of future strategies:
[17:01:02.260] 1. sequential:
[17:01:02.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.260]    - tweaked: FALSE
[17:01:02.260]    - call: NULL
[17:01:02.261] plan(): nbrOfWorkers() = 1
[17:01:02.263] plan(): Setting new future strategy stack:
[17:01:02.263] List of future strategies:
[17:01:02.263] 1. multicore:
[17:01:02.263]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.263]    - tweaked: FALSE
[17:01:02.263]    - call: plan(strategy)
[17:01:02.269] plan(): nbrOfWorkers() = 2
[17:01:02.259] MulticoreFuture:
[17:01:02.259] Label: ‘future_vapply-2’
[17:01:02.259] Expression:
[17:01:02.259] {
[17:01:02.259]     do.call(function(...) {
[17:01:02.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.259]             on.exit(options(oopts), add = TRUE)
[17:01:02.259]         }
[17:01:02.259]         {
[17:01:02.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.259]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.259]             })
[17:01:02.259]         }
[17:01:02.259]     }, args = future.call.arguments)
[17:01:02.259] }
[17:01:02.259] Lazy evaluation: FALSE
[17:01:02.259] Asynchronous evaluation: TRUE
[17:01:02.259] Local evaluation: TRUE
[17:01:02.259] Environment: R_GlobalEnv
[17:01:02.259] Capture standard output: TRUE
[17:01:02.259] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.259] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.259] Packages: 1 packages (‘future.apply’)
[17:01:02.259] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.259] Resolved: TRUE
[17:01:02.259] Value: <not collected>
[17:01:02.259] Conditions captured: <none>
[17:01:02.259] Early signaling: FALSE
[17:01:02.259] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.259] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.270] Chunk #2 of 2 ... DONE
[17:01:02.270] Launching 2 futures (chunks) ... DONE
[17:01:02.270] Resolving 2 futures (chunks) ...
[17:01:02.270] resolve() on list ...
[17:01:02.270]  recursive: 0
[17:01:02.271]  length: 2
[17:01:02.271] 
[17:01:02.271] Future #1
[17:01:02.271] result() for MulticoreFuture ...
[17:01:02.272] result() for MulticoreFuture ...
[17:01:02.272] result() for MulticoreFuture ... done
[17:01:02.272] result() for MulticoreFuture ... done
[17:01:02.273] result() for MulticoreFuture ...
[17:01:02.273] result() for MulticoreFuture ... done
[17:01:02.273] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.273] - nx: 2
[17:01:02.273] - relay: TRUE
[17:01:02.273] - stdout: TRUE
[17:01:02.273] - signal: TRUE
[17:01:02.273] - resignal: FALSE
[17:01:02.274] - force: TRUE
[17:01:02.274] - relayed: [n=2] FALSE, FALSE
[17:01:02.274] - queued futures: [n=2] FALSE, FALSE
[17:01:02.274]  - until=1
[17:01:02.274]  - relaying element #1
[17:01:02.274] result() for MulticoreFuture ...
[17:01:02.274] result() for MulticoreFuture ... done
[17:01:02.275] result() for MulticoreFuture ...
[17:01:02.275] result() for MulticoreFuture ... done
[17:01:02.275] result() for MulticoreFuture ...
[17:01:02.275] result() for MulticoreFuture ... done
[17:01:02.275] result() for MulticoreFuture ...
[17:01:02.275] result() for MulticoreFuture ... done
[17:01:02.276] - relayed: [n=2] TRUE, FALSE
[17:01:02.276] - queued futures: [n=2] TRUE, FALSE
[17:01:02.276] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.276]  length: 1 (resolved future 1)
[17:01:02.276] Future #2
[17:01:02.277] result() for MulticoreFuture ...
[17:01:02.277] result() for MulticoreFuture ...
[17:01:02.278] result() for MulticoreFuture ... done
[17:01:02.278] result() for MulticoreFuture ... done
[17:01:02.278] result() for MulticoreFuture ...
[17:01:02.278] result() for MulticoreFuture ... done
[17:01:02.278] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.279] - nx: 2
[17:01:02.279] - relay: TRUE
[17:01:02.279] - stdout: TRUE
[17:01:02.279] - signal: TRUE
[17:01:02.279] - resignal: FALSE
[17:01:02.279] - force: TRUE
[17:01:02.280] - relayed: [n=2] TRUE, FALSE
[17:01:02.280] - queued futures: [n=2] TRUE, FALSE
[17:01:02.280]  - until=2
[17:01:02.280]  - relaying element #2
[17:01:02.280] result() for MulticoreFuture ...
[17:01:02.280] result() for MulticoreFuture ... done
[17:01:02.281] result() for MulticoreFuture ...
[17:01:02.281] result() for MulticoreFuture ... done
[17:01:02.281] result() for MulticoreFuture ...
[17:01:02.281] result() for MulticoreFuture ... done
[17:01:02.281] result() for MulticoreFuture ...
[17:01:02.281] result() for MulticoreFuture ... done
[17:01:02.281] - relayed: [n=2] TRUE, TRUE
[17:01:02.281] - queued futures: [n=2] TRUE, TRUE
[17:01:02.281] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.282]  length: 0 (resolved future 2)
[17:01:02.282] Relaying remaining futures
[17:01:02.282] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.282] - nx: 2
[17:01:02.282] - relay: TRUE
[17:01:02.282] - stdout: TRUE
[17:01:02.282] - signal: TRUE
[17:01:02.282] - resignal: FALSE
[17:01:02.282] - force: TRUE
[17:01:02.283] - relayed: [n=2] TRUE, TRUE
[17:01:02.283] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.283] - relayed: [n=2] TRUE, TRUE
[17:01:02.283] - queued futures: [n=2] TRUE, TRUE
[17:01:02.283] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.283] resolve() on list ... DONE
[17:01:02.283] result() for MulticoreFuture ...
[17:01:02.283] result() for MulticoreFuture ... done
[17:01:02.284] result() for MulticoreFuture ...
[17:01:02.284] result() for MulticoreFuture ... done
[17:01:02.284] result() for MulticoreFuture ...
[17:01:02.284] result() for MulticoreFuture ... done
[17:01:02.284] result() for MulticoreFuture ...
[17:01:02.284] result() for MulticoreFuture ... done
[17:01:02.284]  - Number of value chunks collected: 2
[17:01:02.284] Resolving 2 futures (chunks) ... DONE
[17:01:02.284] Reducing values from 2 chunks ...
[17:01:02.285]  - Number of values collected after concatenation: 10
[17:01:02.285]  - Number of values expected: 10
[17:01:02.285] Reducing values from 2 chunks ... DONE
[17:01:02.285] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:01:02.286] future_lapply() ...
[17:01:02.292] Number of chunks: 2
[17:01:02.293] getGlobalsAndPackagesXApply() ...
[17:01:02.293]  - future.globals: TRUE
[17:01:02.293] getGlobalsAndPackages() ...
[17:01:02.293] Searching for globals...
[17:01:02.300] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:02.300] Searching for globals ... DONE
[17:01:02.300] Resolving globals: FALSE
[17:01:02.301] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:01:02.302] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.302] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.302] - packages: [1] ‘future.apply’
[17:01:02.302] getGlobalsAndPackages() ... DONE
[17:01:02.302]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.302]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.302] Finding globals ... DONE
[17:01:02.302]  - use_args: TRUE
[17:01:02.303]  - Getting '...' globals ...
[17:01:02.303] resolve() on list ...
[17:01:02.303]  recursive: 0
[17:01:02.303]  length: 1
[17:01:02.303]  elements: ‘...’
[17:01:02.303]  length: 0 (resolved future 1)
[17:01:02.303] resolve() on list ... DONE
[17:01:02.304]    - '...' content: [n=0] 
[17:01:02.304] List of 1
[17:01:02.304]  $ ...: list()
[17:01:02.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.304]  - attr(*, "where")=List of 1
[17:01:02.304]   ..$ ...:<environment: 0x55aadb5090e0> 
[17:01:02.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.304]  - attr(*, "resolved")= logi TRUE
[17:01:02.304]  - attr(*, "total_size")= num NA
[17:01:02.306]  - Getting '...' globals ... DONE
[17:01:02.306] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.307] List of 8
[17:01:02.307]  $ ...future.FUN:function (x, ...)  
[17:01:02.307]  $ x_FUN        :function (x)  
[17:01:02.307]  $ times        : int 1
[17:01:02.307]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.307]  $ stop_if_not  :function (...)  
[17:01:02.307]  $ dim          : NULL
[17:01:02.307]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.307]  $ ...          : list()
[17:01:02.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.307]  - attr(*, "where")=List of 8
[17:01:02.307]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.307]   ..$ ...          :<environment: 0x55aadb5090e0> 
[17:01:02.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.307]  - attr(*, "resolved")= logi FALSE
[17:01:02.307]  - attr(*, "total_size")= num 94336
[17:01:02.312] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.312] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.312] Number of futures (= number of chunks): 2
[17:01:02.312] Launching 2 futures (chunks) ...
[17:01:02.312] Chunk #1 of 2 ...
[17:01:02.313]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.313] getGlobalsAndPackages() ...
[17:01:02.313] Searching for globals...
[17:01:02.313] 
[17:01:02.313] Searching for globals ... DONE
[17:01:02.313] - globals: [0] <none>
[17:01:02.313] getGlobalsAndPackages() ... DONE
[17:01:02.313]    + additional globals found: [n=0] 
[17:01:02.314]    + additional namespaces needed: [n=0] 
[17:01:02.314]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.314]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.314]  - seeds: <none>
[17:01:02.314]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.314] getGlobalsAndPackages() ...
[17:01:02.314] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.314] Resolving globals: FALSE
[17:01:02.314] Tweak future expression to call with '...' arguments ...
[17:01:02.314] {
[17:01:02.314]     do.call(function(...) {
[17:01:02.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.314]             on.exit(options(oopts), add = TRUE)
[17:01:02.314]         }
[17:01:02.314]         {
[17:01:02.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.314]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.314]             })
[17:01:02.314]         }
[17:01:02.314]     }, args = future.call.arguments)
[17:01:02.314] }
[17:01:02.315] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.315] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.315] - packages: [1] ‘future.apply’
[17:01:02.316] getGlobalsAndPackages() ... DONE
[17:01:02.316] run() for ‘Future’ ...
[17:01:02.316] - state: ‘created’
[17:01:02.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.320]   - Field: ‘label’
[17:01:02.320]   - Field: ‘local’
[17:01:02.320]   - Field: ‘owner’
[17:01:02.321]   - Field: ‘envir’
[17:01:02.321]   - Field: ‘workers’
[17:01:02.321]   - Field: ‘packages’
[17:01:02.321]   - Field: ‘gc’
[17:01:02.323]   - Field: ‘job’
[17:01:02.323]   - Field: ‘conditions’
[17:01:02.323]   - Field: ‘expr’
[17:01:02.323]   - Field: ‘uuid’
[17:01:02.323]   - Field: ‘seed’
[17:01:02.324]   - Field: ‘version’
[17:01:02.324]   - Field: ‘result’
[17:01:02.324]   - Field: ‘asynchronous’
[17:01:02.324]   - Field: ‘calls’
[17:01:02.324]   - Field: ‘globals’
[17:01:02.324]   - Field: ‘stdout’
[17:01:02.324]   - Field: ‘earlySignal’
[17:01:02.324]   - Field: ‘lazy’
[17:01:02.324]   - Field: ‘state’
[17:01:02.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.325] - Launch lazy future ...
[17:01:02.325] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.325] Packages needed by future strategies (n = 0): <none>
[17:01:02.326] {
[17:01:02.326]     {
[17:01:02.326]         {
[17:01:02.326]             ...future.startTime <- base::Sys.time()
[17:01:02.326]             {
[17:01:02.326]                 {
[17:01:02.326]                   {
[17:01:02.326]                     {
[17:01:02.326]                       {
[17:01:02.326]                         base::local({
[17:01:02.326]                           has_future <- base::requireNamespace("future", 
[17:01:02.326]                             quietly = TRUE)
[17:01:02.326]                           if (has_future) {
[17:01:02.326]                             ns <- base::getNamespace("future")
[17:01:02.326]                             version <- ns[[".package"]][["version"]]
[17:01:02.326]                             if (is.null(version)) 
[17:01:02.326]                               version <- utils::packageVersion("future")
[17:01:02.326]                           }
[17:01:02.326]                           else {
[17:01:02.326]                             version <- NULL
[17:01:02.326]                           }
[17:01:02.326]                           if (!has_future || version < "1.8.0") {
[17:01:02.326]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.326]                               "", base::R.version$version.string), 
[17:01:02.326]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.326]                                 base::R.version$platform, 8 * 
[17:01:02.326]                                   base::.Machine$sizeof.pointer), 
[17:01:02.326]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.326]                                 "release", "version")], collapse = " "), 
[17:01:02.326]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.326]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.326]                               info)
[17:01:02.326]                             info <- base::paste(info, collapse = "; ")
[17:01:02.326]                             if (!has_future) {
[17:01:02.326]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.326]                                 info)
[17:01:02.326]                             }
[17:01:02.326]                             else {
[17:01:02.326]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.326]                                 info, version)
[17:01:02.326]                             }
[17:01:02.326]                             base::stop(msg)
[17:01:02.326]                           }
[17:01:02.326]                         })
[17:01:02.326]                       }
[17:01:02.326]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.326]                       base::options(mc.cores = 1L)
[17:01:02.326]                     }
[17:01:02.326]                     base::local({
[17:01:02.326]                       for (pkg in "future.apply") {
[17:01:02.326]                         base::loadNamespace(pkg)
[17:01:02.326]                         base::library(pkg, character.only = TRUE)
[17:01:02.326]                       }
[17:01:02.326]                     })
[17:01:02.326]                   }
[17:01:02.326]                   ...future.strategy.old <- future::plan("list")
[17:01:02.326]                   options(future.plan = NULL)
[17:01:02.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.326]                 }
[17:01:02.326]                 ...future.workdir <- getwd()
[17:01:02.326]             }
[17:01:02.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.326]         }
[17:01:02.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.326]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.326]             base::names(...future.oldOptions))
[17:01:02.326]     }
[17:01:02.326]     if (FALSE) {
[17:01:02.326]     }
[17:01:02.326]     else {
[17:01:02.326]         if (TRUE) {
[17:01:02.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.326]                 open = "w")
[17:01:02.326]         }
[17:01:02.326]         else {
[17:01:02.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.326]         }
[17:01:02.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.326]             base::sink(type = "output", split = FALSE)
[17:01:02.326]             base::close(...future.stdout)
[17:01:02.326]         }, add = TRUE)
[17:01:02.326]     }
[17:01:02.326]     ...future.frame <- base::sys.nframe()
[17:01:02.326]     ...future.conditions <- base::list()
[17:01:02.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.326]     if (FALSE) {
[17:01:02.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.326]     }
[17:01:02.326]     ...future.result <- base::tryCatch({
[17:01:02.326]         base::withCallingHandlers({
[17:01:02.326]             ...future.value <- base::withVisible(base::local({
[17:01:02.326]                 withCallingHandlers({
[17:01:02.326]                   {
[17:01:02.326]                     do.call(function(...) {
[17:01:02.326]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.326]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.326]                         ...future.globals.maxSize)) {
[17:01:02.326]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.326]                         on.exit(options(oopts), add = TRUE)
[17:01:02.326]                       }
[17:01:02.326]                       {
[17:01:02.326]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.326]                           FUN = function(jj) {
[17:01:02.326]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.326]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.326]                           })
[17:01:02.326]                       }
[17:01:02.326]                     }, args = future.call.arguments)
[17:01:02.326]                   }
[17:01:02.326]                 }, immediateCondition = function(cond) {
[17:01:02.326]                   save_rds <- function (object, pathname, ...) 
[17:01:02.326]                   {
[17:01:02.326]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.326]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.326]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.326]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.326]                         fi_tmp[["mtime"]])
[17:01:02.326]                     }
[17:01:02.326]                     tryCatch({
[17:01:02.326]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.326]                     }, error = function(ex) {
[17:01:02.326]                       msg <- conditionMessage(ex)
[17:01:02.326]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.326]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.326]                         fi_tmp[["mtime"]], msg)
[17:01:02.326]                       ex$message <- msg
[17:01:02.326]                       stop(ex)
[17:01:02.326]                     })
[17:01:02.326]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.326]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.326]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.326]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.326]                       fi <- file.info(pathname)
[17:01:02.326]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.326]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.326]                         fi[["size"]], fi[["mtime"]])
[17:01:02.326]                       stop(msg)
[17:01:02.326]                     }
[17:01:02.326]                     invisible(pathname)
[17:01:02.326]                   }
[17:01:02.326]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.326]                     rootPath = tempdir()) 
[17:01:02.326]                   {
[17:01:02.326]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.326]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.326]                       tmpdir = path, fileext = ".rds")
[17:01:02.326]                     save_rds(obj, file)
[17:01:02.326]                   }
[17:01:02.326]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.326]                   {
[17:01:02.326]                     inherits <- base::inherits
[17:01:02.326]                     invokeRestart <- base::invokeRestart
[17:01:02.326]                     is.null <- base::is.null
[17:01:02.326]                     muffled <- FALSE
[17:01:02.326]                     if (inherits(cond, "message")) {
[17:01:02.326]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.326]                       if (muffled) 
[17:01:02.326]                         invokeRestart("muffleMessage")
[17:01:02.326]                     }
[17:01:02.326]                     else if (inherits(cond, "warning")) {
[17:01:02.326]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.326]                       if (muffled) 
[17:01:02.326]                         invokeRestart("muffleWarning")
[17:01:02.326]                     }
[17:01:02.326]                     else if (inherits(cond, "condition")) {
[17:01:02.326]                       if (!is.null(pattern)) {
[17:01:02.326]                         computeRestarts <- base::computeRestarts
[17:01:02.326]                         grepl <- base::grepl
[17:01:02.326]                         restarts <- computeRestarts(cond)
[17:01:02.326]                         for (restart in restarts) {
[17:01:02.326]                           name <- restart$name
[17:01:02.326]                           if (is.null(name)) 
[17:01:02.326]                             next
[17:01:02.326]                           if (!grepl(pattern, name)) 
[17:01:02.326]                             next
[17:01:02.326]                           invokeRestart(restart)
[17:01:02.326]                           muffled <- TRUE
[17:01:02.326]                           break
[17:01:02.326]                         }
[17:01:02.326]                       }
[17:01:02.326]                     }
[17:01:02.326]                     invisible(muffled)
[17:01:02.326]                   }
[17:01:02.326]                   muffleCondition(cond)
[17:01:02.326]                 })
[17:01:02.326]             }))
[17:01:02.326]             future::FutureResult(value = ...future.value$value, 
[17:01:02.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.326]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.326]                     ...future.globalenv.names))
[17:01:02.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.326]         }, condition = base::local({
[17:01:02.326]             c <- base::c
[17:01:02.326]             inherits <- base::inherits
[17:01:02.326]             invokeRestart <- base::invokeRestart
[17:01:02.326]             length <- base::length
[17:01:02.326]             list <- base::list
[17:01:02.326]             seq.int <- base::seq.int
[17:01:02.326]             signalCondition <- base::signalCondition
[17:01:02.326]             sys.calls <- base::sys.calls
[17:01:02.326]             `[[` <- base::`[[`
[17:01:02.326]             `+` <- base::`+`
[17:01:02.326]             `<<-` <- base::`<<-`
[17:01:02.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.326]                   3L)]
[17:01:02.326]             }
[17:01:02.326]             function(cond) {
[17:01:02.326]                 is_error <- inherits(cond, "error")
[17:01:02.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.326]                   NULL)
[17:01:02.326]                 if (is_error) {
[17:01:02.326]                   sessionInformation <- function() {
[17:01:02.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.326]                       search = base::search(), system = base::Sys.info())
[17:01:02.326]                   }
[17:01:02.326]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.326]                     cond$call), session = sessionInformation(), 
[17:01:02.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.326]                   signalCondition(cond)
[17:01:02.326]                 }
[17:01:02.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.326]                 "immediateCondition"))) {
[17:01:02.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.326]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.326]                   if (TRUE && !signal) {
[17:01:02.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.326]                     {
[17:01:02.326]                       inherits <- base::inherits
[17:01:02.326]                       invokeRestart <- base::invokeRestart
[17:01:02.326]                       is.null <- base::is.null
[17:01:02.326]                       muffled <- FALSE
[17:01:02.326]                       if (inherits(cond, "message")) {
[17:01:02.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.326]                         if (muffled) 
[17:01:02.326]                           invokeRestart("muffleMessage")
[17:01:02.326]                       }
[17:01:02.326]                       else if (inherits(cond, "warning")) {
[17:01:02.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.326]                         if (muffled) 
[17:01:02.326]                           invokeRestart("muffleWarning")
[17:01:02.326]                       }
[17:01:02.326]                       else if (inherits(cond, "condition")) {
[17:01:02.326]                         if (!is.null(pattern)) {
[17:01:02.326]                           computeRestarts <- base::computeRestarts
[17:01:02.326]                           grepl <- base::grepl
[17:01:02.326]                           restarts <- computeRestarts(cond)
[17:01:02.326]                           for (restart in restarts) {
[17:01:02.326]                             name <- restart$name
[17:01:02.326]                             if (is.null(name)) 
[17:01:02.326]                               next
[17:01:02.326]                             if (!grepl(pattern, name)) 
[17:01:02.326]                               next
[17:01:02.326]                             invokeRestart(restart)
[17:01:02.326]                             muffled <- TRUE
[17:01:02.326]                             break
[17:01:02.326]                           }
[17:01:02.326]                         }
[17:01:02.326]                       }
[17:01:02.326]                       invisible(muffled)
[17:01:02.326]                     }
[17:01:02.326]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.326]                   }
[17:01:02.326]                 }
[17:01:02.326]                 else {
[17:01:02.326]                   if (TRUE) {
[17:01:02.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.326]                     {
[17:01:02.326]                       inherits <- base::inherits
[17:01:02.326]                       invokeRestart <- base::invokeRestart
[17:01:02.326]                       is.null <- base::is.null
[17:01:02.326]                       muffled <- FALSE
[17:01:02.326]                       if (inherits(cond, "message")) {
[17:01:02.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.326]                         if (muffled) 
[17:01:02.326]                           invokeRestart("muffleMessage")
[17:01:02.326]                       }
[17:01:02.326]                       else if (inherits(cond, "warning")) {
[17:01:02.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.326]                         if (muffled) 
[17:01:02.326]                           invokeRestart("muffleWarning")
[17:01:02.326]                       }
[17:01:02.326]                       else if (inherits(cond, "condition")) {
[17:01:02.326]                         if (!is.null(pattern)) {
[17:01:02.326]                           computeRestarts <- base::computeRestarts
[17:01:02.326]                           grepl <- base::grepl
[17:01:02.326]                           restarts <- computeRestarts(cond)
[17:01:02.326]                           for (restart in restarts) {
[17:01:02.326]                             name <- restart$name
[17:01:02.326]                             if (is.null(name)) 
[17:01:02.326]                               next
[17:01:02.326]                             if (!grepl(pattern, name)) 
[17:01:02.326]                               next
[17:01:02.326]                             invokeRestart(restart)
[17:01:02.326]                             muffled <- TRUE
[17:01:02.326]                             break
[17:01:02.326]                           }
[17:01:02.326]                         }
[17:01:02.326]                       }
[17:01:02.326]                       invisible(muffled)
[17:01:02.326]                     }
[17:01:02.326]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.326]                   }
[17:01:02.326]                 }
[17:01:02.326]             }
[17:01:02.326]         }))
[17:01:02.326]     }, error = function(ex) {
[17:01:02.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.326]                 ...future.rng), started = ...future.startTime, 
[17:01:02.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.326]             version = "1.8"), class = "FutureResult")
[17:01:02.326]     }, finally = {
[17:01:02.326]         if (!identical(...future.workdir, getwd())) 
[17:01:02.326]             setwd(...future.workdir)
[17:01:02.326]         {
[17:01:02.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.326]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.326]             }
[17:01:02.326]             base::options(...future.oldOptions)
[17:01:02.326]             if (.Platform$OS.type == "windows") {
[17:01:02.326]                 old_names <- names(...future.oldEnvVars)
[17:01:02.326]                 envs <- base::Sys.getenv()
[17:01:02.326]                 names <- names(envs)
[17:01:02.326]                 common <- intersect(names, old_names)
[17:01:02.326]                 added <- setdiff(names, old_names)
[17:01:02.326]                 removed <- setdiff(old_names, names)
[17:01:02.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.326]                   envs[common]]
[17:01:02.326]                 NAMES <- toupper(changed)
[17:01:02.326]                 args <- list()
[17:01:02.326]                 for (kk in seq_along(NAMES)) {
[17:01:02.326]                   name <- changed[[kk]]
[17:01:02.326]                   NAME <- NAMES[[kk]]
[17:01:02.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.326]                     next
[17:01:02.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.326]                 }
[17:01:02.326]                 NAMES <- toupper(added)
[17:01:02.326]                 for (kk in seq_along(NAMES)) {
[17:01:02.326]                   name <- added[[kk]]
[17:01:02.326]                   NAME <- NAMES[[kk]]
[17:01:02.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.326]                     next
[17:01:02.326]                   args[[name]] <- ""
[17:01:02.326]                 }
[17:01:02.326]                 NAMES <- toupper(removed)
[17:01:02.326]                 for (kk in seq_along(NAMES)) {
[17:01:02.326]                   name <- removed[[kk]]
[17:01:02.326]                   NAME <- NAMES[[kk]]
[17:01:02.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.326]                     next
[17:01:02.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.326]                 }
[17:01:02.326]                 if (length(args) > 0) 
[17:01:02.326]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.326]             }
[17:01:02.326]             else {
[17:01:02.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.326]             }
[17:01:02.326]             {
[17:01:02.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.326]                   0L) {
[17:01:02.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.326]                   base::options(opts)
[17:01:02.326]                 }
[17:01:02.326]                 {
[17:01:02.326]                   {
[17:01:02.326]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.326]                     NULL
[17:01:02.326]                   }
[17:01:02.326]                   options(future.plan = NULL)
[17:01:02.326]                   if (is.na(NA_character_)) 
[17:01:02.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.326]                     .init = FALSE)
[17:01:02.326]                 }
[17:01:02.326]             }
[17:01:02.326]         }
[17:01:02.326]     })
[17:01:02.326]     if (TRUE) {
[17:01:02.326]         base::sink(type = "output", split = FALSE)
[17:01:02.326]         if (TRUE) {
[17:01:02.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.326]         }
[17:01:02.326]         else {
[17:01:02.326]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.326]         }
[17:01:02.326]         base::close(...future.stdout)
[17:01:02.326]         ...future.stdout <- NULL
[17:01:02.326]     }
[17:01:02.326]     ...future.result$conditions <- ...future.conditions
[17:01:02.326]     ...future.result$finished <- base::Sys.time()
[17:01:02.326]     ...future.result
[17:01:02.326] }
[17:01:02.328] assign_globals() ...
[17:01:02.329] List of 11
[17:01:02.329]  $ ...future.FUN            :function (x, ...)  
[17:01:02.329]  $ x_FUN                    :function (x)  
[17:01:02.329]  $ times                    : int 1
[17:01:02.329]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.329]  $ stop_if_not              :function (...)  
[17:01:02.329]  $ dim                      : NULL
[17:01:02.329]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.329]  $ future.call.arguments    : list()
[17:01:02.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.329]  $ ...future.elements_ii    :List of 5
[17:01:02.329]   ..$ : int 1
[17:01:02.329]   ..$ : int 2
[17:01:02.329]   ..$ : int 3
[17:01:02.329]   ..$ : int 4
[17:01:02.329]   ..$ : int 5
[17:01:02.329]  $ ...future.seeds_ii       : NULL
[17:01:02.329]  $ ...future.globals.maxSize: NULL
[17:01:02.329]  - attr(*, "where")=List of 11
[17:01:02.329]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.329]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.329]  - attr(*, "resolved")= logi FALSE
[17:01:02.329]  - attr(*, "total_size")= num 94336
[17:01:02.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.329]  - attr(*, "already-done")= logi TRUE
[17:01:02.337] - copied ‘...future.FUN’ to environment
[17:01:02.337] - copied ‘x_FUN’ to environment
[17:01:02.337] - copied ‘times’ to environment
[17:01:02.338] - copied ‘stopf’ to environment
[17:01:02.338] - copied ‘stop_if_not’ to environment
[17:01:02.338] - copied ‘dim’ to environment
[17:01:02.338] - copied ‘valid_types’ to environment
[17:01:02.338] - copied ‘future.call.arguments’ to environment
[17:01:02.338] - copied ‘...future.elements_ii’ to environment
[17:01:02.338] - copied ‘...future.seeds_ii’ to environment
[17:01:02.338] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.338] assign_globals() ... done
[17:01:02.339] requestCore(): workers = 2
[17:01:02.341] MulticoreFuture started
[17:01:02.341] - Launch lazy future ... done
[17:01:02.341] run() for ‘MulticoreFuture’ ... done
[17:01:02.342] Created future:
[17:01:02.342] plan(): Setting new future strategy stack:
[17:01:02.343] List of future strategies:
[17:01:02.343] 1. sequential:
[17:01:02.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.343]    - tweaked: FALSE
[17:01:02.343]    - call: NULL
[17:01:02.343] plan(): nbrOfWorkers() = 1
[17:01:02.346] plan(): Setting new future strategy stack:
[17:01:02.346] List of future strategies:
[17:01:02.346] 1. multicore:
[17:01:02.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.346]    - tweaked: FALSE
[17:01:02.346]    - call: plan(strategy)
[17:01:02.351] plan(): nbrOfWorkers() = 2
[17:01:02.342] MulticoreFuture:
[17:01:02.342] Label: ‘future_vapply-1’
[17:01:02.342] Expression:
[17:01:02.342] {
[17:01:02.342]     do.call(function(...) {
[17:01:02.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.342]             on.exit(options(oopts), add = TRUE)
[17:01:02.342]         }
[17:01:02.342]         {
[17:01:02.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.342]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.342]             })
[17:01:02.342]         }
[17:01:02.342]     }, args = future.call.arguments)
[17:01:02.342] }
[17:01:02.342] Lazy evaluation: FALSE
[17:01:02.342] Asynchronous evaluation: TRUE
[17:01:02.342] Local evaluation: TRUE
[17:01:02.342] Environment: R_GlobalEnv
[17:01:02.342] Capture standard output: TRUE
[17:01:02.342] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.342] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.342] Packages: 1 packages (‘future.apply’)
[17:01:02.342] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.342] Resolved: TRUE
[17:01:02.342] Value: <not collected>
[17:01:02.342] Conditions captured: <none>
[17:01:02.342] Early signaling: FALSE
[17:01:02.342] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.342] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.353] Chunk #1 of 2 ... DONE
[17:01:02.353] Chunk #2 of 2 ...
[17:01:02.353]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.353] getGlobalsAndPackages() ...
[17:01:02.353] Searching for globals...
[17:01:02.354] 
[17:01:02.354] Searching for globals ... DONE
[17:01:02.354] - globals: [0] <none>
[17:01:02.354] getGlobalsAndPackages() ... DONE
[17:01:02.354]    + additional globals found: [n=0] 
[17:01:02.354]    + additional namespaces needed: [n=0] 
[17:01:02.354]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.355]  - seeds: <none>
[17:01:02.355]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.355] getGlobalsAndPackages() ...
[17:01:02.355] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.355] Resolving globals: FALSE
[17:01:02.355] Tweak future expression to call with '...' arguments ...
[17:01:02.356] {
[17:01:02.356]     do.call(function(...) {
[17:01:02.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.356]             on.exit(options(oopts), add = TRUE)
[17:01:02.356]         }
[17:01:02.356]         {
[17:01:02.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.356]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.356]             })
[17:01:02.356]         }
[17:01:02.356]     }, args = future.call.arguments)
[17:01:02.356] }
[17:01:02.356] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.357] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.357] - packages: [1] ‘future.apply’
[17:01:02.357] getGlobalsAndPackages() ... DONE
[17:01:02.358] run() for ‘Future’ ...
[17:01:02.358] - state: ‘created’
[17:01:02.358] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.363]   - Field: ‘label’
[17:01:02.363]   - Field: ‘local’
[17:01:02.364]   - Field: ‘owner’
[17:01:02.364]   - Field: ‘envir’
[17:01:02.364]   - Field: ‘workers’
[17:01:02.364]   - Field: ‘packages’
[17:01:02.364]   - Field: ‘gc’
[17:01:02.367]   - Field: ‘job’
[17:01:02.368]   - Field: ‘conditions’
[17:01:02.368]   - Field: ‘expr’
[17:01:02.369]   - Field: ‘uuid’
[17:01:02.369]   - Field: ‘seed’
[17:01:02.369]   - Field: ‘version’
[17:01:02.370]   - Field: ‘result’
[17:01:02.370]   - Field: ‘asynchronous’
[17:01:02.370]   - Field: ‘calls’
[17:01:02.370]   - Field: ‘globals’
[17:01:02.371]   - Field: ‘stdout’
[17:01:02.371]   - Field: ‘earlySignal’
[17:01:02.371]   - Field: ‘lazy’
[17:01:02.371]   - Field: ‘state’
[17:01:02.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.372] - Launch lazy future ...
[17:01:02.373] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.373] Packages needed by future strategies (n = 0): <none>
[17:01:02.374] {
[17:01:02.374]     {
[17:01:02.374]         {
[17:01:02.374]             ...future.startTime <- base::Sys.time()
[17:01:02.374]             {
[17:01:02.374]                 {
[17:01:02.374]                   {
[17:01:02.374]                     {
[17:01:02.374]                       {
[17:01:02.374]                         base::local({
[17:01:02.374]                           has_future <- base::requireNamespace("future", 
[17:01:02.374]                             quietly = TRUE)
[17:01:02.374]                           if (has_future) {
[17:01:02.374]                             ns <- base::getNamespace("future")
[17:01:02.374]                             version <- ns[[".package"]][["version"]]
[17:01:02.374]                             if (is.null(version)) 
[17:01:02.374]                               version <- utils::packageVersion("future")
[17:01:02.374]                           }
[17:01:02.374]                           else {
[17:01:02.374]                             version <- NULL
[17:01:02.374]                           }
[17:01:02.374]                           if (!has_future || version < "1.8.0") {
[17:01:02.374]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.374]                               "", base::R.version$version.string), 
[17:01:02.374]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.374]                                 base::R.version$platform, 8 * 
[17:01:02.374]                                   base::.Machine$sizeof.pointer), 
[17:01:02.374]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.374]                                 "release", "version")], collapse = " "), 
[17:01:02.374]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.374]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.374]                               info)
[17:01:02.374]                             info <- base::paste(info, collapse = "; ")
[17:01:02.374]                             if (!has_future) {
[17:01:02.374]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.374]                                 info)
[17:01:02.374]                             }
[17:01:02.374]                             else {
[17:01:02.374]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.374]                                 info, version)
[17:01:02.374]                             }
[17:01:02.374]                             base::stop(msg)
[17:01:02.374]                           }
[17:01:02.374]                         })
[17:01:02.374]                       }
[17:01:02.374]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.374]                       base::options(mc.cores = 1L)
[17:01:02.374]                     }
[17:01:02.374]                     base::local({
[17:01:02.374]                       for (pkg in "future.apply") {
[17:01:02.374]                         base::loadNamespace(pkg)
[17:01:02.374]                         base::library(pkg, character.only = TRUE)
[17:01:02.374]                       }
[17:01:02.374]                     })
[17:01:02.374]                   }
[17:01:02.374]                   ...future.strategy.old <- future::plan("list")
[17:01:02.374]                   options(future.plan = NULL)
[17:01:02.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.374]                 }
[17:01:02.374]                 ...future.workdir <- getwd()
[17:01:02.374]             }
[17:01:02.374]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.374]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.374]         }
[17:01:02.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.374]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.374]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.374]             base::names(...future.oldOptions))
[17:01:02.374]     }
[17:01:02.374]     if (FALSE) {
[17:01:02.374]     }
[17:01:02.374]     else {
[17:01:02.374]         if (TRUE) {
[17:01:02.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.374]                 open = "w")
[17:01:02.374]         }
[17:01:02.374]         else {
[17:01:02.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.374]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.374]         }
[17:01:02.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.374]             base::sink(type = "output", split = FALSE)
[17:01:02.374]             base::close(...future.stdout)
[17:01:02.374]         }, add = TRUE)
[17:01:02.374]     }
[17:01:02.374]     ...future.frame <- base::sys.nframe()
[17:01:02.374]     ...future.conditions <- base::list()
[17:01:02.374]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.374]     if (FALSE) {
[17:01:02.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.374]     }
[17:01:02.374]     ...future.result <- base::tryCatch({
[17:01:02.374]         base::withCallingHandlers({
[17:01:02.374]             ...future.value <- base::withVisible(base::local({
[17:01:02.374]                 withCallingHandlers({
[17:01:02.374]                   {
[17:01:02.374]                     do.call(function(...) {
[17:01:02.374]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.374]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.374]                         ...future.globals.maxSize)) {
[17:01:02.374]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.374]                         on.exit(options(oopts), add = TRUE)
[17:01:02.374]                       }
[17:01:02.374]                       {
[17:01:02.374]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.374]                           FUN = function(jj) {
[17:01:02.374]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.374]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.374]                           })
[17:01:02.374]                       }
[17:01:02.374]                     }, args = future.call.arguments)
[17:01:02.374]                   }
[17:01:02.374]                 }, immediateCondition = function(cond) {
[17:01:02.374]                   save_rds <- function (object, pathname, ...) 
[17:01:02.374]                   {
[17:01:02.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.374]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.374]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.374]                         fi_tmp[["mtime"]])
[17:01:02.374]                     }
[17:01:02.374]                     tryCatch({
[17:01:02.374]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.374]                     }, error = function(ex) {
[17:01:02.374]                       msg <- conditionMessage(ex)
[17:01:02.374]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.374]                         fi_tmp[["mtime"]], msg)
[17:01:02.374]                       ex$message <- msg
[17:01:02.374]                       stop(ex)
[17:01:02.374]                     })
[17:01:02.374]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.374]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.374]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.374]                       fi <- file.info(pathname)
[17:01:02.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.374]                         fi[["size"]], fi[["mtime"]])
[17:01:02.374]                       stop(msg)
[17:01:02.374]                     }
[17:01:02.374]                     invisible(pathname)
[17:01:02.374]                   }
[17:01:02.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.374]                     rootPath = tempdir()) 
[17:01:02.374]                   {
[17:01:02.374]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.374]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.374]                       tmpdir = path, fileext = ".rds")
[17:01:02.374]                     save_rds(obj, file)
[17:01:02.374]                   }
[17:01:02.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.374]                   {
[17:01:02.374]                     inherits <- base::inherits
[17:01:02.374]                     invokeRestart <- base::invokeRestart
[17:01:02.374]                     is.null <- base::is.null
[17:01:02.374]                     muffled <- FALSE
[17:01:02.374]                     if (inherits(cond, "message")) {
[17:01:02.374]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.374]                       if (muffled) 
[17:01:02.374]                         invokeRestart("muffleMessage")
[17:01:02.374]                     }
[17:01:02.374]                     else if (inherits(cond, "warning")) {
[17:01:02.374]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.374]                       if (muffled) 
[17:01:02.374]                         invokeRestart("muffleWarning")
[17:01:02.374]                     }
[17:01:02.374]                     else if (inherits(cond, "condition")) {
[17:01:02.374]                       if (!is.null(pattern)) {
[17:01:02.374]                         computeRestarts <- base::computeRestarts
[17:01:02.374]                         grepl <- base::grepl
[17:01:02.374]                         restarts <- computeRestarts(cond)
[17:01:02.374]                         for (restart in restarts) {
[17:01:02.374]                           name <- restart$name
[17:01:02.374]                           if (is.null(name)) 
[17:01:02.374]                             next
[17:01:02.374]                           if (!grepl(pattern, name)) 
[17:01:02.374]                             next
[17:01:02.374]                           invokeRestart(restart)
[17:01:02.374]                           muffled <- TRUE
[17:01:02.374]                           break
[17:01:02.374]                         }
[17:01:02.374]                       }
[17:01:02.374]                     }
[17:01:02.374]                     invisible(muffled)
[17:01:02.374]                   }
[17:01:02.374]                   muffleCondition(cond)
[17:01:02.374]                 })
[17:01:02.374]             }))
[17:01:02.374]             future::FutureResult(value = ...future.value$value, 
[17:01:02.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.374]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.374]                     ...future.globalenv.names))
[17:01:02.374]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.374]         }, condition = base::local({
[17:01:02.374]             c <- base::c
[17:01:02.374]             inherits <- base::inherits
[17:01:02.374]             invokeRestart <- base::invokeRestart
[17:01:02.374]             length <- base::length
[17:01:02.374]             list <- base::list
[17:01:02.374]             seq.int <- base::seq.int
[17:01:02.374]             signalCondition <- base::signalCondition
[17:01:02.374]             sys.calls <- base::sys.calls
[17:01:02.374]             `[[` <- base::`[[`
[17:01:02.374]             `+` <- base::`+`
[17:01:02.374]             `<<-` <- base::`<<-`
[17:01:02.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.374]                   3L)]
[17:01:02.374]             }
[17:01:02.374]             function(cond) {
[17:01:02.374]                 is_error <- inherits(cond, "error")
[17:01:02.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.374]                   NULL)
[17:01:02.374]                 if (is_error) {
[17:01:02.374]                   sessionInformation <- function() {
[17:01:02.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.374]                       search = base::search(), system = base::Sys.info())
[17:01:02.374]                   }
[17:01:02.374]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.374]                     cond$call), session = sessionInformation(), 
[17:01:02.374]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.374]                   signalCondition(cond)
[17:01:02.374]                 }
[17:01:02.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.374]                 "immediateCondition"))) {
[17:01:02.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.374]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.374]                   if (TRUE && !signal) {
[17:01:02.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.374]                     {
[17:01:02.374]                       inherits <- base::inherits
[17:01:02.374]                       invokeRestart <- base::invokeRestart
[17:01:02.374]                       is.null <- base::is.null
[17:01:02.374]                       muffled <- FALSE
[17:01:02.374]                       if (inherits(cond, "message")) {
[17:01:02.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.374]                         if (muffled) 
[17:01:02.374]                           invokeRestart("muffleMessage")
[17:01:02.374]                       }
[17:01:02.374]                       else if (inherits(cond, "warning")) {
[17:01:02.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.374]                         if (muffled) 
[17:01:02.374]                           invokeRestart("muffleWarning")
[17:01:02.374]                       }
[17:01:02.374]                       else if (inherits(cond, "condition")) {
[17:01:02.374]                         if (!is.null(pattern)) {
[17:01:02.374]                           computeRestarts <- base::computeRestarts
[17:01:02.374]                           grepl <- base::grepl
[17:01:02.374]                           restarts <- computeRestarts(cond)
[17:01:02.374]                           for (restart in restarts) {
[17:01:02.374]                             name <- restart$name
[17:01:02.374]                             if (is.null(name)) 
[17:01:02.374]                               next
[17:01:02.374]                             if (!grepl(pattern, name)) 
[17:01:02.374]                               next
[17:01:02.374]                             invokeRestart(restart)
[17:01:02.374]                             muffled <- TRUE
[17:01:02.374]                             break
[17:01:02.374]                           }
[17:01:02.374]                         }
[17:01:02.374]                       }
[17:01:02.374]                       invisible(muffled)
[17:01:02.374]                     }
[17:01:02.374]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.374]                   }
[17:01:02.374]                 }
[17:01:02.374]                 else {
[17:01:02.374]                   if (TRUE) {
[17:01:02.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.374]                     {
[17:01:02.374]                       inherits <- base::inherits
[17:01:02.374]                       invokeRestart <- base::invokeRestart
[17:01:02.374]                       is.null <- base::is.null
[17:01:02.374]                       muffled <- FALSE
[17:01:02.374]                       if (inherits(cond, "message")) {
[17:01:02.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.374]                         if (muffled) 
[17:01:02.374]                           invokeRestart("muffleMessage")
[17:01:02.374]                       }
[17:01:02.374]                       else if (inherits(cond, "warning")) {
[17:01:02.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.374]                         if (muffled) 
[17:01:02.374]                           invokeRestart("muffleWarning")
[17:01:02.374]                       }
[17:01:02.374]                       else if (inherits(cond, "condition")) {
[17:01:02.374]                         if (!is.null(pattern)) {
[17:01:02.374]                           computeRestarts <- base::computeRestarts
[17:01:02.374]                           grepl <- base::grepl
[17:01:02.374]                           restarts <- computeRestarts(cond)
[17:01:02.374]                           for (restart in restarts) {
[17:01:02.374]                             name <- restart$name
[17:01:02.374]                             if (is.null(name)) 
[17:01:02.374]                               next
[17:01:02.374]                             if (!grepl(pattern, name)) 
[17:01:02.374]                               next
[17:01:02.374]                             invokeRestart(restart)
[17:01:02.374]                             muffled <- TRUE
[17:01:02.374]                             break
[17:01:02.374]                           }
[17:01:02.374]                         }
[17:01:02.374]                       }
[17:01:02.374]                       invisible(muffled)
[17:01:02.374]                     }
[17:01:02.374]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.374]                   }
[17:01:02.374]                 }
[17:01:02.374]             }
[17:01:02.374]         }))
[17:01:02.374]     }, error = function(ex) {
[17:01:02.374]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.374]                 ...future.rng), started = ...future.startTime, 
[17:01:02.374]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.374]             version = "1.8"), class = "FutureResult")
[17:01:02.374]     }, finally = {
[17:01:02.374]         if (!identical(...future.workdir, getwd())) 
[17:01:02.374]             setwd(...future.workdir)
[17:01:02.374]         {
[17:01:02.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.374]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.374]             }
[17:01:02.374]             base::options(...future.oldOptions)
[17:01:02.374]             if (.Platform$OS.type == "windows") {
[17:01:02.374]                 old_names <- names(...future.oldEnvVars)
[17:01:02.374]                 envs <- base::Sys.getenv()
[17:01:02.374]                 names <- names(envs)
[17:01:02.374]                 common <- intersect(names, old_names)
[17:01:02.374]                 added <- setdiff(names, old_names)
[17:01:02.374]                 removed <- setdiff(old_names, names)
[17:01:02.374]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.374]                   envs[common]]
[17:01:02.374]                 NAMES <- toupper(changed)
[17:01:02.374]                 args <- list()
[17:01:02.374]                 for (kk in seq_along(NAMES)) {
[17:01:02.374]                   name <- changed[[kk]]
[17:01:02.374]                   NAME <- NAMES[[kk]]
[17:01:02.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.374]                     next
[17:01:02.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.374]                 }
[17:01:02.374]                 NAMES <- toupper(added)
[17:01:02.374]                 for (kk in seq_along(NAMES)) {
[17:01:02.374]                   name <- added[[kk]]
[17:01:02.374]                   NAME <- NAMES[[kk]]
[17:01:02.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.374]                     next
[17:01:02.374]                   args[[name]] <- ""
[17:01:02.374]                 }
[17:01:02.374]                 NAMES <- toupper(removed)
[17:01:02.374]                 for (kk in seq_along(NAMES)) {
[17:01:02.374]                   name <- removed[[kk]]
[17:01:02.374]                   NAME <- NAMES[[kk]]
[17:01:02.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.374]                     next
[17:01:02.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.374]                 }
[17:01:02.374]                 if (length(args) > 0) 
[17:01:02.374]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.374]             }
[17:01:02.374]             else {
[17:01:02.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.374]             }
[17:01:02.374]             {
[17:01:02.374]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.374]                   0L) {
[17:01:02.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.374]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.374]                   base::options(opts)
[17:01:02.374]                 }
[17:01:02.374]                 {
[17:01:02.374]                   {
[17:01:02.374]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.374]                     NULL
[17:01:02.374]                   }
[17:01:02.374]                   options(future.plan = NULL)
[17:01:02.374]                   if (is.na(NA_character_)) 
[17:01:02.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.374]                     .init = FALSE)
[17:01:02.374]                 }
[17:01:02.374]             }
[17:01:02.374]         }
[17:01:02.374]     })
[17:01:02.374]     if (TRUE) {
[17:01:02.374]         base::sink(type = "output", split = FALSE)
[17:01:02.374]         if (TRUE) {
[17:01:02.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.374]         }
[17:01:02.374]         else {
[17:01:02.374]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.374]         }
[17:01:02.374]         base::close(...future.stdout)
[17:01:02.374]         ...future.stdout <- NULL
[17:01:02.374]     }
[17:01:02.374]     ...future.result$conditions <- ...future.conditions
[17:01:02.374]     ...future.result$finished <- base::Sys.time()
[17:01:02.374]     ...future.result
[17:01:02.374] }
[17:01:02.377] assign_globals() ...
[17:01:02.377] List of 11
[17:01:02.377]  $ ...future.FUN            :function (x, ...)  
[17:01:02.377]  $ x_FUN                    :function (x)  
[17:01:02.377]  $ times                    : int 1
[17:01:02.377]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.377]  $ stop_if_not              :function (...)  
[17:01:02.377]  $ dim                      : NULL
[17:01:02.377]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.377]  $ future.call.arguments    : list()
[17:01:02.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.377]  $ ...future.elements_ii    :List of 5
[17:01:02.377]   ..$ : int 6
[17:01:02.377]   ..$ : int 7
[17:01:02.377]   ..$ : int 8
[17:01:02.377]   ..$ : int 9
[17:01:02.377]   ..$ : int 10
[17:01:02.377]  $ ...future.seeds_ii       : NULL
[17:01:02.377]  $ ...future.globals.maxSize: NULL
[17:01:02.377]  - attr(*, "where")=List of 11
[17:01:02.377]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.377]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.377]  - attr(*, "resolved")= logi FALSE
[17:01:02.377]  - attr(*, "total_size")= num 94336
[17:01:02.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.377]  - attr(*, "already-done")= logi TRUE
[17:01:02.389] - copied ‘...future.FUN’ to environment
[17:01:02.389] - copied ‘x_FUN’ to environment
[17:01:02.389] - copied ‘times’ to environment
[17:01:02.390] - copied ‘stopf’ to environment
[17:01:02.390] - copied ‘stop_if_not’ to environment
[17:01:02.390] - copied ‘dim’ to environment
[17:01:02.390] - copied ‘valid_types’ to environment
[17:01:02.390] - copied ‘future.call.arguments’ to environment
[17:01:02.390] - copied ‘...future.elements_ii’ to environment
[17:01:02.390] - copied ‘...future.seeds_ii’ to environment
[17:01:02.390] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.391] assign_globals() ... done
[17:01:02.391] requestCore(): workers = 2
[17:01:02.393] MulticoreFuture started
[17:01:02.393] - Launch lazy future ... done
[17:01:02.394] run() for ‘MulticoreFuture’ ... done
[17:01:02.394] Created future:
[17:01:02.394] plan(): Setting new future strategy stack:
[17:01:02.395] List of future strategies:
[17:01:02.395] 1. sequential:
[17:01:02.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.395]    - tweaked: FALSE
[17:01:02.395]    - call: NULL
[17:01:02.396] plan(): nbrOfWorkers() = 1
[17:01:02.398] plan(): Setting new future strategy stack:
[17:01:02.398] List of future strategies:
[17:01:02.398] 1. multicore:
[17:01:02.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.398]    - tweaked: FALSE
[17:01:02.398]    - call: plan(strategy)
[17:01:02.403] plan(): nbrOfWorkers() = 2
[17:01:02.394] MulticoreFuture:
[17:01:02.394] Label: ‘future_vapply-2’
[17:01:02.394] Expression:
[17:01:02.394] {
[17:01:02.394]     do.call(function(...) {
[17:01:02.394]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.394]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.394]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.394]             on.exit(options(oopts), add = TRUE)
[17:01:02.394]         }
[17:01:02.394]         {
[17:01:02.394]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.394]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.394]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.394]             })
[17:01:02.394]         }
[17:01:02.394]     }, args = future.call.arguments)
[17:01:02.394] }
[17:01:02.394] Lazy evaluation: FALSE
[17:01:02.394] Asynchronous evaluation: TRUE
[17:01:02.394] Local evaluation: TRUE
[17:01:02.394] Environment: R_GlobalEnv
[17:01:02.394] Capture standard output: TRUE
[17:01:02.394] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.394] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.394] Packages: 1 packages (‘future.apply’)
[17:01:02.394] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.394] Resolved: TRUE
[17:01:02.394] Value: <not collected>
[17:01:02.394] Conditions captured: <none>
[17:01:02.394] Early signaling: FALSE
[17:01:02.394] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.394] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.404] Chunk #2 of 2 ... DONE
[17:01:02.404] Launching 2 futures (chunks) ... DONE
[17:01:02.404] Resolving 2 futures (chunks) ...
[17:01:02.404] resolve() on list ...
[17:01:02.404]  recursive: 0
[17:01:02.405]  length: 2
[17:01:02.405] 
[17:01:02.405] Future #1
[17:01:02.405] result() for MulticoreFuture ...
[17:01:02.406] result() for MulticoreFuture ...
[17:01:02.406] result() for MulticoreFuture ... done
[17:01:02.406] result() for MulticoreFuture ... done
[17:01:02.406] result() for MulticoreFuture ...
[17:01:02.407] result() for MulticoreFuture ... done
[17:01:02.407] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.407] - nx: 2
[17:01:02.407] - relay: TRUE
[17:01:02.407] - stdout: TRUE
[17:01:02.407] - signal: TRUE
[17:01:02.407] - resignal: FALSE
[17:01:02.408] - force: TRUE
[17:01:02.408] - relayed: [n=2] FALSE, FALSE
[17:01:02.408] - queued futures: [n=2] FALSE, FALSE
[17:01:02.408]  - until=1
[17:01:02.408]  - relaying element #1
[17:01:02.408] result() for MulticoreFuture ...
[17:01:02.408] result() for MulticoreFuture ... done
[17:01:02.409] result() for MulticoreFuture ...
[17:01:02.409] result() for MulticoreFuture ... done
[17:01:02.409] result() for MulticoreFuture ...
[17:01:02.409] result() for MulticoreFuture ... done
[17:01:02.409] result() for MulticoreFuture ...
[17:01:02.409] result() for MulticoreFuture ... done
[17:01:02.409] - relayed: [n=2] TRUE, FALSE
[17:01:02.410] - queued futures: [n=2] TRUE, FALSE
[17:01:02.410] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.410]  length: 1 (resolved future 1)
[17:01:02.410] Future #2
[17:01:02.410] result() for MulticoreFuture ...
[17:01:02.411] result() for MulticoreFuture ...
[17:01:02.411] result() for MulticoreFuture ... done
[17:01:02.411] result() for MulticoreFuture ... done
[17:01:02.411] result() for MulticoreFuture ...
[17:01:02.412] result() for MulticoreFuture ... done
[17:01:02.412] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.412] - nx: 2
[17:01:02.412] - relay: TRUE
[17:01:02.412] - stdout: TRUE
[17:01:02.412] - signal: TRUE
[17:01:02.415] - resignal: FALSE
[17:01:02.415] - force: TRUE
[17:01:02.415] - relayed: [n=2] TRUE, FALSE
[17:01:02.416] - queued futures: [n=2] TRUE, FALSE
[17:01:02.416]  - until=2
[17:01:02.416]  - relaying element #2
[17:01:02.416] result() for MulticoreFuture ...
[17:01:02.416] result() for MulticoreFuture ... done
[17:01:02.417] result() for MulticoreFuture ...
[17:01:02.417] result() for MulticoreFuture ... done
[17:01:02.417] result() for MulticoreFuture ...
[17:01:02.417] result() for MulticoreFuture ... done
[17:01:02.417] result() for MulticoreFuture ...
[17:01:02.418] result() for MulticoreFuture ... done
[17:01:02.418] - relayed: [n=2] TRUE, TRUE
[17:01:02.418] - queued futures: [n=2] TRUE, TRUE
[17:01:02.418] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.418]  length: 0 (resolved future 2)
[17:01:02.418] Relaying remaining futures
[17:01:02.419] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.419] - nx: 2
[17:01:02.419] - relay: TRUE
[17:01:02.419] - stdout: TRUE
[17:01:02.419] - signal: TRUE
[17:01:02.419] - resignal: FALSE
[17:01:02.420] - force: TRUE
[17:01:02.420] - relayed: [n=2] TRUE, TRUE
[17:01:02.420] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.420] - relayed: [n=2] TRUE, TRUE
[17:01:02.420] - queued futures: [n=2] TRUE, TRUE
[17:01:02.420] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.421] resolve() on list ... DONE
[17:01:02.421] result() for MulticoreFuture ...
[17:01:02.421] result() for MulticoreFuture ... done
[17:01:02.421] result() for MulticoreFuture ...
[17:01:02.421] result() for MulticoreFuture ... done
[17:01:02.421] result() for MulticoreFuture ...
[17:01:02.421] result() for MulticoreFuture ... done
[17:01:02.421] result() for MulticoreFuture ...
[17:01:02.421] result() for MulticoreFuture ... done
[17:01:02.422]  - Number of value chunks collected: 2
[17:01:02.422] Resolving 2 futures (chunks) ... DONE
[17:01:02.422] Reducing values from 2 chunks ...
[17:01:02.422]  - Number of values collected after concatenation: 10
[17:01:02.422]  - Number of values expected: 10
[17:01:02.422] Reducing values from 2 chunks ... DONE
[17:01:02.422] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:01:02.423] future_lapply() ...
[17:01:02.430] Number of chunks: 2
[17:01:02.430] getGlobalsAndPackagesXApply() ...
[17:01:02.430]  - future.globals: TRUE
[17:01:02.430] getGlobalsAndPackages() ...
[17:01:02.430] Searching for globals...
[17:01:02.434] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:01:02.434] Searching for globals ... DONE
[17:01:02.435] Resolving globals: FALSE
[17:01:02.436] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:01:02.436] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.436] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.436] - packages: [1] ‘future.apply’
[17:01:02.436] getGlobalsAndPackages() ... DONE
[17:01:02.436]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.437]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.437] Finding globals ... DONE
[17:01:02.437]  - use_args: TRUE
[17:01:02.437]  - Getting '...' globals ...
[17:01:02.437] resolve() on list ...
[17:01:02.437]  recursive: 0
[17:01:02.437]  length: 1
[17:01:02.437]  elements: ‘...’
[17:01:02.438]  length: 0 (resolved future 1)
[17:01:02.438] resolve() on list ... DONE
[17:01:02.438]    - '...' content: [n=0] 
[17:01:02.438] List of 1
[17:01:02.438]  $ ...: list()
[17:01:02.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.438]  - attr(*, "where")=List of 1
[17:01:02.438]   ..$ ...:<environment: 0x55aad9a23048> 
[17:01:02.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.438]  - attr(*, "resolved")= logi TRUE
[17:01:02.438]  - attr(*, "total_size")= num NA
[17:01:02.440]  - Getting '...' globals ... DONE
[17:01:02.441] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.441] List of 8
[17:01:02.441]  $ ...future.FUN:function (x, ...)  
[17:01:02.441]  $ x_FUN        :function (x)  
[17:01:02.441]  $ times        : int 2
[17:01:02.441]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.441]  $ stop_if_not  :function (...)  
[17:01:02.441]  $ dim          : NULL
[17:01:02.441]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.441]  $ ...          : list()
[17:01:02.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.441]  - attr(*, "where")=List of 8
[17:01:02.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.441]   ..$ ...          :<environment: 0x55aad9a23048> 
[17:01:02.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.441]  - attr(*, "resolved")= logi FALSE
[17:01:02.441]  - attr(*, "total_size")= num 96456
[17:01:02.449] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.449] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.449] Number of futures (= number of chunks): 2
[17:01:02.449] Launching 2 futures (chunks) ...
[17:01:02.449] Chunk #1 of 2 ...
[17:01:02.449]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.449] getGlobalsAndPackages() ...
[17:01:02.450] Searching for globals...
[17:01:02.450] 
[17:01:02.450] Searching for globals ... DONE
[17:01:02.450] - globals: [0] <none>
[17:01:02.450] getGlobalsAndPackages() ... DONE
[17:01:02.450]    + additional globals found: [n=0] 
[17:01:02.450]    + additional namespaces needed: [n=0] 
[17:01:02.450]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.451]  - seeds: <none>
[17:01:02.451]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.451] getGlobalsAndPackages() ...
[17:01:02.451] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.451] Resolving globals: FALSE
[17:01:02.451] Tweak future expression to call with '...' arguments ...
[17:01:02.451] {
[17:01:02.451]     do.call(function(...) {
[17:01:02.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.451]             on.exit(options(oopts), add = TRUE)
[17:01:02.451]         }
[17:01:02.451]         {
[17:01:02.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.451]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.451]             })
[17:01:02.451]         }
[17:01:02.451]     }, args = future.call.arguments)
[17:01:02.451] }
[17:01:02.452] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.452] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.452] - packages: [1] ‘future.apply’
[17:01:02.452] getGlobalsAndPackages() ... DONE
[17:01:02.453] run() for ‘Future’ ...
[17:01:02.453] - state: ‘created’
[17:01:02.453] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.457]   - Field: ‘label’
[17:01:02.457]   - Field: ‘local’
[17:01:02.457]   - Field: ‘owner’
[17:01:02.458]   - Field: ‘envir’
[17:01:02.458]   - Field: ‘workers’
[17:01:02.458]   - Field: ‘packages’
[17:01:02.458]   - Field: ‘gc’
[17:01:02.458]   - Field: ‘job’
[17:01:02.458]   - Field: ‘conditions’
[17:01:02.458]   - Field: ‘expr’
[17:01:02.458]   - Field: ‘uuid’
[17:01:02.458]   - Field: ‘seed’
[17:01:02.458]   - Field: ‘version’
[17:01:02.459]   - Field: ‘result’
[17:01:02.459]   - Field: ‘asynchronous’
[17:01:02.459]   - Field: ‘calls’
[17:01:02.459]   - Field: ‘globals’
[17:01:02.459]   - Field: ‘stdout’
[17:01:02.459]   - Field: ‘earlySignal’
[17:01:02.459]   - Field: ‘lazy’
[17:01:02.459]   - Field: ‘state’
[17:01:02.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.459] - Launch lazy future ...
[17:01:02.460] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.460] Packages needed by future strategies (n = 0): <none>
[17:01:02.460] {
[17:01:02.460]     {
[17:01:02.460]         {
[17:01:02.460]             ...future.startTime <- base::Sys.time()
[17:01:02.460]             {
[17:01:02.460]                 {
[17:01:02.460]                   {
[17:01:02.460]                     {
[17:01:02.460]                       {
[17:01:02.460]                         base::local({
[17:01:02.460]                           has_future <- base::requireNamespace("future", 
[17:01:02.460]                             quietly = TRUE)
[17:01:02.460]                           if (has_future) {
[17:01:02.460]                             ns <- base::getNamespace("future")
[17:01:02.460]                             version <- ns[[".package"]][["version"]]
[17:01:02.460]                             if (is.null(version)) 
[17:01:02.460]                               version <- utils::packageVersion("future")
[17:01:02.460]                           }
[17:01:02.460]                           else {
[17:01:02.460]                             version <- NULL
[17:01:02.460]                           }
[17:01:02.460]                           if (!has_future || version < "1.8.0") {
[17:01:02.460]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.460]                               "", base::R.version$version.string), 
[17:01:02.460]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.460]                                 base::R.version$platform, 8 * 
[17:01:02.460]                                   base::.Machine$sizeof.pointer), 
[17:01:02.460]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.460]                                 "release", "version")], collapse = " "), 
[17:01:02.460]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.460]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.460]                               info)
[17:01:02.460]                             info <- base::paste(info, collapse = "; ")
[17:01:02.460]                             if (!has_future) {
[17:01:02.460]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.460]                                 info)
[17:01:02.460]                             }
[17:01:02.460]                             else {
[17:01:02.460]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.460]                                 info, version)
[17:01:02.460]                             }
[17:01:02.460]                             base::stop(msg)
[17:01:02.460]                           }
[17:01:02.460]                         })
[17:01:02.460]                       }
[17:01:02.460]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.460]                       base::options(mc.cores = 1L)
[17:01:02.460]                     }
[17:01:02.460]                     base::local({
[17:01:02.460]                       for (pkg in "future.apply") {
[17:01:02.460]                         base::loadNamespace(pkg)
[17:01:02.460]                         base::library(pkg, character.only = TRUE)
[17:01:02.460]                       }
[17:01:02.460]                     })
[17:01:02.460]                   }
[17:01:02.460]                   ...future.strategy.old <- future::plan("list")
[17:01:02.460]                   options(future.plan = NULL)
[17:01:02.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.460]                 }
[17:01:02.460]                 ...future.workdir <- getwd()
[17:01:02.460]             }
[17:01:02.460]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.460]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.460]         }
[17:01:02.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.460]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.460]             base::names(...future.oldOptions))
[17:01:02.460]     }
[17:01:02.460]     if (FALSE) {
[17:01:02.460]     }
[17:01:02.460]     else {
[17:01:02.460]         if (TRUE) {
[17:01:02.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.460]                 open = "w")
[17:01:02.460]         }
[17:01:02.460]         else {
[17:01:02.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.460]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.460]         }
[17:01:02.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.460]             base::sink(type = "output", split = FALSE)
[17:01:02.460]             base::close(...future.stdout)
[17:01:02.460]         }, add = TRUE)
[17:01:02.460]     }
[17:01:02.460]     ...future.frame <- base::sys.nframe()
[17:01:02.460]     ...future.conditions <- base::list()
[17:01:02.460]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.460]     if (FALSE) {
[17:01:02.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.460]     }
[17:01:02.460]     ...future.result <- base::tryCatch({
[17:01:02.460]         base::withCallingHandlers({
[17:01:02.460]             ...future.value <- base::withVisible(base::local({
[17:01:02.460]                 withCallingHandlers({
[17:01:02.460]                   {
[17:01:02.460]                     do.call(function(...) {
[17:01:02.460]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.460]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.460]                         ...future.globals.maxSize)) {
[17:01:02.460]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.460]                         on.exit(options(oopts), add = TRUE)
[17:01:02.460]                       }
[17:01:02.460]                       {
[17:01:02.460]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.460]                           FUN = function(jj) {
[17:01:02.460]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.460]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.460]                           })
[17:01:02.460]                       }
[17:01:02.460]                     }, args = future.call.arguments)
[17:01:02.460]                   }
[17:01:02.460]                 }, immediateCondition = function(cond) {
[17:01:02.460]                   save_rds <- function (object, pathname, ...) 
[17:01:02.460]                   {
[17:01:02.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.460]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.460]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.460]                         fi_tmp[["mtime"]])
[17:01:02.460]                     }
[17:01:02.460]                     tryCatch({
[17:01:02.460]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.460]                     }, error = function(ex) {
[17:01:02.460]                       msg <- conditionMessage(ex)
[17:01:02.460]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.460]                         fi_tmp[["mtime"]], msg)
[17:01:02.460]                       ex$message <- msg
[17:01:02.460]                       stop(ex)
[17:01:02.460]                     })
[17:01:02.460]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.460]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.460]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.460]                       fi <- file.info(pathname)
[17:01:02.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.460]                         fi[["size"]], fi[["mtime"]])
[17:01:02.460]                       stop(msg)
[17:01:02.460]                     }
[17:01:02.460]                     invisible(pathname)
[17:01:02.460]                   }
[17:01:02.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.460]                     rootPath = tempdir()) 
[17:01:02.460]                   {
[17:01:02.460]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.460]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.460]                       tmpdir = path, fileext = ".rds")
[17:01:02.460]                     save_rds(obj, file)
[17:01:02.460]                   }
[17:01:02.460]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.460]                   {
[17:01:02.460]                     inherits <- base::inherits
[17:01:02.460]                     invokeRestart <- base::invokeRestart
[17:01:02.460]                     is.null <- base::is.null
[17:01:02.460]                     muffled <- FALSE
[17:01:02.460]                     if (inherits(cond, "message")) {
[17:01:02.460]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.460]                       if (muffled) 
[17:01:02.460]                         invokeRestart("muffleMessage")
[17:01:02.460]                     }
[17:01:02.460]                     else if (inherits(cond, "warning")) {
[17:01:02.460]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.460]                       if (muffled) 
[17:01:02.460]                         invokeRestart("muffleWarning")
[17:01:02.460]                     }
[17:01:02.460]                     else if (inherits(cond, "condition")) {
[17:01:02.460]                       if (!is.null(pattern)) {
[17:01:02.460]                         computeRestarts <- base::computeRestarts
[17:01:02.460]                         grepl <- base::grepl
[17:01:02.460]                         restarts <- computeRestarts(cond)
[17:01:02.460]                         for (restart in restarts) {
[17:01:02.460]                           name <- restart$name
[17:01:02.460]                           if (is.null(name)) 
[17:01:02.460]                             next
[17:01:02.460]                           if (!grepl(pattern, name)) 
[17:01:02.460]                             next
[17:01:02.460]                           invokeRestart(restart)
[17:01:02.460]                           muffled <- TRUE
[17:01:02.460]                           break
[17:01:02.460]                         }
[17:01:02.460]                       }
[17:01:02.460]                     }
[17:01:02.460]                     invisible(muffled)
[17:01:02.460]                   }
[17:01:02.460]                   muffleCondition(cond)
[17:01:02.460]                 })
[17:01:02.460]             }))
[17:01:02.460]             future::FutureResult(value = ...future.value$value, 
[17:01:02.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.460]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.460]                     ...future.globalenv.names))
[17:01:02.460]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.460]         }, condition = base::local({
[17:01:02.460]             c <- base::c
[17:01:02.460]             inherits <- base::inherits
[17:01:02.460]             invokeRestart <- base::invokeRestart
[17:01:02.460]             length <- base::length
[17:01:02.460]             list <- base::list
[17:01:02.460]             seq.int <- base::seq.int
[17:01:02.460]             signalCondition <- base::signalCondition
[17:01:02.460]             sys.calls <- base::sys.calls
[17:01:02.460]             `[[` <- base::`[[`
[17:01:02.460]             `+` <- base::`+`
[17:01:02.460]             `<<-` <- base::`<<-`
[17:01:02.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.460]                   3L)]
[17:01:02.460]             }
[17:01:02.460]             function(cond) {
[17:01:02.460]                 is_error <- inherits(cond, "error")
[17:01:02.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.460]                   NULL)
[17:01:02.460]                 if (is_error) {
[17:01:02.460]                   sessionInformation <- function() {
[17:01:02.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.460]                       search = base::search(), system = base::Sys.info())
[17:01:02.460]                   }
[17:01:02.460]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.460]                     cond$call), session = sessionInformation(), 
[17:01:02.460]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.460]                   signalCondition(cond)
[17:01:02.460]                 }
[17:01:02.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.460]                 "immediateCondition"))) {
[17:01:02.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.460]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.460]                   if (TRUE && !signal) {
[17:01:02.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.460]                     {
[17:01:02.460]                       inherits <- base::inherits
[17:01:02.460]                       invokeRestart <- base::invokeRestart
[17:01:02.460]                       is.null <- base::is.null
[17:01:02.460]                       muffled <- FALSE
[17:01:02.460]                       if (inherits(cond, "message")) {
[17:01:02.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.460]                         if (muffled) 
[17:01:02.460]                           invokeRestart("muffleMessage")
[17:01:02.460]                       }
[17:01:02.460]                       else if (inherits(cond, "warning")) {
[17:01:02.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.460]                         if (muffled) 
[17:01:02.460]                           invokeRestart("muffleWarning")
[17:01:02.460]                       }
[17:01:02.460]                       else if (inherits(cond, "condition")) {
[17:01:02.460]                         if (!is.null(pattern)) {
[17:01:02.460]                           computeRestarts <- base::computeRestarts
[17:01:02.460]                           grepl <- base::grepl
[17:01:02.460]                           restarts <- computeRestarts(cond)
[17:01:02.460]                           for (restart in restarts) {
[17:01:02.460]                             name <- restart$name
[17:01:02.460]                             if (is.null(name)) 
[17:01:02.460]                               next
[17:01:02.460]                             if (!grepl(pattern, name)) 
[17:01:02.460]                               next
[17:01:02.460]                             invokeRestart(restart)
[17:01:02.460]                             muffled <- TRUE
[17:01:02.460]                             break
[17:01:02.460]                           }
[17:01:02.460]                         }
[17:01:02.460]                       }
[17:01:02.460]                       invisible(muffled)
[17:01:02.460]                     }
[17:01:02.460]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.460]                   }
[17:01:02.460]                 }
[17:01:02.460]                 else {
[17:01:02.460]                   if (TRUE) {
[17:01:02.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.460]                     {
[17:01:02.460]                       inherits <- base::inherits
[17:01:02.460]                       invokeRestart <- base::invokeRestart
[17:01:02.460]                       is.null <- base::is.null
[17:01:02.460]                       muffled <- FALSE
[17:01:02.460]                       if (inherits(cond, "message")) {
[17:01:02.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.460]                         if (muffled) 
[17:01:02.460]                           invokeRestart("muffleMessage")
[17:01:02.460]                       }
[17:01:02.460]                       else if (inherits(cond, "warning")) {
[17:01:02.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.460]                         if (muffled) 
[17:01:02.460]                           invokeRestart("muffleWarning")
[17:01:02.460]                       }
[17:01:02.460]                       else if (inherits(cond, "condition")) {
[17:01:02.460]                         if (!is.null(pattern)) {
[17:01:02.460]                           computeRestarts <- base::computeRestarts
[17:01:02.460]                           grepl <- base::grepl
[17:01:02.460]                           restarts <- computeRestarts(cond)
[17:01:02.460]                           for (restart in restarts) {
[17:01:02.460]                             name <- restart$name
[17:01:02.460]                             if (is.null(name)) 
[17:01:02.460]                               next
[17:01:02.460]                             if (!grepl(pattern, name)) 
[17:01:02.460]                               next
[17:01:02.460]                             invokeRestart(restart)
[17:01:02.460]                             muffled <- TRUE
[17:01:02.460]                             break
[17:01:02.460]                           }
[17:01:02.460]                         }
[17:01:02.460]                       }
[17:01:02.460]                       invisible(muffled)
[17:01:02.460]                     }
[17:01:02.460]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.460]                   }
[17:01:02.460]                 }
[17:01:02.460]             }
[17:01:02.460]         }))
[17:01:02.460]     }, error = function(ex) {
[17:01:02.460]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.460]                 ...future.rng), started = ...future.startTime, 
[17:01:02.460]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.460]             version = "1.8"), class = "FutureResult")
[17:01:02.460]     }, finally = {
[17:01:02.460]         if (!identical(...future.workdir, getwd())) 
[17:01:02.460]             setwd(...future.workdir)
[17:01:02.460]         {
[17:01:02.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.460]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.460]             }
[17:01:02.460]             base::options(...future.oldOptions)
[17:01:02.460]             if (.Platform$OS.type == "windows") {
[17:01:02.460]                 old_names <- names(...future.oldEnvVars)
[17:01:02.460]                 envs <- base::Sys.getenv()
[17:01:02.460]                 names <- names(envs)
[17:01:02.460]                 common <- intersect(names, old_names)
[17:01:02.460]                 added <- setdiff(names, old_names)
[17:01:02.460]                 removed <- setdiff(old_names, names)
[17:01:02.460]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.460]                   envs[common]]
[17:01:02.460]                 NAMES <- toupper(changed)
[17:01:02.460]                 args <- list()
[17:01:02.460]                 for (kk in seq_along(NAMES)) {
[17:01:02.460]                   name <- changed[[kk]]
[17:01:02.460]                   NAME <- NAMES[[kk]]
[17:01:02.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.460]                     next
[17:01:02.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.460]                 }
[17:01:02.460]                 NAMES <- toupper(added)
[17:01:02.460]                 for (kk in seq_along(NAMES)) {
[17:01:02.460]                   name <- added[[kk]]
[17:01:02.460]                   NAME <- NAMES[[kk]]
[17:01:02.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.460]                     next
[17:01:02.460]                   args[[name]] <- ""
[17:01:02.460]                 }
[17:01:02.460]                 NAMES <- toupper(removed)
[17:01:02.460]                 for (kk in seq_along(NAMES)) {
[17:01:02.460]                   name <- removed[[kk]]
[17:01:02.460]                   NAME <- NAMES[[kk]]
[17:01:02.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.460]                     next
[17:01:02.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.460]                 }
[17:01:02.460]                 if (length(args) > 0) 
[17:01:02.460]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.460]             }
[17:01:02.460]             else {
[17:01:02.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.460]             }
[17:01:02.460]             {
[17:01:02.460]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.460]                   0L) {
[17:01:02.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.460]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.460]                   base::options(opts)
[17:01:02.460]                 }
[17:01:02.460]                 {
[17:01:02.460]                   {
[17:01:02.460]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.460]                     NULL
[17:01:02.460]                   }
[17:01:02.460]                   options(future.plan = NULL)
[17:01:02.460]                   if (is.na(NA_character_)) 
[17:01:02.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.460]                     .init = FALSE)
[17:01:02.460]                 }
[17:01:02.460]             }
[17:01:02.460]         }
[17:01:02.460]     })
[17:01:02.460]     if (TRUE) {
[17:01:02.460]         base::sink(type = "output", split = FALSE)
[17:01:02.460]         if (TRUE) {
[17:01:02.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.460]         }
[17:01:02.460]         else {
[17:01:02.460]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.460]         }
[17:01:02.460]         base::close(...future.stdout)
[17:01:02.460]         ...future.stdout <- NULL
[17:01:02.460]     }
[17:01:02.460]     ...future.result$conditions <- ...future.conditions
[17:01:02.460]     ...future.result$finished <- base::Sys.time()
[17:01:02.460]     ...future.result
[17:01:02.460] }
[17:01:02.463] assign_globals() ...
[17:01:02.463] List of 11
[17:01:02.463]  $ ...future.FUN            :function (x, ...)  
[17:01:02.463]  $ x_FUN                    :function (x)  
[17:01:02.463]  $ times                    : int 2
[17:01:02.463]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.463]  $ stop_if_not              :function (...)  
[17:01:02.463]  $ dim                      : NULL
[17:01:02.463]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.463]  $ future.call.arguments    : list()
[17:01:02.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.463]  $ ...future.elements_ii    :List of 5
[17:01:02.463]   ..$ : int 1
[17:01:02.463]   ..$ : int 2
[17:01:02.463]   ..$ : int 3
[17:01:02.463]   ..$ : int 4
[17:01:02.463]   ..$ : int 5
[17:01:02.463]  $ ...future.seeds_ii       : NULL
[17:01:02.463]  $ ...future.globals.maxSize: NULL
[17:01:02.463]  - attr(*, "where")=List of 11
[17:01:02.463]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.463]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.463]  - attr(*, "resolved")= logi FALSE
[17:01:02.463]  - attr(*, "total_size")= num 96456
[17:01:02.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.463]  - attr(*, "already-done")= logi TRUE
[17:01:02.474] - copied ‘...future.FUN’ to environment
[17:01:02.474] - reassign environment for ‘x_FUN’
[17:01:02.474] - copied ‘x_FUN’ to environment
[17:01:02.474] - copied ‘times’ to environment
[17:01:02.474] - copied ‘stopf’ to environment
[17:01:02.475] - copied ‘stop_if_not’ to environment
[17:01:02.475] - copied ‘dim’ to environment
[17:01:02.475] - copied ‘valid_types’ to environment
[17:01:02.475] - copied ‘future.call.arguments’ to environment
[17:01:02.475] - copied ‘...future.elements_ii’ to environment
[17:01:02.475] - copied ‘...future.seeds_ii’ to environment
[17:01:02.475] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.475] assign_globals() ... done
[17:01:02.475] requestCore(): workers = 2
[17:01:02.478] MulticoreFuture started
[17:01:02.478] - Launch lazy future ... done
[17:01:02.479] run() for ‘MulticoreFuture’ ... done
[17:01:02.479] Created future:
[17:01:02.479] plan(): Setting new future strategy stack:
[17:01:02.480] List of future strategies:
[17:01:02.480] 1. sequential:
[17:01:02.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.480]    - tweaked: FALSE
[17:01:02.480]    - call: NULL
[17:01:02.481] plan(): nbrOfWorkers() = 1
[17:01:02.483] plan(): Setting new future strategy stack:
[17:01:02.483] List of future strategies:
[17:01:02.483] 1. multicore:
[17:01:02.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.483]    - tweaked: FALSE
[17:01:02.483]    - call: plan(strategy)
[17:01:02.489] plan(): nbrOfWorkers() = 2
[17:01:02.479] MulticoreFuture:
[17:01:02.479] Label: ‘future_vapply-1’
[17:01:02.479] Expression:
[17:01:02.479] {
[17:01:02.479]     do.call(function(...) {
[17:01:02.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.479]             on.exit(options(oopts), add = TRUE)
[17:01:02.479]         }
[17:01:02.479]         {
[17:01:02.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.479]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.479]             })
[17:01:02.479]         }
[17:01:02.479]     }, args = future.call.arguments)
[17:01:02.479] }
[17:01:02.479] Lazy evaluation: FALSE
[17:01:02.479] Asynchronous evaluation: TRUE
[17:01:02.479] Local evaluation: TRUE
[17:01:02.479] Environment: R_GlobalEnv
[17:01:02.479] Capture standard output: TRUE
[17:01:02.479] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.479] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.479] Packages: 1 packages (‘future.apply’)
[17:01:02.479] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.479] Resolved: TRUE
[17:01:02.479] Value: <not collected>
[17:01:02.479] Conditions captured: <none>
[17:01:02.479] Early signaling: FALSE
[17:01:02.479] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.479] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.490] Chunk #1 of 2 ... DONE
[17:01:02.490] Chunk #2 of 2 ...
[17:01:02.490]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.490] getGlobalsAndPackages() ...
[17:01:02.490] Searching for globals...
[17:01:02.491] 
[17:01:02.491] Searching for globals ... DONE
[17:01:02.491] - globals: [0] <none>
[17:01:02.491] getGlobalsAndPackages() ... DONE
[17:01:02.491]    + additional globals found: [n=0] 
[17:01:02.491]    + additional namespaces needed: [n=0] 
[17:01:02.492]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.492]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.492]  - seeds: <none>
[17:01:02.492]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.492] getGlobalsAndPackages() ...
[17:01:02.492] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.493] Resolving globals: FALSE
[17:01:02.493] Tweak future expression to call with '...' arguments ...
[17:01:02.493] {
[17:01:02.493]     do.call(function(...) {
[17:01:02.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.493]             on.exit(options(oopts), add = TRUE)
[17:01:02.493]         }
[17:01:02.493]         {
[17:01:02.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.493]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.493]             })
[17:01:02.493]         }
[17:01:02.493]     }, args = future.call.arguments)
[17:01:02.493] }
[17:01:02.493] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.494] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.494] - packages: [1] ‘future.apply’
[17:01:02.495] getGlobalsAndPackages() ... DONE
[17:01:02.495] run() for ‘Future’ ...
[17:01:02.495] - state: ‘created’
[17:01:02.496] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.500]   - Field: ‘label’
[17:01:02.500]   - Field: ‘local’
[17:01:02.501]   - Field: ‘owner’
[17:01:02.501]   - Field: ‘envir’
[17:01:02.501]   - Field: ‘workers’
[17:01:02.501]   - Field: ‘packages’
[17:01:02.501]   - Field: ‘gc’
[17:01:02.501]   - Field: ‘job’
[17:01:02.502]   - Field: ‘conditions’
[17:01:02.502]   - Field: ‘expr’
[17:01:02.502]   - Field: ‘uuid’
[17:01:02.502]   - Field: ‘seed’
[17:01:02.502]   - Field: ‘version’
[17:01:02.502]   - Field: ‘result’
[17:01:02.502]   - Field: ‘asynchronous’
[17:01:02.503]   - Field: ‘calls’
[17:01:02.503]   - Field: ‘globals’
[17:01:02.503]   - Field: ‘stdout’
[17:01:02.503]   - Field: ‘earlySignal’
[17:01:02.503]   - Field: ‘lazy’
[17:01:02.503]   - Field: ‘state’
[17:01:02.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.504] - Launch lazy future ...
[17:01:02.504] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.504] Packages needed by future strategies (n = 0): <none>
[17:01:02.505] {
[17:01:02.505]     {
[17:01:02.505]         {
[17:01:02.505]             ...future.startTime <- base::Sys.time()
[17:01:02.505]             {
[17:01:02.505]                 {
[17:01:02.505]                   {
[17:01:02.505]                     {
[17:01:02.505]                       {
[17:01:02.505]                         base::local({
[17:01:02.505]                           has_future <- base::requireNamespace("future", 
[17:01:02.505]                             quietly = TRUE)
[17:01:02.505]                           if (has_future) {
[17:01:02.505]                             ns <- base::getNamespace("future")
[17:01:02.505]                             version <- ns[[".package"]][["version"]]
[17:01:02.505]                             if (is.null(version)) 
[17:01:02.505]                               version <- utils::packageVersion("future")
[17:01:02.505]                           }
[17:01:02.505]                           else {
[17:01:02.505]                             version <- NULL
[17:01:02.505]                           }
[17:01:02.505]                           if (!has_future || version < "1.8.0") {
[17:01:02.505]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.505]                               "", base::R.version$version.string), 
[17:01:02.505]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.505]                                 base::R.version$platform, 8 * 
[17:01:02.505]                                   base::.Machine$sizeof.pointer), 
[17:01:02.505]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.505]                                 "release", "version")], collapse = " "), 
[17:01:02.505]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.505]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.505]                               info)
[17:01:02.505]                             info <- base::paste(info, collapse = "; ")
[17:01:02.505]                             if (!has_future) {
[17:01:02.505]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.505]                                 info)
[17:01:02.505]                             }
[17:01:02.505]                             else {
[17:01:02.505]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.505]                                 info, version)
[17:01:02.505]                             }
[17:01:02.505]                             base::stop(msg)
[17:01:02.505]                           }
[17:01:02.505]                         })
[17:01:02.505]                       }
[17:01:02.505]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.505]                       base::options(mc.cores = 1L)
[17:01:02.505]                     }
[17:01:02.505]                     base::local({
[17:01:02.505]                       for (pkg in "future.apply") {
[17:01:02.505]                         base::loadNamespace(pkg)
[17:01:02.505]                         base::library(pkg, character.only = TRUE)
[17:01:02.505]                       }
[17:01:02.505]                     })
[17:01:02.505]                   }
[17:01:02.505]                   ...future.strategy.old <- future::plan("list")
[17:01:02.505]                   options(future.plan = NULL)
[17:01:02.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.505]                 }
[17:01:02.505]                 ...future.workdir <- getwd()
[17:01:02.505]             }
[17:01:02.505]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.505]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.505]         }
[17:01:02.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.505]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.505]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.505]             base::names(...future.oldOptions))
[17:01:02.505]     }
[17:01:02.505]     if (FALSE) {
[17:01:02.505]     }
[17:01:02.505]     else {
[17:01:02.505]         if (TRUE) {
[17:01:02.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.505]                 open = "w")
[17:01:02.505]         }
[17:01:02.505]         else {
[17:01:02.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.505]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.505]         }
[17:01:02.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.505]             base::sink(type = "output", split = FALSE)
[17:01:02.505]             base::close(...future.stdout)
[17:01:02.505]         }, add = TRUE)
[17:01:02.505]     }
[17:01:02.505]     ...future.frame <- base::sys.nframe()
[17:01:02.505]     ...future.conditions <- base::list()
[17:01:02.505]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.505]     if (FALSE) {
[17:01:02.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.505]     }
[17:01:02.505]     ...future.result <- base::tryCatch({
[17:01:02.505]         base::withCallingHandlers({
[17:01:02.505]             ...future.value <- base::withVisible(base::local({
[17:01:02.505]                 withCallingHandlers({
[17:01:02.505]                   {
[17:01:02.505]                     do.call(function(...) {
[17:01:02.505]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.505]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.505]                         ...future.globals.maxSize)) {
[17:01:02.505]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.505]                         on.exit(options(oopts), add = TRUE)
[17:01:02.505]                       }
[17:01:02.505]                       {
[17:01:02.505]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.505]                           FUN = function(jj) {
[17:01:02.505]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.505]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.505]                           })
[17:01:02.505]                       }
[17:01:02.505]                     }, args = future.call.arguments)
[17:01:02.505]                   }
[17:01:02.505]                 }, immediateCondition = function(cond) {
[17:01:02.505]                   save_rds <- function (object, pathname, ...) 
[17:01:02.505]                   {
[17:01:02.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.505]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.505]                         fi_tmp[["mtime"]])
[17:01:02.505]                     }
[17:01:02.505]                     tryCatch({
[17:01:02.505]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.505]                     }, error = function(ex) {
[17:01:02.505]                       msg <- conditionMessage(ex)
[17:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.505]                         fi_tmp[["mtime"]], msg)
[17:01:02.505]                       ex$message <- msg
[17:01:02.505]                       stop(ex)
[17:01:02.505]                     })
[17:01:02.505]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.505]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.505]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.505]                       fi <- file.info(pathname)
[17:01:02.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.505]                         fi[["size"]], fi[["mtime"]])
[17:01:02.505]                       stop(msg)
[17:01:02.505]                     }
[17:01:02.505]                     invisible(pathname)
[17:01:02.505]                   }
[17:01:02.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.505]                     rootPath = tempdir()) 
[17:01:02.505]                   {
[17:01:02.505]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.505]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.505]                       tmpdir = path, fileext = ".rds")
[17:01:02.505]                     save_rds(obj, file)
[17:01:02.505]                   }
[17:01:02.505]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.505]                   {
[17:01:02.505]                     inherits <- base::inherits
[17:01:02.505]                     invokeRestart <- base::invokeRestart
[17:01:02.505]                     is.null <- base::is.null
[17:01:02.505]                     muffled <- FALSE
[17:01:02.505]                     if (inherits(cond, "message")) {
[17:01:02.505]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.505]                       if (muffled) 
[17:01:02.505]                         invokeRestart("muffleMessage")
[17:01:02.505]                     }
[17:01:02.505]                     else if (inherits(cond, "warning")) {
[17:01:02.505]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.505]                       if (muffled) 
[17:01:02.505]                         invokeRestart("muffleWarning")
[17:01:02.505]                     }
[17:01:02.505]                     else if (inherits(cond, "condition")) {
[17:01:02.505]                       if (!is.null(pattern)) {
[17:01:02.505]                         computeRestarts <- base::computeRestarts
[17:01:02.505]                         grepl <- base::grepl
[17:01:02.505]                         restarts <- computeRestarts(cond)
[17:01:02.505]                         for (restart in restarts) {
[17:01:02.505]                           name <- restart$name
[17:01:02.505]                           if (is.null(name)) 
[17:01:02.505]                             next
[17:01:02.505]                           if (!grepl(pattern, name)) 
[17:01:02.505]                             next
[17:01:02.505]                           invokeRestart(restart)
[17:01:02.505]                           muffled <- TRUE
[17:01:02.505]                           break
[17:01:02.505]                         }
[17:01:02.505]                       }
[17:01:02.505]                     }
[17:01:02.505]                     invisible(muffled)
[17:01:02.505]                   }
[17:01:02.505]                   muffleCondition(cond)
[17:01:02.505]                 })
[17:01:02.505]             }))
[17:01:02.505]             future::FutureResult(value = ...future.value$value, 
[17:01:02.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.505]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.505]                     ...future.globalenv.names))
[17:01:02.505]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.505]         }, condition = base::local({
[17:01:02.505]             c <- base::c
[17:01:02.505]             inherits <- base::inherits
[17:01:02.505]             invokeRestart <- base::invokeRestart
[17:01:02.505]             length <- base::length
[17:01:02.505]             list <- base::list
[17:01:02.505]             seq.int <- base::seq.int
[17:01:02.505]             signalCondition <- base::signalCondition
[17:01:02.505]             sys.calls <- base::sys.calls
[17:01:02.505]             `[[` <- base::`[[`
[17:01:02.505]             `+` <- base::`+`
[17:01:02.505]             `<<-` <- base::`<<-`
[17:01:02.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.505]                   3L)]
[17:01:02.505]             }
[17:01:02.505]             function(cond) {
[17:01:02.505]                 is_error <- inherits(cond, "error")
[17:01:02.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.505]                   NULL)
[17:01:02.505]                 if (is_error) {
[17:01:02.505]                   sessionInformation <- function() {
[17:01:02.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.505]                       search = base::search(), system = base::Sys.info())
[17:01:02.505]                   }
[17:01:02.505]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.505]                     cond$call), session = sessionInformation(), 
[17:01:02.505]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.505]                   signalCondition(cond)
[17:01:02.505]                 }
[17:01:02.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.505]                 "immediateCondition"))) {
[17:01:02.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.505]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.505]                   if (TRUE && !signal) {
[17:01:02.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.505]                     {
[17:01:02.505]                       inherits <- base::inherits
[17:01:02.505]                       invokeRestart <- base::invokeRestart
[17:01:02.505]                       is.null <- base::is.null
[17:01:02.505]                       muffled <- FALSE
[17:01:02.505]                       if (inherits(cond, "message")) {
[17:01:02.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.505]                         if (muffled) 
[17:01:02.505]                           invokeRestart("muffleMessage")
[17:01:02.505]                       }
[17:01:02.505]                       else if (inherits(cond, "warning")) {
[17:01:02.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.505]                         if (muffled) 
[17:01:02.505]                           invokeRestart("muffleWarning")
[17:01:02.505]                       }
[17:01:02.505]                       else if (inherits(cond, "condition")) {
[17:01:02.505]                         if (!is.null(pattern)) {
[17:01:02.505]                           computeRestarts <- base::computeRestarts
[17:01:02.505]                           grepl <- base::grepl
[17:01:02.505]                           restarts <- computeRestarts(cond)
[17:01:02.505]                           for (restart in restarts) {
[17:01:02.505]                             name <- restart$name
[17:01:02.505]                             if (is.null(name)) 
[17:01:02.505]                               next
[17:01:02.505]                             if (!grepl(pattern, name)) 
[17:01:02.505]                               next
[17:01:02.505]                             invokeRestart(restart)
[17:01:02.505]                             muffled <- TRUE
[17:01:02.505]                             break
[17:01:02.505]                           }
[17:01:02.505]                         }
[17:01:02.505]                       }
[17:01:02.505]                       invisible(muffled)
[17:01:02.505]                     }
[17:01:02.505]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.505]                   }
[17:01:02.505]                 }
[17:01:02.505]                 else {
[17:01:02.505]                   if (TRUE) {
[17:01:02.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.505]                     {
[17:01:02.505]                       inherits <- base::inherits
[17:01:02.505]                       invokeRestart <- base::invokeRestart
[17:01:02.505]                       is.null <- base::is.null
[17:01:02.505]                       muffled <- FALSE
[17:01:02.505]                       if (inherits(cond, "message")) {
[17:01:02.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.505]                         if (muffled) 
[17:01:02.505]                           invokeRestart("muffleMessage")
[17:01:02.505]                       }
[17:01:02.505]                       else if (inherits(cond, "warning")) {
[17:01:02.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.505]                         if (muffled) 
[17:01:02.505]                           invokeRestart("muffleWarning")
[17:01:02.505]                       }
[17:01:02.505]                       else if (inherits(cond, "condition")) {
[17:01:02.505]                         if (!is.null(pattern)) {
[17:01:02.505]                           computeRestarts <- base::computeRestarts
[17:01:02.505]                           grepl <- base::grepl
[17:01:02.505]                           restarts <- computeRestarts(cond)
[17:01:02.505]                           for (restart in restarts) {
[17:01:02.505]                             name <- restart$name
[17:01:02.505]                             if (is.null(name)) 
[17:01:02.505]                               next
[17:01:02.505]                             if (!grepl(pattern, name)) 
[17:01:02.505]                               next
[17:01:02.505]                             invokeRestart(restart)
[17:01:02.505]                             muffled <- TRUE
[17:01:02.505]                             break
[17:01:02.505]                           }
[17:01:02.505]                         }
[17:01:02.505]                       }
[17:01:02.505]                       invisible(muffled)
[17:01:02.505]                     }
[17:01:02.505]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.505]                   }
[17:01:02.505]                 }
[17:01:02.505]             }
[17:01:02.505]         }))
[17:01:02.505]     }, error = function(ex) {
[17:01:02.505]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.505]                 ...future.rng), started = ...future.startTime, 
[17:01:02.505]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.505]             version = "1.8"), class = "FutureResult")
[17:01:02.505]     }, finally = {
[17:01:02.505]         if (!identical(...future.workdir, getwd())) 
[17:01:02.505]             setwd(...future.workdir)
[17:01:02.505]         {
[17:01:02.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.505]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.505]             }
[17:01:02.505]             base::options(...future.oldOptions)
[17:01:02.505]             if (.Platform$OS.type == "windows") {
[17:01:02.505]                 old_names <- names(...future.oldEnvVars)
[17:01:02.505]                 envs <- base::Sys.getenv()
[17:01:02.505]                 names <- names(envs)
[17:01:02.505]                 common <- intersect(names, old_names)
[17:01:02.505]                 added <- setdiff(names, old_names)
[17:01:02.505]                 removed <- setdiff(old_names, names)
[17:01:02.505]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.505]                   envs[common]]
[17:01:02.505]                 NAMES <- toupper(changed)
[17:01:02.505]                 args <- list()
[17:01:02.505]                 for (kk in seq_along(NAMES)) {
[17:01:02.505]                   name <- changed[[kk]]
[17:01:02.505]                   NAME <- NAMES[[kk]]
[17:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.505]                     next
[17:01:02.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.505]                 }
[17:01:02.505]                 NAMES <- toupper(added)
[17:01:02.505]                 for (kk in seq_along(NAMES)) {
[17:01:02.505]                   name <- added[[kk]]
[17:01:02.505]                   NAME <- NAMES[[kk]]
[17:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.505]                     next
[17:01:02.505]                   args[[name]] <- ""
[17:01:02.505]                 }
[17:01:02.505]                 NAMES <- toupper(removed)
[17:01:02.505]                 for (kk in seq_along(NAMES)) {
[17:01:02.505]                   name <- removed[[kk]]
[17:01:02.505]                   NAME <- NAMES[[kk]]
[17:01:02.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.505]                     next
[17:01:02.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.505]                 }
[17:01:02.505]                 if (length(args) > 0) 
[17:01:02.505]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.505]             }
[17:01:02.505]             else {
[17:01:02.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.505]             }
[17:01:02.505]             {
[17:01:02.505]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.505]                   0L) {
[17:01:02.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.505]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.505]                   base::options(opts)
[17:01:02.505]                 }
[17:01:02.505]                 {
[17:01:02.505]                   {
[17:01:02.505]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.505]                     NULL
[17:01:02.505]                   }
[17:01:02.505]                   options(future.plan = NULL)
[17:01:02.505]                   if (is.na(NA_character_)) 
[17:01:02.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.505]                     .init = FALSE)
[17:01:02.505]                 }
[17:01:02.505]             }
[17:01:02.505]         }
[17:01:02.505]     })
[17:01:02.505]     if (TRUE) {
[17:01:02.505]         base::sink(type = "output", split = FALSE)
[17:01:02.505]         if (TRUE) {
[17:01:02.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.505]         }
[17:01:02.505]         else {
[17:01:02.505]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.505]         }
[17:01:02.505]         base::close(...future.stdout)
[17:01:02.505]         ...future.stdout <- NULL
[17:01:02.505]     }
[17:01:02.505]     ...future.result$conditions <- ...future.conditions
[17:01:02.505]     ...future.result$finished <- base::Sys.time()
[17:01:02.505]     ...future.result
[17:01:02.505] }
[17:01:02.509] assign_globals() ...
[17:01:02.509] List of 11
[17:01:02.509]  $ ...future.FUN            :function (x, ...)  
[17:01:02.509]  $ x_FUN                    :function (x)  
[17:01:02.509]  $ times                    : int 2
[17:01:02.509]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.509]  $ stop_if_not              :function (...)  
[17:01:02.509]  $ dim                      : NULL
[17:01:02.509]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.509]  $ future.call.arguments    : list()
[17:01:02.509]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.509]  $ ...future.elements_ii    :List of 5
[17:01:02.509]   ..$ : int 6
[17:01:02.509]   ..$ : int 7
[17:01:02.509]   ..$ : int 8
[17:01:02.509]   ..$ : int 9
[17:01:02.509]   ..$ : int 10
[17:01:02.509]  $ ...future.seeds_ii       : NULL
[17:01:02.509]  $ ...future.globals.maxSize: NULL
[17:01:02.509]  - attr(*, "where")=List of 11
[17:01:02.509]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.509]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.509]  - attr(*, "resolved")= logi FALSE
[17:01:02.509]  - attr(*, "total_size")= num 96456
[17:01:02.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.509]  - attr(*, "already-done")= logi TRUE
[17:01:02.525] - copied ‘...future.FUN’ to environment
[17:01:02.525] - reassign environment for ‘x_FUN’
[17:01:02.525] - copied ‘x_FUN’ to environment
[17:01:02.525] - copied ‘times’ to environment
[17:01:02.525] - copied ‘stopf’ to environment
[17:01:02.525] - copied ‘stop_if_not’ to environment
[17:01:02.526] - copied ‘dim’ to environment
[17:01:02.526] - copied ‘valid_types’ to environment
[17:01:02.526] - copied ‘future.call.arguments’ to environment
[17:01:02.526] - copied ‘...future.elements_ii’ to environment
[17:01:02.526] - copied ‘...future.seeds_ii’ to environment
[17:01:02.526] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.526] assign_globals() ... done
[17:01:02.526] requestCore(): workers = 2
[17:01:02.529] MulticoreFuture started
[17:01:02.529] - Launch lazy future ... done
[17:01:02.530] run() for ‘MulticoreFuture’ ... done
[17:01:02.530] Created future:
[17:01:02.530] plan(): Setting new future strategy stack:
[17:01:02.531] List of future strategies:
[17:01:02.531] 1. sequential:
[17:01:02.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.531]    - tweaked: FALSE
[17:01:02.531]    - call: NULL
[17:01:02.532] plan(): nbrOfWorkers() = 1
[17:01:02.534] plan(): Setting new future strategy stack:
[17:01:02.534] List of future strategies:
[17:01:02.534] 1. multicore:
[17:01:02.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.534]    - tweaked: FALSE
[17:01:02.534]    - call: plan(strategy)
[17:01:02.539] plan(): nbrOfWorkers() = 2
[17:01:02.530] MulticoreFuture:
[17:01:02.530] Label: ‘future_vapply-2’
[17:01:02.530] Expression:
[17:01:02.530] {
[17:01:02.530]     do.call(function(...) {
[17:01:02.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.530]             on.exit(options(oopts), add = TRUE)
[17:01:02.530]         }
[17:01:02.530]         {
[17:01:02.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.530]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.530]             })
[17:01:02.530]         }
[17:01:02.530]     }, args = future.call.arguments)
[17:01:02.530] }
[17:01:02.530] Lazy evaluation: FALSE
[17:01:02.530] Asynchronous evaluation: TRUE
[17:01:02.530] Local evaluation: TRUE
[17:01:02.530] Environment: R_GlobalEnv
[17:01:02.530] Capture standard output: TRUE
[17:01:02.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.530] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.530] Packages: 1 packages (‘future.apply’)
[17:01:02.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.530] Resolved: TRUE
[17:01:02.530] Value: <not collected>
[17:01:02.530] Conditions captured: <none>
[17:01:02.530] Early signaling: FALSE
[17:01:02.530] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.530] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.540] Chunk #2 of 2 ... DONE
[17:01:02.540] Launching 2 futures (chunks) ... DONE
[17:01:02.541] Resolving 2 futures (chunks) ...
[17:01:02.541] resolve() on list ...
[17:01:02.541]  recursive: 0
[17:01:02.541]  length: 2
[17:01:02.541] 
[17:01:02.542] Future #1
[17:01:02.542] result() for MulticoreFuture ...
[17:01:02.543] result() for MulticoreFuture ...
[17:01:02.543] result() for MulticoreFuture ... done
[17:01:02.543] result() for MulticoreFuture ... done
[17:01:02.543] result() for MulticoreFuture ...
[17:01:02.543] result() for MulticoreFuture ... done
[17:01:02.543] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.544] - nx: 2
[17:01:02.544] - relay: TRUE
[17:01:02.544] - stdout: TRUE
[17:01:02.544] - signal: TRUE
[17:01:02.544] - resignal: FALSE
[17:01:02.544] - force: TRUE
[17:01:02.544] - relayed: [n=2] FALSE, FALSE
[17:01:02.545] - queued futures: [n=2] FALSE, FALSE
[17:01:02.545]  - until=1
[17:01:02.545]  - relaying element #1
[17:01:02.545] result() for MulticoreFuture ...
[17:01:02.545] result() for MulticoreFuture ... done
[17:01:02.545] result() for MulticoreFuture ...
[17:01:02.545] result() for MulticoreFuture ... done
[17:01:02.546] result() for MulticoreFuture ...
[17:01:02.546] result() for MulticoreFuture ... done
[17:01:02.546] result() for MulticoreFuture ...
[17:01:02.546] result() for MulticoreFuture ... done
[17:01:02.546] - relayed: [n=2] TRUE, FALSE
[17:01:02.546] - queued futures: [n=2] TRUE, FALSE
[17:01:02.547] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.547]  length: 1 (resolved future 1)
[17:01:02.547] Future #2
[17:01:02.547] result() for MulticoreFuture ...
[17:01:02.548] result() for MulticoreFuture ...
[17:01:02.548] result() for MulticoreFuture ... done
[17:01:02.548] result() for MulticoreFuture ... done
[17:01:02.549] result() for MulticoreFuture ...
[17:01:02.549] result() for MulticoreFuture ... done
[17:01:02.549] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.549] - nx: 2
[17:01:02.549] - relay: TRUE
[17:01:02.549] - stdout: TRUE
[17:01:02.549] - signal: TRUE
[17:01:02.549] - resignal: FALSE
[17:01:02.550] - force: TRUE
[17:01:02.550] - relayed: [n=2] TRUE, FALSE
[17:01:02.550] - queued futures: [n=2] TRUE, FALSE
[17:01:02.550]  - until=2
[17:01:02.550]  - relaying element #2
[17:01:02.550] result() for MulticoreFuture ...
[17:01:02.550] result() for MulticoreFuture ... done
[17:01:02.550] result() for MulticoreFuture ...
[17:01:02.551] result() for MulticoreFuture ... done
[17:01:02.551] result() for MulticoreFuture ...
[17:01:02.551] result() for MulticoreFuture ... done
[17:01:02.551] result() for MulticoreFuture ...
[17:01:02.551] result() for MulticoreFuture ... done
[17:01:02.551] - relayed: [n=2] TRUE, TRUE
[17:01:02.551] - queued futures: [n=2] TRUE, TRUE
[17:01:02.551] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.552]  length: 0 (resolved future 2)
[17:01:02.552] Relaying remaining futures
[17:01:02.552] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.552] - nx: 2
[17:01:02.552] - relay: TRUE
[17:01:02.552] - stdout: TRUE
[17:01:02.552] - signal: TRUE
[17:01:02.552] - resignal: FALSE
[17:01:02.552] - force: TRUE
[17:01:02.553] - relayed: [n=2] TRUE, TRUE
[17:01:02.553] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.553] - relayed: [n=2] TRUE, TRUE
[17:01:02.553] - queued futures: [n=2] TRUE, TRUE
[17:01:02.553] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.553] resolve() on list ... DONE
[17:01:02.553] result() for MulticoreFuture ...
[17:01:02.553] result() for MulticoreFuture ... done
[17:01:02.553] result() for MulticoreFuture ...
[17:01:02.554] result() for MulticoreFuture ... done
[17:01:02.554] result() for MulticoreFuture ...
[17:01:02.554] result() for MulticoreFuture ... done
[17:01:02.554] result() for MulticoreFuture ...
[17:01:02.554] result() for MulticoreFuture ... done
[17:01:02.554]  - Number of value chunks collected: 2
[17:01:02.554] Resolving 2 futures (chunks) ... DONE
[17:01:02.554] Reducing values from 2 chunks ...
[17:01:02.554]  - Number of values collected after concatenation: 10
[17:01:02.555]  - Number of values expected: 10
[17:01:02.555] Reducing values from 2 chunks ... DONE
[17:01:02.555] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:02.556] future_lapply() ...
[17:01:02.563] Number of chunks: 2
[17:01:02.563] getGlobalsAndPackagesXApply() ...
[17:01:02.565]  - future.globals: TRUE
[17:01:02.565] getGlobalsAndPackages() ...
[17:01:02.566] Searching for globals...
[17:01:02.571] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:02.571] Searching for globals ... DONE
[17:01:02.571] Resolving globals: FALSE
[17:01:02.572] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:01:02.572] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.573] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.573] - packages: [1] ‘future.apply’
[17:01:02.573] getGlobalsAndPackages() ... DONE
[17:01:02.573]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.573]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.573] Finding globals ... DONE
[17:01:02.573]  - use_args: TRUE
[17:01:02.573]  - Getting '...' globals ...
[17:01:02.574] resolve() on list ...
[17:01:02.574]  recursive: 0
[17:01:02.574]  length: 1
[17:01:02.574]  elements: ‘...’
[17:01:02.574]  length: 0 (resolved future 1)
[17:01:02.574] resolve() on list ... DONE
[17:01:02.574]    - '...' content: [n=0] 
[17:01:02.574] List of 1
[17:01:02.574]  $ ...: list()
[17:01:02.574]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.574]  - attr(*, "where")=List of 1
[17:01:02.574]   ..$ ...:<environment: 0x55aadb529878> 
[17:01:02.574]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.574]  - attr(*, "resolved")= logi TRUE
[17:01:02.574]  - attr(*, "total_size")= num NA
[17:01:02.577]  - Getting '...' globals ... DONE
[17:01:02.577] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.577] List of 8
[17:01:02.577]  $ ...future.FUN:function (x, ...)  
[17:01:02.577]  $ x_FUN        :function (x)  
[17:01:02.577]  $ times        : int 4
[17:01:02.577]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.577]  $ stop_if_not  :function (...)  
[17:01:02.577]  $ dim          : int [1:2] 2 2
[17:01:02.577]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:02.577]  $ ...          : list()
[17:01:02.577]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.577]  - attr(*, "where")=List of 8
[17:01:02.577]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.577]   ..$ ...          :<environment: 0x55aadb529878> 
[17:01:02.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.577]  - attr(*, "resolved")= logi FALSE
[17:01:02.577]  - attr(*, "total_size")= num 97232
[17:01:02.583] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.583] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.583] Number of futures (= number of chunks): 2
[17:01:02.583] Launching 2 futures (chunks) ...
[17:01:02.583] Chunk #1 of 2 ...
[17:01:02.583]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.584] getGlobalsAndPackages() ...
[17:01:02.584] Searching for globals...
[17:01:02.584] 
[17:01:02.584] Searching for globals ... DONE
[17:01:02.584] - globals: [0] <none>
[17:01:02.584] getGlobalsAndPackages() ... DONE
[17:01:02.584]    + additional globals found: [n=0] 
[17:01:02.584]    + additional namespaces needed: [n=0] 
[17:01:02.584]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.585]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.585]  - seeds: <none>
[17:01:02.585]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.585] getGlobalsAndPackages() ...
[17:01:02.585] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.585] Resolving globals: FALSE
[17:01:02.585] Tweak future expression to call with '...' arguments ...
[17:01:02.585] {
[17:01:02.585]     do.call(function(...) {
[17:01:02.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.585]             on.exit(options(oopts), add = TRUE)
[17:01:02.585]         }
[17:01:02.585]         {
[17:01:02.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.585]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.585]             })
[17:01:02.585]         }
[17:01:02.585]     }, args = future.call.arguments)
[17:01:02.585] }
[17:01:02.586] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.586] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.588] - packages: [1] ‘future.apply’
[17:01:02.588] getGlobalsAndPackages() ... DONE
[17:01:02.589] run() for ‘Future’ ...
[17:01:02.589] - state: ‘created’
[17:01:02.589] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.593] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.593]   - Field: ‘label’
[17:01:02.593]   - Field: ‘local’
[17:01:02.594]   - Field: ‘owner’
[17:01:02.594]   - Field: ‘envir’
[17:01:02.594]   - Field: ‘workers’
[17:01:02.594]   - Field: ‘packages’
[17:01:02.594]   - Field: ‘gc’
[17:01:02.594]   - Field: ‘job’
[17:01:02.594]   - Field: ‘conditions’
[17:01:02.594]   - Field: ‘expr’
[17:01:02.595]   - Field: ‘uuid’
[17:01:02.595]   - Field: ‘seed’
[17:01:02.595]   - Field: ‘version’
[17:01:02.595]   - Field: ‘result’
[17:01:02.595]   - Field: ‘asynchronous’
[17:01:02.595]   - Field: ‘calls’
[17:01:02.595]   - Field: ‘globals’
[17:01:02.595]   - Field: ‘stdout’
[17:01:02.595]   - Field: ‘earlySignal’
[17:01:02.596]   - Field: ‘lazy’
[17:01:02.596]   - Field: ‘state’
[17:01:02.596] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.596] - Launch lazy future ...
[17:01:02.596] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.596] Packages needed by future strategies (n = 0): <none>
[17:01:02.597] {
[17:01:02.597]     {
[17:01:02.597]         {
[17:01:02.597]             ...future.startTime <- base::Sys.time()
[17:01:02.597]             {
[17:01:02.597]                 {
[17:01:02.597]                   {
[17:01:02.597]                     {
[17:01:02.597]                       {
[17:01:02.597]                         base::local({
[17:01:02.597]                           has_future <- base::requireNamespace("future", 
[17:01:02.597]                             quietly = TRUE)
[17:01:02.597]                           if (has_future) {
[17:01:02.597]                             ns <- base::getNamespace("future")
[17:01:02.597]                             version <- ns[[".package"]][["version"]]
[17:01:02.597]                             if (is.null(version)) 
[17:01:02.597]                               version <- utils::packageVersion("future")
[17:01:02.597]                           }
[17:01:02.597]                           else {
[17:01:02.597]                             version <- NULL
[17:01:02.597]                           }
[17:01:02.597]                           if (!has_future || version < "1.8.0") {
[17:01:02.597]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.597]                               "", base::R.version$version.string), 
[17:01:02.597]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.597]                                 base::R.version$platform, 8 * 
[17:01:02.597]                                   base::.Machine$sizeof.pointer), 
[17:01:02.597]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.597]                                 "release", "version")], collapse = " "), 
[17:01:02.597]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.597]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.597]                               info)
[17:01:02.597]                             info <- base::paste(info, collapse = "; ")
[17:01:02.597]                             if (!has_future) {
[17:01:02.597]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.597]                                 info)
[17:01:02.597]                             }
[17:01:02.597]                             else {
[17:01:02.597]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.597]                                 info, version)
[17:01:02.597]                             }
[17:01:02.597]                             base::stop(msg)
[17:01:02.597]                           }
[17:01:02.597]                         })
[17:01:02.597]                       }
[17:01:02.597]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.597]                       base::options(mc.cores = 1L)
[17:01:02.597]                     }
[17:01:02.597]                     base::local({
[17:01:02.597]                       for (pkg in "future.apply") {
[17:01:02.597]                         base::loadNamespace(pkg)
[17:01:02.597]                         base::library(pkg, character.only = TRUE)
[17:01:02.597]                       }
[17:01:02.597]                     })
[17:01:02.597]                   }
[17:01:02.597]                   ...future.strategy.old <- future::plan("list")
[17:01:02.597]                   options(future.plan = NULL)
[17:01:02.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.597]                 }
[17:01:02.597]                 ...future.workdir <- getwd()
[17:01:02.597]             }
[17:01:02.597]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.597]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.597]         }
[17:01:02.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.597]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.597]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.597]             base::names(...future.oldOptions))
[17:01:02.597]     }
[17:01:02.597]     if (FALSE) {
[17:01:02.597]     }
[17:01:02.597]     else {
[17:01:02.597]         if (TRUE) {
[17:01:02.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.597]                 open = "w")
[17:01:02.597]         }
[17:01:02.597]         else {
[17:01:02.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.597]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.597]         }
[17:01:02.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.597]             base::sink(type = "output", split = FALSE)
[17:01:02.597]             base::close(...future.stdout)
[17:01:02.597]         }, add = TRUE)
[17:01:02.597]     }
[17:01:02.597]     ...future.frame <- base::sys.nframe()
[17:01:02.597]     ...future.conditions <- base::list()
[17:01:02.597]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.597]     if (FALSE) {
[17:01:02.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.597]     }
[17:01:02.597]     ...future.result <- base::tryCatch({
[17:01:02.597]         base::withCallingHandlers({
[17:01:02.597]             ...future.value <- base::withVisible(base::local({
[17:01:02.597]                 withCallingHandlers({
[17:01:02.597]                   {
[17:01:02.597]                     do.call(function(...) {
[17:01:02.597]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.597]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.597]                         ...future.globals.maxSize)) {
[17:01:02.597]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.597]                         on.exit(options(oopts), add = TRUE)
[17:01:02.597]                       }
[17:01:02.597]                       {
[17:01:02.597]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.597]                           FUN = function(jj) {
[17:01:02.597]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.597]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.597]                           })
[17:01:02.597]                       }
[17:01:02.597]                     }, args = future.call.arguments)
[17:01:02.597]                   }
[17:01:02.597]                 }, immediateCondition = function(cond) {
[17:01:02.597]                   save_rds <- function (object, pathname, ...) 
[17:01:02.597]                   {
[17:01:02.597]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.597]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.597]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.597]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.597]                         fi_tmp[["mtime"]])
[17:01:02.597]                     }
[17:01:02.597]                     tryCatch({
[17:01:02.597]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.597]                     }, error = function(ex) {
[17:01:02.597]                       msg <- conditionMessage(ex)
[17:01:02.597]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.597]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.597]                         fi_tmp[["mtime"]], msg)
[17:01:02.597]                       ex$message <- msg
[17:01:02.597]                       stop(ex)
[17:01:02.597]                     })
[17:01:02.597]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.597]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.597]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.597]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.597]                       fi <- file.info(pathname)
[17:01:02.597]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.597]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.597]                         fi[["size"]], fi[["mtime"]])
[17:01:02.597]                       stop(msg)
[17:01:02.597]                     }
[17:01:02.597]                     invisible(pathname)
[17:01:02.597]                   }
[17:01:02.597]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.597]                     rootPath = tempdir()) 
[17:01:02.597]                   {
[17:01:02.597]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.597]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.597]                       tmpdir = path, fileext = ".rds")
[17:01:02.597]                     save_rds(obj, file)
[17:01:02.597]                   }
[17:01:02.597]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.597]                   {
[17:01:02.597]                     inherits <- base::inherits
[17:01:02.597]                     invokeRestart <- base::invokeRestart
[17:01:02.597]                     is.null <- base::is.null
[17:01:02.597]                     muffled <- FALSE
[17:01:02.597]                     if (inherits(cond, "message")) {
[17:01:02.597]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.597]                       if (muffled) 
[17:01:02.597]                         invokeRestart("muffleMessage")
[17:01:02.597]                     }
[17:01:02.597]                     else if (inherits(cond, "warning")) {
[17:01:02.597]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.597]                       if (muffled) 
[17:01:02.597]                         invokeRestart("muffleWarning")
[17:01:02.597]                     }
[17:01:02.597]                     else if (inherits(cond, "condition")) {
[17:01:02.597]                       if (!is.null(pattern)) {
[17:01:02.597]                         computeRestarts <- base::computeRestarts
[17:01:02.597]                         grepl <- base::grepl
[17:01:02.597]                         restarts <- computeRestarts(cond)
[17:01:02.597]                         for (restart in restarts) {
[17:01:02.597]                           name <- restart$name
[17:01:02.597]                           if (is.null(name)) 
[17:01:02.597]                             next
[17:01:02.597]                           if (!grepl(pattern, name)) 
[17:01:02.597]                             next
[17:01:02.597]                           invokeRestart(restart)
[17:01:02.597]                           muffled <- TRUE
[17:01:02.597]                           break
[17:01:02.597]                         }
[17:01:02.597]                       }
[17:01:02.597]                     }
[17:01:02.597]                     invisible(muffled)
[17:01:02.597]                   }
[17:01:02.597]                   muffleCondition(cond)
[17:01:02.597]                 })
[17:01:02.597]             }))
[17:01:02.597]             future::FutureResult(value = ...future.value$value, 
[17:01:02.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.597]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.597]                     ...future.globalenv.names))
[17:01:02.597]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.597]         }, condition = base::local({
[17:01:02.597]             c <- base::c
[17:01:02.597]             inherits <- base::inherits
[17:01:02.597]             invokeRestart <- base::invokeRestart
[17:01:02.597]             length <- base::length
[17:01:02.597]             list <- base::list
[17:01:02.597]             seq.int <- base::seq.int
[17:01:02.597]             signalCondition <- base::signalCondition
[17:01:02.597]             sys.calls <- base::sys.calls
[17:01:02.597]             `[[` <- base::`[[`
[17:01:02.597]             `+` <- base::`+`
[17:01:02.597]             `<<-` <- base::`<<-`
[17:01:02.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.597]                   3L)]
[17:01:02.597]             }
[17:01:02.597]             function(cond) {
[17:01:02.597]                 is_error <- inherits(cond, "error")
[17:01:02.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.597]                   NULL)
[17:01:02.597]                 if (is_error) {
[17:01:02.597]                   sessionInformation <- function() {
[17:01:02.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.597]                       search = base::search(), system = base::Sys.info())
[17:01:02.597]                   }
[17:01:02.597]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.597]                     cond$call), session = sessionInformation(), 
[17:01:02.597]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.597]                   signalCondition(cond)
[17:01:02.597]                 }
[17:01:02.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.597]                 "immediateCondition"))) {
[17:01:02.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.597]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.597]                   if (TRUE && !signal) {
[17:01:02.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.597]                     {
[17:01:02.597]                       inherits <- base::inherits
[17:01:02.597]                       invokeRestart <- base::invokeRestart
[17:01:02.597]                       is.null <- base::is.null
[17:01:02.597]                       muffled <- FALSE
[17:01:02.597]                       if (inherits(cond, "message")) {
[17:01:02.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.597]                         if (muffled) 
[17:01:02.597]                           invokeRestart("muffleMessage")
[17:01:02.597]                       }
[17:01:02.597]                       else if (inherits(cond, "warning")) {
[17:01:02.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.597]                         if (muffled) 
[17:01:02.597]                           invokeRestart("muffleWarning")
[17:01:02.597]                       }
[17:01:02.597]                       else if (inherits(cond, "condition")) {
[17:01:02.597]                         if (!is.null(pattern)) {
[17:01:02.597]                           computeRestarts <- base::computeRestarts
[17:01:02.597]                           grepl <- base::grepl
[17:01:02.597]                           restarts <- computeRestarts(cond)
[17:01:02.597]                           for (restart in restarts) {
[17:01:02.597]                             name <- restart$name
[17:01:02.597]                             if (is.null(name)) 
[17:01:02.597]                               next
[17:01:02.597]                             if (!grepl(pattern, name)) 
[17:01:02.597]                               next
[17:01:02.597]                             invokeRestart(restart)
[17:01:02.597]                             muffled <- TRUE
[17:01:02.597]                             break
[17:01:02.597]                           }
[17:01:02.597]                         }
[17:01:02.597]                       }
[17:01:02.597]                       invisible(muffled)
[17:01:02.597]                     }
[17:01:02.597]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.597]                   }
[17:01:02.597]                 }
[17:01:02.597]                 else {
[17:01:02.597]                   if (TRUE) {
[17:01:02.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.597]                     {
[17:01:02.597]                       inherits <- base::inherits
[17:01:02.597]                       invokeRestart <- base::invokeRestart
[17:01:02.597]                       is.null <- base::is.null
[17:01:02.597]                       muffled <- FALSE
[17:01:02.597]                       if (inherits(cond, "message")) {
[17:01:02.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.597]                         if (muffled) 
[17:01:02.597]                           invokeRestart("muffleMessage")
[17:01:02.597]                       }
[17:01:02.597]                       else if (inherits(cond, "warning")) {
[17:01:02.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.597]                         if (muffled) 
[17:01:02.597]                           invokeRestart("muffleWarning")
[17:01:02.597]                       }
[17:01:02.597]                       else if (inherits(cond, "condition")) {
[17:01:02.597]                         if (!is.null(pattern)) {
[17:01:02.597]                           computeRestarts <- base::computeRestarts
[17:01:02.597]                           grepl <- base::grepl
[17:01:02.597]                           restarts <- computeRestarts(cond)
[17:01:02.597]                           for (restart in restarts) {
[17:01:02.597]                             name <- restart$name
[17:01:02.597]                             if (is.null(name)) 
[17:01:02.597]                               next
[17:01:02.597]                             if (!grepl(pattern, name)) 
[17:01:02.597]                               next
[17:01:02.597]                             invokeRestart(restart)
[17:01:02.597]                             muffled <- TRUE
[17:01:02.597]                             break
[17:01:02.597]                           }
[17:01:02.597]                         }
[17:01:02.597]                       }
[17:01:02.597]                       invisible(muffled)
[17:01:02.597]                     }
[17:01:02.597]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.597]                   }
[17:01:02.597]                 }
[17:01:02.597]             }
[17:01:02.597]         }))
[17:01:02.597]     }, error = function(ex) {
[17:01:02.597]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.597]                 ...future.rng), started = ...future.startTime, 
[17:01:02.597]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.597]             version = "1.8"), class = "FutureResult")
[17:01:02.597]     }, finally = {
[17:01:02.597]         if (!identical(...future.workdir, getwd())) 
[17:01:02.597]             setwd(...future.workdir)
[17:01:02.597]         {
[17:01:02.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.597]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.597]             }
[17:01:02.597]             base::options(...future.oldOptions)
[17:01:02.597]             if (.Platform$OS.type == "windows") {
[17:01:02.597]                 old_names <- names(...future.oldEnvVars)
[17:01:02.597]                 envs <- base::Sys.getenv()
[17:01:02.597]                 names <- names(envs)
[17:01:02.597]                 common <- intersect(names, old_names)
[17:01:02.597]                 added <- setdiff(names, old_names)
[17:01:02.597]                 removed <- setdiff(old_names, names)
[17:01:02.597]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.597]                   envs[common]]
[17:01:02.597]                 NAMES <- toupper(changed)
[17:01:02.597]                 args <- list()
[17:01:02.597]                 for (kk in seq_along(NAMES)) {
[17:01:02.597]                   name <- changed[[kk]]
[17:01:02.597]                   NAME <- NAMES[[kk]]
[17:01:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.597]                     next
[17:01:02.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.597]                 }
[17:01:02.597]                 NAMES <- toupper(added)
[17:01:02.597]                 for (kk in seq_along(NAMES)) {
[17:01:02.597]                   name <- added[[kk]]
[17:01:02.597]                   NAME <- NAMES[[kk]]
[17:01:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.597]                     next
[17:01:02.597]                   args[[name]] <- ""
[17:01:02.597]                 }
[17:01:02.597]                 NAMES <- toupper(removed)
[17:01:02.597]                 for (kk in seq_along(NAMES)) {
[17:01:02.597]                   name <- removed[[kk]]
[17:01:02.597]                   NAME <- NAMES[[kk]]
[17:01:02.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.597]                     next
[17:01:02.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.597]                 }
[17:01:02.597]                 if (length(args) > 0) 
[17:01:02.597]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.597]             }
[17:01:02.597]             else {
[17:01:02.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.597]             }
[17:01:02.597]             {
[17:01:02.597]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.597]                   0L) {
[17:01:02.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.597]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.597]                   base::options(opts)
[17:01:02.597]                 }
[17:01:02.597]                 {
[17:01:02.597]                   {
[17:01:02.597]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.597]                     NULL
[17:01:02.597]                   }
[17:01:02.597]                   options(future.plan = NULL)
[17:01:02.597]                   if (is.na(NA_character_)) 
[17:01:02.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.597]                     .init = FALSE)
[17:01:02.597]                 }
[17:01:02.597]             }
[17:01:02.597]         }
[17:01:02.597]     })
[17:01:02.597]     if (TRUE) {
[17:01:02.597]         base::sink(type = "output", split = FALSE)
[17:01:02.597]         if (TRUE) {
[17:01:02.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.597]         }
[17:01:02.597]         else {
[17:01:02.597]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.597]         }
[17:01:02.597]         base::close(...future.stdout)
[17:01:02.597]         ...future.stdout <- NULL
[17:01:02.597]     }
[17:01:02.597]     ...future.result$conditions <- ...future.conditions
[17:01:02.597]     ...future.result$finished <- base::Sys.time()
[17:01:02.597]     ...future.result
[17:01:02.597] }
[17:01:02.599] assign_globals() ...
[17:01:02.600] List of 11
[17:01:02.600]  $ ...future.FUN            :function (x, ...)  
[17:01:02.600]  $ x_FUN                    :function (x)  
[17:01:02.600]  $ times                    : int 4
[17:01:02.600]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.600]  $ stop_if_not              :function (...)  
[17:01:02.600]  $ dim                      : int [1:2] 2 2
[17:01:02.600]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:02.600]  $ future.call.arguments    : list()
[17:01:02.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.600]  $ ...future.elements_ii    :List of 5
[17:01:02.600]   ..$ : int 1
[17:01:02.600]   ..$ : int 2
[17:01:02.600]   ..$ : int 3
[17:01:02.600]   ..$ : int 4
[17:01:02.600]   ..$ : int 5
[17:01:02.600]  $ ...future.seeds_ii       : NULL
[17:01:02.600]  $ ...future.globals.maxSize: NULL
[17:01:02.600]  - attr(*, "where")=List of 11
[17:01:02.600]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.600]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.600]  - attr(*, "resolved")= logi FALSE
[17:01:02.600]  - attr(*, "total_size")= num 97232
[17:01:02.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.600]  - attr(*, "already-done")= logi TRUE
[17:01:02.608] - copied ‘...future.FUN’ to environment
[17:01:02.608] - reassign environment for ‘x_FUN’
[17:01:02.608] - copied ‘x_FUN’ to environment
[17:01:02.608] - copied ‘times’ to environment
[17:01:02.609] - copied ‘stopf’ to environment
[17:01:02.609] - copied ‘stop_if_not’ to environment
[17:01:02.609] - copied ‘dim’ to environment
[17:01:02.609] - copied ‘valid_types’ to environment
[17:01:02.609] - copied ‘future.call.arguments’ to environment
[17:01:02.609] - copied ‘...future.elements_ii’ to environment
[17:01:02.609] - copied ‘...future.seeds_ii’ to environment
[17:01:02.609] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.609] assign_globals() ... done
[17:01:02.609] requestCore(): workers = 2
[17:01:02.612] MulticoreFuture started
[17:01:02.612] - Launch lazy future ... done
[17:01:02.612] run() for ‘MulticoreFuture’ ... done
[17:01:02.613] Created future:
[17:01:02.613] plan(): Setting new future strategy stack:
[17:01:02.613] List of future strategies:
[17:01:02.613] 1. sequential:
[17:01:02.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.613]    - tweaked: FALSE
[17:01:02.613]    - call: NULL
[17:01:02.614] plan(): nbrOfWorkers() = 1
[17:01:02.617] plan(): Setting new future strategy stack:
[17:01:02.617] List of future strategies:
[17:01:02.617] 1. multicore:
[17:01:02.617]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.617]    - tweaked: FALSE
[17:01:02.617]    - call: plan(strategy)
[17:01:02.622] plan(): nbrOfWorkers() = 2
[17:01:02.613] MulticoreFuture:
[17:01:02.613] Label: ‘future_vapply-1’
[17:01:02.613] Expression:
[17:01:02.613] {
[17:01:02.613]     do.call(function(...) {
[17:01:02.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.613]             on.exit(options(oopts), add = TRUE)
[17:01:02.613]         }
[17:01:02.613]         {
[17:01:02.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.613]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.613]             })
[17:01:02.613]         }
[17:01:02.613]     }, args = future.call.arguments)
[17:01:02.613] }
[17:01:02.613] Lazy evaluation: FALSE
[17:01:02.613] Asynchronous evaluation: TRUE
[17:01:02.613] Local evaluation: TRUE
[17:01:02.613] Environment: R_GlobalEnv
[17:01:02.613] Capture standard output: TRUE
[17:01:02.613] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.613] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.613] Packages: 1 packages (‘future.apply’)
[17:01:02.613] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.613] Resolved: TRUE
[17:01:02.613] Value: <not collected>
[17:01:02.613] Conditions captured: <none>
[17:01:02.613] Early signaling: FALSE
[17:01:02.613] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.613] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.623] Chunk #1 of 2 ... DONE
[17:01:02.623] Chunk #2 of 2 ...
[17:01:02.624]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.624] getGlobalsAndPackages() ...
[17:01:02.624] Searching for globals...
[17:01:02.624] 
[17:01:02.625] Searching for globals ... DONE
[17:01:02.625] - globals: [0] <none>
[17:01:02.625] getGlobalsAndPackages() ... DONE
[17:01:02.625]    + additional globals found: [n=0] 
[17:01:02.625]    + additional namespaces needed: [n=0] 
[17:01:02.625]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.625]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.625]  - seeds: <none>
[17:01:02.626]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.629] getGlobalsAndPackages() ...
[17:01:02.630] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.630] Resolving globals: FALSE
[17:01:02.631] Tweak future expression to call with '...' arguments ...
[17:01:02.631] {
[17:01:02.631]     do.call(function(...) {
[17:01:02.631]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.631]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.631]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.631]             on.exit(options(oopts), add = TRUE)
[17:01:02.631]         }
[17:01:02.631]         {
[17:01:02.631]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.631]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.631]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.631]             })
[17:01:02.631]         }
[17:01:02.631]     }, args = future.call.arguments)
[17:01:02.631] }
[17:01:02.632] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.634] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.634] - packages: [1] ‘future.apply’
[17:01:02.634] getGlobalsAndPackages() ... DONE
[17:01:02.635] run() for ‘Future’ ...
[17:01:02.635] - state: ‘created’
[17:01:02.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.642]   - Field: ‘label’
[17:01:02.642]   - Field: ‘local’
[17:01:02.643]   - Field: ‘owner’
[17:01:02.643]   - Field: ‘envir’
[17:01:02.643]   - Field: ‘workers’
[17:01:02.643]   - Field: ‘packages’
[17:01:02.643]   - Field: ‘gc’
[17:01:02.643]   - Field: ‘job’
[17:01:02.643]   - Field: ‘conditions’
[17:01:02.644]   - Field: ‘expr’
[17:01:02.644]   - Field: ‘uuid’
[17:01:02.644]   - Field: ‘seed’
[17:01:02.644]   - Field: ‘version’
[17:01:02.644]   - Field: ‘result’
[17:01:02.645]   - Field: ‘asynchronous’
[17:01:02.645]   - Field: ‘calls’
[17:01:02.645]   - Field: ‘globals’
[17:01:02.645]   - Field: ‘stdout’
[17:01:02.645]   - Field: ‘earlySignal’
[17:01:02.645]   - Field: ‘lazy’
[17:01:02.645]   - Field: ‘state’
[17:01:02.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.646] - Launch lazy future ...
[17:01:02.646] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.646] Packages needed by future strategies (n = 0): <none>
[17:01:02.647] {
[17:01:02.647]     {
[17:01:02.647]         {
[17:01:02.647]             ...future.startTime <- base::Sys.time()
[17:01:02.647]             {
[17:01:02.647]                 {
[17:01:02.647]                   {
[17:01:02.647]                     {
[17:01:02.647]                       {
[17:01:02.647]                         base::local({
[17:01:02.647]                           has_future <- base::requireNamespace("future", 
[17:01:02.647]                             quietly = TRUE)
[17:01:02.647]                           if (has_future) {
[17:01:02.647]                             ns <- base::getNamespace("future")
[17:01:02.647]                             version <- ns[[".package"]][["version"]]
[17:01:02.647]                             if (is.null(version)) 
[17:01:02.647]                               version <- utils::packageVersion("future")
[17:01:02.647]                           }
[17:01:02.647]                           else {
[17:01:02.647]                             version <- NULL
[17:01:02.647]                           }
[17:01:02.647]                           if (!has_future || version < "1.8.0") {
[17:01:02.647]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.647]                               "", base::R.version$version.string), 
[17:01:02.647]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.647]                                 base::R.version$platform, 8 * 
[17:01:02.647]                                   base::.Machine$sizeof.pointer), 
[17:01:02.647]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.647]                                 "release", "version")], collapse = " "), 
[17:01:02.647]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.647]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.647]                               info)
[17:01:02.647]                             info <- base::paste(info, collapse = "; ")
[17:01:02.647]                             if (!has_future) {
[17:01:02.647]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.647]                                 info)
[17:01:02.647]                             }
[17:01:02.647]                             else {
[17:01:02.647]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.647]                                 info, version)
[17:01:02.647]                             }
[17:01:02.647]                             base::stop(msg)
[17:01:02.647]                           }
[17:01:02.647]                         })
[17:01:02.647]                       }
[17:01:02.647]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.647]                       base::options(mc.cores = 1L)
[17:01:02.647]                     }
[17:01:02.647]                     base::local({
[17:01:02.647]                       for (pkg in "future.apply") {
[17:01:02.647]                         base::loadNamespace(pkg)
[17:01:02.647]                         base::library(pkg, character.only = TRUE)
[17:01:02.647]                       }
[17:01:02.647]                     })
[17:01:02.647]                   }
[17:01:02.647]                   ...future.strategy.old <- future::plan("list")
[17:01:02.647]                   options(future.plan = NULL)
[17:01:02.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.647]                 }
[17:01:02.647]                 ...future.workdir <- getwd()
[17:01:02.647]             }
[17:01:02.647]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.647]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.647]         }
[17:01:02.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.647]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.647]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.647]             base::names(...future.oldOptions))
[17:01:02.647]     }
[17:01:02.647]     if (FALSE) {
[17:01:02.647]     }
[17:01:02.647]     else {
[17:01:02.647]         if (TRUE) {
[17:01:02.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.647]                 open = "w")
[17:01:02.647]         }
[17:01:02.647]         else {
[17:01:02.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.647]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.647]         }
[17:01:02.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.647]             base::sink(type = "output", split = FALSE)
[17:01:02.647]             base::close(...future.stdout)
[17:01:02.647]         }, add = TRUE)
[17:01:02.647]     }
[17:01:02.647]     ...future.frame <- base::sys.nframe()
[17:01:02.647]     ...future.conditions <- base::list()
[17:01:02.647]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.647]     if (FALSE) {
[17:01:02.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.647]     }
[17:01:02.647]     ...future.result <- base::tryCatch({
[17:01:02.647]         base::withCallingHandlers({
[17:01:02.647]             ...future.value <- base::withVisible(base::local({
[17:01:02.647]                 withCallingHandlers({
[17:01:02.647]                   {
[17:01:02.647]                     do.call(function(...) {
[17:01:02.647]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.647]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.647]                         ...future.globals.maxSize)) {
[17:01:02.647]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.647]                         on.exit(options(oopts), add = TRUE)
[17:01:02.647]                       }
[17:01:02.647]                       {
[17:01:02.647]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.647]                           FUN = function(jj) {
[17:01:02.647]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.647]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.647]                           })
[17:01:02.647]                       }
[17:01:02.647]                     }, args = future.call.arguments)
[17:01:02.647]                   }
[17:01:02.647]                 }, immediateCondition = function(cond) {
[17:01:02.647]                   save_rds <- function (object, pathname, ...) 
[17:01:02.647]                   {
[17:01:02.647]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.647]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.647]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.647]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.647]                         fi_tmp[["mtime"]])
[17:01:02.647]                     }
[17:01:02.647]                     tryCatch({
[17:01:02.647]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.647]                     }, error = function(ex) {
[17:01:02.647]                       msg <- conditionMessage(ex)
[17:01:02.647]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.647]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.647]                         fi_tmp[["mtime"]], msg)
[17:01:02.647]                       ex$message <- msg
[17:01:02.647]                       stop(ex)
[17:01:02.647]                     })
[17:01:02.647]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.647]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.647]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.647]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.647]                       fi <- file.info(pathname)
[17:01:02.647]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.647]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.647]                         fi[["size"]], fi[["mtime"]])
[17:01:02.647]                       stop(msg)
[17:01:02.647]                     }
[17:01:02.647]                     invisible(pathname)
[17:01:02.647]                   }
[17:01:02.647]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.647]                     rootPath = tempdir()) 
[17:01:02.647]                   {
[17:01:02.647]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.647]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.647]                       tmpdir = path, fileext = ".rds")
[17:01:02.647]                     save_rds(obj, file)
[17:01:02.647]                   }
[17:01:02.647]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.647]                   {
[17:01:02.647]                     inherits <- base::inherits
[17:01:02.647]                     invokeRestart <- base::invokeRestart
[17:01:02.647]                     is.null <- base::is.null
[17:01:02.647]                     muffled <- FALSE
[17:01:02.647]                     if (inherits(cond, "message")) {
[17:01:02.647]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.647]                       if (muffled) 
[17:01:02.647]                         invokeRestart("muffleMessage")
[17:01:02.647]                     }
[17:01:02.647]                     else if (inherits(cond, "warning")) {
[17:01:02.647]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.647]                       if (muffled) 
[17:01:02.647]                         invokeRestart("muffleWarning")
[17:01:02.647]                     }
[17:01:02.647]                     else if (inherits(cond, "condition")) {
[17:01:02.647]                       if (!is.null(pattern)) {
[17:01:02.647]                         computeRestarts <- base::computeRestarts
[17:01:02.647]                         grepl <- base::grepl
[17:01:02.647]                         restarts <- computeRestarts(cond)
[17:01:02.647]                         for (restart in restarts) {
[17:01:02.647]                           name <- restart$name
[17:01:02.647]                           if (is.null(name)) 
[17:01:02.647]                             next
[17:01:02.647]                           if (!grepl(pattern, name)) 
[17:01:02.647]                             next
[17:01:02.647]                           invokeRestart(restart)
[17:01:02.647]                           muffled <- TRUE
[17:01:02.647]                           break
[17:01:02.647]                         }
[17:01:02.647]                       }
[17:01:02.647]                     }
[17:01:02.647]                     invisible(muffled)
[17:01:02.647]                   }
[17:01:02.647]                   muffleCondition(cond)
[17:01:02.647]                 })
[17:01:02.647]             }))
[17:01:02.647]             future::FutureResult(value = ...future.value$value, 
[17:01:02.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.647]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.647]                     ...future.globalenv.names))
[17:01:02.647]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.647]         }, condition = base::local({
[17:01:02.647]             c <- base::c
[17:01:02.647]             inherits <- base::inherits
[17:01:02.647]             invokeRestart <- base::invokeRestart
[17:01:02.647]             length <- base::length
[17:01:02.647]             list <- base::list
[17:01:02.647]             seq.int <- base::seq.int
[17:01:02.647]             signalCondition <- base::signalCondition
[17:01:02.647]             sys.calls <- base::sys.calls
[17:01:02.647]             `[[` <- base::`[[`
[17:01:02.647]             `+` <- base::`+`
[17:01:02.647]             `<<-` <- base::`<<-`
[17:01:02.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.647]                   3L)]
[17:01:02.647]             }
[17:01:02.647]             function(cond) {
[17:01:02.647]                 is_error <- inherits(cond, "error")
[17:01:02.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.647]                   NULL)
[17:01:02.647]                 if (is_error) {
[17:01:02.647]                   sessionInformation <- function() {
[17:01:02.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.647]                       search = base::search(), system = base::Sys.info())
[17:01:02.647]                   }
[17:01:02.647]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.647]                     cond$call), session = sessionInformation(), 
[17:01:02.647]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.647]                   signalCondition(cond)
[17:01:02.647]                 }
[17:01:02.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.647]                 "immediateCondition"))) {
[17:01:02.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.647]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.647]                   if (TRUE && !signal) {
[17:01:02.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.647]                     {
[17:01:02.647]                       inherits <- base::inherits
[17:01:02.647]                       invokeRestart <- base::invokeRestart
[17:01:02.647]                       is.null <- base::is.null
[17:01:02.647]                       muffled <- FALSE
[17:01:02.647]                       if (inherits(cond, "message")) {
[17:01:02.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.647]                         if (muffled) 
[17:01:02.647]                           invokeRestart("muffleMessage")
[17:01:02.647]                       }
[17:01:02.647]                       else if (inherits(cond, "warning")) {
[17:01:02.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.647]                         if (muffled) 
[17:01:02.647]                           invokeRestart("muffleWarning")
[17:01:02.647]                       }
[17:01:02.647]                       else if (inherits(cond, "condition")) {
[17:01:02.647]                         if (!is.null(pattern)) {
[17:01:02.647]                           computeRestarts <- base::computeRestarts
[17:01:02.647]                           grepl <- base::grepl
[17:01:02.647]                           restarts <- computeRestarts(cond)
[17:01:02.647]                           for (restart in restarts) {
[17:01:02.647]                             name <- restart$name
[17:01:02.647]                             if (is.null(name)) 
[17:01:02.647]                               next
[17:01:02.647]                             if (!grepl(pattern, name)) 
[17:01:02.647]                               next
[17:01:02.647]                             invokeRestart(restart)
[17:01:02.647]                             muffled <- TRUE
[17:01:02.647]                             break
[17:01:02.647]                           }
[17:01:02.647]                         }
[17:01:02.647]                       }
[17:01:02.647]                       invisible(muffled)
[17:01:02.647]                     }
[17:01:02.647]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.647]                   }
[17:01:02.647]                 }
[17:01:02.647]                 else {
[17:01:02.647]                   if (TRUE) {
[17:01:02.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.647]                     {
[17:01:02.647]                       inherits <- base::inherits
[17:01:02.647]                       invokeRestart <- base::invokeRestart
[17:01:02.647]                       is.null <- base::is.null
[17:01:02.647]                       muffled <- FALSE
[17:01:02.647]                       if (inherits(cond, "message")) {
[17:01:02.647]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.647]                         if (muffled) 
[17:01:02.647]                           invokeRestart("muffleMessage")
[17:01:02.647]                       }
[17:01:02.647]                       else if (inherits(cond, "warning")) {
[17:01:02.647]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.647]                         if (muffled) 
[17:01:02.647]                           invokeRestart("muffleWarning")
[17:01:02.647]                       }
[17:01:02.647]                       else if (inherits(cond, "condition")) {
[17:01:02.647]                         if (!is.null(pattern)) {
[17:01:02.647]                           computeRestarts <- base::computeRestarts
[17:01:02.647]                           grepl <- base::grepl
[17:01:02.647]                           restarts <- computeRestarts(cond)
[17:01:02.647]                           for (restart in restarts) {
[17:01:02.647]                             name <- restart$name
[17:01:02.647]                             if (is.null(name)) 
[17:01:02.647]                               next
[17:01:02.647]                             if (!grepl(pattern, name)) 
[17:01:02.647]                               next
[17:01:02.647]                             invokeRestart(restart)
[17:01:02.647]                             muffled <- TRUE
[17:01:02.647]                             break
[17:01:02.647]                           }
[17:01:02.647]                         }
[17:01:02.647]                       }
[17:01:02.647]                       invisible(muffled)
[17:01:02.647]                     }
[17:01:02.647]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.647]                   }
[17:01:02.647]                 }
[17:01:02.647]             }
[17:01:02.647]         }))
[17:01:02.647]     }, error = function(ex) {
[17:01:02.647]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.647]                 ...future.rng), started = ...future.startTime, 
[17:01:02.647]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.647]             version = "1.8"), class = "FutureResult")
[17:01:02.647]     }, finally = {
[17:01:02.647]         if (!identical(...future.workdir, getwd())) 
[17:01:02.647]             setwd(...future.workdir)
[17:01:02.647]         {
[17:01:02.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.647]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.647]             }
[17:01:02.647]             base::options(...future.oldOptions)
[17:01:02.647]             if (.Platform$OS.type == "windows") {
[17:01:02.647]                 old_names <- names(...future.oldEnvVars)
[17:01:02.647]                 envs <- base::Sys.getenv()
[17:01:02.647]                 names <- names(envs)
[17:01:02.647]                 common <- intersect(names, old_names)
[17:01:02.647]                 added <- setdiff(names, old_names)
[17:01:02.647]                 removed <- setdiff(old_names, names)
[17:01:02.647]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.647]                   envs[common]]
[17:01:02.647]                 NAMES <- toupper(changed)
[17:01:02.647]                 args <- list()
[17:01:02.647]                 for (kk in seq_along(NAMES)) {
[17:01:02.647]                   name <- changed[[kk]]
[17:01:02.647]                   NAME <- NAMES[[kk]]
[17:01:02.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.647]                     next
[17:01:02.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.647]                 }
[17:01:02.647]                 NAMES <- toupper(added)
[17:01:02.647]                 for (kk in seq_along(NAMES)) {
[17:01:02.647]                   name <- added[[kk]]
[17:01:02.647]                   NAME <- NAMES[[kk]]
[17:01:02.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.647]                     next
[17:01:02.647]                   args[[name]] <- ""
[17:01:02.647]                 }
[17:01:02.647]                 NAMES <- toupper(removed)
[17:01:02.647]                 for (kk in seq_along(NAMES)) {
[17:01:02.647]                   name <- removed[[kk]]
[17:01:02.647]                   NAME <- NAMES[[kk]]
[17:01:02.647]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.647]                     next
[17:01:02.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.647]                 }
[17:01:02.647]                 if (length(args) > 0) 
[17:01:02.647]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.647]             }
[17:01:02.647]             else {
[17:01:02.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.647]             }
[17:01:02.647]             {
[17:01:02.647]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.647]                   0L) {
[17:01:02.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.647]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.647]                   base::options(opts)
[17:01:02.647]                 }
[17:01:02.647]                 {
[17:01:02.647]                   {
[17:01:02.647]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.647]                     NULL
[17:01:02.647]                   }
[17:01:02.647]                   options(future.plan = NULL)
[17:01:02.647]                   if (is.na(NA_character_)) 
[17:01:02.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.647]                     .init = FALSE)
[17:01:02.647]                 }
[17:01:02.647]             }
[17:01:02.647]         }
[17:01:02.647]     })
[17:01:02.647]     if (TRUE) {
[17:01:02.647]         base::sink(type = "output", split = FALSE)
[17:01:02.647]         if (TRUE) {
[17:01:02.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.647]         }
[17:01:02.647]         else {
[17:01:02.647]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.647]         }
[17:01:02.647]         base::close(...future.stdout)
[17:01:02.647]         ...future.stdout <- NULL
[17:01:02.647]     }
[17:01:02.647]     ...future.result$conditions <- ...future.conditions
[17:01:02.647]     ...future.result$finished <- base::Sys.time()
[17:01:02.647]     ...future.result
[17:01:02.647] }
[17:01:02.650] assign_globals() ...
[17:01:02.650] List of 11
[17:01:02.650]  $ ...future.FUN            :function (x, ...)  
[17:01:02.650]  $ x_FUN                    :function (x)  
[17:01:02.650]  $ times                    : int 4
[17:01:02.650]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.650]  $ stop_if_not              :function (...)  
[17:01:02.650]  $ dim                      : int [1:2] 2 2
[17:01:02.650]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:02.650]  $ future.call.arguments    : list()
[17:01:02.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.650]  $ ...future.elements_ii    :List of 5
[17:01:02.650]   ..$ : int 6
[17:01:02.650]   ..$ : int 7
[17:01:02.650]   ..$ : int 8
[17:01:02.650]   ..$ : int 9
[17:01:02.650]   ..$ : int 10
[17:01:02.650]  $ ...future.seeds_ii       : NULL
[17:01:02.650]  $ ...future.globals.maxSize: NULL
[17:01:02.650]  - attr(*, "where")=List of 11
[17:01:02.650]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.650]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.650]  - attr(*, "resolved")= logi FALSE
[17:01:02.650]  - attr(*, "total_size")= num 97232
[17:01:02.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.650]  - attr(*, "already-done")= logi TRUE
[17:01:02.661] - copied ‘...future.FUN’ to environment
[17:01:02.661] - reassign environment for ‘x_FUN’
[17:01:02.661] - copied ‘x_FUN’ to environment
[17:01:02.661] - copied ‘times’ to environment
[17:01:02.662] - copied ‘stopf’ to environment
[17:01:02.662] - copied ‘stop_if_not’ to environment
[17:01:02.662] - copied ‘dim’ to environment
[17:01:02.662] - copied ‘valid_types’ to environment
[17:01:02.662] - copied ‘future.call.arguments’ to environment
[17:01:02.662] - copied ‘...future.elements_ii’ to environment
[17:01:02.662] - copied ‘...future.seeds_ii’ to environment
[17:01:02.662] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.662] assign_globals() ... done
[17:01:02.662] requestCore(): workers = 2
[17:01:02.665] MulticoreFuture started
[17:01:02.665] - Launch lazy future ... done
[17:01:02.665] run() for ‘MulticoreFuture’ ... done
[17:01:02.666] Created future:
[17:01:02.666] plan(): Setting new future strategy stack:
[17:01:02.666] List of future strategies:
[17:01:02.666] 1. sequential:
[17:01:02.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.666]    - tweaked: FALSE
[17:01:02.666]    - call: NULL
[17:01:02.667] plan(): nbrOfWorkers() = 1
[17:01:02.670] plan(): Setting new future strategy stack:
[17:01:02.670] List of future strategies:
[17:01:02.670] 1. multicore:
[17:01:02.670]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.670]    - tweaked: FALSE
[17:01:02.670]    - call: plan(strategy)
[17:01:02.666] MulticoreFuture:
[17:01:02.666] Label: ‘future_vapply-2’
[17:01:02.666] Expression:
[17:01:02.666] {
[17:01:02.666]     do.call(function(...) {
[17:01:02.666]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.666]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.666]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.666]             on.exit(options(oopts), add = TRUE)
[17:01:02.666]         }
[17:01:02.666]         {
[17:01:02.666]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.666]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.666]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.666]             })
[17:01:02.666]         }
[17:01:02.666]     }, args = future.call.arguments)
[17:01:02.666] }
[17:01:02.666] Lazy evaluation: FALSE
[17:01:02.666] Asynchronous evaluation: TRUE
[17:01:02.666] Local evaluation: TRUE
[17:01:02.666] Environment: R_GlobalEnv
[17:01:02.666] Capture standard output: TRUE
[17:01:02.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.666] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.666] Packages: 1 packages (‘future.apply’)
[17:01:02.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.666] Resolved: FALSE
[17:01:02.666] Value: <not collected>
[17:01:02.666] Conditions captured: <none>
[17:01:02.666] Early signaling: FALSE
[17:01:02.666] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.666] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.679] Chunk #2 of 2 ... DONE
[17:01:02.679] Launching 2 futures (chunks) ... DONE
[17:01:02.679] Resolving 2 futures (chunks) ...
[17:01:02.682] plan(): nbrOfWorkers() = 2
[17:01:02.679] resolve() on list ...
[17:01:02.682]  recursive: 0
[17:01:02.683]  length: 2
[17:01:02.683] 
[17:01:02.683] Future #1
[17:01:02.684] result() for MulticoreFuture ...
[17:01:02.685] result() for MulticoreFuture ...
[17:01:02.685] result() for MulticoreFuture ... done
[17:01:02.685] result() for MulticoreFuture ... done
[17:01:02.686] result() for MulticoreFuture ...
[17:01:02.686] result() for MulticoreFuture ... done
[17:01:02.686] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.686] - nx: 2
[17:01:02.687] - relay: TRUE
[17:01:02.687] - stdout: TRUE
[17:01:02.687] - signal: TRUE
[17:01:02.687] - resignal: FALSE
[17:01:02.688] - force: TRUE
[17:01:02.688] - relayed: [n=2] FALSE, FALSE
[17:01:02.688] - queued futures: [n=2] FALSE, FALSE
[17:01:02.689]  - until=1
[17:01:02.689]  - relaying element #1
[17:01:02.689] result() for MulticoreFuture ...
[17:01:02.689] result() for MulticoreFuture ... done
[17:01:02.690] result() for MulticoreFuture ...
[17:01:02.690] result() for MulticoreFuture ... done
[17:01:02.690] result() for MulticoreFuture ...
[17:01:02.691] result() for MulticoreFuture ... done
[17:01:02.691] result() for MulticoreFuture ...
[17:01:02.691] result() for MulticoreFuture ... done
[17:01:02.691] - relayed: [n=2] TRUE, FALSE
[17:01:02.691] - queued futures: [n=2] TRUE, FALSE
[17:01:02.692] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.692]  length: 1 (resolved future 1)
[17:01:02.692] Future #2
[17:01:02.692] result() for MulticoreFuture ...
[17:01:02.693] result() for MulticoreFuture ...
[17:01:02.693] result() for MulticoreFuture ... done
[17:01:02.693] result() for MulticoreFuture ... done
[17:01:02.694] result() for MulticoreFuture ...
[17:01:02.694] result() for MulticoreFuture ... done
[17:01:02.694] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.694] - nx: 2
[17:01:02.694] - relay: TRUE
[17:01:02.694] - stdout: TRUE
[17:01:02.694] - signal: TRUE
[17:01:02.695] - resignal: FALSE
[17:01:02.695] - force: TRUE
[17:01:02.695] - relayed: [n=2] TRUE, FALSE
[17:01:02.695] - queued futures: [n=2] TRUE, FALSE
[17:01:02.695]  - until=2
[17:01:02.695]  - relaying element #2
[17:01:02.695] result() for MulticoreFuture ...
[17:01:02.695] result() for MulticoreFuture ... done
[17:01:02.696] result() for MulticoreFuture ...
[17:01:02.696] result() for MulticoreFuture ... done
[17:01:02.696] result() for MulticoreFuture ...
[17:01:02.696] result() for MulticoreFuture ... done
[17:01:02.696] result() for MulticoreFuture ...
[17:01:02.696] result() for MulticoreFuture ... done
[17:01:02.696] - relayed: [n=2] TRUE, TRUE
[17:01:02.696] - queued futures: [n=2] TRUE, TRUE
[17:01:02.696] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.697]  length: 0 (resolved future 2)
[17:01:02.697] Relaying remaining futures
[17:01:02.697] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.697] - nx: 2
[17:01:02.697] - relay: TRUE
[17:01:02.697] - stdout: TRUE
[17:01:02.697] - signal: TRUE
[17:01:02.697] - resignal: FALSE
[17:01:02.697] - force: TRUE
[17:01:02.697] - relayed: [n=2] TRUE, TRUE
[17:01:02.698] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.698] - relayed: [n=2] TRUE, TRUE
[17:01:02.698] - queued futures: [n=2] TRUE, TRUE
[17:01:02.698] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.698] resolve() on list ... DONE
[17:01:02.698] result() for MulticoreFuture ...
[17:01:02.698] result() for MulticoreFuture ... done
[17:01:02.698] result() for MulticoreFuture ...
[17:01:02.698] result() for MulticoreFuture ... done
[17:01:02.699] result() for MulticoreFuture ...
[17:01:02.699] result() for MulticoreFuture ... done
[17:01:02.699] result() for MulticoreFuture ...
[17:01:02.699] result() for MulticoreFuture ... done
[17:01:02.699]  - Number of value chunks collected: 2
[17:01:02.699] Resolving 2 futures (chunks) ... DONE
[17:01:02.699] Reducing values from 2 chunks ...
[17:01:02.699]  - Number of values collected after concatenation: 10
[17:01:02.699]  - Number of values expected: 10
[17:01:02.700] Reducing values from 2 chunks ... DONE
[17:01:02.700] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:02.701] future_lapply() ...
[17:01:02.707] Number of chunks: 2
[17:01:02.707] getGlobalsAndPackagesXApply() ...
[17:01:02.707]  - future.globals: TRUE
[17:01:02.707] getGlobalsAndPackages() ...
[17:01:02.708] Searching for globals...
[17:01:02.711] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:02.712] Searching for globals ... DONE
[17:01:02.712] Resolving globals: FALSE
[17:01:02.713] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:01:02.713] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.713] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.713] - packages: [1] ‘future.apply’
[17:01:02.713] getGlobalsAndPackages() ... DONE
[17:01:02.716]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.716]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.716] Finding globals ... DONE
[17:01:02.716]  - use_args: TRUE
[17:01:02.716]  - Getting '...' globals ...
[17:01:02.717] resolve() on list ...
[17:01:02.717]  recursive: 0
[17:01:02.717]  length: 1
[17:01:02.717]  elements: ‘...’
[17:01:02.717]  length: 0 (resolved future 1)
[17:01:02.717] resolve() on list ... DONE
[17:01:02.717]    - '...' content: [n=0] 
[17:01:02.717] List of 1
[17:01:02.717]  $ ...: list()
[17:01:02.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.717]  - attr(*, "where")=List of 1
[17:01:02.717]   ..$ ...:<environment: 0x55aadac493e8> 
[17:01:02.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.717]  - attr(*, "resolved")= logi TRUE
[17:01:02.717]  - attr(*, "total_size")= num NA
[17:01:02.720]  - Getting '...' globals ... DONE
[17:01:02.721] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.721] List of 8
[17:01:02.721]  $ ...future.FUN:function (x, ...)  
[17:01:02.721]  $ x_FUN        :function (x)  
[17:01:02.721]  $ times        : int 4
[17:01:02.721]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.721]  $ stop_if_not  :function (...)  
[17:01:02.721]  $ dim          : int [1:2] 2 2
[17:01:02.721]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.721]  $ ...          : list()
[17:01:02.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.721]  - attr(*, "where")=List of 8
[17:01:02.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.721]   ..$ ...          :<environment: 0x55aadac493e8> 
[17:01:02.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.721]  - attr(*, "resolved")= logi FALSE
[17:01:02.721]  - attr(*, "total_size")= num 97304
[17:01:02.726] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.726] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.727] Number of futures (= number of chunks): 2
[17:01:02.727] Launching 2 futures (chunks) ...
[17:01:02.727] Chunk #1 of 2 ...
[17:01:02.727]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.727] getGlobalsAndPackages() ...
[17:01:02.727] Searching for globals...
[17:01:02.727] 
[17:01:02.728] Searching for globals ... DONE
[17:01:02.728] - globals: [0] <none>
[17:01:02.728] getGlobalsAndPackages() ... DONE
[17:01:02.728]    + additional globals found: [n=0] 
[17:01:02.728]    + additional namespaces needed: [n=0] 
[17:01:02.728]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.728]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.728]  - seeds: <none>
[17:01:02.728]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.728] getGlobalsAndPackages() ...
[17:01:02.728] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.729] Resolving globals: FALSE
[17:01:02.729] Tweak future expression to call with '...' arguments ...
[17:01:02.729] {
[17:01:02.729]     do.call(function(...) {
[17:01:02.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.729]             on.exit(options(oopts), add = TRUE)
[17:01:02.729]         }
[17:01:02.729]         {
[17:01:02.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.729]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.729]             })
[17:01:02.729]         }
[17:01:02.729]     }, args = future.call.arguments)
[17:01:02.729] }
[17:01:02.729] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.730] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.730] - packages: [1] ‘future.apply’
[17:01:02.730] getGlobalsAndPackages() ... DONE
[17:01:02.730] run() for ‘Future’ ...
[17:01:02.730] - state: ‘created’
[17:01:02.730] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.734] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.735]   - Field: ‘label’
[17:01:02.735]   - Field: ‘local’
[17:01:02.735]   - Field: ‘owner’
[17:01:02.735]   - Field: ‘envir’
[17:01:02.735]   - Field: ‘workers’
[17:01:02.735]   - Field: ‘packages’
[17:01:02.735]   - Field: ‘gc’
[17:01:02.735]   - Field: ‘job’
[17:01:02.735]   - Field: ‘conditions’
[17:01:02.735]   - Field: ‘expr’
[17:01:02.736]   - Field: ‘uuid’
[17:01:02.736]   - Field: ‘seed’
[17:01:02.736]   - Field: ‘version’
[17:01:02.736]   - Field: ‘result’
[17:01:02.736]   - Field: ‘asynchronous’
[17:01:02.736]   - Field: ‘calls’
[17:01:02.736]   - Field: ‘globals’
[17:01:02.736]   - Field: ‘stdout’
[17:01:02.736]   - Field: ‘earlySignal’
[17:01:02.736]   - Field: ‘lazy’
[17:01:02.736]   - Field: ‘state’
[17:01:02.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.737] - Launch lazy future ...
[17:01:02.737] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.737] Packages needed by future strategies (n = 0): <none>
[17:01:02.738] {
[17:01:02.738]     {
[17:01:02.738]         {
[17:01:02.738]             ...future.startTime <- base::Sys.time()
[17:01:02.738]             {
[17:01:02.738]                 {
[17:01:02.738]                   {
[17:01:02.738]                     {
[17:01:02.738]                       {
[17:01:02.738]                         base::local({
[17:01:02.738]                           has_future <- base::requireNamespace("future", 
[17:01:02.738]                             quietly = TRUE)
[17:01:02.738]                           if (has_future) {
[17:01:02.738]                             ns <- base::getNamespace("future")
[17:01:02.738]                             version <- ns[[".package"]][["version"]]
[17:01:02.738]                             if (is.null(version)) 
[17:01:02.738]                               version <- utils::packageVersion("future")
[17:01:02.738]                           }
[17:01:02.738]                           else {
[17:01:02.738]                             version <- NULL
[17:01:02.738]                           }
[17:01:02.738]                           if (!has_future || version < "1.8.0") {
[17:01:02.738]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.738]                               "", base::R.version$version.string), 
[17:01:02.738]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.738]                                 base::R.version$platform, 8 * 
[17:01:02.738]                                   base::.Machine$sizeof.pointer), 
[17:01:02.738]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.738]                                 "release", "version")], collapse = " "), 
[17:01:02.738]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.738]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.738]                               info)
[17:01:02.738]                             info <- base::paste(info, collapse = "; ")
[17:01:02.738]                             if (!has_future) {
[17:01:02.738]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.738]                                 info)
[17:01:02.738]                             }
[17:01:02.738]                             else {
[17:01:02.738]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.738]                                 info, version)
[17:01:02.738]                             }
[17:01:02.738]                             base::stop(msg)
[17:01:02.738]                           }
[17:01:02.738]                         })
[17:01:02.738]                       }
[17:01:02.738]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.738]                       base::options(mc.cores = 1L)
[17:01:02.738]                     }
[17:01:02.738]                     base::local({
[17:01:02.738]                       for (pkg in "future.apply") {
[17:01:02.738]                         base::loadNamespace(pkg)
[17:01:02.738]                         base::library(pkg, character.only = TRUE)
[17:01:02.738]                       }
[17:01:02.738]                     })
[17:01:02.738]                   }
[17:01:02.738]                   ...future.strategy.old <- future::plan("list")
[17:01:02.738]                   options(future.plan = NULL)
[17:01:02.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.738]                 }
[17:01:02.738]                 ...future.workdir <- getwd()
[17:01:02.738]             }
[17:01:02.738]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.738]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.738]         }
[17:01:02.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.738]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.738]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.738]             base::names(...future.oldOptions))
[17:01:02.738]     }
[17:01:02.738]     if (FALSE) {
[17:01:02.738]     }
[17:01:02.738]     else {
[17:01:02.738]         if (TRUE) {
[17:01:02.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.738]                 open = "w")
[17:01:02.738]         }
[17:01:02.738]         else {
[17:01:02.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.738]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.738]         }
[17:01:02.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.738]             base::sink(type = "output", split = FALSE)
[17:01:02.738]             base::close(...future.stdout)
[17:01:02.738]         }, add = TRUE)
[17:01:02.738]     }
[17:01:02.738]     ...future.frame <- base::sys.nframe()
[17:01:02.738]     ...future.conditions <- base::list()
[17:01:02.738]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.738]     if (FALSE) {
[17:01:02.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.738]     }
[17:01:02.738]     ...future.result <- base::tryCatch({
[17:01:02.738]         base::withCallingHandlers({
[17:01:02.738]             ...future.value <- base::withVisible(base::local({
[17:01:02.738]                 withCallingHandlers({
[17:01:02.738]                   {
[17:01:02.738]                     do.call(function(...) {
[17:01:02.738]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.738]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.738]                         ...future.globals.maxSize)) {
[17:01:02.738]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.738]                         on.exit(options(oopts), add = TRUE)
[17:01:02.738]                       }
[17:01:02.738]                       {
[17:01:02.738]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.738]                           FUN = function(jj) {
[17:01:02.738]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.738]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.738]                           })
[17:01:02.738]                       }
[17:01:02.738]                     }, args = future.call.arguments)
[17:01:02.738]                   }
[17:01:02.738]                 }, immediateCondition = function(cond) {
[17:01:02.738]                   save_rds <- function (object, pathname, ...) 
[17:01:02.738]                   {
[17:01:02.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.738]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.738]                         fi_tmp[["mtime"]])
[17:01:02.738]                     }
[17:01:02.738]                     tryCatch({
[17:01:02.738]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.738]                     }, error = function(ex) {
[17:01:02.738]                       msg <- conditionMessage(ex)
[17:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.738]                         fi_tmp[["mtime"]], msg)
[17:01:02.738]                       ex$message <- msg
[17:01:02.738]                       stop(ex)
[17:01:02.738]                     })
[17:01:02.738]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.738]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.738]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.738]                       fi <- file.info(pathname)
[17:01:02.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.738]                         fi[["size"]], fi[["mtime"]])
[17:01:02.738]                       stop(msg)
[17:01:02.738]                     }
[17:01:02.738]                     invisible(pathname)
[17:01:02.738]                   }
[17:01:02.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.738]                     rootPath = tempdir()) 
[17:01:02.738]                   {
[17:01:02.738]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.738]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.738]                       tmpdir = path, fileext = ".rds")
[17:01:02.738]                     save_rds(obj, file)
[17:01:02.738]                   }
[17:01:02.738]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.738]                   {
[17:01:02.738]                     inherits <- base::inherits
[17:01:02.738]                     invokeRestart <- base::invokeRestart
[17:01:02.738]                     is.null <- base::is.null
[17:01:02.738]                     muffled <- FALSE
[17:01:02.738]                     if (inherits(cond, "message")) {
[17:01:02.738]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.738]                       if (muffled) 
[17:01:02.738]                         invokeRestart("muffleMessage")
[17:01:02.738]                     }
[17:01:02.738]                     else if (inherits(cond, "warning")) {
[17:01:02.738]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.738]                       if (muffled) 
[17:01:02.738]                         invokeRestart("muffleWarning")
[17:01:02.738]                     }
[17:01:02.738]                     else if (inherits(cond, "condition")) {
[17:01:02.738]                       if (!is.null(pattern)) {
[17:01:02.738]                         computeRestarts <- base::computeRestarts
[17:01:02.738]                         grepl <- base::grepl
[17:01:02.738]                         restarts <- computeRestarts(cond)
[17:01:02.738]                         for (restart in restarts) {
[17:01:02.738]                           name <- restart$name
[17:01:02.738]                           if (is.null(name)) 
[17:01:02.738]                             next
[17:01:02.738]                           if (!grepl(pattern, name)) 
[17:01:02.738]                             next
[17:01:02.738]                           invokeRestart(restart)
[17:01:02.738]                           muffled <- TRUE
[17:01:02.738]                           break
[17:01:02.738]                         }
[17:01:02.738]                       }
[17:01:02.738]                     }
[17:01:02.738]                     invisible(muffled)
[17:01:02.738]                   }
[17:01:02.738]                   muffleCondition(cond)
[17:01:02.738]                 })
[17:01:02.738]             }))
[17:01:02.738]             future::FutureResult(value = ...future.value$value, 
[17:01:02.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.738]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.738]                     ...future.globalenv.names))
[17:01:02.738]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.738]         }, condition = base::local({
[17:01:02.738]             c <- base::c
[17:01:02.738]             inherits <- base::inherits
[17:01:02.738]             invokeRestart <- base::invokeRestart
[17:01:02.738]             length <- base::length
[17:01:02.738]             list <- base::list
[17:01:02.738]             seq.int <- base::seq.int
[17:01:02.738]             signalCondition <- base::signalCondition
[17:01:02.738]             sys.calls <- base::sys.calls
[17:01:02.738]             `[[` <- base::`[[`
[17:01:02.738]             `+` <- base::`+`
[17:01:02.738]             `<<-` <- base::`<<-`
[17:01:02.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.738]                   3L)]
[17:01:02.738]             }
[17:01:02.738]             function(cond) {
[17:01:02.738]                 is_error <- inherits(cond, "error")
[17:01:02.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.738]                   NULL)
[17:01:02.738]                 if (is_error) {
[17:01:02.738]                   sessionInformation <- function() {
[17:01:02.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.738]                       search = base::search(), system = base::Sys.info())
[17:01:02.738]                   }
[17:01:02.738]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.738]                     cond$call), session = sessionInformation(), 
[17:01:02.738]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.738]                   signalCondition(cond)
[17:01:02.738]                 }
[17:01:02.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.738]                 "immediateCondition"))) {
[17:01:02.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.738]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.738]                   if (TRUE && !signal) {
[17:01:02.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.738]                     {
[17:01:02.738]                       inherits <- base::inherits
[17:01:02.738]                       invokeRestart <- base::invokeRestart
[17:01:02.738]                       is.null <- base::is.null
[17:01:02.738]                       muffled <- FALSE
[17:01:02.738]                       if (inherits(cond, "message")) {
[17:01:02.738]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.738]                         if (muffled) 
[17:01:02.738]                           invokeRestart("muffleMessage")
[17:01:02.738]                       }
[17:01:02.738]                       else if (inherits(cond, "warning")) {
[17:01:02.738]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.738]                         if (muffled) 
[17:01:02.738]                           invokeRestart("muffleWarning")
[17:01:02.738]                       }
[17:01:02.738]                       else if (inherits(cond, "condition")) {
[17:01:02.738]                         if (!is.null(pattern)) {
[17:01:02.738]                           computeRestarts <- base::computeRestarts
[17:01:02.738]                           grepl <- base::grepl
[17:01:02.738]                           restarts <- computeRestarts(cond)
[17:01:02.738]                           for (restart in restarts) {
[17:01:02.738]                             name <- restart$name
[17:01:02.738]                             if (is.null(name)) 
[17:01:02.738]                               next
[17:01:02.738]                             if (!grepl(pattern, name)) 
[17:01:02.738]                               next
[17:01:02.738]                             invokeRestart(restart)
[17:01:02.738]                             muffled <- TRUE
[17:01:02.738]                             break
[17:01:02.738]                           }
[17:01:02.738]                         }
[17:01:02.738]                       }
[17:01:02.738]                       invisible(muffled)
[17:01:02.738]                     }
[17:01:02.738]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.738]                   }
[17:01:02.738]                 }
[17:01:02.738]                 else {
[17:01:02.738]                   if (TRUE) {
[17:01:02.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.738]                     {
[17:01:02.738]                       inherits <- base::inherits
[17:01:02.738]                       invokeRestart <- base::invokeRestart
[17:01:02.738]                       is.null <- base::is.null
[17:01:02.738]                       muffled <- FALSE
[17:01:02.738]                       if (inherits(cond, "message")) {
[17:01:02.738]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.738]                         if (muffled) 
[17:01:02.738]                           invokeRestart("muffleMessage")
[17:01:02.738]                       }
[17:01:02.738]                       else if (inherits(cond, "warning")) {
[17:01:02.738]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.738]                         if (muffled) 
[17:01:02.738]                           invokeRestart("muffleWarning")
[17:01:02.738]                       }
[17:01:02.738]                       else if (inherits(cond, "condition")) {
[17:01:02.738]                         if (!is.null(pattern)) {
[17:01:02.738]                           computeRestarts <- base::computeRestarts
[17:01:02.738]                           grepl <- base::grepl
[17:01:02.738]                           restarts <- computeRestarts(cond)
[17:01:02.738]                           for (restart in restarts) {
[17:01:02.738]                             name <- restart$name
[17:01:02.738]                             if (is.null(name)) 
[17:01:02.738]                               next
[17:01:02.738]                             if (!grepl(pattern, name)) 
[17:01:02.738]                               next
[17:01:02.738]                             invokeRestart(restart)
[17:01:02.738]                             muffled <- TRUE
[17:01:02.738]                             break
[17:01:02.738]                           }
[17:01:02.738]                         }
[17:01:02.738]                       }
[17:01:02.738]                       invisible(muffled)
[17:01:02.738]                     }
[17:01:02.738]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.738]                   }
[17:01:02.738]                 }
[17:01:02.738]             }
[17:01:02.738]         }))
[17:01:02.738]     }, error = function(ex) {
[17:01:02.738]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.738]                 ...future.rng), started = ...future.startTime, 
[17:01:02.738]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.738]             version = "1.8"), class = "FutureResult")
[17:01:02.738]     }, finally = {
[17:01:02.738]         if (!identical(...future.workdir, getwd())) 
[17:01:02.738]             setwd(...future.workdir)
[17:01:02.738]         {
[17:01:02.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.738]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.738]             }
[17:01:02.738]             base::options(...future.oldOptions)
[17:01:02.738]             if (.Platform$OS.type == "windows") {
[17:01:02.738]                 old_names <- names(...future.oldEnvVars)
[17:01:02.738]                 envs <- base::Sys.getenv()
[17:01:02.738]                 names <- names(envs)
[17:01:02.738]                 common <- intersect(names, old_names)
[17:01:02.738]                 added <- setdiff(names, old_names)
[17:01:02.738]                 removed <- setdiff(old_names, names)
[17:01:02.738]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.738]                   envs[common]]
[17:01:02.738]                 NAMES <- toupper(changed)
[17:01:02.738]                 args <- list()
[17:01:02.738]                 for (kk in seq_along(NAMES)) {
[17:01:02.738]                   name <- changed[[kk]]
[17:01:02.738]                   NAME <- NAMES[[kk]]
[17:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.738]                     next
[17:01:02.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.738]                 }
[17:01:02.738]                 NAMES <- toupper(added)
[17:01:02.738]                 for (kk in seq_along(NAMES)) {
[17:01:02.738]                   name <- added[[kk]]
[17:01:02.738]                   NAME <- NAMES[[kk]]
[17:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.738]                     next
[17:01:02.738]                   args[[name]] <- ""
[17:01:02.738]                 }
[17:01:02.738]                 NAMES <- toupper(removed)
[17:01:02.738]                 for (kk in seq_along(NAMES)) {
[17:01:02.738]                   name <- removed[[kk]]
[17:01:02.738]                   NAME <- NAMES[[kk]]
[17:01:02.738]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.738]                     next
[17:01:02.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.738]                 }
[17:01:02.738]                 if (length(args) > 0) 
[17:01:02.738]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.738]             }
[17:01:02.738]             else {
[17:01:02.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.738]             }
[17:01:02.738]             {
[17:01:02.738]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.738]                   0L) {
[17:01:02.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.738]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.738]                   base::options(opts)
[17:01:02.738]                 }
[17:01:02.738]                 {
[17:01:02.738]                   {
[17:01:02.738]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.738]                     NULL
[17:01:02.738]                   }
[17:01:02.738]                   options(future.plan = NULL)
[17:01:02.738]                   if (is.na(NA_character_)) 
[17:01:02.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.738]                     .init = FALSE)
[17:01:02.738]                 }
[17:01:02.738]             }
[17:01:02.738]         }
[17:01:02.738]     })
[17:01:02.738]     if (TRUE) {
[17:01:02.738]         base::sink(type = "output", split = FALSE)
[17:01:02.738]         if (TRUE) {
[17:01:02.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.738]         }
[17:01:02.738]         else {
[17:01:02.738]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.738]         }
[17:01:02.738]         base::close(...future.stdout)
[17:01:02.738]         ...future.stdout <- NULL
[17:01:02.738]     }
[17:01:02.738]     ...future.result$conditions <- ...future.conditions
[17:01:02.738]     ...future.result$finished <- base::Sys.time()
[17:01:02.738]     ...future.result
[17:01:02.738] }
[17:01:02.740] assign_globals() ...
[17:01:02.740] List of 11
[17:01:02.740]  $ ...future.FUN            :function (x, ...)  
[17:01:02.740]  $ x_FUN                    :function (x)  
[17:01:02.740]  $ times                    : int 4
[17:01:02.740]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.740]  $ stop_if_not              :function (...)  
[17:01:02.740]  $ dim                      : int [1:2] 2 2
[17:01:02.740]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.740]  $ future.call.arguments    : list()
[17:01:02.740]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.740]  $ ...future.elements_ii    :List of 5
[17:01:02.740]   ..$ : int 1
[17:01:02.740]   ..$ : int 2
[17:01:02.740]   ..$ : int 3
[17:01:02.740]   ..$ : int 4
[17:01:02.740]   ..$ : int 5
[17:01:02.740]  $ ...future.seeds_ii       : NULL
[17:01:02.740]  $ ...future.globals.maxSize: NULL
[17:01:02.740]  - attr(*, "where")=List of 11
[17:01:02.740]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.740]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.740]  - attr(*, "resolved")= logi FALSE
[17:01:02.740]  - attr(*, "total_size")= num 97304
[17:01:02.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.740]  - attr(*, "already-done")= logi TRUE
[17:01:02.752] - copied ‘...future.FUN’ to environment
[17:01:02.752] - reassign environment for ‘x_FUN’
[17:01:02.752] - copied ‘x_FUN’ to environment
[17:01:02.752] - copied ‘times’ to environment
[17:01:02.752] - copied ‘stopf’ to environment
[17:01:02.752] - copied ‘stop_if_not’ to environment
[17:01:02.752] - copied ‘dim’ to environment
[17:01:02.752] - copied ‘valid_types’ to environment
[17:01:02.753] - copied ‘future.call.arguments’ to environment
[17:01:02.753] - copied ‘...future.elements_ii’ to environment
[17:01:02.753] - copied ‘...future.seeds_ii’ to environment
[17:01:02.753] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.753] assign_globals() ... done
[17:01:02.753] requestCore(): workers = 2
[17:01:02.755] MulticoreFuture started
[17:01:02.756] - Launch lazy future ... done
[17:01:02.756] run() for ‘MulticoreFuture’ ... done
[17:01:02.756] Created future:
[17:01:02.757] plan(): Setting new future strategy stack:
[17:01:02.757] List of future strategies:
[17:01:02.757] 1. sequential:
[17:01:02.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.757]    - tweaked: FALSE
[17:01:02.757]    - call: NULL
[17:01:02.758] plan(): nbrOfWorkers() = 1
[17:01:02.760] plan(): Setting new future strategy stack:
[17:01:02.761] List of future strategies:
[17:01:02.761] 1. multicore:
[17:01:02.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.761]    - tweaked: FALSE
[17:01:02.761]    - call: plan(strategy)
[17:01:02.766] plan(): nbrOfWorkers() = 2
[17:01:02.756] MulticoreFuture:
[17:01:02.756] Label: ‘future_vapply-1’
[17:01:02.756] Expression:
[17:01:02.756] {
[17:01:02.756]     do.call(function(...) {
[17:01:02.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.756]             on.exit(options(oopts), add = TRUE)
[17:01:02.756]         }
[17:01:02.756]         {
[17:01:02.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.756]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.756]             })
[17:01:02.756]         }
[17:01:02.756]     }, args = future.call.arguments)
[17:01:02.756] }
[17:01:02.756] Lazy evaluation: FALSE
[17:01:02.756] Asynchronous evaluation: TRUE
[17:01:02.756] Local evaluation: TRUE
[17:01:02.756] Environment: R_GlobalEnv
[17:01:02.756] Capture standard output: TRUE
[17:01:02.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.756] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.756] Packages: 1 packages (‘future.apply’)
[17:01:02.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.756] Resolved: TRUE
[17:01:02.756] Value: <not collected>
[17:01:02.756] Conditions captured: <none>
[17:01:02.756] Early signaling: FALSE
[17:01:02.756] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.756] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.767] Chunk #1 of 2 ... DONE
[17:01:02.767] Chunk #2 of 2 ...
[17:01:02.767]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.768] getGlobalsAndPackages() ...
[17:01:02.768] Searching for globals...
[17:01:02.768] 
[17:01:02.768] Searching for globals ... DONE
[17:01:02.769] - globals: [0] <none>
[17:01:02.769] getGlobalsAndPackages() ... DONE
[17:01:02.769]    + additional globals found: [n=0] 
[17:01:02.769]    + additional namespaces needed: [n=0] 
[17:01:02.769]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.769]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.769]  - seeds: <none>
[17:01:02.769]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.770] getGlobalsAndPackages() ...
[17:01:02.770] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.770] Resolving globals: FALSE
[17:01:02.770] Tweak future expression to call with '...' arguments ...
[17:01:02.770] {
[17:01:02.770]     do.call(function(...) {
[17:01:02.770]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.770]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.770]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.770]             on.exit(options(oopts), add = TRUE)
[17:01:02.770]         }
[17:01:02.770]         {
[17:01:02.770]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.770]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.770]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.770]             })
[17:01:02.770]         }
[17:01:02.770]     }, args = future.call.arguments)
[17:01:02.770] }
[17:01:02.771] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.772] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.772] - packages: [1] ‘future.apply’
[17:01:02.772] getGlobalsAndPackages() ... DONE
[17:01:02.773] run() for ‘Future’ ...
[17:01:02.773] - state: ‘created’
[17:01:02.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.778]   - Field: ‘label’
[17:01:02.778]   - Field: ‘local’
[17:01:02.778]   - Field: ‘owner’
[17:01:02.778]   - Field: ‘envir’
[17:01:02.779]   - Field: ‘workers’
[17:01:02.779]   - Field: ‘packages’
[17:01:02.779]   - Field: ‘gc’
[17:01:02.779]   - Field: ‘job’
[17:01:02.779]   - Field: ‘conditions’
[17:01:02.779]   - Field: ‘expr’
[17:01:02.779]   - Field: ‘uuid’
[17:01:02.780]   - Field: ‘seed’
[17:01:02.780]   - Field: ‘version’
[17:01:02.780]   - Field: ‘result’
[17:01:02.780]   - Field: ‘asynchronous’
[17:01:02.780]   - Field: ‘calls’
[17:01:02.780]   - Field: ‘globals’
[17:01:02.780]   - Field: ‘stdout’
[17:01:02.781]   - Field: ‘earlySignal’
[17:01:02.781]   - Field: ‘lazy’
[17:01:02.781]   - Field: ‘state’
[17:01:02.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.784] - Launch lazy future ...
[17:01:02.785] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.785] Packages needed by future strategies (n = 0): <none>
[17:01:02.787] {
[17:01:02.787]     {
[17:01:02.787]         {
[17:01:02.787]             ...future.startTime <- base::Sys.time()
[17:01:02.787]             {
[17:01:02.787]                 {
[17:01:02.787]                   {
[17:01:02.787]                     {
[17:01:02.787]                       {
[17:01:02.787]                         base::local({
[17:01:02.787]                           has_future <- base::requireNamespace("future", 
[17:01:02.787]                             quietly = TRUE)
[17:01:02.787]                           if (has_future) {
[17:01:02.787]                             ns <- base::getNamespace("future")
[17:01:02.787]                             version <- ns[[".package"]][["version"]]
[17:01:02.787]                             if (is.null(version)) 
[17:01:02.787]                               version <- utils::packageVersion("future")
[17:01:02.787]                           }
[17:01:02.787]                           else {
[17:01:02.787]                             version <- NULL
[17:01:02.787]                           }
[17:01:02.787]                           if (!has_future || version < "1.8.0") {
[17:01:02.787]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.787]                               "", base::R.version$version.string), 
[17:01:02.787]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.787]                                 base::R.version$platform, 8 * 
[17:01:02.787]                                   base::.Machine$sizeof.pointer), 
[17:01:02.787]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.787]                                 "release", "version")], collapse = " "), 
[17:01:02.787]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.787]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.787]                               info)
[17:01:02.787]                             info <- base::paste(info, collapse = "; ")
[17:01:02.787]                             if (!has_future) {
[17:01:02.787]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.787]                                 info)
[17:01:02.787]                             }
[17:01:02.787]                             else {
[17:01:02.787]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.787]                                 info, version)
[17:01:02.787]                             }
[17:01:02.787]                             base::stop(msg)
[17:01:02.787]                           }
[17:01:02.787]                         })
[17:01:02.787]                       }
[17:01:02.787]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.787]                       base::options(mc.cores = 1L)
[17:01:02.787]                     }
[17:01:02.787]                     base::local({
[17:01:02.787]                       for (pkg in "future.apply") {
[17:01:02.787]                         base::loadNamespace(pkg)
[17:01:02.787]                         base::library(pkg, character.only = TRUE)
[17:01:02.787]                       }
[17:01:02.787]                     })
[17:01:02.787]                   }
[17:01:02.787]                   ...future.strategy.old <- future::plan("list")
[17:01:02.787]                   options(future.plan = NULL)
[17:01:02.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.787]                 }
[17:01:02.787]                 ...future.workdir <- getwd()
[17:01:02.787]             }
[17:01:02.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.787]         }
[17:01:02.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.787]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.787]             base::names(...future.oldOptions))
[17:01:02.787]     }
[17:01:02.787]     if (FALSE) {
[17:01:02.787]     }
[17:01:02.787]     else {
[17:01:02.787]         if (TRUE) {
[17:01:02.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.787]                 open = "w")
[17:01:02.787]         }
[17:01:02.787]         else {
[17:01:02.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.787]         }
[17:01:02.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.787]             base::sink(type = "output", split = FALSE)
[17:01:02.787]             base::close(...future.stdout)
[17:01:02.787]         }, add = TRUE)
[17:01:02.787]     }
[17:01:02.787]     ...future.frame <- base::sys.nframe()
[17:01:02.787]     ...future.conditions <- base::list()
[17:01:02.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.787]     if (FALSE) {
[17:01:02.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.787]     }
[17:01:02.787]     ...future.result <- base::tryCatch({
[17:01:02.787]         base::withCallingHandlers({
[17:01:02.787]             ...future.value <- base::withVisible(base::local({
[17:01:02.787]                 withCallingHandlers({
[17:01:02.787]                   {
[17:01:02.787]                     do.call(function(...) {
[17:01:02.787]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.787]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.787]                         ...future.globals.maxSize)) {
[17:01:02.787]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.787]                         on.exit(options(oopts), add = TRUE)
[17:01:02.787]                       }
[17:01:02.787]                       {
[17:01:02.787]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.787]                           FUN = function(jj) {
[17:01:02.787]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.787]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.787]                           })
[17:01:02.787]                       }
[17:01:02.787]                     }, args = future.call.arguments)
[17:01:02.787]                   }
[17:01:02.787]                 }, immediateCondition = function(cond) {
[17:01:02.787]                   save_rds <- function (object, pathname, ...) 
[17:01:02.787]                   {
[17:01:02.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.787]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.787]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.787]                         fi_tmp[["mtime"]])
[17:01:02.787]                     }
[17:01:02.787]                     tryCatch({
[17:01:02.787]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.787]                     }, error = function(ex) {
[17:01:02.787]                       msg <- conditionMessage(ex)
[17:01:02.787]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.787]                         fi_tmp[["mtime"]], msg)
[17:01:02.787]                       ex$message <- msg
[17:01:02.787]                       stop(ex)
[17:01:02.787]                     })
[17:01:02.787]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.787]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.787]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.787]                       fi <- file.info(pathname)
[17:01:02.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.787]                         fi[["size"]], fi[["mtime"]])
[17:01:02.787]                       stop(msg)
[17:01:02.787]                     }
[17:01:02.787]                     invisible(pathname)
[17:01:02.787]                   }
[17:01:02.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.787]                     rootPath = tempdir()) 
[17:01:02.787]                   {
[17:01:02.787]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.787]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.787]                       tmpdir = path, fileext = ".rds")
[17:01:02.787]                     save_rds(obj, file)
[17:01:02.787]                   }
[17:01:02.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.787]                   {
[17:01:02.787]                     inherits <- base::inherits
[17:01:02.787]                     invokeRestart <- base::invokeRestart
[17:01:02.787]                     is.null <- base::is.null
[17:01:02.787]                     muffled <- FALSE
[17:01:02.787]                     if (inherits(cond, "message")) {
[17:01:02.787]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.787]                       if (muffled) 
[17:01:02.787]                         invokeRestart("muffleMessage")
[17:01:02.787]                     }
[17:01:02.787]                     else if (inherits(cond, "warning")) {
[17:01:02.787]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.787]                       if (muffled) 
[17:01:02.787]                         invokeRestart("muffleWarning")
[17:01:02.787]                     }
[17:01:02.787]                     else if (inherits(cond, "condition")) {
[17:01:02.787]                       if (!is.null(pattern)) {
[17:01:02.787]                         computeRestarts <- base::computeRestarts
[17:01:02.787]                         grepl <- base::grepl
[17:01:02.787]                         restarts <- computeRestarts(cond)
[17:01:02.787]                         for (restart in restarts) {
[17:01:02.787]                           name <- restart$name
[17:01:02.787]                           if (is.null(name)) 
[17:01:02.787]                             next
[17:01:02.787]                           if (!grepl(pattern, name)) 
[17:01:02.787]                             next
[17:01:02.787]                           invokeRestart(restart)
[17:01:02.787]                           muffled <- TRUE
[17:01:02.787]                           break
[17:01:02.787]                         }
[17:01:02.787]                       }
[17:01:02.787]                     }
[17:01:02.787]                     invisible(muffled)
[17:01:02.787]                   }
[17:01:02.787]                   muffleCondition(cond)
[17:01:02.787]                 })
[17:01:02.787]             }))
[17:01:02.787]             future::FutureResult(value = ...future.value$value, 
[17:01:02.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.787]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.787]                     ...future.globalenv.names))
[17:01:02.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.787]         }, condition = base::local({
[17:01:02.787]             c <- base::c
[17:01:02.787]             inherits <- base::inherits
[17:01:02.787]             invokeRestart <- base::invokeRestart
[17:01:02.787]             length <- base::length
[17:01:02.787]             list <- base::list
[17:01:02.787]             seq.int <- base::seq.int
[17:01:02.787]             signalCondition <- base::signalCondition
[17:01:02.787]             sys.calls <- base::sys.calls
[17:01:02.787]             `[[` <- base::`[[`
[17:01:02.787]             `+` <- base::`+`
[17:01:02.787]             `<<-` <- base::`<<-`
[17:01:02.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.787]                   3L)]
[17:01:02.787]             }
[17:01:02.787]             function(cond) {
[17:01:02.787]                 is_error <- inherits(cond, "error")
[17:01:02.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.787]                   NULL)
[17:01:02.787]                 if (is_error) {
[17:01:02.787]                   sessionInformation <- function() {
[17:01:02.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.787]                       search = base::search(), system = base::Sys.info())
[17:01:02.787]                   }
[17:01:02.787]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.787]                     cond$call), session = sessionInformation(), 
[17:01:02.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.787]                   signalCondition(cond)
[17:01:02.787]                 }
[17:01:02.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.787]                 "immediateCondition"))) {
[17:01:02.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.787]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.787]                   if (TRUE && !signal) {
[17:01:02.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.787]                     {
[17:01:02.787]                       inherits <- base::inherits
[17:01:02.787]                       invokeRestart <- base::invokeRestart
[17:01:02.787]                       is.null <- base::is.null
[17:01:02.787]                       muffled <- FALSE
[17:01:02.787]                       if (inherits(cond, "message")) {
[17:01:02.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.787]                         if (muffled) 
[17:01:02.787]                           invokeRestart("muffleMessage")
[17:01:02.787]                       }
[17:01:02.787]                       else if (inherits(cond, "warning")) {
[17:01:02.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.787]                         if (muffled) 
[17:01:02.787]                           invokeRestart("muffleWarning")
[17:01:02.787]                       }
[17:01:02.787]                       else if (inherits(cond, "condition")) {
[17:01:02.787]                         if (!is.null(pattern)) {
[17:01:02.787]                           computeRestarts <- base::computeRestarts
[17:01:02.787]                           grepl <- base::grepl
[17:01:02.787]                           restarts <- computeRestarts(cond)
[17:01:02.787]                           for (restart in restarts) {
[17:01:02.787]                             name <- restart$name
[17:01:02.787]                             if (is.null(name)) 
[17:01:02.787]                               next
[17:01:02.787]                             if (!grepl(pattern, name)) 
[17:01:02.787]                               next
[17:01:02.787]                             invokeRestart(restart)
[17:01:02.787]                             muffled <- TRUE
[17:01:02.787]                             break
[17:01:02.787]                           }
[17:01:02.787]                         }
[17:01:02.787]                       }
[17:01:02.787]                       invisible(muffled)
[17:01:02.787]                     }
[17:01:02.787]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.787]                   }
[17:01:02.787]                 }
[17:01:02.787]                 else {
[17:01:02.787]                   if (TRUE) {
[17:01:02.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.787]                     {
[17:01:02.787]                       inherits <- base::inherits
[17:01:02.787]                       invokeRestart <- base::invokeRestart
[17:01:02.787]                       is.null <- base::is.null
[17:01:02.787]                       muffled <- FALSE
[17:01:02.787]                       if (inherits(cond, "message")) {
[17:01:02.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.787]                         if (muffled) 
[17:01:02.787]                           invokeRestart("muffleMessage")
[17:01:02.787]                       }
[17:01:02.787]                       else if (inherits(cond, "warning")) {
[17:01:02.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.787]                         if (muffled) 
[17:01:02.787]                           invokeRestart("muffleWarning")
[17:01:02.787]                       }
[17:01:02.787]                       else if (inherits(cond, "condition")) {
[17:01:02.787]                         if (!is.null(pattern)) {
[17:01:02.787]                           computeRestarts <- base::computeRestarts
[17:01:02.787]                           grepl <- base::grepl
[17:01:02.787]                           restarts <- computeRestarts(cond)
[17:01:02.787]                           for (restart in restarts) {
[17:01:02.787]                             name <- restart$name
[17:01:02.787]                             if (is.null(name)) 
[17:01:02.787]                               next
[17:01:02.787]                             if (!grepl(pattern, name)) 
[17:01:02.787]                               next
[17:01:02.787]                             invokeRestart(restart)
[17:01:02.787]                             muffled <- TRUE
[17:01:02.787]                             break
[17:01:02.787]                           }
[17:01:02.787]                         }
[17:01:02.787]                       }
[17:01:02.787]                       invisible(muffled)
[17:01:02.787]                     }
[17:01:02.787]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.787]                   }
[17:01:02.787]                 }
[17:01:02.787]             }
[17:01:02.787]         }))
[17:01:02.787]     }, error = function(ex) {
[17:01:02.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.787]                 ...future.rng), started = ...future.startTime, 
[17:01:02.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.787]             version = "1.8"), class = "FutureResult")
[17:01:02.787]     }, finally = {
[17:01:02.787]         if (!identical(...future.workdir, getwd())) 
[17:01:02.787]             setwd(...future.workdir)
[17:01:02.787]         {
[17:01:02.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.787]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.787]             }
[17:01:02.787]             base::options(...future.oldOptions)
[17:01:02.787]             if (.Platform$OS.type == "windows") {
[17:01:02.787]                 old_names <- names(...future.oldEnvVars)
[17:01:02.787]                 envs <- base::Sys.getenv()
[17:01:02.787]                 names <- names(envs)
[17:01:02.787]                 common <- intersect(names, old_names)
[17:01:02.787]                 added <- setdiff(names, old_names)
[17:01:02.787]                 removed <- setdiff(old_names, names)
[17:01:02.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.787]                   envs[common]]
[17:01:02.787]                 NAMES <- toupper(changed)
[17:01:02.787]                 args <- list()
[17:01:02.787]                 for (kk in seq_along(NAMES)) {
[17:01:02.787]                   name <- changed[[kk]]
[17:01:02.787]                   NAME <- NAMES[[kk]]
[17:01:02.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.787]                     next
[17:01:02.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.787]                 }
[17:01:02.787]                 NAMES <- toupper(added)
[17:01:02.787]                 for (kk in seq_along(NAMES)) {
[17:01:02.787]                   name <- added[[kk]]
[17:01:02.787]                   NAME <- NAMES[[kk]]
[17:01:02.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.787]                     next
[17:01:02.787]                   args[[name]] <- ""
[17:01:02.787]                 }
[17:01:02.787]                 NAMES <- toupper(removed)
[17:01:02.787]                 for (kk in seq_along(NAMES)) {
[17:01:02.787]                   name <- removed[[kk]]
[17:01:02.787]                   NAME <- NAMES[[kk]]
[17:01:02.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.787]                     next
[17:01:02.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.787]                 }
[17:01:02.787]                 if (length(args) > 0) 
[17:01:02.787]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.787]             }
[17:01:02.787]             else {
[17:01:02.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.787]             }
[17:01:02.787]             {
[17:01:02.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.787]                   0L) {
[17:01:02.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.787]                   base::options(opts)
[17:01:02.787]                 }
[17:01:02.787]                 {
[17:01:02.787]                   {
[17:01:02.787]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.787]                     NULL
[17:01:02.787]                   }
[17:01:02.787]                   options(future.plan = NULL)
[17:01:02.787]                   if (is.na(NA_character_)) 
[17:01:02.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.787]                     .init = FALSE)
[17:01:02.787]                 }
[17:01:02.787]             }
[17:01:02.787]         }
[17:01:02.787]     })
[17:01:02.787]     if (TRUE) {
[17:01:02.787]         base::sink(type = "output", split = FALSE)
[17:01:02.787]         if (TRUE) {
[17:01:02.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.787]         }
[17:01:02.787]         else {
[17:01:02.787]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.787]         }
[17:01:02.787]         base::close(...future.stdout)
[17:01:02.787]         ...future.stdout <- NULL
[17:01:02.787]     }
[17:01:02.787]     ...future.result$conditions <- ...future.conditions
[17:01:02.787]     ...future.result$finished <- base::Sys.time()
[17:01:02.787]     ...future.result
[17:01:02.787] }
[17:01:02.790] assign_globals() ...
[17:01:02.791] List of 11
[17:01:02.791]  $ ...future.FUN            :function (x, ...)  
[17:01:02.791]  $ x_FUN                    :function (x)  
[17:01:02.791]  $ times                    : int 4
[17:01:02.791]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.791]  $ stop_if_not              :function (...)  
[17:01:02.791]  $ dim                      : int [1:2] 2 2
[17:01:02.791]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.791]  $ future.call.arguments    : list()
[17:01:02.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.791]  $ ...future.elements_ii    :List of 5
[17:01:02.791]   ..$ : int 6
[17:01:02.791]   ..$ : int 7
[17:01:02.791]   ..$ : int 8
[17:01:02.791]   ..$ : int 9
[17:01:02.791]   ..$ : int 10
[17:01:02.791]  $ ...future.seeds_ii       : NULL
[17:01:02.791]  $ ...future.globals.maxSize: NULL
[17:01:02.791]  - attr(*, "where")=List of 11
[17:01:02.791]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.791]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.791]  - attr(*, "resolved")= logi FALSE
[17:01:02.791]  - attr(*, "total_size")= num 97304
[17:01:02.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.791]  - attr(*, "already-done")= logi TRUE
[17:01:02.804] - copied ‘...future.FUN’ to environment
[17:01:02.804] - reassign environment for ‘x_FUN’
[17:01:02.804] - copied ‘x_FUN’ to environment
[17:01:02.804] - copied ‘times’ to environment
[17:01:02.804] - copied ‘stopf’ to environment
[17:01:02.804] - copied ‘stop_if_not’ to environment
[17:01:02.804] - copied ‘dim’ to environment
[17:01:02.805] - copied ‘valid_types’ to environment
[17:01:02.805] - copied ‘future.call.arguments’ to environment
[17:01:02.805] - copied ‘...future.elements_ii’ to environment
[17:01:02.805] - copied ‘...future.seeds_ii’ to environment
[17:01:02.805] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.805] assign_globals() ... done
[17:01:02.805] requestCore(): workers = 2
[17:01:02.807] MulticoreFuture started
[17:01:02.808] - Launch lazy future ... done
[17:01:02.808] run() for ‘MulticoreFuture’ ... done
[17:01:02.808] Created future:
[17:01:02.809] plan(): Setting new future strategy stack:
[17:01:02.809] List of future strategies:
[17:01:02.809] 1. sequential:
[17:01:02.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.809]    - tweaked: FALSE
[17:01:02.809]    - call: NULL
[17:01:02.810] plan(): nbrOfWorkers() = 1
[17:01:02.812] plan(): Setting new future strategy stack:
[17:01:02.812] List of future strategies:
[17:01:02.812] 1. multicore:
[17:01:02.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.812]    - tweaked: FALSE
[17:01:02.812]    - call: plan(strategy)
[17:01:02.818] plan(): nbrOfWorkers() = 2
[17:01:02.808] MulticoreFuture:
[17:01:02.808] Label: ‘future_vapply-2’
[17:01:02.808] Expression:
[17:01:02.808] {
[17:01:02.808]     do.call(function(...) {
[17:01:02.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.808]             on.exit(options(oopts), add = TRUE)
[17:01:02.808]         }
[17:01:02.808]         {
[17:01:02.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.808]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.808]             })
[17:01:02.808]         }
[17:01:02.808]     }, args = future.call.arguments)
[17:01:02.808] }
[17:01:02.808] Lazy evaluation: FALSE
[17:01:02.808] Asynchronous evaluation: TRUE
[17:01:02.808] Local evaluation: TRUE
[17:01:02.808] Environment: R_GlobalEnv
[17:01:02.808] Capture standard output: TRUE
[17:01:02.808] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.808] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.808] Packages: 1 packages (‘future.apply’)
[17:01:02.808] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.808] Resolved: TRUE
[17:01:02.808] Value: <not collected>
[17:01:02.808] Conditions captured: <none>
[17:01:02.808] Early signaling: FALSE
[17:01:02.808] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.808] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.819] Chunk #2 of 2 ... DONE
[17:01:02.819] Launching 2 futures (chunks) ... DONE
[17:01:02.820] Resolving 2 futures (chunks) ...
[17:01:02.820] resolve() on list ...
[17:01:02.820]  recursive: 0
[17:01:02.820]  length: 2
[17:01:02.820] 
[17:01:02.820] Future #1
[17:01:02.821] result() for MulticoreFuture ...
[17:01:02.821] result() for MulticoreFuture ...
[17:01:02.822] result() for MulticoreFuture ... done
[17:01:02.822] result() for MulticoreFuture ... done
[17:01:02.822] result() for MulticoreFuture ...
[17:01:02.822] result() for MulticoreFuture ... done
[17:01:02.822] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.822] - nx: 2
[17:01:02.822] - relay: TRUE
[17:01:02.823] - stdout: TRUE
[17:01:02.823] - signal: TRUE
[17:01:02.823] - resignal: FALSE
[17:01:02.823] - force: TRUE
[17:01:02.823] - relayed: [n=2] FALSE, FALSE
[17:01:02.823] - queued futures: [n=2] FALSE, FALSE
[17:01:02.823]  - until=1
[17:01:02.824]  - relaying element #1
[17:01:02.824] result() for MulticoreFuture ...
[17:01:02.824] result() for MulticoreFuture ... done
[17:01:02.824] result() for MulticoreFuture ...
[17:01:02.824] result() for MulticoreFuture ... done
[17:01:02.824] result() for MulticoreFuture ...
[17:01:02.824] result() for MulticoreFuture ... done
[17:01:02.825] result() for MulticoreFuture ...
[17:01:02.825] result() for MulticoreFuture ... done
[17:01:02.825] - relayed: [n=2] TRUE, FALSE
[17:01:02.825] - queued futures: [n=2] TRUE, FALSE
[17:01:02.825] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.825]  length: 1 (resolved future 1)
[17:01:02.826] Future #2
[17:01:02.826] result() for MulticoreFuture ...
[17:01:02.827] result() for MulticoreFuture ...
[17:01:02.827] result() for MulticoreFuture ... done
[17:01:02.827] result() for MulticoreFuture ... done
[17:01:02.827] result() for MulticoreFuture ...
[17:01:02.827] result() for MulticoreFuture ... done
[17:01:02.827] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.827] - nx: 2
[17:01:02.828] - relay: TRUE
[17:01:02.833] - stdout: TRUE
[17:01:02.833] - signal: TRUE
[17:01:02.833] - resignal: FALSE
[17:01:02.833] - force: TRUE
[17:01:02.833] - relayed: [n=2] TRUE, FALSE
[17:01:02.834] - queued futures: [n=2] TRUE, FALSE
[17:01:02.834]  - until=2
[17:01:02.834]  - relaying element #2
[17:01:02.834] result() for MulticoreFuture ...
[17:01:02.834] result() for MulticoreFuture ... done
[17:01:02.834] result() for MulticoreFuture ...
[17:01:02.834] result() for MulticoreFuture ... done
[17:01:02.834] result() for MulticoreFuture ...
[17:01:02.834] result() for MulticoreFuture ... done
[17:01:02.835] result() for MulticoreFuture ...
[17:01:02.835] result() for MulticoreFuture ... done
[17:01:02.835] - relayed: [n=2] TRUE, TRUE
[17:01:02.835] - queued futures: [n=2] TRUE, TRUE
[17:01:02.835] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.835]  length: 0 (resolved future 2)
[17:01:02.836] Relaying remaining futures
[17:01:02.836] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.836] - nx: 2
[17:01:02.836] - relay: TRUE
[17:01:02.836] - stdout: TRUE
[17:01:02.836] - signal: TRUE
[17:01:02.836] - resignal: FALSE
[17:01:02.836] - force: TRUE
[17:01:02.837] - relayed: [n=2] TRUE, TRUE
[17:01:02.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.837] - relayed: [n=2] TRUE, TRUE
[17:01:02.837] - queued futures: [n=2] TRUE, TRUE
[17:01:02.837] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.837] resolve() on list ... DONE
[17:01:02.838] result() for MulticoreFuture ...
[17:01:02.838] result() for MulticoreFuture ... done
[17:01:02.838] result() for MulticoreFuture ...
[17:01:02.838] result() for MulticoreFuture ... done
[17:01:02.838] result() for MulticoreFuture ...
[17:01:02.838] result() for MulticoreFuture ... done
[17:01:02.838] result() for MulticoreFuture ...
[17:01:02.839] result() for MulticoreFuture ... done
[17:01:02.839]  - Number of value chunks collected: 2
[17:01:02.839] Resolving 2 futures (chunks) ... DONE
[17:01:02.839] Reducing values from 2 chunks ...
[17:01:02.839]  - Number of values collected after concatenation: 10
[17:01:02.839]  - Number of values expected: 10
[17:01:02.840] Reducing values from 2 chunks ... DONE
[17:01:02.840] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:01:02.842] future_lapply() ...
[17:01:02.848] Number of chunks: 2
[17:01:02.848] getGlobalsAndPackagesXApply() ...
[17:01:02.848]  - future.globals: TRUE
[17:01:02.848] getGlobalsAndPackages() ...
[17:01:02.848] Searching for globals...
[17:01:02.852] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:01:02.853] Searching for globals ... DONE
[17:01:02.853] Resolving globals: FALSE
[17:01:02.854] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:01:02.854] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.854] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.854] - packages: [1] ‘future.apply’
[17:01:02.854] getGlobalsAndPackages() ... DONE
[17:01:02.854]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.855]  - needed namespaces: [n=1] ‘future.apply’
[17:01:02.855] Finding globals ... DONE
[17:01:02.855]  - use_args: TRUE
[17:01:02.855]  - Getting '...' globals ...
[17:01:02.855] resolve() on list ...
[17:01:02.855]  recursive: 0
[17:01:02.855]  length: 1
[17:01:02.856]  elements: ‘...’
[17:01:02.856]  length: 0 (resolved future 1)
[17:01:02.856] resolve() on list ... DONE
[17:01:02.856]    - '...' content: [n=0] 
[17:01:02.856] List of 1
[17:01:02.856]  $ ...: list()
[17:01:02.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.856]  - attr(*, "where")=List of 1
[17:01:02.856]   ..$ ...:<environment: 0x55aad9a13d58> 
[17:01:02.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.856]  - attr(*, "resolved")= logi TRUE
[17:01:02.856]  - attr(*, "total_size")= num NA
[17:01:02.858]  - Getting '...' globals ... DONE
[17:01:02.859] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.861] List of 8
[17:01:02.861]  $ ...future.FUN:function (x, ...)  
[17:01:02.861]  $ x_FUN        :function (x)  
[17:01:02.861]  $ times        : int 4
[17:01:02.861]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.861]  $ stop_if_not  :function (...)  
[17:01:02.861]  $ dim          : int [1:2] 2 2
[17:01:02.861]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.861]  $ ...          : list()
[17:01:02.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.861]  - attr(*, "where")=List of 8
[17:01:02.861]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.861]   ..$ ...          :<environment: 0x55aad9a13d58> 
[17:01:02.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.861]  - attr(*, "resolved")= logi FALSE
[17:01:02.861]  - attr(*, "total_size")= num 105552
[17:01:02.867] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:02.867] getGlobalsAndPackagesXApply() ... DONE
[17:01:02.868] Number of futures (= number of chunks): 2
[17:01:02.868] Launching 2 futures (chunks) ...
[17:01:02.868] Chunk #1 of 2 ...
[17:01:02.868]  - Finding globals in 'X' for chunk #1 ...
[17:01:02.868] getGlobalsAndPackages() ...
[17:01:02.868] Searching for globals...
[17:01:02.868] 
[17:01:02.869] Searching for globals ... DONE
[17:01:02.869] - globals: [0] <none>
[17:01:02.869] getGlobalsAndPackages() ... DONE
[17:01:02.869]    + additional globals found: [n=0] 
[17:01:02.869]    + additional namespaces needed: [n=0] 
[17:01:02.869]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:02.869]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.869]  - seeds: <none>
[17:01:02.869]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.869] getGlobalsAndPackages() ...
[17:01:02.869] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.870] Resolving globals: FALSE
[17:01:02.870] Tweak future expression to call with '...' arguments ...
[17:01:02.870] {
[17:01:02.870]     do.call(function(...) {
[17:01:02.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.870]             on.exit(options(oopts), add = TRUE)
[17:01:02.870]         }
[17:01:02.870]         {
[17:01:02.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.870]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.870]             })
[17:01:02.870]         }
[17:01:02.870]     }, args = future.call.arguments)
[17:01:02.870] }
[17:01:02.870] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.871] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.871] - packages: [1] ‘future.apply’
[17:01:02.871] getGlobalsAndPackages() ... DONE
[17:01:02.871] run() for ‘Future’ ...
[17:01:02.871] - state: ‘created’
[17:01:02.871] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.875] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.875]   - Field: ‘label’
[17:01:02.875]   - Field: ‘local’
[17:01:02.876]   - Field: ‘owner’
[17:01:02.876]   - Field: ‘envir’
[17:01:02.876]   - Field: ‘workers’
[17:01:02.876]   - Field: ‘packages’
[17:01:02.876]   - Field: ‘gc’
[17:01:02.876]   - Field: ‘job’
[17:01:02.876]   - Field: ‘conditions’
[17:01:02.876]   - Field: ‘expr’
[17:01:02.876]   - Field: ‘uuid’
[17:01:02.876]   - Field: ‘seed’
[17:01:02.876]   - Field: ‘version’
[17:01:02.877]   - Field: ‘result’
[17:01:02.877]   - Field: ‘asynchronous’
[17:01:02.877]   - Field: ‘calls’
[17:01:02.877]   - Field: ‘globals’
[17:01:02.877]   - Field: ‘stdout’
[17:01:02.877]   - Field: ‘earlySignal’
[17:01:02.877]   - Field: ‘lazy’
[17:01:02.877]   - Field: ‘state’
[17:01:02.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.877] - Launch lazy future ...
[17:01:02.878] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.878] Packages needed by future strategies (n = 0): <none>
[17:01:02.878] {
[17:01:02.878]     {
[17:01:02.878]         {
[17:01:02.878]             ...future.startTime <- base::Sys.time()
[17:01:02.878]             {
[17:01:02.878]                 {
[17:01:02.878]                   {
[17:01:02.878]                     {
[17:01:02.878]                       {
[17:01:02.878]                         base::local({
[17:01:02.878]                           has_future <- base::requireNamespace("future", 
[17:01:02.878]                             quietly = TRUE)
[17:01:02.878]                           if (has_future) {
[17:01:02.878]                             ns <- base::getNamespace("future")
[17:01:02.878]                             version <- ns[[".package"]][["version"]]
[17:01:02.878]                             if (is.null(version)) 
[17:01:02.878]                               version <- utils::packageVersion("future")
[17:01:02.878]                           }
[17:01:02.878]                           else {
[17:01:02.878]                             version <- NULL
[17:01:02.878]                           }
[17:01:02.878]                           if (!has_future || version < "1.8.0") {
[17:01:02.878]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.878]                               "", base::R.version$version.string), 
[17:01:02.878]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.878]                                 base::R.version$platform, 8 * 
[17:01:02.878]                                   base::.Machine$sizeof.pointer), 
[17:01:02.878]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.878]                                 "release", "version")], collapse = " "), 
[17:01:02.878]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.878]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.878]                               info)
[17:01:02.878]                             info <- base::paste(info, collapse = "; ")
[17:01:02.878]                             if (!has_future) {
[17:01:02.878]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.878]                                 info)
[17:01:02.878]                             }
[17:01:02.878]                             else {
[17:01:02.878]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.878]                                 info, version)
[17:01:02.878]                             }
[17:01:02.878]                             base::stop(msg)
[17:01:02.878]                           }
[17:01:02.878]                         })
[17:01:02.878]                       }
[17:01:02.878]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.878]                       base::options(mc.cores = 1L)
[17:01:02.878]                     }
[17:01:02.878]                     base::local({
[17:01:02.878]                       for (pkg in "future.apply") {
[17:01:02.878]                         base::loadNamespace(pkg)
[17:01:02.878]                         base::library(pkg, character.only = TRUE)
[17:01:02.878]                       }
[17:01:02.878]                     })
[17:01:02.878]                   }
[17:01:02.878]                   ...future.strategy.old <- future::plan("list")
[17:01:02.878]                   options(future.plan = NULL)
[17:01:02.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.878]                 }
[17:01:02.878]                 ...future.workdir <- getwd()
[17:01:02.878]             }
[17:01:02.878]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.878]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.878]         }
[17:01:02.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.878]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.878]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.878]             base::names(...future.oldOptions))
[17:01:02.878]     }
[17:01:02.878]     if (FALSE) {
[17:01:02.878]     }
[17:01:02.878]     else {
[17:01:02.878]         if (TRUE) {
[17:01:02.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.878]                 open = "w")
[17:01:02.878]         }
[17:01:02.878]         else {
[17:01:02.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.878]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.878]         }
[17:01:02.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.878]             base::sink(type = "output", split = FALSE)
[17:01:02.878]             base::close(...future.stdout)
[17:01:02.878]         }, add = TRUE)
[17:01:02.878]     }
[17:01:02.878]     ...future.frame <- base::sys.nframe()
[17:01:02.878]     ...future.conditions <- base::list()
[17:01:02.878]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.878]     if (FALSE) {
[17:01:02.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.878]     }
[17:01:02.878]     ...future.result <- base::tryCatch({
[17:01:02.878]         base::withCallingHandlers({
[17:01:02.878]             ...future.value <- base::withVisible(base::local({
[17:01:02.878]                 withCallingHandlers({
[17:01:02.878]                   {
[17:01:02.878]                     do.call(function(...) {
[17:01:02.878]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.878]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.878]                         ...future.globals.maxSize)) {
[17:01:02.878]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.878]                         on.exit(options(oopts), add = TRUE)
[17:01:02.878]                       }
[17:01:02.878]                       {
[17:01:02.878]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.878]                           FUN = function(jj) {
[17:01:02.878]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.878]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.878]                           })
[17:01:02.878]                       }
[17:01:02.878]                     }, args = future.call.arguments)
[17:01:02.878]                   }
[17:01:02.878]                 }, immediateCondition = function(cond) {
[17:01:02.878]                   save_rds <- function (object, pathname, ...) 
[17:01:02.878]                   {
[17:01:02.878]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.878]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.878]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.878]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.878]                         fi_tmp[["mtime"]])
[17:01:02.878]                     }
[17:01:02.878]                     tryCatch({
[17:01:02.878]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.878]                     }, error = function(ex) {
[17:01:02.878]                       msg <- conditionMessage(ex)
[17:01:02.878]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.878]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.878]                         fi_tmp[["mtime"]], msg)
[17:01:02.878]                       ex$message <- msg
[17:01:02.878]                       stop(ex)
[17:01:02.878]                     })
[17:01:02.878]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.878]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.878]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.878]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.878]                       fi <- file.info(pathname)
[17:01:02.878]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.878]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.878]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.878]                         fi[["size"]], fi[["mtime"]])
[17:01:02.878]                       stop(msg)
[17:01:02.878]                     }
[17:01:02.878]                     invisible(pathname)
[17:01:02.878]                   }
[17:01:02.878]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.878]                     rootPath = tempdir()) 
[17:01:02.878]                   {
[17:01:02.878]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.878]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.878]                       tmpdir = path, fileext = ".rds")
[17:01:02.878]                     save_rds(obj, file)
[17:01:02.878]                   }
[17:01:02.878]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.878]                   {
[17:01:02.878]                     inherits <- base::inherits
[17:01:02.878]                     invokeRestart <- base::invokeRestart
[17:01:02.878]                     is.null <- base::is.null
[17:01:02.878]                     muffled <- FALSE
[17:01:02.878]                     if (inherits(cond, "message")) {
[17:01:02.878]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.878]                       if (muffled) 
[17:01:02.878]                         invokeRestart("muffleMessage")
[17:01:02.878]                     }
[17:01:02.878]                     else if (inherits(cond, "warning")) {
[17:01:02.878]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.878]                       if (muffled) 
[17:01:02.878]                         invokeRestart("muffleWarning")
[17:01:02.878]                     }
[17:01:02.878]                     else if (inherits(cond, "condition")) {
[17:01:02.878]                       if (!is.null(pattern)) {
[17:01:02.878]                         computeRestarts <- base::computeRestarts
[17:01:02.878]                         grepl <- base::grepl
[17:01:02.878]                         restarts <- computeRestarts(cond)
[17:01:02.878]                         for (restart in restarts) {
[17:01:02.878]                           name <- restart$name
[17:01:02.878]                           if (is.null(name)) 
[17:01:02.878]                             next
[17:01:02.878]                           if (!grepl(pattern, name)) 
[17:01:02.878]                             next
[17:01:02.878]                           invokeRestart(restart)
[17:01:02.878]                           muffled <- TRUE
[17:01:02.878]                           break
[17:01:02.878]                         }
[17:01:02.878]                       }
[17:01:02.878]                     }
[17:01:02.878]                     invisible(muffled)
[17:01:02.878]                   }
[17:01:02.878]                   muffleCondition(cond)
[17:01:02.878]                 })
[17:01:02.878]             }))
[17:01:02.878]             future::FutureResult(value = ...future.value$value, 
[17:01:02.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.878]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.878]                     ...future.globalenv.names))
[17:01:02.878]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.878]         }, condition = base::local({
[17:01:02.878]             c <- base::c
[17:01:02.878]             inherits <- base::inherits
[17:01:02.878]             invokeRestart <- base::invokeRestart
[17:01:02.878]             length <- base::length
[17:01:02.878]             list <- base::list
[17:01:02.878]             seq.int <- base::seq.int
[17:01:02.878]             signalCondition <- base::signalCondition
[17:01:02.878]             sys.calls <- base::sys.calls
[17:01:02.878]             `[[` <- base::`[[`
[17:01:02.878]             `+` <- base::`+`
[17:01:02.878]             `<<-` <- base::`<<-`
[17:01:02.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.878]                   3L)]
[17:01:02.878]             }
[17:01:02.878]             function(cond) {
[17:01:02.878]                 is_error <- inherits(cond, "error")
[17:01:02.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.878]                   NULL)
[17:01:02.878]                 if (is_error) {
[17:01:02.878]                   sessionInformation <- function() {
[17:01:02.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.878]                       search = base::search(), system = base::Sys.info())
[17:01:02.878]                   }
[17:01:02.878]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.878]                     cond$call), session = sessionInformation(), 
[17:01:02.878]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.878]                   signalCondition(cond)
[17:01:02.878]                 }
[17:01:02.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.878]                 "immediateCondition"))) {
[17:01:02.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.878]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.878]                   if (TRUE && !signal) {
[17:01:02.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.878]                     {
[17:01:02.878]                       inherits <- base::inherits
[17:01:02.878]                       invokeRestart <- base::invokeRestart
[17:01:02.878]                       is.null <- base::is.null
[17:01:02.878]                       muffled <- FALSE
[17:01:02.878]                       if (inherits(cond, "message")) {
[17:01:02.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.878]                         if (muffled) 
[17:01:02.878]                           invokeRestart("muffleMessage")
[17:01:02.878]                       }
[17:01:02.878]                       else if (inherits(cond, "warning")) {
[17:01:02.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.878]                         if (muffled) 
[17:01:02.878]                           invokeRestart("muffleWarning")
[17:01:02.878]                       }
[17:01:02.878]                       else if (inherits(cond, "condition")) {
[17:01:02.878]                         if (!is.null(pattern)) {
[17:01:02.878]                           computeRestarts <- base::computeRestarts
[17:01:02.878]                           grepl <- base::grepl
[17:01:02.878]                           restarts <- computeRestarts(cond)
[17:01:02.878]                           for (restart in restarts) {
[17:01:02.878]                             name <- restart$name
[17:01:02.878]                             if (is.null(name)) 
[17:01:02.878]                               next
[17:01:02.878]                             if (!grepl(pattern, name)) 
[17:01:02.878]                               next
[17:01:02.878]                             invokeRestart(restart)
[17:01:02.878]                             muffled <- TRUE
[17:01:02.878]                             break
[17:01:02.878]                           }
[17:01:02.878]                         }
[17:01:02.878]                       }
[17:01:02.878]                       invisible(muffled)
[17:01:02.878]                     }
[17:01:02.878]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.878]                   }
[17:01:02.878]                 }
[17:01:02.878]                 else {
[17:01:02.878]                   if (TRUE) {
[17:01:02.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.878]                     {
[17:01:02.878]                       inherits <- base::inherits
[17:01:02.878]                       invokeRestart <- base::invokeRestart
[17:01:02.878]                       is.null <- base::is.null
[17:01:02.878]                       muffled <- FALSE
[17:01:02.878]                       if (inherits(cond, "message")) {
[17:01:02.878]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.878]                         if (muffled) 
[17:01:02.878]                           invokeRestart("muffleMessage")
[17:01:02.878]                       }
[17:01:02.878]                       else if (inherits(cond, "warning")) {
[17:01:02.878]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.878]                         if (muffled) 
[17:01:02.878]                           invokeRestart("muffleWarning")
[17:01:02.878]                       }
[17:01:02.878]                       else if (inherits(cond, "condition")) {
[17:01:02.878]                         if (!is.null(pattern)) {
[17:01:02.878]                           computeRestarts <- base::computeRestarts
[17:01:02.878]                           grepl <- base::grepl
[17:01:02.878]                           restarts <- computeRestarts(cond)
[17:01:02.878]                           for (restart in restarts) {
[17:01:02.878]                             name <- restart$name
[17:01:02.878]                             if (is.null(name)) 
[17:01:02.878]                               next
[17:01:02.878]                             if (!grepl(pattern, name)) 
[17:01:02.878]                               next
[17:01:02.878]                             invokeRestart(restart)
[17:01:02.878]                             muffled <- TRUE
[17:01:02.878]                             break
[17:01:02.878]                           }
[17:01:02.878]                         }
[17:01:02.878]                       }
[17:01:02.878]                       invisible(muffled)
[17:01:02.878]                     }
[17:01:02.878]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.878]                   }
[17:01:02.878]                 }
[17:01:02.878]             }
[17:01:02.878]         }))
[17:01:02.878]     }, error = function(ex) {
[17:01:02.878]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.878]                 ...future.rng), started = ...future.startTime, 
[17:01:02.878]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.878]             version = "1.8"), class = "FutureResult")
[17:01:02.878]     }, finally = {
[17:01:02.878]         if (!identical(...future.workdir, getwd())) 
[17:01:02.878]             setwd(...future.workdir)
[17:01:02.878]         {
[17:01:02.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.878]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.878]             }
[17:01:02.878]             base::options(...future.oldOptions)
[17:01:02.878]             if (.Platform$OS.type == "windows") {
[17:01:02.878]                 old_names <- names(...future.oldEnvVars)
[17:01:02.878]                 envs <- base::Sys.getenv()
[17:01:02.878]                 names <- names(envs)
[17:01:02.878]                 common <- intersect(names, old_names)
[17:01:02.878]                 added <- setdiff(names, old_names)
[17:01:02.878]                 removed <- setdiff(old_names, names)
[17:01:02.878]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.878]                   envs[common]]
[17:01:02.878]                 NAMES <- toupper(changed)
[17:01:02.878]                 args <- list()
[17:01:02.878]                 for (kk in seq_along(NAMES)) {
[17:01:02.878]                   name <- changed[[kk]]
[17:01:02.878]                   NAME <- NAMES[[kk]]
[17:01:02.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.878]                     next
[17:01:02.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.878]                 }
[17:01:02.878]                 NAMES <- toupper(added)
[17:01:02.878]                 for (kk in seq_along(NAMES)) {
[17:01:02.878]                   name <- added[[kk]]
[17:01:02.878]                   NAME <- NAMES[[kk]]
[17:01:02.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.878]                     next
[17:01:02.878]                   args[[name]] <- ""
[17:01:02.878]                 }
[17:01:02.878]                 NAMES <- toupper(removed)
[17:01:02.878]                 for (kk in seq_along(NAMES)) {
[17:01:02.878]                   name <- removed[[kk]]
[17:01:02.878]                   NAME <- NAMES[[kk]]
[17:01:02.878]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.878]                     next
[17:01:02.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.878]                 }
[17:01:02.878]                 if (length(args) > 0) 
[17:01:02.878]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.878]             }
[17:01:02.878]             else {
[17:01:02.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.878]             }
[17:01:02.878]             {
[17:01:02.878]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.878]                   0L) {
[17:01:02.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.878]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.878]                   base::options(opts)
[17:01:02.878]                 }
[17:01:02.878]                 {
[17:01:02.878]                   {
[17:01:02.878]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.878]                     NULL
[17:01:02.878]                   }
[17:01:02.878]                   options(future.plan = NULL)
[17:01:02.878]                   if (is.na(NA_character_)) 
[17:01:02.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.878]                     .init = FALSE)
[17:01:02.878]                 }
[17:01:02.878]             }
[17:01:02.878]         }
[17:01:02.878]     })
[17:01:02.878]     if (TRUE) {
[17:01:02.878]         base::sink(type = "output", split = FALSE)
[17:01:02.878]         if (TRUE) {
[17:01:02.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.878]         }
[17:01:02.878]         else {
[17:01:02.878]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.878]         }
[17:01:02.878]         base::close(...future.stdout)
[17:01:02.878]         ...future.stdout <- NULL
[17:01:02.878]     }
[17:01:02.878]     ...future.result$conditions <- ...future.conditions
[17:01:02.878]     ...future.result$finished <- base::Sys.time()
[17:01:02.878]     ...future.result
[17:01:02.878] }
[17:01:02.881] assign_globals() ...
[17:01:02.881] List of 11
[17:01:02.881]  $ ...future.FUN            :function (x, ...)  
[17:01:02.881]  $ x_FUN                    :function (x)  
[17:01:02.881]  $ times                    : int 4
[17:01:02.881]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.881]  $ stop_if_not              :function (...)  
[17:01:02.881]  $ dim                      : int [1:2] 2 2
[17:01:02.881]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.881]  $ future.call.arguments    : list()
[17:01:02.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.881]  $ ...future.elements_ii    :List of 5
[17:01:02.881]   ..$ : int 1
[17:01:02.881]   ..$ : int 2
[17:01:02.881]   ..$ : int 3
[17:01:02.881]   ..$ : int 4
[17:01:02.881]   ..$ : int 5
[17:01:02.881]  $ ...future.seeds_ii       : NULL
[17:01:02.881]  $ ...future.globals.maxSize: NULL
[17:01:02.881]  - attr(*, "where")=List of 11
[17:01:02.881]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.881]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.881]  - attr(*, "resolved")= logi FALSE
[17:01:02.881]  - attr(*, "total_size")= num 105552
[17:01:02.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.881]  - attr(*, "already-done")= logi TRUE
[17:01:02.892] - copied ‘...future.FUN’ to environment
[17:01:02.893] - reassign environment for ‘x_FUN’
[17:01:02.893] - copied ‘x_FUN’ to environment
[17:01:02.893] - copied ‘times’ to environment
[17:01:02.893] - copied ‘stopf’ to environment
[17:01:02.893] - copied ‘stop_if_not’ to environment
[17:01:02.893] - copied ‘dim’ to environment
[17:01:02.893] - copied ‘valid_types’ to environment
[17:01:02.893] - copied ‘future.call.arguments’ to environment
[17:01:02.893] - copied ‘...future.elements_ii’ to environment
[17:01:02.894] - copied ‘...future.seeds_ii’ to environment
[17:01:02.894] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.894] assign_globals() ... done
[17:01:02.894] requestCore(): workers = 2
[17:01:02.896] MulticoreFuture started
[17:01:02.897] - Launch lazy future ... done
[17:01:02.897] run() for ‘MulticoreFuture’ ... done
[17:01:02.898] Created future:
[17:01:02.898] plan(): Setting new future strategy stack:
[17:01:02.898] List of future strategies:
[17:01:02.898] 1. sequential:
[17:01:02.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.898]    - tweaked: FALSE
[17:01:02.898]    - call: NULL
[17:01:02.899] plan(): nbrOfWorkers() = 1
[17:01:02.902] plan(): Setting new future strategy stack:
[17:01:02.902] List of future strategies:
[17:01:02.902] 1. multicore:
[17:01:02.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.902]    - tweaked: FALSE
[17:01:02.902]    - call: plan(strategy)
[17:01:02.907] plan(): nbrOfWorkers() = 2
[17:01:02.898] MulticoreFuture:
[17:01:02.898] Label: ‘future_vapply-1’
[17:01:02.898] Expression:
[17:01:02.898] {
[17:01:02.898]     do.call(function(...) {
[17:01:02.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.898]             on.exit(options(oopts), add = TRUE)
[17:01:02.898]         }
[17:01:02.898]         {
[17:01:02.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.898]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.898]             })
[17:01:02.898]         }
[17:01:02.898]     }, args = future.call.arguments)
[17:01:02.898] }
[17:01:02.898] Lazy evaluation: FALSE
[17:01:02.898] Asynchronous evaluation: TRUE
[17:01:02.898] Local evaluation: TRUE
[17:01:02.898] Environment: R_GlobalEnv
[17:01:02.898] Capture standard output: TRUE
[17:01:02.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.898] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.898] Packages: 1 packages (‘future.apply’)
[17:01:02.898] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.898] Resolved: TRUE
[17:01:02.898] Value: <not collected>
[17:01:02.898] Conditions captured: <none>
[17:01:02.898] Early signaling: FALSE
[17:01:02.898] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.898] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.908] Chunk #1 of 2 ... DONE
[17:01:02.909] Chunk #2 of 2 ...
[17:01:02.909]  - Finding globals in 'X' for chunk #2 ...
[17:01:02.909] getGlobalsAndPackages() ...
[17:01:02.909] Searching for globals...
[17:01:02.910] 
[17:01:02.910] Searching for globals ... DONE
[17:01:02.910] - globals: [0] <none>
[17:01:02.910] getGlobalsAndPackages() ... DONE
[17:01:02.910]    + additional globals found: [n=0] 
[17:01:02.910]    + additional namespaces needed: [n=0] 
[17:01:02.910]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:02.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:02.911]  - seeds: <none>
[17:01:02.911]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.911] getGlobalsAndPackages() ...
[17:01:02.911] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.911] Resolving globals: FALSE
[17:01:02.911] Tweak future expression to call with '...' arguments ...
[17:01:02.912] {
[17:01:02.912]     do.call(function(...) {
[17:01:02.912]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.912]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.912]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.912]             on.exit(options(oopts), add = TRUE)
[17:01:02.912]         }
[17:01:02.912]         {
[17:01:02.912]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.912]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.912]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.912]             })
[17:01:02.912]         }
[17:01:02.912]     }, args = future.call.arguments)
[17:01:02.912] }
[17:01:02.912] Tweak future expression to call with '...' arguments ... DONE
[17:01:02.913] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:02.913] - packages: [1] ‘future.apply’
[17:01:02.913] getGlobalsAndPackages() ... DONE
[17:01:02.914] run() for ‘Future’ ...
[17:01:02.914] - state: ‘created’
[17:01:02.914] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:02.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:02.919]   - Field: ‘label’
[17:01:02.919]   - Field: ‘local’
[17:01:02.920]   - Field: ‘owner’
[17:01:02.920]   - Field: ‘envir’
[17:01:02.920]   - Field: ‘workers’
[17:01:02.920]   - Field: ‘packages’
[17:01:02.920]   - Field: ‘gc’
[17:01:02.920]   - Field: ‘job’
[17:01:02.921]   - Field: ‘conditions’
[17:01:02.921]   - Field: ‘expr’
[17:01:02.921]   - Field: ‘uuid’
[17:01:02.921]   - Field: ‘seed’
[17:01:02.921]   - Field: ‘version’
[17:01:02.921]   - Field: ‘result’
[17:01:02.921]   - Field: ‘asynchronous’
[17:01:02.922]   - Field: ‘calls’
[17:01:02.922]   - Field: ‘globals’
[17:01:02.922]   - Field: ‘stdout’
[17:01:02.922]   - Field: ‘earlySignal’
[17:01:02.922]   - Field: ‘lazy’
[17:01:02.922]   - Field: ‘state’
[17:01:02.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:02.923] - Launch lazy future ...
[17:01:02.923] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:02.923] Packages needed by future strategies (n = 0): <none>
[17:01:02.924] {
[17:01:02.924]     {
[17:01:02.924]         {
[17:01:02.924]             ...future.startTime <- base::Sys.time()
[17:01:02.924]             {
[17:01:02.924]                 {
[17:01:02.924]                   {
[17:01:02.924]                     {
[17:01:02.924]                       {
[17:01:02.924]                         base::local({
[17:01:02.924]                           has_future <- base::requireNamespace("future", 
[17:01:02.924]                             quietly = TRUE)
[17:01:02.924]                           if (has_future) {
[17:01:02.924]                             ns <- base::getNamespace("future")
[17:01:02.924]                             version <- ns[[".package"]][["version"]]
[17:01:02.924]                             if (is.null(version)) 
[17:01:02.924]                               version <- utils::packageVersion("future")
[17:01:02.924]                           }
[17:01:02.924]                           else {
[17:01:02.924]                             version <- NULL
[17:01:02.924]                           }
[17:01:02.924]                           if (!has_future || version < "1.8.0") {
[17:01:02.924]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:02.924]                               "", base::R.version$version.string), 
[17:01:02.924]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:02.924]                                 base::R.version$platform, 8 * 
[17:01:02.924]                                   base::.Machine$sizeof.pointer), 
[17:01:02.924]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:02.924]                                 "release", "version")], collapse = " "), 
[17:01:02.924]                               hostname = base::Sys.info()[["nodename"]])
[17:01:02.924]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:02.924]                               info)
[17:01:02.924]                             info <- base::paste(info, collapse = "; ")
[17:01:02.924]                             if (!has_future) {
[17:01:02.924]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:02.924]                                 info)
[17:01:02.924]                             }
[17:01:02.924]                             else {
[17:01:02.924]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:02.924]                                 info, version)
[17:01:02.924]                             }
[17:01:02.924]                             base::stop(msg)
[17:01:02.924]                           }
[17:01:02.924]                         })
[17:01:02.924]                       }
[17:01:02.924]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:02.924]                       base::options(mc.cores = 1L)
[17:01:02.924]                     }
[17:01:02.924]                     base::local({
[17:01:02.924]                       for (pkg in "future.apply") {
[17:01:02.924]                         base::loadNamespace(pkg)
[17:01:02.924]                         base::library(pkg, character.only = TRUE)
[17:01:02.924]                       }
[17:01:02.924]                     })
[17:01:02.924]                   }
[17:01:02.924]                   ...future.strategy.old <- future::plan("list")
[17:01:02.924]                   options(future.plan = NULL)
[17:01:02.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:02.924]                 }
[17:01:02.924]                 ...future.workdir <- getwd()
[17:01:02.924]             }
[17:01:02.924]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:02.924]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:02.924]         }
[17:01:02.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:02.924]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:02.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:02.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:02.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:02.924]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:02.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:02.924]             base::names(...future.oldOptions))
[17:01:02.924]     }
[17:01:02.924]     if (FALSE) {
[17:01:02.924]     }
[17:01:02.924]     else {
[17:01:02.924]         if (TRUE) {
[17:01:02.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:02.924]                 open = "w")
[17:01:02.924]         }
[17:01:02.924]         else {
[17:01:02.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:02.924]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:02.924]         }
[17:01:02.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:02.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:02.924]             base::sink(type = "output", split = FALSE)
[17:01:02.924]             base::close(...future.stdout)
[17:01:02.924]         }, add = TRUE)
[17:01:02.924]     }
[17:01:02.924]     ...future.frame <- base::sys.nframe()
[17:01:02.924]     ...future.conditions <- base::list()
[17:01:02.924]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:02.924]     if (FALSE) {
[17:01:02.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:02.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:02.924]     }
[17:01:02.924]     ...future.result <- base::tryCatch({
[17:01:02.924]         base::withCallingHandlers({
[17:01:02.924]             ...future.value <- base::withVisible(base::local({
[17:01:02.924]                 withCallingHandlers({
[17:01:02.924]                   {
[17:01:02.924]                     do.call(function(...) {
[17:01:02.924]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.924]                       if (!identical(...future.globals.maxSize.org, 
[17:01:02.924]                         ...future.globals.maxSize)) {
[17:01:02.924]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.924]                         on.exit(options(oopts), add = TRUE)
[17:01:02.924]                       }
[17:01:02.924]                       {
[17:01:02.924]                         lapply(seq_along(...future.elements_ii), 
[17:01:02.924]                           FUN = function(jj) {
[17:01:02.924]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.924]                             ...future.FUN(...future.X_jj, ...)
[17:01:02.924]                           })
[17:01:02.924]                       }
[17:01:02.924]                     }, args = future.call.arguments)
[17:01:02.924]                   }
[17:01:02.924]                 }, immediateCondition = function(cond) {
[17:01:02.924]                   save_rds <- function (object, pathname, ...) 
[17:01:02.924]                   {
[17:01:02.924]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:02.924]                     if (file_test("-f", pathname_tmp)) {
[17:01:02.924]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.924]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:02.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.924]                         fi_tmp[["mtime"]])
[17:01:02.924]                     }
[17:01:02.924]                     tryCatch({
[17:01:02.924]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:02.924]                     }, error = function(ex) {
[17:01:02.924]                       msg <- conditionMessage(ex)
[17:01:02.924]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.924]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:02.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.924]                         fi_tmp[["mtime"]], msg)
[17:01:02.924]                       ex$message <- msg
[17:01:02.924]                       stop(ex)
[17:01:02.924]                     })
[17:01:02.924]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:02.924]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:02.924]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:02.924]                       fi_tmp <- file.info(pathname_tmp)
[17:01:02.924]                       fi <- file.info(pathname)
[17:01:02.924]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:02.924]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:02.924]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:02.924]                         fi[["size"]], fi[["mtime"]])
[17:01:02.924]                       stop(msg)
[17:01:02.924]                     }
[17:01:02.924]                     invisible(pathname)
[17:01:02.924]                   }
[17:01:02.924]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:02.924]                     rootPath = tempdir()) 
[17:01:02.924]                   {
[17:01:02.924]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:02.924]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:02.924]                       tmpdir = path, fileext = ".rds")
[17:01:02.924]                     save_rds(obj, file)
[17:01:02.924]                   }
[17:01:02.924]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:02.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.924]                   {
[17:01:02.924]                     inherits <- base::inherits
[17:01:02.924]                     invokeRestart <- base::invokeRestart
[17:01:02.924]                     is.null <- base::is.null
[17:01:02.924]                     muffled <- FALSE
[17:01:02.924]                     if (inherits(cond, "message")) {
[17:01:02.924]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:02.924]                       if (muffled) 
[17:01:02.924]                         invokeRestart("muffleMessage")
[17:01:02.924]                     }
[17:01:02.924]                     else if (inherits(cond, "warning")) {
[17:01:02.924]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:02.924]                       if (muffled) 
[17:01:02.924]                         invokeRestart("muffleWarning")
[17:01:02.924]                     }
[17:01:02.924]                     else if (inherits(cond, "condition")) {
[17:01:02.924]                       if (!is.null(pattern)) {
[17:01:02.924]                         computeRestarts <- base::computeRestarts
[17:01:02.924]                         grepl <- base::grepl
[17:01:02.924]                         restarts <- computeRestarts(cond)
[17:01:02.924]                         for (restart in restarts) {
[17:01:02.924]                           name <- restart$name
[17:01:02.924]                           if (is.null(name)) 
[17:01:02.924]                             next
[17:01:02.924]                           if (!grepl(pattern, name)) 
[17:01:02.924]                             next
[17:01:02.924]                           invokeRestart(restart)
[17:01:02.924]                           muffled <- TRUE
[17:01:02.924]                           break
[17:01:02.924]                         }
[17:01:02.924]                       }
[17:01:02.924]                     }
[17:01:02.924]                     invisible(muffled)
[17:01:02.924]                   }
[17:01:02.924]                   muffleCondition(cond)
[17:01:02.924]                 })
[17:01:02.924]             }))
[17:01:02.924]             future::FutureResult(value = ...future.value$value, 
[17:01:02.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.924]                   ...future.rng), globalenv = if (FALSE) 
[17:01:02.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:02.924]                     ...future.globalenv.names))
[17:01:02.924]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:02.924]         }, condition = base::local({
[17:01:02.924]             c <- base::c
[17:01:02.924]             inherits <- base::inherits
[17:01:02.924]             invokeRestart <- base::invokeRestart
[17:01:02.924]             length <- base::length
[17:01:02.924]             list <- base::list
[17:01:02.924]             seq.int <- base::seq.int
[17:01:02.924]             signalCondition <- base::signalCondition
[17:01:02.924]             sys.calls <- base::sys.calls
[17:01:02.924]             `[[` <- base::`[[`
[17:01:02.924]             `+` <- base::`+`
[17:01:02.924]             `<<-` <- base::`<<-`
[17:01:02.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:02.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:02.924]                   3L)]
[17:01:02.924]             }
[17:01:02.924]             function(cond) {
[17:01:02.924]                 is_error <- inherits(cond, "error")
[17:01:02.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:02.924]                   NULL)
[17:01:02.924]                 if (is_error) {
[17:01:02.924]                   sessionInformation <- function() {
[17:01:02.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:02.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:02.924]                       search = base::search(), system = base::Sys.info())
[17:01:02.924]                   }
[17:01:02.924]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:02.924]                     cond$call), session = sessionInformation(), 
[17:01:02.924]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:02.924]                   signalCondition(cond)
[17:01:02.924]                 }
[17:01:02.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:02.924]                 "immediateCondition"))) {
[17:01:02.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:02.924]                   ...future.conditions[[length(...future.conditions) + 
[17:01:02.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:02.924]                   if (TRUE && !signal) {
[17:01:02.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.924]                     {
[17:01:02.924]                       inherits <- base::inherits
[17:01:02.924]                       invokeRestart <- base::invokeRestart
[17:01:02.924]                       is.null <- base::is.null
[17:01:02.924]                       muffled <- FALSE
[17:01:02.924]                       if (inherits(cond, "message")) {
[17:01:02.924]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.924]                         if (muffled) 
[17:01:02.924]                           invokeRestart("muffleMessage")
[17:01:02.924]                       }
[17:01:02.924]                       else if (inherits(cond, "warning")) {
[17:01:02.924]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.924]                         if (muffled) 
[17:01:02.924]                           invokeRestart("muffleWarning")
[17:01:02.924]                       }
[17:01:02.924]                       else if (inherits(cond, "condition")) {
[17:01:02.924]                         if (!is.null(pattern)) {
[17:01:02.924]                           computeRestarts <- base::computeRestarts
[17:01:02.924]                           grepl <- base::grepl
[17:01:02.924]                           restarts <- computeRestarts(cond)
[17:01:02.924]                           for (restart in restarts) {
[17:01:02.924]                             name <- restart$name
[17:01:02.924]                             if (is.null(name)) 
[17:01:02.924]                               next
[17:01:02.924]                             if (!grepl(pattern, name)) 
[17:01:02.924]                               next
[17:01:02.924]                             invokeRestart(restart)
[17:01:02.924]                             muffled <- TRUE
[17:01:02.924]                             break
[17:01:02.924]                           }
[17:01:02.924]                         }
[17:01:02.924]                       }
[17:01:02.924]                       invisible(muffled)
[17:01:02.924]                     }
[17:01:02.924]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.924]                   }
[17:01:02.924]                 }
[17:01:02.924]                 else {
[17:01:02.924]                   if (TRUE) {
[17:01:02.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:02.924]                     {
[17:01:02.924]                       inherits <- base::inherits
[17:01:02.924]                       invokeRestart <- base::invokeRestart
[17:01:02.924]                       is.null <- base::is.null
[17:01:02.924]                       muffled <- FALSE
[17:01:02.924]                       if (inherits(cond, "message")) {
[17:01:02.924]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:02.924]                         if (muffled) 
[17:01:02.924]                           invokeRestart("muffleMessage")
[17:01:02.924]                       }
[17:01:02.924]                       else if (inherits(cond, "warning")) {
[17:01:02.924]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:02.924]                         if (muffled) 
[17:01:02.924]                           invokeRestart("muffleWarning")
[17:01:02.924]                       }
[17:01:02.924]                       else if (inherits(cond, "condition")) {
[17:01:02.924]                         if (!is.null(pattern)) {
[17:01:02.924]                           computeRestarts <- base::computeRestarts
[17:01:02.924]                           grepl <- base::grepl
[17:01:02.924]                           restarts <- computeRestarts(cond)
[17:01:02.924]                           for (restart in restarts) {
[17:01:02.924]                             name <- restart$name
[17:01:02.924]                             if (is.null(name)) 
[17:01:02.924]                               next
[17:01:02.924]                             if (!grepl(pattern, name)) 
[17:01:02.924]                               next
[17:01:02.924]                             invokeRestart(restart)
[17:01:02.924]                             muffled <- TRUE
[17:01:02.924]                             break
[17:01:02.924]                           }
[17:01:02.924]                         }
[17:01:02.924]                       }
[17:01:02.924]                       invisible(muffled)
[17:01:02.924]                     }
[17:01:02.924]                     muffleCondition(cond, pattern = "^muffle")
[17:01:02.924]                   }
[17:01:02.924]                 }
[17:01:02.924]             }
[17:01:02.924]         }))
[17:01:02.924]     }, error = function(ex) {
[17:01:02.924]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:02.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:02.924]                 ...future.rng), started = ...future.startTime, 
[17:01:02.924]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:02.924]             version = "1.8"), class = "FutureResult")
[17:01:02.924]     }, finally = {
[17:01:02.924]         if (!identical(...future.workdir, getwd())) 
[17:01:02.924]             setwd(...future.workdir)
[17:01:02.924]         {
[17:01:02.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:02.924]                 ...future.oldOptions$nwarnings <- NULL
[17:01:02.924]             }
[17:01:02.924]             base::options(...future.oldOptions)
[17:01:02.924]             if (.Platform$OS.type == "windows") {
[17:01:02.924]                 old_names <- names(...future.oldEnvVars)
[17:01:02.924]                 envs <- base::Sys.getenv()
[17:01:02.924]                 names <- names(envs)
[17:01:02.924]                 common <- intersect(names, old_names)
[17:01:02.924]                 added <- setdiff(names, old_names)
[17:01:02.924]                 removed <- setdiff(old_names, names)
[17:01:02.924]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:02.924]                   envs[common]]
[17:01:02.924]                 NAMES <- toupper(changed)
[17:01:02.924]                 args <- list()
[17:01:02.924]                 for (kk in seq_along(NAMES)) {
[17:01:02.924]                   name <- changed[[kk]]
[17:01:02.924]                   NAME <- NAMES[[kk]]
[17:01:02.924]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.924]                     next
[17:01:02.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.924]                 }
[17:01:02.924]                 NAMES <- toupper(added)
[17:01:02.924]                 for (kk in seq_along(NAMES)) {
[17:01:02.924]                   name <- added[[kk]]
[17:01:02.924]                   NAME <- NAMES[[kk]]
[17:01:02.924]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.924]                     next
[17:01:02.924]                   args[[name]] <- ""
[17:01:02.924]                 }
[17:01:02.924]                 NAMES <- toupper(removed)
[17:01:02.924]                 for (kk in seq_along(NAMES)) {
[17:01:02.924]                   name <- removed[[kk]]
[17:01:02.924]                   NAME <- NAMES[[kk]]
[17:01:02.924]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:02.924]                     next
[17:01:02.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:02.924]                 }
[17:01:02.924]                 if (length(args) > 0) 
[17:01:02.924]                   base::do.call(base::Sys.setenv, args = args)
[17:01:02.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:02.924]             }
[17:01:02.924]             else {
[17:01:02.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:02.924]             }
[17:01:02.924]             {
[17:01:02.924]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:02.924]                   0L) {
[17:01:02.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:02.924]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:02.924]                   base::options(opts)
[17:01:02.924]                 }
[17:01:02.924]                 {
[17:01:02.924]                   {
[17:01:02.924]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:02.924]                     NULL
[17:01:02.924]                   }
[17:01:02.924]                   options(future.plan = NULL)
[17:01:02.924]                   if (is.na(NA_character_)) 
[17:01:02.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:02.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:02.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:02.924]                     .init = FALSE)
[17:01:02.924]                 }
[17:01:02.924]             }
[17:01:02.924]         }
[17:01:02.924]     })
[17:01:02.924]     if (TRUE) {
[17:01:02.924]         base::sink(type = "output", split = FALSE)
[17:01:02.924]         if (TRUE) {
[17:01:02.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:02.924]         }
[17:01:02.924]         else {
[17:01:02.924]             ...future.result["stdout"] <- base::list(NULL)
[17:01:02.924]         }
[17:01:02.924]         base::close(...future.stdout)
[17:01:02.924]         ...future.stdout <- NULL
[17:01:02.924]     }
[17:01:02.924]     ...future.result$conditions <- ...future.conditions
[17:01:02.924]     ...future.result$finished <- base::Sys.time()
[17:01:02.924]     ...future.result
[17:01:02.924] }
[17:01:02.928] assign_globals() ...
[17:01:02.928] List of 11
[17:01:02.928]  $ ...future.FUN            :function (x, ...)  
[17:01:02.928]  $ x_FUN                    :function (x)  
[17:01:02.928]  $ times                    : int 4
[17:01:02.928]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.928]  $ stop_if_not              :function (...)  
[17:01:02.928]  $ dim                      : int [1:2] 2 2
[17:01:02.928]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:02.928]  $ future.call.arguments    : list()
[17:01:02.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.928]  $ ...future.elements_ii    :List of 5
[17:01:02.928]   ..$ : int 6
[17:01:02.928]   ..$ : int 7
[17:01:02.928]   ..$ : int 8
[17:01:02.928]   ..$ : int 9
[17:01:02.928]   ..$ : int 10
[17:01:02.928]  $ ...future.seeds_ii       : NULL
[17:01:02.928]  $ ...future.globals.maxSize: NULL
[17:01:02.928]  - attr(*, "where")=List of 11
[17:01:02.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:02.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:02.928]  - attr(*, "resolved")= logi FALSE
[17:01:02.928]  - attr(*, "total_size")= num 105552
[17:01:02.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.928]  - attr(*, "already-done")= logi TRUE
[17:01:02.945] - copied ‘...future.FUN’ to environment
[17:01:02.945] - reassign environment for ‘x_FUN’
[17:01:02.945] - copied ‘x_FUN’ to environment
[17:01:02.945] - copied ‘times’ to environment
[17:01:02.945] - copied ‘stopf’ to environment
[17:01:02.945] - copied ‘stop_if_not’ to environment
[17:01:02.945] - copied ‘dim’ to environment
[17:01:02.946] - copied ‘valid_types’ to environment
[17:01:02.946] - copied ‘future.call.arguments’ to environment
[17:01:02.946] - copied ‘...future.elements_ii’ to environment
[17:01:02.946] - copied ‘...future.seeds_ii’ to environment
[17:01:02.946] - copied ‘...future.globals.maxSize’ to environment
[17:01:02.946] assign_globals() ... done
[17:01:02.946] requestCore(): workers = 2
[17:01:02.949] MulticoreFuture started
[17:01:02.949] - Launch lazy future ... done
[17:01:02.950] run() for ‘MulticoreFuture’ ... done
[17:01:02.950] Created future:
[17:01:02.950] plan(): Setting new future strategy stack:
[17:01:02.951] List of future strategies:
[17:01:02.951] 1. sequential:
[17:01:02.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:02.951]    - tweaked: FALSE
[17:01:02.951]    - call: NULL
[17:01:02.952] plan(): nbrOfWorkers() = 1
[17:01:02.954] plan(): Setting new future strategy stack:
[17:01:02.954] List of future strategies:
[17:01:02.954] 1. multicore:
[17:01:02.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:02.954]    - tweaked: FALSE
[17:01:02.954]    - call: plan(strategy)
[17:01:02.960] plan(): nbrOfWorkers() = 2
[17:01:02.950] MulticoreFuture:
[17:01:02.950] Label: ‘future_vapply-2’
[17:01:02.950] Expression:
[17:01:02.950] {
[17:01:02.950]     do.call(function(...) {
[17:01:02.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:02.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:02.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:02.950]             on.exit(options(oopts), add = TRUE)
[17:01:02.950]         }
[17:01:02.950]         {
[17:01:02.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:02.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:02.950]                 ...future.FUN(...future.X_jj, ...)
[17:01:02.950]             })
[17:01:02.950]         }
[17:01:02.950]     }, args = future.call.arguments)
[17:01:02.950] }
[17:01:02.950] Lazy evaluation: FALSE
[17:01:02.950] Asynchronous evaluation: TRUE
[17:01:02.950] Local evaluation: TRUE
[17:01:02.950] Environment: R_GlobalEnv
[17:01:02.950] Capture standard output: TRUE
[17:01:02.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:02.950] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:02.950] Packages: 1 packages (‘future.apply’)
[17:01:02.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:02.950] Resolved: TRUE
[17:01:02.950] Value: <not collected>
[17:01:02.950] Conditions captured: <none>
[17:01:02.950] Early signaling: FALSE
[17:01:02.950] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:02.950] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:02.961] Chunk #2 of 2 ... DONE
[17:01:02.961] Launching 2 futures (chunks) ... DONE
[17:01:02.961] Resolving 2 futures (chunks) ...
[17:01:02.961] resolve() on list ...
[17:01:02.962]  recursive: 0
[17:01:02.962]  length: 2
[17:01:02.962] 
[17:01:02.962] Future #1
[17:01:02.962] result() for MulticoreFuture ...
[17:01:02.963] result() for MulticoreFuture ...
[17:01:02.963] result() for MulticoreFuture ... done
[17:01:02.964] result() for MulticoreFuture ... done
[17:01:02.964] result() for MulticoreFuture ...
[17:01:02.964] result() for MulticoreFuture ... done
[17:01:02.964] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:02.964] - nx: 2
[17:01:02.964] - relay: TRUE
[17:01:02.965] - stdout: TRUE
[17:01:02.965] - signal: TRUE
[17:01:02.965] - resignal: FALSE
[17:01:02.965] - force: TRUE
[17:01:02.965] - relayed: [n=2] FALSE, FALSE
[17:01:02.965] - queued futures: [n=2] FALSE, FALSE
[17:01:02.965]  - until=1
[17:01:02.966]  - relaying element #1
[17:01:02.966] result() for MulticoreFuture ...
[17:01:02.966] result() for MulticoreFuture ... done
[17:01:02.966] result() for MulticoreFuture ...
[17:01:02.966] result() for MulticoreFuture ... done
[17:01:02.966] result() for MulticoreFuture ...
[17:01:02.967] result() for MulticoreFuture ... done
[17:01:02.967] result() for MulticoreFuture ...
[17:01:02.967] result() for MulticoreFuture ... done
[17:01:02.967] - relayed: [n=2] TRUE, FALSE
[17:01:02.967] - queued futures: [n=2] TRUE, FALSE
[17:01:02.967] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:02.968]  length: 1 (resolved future 1)
[17:01:02.968] Future #2
[17:01:02.968] result() for MulticoreFuture ...
[17:01:02.969] result() for MulticoreFuture ...
[17:01:02.969] result() for MulticoreFuture ... done
[17:01:02.969] result() for MulticoreFuture ... done
[17:01:02.969] result() for MulticoreFuture ...
[17:01:02.969] result() for MulticoreFuture ... done
[17:01:02.969] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:02.970] - nx: 2
[17:01:02.970] - relay: TRUE
[17:01:02.970] - stdout: TRUE
[17:01:02.970] - signal: TRUE
[17:01:02.970] - resignal: FALSE
[17:01:02.970] - force: TRUE
[17:01:02.970] - relayed: [n=2] TRUE, FALSE
[17:01:02.970] - queued futures: [n=2] TRUE, FALSE
[17:01:02.971]  - until=2
[17:01:02.971]  - relaying element #2
[17:01:02.971] result() for MulticoreFuture ...
[17:01:02.971] result() for MulticoreFuture ... done
[17:01:02.971] result() for MulticoreFuture ...
[17:01:02.971] result() for MulticoreFuture ... done
[17:01:02.971] result() for MulticoreFuture ...
[17:01:02.971] result() for MulticoreFuture ... done
[17:01:02.972] result() for MulticoreFuture ...
[17:01:02.972] result() for MulticoreFuture ... done
[17:01:02.972] - relayed: [n=2] TRUE, TRUE
[17:01:02.972] - queued futures: [n=2] TRUE, TRUE
[17:01:02.972] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:02.972]  length: 0 (resolved future 2)
[17:01:02.972] Relaying remaining futures
[17:01:02.972] signalConditionsASAP(NULL, pos=0) ...
[17:01:02.972] - nx: 2
[17:01:02.973] - relay: TRUE
[17:01:02.973] - stdout: TRUE
[17:01:02.973] - signal: TRUE
[17:01:02.973] - resignal: FALSE
[17:01:02.973] - force: TRUE
[17:01:02.973] - relayed: [n=2] TRUE, TRUE
[17:01:02.973] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:02.973] - relayed: [n=2] TRUE, TRUE
[17:01:02.973] - queued futures: [n=2] TRUE, TRUE
[17:01:02.974] signalConditionsASAP(NULL, pos=0) ... done
[17:01:02.974] resolve() on list ... DONE
[17:01:02.974] result() for MulticoreFuture ...
[17:01:02.974] result() for MulticoreFuture ... done
[17:01:02.974] result() for MulticoreFuture ...
[17:01:02.974] result() for MulticoreFuture ... done
[17:01:02.974] result() for MulticoreFuture ...
[17:01:02.974] result() for MulticoreFuture ... done
[17:01:02.974] result() for MulticoreFuture ...
[17:01:02.975] result() for MulticoreFuture ... done
[17:01:02.975]  - Number of value chunks collected: 2
[17:01:02.975] Resolving 2 futures (chunks) ... DONE
[17:01:02.975] Reducing values from 2 chunks ...
[17:01:02.975]  - Number of values collected after concatenation: 10
[17:01:02.975]  - Number of values expected: 10
[17:01:02.975] Reducing values from 2 chunks ... DONE
[17:01:02.975] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:01:02.978] future_lapply() ...
[17:01:02.988] Number of chunks: 2
[17:01:02.988] getGlobalsAndPackagesXApply() ...
[17:01:02.988]  - future.globals: TRUE
[17:01:02.988] getGlobalsAndPackages() ...
[17:01:02.988] Searching for globals...
[17:01:02.993] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:01:02.993] Searching for globals ... DONE
[17:01:02.993] Resolving globals: FALSE
[17:01:02.994] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:01:02.994] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:02.995] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.995] - packages: [2] ‘stats’, ‘future.apply’
[17:01:02.995] getGlobalsAndPackages() ... DONE
[17:01:02.995]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:02.995]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:02.995] Finding globals ... DONE
[17:01:02.995]  - use_args: TRUE
[17:01:02.995]  - Getting '...' globals ...
[17:01:02.996] resolve() on list ...
[17:01:02.996]  recursive: 0
[17:01:02.996]  length: 1
[17:01:02.996]  elements: ‘...’
[17:01:02.996]  length: 0 (resolved future 1)
[17:01:02.996] resolve() on list ... DONE
[17:01:02.996]    - '...' content: [n=0] 
[17:01:02.996] List of 1
[17:01:02.996]  $ ...: list()
[17:01:02.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.996]  - attr(*, "where")=List of 1
[17:01:02.996]   ..$ ...:<environment: 0x55aadb690090> 
[17:01:02.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.996]  - attr(*, "resolved")= logi TRUE
[17:01:02.996]  - attr(*, "total_size")= num NA
[17:01:02.999]  - Getting '...' globals ... DONE
[17:01:02.999] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:02.999] List of 8
[17:01:02.999]  $ ...future.FUN:function (x, ...)  
[17:01:02.999]  $ x_FUN        :function (x, ...)  
[17:01:02.999]  $ times        : int 5
[17:01:02.999]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:02.999]  $ stop_if_not  :function (...)  
[17:01:02.999]  $ dim          : NULL
[17:01:02.999]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:02.999]  $ ...          : list()
[17:01:02.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:02.999]  - attr(*, "where")=List of 8
[17:01:02.999]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:02.999]   ..$ ...          :<environment: 0x55aadb690090> 
[17:01:02.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:02.999]  - attr(*, "resolved")= logi FALSE
[17:01:02.999]  - attr(*, "total_size")= num 95528
[17:01:03.005] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:03.005] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.005] Number of futures (= number of chunks): 2
[17:01:03.005] Launching 2 futures (chunks) ...
[17:01:03.005] Chunk #1 of 2 ...
[17:01:03.005]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.006] getGlobalsAndPackages() ...
[17:01:03.006] Searching for globals...
[17:01:03.006] 
[17:01:03.008] Searching for globals ... DONE
[17:01:03.008] - globals: [0] <none>
[17:01:03.008] getGlobalsAndPackages() ... DONE
[17:01:03.008]    + additional globals found: [n=0] 
[17:01:03.008]    + additional namespaces needed: [n=0] 
[17:01:03.009]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.009]  - seeds: <none>
[17:01:03.009]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.009] getGlobalsAndPackages() ...
[17:01:03.009] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.009] Resolving globals: FALSE
[17:01:03.009] Tweak future expression to call with '...' arguments ...
[17:01:03.010] {
[17:01:03.010]     do.call(function(...) {
[17:01:03.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.010]             on.exit(options(oopts), add = TRUE)
[17:01:03.010]         }
[17:01:03.010]         {
[17:01:03.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.010]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.010]             })
[17:01:03.010]         }
[17:01:03.010]     }, args = future.call.arguments)
[17:01:03.010] }
[17:01:03.010] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.011] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.011] - packages: [2] ‘stats’, ‘future.apply’
[17:01:03.011] getGlobalsAndPackages() ... DONE
[17:01:03.011] run() for ‘Future’ ...
[17:01:03.011] - state: ‘created’
[17:01:03.012] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.016] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.016] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.016]   - Field: ‘label’
[17:01:03.016]   - Field: ‘local’
[17:01:03.016]   - Field: ‘owner’
[17:01:03.016]   - Field: ‘envir’
[17:01:03.016]   - Field: ‘workers’
[17:01:03.017]   - Field: ‘packages’
[17:01:03.017]   - Field: ‘gc’
[17:01:03.017]   - Field: ‘job’
[17:01:03.017]   - Field: ‘conditions’
[17:01:03.017]   - Field: ‘expr’
[17:01:03.017]   - Field: ‘uuid’
[17:01:03.017]   - Field: ‘seed’
[17:01:03.017]   - Field: ‘version’
[17:01:03.017]   - Field: ‘result’
[17:01:03.017]   - Field: ‘asynchronous’
[17:01:03.018]   - Field: ‘calls’
[17:01:03.018]   - Field: ‘globals’
[17:01:03.018]   - Field: ‘stdout’
[17:01:03.018]   - Field: ‘earlySignal’
[17:01:03.018]   - Field: ‘lazy’
[17:01:03.018]   - Field: ‘state’
[17:01:03.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.018] - Launch lazy future ...
[17:01:03.019] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:03.019] Packages needed by future strategies (n = 0): <none>
[17:01:03.019] {
[17:01:03.019]     {
[17:01:03.019]         {
[17:01:03.019]             ...future.startTime <- base::Sys.time()
[17:01:03.019]             {
[17:01:03.019]                 {
[17:01:03.019]                   {
[17:01:03.019]                     {
[17:01:03.019]                       {
[17:01:03.019]                         base::local({
[17:01:03.019]                           has_future <- base::requireNamespace("future", 
[17:01:03.019]                             quietly = TRUE)
[17:01:03.019]                           if (has_future) {
[17:01:03.019]                             ns <- base::getNamespace("future")
[17:01:03.019]                             version <- ns[[".package"]][["version"]]
[17:01:03.019]                             if (is.null(version)) 
[17:01:03.019]                               version <- utils::packageVersion("future")
[17:01:03.019]                           }
[17:01:03.019]                           else {
[17:01:03.019]                             version <- NULL
[17:01:03.019]                           }
[17:01:03.019]                           if (!has_future || version < "1.8.0") {
[17:01:03.019]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.019]                               "", base::R.version$version.string), 
[17:01:03.019]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.019]                                 base::R.version$platform, 8 * 
[17:01:03.019]                                   base::.Machine$sizeof.pointer), 
[17:01:03.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.019]                                 "release", "version")], collapse = " "), 
[17:01:03.019]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.019]                               info)
[17:01:03.019]                             info <- base::paste(info, collapse = "; ")
[17:01:03.019]                             if (!has_future) {
[17:01:03.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.019]                                 info)
[17:01:03.019]                             }
[17:01:03.019]                             else {
[17:01:03.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.019]                                 info, version)
[17:01:03.019]                             }
[17:01:03.019]                             base::stop(msg)
[17:01:03.019]                           }
[17:01:03.019]                         })
[17:01:03.019]                       }
[17:01:03.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.019]                       base::options(mc.cores = 1L)
[17:01:03.019]                     }
[17:01:03.019]                     base::local({
[17:01:03.019]                       for (pkg in c("stats", "future.apply")) {
[17:01:03.019]                         base::loadNamespace(pkg)
[17:01:03.019]                         base::library(pkg, character.only = TRUE)
[17:01:03.019]                       }
[17:01:03.019]                     })
[17:01:03.019]                   }
[17:01:03.019]                   ...future.strategy.old <- future::plan("list")
[17:01:03.019]                   options(future.plan = NULL)
[17:01:03.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.019]                 }
[17:01:03.019]                 ...future.workdir <- getwd()
[17:01:03.019]             }
[17:01:03.019]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.019]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.019]         }
[17:01:03.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.019]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.019]             base::names(...future.oldOptions))
[17:01:03.019]     }
[17:01:03.019]     if (FALSE) {
[17:01:03.019]     }
[17:01:03.019]     else {
[17:01:03.019]         if (TRUE) {
[17:01:03.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.019]                 open = "w")
[17:01:03.019]         }
[17:01:03.019]         else {
[17:01:03.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.019]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.019]         }
[17:01:03.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.019]             base::sink(type = "output", split = FALSE)
[17:01:03.019]             base::close(...future.stdout)
[17:01:03.019]         }, add = TRUE)
[17:01:03.019]     }
[17:01:03.019]     ...future.frame <- base::sys.nframe()
[17:01:03.019]     ...future.conditions <- base::list()
[17:01:03.019]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.019]     if (FALSE) {
[17:01:03.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.019]     }
[17:01:03.019]     ...future.result <- base::tryCatch({
[17:01:03.019]         base::withCallingHandlers({
[17:01:03.019]             ...future.value <- base::withVisible(base::local({
[17:01:03.019]                 withCallingHandlers({
[17:01:03.019]                   {
[17:01:03.019]                     do.call(function(...) {
[17:01:03.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.019]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.019]                         ...future.globals.maxSize)) {
[17:01:03.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.019]                         on.exit(options(oopts), add = TRUE)
[17:01:03.019]                       }
[17:01:03.019]                       {
[17:01:03.019]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.019]                           FUN = function(jj) {
[17:01:03.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.019]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.019]                           })
[17:01:03.019]                       }
[17:01:03.019]                     }, args = future.call.arguments)
[17:01:03.019]                   }
[17:01:03.019]                 }, immediateCondition = function(cond) {
[17:01:03.019]                   save_rds <- function (object, pathname, ...) 
[17:01:03.019]                   {
[17:01:03.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.019]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.019]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.019]                         fi_tmp[["mtime"]])
[17:01:03.019]                     }
[17:01:03.019]                     tryCatch({
[17:01:03.019]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.019]                     }, error = function(ex) {
[17:01:03.019]                       msg <- conditionMessage(ex)
[17:01:03.019]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.019]                         fi_tmp[["mtime"]], msg)
[17:01:03.019]                       ex$message <- msg
[17:01:03.019]                       stop(ex)
[17:01:03.019]                     })
[17:01:03.019]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.019]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.019]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.019]                       fi <- file.info(pathname)
[17:01:03.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.019]                         fi[["size"]], fi[["mtime"]])
[17:01:03.019]                       stop(msg)
[17:01:03.019]                     }
[17:01:03.019]                     invisible(pathname)
[17:01:03.019]                   }
[17:01:03.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.019]                     rootPath = tempdir()) 
[17:01:03.019]                   {
[17:01:03.019]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.019]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.019]                       tmpdir = path, fileext = ".rds")
[17:01:03.019]                     save_rds(obj, file)
[17:01:03.019]                   }
[17:01:03.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.019]                   {
[17:01:03.019]                     inherits <- base::inherits
[17:01:03.019]                     invokeRestart <- base::invokeRestart
[17:01:03.019]                     is.null <- base::is.null
[17:01:03.019]                     muffled <- FALSE
[17:01:03.019]                     if (inherits(cond, "message")) {
[17:01:03.019]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.019]                       if (muffled) 
[17:01:03.019]                         invokeRestart("muffleMessage")
[17:01:03.019]                     }
[17:01:03.019]                     else if (inherits(cond, "warning")) {
[17:01:03.019]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.019]                       if (muffled) 
[17:01:03.019]                         invokeRestart("muffleWarning")
[17:01:03.019]                     }
[17:01:03.019]                     else if (inherits(cond, "condition")) {
[17:01:03.019]                       if (!is.null(pattern)) {
[17:01:03.019]                         computeRestarts <- base::computeRestarts
[17:01:03.019]                         grepl <- base::grepl
[17:01:03.019]                         restarts <- computeRestarts(cond)
[17:01:03.019]                         for (restart in restarts) {
[17:01:03.019]                           name <- restart$name
[17:01:03.019]                           if (is.null(name)) 
[17:01:03.019]                             next
[17:01:03.019]                           if (!grepl(pattern, name)) 
[17:01:03.019]                             next
[17:01:03.019]                           invokeRestart(restart)
[17:01:03.019]                           muffled <- TRUE
[17:01:03.019]                           break
[17:01:03.019]                         }
[17:01:03.019]                       }
[17:01:03.019]                     }
[17:01:03.019]                     invisible(muffled)
[17:01:03.019]                   }
[17:01:03.019]                   muffleCondition(cond)
[17:01:03.019]                 })
[17:01:03.019]             }))
[17:01:03.019]             future::FutureResult(value = ...future.value$value, 
[17:01:03.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.019]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.019]                     ...future.globalenv.names))
[17:01:03.019]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.019]         }, condition = base::local({
[17:01:03.019]             c <- base::c
[17:01:03.019]             inherits <- base::inherits
[17:01:03.019]             invokeRestart <- base::invokeRestart
[17:01:03.019]             length <- base::length
[17:01:03.019]             list <- base::list
[17:01:03.019]             seq.int <- base::seq.int
[17:01:03.019]             signalCondition <- base::signalCondition
[17:01:03.019]             sys.calls <- base::sys.calls
[17:01:03.019]             `[[` <- base::`[[`
[17:01:03.019]             `+` <- base::`+`
[17:01:03.019]             `<<-` <- base::`<<-`
[17:01:03.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.019]                   3L)]
[17:01:03.019]             }
[17:01:03.019]             function(cond) {
[17:01:03.019]                 is_error <- inherits(cond, "error")
[17:01:03.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.019]                   NULL)
[17:01:03.019]                 if (is_error) {
[17:01:03.019]                   sessionInformation <- function() {
[17:01:03.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.019]                       search = base::search(), system = base::Sys.info())
[17:01:03.019]                   }
[17:01:03.019]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.019]                     cond$call), session = sessionInformation(), 
[17:01:03.019]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.019]                   signalCondition(cond)
[17:01:03.019]                 }
[17:01:03.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.019]                 "immediateCondition"))) {
[17:01:03.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.019]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.019]                   if (TRUE && !signal) {
[17:01:03.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.019]                     {
[17:01:03.019]                       inherits <- base::inherits
[17:01:03.019]                       invokeRestart <- base::invokeRestart
[17:01:03.019]                       is.null <- base::is.null
[17:01:03.019]                       muffled <- FALSE
[17:01:03.019]                       if (inherits(cond, "message")) {
[17:01:03.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.019]                         if (muffled) 
[17:01:03.019]                           invokeRestart("muffleMessage")
[17:01:03.019]                       }
[17:01:03.019]                       else if (inherits(cond, "warning")) {
[17:01:03.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.019]                         if (muffled) 
[17:01:03.019]                           invokeRestart("muffleWarning")
[17:01:03.019]                       }
[17:01:03.019]                       else if (inherits(cond, "condition")) {
[17:01:03.019]                         if (!is.null(pattern)) {
[17:01:03.019]                           computeRestarts <- base::computeRestarts
[17:01:03.019]                           grepl <- base::grepl
[17:01:03.019]                           restarts <- computeRestarts(cond)
[17:01:03.019]                           for (restart in restarts) {
[17:01:03.019]                             name <- restart$name
[17:01:03.019]                             if (is.null(name)) 
[17:01:03.019]                               next
[17:01:03.019]                             if (!grepl(pattern, name)) 
[17:01:03.019]                               next
[17:01:03.019]                             invokeRestart(restart)
[17:01:03.019]                             muffled <- TRUE
[17:01:03.019]                             break
[17:01:03.019]                           }
[17:01:03.019]                         }
[17:01:03.019]                       }
[17:01:03.019]                       invisible(muffled)
[17:01:03.019]                     }
[17:01:03.019]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.019]                   }
[17:01:03.019]                 }
[17:01:03.019]                 else {
[17:01:03.019]                   if (TRUE) {
[17:01:03.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.019]                     {
[17:01:03.019]                       inherits <- base::inherits
[17:01:03.019]                       invokeRestart <- base::invokeRestart
[17:01:03.019]                       is.null <- base::is.null
[17:01:03.019]                       muffled <- FALSE
[17:01:03.019]                       if (inherits(cond, "message")) {
[17:01:03.019]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.019]                         if (muffled) 
[17:01:03.019]                           invokeRestart("muffleMessage")
[17:01:03.019]                       }
[17:01:03.019]                       else if (inherits(cond, "warning")) {
[17:01:03.019]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.019]                         if (muffled) 
[17:01:03.019]                           invokeRestart("muffleWarning")
[17:01:03.019]                       }
[17:01:03.019]                       else if (inherits(cond, "condition")) {
[17:01:03.019]                         if (!is.null(pattern)) {
[17:01:03.019]                           computeRestarts <- base::computeRestarts
[17:01:03.019]                           grepl <- base::grepl
[17:01:03.019]                           restarts <- computeRestarts(cond)
[17:01:03.019]                           for (restart in restarts) {
[17:01:03.019]                             name <- restart$name
[17:01:03.019]                             if (is.null(name)) 
[17:01:03.019]                               next
[17:01:03.019]                             if (!grepl(pattern, name)) 
[17:01:03.019]                               next
[17:01:03.019]                             invokeRestart(restart)
[17:01:03.019]                             muffled <- TRUE
[17:01:03.019]                             break
[17:01:03.019]                           }
[17:01:03.019]                         }
[17:01:03.019]                       }
[17:01:03.019]                       invisible(muffled)
[17:01:03.019]                     }
[17:01:03.019]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.019]                   }
[17:01:03.019]                 }
[17:01:03.019]             }
[17:01:03.019]         }))
[17:01:03.019]     }, error = function(ex) {
[17:01:03.019]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.019]                 ...future.rng), started = ...future.startTime, 
[17:01:03.019]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.019]             version = "1.8"), class = "FutureResult")
[17:01:03.019]     }, finally = {
[17:01:03.019]         if (!identical(...future.workdir, getwd())) 
[17:01:03.019]             setwd(...future.workdir)
[17:01:03.019]         {
[17:01:03.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.019]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.019]             }
[17:01:03.019]             base::options(...future.oldOptions)
[17:01:03.019]             if (.Platform$OS.type == "windows") {
[17:01:03.019]                 old_names <- names(...future.oldEnvVars)
[17:01:03.019]                 envs <- base::Sys.getenv()
[17:01:03.019]                 names <- names(envs)
[17:01:03.019]                 common <- intersect(names, old_names)
[17:01:03.019]                 added <- setdiff(names, old_names)
[17:01:03.019]                 removed <- setdiff(old_names, names)
[17:01:03.019]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.019]                   envs[common]]
[17:01:03.019]                 NAMES <- toupper(changed)
[17:01:03.019]                 args <- list()
[17:01:03.019]                 for (kk in seq_along(NAMES)) {
[17:01:03.019]                   name <- changed[[kk]]
[17:01:03.019]                   NAME <- NAMES[[kk]]
[17:01:03.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.019]                     next
[17:01:03.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.019]                 }
[17:01:03.019]                 NAMES <- toupper(added)
[17:01:03.019]                 for (kk in seq_along(NAMES)) {
[17:01:03.019]                   name <- added[[kk]]
[17:01:03.019]                   NAME <- NAMES[[kk]]
[17:01:03.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.019]                     next
[17:01:03.019]                   args[[name]] <- ""
[17:01:03.019]                 }
[17:01:03.019]                 NAMES <- toupper(removed)
[17:01:03.019]                 for (kk in seq_along(NAMES)) {
[17:01:03.019]                   name <- removed[[kk]]
[17:01:03.019]                   NAME <- NAMES[[kk]]
[17:01:03.019]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.019]                     next
[17:01:03.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.019]                 }
[17:01:03.019]                 if (length(args) > 0) 
[17:01:03.019]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.019]             }
[17:01:03.019]             else {
[17:01:03.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.019]             }
[17:01:03.019]             {
[17:01:03.019]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.019]                   0L) {
[17:01:03.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.019]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.019]                   base::options(opts)
[17:01:03.019]                 }
[17:01:03.019]                 {
[17:01:03.019]                   {
[17:01:03.019]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.019]                     NULL
[17:01:03.019]                   }
[17:01:03.019]                   options(future.plan = NULL)
[17:01:03.019]                   if (is.na(NA_character_)) 
[17:01:03.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.019]                     .init = FALSE)
[17:01:03.019]                 }
[17:01:03.019]             }
[17:01:03.019]         }
[17:01:03.019]     })
[17:01:03.019]     if (TRUE) {
[17:01:03.019]         base::sink(type = "output", split = FALSE)
[17:01:03.019]         if (TRUE) {
[17:01:03.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.019]         }
[17:01:03.019]         else {
[17:01:03.019]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.019]         }
[17:01:03.019]         base::close(...future.stdout)
[17:01:03.019]         ...future.stdout <- NULL
[17:01:03.019]     }
[17:01:03.019]     ...future.result$conditions <- ...future.conditions
[17:01:03.019]     ...future.result$finished <- base::Sys.time()
[17:01:03.019]     ...future.result
[17:01:03.019] }
[17:01:03.022] assign_globals() ...
[17:01:03.022] List of 11
[17:01:03.022]  $ ...future.FUN            :function (x, ...)  
[17:01:03.022]  $ x_FUN                    :function (x, ...)  
[17:01:03.022]  $ times                    : int 5
[17:01:03.022]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.022]  $ stop_if_not              :function (...)  
[17:01:03.022]  $ dim                      : NULL
[17:01:03.022]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.022]  $ future.call.arguments    : list()
[17:01:03.022]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.022]  $ ...future.elements_ii    :List of 1
[17:01:03.022]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:01:03.022]  $ ...future.seeds_ii       : NULL
[17:01:03.022]  $ ...future.globals.maxSize: NULL
[17:01:03.022]  - attr(*, "where")=List of 11
[17:01:03.022]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.022]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.022]  - attr(*, "resolved")= logi FALSE
[17:01:03.022]  - attr(*, "total_size")= num 95528
[17:01:03.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.022]  - attr(*, "already-done")= logi TRUE
[17:01:03.029] - copied ‘...future.FUN’ to environment
[17:01:03.030] - copied ‘x_FUN’ to environment
[17:01:03.030] - copied ‘times’ to environment
[17:01:03.030] - copied ‘stopf’ to environment
[17:01:03.030] - copied ‘stop_if_not’ to environment
[17:01:03.030] - copied ‘dim’ to environment
[17:01:03.030] - copied ‘valid_types’ to environment
[17:01:03.030] - copied ‘future.call.arguments’ to environment
[17:01:03.030] - copied ‘...future.elements_ii’ to environment
[17:01:03.030] - copied ‘...future.seeds_ii’ to environment
[17:01:03.030] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.031] assign_globals() ... done
[17:01:03.031] requestCore(): workers = 2
[17:01:03.033] MulticoreFuture started
[17:01:03.033] - Launch lazy future ... done
[17:01:03.034] run() for ‘MulticoreFuture’ ... done
[17:01:03.034] Created future:
[17:01:03.034] plan(): Setting new future strategy stack:
[17:01:03.035] List of future strategies:
[17:01:03.035] 1. sequential:
[17:01:03.035]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.035]    - tweaked: FALSE
[17:01:03.035]    - call: NULL
[17:01:03.036] plan(): nbrOfWorkers() = 1
[17:01:03.038] plan(): Setting new future strategy stack:
[17:01:03.039] List of future strategies:
[17:01:03.039] 1. multicore:
[17:01:03.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.039]    - tweaked: FALSE
[17:01:03.039]    - call: plan(strategy)
[17:01:03.034] MulticoreFuture:
[17:01:03.034] Label: ‘future_vapply-1’
[17:01:03.034] Expression:
[17:01:03.034] {
[17:01:03.034]     do.call(function(...) {
[17:01:03.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.034]             on.exit(options(oopts), add = TRUE)
[17:01:03.034]         }
[17:01:03.034]         {
[17:01:03.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.034]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.034]             })
[17:01:03.034]         }
[17:01:03.034]     }, args = future.call.arguments)
[17:01:03.034] }
[17:01:03.034] Lazy evaluation: FALSE
[17:01:03.034] Asynchronous evaluation: TRUE
[17:01:03.034] Local evaluation: TRUE
[17:01:03.034] Environment: R_GlobalEnv
[17:01:03.034] Capture standard output: TRUE
[17:01:03.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.034] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.034] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:03.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.034] Resolved: FALSE
[17:01:03.034] Value: <not collected>
[17:01:03.034] Conditions captured: <none>
[17:01:03.034] Early signaling: FALSE
[17:01:03.034] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.034] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.047] Chunk #1 of 2 ... DONE
[17:01:03.047] Chunk #2 of 2 ...
[17:01:03.048]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.048] getGlobalsAndPackages() ...
[17:01:03.048] Searching for globals...
[17:01:03.048] 
[17:01:03.048] Searching for globals ... DONE
[17:01:03.049] - globals: [0] <none>
[17:01:03.049] getGlobalsAndPackages() ... DONE
[17:01:03.049] plan(): nbrOfWorkers() = 2
[17:01:03.049]    + additional globals found: [n=0] 
[17:01:03.049]    + additional namespaces needed: [n=0] 
[17:01:03.049]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.052]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.052]  - seeds: <none>
[17:01:03.052]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.053] getGlobalsAndPackages() ...
[17:01:03.053] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.053] Resolving globals: FALSE
[17:01:03.054] Tweak future expression to call with '...' arguments ...
[17:01:03.054] {
[17:01:03.054]     do.call(function(...) {
[17:01:03.054]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.054]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.054]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.054]             on.exit(options(oopts), add = TRUE)
[17:01:03.054]         }
[17:01:03.054]         {
[17:01:03.054]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.054]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.054]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.054]             })
[17:01:03.054]         }
[17:01:03.054]     }, args = future.call.arguments)
[17:01:03.054] }
[17:01:03.055] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.056] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.057] - packages: [2] ‘stats’, ‘future.apply’
[17:01:03.057] getGlobalsAndPackages() ... DONE
[17:01:03.058] run() for ‘Future’ ...
[17:01:03.058] - state: ‘created’
[17:01:03.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.064] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.065]   - Field: ‘label’
[17:01:03.065]   - Field: ‘local’
[17:01:03.065]   - Field: ‘owner’
[17:01:03.066]   - Field: ‘envir’
[17:01:03.066]   - Field: ‘workers’
[17:01:03.066]   - Field: ‘packages’
[17:01:03.066]   - Field: ‘gc’
[17:01:03.066]   - Field: ‘job’
[17:01:03.067]   - Field: ‘conditions’
[17:01:03.067]   - Field: ‘expr’
[17:01:03.067]   - Field: ‘uuid’
[17:01:03.067]   - Field: ‘seed’
[17:01:03.067]   - Field: ‘version’
[17:01:03.067]   - Field: ‘result’
[17:01:03.068]   - Field: ‘asynchronous’
[17:01:03.068]   - Field: ‘calls’
[17:01:03.068]   - Field: ‘globals’
[17:01:03.068]   - Field: ‘stdout’
[17:01:03.068]   - Field: ‘earlySignal’
[17:01:03.068]   - Field: ‘lazy’
[17:01:03.068]   - Field: ‘state’
[17:01:03.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.069] - Launch lazy future ...
[17:01:03.069] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:03.069] Packages needed by future strategies (n = 0): <none>
[17:01:03.070] {
[17:01:03.070]     {
[17:01:03.070]         {
[17:01:03.070]             ...future.startTime <- base::Sys.time()
[17:01:03.070]             {
[17:01:03.070]                 {
[17:01:03.070]                   {
[17:01:03.070]                     {
[17:01:03.070]                       {
[17:01:03.070]                         base::local({
[17:01:03.070]                           has_future <- base::requireNamespace("future", 
[17:01:03.070]                             quietly = TRUE)
[17:01:03.070]                           if (has_future) {
[17:01:03.070]                             ns <- base::getNamespace("future")
[17:01:03.070]                             version <- ns[[".package"]][["version"]]
[17:01:03.070]                             if (is.null(version)) 
[17:01:03.070]                               version <- utils::packageVersion("future")
[17:01:03.070]                           }
[17:01:03.070]                           else {
[17:01:03.070]                             version <- NULL
[17:01:03.070]                           }
[17:01:03.070]                           if (!has_future || version < "1.8.0") {
[17:01:03.070]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.070]                               "", base::R.version$version.string), 
[17:01:03.070]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.070]                                 base::R.version$platform, 8 * 
[17:01:03.070]                                   base::.Machine$sizeof.pointer), 
[17:01:03.070]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.070]                                 "release", "version")], collapse = " "), 
[17:01:03.070]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.070]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.070]                               info)
[17:01:03.070]                             info <- base::paste(info, collapse = "; ")
[17:01:03.070]                             if (!has_future) {
[17:01:03.070]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.070]                                 info)
[17:01:03.070]                             }
[17:01:03.070]                             else {
[17:01:03.070]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.070]                                 info, version)
[17:01:03.070]                             }
[17:01:03.070]                             base::stop(msg)
[17:01:03.070]                           }
[17:01:03.070]                         })
[17:01:03.070]                       }
[17:01:03.070]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.070]                       base::options(mc.cores = 1L)
[17:01:03.070]                     }
[17:01:03.070]                     base::local({
[17:01:03.070]                       for (pkg in c("stats", "future.apply")) {
[17:01:03.070]                         base::loadNamespace(pkg)
[17:01:03.070]                         base::library(pkg, character.only = TRUE)
[17:01:03.070]                       }
[17:01:03.070]                     })
[17:01:03.070]                   }
[17:01:03.070]                   ...future.strategy.old <- future::plan("list")
[17:01:03.070]                   options(future.plan = NULL)
[17:01:03.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.070]                 }
[17:01:03.070]                 ...future.workdir <- getwd()
[17:01:03.070]             }
[17:01:03.070]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.070]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.070]         }
[17:01:03.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.070]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.070]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.070]             base::names(...future.oldOptions))
[17:01:03.070]     }
[17:01:03.070]     if (FALSE) {
[17:01:03.070]     }
[17:01:03.070]     else {
[17:01:03.070]         if (TRUE) {
[17:01:03.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.070]                 open = "w")
[17:01:03.070]         }
[17:01:03.070]         else {
[17:01:03.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.070]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.070]         }
[17:01:03.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.070]             base::sink(type = "output", split = FALSE)
[17:01:03.070]             base::close(...future.stdout)
[17:01:03.070]         }, add = TRUE)
[17:01:03.070]     }
[17:01:03.070]     ...future.frame <- base::sys.nframe()
[17:01:03.070]     ...future.conditions <- base::list()
[17:01:03.070]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.070]     if (FALSE) {
[17:01:03.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.070]     }
[17:01:03.070]     ...future.result <- base::tryCatch({
[17:01:03.070]         base::withCallingHandlers({
[17:01:03.070]             ...future.value <- base::withVisible(base::local({
[17:01:03.070]                 withCallingHandlers({
[17:01:03.070]                   {
[17:01:03.070]                     do.call(function(...) {
[17:01:03.070]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.070]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.070]                         ...future.globals.maxSize)) {
[17:01:03.070]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.070]                         on.exit(options(oopts), add = TRUE)
[17:01:03.070]                       }
[17:01:03.070]                       {
[17:01:03.070]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.070]                           FUN = function(jj) {
[17:01:03.070]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.070]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.070]                           })
[17:01:03.070]                       }
[17:01:03.070]                     }, args = future.call.arguments)
[17:01:03.070]                   }
[17:01:03.070]                 }, immediateCondition = function(cond) {
[17:01:03.070]                   save_rds <- function (object, pathname, ...) 
[17:01:03.070]                   {
[17:01:03.070]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.070]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.070]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.070]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.070]                         fi_tmp[["mtime"]])
[17:01:03.070]                     }
[17:01:03.070]                     tryCatch({
[17:01:03.070]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.070]                     }, error = function(ex) {
[17:01:03.070]                       msg <- conditionMessage(ex)
[17:01:03.070]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.070]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.070]                         fi_tmp[["mtime"]], msg)
[17:01:03.070]                       ex$message <- msg
[17:01:03.070]                       stop(ex)
[17:01:03.070]                     })
[17:01:03.070]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.070]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.070]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.070]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.070]                       fi <- file.info(pathname)
[17:01:03.070]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.070]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.070]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.070]                         fi[["size"]], fi[["mtime"]])
[17:01:03.070]                       stop(msg)
[17:01:03.070]                     }
[17:01:03.070]                     invisible(pathname)
[17:01:03.070]                   }
[17:01:03.070]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.070]                     rootPath = tempdir()) 
[17:01:03.070]                   {
[17:01:03.070]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.070]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.070]                       tmpdir = path, fileext = ".rds")
[17:01:03.070]                     save_rds(obj, file)
[17:01:03.070]                   }
[17:01:03.070]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.070]                   {
[17:01:03.070]                     inherits <- base::inherits
[17:01:03.070]                     invokeRestart <- base::invokeRestart
[17:01:03.070]                     is.null <- base::is.null
[17:01:03.070]                     muffled <- FALSE
[17:01:03.070]                     if (inherits(cond, "message")) {
[17:01:03.070]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.070]                       if (muffled) 
[17:01:03.070]                         invokeRestart("muffleMessage")
[17:01:03.070]                     }
[17:01:03.070]                     else if (inherits(cond, "warning")) {
[17:01:03.070]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.070]                       if (muffled) 
[17:01:03.070]                         invokeRestart("muffleWarning")
[17:01:03.070]                     }
[17:01:03.070]                     else if (inherits(cond, "condition")) {
[17:01:03.070]                       if (!is.null(pattern)) {
[17:01:03.070]                         computeRestarts <- base::computeRestarts
[17:01:03.070]                         grepl <- base::grepl
[17:01:03.070]                         restarts <- computeRestarts(cond)
[17:01:03.070]                         for (restart in restarts) {
[17:01:03.070]                           name <- restart$name
[17:01:03.070]                           if (is.null(name)) 
[17:01:03.070]                             next
[17:01:03.070]                           if (!grepl(pattern, name)) 
[17:01:03.070]                             next
[17:01:03.070]                           invokeRestart(restart)
[17:01:03.070]                           muffled <- TRUE
[17:01:03.070]                           break
[17:01:03.070]                         }
[17:01:03.070]                       }
[17:01:03.070]                     }
[17:01:03.070]                     invisible(muffled)
[17:01:03.070]                   }
[17:01:03.070]                   muffleCondition(cond)
[17:01:03.070]                 })
[17:01:03.070]             }))
[17:01:03.070]             future::FutureResult(value = ...future.value$value, 
[17:01:03.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.070]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.070]                     ...future.globalenv.names))
[17:01:03.070]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.070]         }, condition = base::local({
[17:01:03.070]             c <- base::c
[17:01:03.070]             inherits <- base::inherits
[17:01:03.070]             invokeRestart <- base::invokeRestart
[17:01:03.070]             length <- base::length
[17:01:03.070]             list <- base::list
[17:01:03.070]             seq.int <- base::seq.int
[17:01:03.070]             signalCondition <- base::signalCondition
[17:01:03.070]             sys.calls <- base::sys.calls
[17:01:03.070]             `[[` <- base::`[[`
[17:01:03.070]             `+` <- base::`+`
[17:01:03.070]             `<<-` <- base::`<<-`
[17:01:03.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.070]                   3L)]
[17:01:03.070]             }
[17:01:03.070]             function(cond) {
[17:01:03.070]                 is_error <- inherits(cond, "error")
[17:01:03.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.070]                   NULL)
[17:01:03.070]                 if (is_error) {
[17:01:03.070]                   sessionInformation <- function() {
[17:01:03.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.070]                       search = base::search(), system = base::Sys.info())
[17:01:03.070]                   }
[17:01:03.070]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.070]                     cond$call), session = sessionInformation(), 
[17:01:03.070]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.070]                   signalCondition(cond)
[17:01:03.070]                 }
[17:01:03.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.070]                 "immediateCondition"))) {
[17:01:03.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.070]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.070]                   if (TRUE && !signal) {
[17:01:03.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.070]                     {
[17:01:03.070]                       inherits <- base::inherits
[17:01:03.070]                       invokeRestart <- base::invokeRestart
[17:01:03.070]                       is.null <- base::is.null
[17:01:03.070]                       muffled <- FALSE
[17:01:03.070]                       if (inherits(cond, "message")) {
[17:01:03.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.070]                         if (muffled) 
[17:01:03.070]                           invokeRestart("muffleMessage")
[17:01:03.070]                       }
[17:01:03.070]                       else if (inherits(cond, "warning")) {
[17:01:03.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.070]                         if (muffled) 
[17:01:03.070]                           invokeRestart("muffleWarning")
[17:01:03.070]                       }
[17:01:03.070]                       else if (inherits(cond, "condition")) {
[17:01:03.070]                         if (!is.null(pattern)) {
[17:01:03.070]                           computeRestarts <- base::computeRestarts
[17:01:03.070]                           grepl <- base::grepl
[17:01:03.070]                           restarts <- computeRestarts(cond)
[17:01:03.070]                           for (restart in restarts) {
[17:01:03.070]                             name <- restart$name
[17:01:03.070]                             if (is.null(name)) 
[17:01:03.070]                               next
[17:01:03.070]                             if (!grepl(pattern, name)) 
[17:01:03.070]                               next
[17:01:03.070]                             invokeRestart(restart)
[17:01:03.070]                             muffled <- TRUE
[17:01:03.070]                             break
[17:01:03.070]                           }
[17:01:03.070]                         }
[17:01:03.070]                       }
[17:01:03.070]                       invisible(muffled)
[17:01:03.070]                     }
[17:01:03.070]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.070]                   }
[17:01:03.070]                 }
[17:01:03.070]                 else {
[17:01:03.070]                   if (TRUE) {
[17:01:03.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.070]                     {
[17:01:03.070]                       inherits <- base::inherits
[17:01:03.070]                       invokeRestart <- base::invokeRestart
[17:01:03.070]                       is.null <- base::is.null
[17:01:03.070]                       muffled <- FALSE
[17:01:03.070]                       if (inherits(cond, "message")) {
[17:01:03.070]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.070]                         if (muffled) 
[17:01:03.070]                           invokeRestart("muffleMessage")
[17:01:03.070]                       }
[17:01:03.070]                       else if (inherits(cond, "warning")) {
[17:01:03.070]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.070]                         if (muffled) 
[17:01:03.070]                           invokeRestart("muffleWarning")
[17:01:03.070]                       }
[17:01:03.070]                       else if (inherits(cond, "condition")) {
[17:01:03.070]                         if (!is.null(pattern)) {
[17:01:03.070]                           computeRestarts <- base::computeRestarts
[17:01:03.070]                           grepl <- base::grepl
[17:01:03.070]                           restarts <- computeRestarts(cond)
[17:01:03.070]                           for (restart in restarts) {
[17:01:03.070]                             name <- restart$name
[17:01:03.070]                             if (is.null(name)) 
[17:01:03.070]                               next
[17:01:03.070]                             if (!grepl(pattern, name)) 
[17:01:03.070]                               next
[17:01:03.070]                             invokeRestart(restart)
[17:01:03.070]                             muffled <- TRUE
[17:01:03.070]                             break
[17:01:03.070]                           }
[17:01:03.070]                         }
[17:01:03.070]                       }
[17:01:03.070]                       invisible(muffled)
[17:01:03.070]                     }
[17:01:03.070]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.070]                   }
[17:01:03.070]                 }
[17:01:03.070]             }
[17:01:03.070]         }))
[17:01:03.070]     }, error = function(ex) {
[17:01:03.070]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.070]                 ...future.rng), started = ...future.startTime, 
[17:01:03.070]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.070]             version = "1.8"), class = "FutureResult")
[17:01:03.070]     }, finally = {
[17:01:03.070]         if (!identical(...future.workdir, getwd())) 
[17:01:03.070]             setwd(...future.workdir)
[17:01:03.070]         {
[17:01:03.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.070]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.070]             }
[17:01:03.070]             base::options(...future.oldOptions)
[17:01:03.070]             if (.Platform$OS.type == "windows") {
[17:01:03.070]                 old_names <- names(...future.oldEnvVars)
[17:01:03.070]                 envs <- base::Sys.getenv()
[17:01:03.070]                 names <- names(envs)
[17:01:03.070]                 common <- intersect(names, old_names)
[17:01:03.070]                 added <- setdiff(names, old_names)
[17:01:03.070]                 removed <- setdiff(old_names, names)
[17:01:03.070]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.070]                   envs[common]]
[17:01:03.070]                 NAMES <- toupper(changed)
[17:01:03.070]                 args <- list()
[17:01:03.070]                 for (kk in seq_along(NAMES)) {
[17:01:03.070]                   name <- changed[[kk]]
[17:01:03.070]                   NAME <- NAMES[[kk]]
[17:01:03.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.070]                     next
[17:01:03.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.070]                 }
[17:01:03.070]                 NAMES <- toupper(added)
[17:01:03.070]                 for (kk in seq_along(NAMES)) {
[17:01:03.070]                   name <- added[[kk]]
[17:01:03.070]                   NAME <- NAMES[[kk]]
[17:01:03.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.070]                     next
[17:01:03.070]                   args[[name]] <- ""
[17:01:03.070]                 }
[17:01:03.070]                 NAMES <- toupper(removed)
[17:01:03.070]                 for (kk in seq_along(NAMES)) {
[17:01:03.070]                   name <- removed[[kk]]
[17:01:03.070]                   NAME <- NAMES[[kk]]
[17:01:03.070]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.070]                     next
[17:01:03.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.070]                 }
[17:01:03.070]                 if (length(args) > 0) 
[17:01:03.070]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.070]             }
[17:01:03.070]             else {
[17:01:03.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.070]             }
[17:01:03.070]             {
[17:01:03.070]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.070]                   0L) {
[17:01:03.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.070]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.070]                   base::options(opts)
[17:01:03.070]                 }
[17:01:03.070]                 {
[17:01:03.070]                   {
[17:01:03.070]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.070]                     NULL
[17:01:03.070]                   }
[17:01:03.070]                   options(future.plan = NULL)
[17:01:03.070]                   if (is.na(NA_character_)) 
[17:01:03.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.070]                     .init = FALSE)
[17:01:03.070]                 }
[17:01:03.070]             }
[17:01:03.070]         }
[17:01:03.070]     })
[17:01:03.070]     if (TRUE) {
[17:01:03.070]         base::sink(type = "output", split = FALSE)
[17:01:03.070]         if (TRUE) {
[17:01:03.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.070]         }
[17:01:03.070]         else {
[17:01:03.070]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.070]         }
[17:01:03.070]         base::close(...future.stdout)
[17:01:03.070]         ...future.stdout <- NULL
[17:01:03.070]     }
[17:01:03.070]     ...future.result$conditions <- ...future.conditions
[17:01:03.070]     ...future.result$finished <- base::Sys.time()
[17:01:03.070]     ...future.result
[17:01:03.070] }
[17:01:03.073] assign_globals() ...
[17:01:03.073] List of 11
[17:01:03.073]  $ ...future.FUN            :function (x, ...)  
[17:01:03.073]  $ x_FUN                    :function (x, ...)  
[17:01:03.073]  $ times                    : int 5
[17:01:03.073]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.073]  $ stop_if_not              :function (...)  
[17:01:03.073]  $ dim                      : NULL
[17:01:03.073]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.073]  $ future.call.arguments    : list()
[17:01:03.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.073]  $ ...future.elements_ii    :List of 2
[17:01:03.073]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:01:03.073]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:01:03.073]  $ ...future.seeds_ii       : NULL
[17:01:03.073]  $ ...future.globals.maxSize: NULL
[17:01:03.073]  - attr(*, "where")=List of 11
[17:01:03.073]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.073]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.073]  - attr(*, "resolved")= logi FALSE
[17:01:03.073]  - attr(*, "total_size")= num 95528
[17:01:03.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.073]  - attr(*, "already-done")= logi TRUE
[17:01:03.083] - copied ‘...future.FUN’ to environment
[17:01:03.083] - copied ‘x_FUN’ to environment
[17:01:03.083] - copied ‘times’ to environment
[17:01:03.083] - copied ‘stopf’ to environment
[17:01:03.083] - copied ‘stop_if_not’ to environment
[17:01:03.083] - copied ‘dim’ to environment
[17:01:03.083] - copied ‘valid_types’ to environment
[17:01:03.084] - copied ‘future.call.arguments’ to environment
[17:01:03.084] - copied ‘...future.elements_ii’ to environment
[17:01:03.084] - copied ‘...future.seeds_ii’ to environment
[17:01:03.084] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.084] assign_globals() ... done
[17:01:03.084] requestCore(): workers = 2
[17:01:03.086] MulticoreFuture started
[17:01:03.087] - Launch lazy future ... done
[17:01:03.087] run() for ‘MulticoreFuture’ ... done
[17:01:03.087] Created future:
[17:01:03.088] plan(): Setting new future strategy stack:
[17:01:03.088] List of future strategies:
[17:01:03.088] 1. sequential:
[17:01:03.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.088]    - tweaked: FALSE
[17:01:03.088]    - call: NULL
[17:01:03.089] plan(): nbrOfWorkers() = 1
[17:01:03.092] plan(): Setting new future strategy stack:
[17:01:03.092] List of future strategies:
[17:01:03.092] 1. multicore:
[17:01:03.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.092]    - tweaked: FALSE
[17:01:03.092]    - call: plan(strategy)
[17:01:03.088] MulticoreFuture:
[17:01:03.088] Label: ‘future_vapply-2’
[17:01:03.088] Expression:
[17:01:03.088] {
[17:01:03.088]     do.call(function(...) {
[17:01:03.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.088]             on.exit(options(oopts), add = TRUE)
[17:01:03.088]         }
[17:01:03.088]         {
[17:01:03.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.088]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.088]             })
[17:01:03.088]         }
[17:01:03.088]     }, args = future.call.arguments)
[17:01:03.088] }
[17:01:03.088] Lazy evaluation: FALSE
[17:01:03.088] Asynchronous evaluation: TRUE
[17:01:03.088] Local evaluation: TRUE
[17:01:03.088] Environment: R_GlobalEnv
[17:01:03.088] Capture standard output: TRUE
[17:01:03.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.088] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.088] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:03.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.088] Resolved: FALSE
[17:01:03.088] Value: <not collected>
[17:01:03.088] Conditions captured: <none>
[17:01:03.088] Early signaling: FALSE
[17:01:03.088] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.088] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.101] Chunk #2 of 2 ... DONE
[17:01:03.101] Launching 2 futures (chunks) ... DONE
[17:01:03.101] Resolving 2 futures (chunks) ...
[17:01:03.101] resolve() on list ...
[17:01:03.101]  recursive: 0
[17:01:03.101]  length: 2
[17:01:03.102] 
[17:01:03.102] Future #1
[17:01:03.102] result() for MulticoreFuture ...
[17:01:03.103] plan(): nbrOfWorkers() = 2
[17:01:03.103] result() for MulticoreFuture ...
[17:01:03.103] result() for MulticoreFuture ... done
[17:01:03.103] result() for MulticoreFuture ... done
[17:01:03.106] result() for MulticoreFuture ...
[17:01:03.106] result() for MulticoreFuture ... done
[17:01:03.107] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.107] - nx: 2
[17:01:03.107] - relay: TRUE
[17:01:03.107] - stdout: TRUE
[17:01:03.108] - signal: TRUE
[17:01:03.108] - resignal: FALSE
[17:01:03.108] - force: TRUE
[17:01:03.108] - relayed: [n=2] FALSE, FALSE
[17:01:03.109] - queued futures: [n=2] FALSE, FALSE
[17:01:03.109]  - until=1
[17:01:03.109]  - relaying element #1
[17:01:03.110] result() for MulticoreFuture ...
[17:01:03.110] result() for MulticoreFuture ... done
[17:01:03.110] result() for MulticoreFuture ...
[17:01:03.110] result() for MulticoreFuture ... done
[17:01:03.111] result() for MulticoreFuture ...
[17:01:03.111] result() for MulticoreFuture ... done
[17:01:03.111] result() for MulticoreFuture ...
[17:01:03.112] result() for MulticoreFuture ... done
[17:01:03.112] - relayed: [n=2] TRUE, FALSE
[17:01:03.112] - queued futures: [n=2] TRUE, FALSE
[17:01:03.112] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.113]  length: 1 (resolved future 1)
[17:01:03.113] Future #2
[17:01:03.113] result() for MulticoreFuture ...
[17:01:03.114] result() for MulticoreFuture ...
[17:01:03.115] result() for MulticoreFuture ... done
[17:01:03.115] result() for MulticoreFuture ... done
[17:01:03.115] result() for MulticoreFuture ...
[17:01:03.116] result() for MulticoreFuture ... done
[17:01:03.116] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.116] - nx: 2
[17:01:03.116] - relay: TRUE
[17:01:03.117] - stdout: TRUE
[17:01:03.117] - signal: TRUE
[17:01:03.117] - resignal: FALSE
[17:01:03.117] - force: TRUE
[17:01:03.117] - relayed: [n=2] TRUE, FALSE
[17:01:03.117] - queued futures: [n=2] TRUE, FALSE
[17:01:03.118]  - until=2
[17:01:03.118]  - relaying element #2
[17:01:03.118] result() for MulticoreFuture ...
[17:01:03.118] result() for MulticoreFuture ... done
[17:01:03.118] result() for MulticoreFuture ...
[17:01:03.119] result() for MulticoreFuture ... done
[17:01:03.119] result() for MulticoreFuture ...
[17:01:03.119] result() for MulticoreFuture ... done
[17:01:03.119] result() for MulticoreFuture ...
[17:01:03.119] result() for MulticoreFuture ... done
[17:01:03.119] - relayed: [n=2] TRUE, TRUE
[17:01:03.119] - queued futures: [n=2] TRUE, TRUE
[17:01:03.120] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.120]  length: 0 (resolved future 2)
[17:01:03.120] Relaying remaining futures
[17:01:03.120] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.120] - nx: 2
[17:01:03.120] - relay: TRUE
[17:01:03.120] - stdout: TRUE
[17:01:03.120] - signal: TRUE
[17:01:03.120] - resignal: FALSE
[17:01:03.121] - force: TRUE
[17:01:03.121] - relayed: [n=2] TRUE, TRUE
[17:01:03.121] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.121] - relayed: [n=2] TRUE, TRUE
[17:01:03.121] - queued futures: [n=2] TRUE, TRUE
[17:01:03.121] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.121] resolve() on list ... DONE
[17:01:03.121] result() for MulticoreFuture ...
[17:01:03.121] result() for MulticoreFuture ... done
[17:01:03.122] result() for MulticoreFuture ...
[17:01:03.122] result() for MulticoreFuture ... done
[17:01:03.122] result() for MulticoreFuture ...
[17:01:03.122] result() for MulticoreFuture ... done
[17:01:03.122] result() for MulticoreFuture ...
[17:01:03.122] result() for MulticoreFuture ... done
[17:01:03.122]  - Number of value chunks collected: 2
[17:01:03.122] Resolving 2 futures (chunks) ... DONE
[17:01:03.122] Reducing values from 2 chunks ...
[17:01:03.123]  - Number of values collected after concatenation: 3
[17:01:03.123]  - Number of values expected: 3
[17:01:03.123] Reducing values from 2 chunks ... DONE
[17:01:03.123] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:01:03.125] future_lapply() ...
[17:01:03.133] Number of chunks: 2
[17:01:03.133] getGlobalsAndPackagesXApply() ...
[17:01:03.133]  - future.globals: TRUE
[17:01:03.133] getGlobalsAndPackages() ...
[17:01:03.134] Searching for globals...
[17:01:03.141] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:03.141] Searching for globals ... DONE
[17:01:03.142] Resolving globals: FALSE
[17:01:03.143] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:01:03.143] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:01:03.143] - globals: [1] ‘FUN’
[17:01:03.143] - packages: [1] ‘stats’
[17:01:03.144] getGlobalsAndPackages() ... DONE
[17:01:03.144]  - globals found/used: [n=1] ‘FUN’
[17:01:03.144]  - needed namespaces: [n=1] ‘stats’
[17:01:03.144] Finding globals ... DONE
[17:01:03.144]  - use_args: TRUE
[17:01:03.144]  - Getting '...' globals ...
[17:01:03.145] resolve() on list ...
[17:01:03.145]  recursive: 0
[17:01:03.145]  length: 1
[17:01:03.145]  elements: ‘...’
[17:01:03.145]  length: 0 (resolved future 1)
[17:01:03.145] resolve() on list ... DONE
[17:01:03.145]    - '...' content: [n=0] 
[17:01:03.145] List of 1
[17:01:03.145]  $ ...: list()
[17:01:03.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.145]  - attr(*, "where")=List of 1
[17:01:03.145]   ..$ ...:<environment: 0x55aada65c978> 
[17:01:03.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.145]  - attr(*, "resolved")= logi TRUE
[17:01:03.145]  - attr(*, "total_size")= num NA
[17:01:03.148]  - Getting '...' globals ... DONE
[17:01:03.148] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:03.148] List of 2
[17:01:03.148]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:01:03.148]  $ ...          : list()
[17:01:03.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.148]  - attr(*, "where")=List of 2
[17:01:03.148]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.148]   ..$ ...          :<environment: 0x55aada65c978> 
[17:01:03.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.148]  - attr(*, "resolved")= logi FALSE
[17:01:03.148]  - attr(*, "total_size")= num 46960
[17:01:03.151] Packages to be attached in all futures: [n=1] ‘stats’
[17:01:03.151] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.151] Number of futures (= number of chunks): 2
[17:01:03.151] Launching 2 futures (chunks) ...
[17:01:03.151] Chunk #1 of 2 ...
[17:01:03.152]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.152] getGlobalsAndPackages() ...
[17:01:03.152] Searching for globals...
[17:01:03.152] 
[17:01:03.152] Searching for globals ... DONE
[17:01:03.152] - globals: [0] <none>
[17:01:03.152] getGlobalsAndPackages() ... DONE
[17:01:03.152]    + additional globals found: [n=0] 
[17:01:03.153]    + additional namespaces needed: [n=0] 
[17:01:03.153]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.153]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.153]  - seeds: <none>
[17:01:03.153]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.153] getGlobalsAndPackages() ...
[17:01:03.153] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.153] Resolving globals: FALSE
[17:01:03.153] Tweak future expression to call with '...' arguments ...
[17:01:03.154] {
[17:01:03.154]     do.call(function(...) {
[17:01:03.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.154]             on.exit(options(oopts), add = TRUE)
[17:01:03.154]         }
[17:01:03.154]         {
[17:01:03.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.154]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.154]             })
[17:01:03.154]         }
[17:01:03.154]     }, args = future.call.arguments)
[17:01:03.154] }
[17:01:03.154] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.154] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.154] - packages: [1] ‘stats’
[17:01:03.154] getGlobalsAndPackages() ... DONE
[17:01:03.155] run() for ‘Future’ ...
[17:01:03.155] - state: ‘created’
[17:01:03.155] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.159] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.159] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.159]   - Field: ‘label’
[17:01:03.159]   - Field: ‘local’
[17:01:03.159]   - Field: ‘owner’
[17:01:03.159]   - Field: ‘envir’
[17:01:03.160]   - Field: ‘workers’
[17:01:03.160]   - Field: ‘packages’
[17:01:03.160]   - Field: ‘gc’
[17:01:03.160]   - Field: ‘job’
[17:01:03.160]   - Field: ‘conditions’
[17:01:03.160]   - Field: ‘expr’
[17:01:03.160]   - Field: ‘uuid’
[17:01:03.160]   - Field: ‘seed’
[17:01:03.160]   - Field: ‘version’
[17:01:03.160]   - Field: ‘result’
[17:01:03.160]   - Field: ‘asynchronous’
[17:01:03.161]   - Field: ‘calls’
[17:01:03.161]   - Field: ‘globals’
[17:01:03.161]   - Field: ‘stdout’
[17:01:03.161]   - Field: ‘earlySignal’
[17:01:03.161]   - Field: ‘lazy’
[17:01:03.161]   - Field: ‘state’
[17:01:03.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.161] - Launch lazy future ...
[17:01:03.162] Packages needed by the future expression (n = 1): ‘stats’
[17:01:03.162] Packages needed by future strategies (n = 0): <none>
[17:01:03.162] {
[17:01:03.162]     {
[17:01:03.162]         {
[17:01:03.162]             ...future.startTime <- base::Sys.time()
[17:01:03.162]             {
[17:01:03.162]                 {
[17:01:03.162]                   {
[17:01:03.162]                     {
[17:01:03.162]                       {
[17:01:03.162]                         base::local({
[17:01:03.162]                           has_future <- base::requireNamespace("future", 
[17:01:03.162]                             quietly = TRUE)
[17:01:03.162]                           if (has_future) {
[17:01:03.162]                             ns <- base::getNamespace("future")
[17:01:03.162]                             version <- ns[[".package"]][["version"]]
[17:01:03.162]                             if (is.null(version)) 
[17:01:03.162]                               version <- utils::packageVersion("future")
[17:01:03.162]                           }
[17:01:03.162]                           else {
[17:01:03.162]                             version <- NULL
[17:01:03.162]                           }
[17:01:03.162]                           if (!has_future || version < "1.8.0") {
[17:01:03.162]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.162]                               "", base::R.version$version.string), 
[17:01:03.162]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.162]                                 base::R.version$platform, 8 * 
[17:01:03.162]                                   base::.Machine$sizeof.pointer), 
[17:01:03.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.162]                                 "release", "version")], collapse = " "), 
[17:01:03.162]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.162]                               info)
[17:01:03.162]                             info <- base::paste(info, collapse = "; ")
[17:01:03.162]                             if (!has_future) {
[17:01:03.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.162]                                 info)
[17:01:03.162]                             }
[17:01:03.162]                             else {
[17:01:03.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.162]                                 info, version)
[17:01:03.162]                             }
[17:01:03.162]                             base::stop(msg)
[17:01:03.162]                           }
[17:01:03.162]                         })
[17:01:03.162]                       }
[17:01:03.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.162]                       base::options(mc.cores = 1L)
[17:01:03.162]                     }
[17:01:03.162]                     base::local({
[17:01:03.162]                       for (pkg in "stats") {
[17:01:03.162]                         base::loadNamespace(pkg)
[17:01:03.162]                         base::library(pkg, character.only = TRUE)
[17:01:03.162]                       }
[17:01:03.162]                     })
[17:01:03.162]                   }
[17:01:03.162]                   ...future.strategy.old <- future::plan("list")
[17:01:03.162]                   options(future.plan = NULL)
[17:01:03.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.162]                 }
[17:01:03.162]                 ...future.workdir <- getwd()
[17:01:03.162]             }
[17:01:03.162]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.162]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.162]         }
[17:01:03.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.162]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.162]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.162]             base::names(...future.oldOptions))
[17:01:03.162]     }
[17:01:03.162]     if (FALSE) {
[17:01:03.162]     }
[17:01:03.162]     else {
[17:01:03.162]         if (TRUE) {
[17:01:03.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.162]                 open = "w")
[17:01:03.162]         }
[17:01:03.162]         else {
[17:01:03.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.162]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.162]         }
[17:01:03.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.162]             base::sink(type = "output", split = FALSE)
[17:01:03.162]             base::close(...future.stdout)
[17:01:03.162]         }, add = TRUE)
[17:01:03.162]     }
[17:01:03.162]     ...future.frame <- base::sys.nframe()
[17:01:03.162]     ...future.conditions <- base::list()
[17:01:03.162]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.162]     if (FALSE) {
[17:01:03.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.162]     }
[17:01:03.162]     ...future.result <- base::tryCatch({
[17:01:03.162]         base::withCallingHandlers({
[17:01:03.162]             ...future.value <- base::withVisible(base::local({
[17:01:03.162]                 withCallingHandlers({
[17:01:03.162]                   {
[17:01:03.162]                     do.call(function(...) {
[17:01:03.162]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.162]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.162]                         ...future.globals.maxSize)) {
[17:01:03.162]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.162]                         on.exit(options(oopts), add = TRUE)
[17:01:03.162]                       }
[17:01:03.162]                       {
[17:01:03.162]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.162]                           FUN = function(jj) {
[17:01:03.162]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.162]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.162]                           })
[17:01:03.162]                       }
[17:01:03.162]                     }, args = future.call.arguments)
[17:01:03.162]                   }
[17:01:03.162]                 }, immediateCondition = function(cond) {
[17:01:03.162]                   save_rds <- function (object, pathname, ...) 
[17:01:03.162]                   {
[17:01:03.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.162]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.162]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.162]                         fi_tmp[["mtime"]])
[17:01:03.162]                     }
[17:01:03.162]                     tryCatch({
[17:01:03.162]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.162]                     }, error = function(ex) {
[17:01:03.162]                       msg <- conditionMessage(ex)
[17:01:03.162]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.162]                         fi_tmp[["mtime"]], msg)
[17:01:03.162]                       ex$message <- msg
[17:01:03.162]                       stop(ex)
[17:01:03.162]                     })
[17:01:03.162]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.162]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.162]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.162]                       fi <- file.info(pathname)
[17:01:03.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.162]                         fi[["size"]], fi[["mtime"]])
[17:01:03.162]                       stop(msg)
[17:01:03.162]                     }
[17:01:03.162]                     invisible(pathname)
[17:01:03.162]                   }
[17:01:03.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.162]                     rootPath = tempdir()) 
[17:01:03.162]                   {
[17:01:03.162]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.162]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.162]                       tmpdir = path, fileext = ".rds")
[17:01:03.162]                     save_rds(obj, file)
[17:01:03.162]                   }
[17:01:03.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.162]                   {
[17:01:03.162]                     inherits <- base::inherits
[17:01:03.162]                     invokeRestart <- base::invokeRestart
[17:01:03.162]                     is.null <- base::is.null
[17:01:03.162]                     muffled <- FALSE
[17:01:03.162]                     if (inherits(cond, "message")) {
[17:01:03.162]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.162]                       if (muffled) 
[17:01:03.162]                         invokeRestart("muffleMessage")
[17:01:03.162]                     }
[17:01:03.162]                     else if (inherits(cond, "warning")) {
[17:01:03.162]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.162]                       if (muffled) 
[17:01:03.162]                         invokeRestart("muffleWarning")
[17:01:03.162]                     }
[17:01:03.162]                     else if (inherits(cond, "condition")) {
[17:01:03.162]                       if (!is.null(pattern)) {
[17:01:03.162]                         computeRestarts <- base::computeRestarts
[17:01:03.162]                         grepl <- base::grepl
[17:01:03.162]                         restarts <- computeRestarts(cond)
[17:01:03.162]                         for (restart in restarts) {
[17:01:03.162]                           name <- restart$name
[17:01:03.162]                           if (is.null(name)) 
[17:01:03.162]                             next
[17:01:03.162]                           if (!grepl(pattern, name)) 
[17:01:03.162]                             next
[17:01:03.162]                           invokeRestart(restart)
[17:01:03.162]                           muffled <- TRUE
[17:01:03.162]                           break
[17:01:03.162]                         }
[17:01:03.162]                       }
[17:01:03.162]                     }
[17:01:03.162]                     invisible(muffled)
[17:01:03.162]                   }
[17:01:03.162]                   muffleCondition(cond)
[17:01:03.162]                 })
[17:01:03.162]             }))
[17:01:03.162]             future::FutureResult(value = ...future.value$value, 
[17:01:03.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.162]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.162]                     ...future.globalenv.names))
[17:01:03.162]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.162]         }, condition = base::local({
[17:01:03.162]             c <- base::c
[17:01:03.162]             inherits <- base::inherits
[17:01:03.162]             invokeRestart <- base::invokeRestart
[17:01:03.162]             length <- base::length
[17:01:03.162]             list <- base::list
[17:01:03.162]             seq.int <- base::seq.int
[17:01:03.162]             signalCondition <- base::signalCondition
[17:01:03.162]             sys.calls <- base::sys.calls
[17:01:03.162]             `[[` <- base::`[[`
[17:01:03.162]             `+` <- base::`+`
[17:01:03.162]             `<<-` <- base::`<<-`
[17:01:03.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.162]                   3L)]
[17:01:03.162]             }
[17:01:03.162]             function(cond) {
[17:01:03.162]                 is_error <- inherits(cond, "error")
[17:01:03.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.162]                   NULL)
[17:01:03.162]                 if (is_error) {
[17:01:03.162]                   sessionInformation <- function() {
[17:01:03.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.162]                       search = base::search(), system = base::Sys.info())
[17:01:03.162]                   }
[17:01:03.162]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.162]                     cond$call), session = sessionInformation(), 
[17:01:03.162]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.162]                   signalCondition(cond)
[17:01:03.162]                 }
[17:01:03.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.162]                 "immediateCondition"))) {
[17:01:03.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.162]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.162]                   if (TRUE && !signal) {
[17:01:03.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.162]                     {
[17:01:03.162]                       inherits <- base::inherits
[17:01:03.162]                       invokeRestart <- base::invokeRestart
[17:01:03.162]                       is.null <- base::is.null
[17:01:03.162]                       muffled <- FALSE
[17:01:03.162]                       if (inherits(cond, "message")) {
[17:01:03.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.162]                         if (muffled) 
[17:01:03.162]                           invokeRestart("muffleMessage")
[17:01:03.162]                       }
[17:01:03.162]                       else if (inherits(cond, "warning")) {
[17:01:03.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.162]                         if (muffled) 
[17:01:03.162]                           invokeRestart("muffleWarning")
[17:01:03.162]                       }
[17:01:03.162]                       else if (inherits(cond, "condition")) {
[17:01:03.162]                         if (!is.null(pattern)) {
[17:01:03.162]                           computeRestarts <- base::computeRestarts
[17:01:03.162]                           grepl <- base::grepl
[17:01:03.162]                           restarts <- computeRestarts(cond)
[17:01:03.162]                           for (restart in restarts) {
[17:01:03.162]                             name <- restart$name
[17:01:03.162]                             if (is.null(name)) 
[17:01:03.162]                               next
[17:01:03.162]                             if (!grepl(pattern, name)) 
[17:01:03.162]                               next
[17:01:03.162]                             invokeRestart(restart)
[17:01:03.162]                             muffled <- TRUE
[17:01:03.162]                             break
[17:01:03.162]                           }
[17:01:03.162]                         }
[17:01:03.162]                       }
[17:01:03.162]                       invisible(muffled)
[17:01:03.162]                     }
[17:01:03.162]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.162]                   }
[17:01:03.162]                 }
[17:01:03.162]                 else {
[17:01:03.162]                   if (TRUE) {
[17:01:03.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.162]                     {
[17:01:03.162]                       inherits <- base::inherits
[17:01:03.162]                       invokeRestart <- base::invokeRestart
[17:01:03.162]                       is.null <- base::is.null
[17:01:03.162]                       muffled <- FALSE
[17:01:03.162]                       if (inherits(cond, "message")) {
[17:01:03.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.162]                         if (muffled) 
[17:01:03.162]                           invokeRestart("muffleMessage")
[17:01:03.162]                       }
[17:01:03.162]                       else if (inherits(cond, "warning")) {
[17:01:03.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.162]                         if (muffled) 
[17:01:03.162]                           invokeRestart("muffleWarning")
[17:01:03.162]                       }
[17:01:03.162]                       else if (inherits(cond, "condition")) {
[17:01:03.162]                         if (!is.null(pattern)) {
[17:01:03.162]                           computeRestarts <- base::computeRestarts
[17:01:03.162]                           grepl <- base::grepl
[17:01:03.162]                           restarts <- computeRestarts(cond)
[17:01:03.162]                           for (restart in restarts) {
[17:01:03.162]                             name <- restart$name
[17:01:03.162]                             if (is.null(name)) 
[17:01:03.162]                               next
[17:01:03.162]                             if (!grepl(pattern, name)) 
[17:01:03.162]                               next
[17:01:03.162]                             invokeRestart(restart)
[17:01:03.162]                             muffled <- TRUE
[17:01:03.162]                             break
[17:01:03.162]                           }
[17:01:03.162]                         }
[17:01:03.162]                       }
[17:01:03.162]                       invisible(muffled)
[17:01:03.162]                     }
[17:01:03.162]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.162]                   }
[17:01:03.162]                 }
[17:01:03.162]             }
[17:01:03.162]         }))
[17:01:03.162]     }, error = function(ex) {
[17:01:03.162]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.162]                 ...future.rng), started = ...future.startTime, 
[17:01:03.162]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.162]             version = "1.8"), class = "FutureResult")
[17:01:03.162]     }, finally = {
[17:01:03.162]         if (!identical(...future.workdir, getwd())) 
[17:01:03.162]             setwd(...future.workdir)
[17:01:03.162]         {
[17:01:03.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.162]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.162]             }
[17:01:03.162]             base::options(...future.oldOptions)
[17:01:03.162]             if (.Platform$OS.type == "windows") {
[17:01:03.162]                 old_names <- names(...future.oldEnvVars)
[17:01:03.162]                 envs <- base::Sys.getenv()
[17:01:03.162]                 names <- names(envs)
[17:01:03.162]                 common <- intersect(names, old_names)
[17:01:03.162]                 added <- setdiff(names, old_names)
[17:01:03.162]                 removed <- setdiff(old_names, names)
[17:01:03.162]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.162]                   envs[common]]
[17:01:03.162]                 NAMES <- toupper(changed)
[17:01:03.162]                 args <- list()
[17:01:03.162]                 for (kk in seq_along(NAMES)) {
[17:01:03.162]                   name <- changed[[kk]]
[17:01:03.162]                   NAME <- NAMES[[kk]]
[17:01:03.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.162]                     next
[17:01:03.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.162]                 }
[17:01:03.162]                 NAMES <- toupper(added)
[17:01:03.162]                 for (kk in seq_along(NAMES)) {
[17:01:03.162]                   name <- added[[kk]]
[17:01:03.162]                   NAME <- NAMES[[kk]]
[17:01:03.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.162]                     next
[17:01:03.162]                   args[[name]] <- ""
[17:01:03.162]                 }
[17:01:03.162]                 NAMES <- toupper(removed)
[17:01:03.162]                 for (kk in seq_along(NAMES)) {
[17:01:03.162]                   name <- removed[[kk]]
[17:01:03.162]                   NAME <- NAMES[[kk]]
[17:01:03.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.162]                     next
[17:01:03.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.162]                 }
[17:01:03.162]                 if (length(args) > 0) 
[17:01:03.162]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.162]             }
[17:01:03.162]             else {
[17:01:03.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.162]             }
[17:01:03.162]             {
[17:01:03.162]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.162]                   0L) {
[17:01:03.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.162]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.162]                   base::options(opts)
[17:01:03.162]                 }
[17:01:03.162]                 {
[17:01:03.162]                   {
[17:01:03.162]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.162]                     NULL
[17:01:03.162]                   }
[17:01:03.162]                   options(future.plan = NULL)
[17:01:03.162]                   if (is.na(NA_character_)) 
[17:01:03.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.162]                     .init = FALSE)
[17:01:03.162]                 }
[17:01:03.162]             }
[17:01:03.162]         }
[17:01:03.162]     })
[17:01:03.162]     if (TRUE) {
[17:01:03.162]         base::sink(type = "output", split = FALSE)
[17:01:03.162]         if (TRUE) {
[17:01:03.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.162]         }
[17:01:03.162]         else {
[17:01:03.162]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.162]         }
[17:01:03.162]         base::close(...future.stdout)
[17:01:03.162]         ...future.stdout <- NULL
[17:01:03.162]     }
[17:01:03.162]     ...future.result$conditions <- ...future.conditions
[17:01:03.162]     ...future.result$finished <- base::Sys.time()
[17:01:03.162]     ...future.result
[17:01:03.162] }
[17:01:03.167] assign_globals() ...
[17:01:03.167] List of 5
[17:01:03.167]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:01:03.167]  $ future.call.arguments    : list()
[17:01:03.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.167]  $ ...future.elements_ii    :List of 4
[17:01:03.167]   ..$ : int [1:3] 1 2 3
[17:01:03.167]   ..$ : int [1:4] 1 2 3 4
[17:01:03.167]   ..$ : int [1:5] 1 2 3 4 5
[17:01:03.167]   ..$ : int [1:6] 1 2 3 4 5 6
[17:01:03.167]  $ ...future.seeds_ii       : NULL
[17:01:03.167]  $ ...future.globals.maxSize: NULL
[17:01:03.167]  - attr(*, "where")=List of 5
[17:01:03.167]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.167]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.167]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.167]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.167]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.167]  - attr(*, "resolved")= logi FALSE
[17:01:03.167]  - attr(*, "total_size")= num 46960
[17:01:03.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.167]  - attr(*, "already-done")= logi TRUE
[17:01:03.174] - copied ‘...future.FUN’ to environment
[17:01:03.174] - copied ‘future.call.arguments’ to environment
[17:01:03.174] - copied ‘...future.elements_ii’ to environment
[17:01:03.174] - copied ‘...future.seeds_ii’ to environment
[17:01:03.174] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.174] assign_globals() ... done
[17:01:03.175] requestCore(): workers = 2
[17:01:03.177] MulticoreFuture started
[17:01:03.177] - Launch lazy future ... done
[17:01:03.178] run() for ‘MulticoreFuture’ ... done
[17:01:03.178] Created future:
[17:01:03.178] plan(): Setting new future strategy stack:
[17:01:03.179] List of future strategies:
[17:01:03.179] 1. sequential:
[17:01:03.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.179]    - tweaked: FALSE
[17:01:03.179]    - call: NULL
[17:01:03.180] plan(): nbrOfWorkers() = 1
[17:01:03.182] plan(): Setting new future strategy stack:
[17:01:03.182] List of future strategies:
[17:01:03.182] 1. multicore:
[17:01:03.182]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.182]    - tweaked: FALSE
[17:01:03.182]    - call: plan(strategy)
[17:01:03.187] plan(): nbrOfWorkers() = 2
[17:01:03.178] MulticoreFuture:
[17:01:03.178] Label: ‘future_sapply-1’
[17:01:03.178] Expression:
[17:01:03.178] {
[17:01:03.178]     do.call(function(...) {
[17:01:03.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.178]             on.exit(options(oopts), add = TRUE)
[17:01:03.178]         }
[17:01:03.178]         {
[17:01:03.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.178]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.178]             })
[17:01:03.178]         }
[17:01:03.178]     }, args = future.call.arguments)
[17:01:03.178] }
[17:01:03.178] Lazy evaluation: FALSE
[17:01:03.178] Asynchronous evaluation: TRUE
[17:01:03.178] Local evaluation: TRUE
[17:01:03.178] Environment: R_GlobalEnv
[17:01:03.178] Capture standard output: TRUE
[17:01:03.178] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.178] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:03.178] Packages: 1 packages (‘stats’)
[17:01:03.178] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.178] Resolved: TRUE
[17:01:03.178] Value: <not collected>
[17:01:03.178] Conditions captured: <none>
[17:01:03.178] Early signaling: FALSE
[17:01:03.178] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.178] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.188] Chunk #1 of 2 ... DONE
[17:01:03.189] Chunk #2 of 2 ...
[17:01:03.189]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.189] getGlobalsAndPackages() ...
[17:01:03.189] Searching for globals...
[17:01:03.190] 
[17:01:03.190] Searching for globals ... DONE
[17:01:03.190] - globals: [0] <none>
[17:01:03.190] getGlobalsAndPackages() ... DONE
[17:01:03.190]    + additional globals found: [n=0] 
[17:01:03.190]    + additional namespaces needed: [n=0] 
[17:01:03.190]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.190]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.191]  - seeds: <none>
[17:01:03.191]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.191] getGlobalsAndPackages() ...
[17:01:03.191] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.191] Resolving globals: FALSE
[17:01:03.191] Tweak future expression to call with '...' arguments ...
[17:01:03.192] {
[17:01:03.192]     do.call(function(...) {
[17:01:03.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.192]             on.exit(options(oopts), add = TRUE)
[17:01:03.192]         }
[17:01:03.192]         {
[17:01:03.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.192]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.192]             })
[17:01:03.192]         }
[17:01:03.192]     }, args = future.call.arguments)
[17:01:03.192] }
[17:01:03.192] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.193] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.193] - packages: [1] ‘stats’
[17:01:03.193] getGlobalsAndPackages() ... DONE
[17:01:03.194] run() for ‘Future’ ...
[17:01:03.194] - state: ‘created’
[17:01:03.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.199] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.199]   - Field: ‘label’
[17:01:03.199]   - Field: ‘local’
[17:01:03.199]   - Field: ‘owner’
[17:01:03.200]   - Field: ‘envir’
[17:01:03.200]   - Field: ‘workers’
[17:01:03.200]   - Field: ‘packages’
[17:01:03.200]   - Field: ‘gc’
[17:01:03.200]   - Field: ‘job’
[17:01:03.200]   - Field: ‘conditions’
[17:01:03.201]   - Field: ‘expr’
[17:01:03.201]   - Field: ‘uuid’
[17:01:03.201]   - Field: ‘seed’
[17:01:03.201]   - Field: ‘version’
[17:01:03.201]   - Field: ‘result’
[17:01:03.201]   - Field: ‘asynchronous’
[17:01:03.202]   - Field: ‘calls’
[17:01:03.202]   - Field: ‘globals’
[17:01:03.202]   - Field: ‘stdout’
[17:01:03.202]   - Field: ‘earlySignal’
[17:01:03.202]   - Field: ‘lazy’
[17:01:03.202]   - Field: ‘state’
[17:01:03.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.203] - Launch lazy future ...
[17:01:03.203] Packages needed by the future expression (n = 1): ‘stats’
[17:01:03.203] Packages needed by future strategies (n = 0): <none>
[17:01:03.204] {
[17:01:03.204]     {
[17:01:03.204]         {
[17:01:03.204]             ...future.startTime <- base::Sys.time()
[17:01:03.204]             {
[17:01:03.204]                 {
[17:01:03.204]                   {
[17:01:03.204]                     {
[17:01:03.204]                       {
[17:01:03.204]                         base::local({
[17:01:03.204]                           has_future <- base::requireNamespace("future", 
[17:01:03.204]                             quietly = TRUE)
[17:01:03.204]                           if (has_future) {
[17:01:03.204]                             ns <- base::getNamespace("future")
[17:01:03.204]                             version <- ns[[".package"]][["version"]]
[17:01:03.204]                             if (is.null(version)) 
[17:01:03.204]                               version <- utils::packageVersion("future")
[17:01:03.204]                           }
[17:01:03.204]                           else {
[17:01:03.204]                             version <- NULL
[17:01:03.204]                           }
[17:01:03.204]                           if (!has_future || version < "1.8.0") {
[17:01:03.204]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.204]                               "", base::R.version$version.string), 
[17:01:03.204]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.204]                                 base::R.version$platform, 8 * 
[17:01:03.204]                                   base::.Machine$sizeof.pointer), 
[17:01:03.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.204]                                 "release", "version")], collapse = " "), 
[17:01:03.204]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.204]                               info)
[17:01:03.204]                             info <- base::paste(info, collapse = "; ")
[17:01:03.204]                             if (!has_future) {
[17:01:03.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.204]                                 info)
[17:01:03.204]                             }
[17:01:03.204]                             else {
[17:01:03.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.204]                                 info, version)
[17:01:03.204]                             }
[17:01:03.204]                             base::stop(msg)
[17:01:03.204]                           }
[17:01:03.204]                         })
[17:01:03.204]                       }
[17:01:03.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.204]                       base::options(mc.cores = 1L)
[17:01:03.204]                     }
[17:01:03.204]                     base::local({
[17:01:03.204]                       for (pkg in "stats") {
[17:01:03.204]                         base::loadNamespace(pkg)
[17:01:03.204]                         base::library(pkg, character.only = TRUE)
[17:01:03.204]                       }
[17:01:03.204]                     })
[17:01:03.204]                   }
[17:01:03.204]                   ...future.strategy.old <- future::plan("list")
[17:01:03.204]                   options(future.plan = NULL)
[17:01:03.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.204]                 }
[17:01:03.204]                 ...future.workdir <- getwd()
[17:01:03.204]             }
[17:01:03.204]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.204]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.204]         }
[17:01:03.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.204]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.204]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.204]             base::names(...future.oldOptions))
[17:01:03.204]     }
[17:01:03.204]     if (FALSE) {
[17:01:03.204]     }
[17:01:03.204]     else {
[17:01:03.204]         if (TRUE) {
[17:01:03.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.204]                 open = "w")
[17:01:03.204]         }
[17:01:03.204]         else {
[17:01:03.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.204]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.204]         }
[17:01:03.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.204]             base::sink(type = "output", split = FALSE)
[17:01:03.204]             base::close(...future.stdout)
[17:01:03.204]         }, add = TRUE)
[17:01:03.204]     }
[17:01:03.204]     ...future.frame <- base::sys.nframe()
[17:01:03.204]     ...future.conditions <- base::list()
[17:01:03.204]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.204]     if (FALSE) {
[17:01:03.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.204]     }
[17:01:03.204]     ...future.result <- base::tryCatch({
[17:01:03.204]         base::withCallingHandlers({
[17:01:03.204]             ...future.value <- base::withVisible(base::local({
[17:01:03.204]                 withCallingHandlers({
[17:01:03.204]                   {
[17:01:03.204]                     do.call(function(...) {
[17:01:03.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.204]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.204]                         ...future.globals.maxSize)) {
[17:01:03.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.204]                         on.exit(options(oopts), add = TRUE)
[17:01:03.204]                       }
[17:01:03.204]                       {
[17:01:03.204]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.204]                           FUN = function(jj) {
[17:01:03.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.204]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.204]                           })
[17:01:03.204]                       }
[17:01:03.204]                     }, args = future.call.arguments)
[17:01:03.204]                   }
[17:01:03.204]                 }, immediateCondition = function(cond) {
[17:01:03.204]                   save_rds <- function (object, pathname, ...) 
[17:01:03.204]                   {
[17:01:03.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.204]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.204]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.204]                         fi_tmp[["mtime"]])
[17:01:03.204]                     }
[17:01:03.204]                     tryCatch({
[17:01:03.204]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.204]                     }, error = function(ex) {
[17:01:03.204]                       msg <- conditionMessage(ex)
[17:01:03.204]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.204]                         fi_tmp[["mtime"]], msg)
[17:01:03.204]                       ex$message <- msg
[17:01:03.204]                       stop(ex)
[17:01:03.204]                     })
[17:01:03.204]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.204]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.204]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.204]                       fi <- file.info(pathname)
[17:01:03.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.204]                         fi[["size"]], fi[["mtime"]])
[17:01:03.204]                       stop(msg)
[17:01:03.204]                     }
[17:01:03.204]                     invisible(pathname)
[17:01:03.204]                   }
[17:01:03.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.204]                     rootPath = tempdir()) 
[17:01:03.204]                   {
[17:01:03.204]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.204]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.204]                       tmpdir = path, fileext = ".rds")
[17:01:03.204]                     save_rds(obj, file)
[17:01:03.204]                   }
[17:01:03.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.204]                   {
[17:01:03.204]                     inherits <- base::inherits
[17:01:03.204]                     invokeRestart <- base::invokeRestart
[17:01:03.204]                     is.null <- base::is.null
[17:01:03.204]                     muffled <- FALSE
[17:01:03.204]                     if (inherits(cond, "message")) {
[17:01:03.204]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.204]                       if (muffled) 
[17:01:03.204]                         invokeRestart("muffleMessage")
[17:01:03.204]                     }
[17:01:03.204]                     else if (inherits(cond, "warning")) {
[17:01:03.204]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.204]                       if (muffled) 
[17:01:03.204]                         invokeRestart("muffleWarning")
[17:01:03.204]                     }
[17:01:03.204]                     else if (inherits(cond, "condition")) {
[17:01:03.204]                       if (!is.null(pattern)) {
[17:01:03.204]                         computeRestarts <- base::computeRestarts
[17:01:03.204]                         grepl <- base::grepl
[17:01:03.204]                         restarts <- computeRestarts(cond)
[17:01:03.204]                         for (restart in restarts) {
[17:01:03.204]                           name <- restart$name
[17:01:03.204]                           if (is.null(name)) 
[17:01:03.204]                             next
[17:01:03.204]                           if (!grepl(pattern, name)) 
[17:01:03.204]                             next
[17:01:03.204]                           invokeRestart(restart)
[17:01:03.204]                           muffled <- TRUE
[17:01:03.204]                           break
[17:01:03.204]                         }
[17:01:03.204]                       }
[17:01:03.204]                     }
[17:01:03.204]                     invisible(muffled)
[17:01:03.204]                   }
[17:01:03.204]                   muffleCondition(cond)
[17:01:03.204]                 })
[17:01:03.204]             }))
[17:01:03.204]             future::FutureResult(value = ...future.value$value, 
[17:01:03.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.204]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.204]                     ...future.globalenv.names))
[17:01:03.204]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.204]         }, condition = base::local({
[17:01:03.204]             c <- base::c
[17:01:03.204]             inherits <- base::inherits
[17:01:03.204]             invokeRestart <- base::invokeRestart
[17:01:03.204]             length <- base::length
[17:01:03.204]             list <- base::list
[17:01:03.204]             seq.int <- base::seq.int
[17:01:03.204]             signalCondition <- base::signalCondition
[17:01:03.204]             sys.calls <- base::sys.calls
[17:01:03.204]             `[[` <- base::`[[`
[17:01:03.204]             `+` <- base::`+`
[17:01:03.204]             `<<-` <- base::`<<-`
[17:01:03.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.204]                   3L)]
[17:01:03.204]             }
[17:01:03.204]             function(cond) {
[17:01:03.204]                 is_error <- inherits(cond, "error")
[17:01:03.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.204]                   NULL)
[17:01:03.204]                 if (is_error) {
[17:01:03.204]                   sessionInformation <- function() {
[17:01:03.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.204]                       search = base::search(), system = base::Sys.info())
[17:01:03.204]                   }
[17:01:03.204]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.204]                     cond$call), session = sessionInformation(), 
[17:01:03.204]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.204]                   signalCondition(cond)
[17:01:03.204]                 }
[17:01:03.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.204]                 "immediateCondition"))) {
[17:01:03.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.204]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.204]                   if (TRUE && !signal) {
[17:01:03.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.204]                     {
[17:01:03.204]                       inherits <- base::inherits
[17:01:03.204]                       invokeRestart <- base::invokeRestart
[17:01:03.204]                       is.null <- base::is.null
[17:01:03.204]                       muffled <- FALSE
[17:01:03.204]                       if (inherits(cond, "message")) {
[17:01:03.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.204]                         if (muffled) 
[17:01:03.204]                           invokeRestart("muffleMessage")
[17:01:03.204]                       }
[17:01:03.204]                       else if (inherits(cond, "warning")) {
[17:01:03.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.204]                         if (muffled) 
[17:01:03.204]                           invokeRestart("muffleWarning")
[17:01:03.204]                       }
[17:01:03.204]                       else if (inherits(cond, "condition")) {
[17:01:03.204]                         if (!is.null(pattern)) {
[17:01:03.204]                           computeRestarts <- base::computeRestarts
[17:01:03.204]                           grepl <- base::grepl
[17:01:03.204]                           restarts <- computeRestarts(cond)
[17:01:03.204]                           for (restart in restarts) {
[17:01:03.204]                             name <- restart$name
[17:01:03.204]                             if (is.null(name)) 
[17:01:03.204]                               next
[17:01:03.204]                             if (!grepl(pattern, name)) 
[17:01:03.204]                               next
[17:01:03.204]                             invokeRestart(restart)
[17:01:03.204]                             muffled <- TRUE
[17:01:03.204]                             break
[17:01:03.204]                           }
[17:01:03.204]                         }
[17:01:03.204]                       }
[17:01:03.204]                       invisible(muffled)
[17:01:03.204]                     }
[17:01:03.204]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.204]                   }
[17:01:03.204]                 }
[17:01:03.204]                 else {
[17:01:03.204]                   if (TRUE) {
[17:01:03.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.204]                     {
[17:01:03.204]                       inherits <- base::inherits
[17:01:03.204]                       invokeRestart <- base::invokeRestart
[17:01:03.204]                       is.null <- base::is.null
[17:01:03.204]                       muffled <- FALSE
[17:01:03.204]                       if (inherits(cond, "message")) {
[17:01:03.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.204]                         if (muffled) 
[17:01:03.204]                           invokeRestart("muffleMessage")
[17:01:03.204]                       }
[17:01:03.204]                       else if (inherits(cond, "warning")) {
[17:01:03.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.204]                         if (muffled) 
[17:01:03.204]                           invokeRestart("muffleWarning")
[17:01:03.204]                       }
[17:01:03.204]                       else if (inherits(cond, "condition")) {
[17:01:03.204]                         if (!is.null(pattern)) {
[17:01:03.204]                           computeRestarts <- base::computeRestarts
[17:01:03.204]                           grepl <- base::grepl
[17:01:03.204]                           restarts <- computeRestarts(cond)
[17:01:03.204]                           for (restart in restarts) {
[17:01:03.204]                             name <- restart$name
[17:01:03.204]                             if (is.null(name)) 
[17:01:03.204]                               next
[17:01:03.204]                             if (!grepl(pattern, name)) 
[17:01:03.204]                               next
[17:01:03.204]                             invokeRestart(restart)
[17:01:03.204]                             muffled <- TRUE
[17:01:03.204]                             break
[17:01:03.204]                           }
[17:01:03.204]                         }
[17:01:03.204]                       }
[17:01:03.204]                       invisible(muffled)
[17:01:03.204]                     }
[17:01:03.204]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.204]                   }
[17:01:03.204]                 }
[17:01:03.204]             }
[17:01:03.204]         }))
[17:01:03.204]     }, error = function(ex) {
[17:01:03.204]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.204]                 ...future.rng), started = ...future.startTime, 
[17:01:03.204]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.204]             version = "1.8"), class = "FutureResult")
[17:01:03.204]     }, finally = {
[17:01:03.204]         if (!identical(...future.workdir, getwd())) 
[17:01:03.204]             setwd(...future.workdir)
[17:01:03.204]         {
[17:01:03.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.204]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.204]             }
[17:01:03.204]             base::options(...future.oldOptions)
[17:01:03.204]             if (.Platform$OS.type == "windows") {
[17:01:03.204]                 old_names <- names(...future.oldEnvVars)
[17:01:03.204]                 envs <- base::Sys.getenv()
[17:01:03.204]                 names <- names(envs)
[17:01:03.204]                 common <- intersect(names, old_names)
[17:01:03.204]                 added <- setdiff(names, old_names)
[17:01:03.204]                 removed <- setdiff(old_names, names)
[17:01:03.204]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.204]                   envs[common]]
[17:01:03.204]                 NAMES <- toupper(changed)
[17:01:03.204]                 args <- list()
[17:01:03.204]                 for (kk in seq_along(NAMES)) {
[17:01:03.204]                   name <- changed[[kk]]
[17:01:03.204]                   NAME <- NAMES[[kk]]
[17:01:03.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.204]                     next
[17:01:03.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.204]                 }
[17:01:03.204]                 NAMES <- toupper(added)
[17:01:03.204]                 for (kk in seq_along(NAMES)) {
[17:01:03.204]                   name <- added[[kk]]
[17:01:03.204]                   NAME <- NAMES[[kk]]
[17:01:03.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.204]                     next
[17:01:03.204]                   args[[name]] <- ""
[17:01:03.204]                 }
[17:01:03.204]                 NAMES <- toupper(removed)
[17:01:03.204]                 for (kk in seq_along(NAMES)) {
[17:01:03.204]                   name <- removed[[kk]]
[17:01:03.204]                   NAME <- NAMES[[kk]]
[17:01:03.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.204]                     next
[17:01:03.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.204]                 }
[17:01:03.204]                 if (length(args) > 0) 
[17:01:03.204]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.204]             }
[17:01:03.204]             else {
[17:01:03.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.204]             }
[17:01:03.204]             {
[17:01:03.204]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.204]                   0L) {
[17:01:03.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.204]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.204]                   base::options(opts)
[17:01:03.204]                 }
[17:01:03.204]                 {
[17:01:03.204]                   {
[17:01:03.204]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.204]                     NULL
[17:01:03.204]                   }
[17:01:03.204]                   options(future.plan = NULL)
[17:01:03.204]                   if (is.na(NA_character_)) 
[17:01:03.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.204]                     .init = FALSE)
[17:01:03.204]                 }
[17:01:03.204]             }
[17:01:03.204]         }
[17:01:03.204]     })
[17:01:03.204]     if (TRUE) {
[17:01:03.204]         base::sink(type = "output", split = FALSE)
[17:01:03.204]         if (TRUE) {
[17:01:03.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.204]         }
[17:01:03.204]         else {
[17:01:03.204]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.204]         }
[17:01:03.204]         base::close(...future.stdout)
[17:01:03.204]         ...future.stdout <- NULL
[17:01:03.204]     }
[17:01:03.204]     ...future.result$conditions <- ...future.conditions
[17:01:03.204]     ...future.result$finished <- base::Sys.time()
[17:01:03.204]     ...future.result
[17:01:03.204] }
[17:01:03.208] assign_globals() ...
[17:01:03.208] List of 5
[17:01:03.208]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:01:03.208]  $ future.call.arguments    : list()
[17:01:03.208]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.208]  $ ...future.elements_ii    :List of 3
[17:01:03.208]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:01:03.208]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:01:03.208]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:01:03.208]  $ ...future.seeds_ii       : NULL
[17:01:03.208]  $ ...future.globals.maxSize: NULL
[17:01:03.208]  - attr(*, "where")=List of 5
[17:01:03.208]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.208]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.208]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.208]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.208]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.208]  - attr(*, "resolved")= logi FALSE
[17:01:03.208]  - attr(*, "total_size")= num 46960
[17:01:03.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.208]  - attr(*, "already-done")= logi TRUE
[17:01:03.220] - copied ‘...future.FUN’ to environment
[17:01:03.220] - copied ‘future.call.arguments’ to environment
[17:01:03.220] - copied ‘...future.elements_ii’ to environment
[17:01:03.221] - copied ‘...future.seeds_ii’ to environment
[17:01:03.221] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.221] assign_globals() ... done
[17:01:03.221] requestCore(): workers = 2
[17:01:03.224] MulticoreFuture started
[17:01:03.224] - Launch lazy future ... done
[17:01:03.225] run() for ‘MulticoreFuture’ ... done
[17:01:03.225] Created future:
[17:01:03.226] plan(): Setting new future strategy stack:
[17:01:03.226] List of future strategies:
[17:01:03.226] 1. sequential:
[17:01:03.226]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.226]    - tweaked: FALSE
[17:01:03.226]    - call: NULL
[17:01:03.228] plan(): nbrOfWorkers() = 1
[17:01:03.231] plan(): Setting new future strategy stack:
[17:01:03.231] List of future strategies:
[17:01:03.231] 1. multicore:
[17:01:03.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.231]    - tweaked: FALSE
[17:01:03.231]    - call: plan(strategy)
[17:01:03.237] plan(): nbrOfWorkers() = 2
[17:01:03.226] MulticoreFuture:
[17:01:03.226] Label: ‘future_sapply-2’
[17:01:03.226] Expression:
[17:01:03.226] {
[17:01:03.226]     do.call(function(...) {
[17:01:03.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.226]             on.exit(options(oopts), add = TRUE)
[17:01:03.226]         }
[17:01:03.226]         {
[17:01:03.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.226]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.226]             })
[17:01:03.226]         }
[17:01:03.226]     }, args = future.call.arguments)
[17:01:03.226] }
[17:01:03.226] Lazy evaluation: FALSE
[17:01:03.226] Asynchronous evaluation: TRUE
[17:01:03.226] Local evaluation: TRUE
[17:01:03.226] Environment: R_GlobalEnv
[17:01:03.226] Capture standard output: TRUE
[17:01:03.226] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.226] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:03.226] Packages: 1 packages (‘stats’)
[17:01:03.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.226] Resolved: TRUE
[17:01:03.226] Value: <not collected>
[17:01:03.226] Conditions captured: <none>
[17:01:03.226] Early signaling: FALSE
[17:01:03.226] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.226] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.238] Chunk #2 of 2 ... DONE
[17:01:03.238] Launching 2 futures (chunks) ... DONE
[17:01:03.238] Resolving 2 futures (chunks) ...
[17:01:03.238] resolve() on list ...
[17:01:03.238]  recursive: 0
[17:01:03.239]  length: 2
[17:01:03.239] 
[17:01:03.239] Future #1
[17:01:03.239] result() for MulticoreFuture ...
[17:01:03.240] result() for MulticoreFuture ...
[17:01:03.241] result() for MulticoreFuture ... done
[17:01:03.241] result() for MulticoreFuture ... done
[17:01:03.241] result() for MulticoreFuture ...
[17:01:03.241] result() for MulticoreFuture ... done
[17:01:03.241] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.242] - nx: 2
[17:01:03.242] - relay: TRUE
[17:01:03.242] - stdout: TRUE
[17:01:03.242] - signal: TRUE
[17:01:03.242] - resignal: FALSE
[17:01:03.242] - force: TRUE
[17:01:03.242] - relayed: [n=2] FALSE, FALSE
[17:01:03.242] - queued futures: [n=2] FALSE, FALSE
[17:01:03.243]  - until=1
[17:01:03.243]  - relaying element #1
[17:01:03.243] result() for MulticoreFuture ...
[17:01:03.243] result() for MulticoreFuture ... done
[17:01:03.243] result() for MulticoreFuture ...
[17:01:03.243] result() for MulticoreFuture ... done
[17:01:03.244] result() for MulticoreFuture ...
[17:01:03.244] result() for MulticoreFuture ... done
[17:01:03.244] result() for MulticoreFuture ...
[17:01:03.244] result() for MulticoreFuture ... done
[17:01:03.244] - relayed: [n=2] TRUE, FALSE
[17:01:03.244] - queued futures: [n=2] TRUE, FALSE
[17:01:03.244] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.245]  length: 1 (resolved future 1)
[17:01:03.245] Future #2
[17:01:03.245] result() for MulticoreFuture ...
[17:01:03.246] result() for MulticoreFuture ...
[17:01:03.246] result() for MulticoreFuture ... done
[17:01:03.246] result() for MulticoreFuture ... done
[17:01:03.246] result() for MulticoreFuture ...
[17:01:03.246] result() for MulticoreFuture ... done
[17:01:03.247] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.247] - nx: 2
[17:01:03.247] - relay: TRUE
[17:01:03.247] - stdout: TRUE
[17:01:03.247] - signal: TRUE
[17:01:03.247] - resignal: FALSE
[17:01:03.248] - force: TRUE
[17:01:03.248] - relayed: [n=2] TRUE, FALSE
[17:01:03.248] - queued futures: [n=2] TRUE, FALSE
[17:01:03.248]  - until=2
[17:01:03.248]  - relaying element #2
[17:01:03.248] result() for MulticoreFuture ...
[17:01:03.249] result() for MulticoreFuture ... done
[17:01:03.249] result() for MulticoreFuture ...
[17:01:03.249] result() for MulticoreFuture ... done
[17:01:03.249] result() for MulticoreFuture ...
[17:01:03.249] result() for MulticoreFuture ... done
[17:01:03.249] result() for MulticoreFuture ...
[17:01:03.249] result() for MulticoreFuture ... done
[17:01:03.250] - relayed: [n=2] TRUE, TRUE
[17:01:03.250] - queued futures: [n=2] TRUE, TRUE
[17:01:03.250] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.250]  length: 0 (resolved future 2)
[17:01:03.250] Relaying remaining futures
[17:01:03.250] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.250] - nx: 2
[17:01:03.250] - relay: TRUE
[17:01:03.250] - stdout: TRUE
[17:01:03.250] - signal: TRUE
[17:01:03.250] - resignal: FALSE
[17:01:03.251] - force: TRUE
[17:01:03.251] - relayed: [n=2] TRUE, TRUE
[17:01:03.251] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.251] - relayed: [n=2] TRUE, TRUE
[17:01:03.251] - queued futures: [n=2] TRUE, TRUE
[17:01:03.251] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.251] resolve() on list ... DONE
[17:01:03.251] result() for MulticoreFuture ...
[17:01:03.252] result() for MulticoreFuture ... done
[17:01:03.252] result() for MulticoreFuture ...
[17:01:03.252] result() for MulticoreFuture ... done
[17:01:03.252] result() for MulticoreFuture ...
[17:01:03.252] result() for MulticoreFuture ... done
[17:01:03.252] result() for MulticoreFuture ...
[17:01:03.252] result() for MulticoreFuture ... done
[17:01:03.252]  - Number of value chunks collected: 2
[17:01:03.252] Resolving 2 futures (chunks) ... DONE
[17:01:03.253] Reducing values from 2 chunks ...
[17:01:03.253]  - Number of values collected after concatenation: 7
[17:01:03.253]  - Number of values expected: 7
[17:01:03.253] Reducing values from 2 chunks ... DONE
[17:01:03.253] future_lapply() ... DONE
[17:01:03.254] future_lapply() ...
[17:01:03.260] Number of chunks: 2
[17:01:03.260] getGlobalsAndPackagesXApply() ...
[17:01:03.260]  - future.globals: TRUE
[17:01:03.260] getGlobalsAndPackages() ...
[17:01:03.260] Searching for globals...
[17:01:03.271] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:03.271] Searching for globals ... DONE
[17:01:03.271] Resolving globals: FALSE
[17:01:03.273] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:01:03.273] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:01:03.273] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.273] - packages: [2] ‘stats’, ‘future.apply’
[17:01:03.274] getGlobalsAndPackages() ... DONE
[17:01:03.274]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.274]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:03.274] Finding globals ... DONE
[17:01:03.274]  - use_args: TRUE
[17:01:03.274]  - Getting '...' globals ...
[17:01:03.274] resolve() on list ...
[17:01:03.274]  recursive: 0
[17:01:03.275]  length: 1
[17:01:03.275]  elements: ‘...’
[17:01:03.275]  length: 0 (resolved future 1)
[17:01:03.275] resolve() on list ... DONE
[17:01:03.275]    - '...' content: [n=0] 
[17:01:03.275] List of 1
[17:01:03.275]  $ ...: list()
[17:01:03.275]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.275]  - attr(*, "where")=List of 1
[17:01:03.275]   ..$ ...:<environment: 0x55aadb3426c0> 
[17:01:03.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.275]  - attr(*, "resolved")= logi TRUE
[17:01:03.275]  - attr(*, "total_size")= num NA
[17:01:03.278]  - Getting '...' globals ... DONE
[17:01:03.278] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:03.278] List of 8
[17:01:03.278]  $ ...future.FUN:function (x, ...)  
[17:01:03.278]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:01:03.278]  $ times        : int 5
[17:01:03.278]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.278]  $ stop_if_not  :function (...)  
[17:01:03.278]  $ dim          : NULL
[17:01:03.278]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:03.278]  $ ...          : list()
[17:01:03.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.278]  - attr(*, "where")=List of 8
[17:01:03.278]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:03.278]   ..$ ...          :<environment: 0x55aadb3426c0> 
[17:01:03.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.278]  - attr(*, "resolved")= logi FALSE
[17:01:03.278]  - attr(*, "total_size")= num 141240
[17:01:03.286] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:03.286] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.286] Number of futures (= number of chunks): 2
[17:01:03.286] Launching 2 futures (chunks) ...
[17:01:03.286] Chunk #1 of 2 ...
[17:01:03.287]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.287] getGlobalsAndPackages() ...
[17:01:03.287] Searching for globals...
[17:01:03.287] 
[17:01:03.287] Searching for globals ... DONE
[17:01:03.287] - globals: [0] <none>
[17:01:03.287] getGlobalsAndPackages() ... DONE
[17:01:03.288]    + additional globals found: [n=0] 
[17:01:03.288]    + additional namespaces needed: [n=0] 
[17:01:03.288]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.288]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.288]  - seeds: <none>
[17:01:03.288]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.288] getGlobalsAndPackages() ...
[17:01:03.288] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.289] Resolving globals: FALSE
[17:01:03.289] Tweak future expression to call with '...' arguments ...
[17:01:03.289] {
[17:01:03.289]     do.call(function(...) {
[17:01:03.289]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.289]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.289]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.289]             on.exit(options(oopts), add = TRUE)
[17:01:03.289]         }
[17:01:03.289]         {
[17:01:03.289]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.289]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.289]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.289]             })
[17:01:03.289]         }
[17:01:03.289]     }, args = future.call.arguments)
[17:01:03.289] }
[17:01:03.289] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.290] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.290] - packages: [2] ‘stats’, ‘future.apply’
[17:01:03.290] getGlobalsAndPackages() ... DONE
[17:01:03.290] run() for ‘Future’ ...
[17:01:03.290] - state: ‘created’
[17:01:03.290] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.294] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.294] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.295]   - Field: ‘label’
[17:01:03.295]   - Field: ‘local’
[17:01:03.295]   - Field: ‘owner’
[17:01:03.295]   - Field: ‘envir’
[17:01:03.295]   - Field: ‘workers’
[17:01:03.295]   - Field: ‘packages’
[17:01:03.295]   - Field: ‘gc’
[17:01:03.295]   - Field: ‘job’
[17:01:03.295]   - Field: ‘conditions’
[17:01:03.295]   - Field: ‘expr’
[17:01:03.296]   - Field: ‘uuid’
[17:01:03.296]   - Field: ‘seed’
[17:01:03.296]   - Field: ‘version’
[17:01:03.296]   - Field: ‘result’
[17:01:03.296]   - Field: ‘asynchronous’
[17:01:03.296]   - Field: ‘calls’
[17:01:03.296]   - Field: ‘globals’
[17:01:03.296]   - Field: ‘stdout’
[17:01:03.296]   - Field: ‘earlySignal’
[17:01:03.296]   - Field: ‘lazy’
[17:01:03.296]   - Field: ‘state’
[17:01:03.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.297] - Launch lazy future ...
[17:01:03.297] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:03.297] Packages needed by future strategies (n = 0): <none>
[17:01:03.298] {
[17:01:03.298]     {
[17:01:03.298]         {
[17:01:03.298]             ...future.startTime <- base::Sys.time()
[17:01:03.298]             {
[17:01:03.298]                 {
[17:01:03.298]                   {
[17:01:03.298]                     {
[17:01:03.298]                       {
[17:01:03.298]                         base::local({
[17:01:03.298]                           has_future <- base::requireNamespace("future", 
[17:01:03.298]                             quietly = TRUE)
[17:01:03.298]                           if (has_future) {
[17:01:03.298]                             ns <- base::getNamespace("future")
[17:01:03.298]                             version <- ns[[".package"]][["version"]]
[17:01:03.298]                             if (is.null(version)) 
[17:01:03.298]                               version <- utils::packageVersion("future")
[17:01:03.298]                           }
[17:01:03.298]                           else {
[17:01:03.298]                             version <- NULL
[17:01:03.298]                           }
[17:01:03.298]                           if (!has_future || version < "1.8.0") {
[17:01:03.298]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.298]                               "", base::R.version$version.string), 
[17:01:03.298]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.298]                                 base::R.version$platform, 8 * 
[17:01:03.298]                                   base::.Machine$sizeof.pointer), 
[17:01:03.298]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.298]                                 "release", "version")], collapse = " "), 
[17:01:03.298]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.298]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.298]                               info)
[17:01:03.298]                             info <- base::paste(info, collapse = "; ")
[17:01:03.298]                             if (!has_future) {
[17:01:03.298]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.298]                                 info)
[17:01:03.298]                             }
[17:01:03.298]                             else {
[17:01:03.298]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.298]                                 info, version)
[17:01:03.298]                             }
[17:01:03.298]                             base::stop(msg)
[17:01:03.298]                           }
[17:01:03.298]                         })
[17:01:03.298]                       }
[17:01:03.298]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.298]                       base::options(mc.cores = 1L)
[17:01:03.298]                     }
[17:01:03.298]                     base::local({
[17:01:03.298]                       for (pkg in c("stats", "future.apply")) {
[17:01:03.298]                         base::loadNamespace(pkg)
[17:01:03.298]                         base::library(pkg, character.only = TRUE)
[17:01:03.298]                       }
[17:01:03.298]                     })
[17:01:03.298]                   }
[17:01:03.298]                   ...future.strategy.old <- future::plan("list")
[17:01:03.298]                   options(future.plan = NULL)
[17:01:03.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.298]                 }
[17:01:03.298]                 ...future.workdir <- getwd()
[17:01:03.298]             }
[17:01:03.298]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.298]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.298]         }
[17:01:03.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.298]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.298]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.298]             base::names(...future.oldOptions))
[17:01:03.298]     }
[17:01:03.298]     if (FALSE) {
[17:01:03.298]     }
[17:01:03.298]     else {
[17:01:03.298]         if (TRUE) {
[17:01:03.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.298]                 open = "w")
[17:01:03.298]         }
[17:01:03.298]         else {
[17:01:03.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.298]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.298]         }
[17:01:03.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.298]             base::sink(type = "output", split = FALSE)
[17:01:03.298]             base::close(...future.stdout)
[17:01:03.298]         }, add = TRUE)
[17:01:03.298]     }
[17:01:03.298]     ...future.frame <- base::sys.nframe()
[17:01:03.298]     ...future.conditions <- base::list()
[17:01:03.298]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.298]     if (FALSE) {
[17:01:03.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.298]     }
[17:01:03.298]     ...future.result <- base::tryCatch({
[17:01:03.298]         base::withCallingHandlers({
[17:01:03.298]             ...future.value <- base::withVisible(base::local({
[17:01:03.298]                 withCallingHandlers({
[17:01:03.298]                   {
[17:01:03.298]                     do.call(function(...) {
[17:01:03.298]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.298]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.298]                         ...future.globals.maxSize)) {
[17:01:03.298]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.298]                         on.exit(options(oopts), add = TRUE)
[17:01:03.298]                       }
[17:01:03.298]                       {
[17:01:03.298]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.298]                           FUN = function(jj) {
[17:01:03.298]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.298]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.298]                           })
[17:01:03.298]                       }
[17:01:03.298]                     }, args = future.call.arguments)
[17:01:03.298]                   }
[17:01:03.298]                 }, immediateCondition = function(cond) {
[17:01:03.298]                   save_rds <- function (object, pathname, ...) 
[17:01:03.298]                   {
[17:01:03.298]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.298]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.298]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.298]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.298]                         fi_tmp[["mtime"]])
[17:01:03.298]                     }
[17:01:03.298]                     tryCatch({
[17:01:03.298]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.298]                     }, error = function(ex) {
[17:01:03.298]                       msg <- conditionMessage(ex)
[17:01:03.298]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.298]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.298]                         fi_tmp[["mtime"]], msg)
[17:01:03.298]                       ex$message <- msg
[17:01:03.298]                       stop(ex)
[17:01:03.298]                     })
[17:01:03.298]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.298]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.298]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.298]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.298]                       fi <- file.info(pathname)
[17:01:03.298]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.298]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.298]                         fi[["size"]], fi[["mtime"]])
[17:01:03.298]                       stop(msg)
[17:01:03.298]                     }
[17:01:03.298]                     invisible(pathname)
[17:01:03.298]                   }
[17:01:03.298]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.298]                     rootPath = tempdir()) 
[17:01:03.298]                   {
[17:01:03.298]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.298]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.298]                       tmpdir = path, fileext = ".rds")
[17:01:03.298]                     save_rds(obj, file)
[17:01:03.298]                   }
[17:01:03.298]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.298]                   {
[17:01:03.298]                     inherits <- base::inherits
[17:01:03.298]                     invokeRestart <- base::invokeRestart
[17:01:03.298]                     is.null <- base::is.null
[17:01:03.298]                     muffled <- FALSE
[17:01:03.298]                     if (inherits(cond, "message")) {
[17:01:03.298]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.298]                       if (muffled) 
[17:01:03.298]                         invokeRestart("muffleMessage")
[17:01:03.298]                     }
[17:01:03.298]                     else if (inherits(cond, "warning")) {
[17:01:03.298]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.298]                       if (muffled) 
[17:01:03.298]                         invokeRestart("muffleWarning")
[17:01:03.298]                     }
[17:01:03.298]                     else if (inherits(cond, "condition")) {
[17:01:03.298]                       if (!is.null(pattern)) {
[17:01:03.298]                         computeRestarts <- base::computeRestarts
[17:01:03.298]                         grepl <- base::grepl
[17:01:03.298]                         restarts <- computeRestarts(cond)
[17:01:03.298]                         for (restart in restarts) {
[17:01:03.298]                           name <- restart$name
[17:01:03.298]                           if (is.null(name)) 
[17:01:03.298]                             next
[17:01:03.298]                           if (!grepl(pattern, name)) 
[17:01:03.298]                             next
[17:01:03.298]                           invokeRestart(restart)
[17:01:03.298]                           muffled <- TRUE
[17:01:03.298]                           break
[17:01:03.298]                         }
[17:01:03.298]                       }
[17:01:03.298]                     }
[17:01:03.298]                     invisible(muffled)
[17:01:03.298]                   }
[17:01:03.298]                   muffleCondition(cond)
[17:01:03.298]                 })
[17:01:03.298]             }))
[17:01:03.298]             future::FutureResult(value = ...future.value$value, 
[17:01:03.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.298]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.298]                     ...future.globalenv.names))
[17:01:03.298]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.298]         }, condition = base::local({
[17:01:03.298]             c <- base::c
[17:01:03.298]             inherits <- base::inherits
[17:01:03.298]             invokeRestart <- base::invokeRestart
[17:01:03.298]             length <- base::length
[17:01:03.298]             list <- base::list
[17:01:03.298]             seq.int <- base::seq.int
[17:01:03.298]             signalCondition <- base::signalCondition
[17:01:03.298]             sys.calls <- base::sys.calls
[17:01:03.298]             `[[` <- base::`[[`
[17:01:03.298]             `+` <- base::`+`
[17:01:03.298]             `<<-` <- base::`<<-`
[17:01:03.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.298]                   3L)]
[17:01:03.298]             }
[17:01:03.298]             function(cond) {
[17:01:03.298]                 is_error <- inherits(cond, "error")
[17:01:03.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.298]                   NULL)
[17:01:03.298]                 if (is_error) {
[17:01:03.298]                   sessionInformation <- function() {
[17:01:03.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.298]                       search = base::search(), system = base::Sys.info())
[17:01:03.298]                   }
[17:01:03.298]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.298]                     cond$call), session = sessionInformation(), 
[17:01:03.298]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.298]                   signalCondition(cond)
[17:01:03.298]                 }
[17:01:03.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.298]                 "immediateCondition"))) {
[17:01:03.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.298]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.298]                   if (TRUE && !signal) {
[17:01:03.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.298]                     {
[17:01:03.298]                       inherits <- base::inherits
[17:01:03.298]                       invokeRestart <- base::invokeRestart
[17:01:03.298]                       is.null <- base::is.null
[17:01:03.298]                       muffled <- FALSE
[17:01:03.298]                       if (inherits(cond, "message")) {
[17:01:03.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.298]                         if (muffled) 
[17:01:03.298]                           invokeRestart("muffleMessage")
[17:01:03.298]                       }
[17:01:03.298]                       else if (inherits(cond, "warning")) {
[17:01:03.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.298]                         if (muffled) 
[17:01:03.298]                           invokeRestart("muffleWarning")
[17:01:03.298]                       }
[17:01:03.298]                       else if (inherits(cond, "condition")) {
[17:01:03.298]                         if (!is.null(pattern)) {
[17:01:03.298]                           computeRestarts <- base::computeRestarts
[17:01:03.298]                           grepl <- base::grepl
[17:01:03.298]                           restarts <- computeRestarts(cond)
[17:01:03.298]                           for (restart in restarts) {
[17:01:03.298]                             name <- restart$name
[17:01:03.298]                             if (is.null(name)) 
[17:01:03.298]                               next
[17:01:03.298]                             if (!grepl(pattern, name)) 
[17:01:03.298]                               next
[17:01:03.298]                             invokeRestart(restart)
[17:01:03.298]                             muffled <- TRUE
[17:01:03.298]                             break
[17:01:03.298]                           }
[17:01:03.298]                         }
[17:01:03.298]                       }
[17:01:03.298]                       invisible(muffled)
[17:01:03.298]                     }
[17:01:03.298]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.298]                   }
[17:01:03.298]                 }
[17:01:03.298]                 else {
[17:01:03.298]                   if (TRUE) {
[17:01:03.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.298]                     {
[17:01:03.298]                       inherits <- base::inherits
[17:01:03.298]                       invokeRestart <- base::invokeRestart
[17:01:03.298]                       is.null <- base::is.null
[17:01:03.298]                       muffled <- FALSE
[17:01:03.298]                       if (inherits(cond, "message")) {
[17:01:03.298]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.298]                         if (muffled) 
[17:01:03.298]                           invokeRestart("muffleMessage")
[17:01:03.298]                       }
[17:01:03.298]                       else if (inherits(cond, "warning")) {
[17:01:03.298]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.298]                         if (muffled) 
[17:01:03.298]                           invokeRestart("muffleWarning")
[17:01:03.298]                       }
[17:01:03.298]                       else if (inherits(cond, "condition")) {
[17:01:03.298]                         if (!is.null(pattern)) {
[17:01:03.298]                           computeRestarts <- base::computeRestarts
[17:01:03.298]                           grepl <- base::grepl
[17:01:03.298]                           restarts <- computeRestarts(cond)
[17:01:03.298]                           for (restart in restarts) {
[17:01:03.298]                             name <- restart$name
[17:01:03.298]                             if (is.null(name)) 
[17:01:03.298]                               next
[17:01:03.298]                             if (!grepl(pattern, name)) 
[17:01:03.298]                               next
[17:01:03.298]                             invokeRestart(restart)
[17:01:03.298]                             muffled <- TRUE
[17:01:03.298]                             break
[17:01:03.298]                           }
[17:01:03.298]                         }
[17:01:03.298]                       }
[17:01:03.298]                       invisible(muffled)
[17:01:03.298]                     }
[17:01:03.298]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.298]                   }
[17:01:03.298]                 }
[17:01:03.298]             }
[17:01:03.298]         }))
[17:01:03.298]     }, error = function(ex) {
[17:01:03.298]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.298]                 ...future.rng), started = ...future.startTime, 
[17:01:03.298]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.298]             version = "1.8"), class = "FutureResult")
[17:01:03.298]     }, finally = {
[17:01:03.298]         if (!identical(...future.workdir, getwd())) 
[17:01:03.298]             setwd(...future.workdir)
[17:01:03.298]         {
[17:01:03.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.298]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.298]             }
[17:01:03.298]             base::options(...future.oldOptions)
[17:01:03.298]             if (.Platform$OS.type == "windows") {
[17:01:03.298]                 old_names <- names(...future.oldEnvVars)
[17:01:03.298]                 envs <- base::Sys.getenv()
[17:01:03.298]                 names <- names(envs)
[17:01:03.298]                 common <- intersect(names, old_names)
[17:01:03.298]                 added <- setdiff(names, old_names)
[17:01:03.298]                 removed <- setdiff(old_names, names)
[17:01:03.298]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.298]                   envs[common]]
[17:01:03.298]                 NAMES <- toupper(changed)
[17:01:03.298]                 args <- list()
[17:01:03.298]                 for (kk in seq_along(NAMES)) {
[17:01:03.298]                   name <- changed[[kk]]
[17:01:03.298]                   NAME <- NAMES[[kk]]
[17:01:03.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.298]                     next
[17:01:03.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.298]                 }
[17:01:03.298]                 NAMES <- toupper(added)
[17:01:03.298]                 for (kk in seq_along(NAMES)) {
[17:01:03.298]                   name <- added[[kk]]
[17:01:03.298]                   NAME <- NAMES[[kk]]
[17:01:03.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.298]                     next
[17:01:03.298]                   args[[name]] <- ""
[17:01:03.298]                 }
[17:01:03.298]                 NAMES <- toupper(removed)
[17:01:03.298]                 for (kk in seq_along(NAMES)) {
[17:01:03.298]                   name <- removed[[kk]]
[17:01:03.298]                   NAME <- NAMES[[kk]]
[17:01:03.298]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.298]                     next
[17:01:03.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.298]                 }
[17:01:03.298]                 if (length(args) > 0) 
[17:01:03.298]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.298]             }
[17:01:03.298]             else {
[17:01:03.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.298]             }
[17:01:03.298]             {
[17:01:03.298]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.298]                   0L) {
[17:01:03.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.298]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.298]                   base::options(opts)
[17:01:03.298]                 }
[17:01:03.298]                 {
[17:01:03.298]                   {
[17:01:03.298]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.298]                     NULL
[17:01:03.298]                   }
[17:01:03.298]                   options(future.plan = NULL)
[17:01:03.298]                   if (is.na(NA_character_)) 
[17:01:03.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.298]                     .init = FALSE)
[17:01:03.298]                 }
[17:01:03.298]             }
[17:01:03.298]         }
[17:01:03.298]     })
[17:01:03.298]     if (TRUE) {
[17:01:03.298]         base::sink(type = "output", split = FALSE)
[17:01:03.298]         if (TRUE) {
[17:01:03.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.298]         }
[17:01:03.298]         else {
[17:01:03.298]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.298]         }
[17:01:03.298]         base::close(...future.stdout)
[17:01:03.298]         ...future.stdout <- NULL
[17:01:03.298]     }
[17:01:03.298]     ...future.result$conditions <- ...future.conditions
[17:01:03.298]     ...future.result$finished <- base::Sys.time()
[17:01:03.298]     ...future.result
[17:01:03.298] }
[17:01:03.300] assign_globals() ...
[17:01:03.300] List of 11
[17:01:03.300]  $ ...future.FUN            :function (x, ...)  
[17:01:03.300]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:01:03.300]  $ times                    : int 5
[17:01:03.300]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.300]  $ stop_if_not              :function (...)  
[17:01:03.300]  $ dim                      : NULL
[17:01:03.300]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.300]  $ future.call.arguments    : list()
[17:01:03.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.300]  $ ...future.elements_ii    :List of 4
[17:01:03.300]   ..$ : int [1:3] 1 2 3
[17:01:03.300]   ..$ : int [1:4] 1 2 3 4
[17:01:03.300]   ..$ : int [1:5] 1 2 3 4 5
[17:01:03.300]   ..$ : int [1:6] 1 2 3 4 5 6
[17:01:03.300]  $ ...future.seeds_ii       : NULL
[17:01:03.300]  $ ...future.globals.maxSize: NULL
[17:01:03.300]  - attr(*, "where")=List of 11
[17:01:03.300]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.300]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.300]  - attr(*, "resolved")= logi FALSE
[17:01:03.300]  - attr(*, "total_size")= num 141240
[17:01:03.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.300]  - attr(*, "already-done")= logi TRUE
[17:01:03.311] - copied ‘...future.FUN’ to environment
[17:01:03.311] - copied ‘x_FUN’ to environment
[17:01:03.311] - copied ‘times’ to environment
[17:01:03.312] - copied ‘stopf’ to environment
[17:01:03.312] - copied ‘stop_if_not’ to environment
[17:01:03.312] - copied ‘dim’ to environment
[17:01:03.312] - copied ‘valid_types’ to environment
[17:01:03.312] - copied ‘future.call.arguments’ to environment
[17:01:03.312] - copied ‘...future.elements_ii’ to environment
[17:01:03.312] - copied ‘...future.seeds_ii’ to environment
[17:01:03.312] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.312] assign_globals() ... done
[17:01:03.313] requestCore(): workers = 2
[17:01:03.315] MulticoreFuture started
[17:01:03.316] - Launch lazy future ... done
[17:01:03.316] run() for ‘MulticoreFuture’ ... done
[17:01:03.317] Created future:
[17:01:03.318] plan(): Setting new future strategy stack:
[17:01:03.318] List of future strategies:
[17:01:03.318] 1. sequential:
[17:01:03.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.318]    - tweaked: FALSE
[17:01:03.318]    - call: NULL
[17:01:03.320] plan(): nbrOfWorkers() = 1
[17:01:03.323] plan(): Setting new future strategy stack:
[17:01:03.323] List of future strategies:
[17:01:03.323] 1. multicore:
[17:01:03.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.323]    - tweaked: FALSE
[17:01:03.323]    - call: plan(strategy)
[17:01:03.330] plan(): nbrOfWorkers() = 2
[17:01:03.317] MulticoreFuture:
[17:01:03.317] Label: ‘future_vapply-1’
[17:01:03.317] Expression:
[17:01:03.317] {
[17:01:03.317]     do.call(function(...) {
[17:01:03.317]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.317]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.317]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.317]             on.exit(options(oopts), add = TRUE)
[17:01:03.317]         }
[17:01:03.317]         {
[17:01:03.317]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.317]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.317]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.317]             })
[17:01:03.317]         }
[17:01:03.317]     }, args = future.call.arguments)
[17:01:03.317] }
[17:01:03.317] Lazy evaluation: FALSE
[17:01:03.317] Asynchronous evaluation: TRUE
[17:01:03.317] Local evaluation: TRUE
[17:01:03.317] Environment: R_GlobalEnv
[17:01:03.317] Capture standard output: TRUE
[17:01:03.317] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.317] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.317] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:03.317] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.317] Resolved: TRUE
[17:01:03.317] Value: <not collected>
[17:01:03.317] Conditions captured: <none>
[17:01:03.317] Early signaling: FALSE
[17:01:03.317] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.317] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.331] Chunk #1 of 2 ... DONE
[17:01:03.332] Chunk #2 of 2 ...
[17:01:03.332]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.332] getGlobalsAndPackages() ...
[17:01:03.332] Searching for globals...
[17:01:03.333] 
[17:01:03.333] Searching for globals ... DONE
[17:01:03.333] - globals: [0] <none>
[17:01:03.334] getGlobalsAndPackages() ... DONE
[17:01:03.334]    + additional globals found: [n=0] 
[17:01:03.334]    + additional namespaces needed: [n=0] 
[17:01:03.334]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.334]  - seeds: <none>
[17:01:03.335]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.335] getGlobalsAndPackages() ...
[17:01:03.335] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.335] Resolving globals: FALSE
[17:01:03.335] Tweak future expression to call with '...' arguments ...
[17:01:03.335] {
[17:01:03.335]     do.call(function(...) {
[17:01:03.335]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.335]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.335]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.335]             on.exit(options(oopts), add = TRUE)
[17:01:03.335]         }
[17:01:03.335]         {
[17:01:03.335]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.335]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.335]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.335]             })
[17:01:03.335]         }
[17:01:03.335]     }, args = future.call.arguments)
[17:01:03.335] }
[17:01:03.336] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.337] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.337] - packages: [2] ‘stats’, ‘future.apply’
[17:01:03.337] getGlobalsAndPackages() ... DONE
[17:01:03.338] run() for ‘Future’ ...
[17:01:03.338] - state: ‘created’
[17:01:03.338] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.343] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.343]   - Field: ‘label’
[17:01:03.343]   - Field: ‘local’
[17:01:03.343]   - Field: ‘owner’
[17:01:03.344]   - Field: ‘envir’
[17:01:03.344]   - Field: ‘workers’
[17:01:03.344]   - Field: ‘packages’
[17:01:03.344]   - Field: ‘gc’
[17:01:03.344]   - Field: ‘job’
[17:01:03.344]   - Field: ‘conditions’
[17:01:03.344]   - Field: ‘expr’
[17:01:03.344]   - Field: ‘uuid’
[17:01:03.345]   - Field: ‘seed’
[17:01:03.345]   - Field: ‘version’
[17:01:03.345]   - Field: ‘result’
[17:01:03.345]   - Field: ‘asynchronous’
[17:01:03.345]   - Field: ‘calls’
[17:01:03.345]   - Field: ‘globals’
[17:01:03.345]   - Field: ‘stdout’
[17:01:03.345]   - Field: ‘earlySignal’
[17:01:03.345]   - Field: ‘lazy’
[17:01:03.346]   - Field: ‘state’
[17:01:03.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.346] - Launch lazy future ...
[17:01:03.346] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:03.346] Packages needed by future strategies (n = 0): <none>
[17:01:03.347] {
[17:01:03.347]     {
[17:01:03.347]         {
[17:01:03.347]             ...future.startTime <- base::Sys.time()
[17:01:03.347]             {
[17:01:03.347]                 {
[17:01:03.347]                   {
[17:01:03.347]                     {
[17:01:03.347]                       {
[17:01:03.347]                         base::local({
[17:01:03.347]                           has_future <- base::requireNamespace("future", 
[17:01:03.347]                             quietly = TRUE)
[17:01:03.347]                           if (has_future) {
[17:01:03.347]                             ns <- base::getNamespace("future")
[17:01:03.347]                             version <- ns[[".package"]][["version"]]
[17:01:03.347]                             if (is.null(version)) 
[17:01:03.347]                               version <- utils::packageVersion("future")
[17:01:03.347]                           }
[17:01:03.347]                           else {
[17:01:03.347]                             version <- NULL
[17:01:03.347]                           }
[17:01:03.347]                           if (!has_future || version < "1.8.0") {
[17:01:03.347]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.347]                               "", base::R.version$version.string), 
[17:01:03.347]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.347]                                 base::R.version$platform, 8 * 
[17:01:03.347]                                   base::.Machine$sizeof.pointer), 
[17:01:03.347]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.347]                                 "release", "version")], collapse = " "), 
[17:01:03.347]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.347]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.347]                               info)
[17:01:03.347]                             info <- base::paste(info, collapse = "; ")
[17:01:03.347]                             if (!has_future) {
[17:01:03.347]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.347]                                 info)
[17:01:03.347]                             }
[17:01:03.347]                             else {
[17:01:03.347]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.347]                                 info, version)
[17:01:03.347]                             }
[17:01:03.347]                             base::stop(msg)
[17:01:03.347]                           }
[17:01:03.347]                         })
[17:01:03.347]                       }
[17:01:03.347]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.347]                       base::options(mc.cores = 1L)
[17:01:03.347]                     }
[17:01:03.347]                     base::local({
[17:01:03.347]                       for (pkg in c("stats", "future.apply")) {
[17:01:03.347]                         base::loadNamespace(pkg)
[17:01:03.347]                         base::library(pkg, character.only = TRUE)
[17:01:03.347]                       }
[17:01:03.347]                     })
[17:01:03.347]                   }
[17:01:03.347]                   ...future.strategy.old <- future::plan("list")
[17:01:03.347]                   options(future.plan = NULL)
[17:01:03.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.347]                 }
[17:01:03.347]                 ...future.workdir <- getwd()
[17:01:03.347]             }
[17:01:03.347]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.347]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.347]         }
[17:01:03.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.347]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.347]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.347]             base::names(...future.oldOptions))
[17:01:03.347]     }
[17:01:03.347]     if (FALSE) {
[17:01:03.347]     }
[17:01:03.347]     else {
[17:01:03.347]         if (TRUE) {
[17:01:03.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.347]                 open = "w")
[17:01:03.347]         }
[17:01:03.347]         else {
[17:01:03.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.347]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.347]         }
[17:01:03.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.347]             base::sink(type = "output", split = FALSE)
[17:01:03.347]             base::close(...future.stdout)
[17:01:03.347]         }, add = TRUE)
[17:01:03.347]     }
[17:01:03.347]     ...future.frame <- base::sys.nframe()
[17:01:03.347]     ...future.conditions <- base::list()
[17:01:03.347]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.347]     if (FALSE) {
[17:01:03.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.347]     }
[17:01:03.347]     ...future.result <- base::tryCatch({
[17:01:03.347]         base::withCallingHandlers({
[17:01:03.347]             ...future.value <- base::withVisible(base::local({
[17:01:03.347]                 withCallingHandlers({
[17:01:03.347]                   {
[17:01:03.347]                     do.call(function(...) {
[17:01:03.347]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.347]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.347]                         ...future.globals.maxSize)) {
[17:01:03.347]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.347]                         on.exit(options(oopts), add = TRUE)
[17:01:03.347]                       }
[17:01:03.347]                       {
[17:01:03.347]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.347]                           FUN = function(jj) {
[17:01:03.347]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.347]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.347]                           })
[17:01:03.347]                       }
[17:01:03.347]                     }, args = future.call.arguments)
[17:01:03.347]                   }
[17:01:03.347]                 }, immediateCondition = function(cond) {
[17:01:03.347]                   save_rds <- function (object, pathname, ...) 
[17:01:03.347]                   {
[17:01:03.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.347]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.347]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.347]                         fi_tmp[["mtime"]])
[17:01:03.347]                     }
[17:01:03.347]                     tryCatch({
[17:01:03.347]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.347]                     }, error = function(ex) {
[17:01:03.347]                       msg <- conditionMessage(ex)
[17:01:03.347]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.347]                         fi_tmp[["mtime"]], msg)
[17:01:03.347]                       ex$message <- msg
[17:01:03.347]                       stop(ex)
[17:01:03.347]                     })
[17:01:03.347]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.347]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.347]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.347]                       fi <- file.info(pathname)
[17:01:03.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.347]                         fi[["size"]], fi[["mtime"]])
[17:01:03.347]                       stop(msg)
[17:01:03.347]                     }
[17:01:03.347]                     invisible(pathname)
[17:01:03.347]                   }
[17:01:03.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.347]                     rootPath = tempdir()) 
[17:01:03.347]                   {
[17:01:03.347]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.347]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.347]                       tmpdir = path, fileext = ".rds")
[17:01:03.347]                     save_rds(obj, file)
[17:01:03.347]                   }
[17:01:03.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.347]                   {
[17:01:03.347]                     inherits <- base::inherits
[17:01:03.347]                     invokeRestart <- base::invokeRestart
[17:01:03.347]                     is.null <- base::is.null
[17:01:03.347]                     muffled <- FALSE
[17:01:03.347]                     if (inherits(cond, "message")) {
[17:01:03.347]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.347]                       if (muffled) 
[17:01:03.347]                         invokeRestart("muffleMessage")
[17:01:03.347]                     }
[17:01:03.347]                     else if (inherits(cond, "warning")) {
[17:01:03.347]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.347]                       if (muffled) 
[17:01:03.347]                         invokeRestart("muffleWarning")
[17:01:03.347]                     }
[17:01:03.347]                     else if (inherits(cond, "condition")) {
[17:01:03.347]                       if (!is.null(pattern)) {
[17:01:03.347]                         computeRestarts <- base::computeRestarts
[17:01:03.347]                         grepl <- base::grepl
[17:01:03.347]                         restarts <- computeRestarts(cond)
[17:01:03.347]                         for (restart in restarts) {
[17:01:03.347]                           name <- restart$name
[17:01:03.347]                           if (is.null(name)) 
[17:01:03.347]                             next
[17:01:03.347]                           if (!grepl(pattern, name)) 
[17:01:03.347]                             next
[17:01:03.347]                           invokeRestart(restart)
[17:01:03.347]                           muffled <- TRUE
[17:01:03.347]                           break
[17:01:03.347]                         }
[17:01:03.347]                       }
[17:01:03.347]                     }
[17:01:03.347]                     invisible(muffled)
[17:01:03.347]                   }
[17:01:03.347]                   muffleCondition(cond)
[17:01:03.347]                 })
[17:01:03.347]             }))
[17:01:03.347]             future::FutureResult(value = ...future.value$value, 
[17:01:03.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.347]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.347]                     ...future.globalenv.names))
[17:01:03.347]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.347]         }, condition = base::local({
[17:01:03.347]             c <- base::c
[17:01:03.347]             inherits <- base::inherits
[17:01:03.347]             invokeRestart <- base::invokeRestart
[17:01:03.347]             length <- base::length
[17:01:03.347]             list <- base::list
[17:01:03.347]             seq.int <- base::seq.int
[17:01:03.347]             signalCondition <- base::signalCondition
[17:01:03.347]             sys.calls <- base::sys.calls
[17:01:03.347]             `[[` <- base::`[[`
[17:01:03.347]             `+` <- base::`+`
[17:01:03.347]             `<<-` <- base::`<<-`
[17:01:03.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.347]                   3L)]
[17:01:03.347]             }
[17:01:03.347]             function(cond) {
[17:01:03.347]                 is_error <- inherits(cond, "error")
[17:01:03.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.347]                   NULL)
[17:01:03.347]                 if (is_error) {
[17:01:03.347]                   sessionInformation <- function() {
[17:01:03.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.347]                       search = base::search(), system = base::Sys.info())
[17:01:03.347]                   }
[17:01:03.347]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.347]                     cond$call), session = sessionInformation(), 
[17:01:03.347]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.347]                   signalCondition(cond)
[17:01:03.347]                 }
[17:01:03.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.347]                 "immediateCondition"))) {
[17:01:03.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.347]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.347]                   if (TRUE && !signal) {
[17:01:03.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.347]                     {
[17:01:03.347]                       inherits <- base::inherits
[17:01:03.347]                       invokeRestart <- base::invokeRestart
[17:01:03.347]                       is.null <- base::is.null
[17:01:03.347]                       muffled <- FALSE
[17:01:03.347]                       if (inherits(cond, "message")) {
[17:01:03.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.347]                         if (muffled) 
[17:01:03.347]                           invokeRestart("muffleMessage")
[17:01:03.347]                       }
[17:01:03.347]                       else if (inherits(cond, "warning")) {
[17:01:03.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.347]                         if (muffled) 
[17:01:03.347]                           invokeRestart("muffleWarning")
[17:01:03.347]                       }
[17:01:03.347]                       else if (inherits(cond, "condition")) {
[17:01:03.347]                         if (!is.null(pattern)) {
[17:01:03.347]                           computeRestarts <- base::computeRestarts
[17:01:03.347]                           grepl <- base::grepl
[17:01:03.347]                           restarts <- computeRestarts(cond)
[17:01:03.347]                           for (restart in restarts) {
[17:01:03.347]                             name <- restart$name
[17:01:03.347]                             if (is.null(name)) 
[17:01:03.347]                               next
[17:01:03.347]                             if (!grepl(pattern, name)) 
[17:01:03.347]                               next
[17:01:03.347]                             invokeRestart(restart)
[17:01:03.347]                             muffled <- TRUE
[17:01:03.347]                             break
[17:01:03.347]                           }
[17:01:03.347]                         }
[17:01:03.347]                       }
[17:01:03.347]                       invisible(muffled)
[17:01:03.347]                     }
[17:01:03.347]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.347]                   }
[17:01:03.347]                 }
[17:01:03.347]                 else {
[17:01:03.347]                   if (TRUE) {
[17:01:03.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.347]                     {
[17:01:03.347]                       inherits <- base::inherits
[17:01:03.347]                       invokeRestart <- base::invokeRestart
[17:01:03.347]                       is.null <- base::is.null
[17:01:03.347]                       muffled <- FALSE
[17:01:03.347]                       if (inherits(cond, "message")) {
[17:01:03.347]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.347]                         if (muffled) 
[17:01:03.347]                           invokeRestart("muffleMessage")
[17:01:03.347]                       }
[17:01:03.347]                       else if (inherits(cond, "warning")) {
[17:01:03.347]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.347]                         if (muffled) 
[17:01:03.347]                           invokeRestart("muffleWarning")
[17:01:03.347]                       }
[17:01:03.347]                       else if (inherits(cond, "condition")) {
[17:01:03.347]                         if (!is.null(pattern)) {
[17:01:03.347]                           computeRestarts <- base::computeRestarts
[17:01:03.347]                           grepl <- base::grepl
[17:01:03.347]                           restarts <- computeRestarts(cond)
[17:01:03.347]                           for (restart in restarts) {
[17:01:03.347]                             name <- restart$name
[17:01:03.347]                             if (is.null(name)) 
[17:01:03.347]                               next
[17:01:03.347]                             if (!grepl(pattern, name)) 
[17:01:03.347]                               next
[17:01:03.347]                             invokeRestart(restart)
[17:01:03.347]                             muffled <- TRUE
[17:01:03.347]                             break
[17:01:03.347]                           }
[17:01:03.347]                         }
[17:01:03.347]                       }
[17:01:03.347]                       invisible(muffled)
[17:01:03.347]                     }
[17:01:03.347]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.347]                   }
[17:01:03.347]                 }
[17:01:03.347]             }
[17:01:03.347]         }))
[17:01:03.347]     }, error = function(ex) {
[17:01:03.347]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.347]                 ...future.rng), started = ...future.startTime, 
[17:01:03.347]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.347]             version = "1.8"), class = "FutureResult")
[17:01:03.347]     }, finally = {
[17:01:03.347]         if (!identical(...future.workdir, getwd())) 
[17:01:03.347]             setwd(...future.workdir)
[17:01:03.347]         {
[17:01:03.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.347]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.347]             }
[17:01:03.347]             base::options(...future.oldOptions)
[17:01:03.347]             if (.Platform$OS.type == "windows") {
[17:01:03.347]                 old_names <- names(...future.oldEnvVars)
[17:01:03.347]                 envs <- base::Sys.getenv()
[17:01:03.347]                 names <- names(envs)
[17:01:03.347]                 common <- intersect(names, old_names)
[17:01:03.347]                 added <- setdiff(names, old_names)
[17:01:03.347]                 removed <- setdiff(old_names, names)
[17:01:03.347]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.347]                   envs[common]]
[17:01:03.347]                 NAMES <- toupper(changed)
[17:01:03.347]                 args <- list()
[17:01:03.347]                 for (kk in seq_along(NAMES)) {
[17:01:03.347]                   name <- changed[[kk]]
[17:01:03.347]                   NAME <- NAMES[[kk]]
[17:01:03.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.347]                     next
[17:01:03.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.347]                 }
[17:01:03.347]                 NAMES <- toupper(added)
[17:01:03.347]                 for (kk in seq_along(NAMES)) {
[17:01:03.347]                   name <- added[[kk]]
[17:01:03.347]                   NAME <- NAMES[[kk]]
[17:01:03.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.347]                     next
[17:01:03.347]                   args[[name]] <- ""
[17:01:03.347]                 }
[17:01:03.347]                 NAMES <- toupper(removed)
[17:01:03.347]                 for (kk in seq_along(NAMES)) {
[17:01:03.347]                   name <- removed[[kk]]
[17:01:03.347]                   NAME <- NAMES[[kk]]
[17:01:03.347]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.347]                     next
[17:01:03.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.347]                 }
[17:01:03.347]                 if (length(args) > 0) 
[17:01:03.347]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.347]             }
[17:01:03.347]             else {
[17:01:03.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.347]             }
[17:01:03.347]             {
[17:01:03.347]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.347]                   0L) {
[17:01:03.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.347]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.347]                   base::options(opts)
[17:01:03.347]                 }
[17:01:03.347]                 {
[17:01:03.347]                   {
[17:01:03.347]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.347]                     NULL
[17:01:03.347]                   }
[17:01:03.347]                   options(future.plan = NULL)
[17:01:03.347]                   if (is.na(NA_character_)) 
[17:01:03.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.347]                     .init = FALSE)
[17:01:03.347]                 }
[17:01:03.347]             }
[17:01:03.347]         }
[17:01:03.347]     })
[17:01:03.347]     if (TRUE) {
[17:01:03.347]         base::sink(type = "output", split = FALSE)
[17:01:03.347]         if (TRUE) {
[17:01:03.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.347]         }
[17:01:03.347]         else {
[17:01:03.347]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.347]         }
[17:01:03.347]         base::close(...future.stdout)
[17:01:03.347]         ...future.stdout <- NULL
[17:01:03.347]     }
[17:01:03.347]     ...future.result$conditions <- ...future.conditions
[17:01:03.347]     ...future.result$finished <- base::Sys.time()
[17:01:03.347]     ...future.result
[17:01:03.347] }
[17:01:03.351] assign_globals() ...
[17:01:03.351] List of 11
[17:01:03.351]  $ ...future.FUN            :function (x, ...)  
[17:01:03.351]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:01:03.351]  $ times                    : int 5
[17:01:03.351]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.351]  $ stop_if_not              :function (...)  
[17:01:03.351]  $ dim                      : NULL
[17:01:03.351]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.351]  $ future.call.arguments    : list()
[17:01:03.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.351]  $ ...future.elements_ii    :List of 3
[17:01:03.351]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:01:03.351]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:01:03.351]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:01:03.351]  $ ...future.seeds_ii       : NULL
[17:01:03.351]  $ ...future.globals.maxSize: NULL
[17:01:03.351]  - attr(*, "where")=List of 11
[17:01:03.351]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.351]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.351]  - attr(*, "resolved")= logi FALSE
[17:01:03.351]  - attr(*, "total_size")= num 141240
[17:01:03.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.351]  - attr(*, "already-done")= logi TRUE
[17:01:03.364] - copied ‘...future.FUN’ to environment
[17:01:03.364] - copied ‘x_FUN’ to environment
[17:01:03.364] - copied ‘times’ to environment
[17:01:03.364] - copied ‘stopf’ to environment
[17:01:03.364] - copied ‘stop_if_not’ to environment
[17:01:03.364] - copied ‘dim’ to environment
[17:01:03.365] - copied ‘valid_types’ to environment
[17:01:03.365] - copied ‘future.call.arguments’ to environment
[17:01:03.365] - copied ‘...future.elements_ii’ to environment
[17:01:03.365] - copied ‘...future.seeds_ii’ to environment
[17:01:03.365] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.365] assign_globals() ... done
[17:01:03.365] requestCore(): workers = 2
[17:01:03.368] MulticoreFuture started
[17:01:03.368] - Launch lazy future ... done
[17:01:03.369] run() for ‘MulticoreFuture’ ... done
[17:01:03.369] Created future:
[17:01:03.370] plan(): Setting new future strategy stack:
[17:01:03.371] List of future strategies:
[17:01:03.371] 1. sequential:
[17:01:03.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.371]    - tweaked: FALSE
[17:01:03.371]    - call: NULL
[17:01:03.373] plan(): nbrOfWorkers() = 1
[17:01:03.375] plan(): Setting new future strategy stack:
[17:01:03.375] List of future strategies:
[17:01:03.375] 1. multicore:
[17:01:03.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.375]    - tweaked: FALSE
[17:01:03.375]    - call: plan(strategy)
[17:01:03.381] plan(): nbrOfWorkers() = 2
[17:01:03.370] MulticoreFuture:
[17:01:03.370] Label: ‘future_vapply-2’
[17:01:03.370] Expression:
[17:01:03.370] {
[17:01:03.370]     do.call(function(...) {
[17:01:03.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.370]             on.exit(options(oopts), add = TRUE)
[17:01:03.370]         }
[17:01:03.370]         {
[17:01:03.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.370]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.370]             })
[17:01:03.370]         }
[17:01:03.370]     }, args = future.call.arguments)
[17:01:03.370] }
[17:01:03.370] Lazy evaluation: FALSE
[17:01:03.370] Asynchronous evaluation: TRUE
[17:01:03.370] Local evaluation: TRUE
[17:01:03.370] Environment: R_GlobalEnv
[17:01:03.370] Capture standard output: TRUE
[17:01:03.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.370] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.370] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:03.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.370] Resolved: TRUE
[17:01:03.370] Value: <not collected>
[17:01:03.370] Conditions captured: <none>
[17:01:03.370] Early signaling: FALSE
[17:01:03.370] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.382] Chunk #2 of 2 ... DONE
[17:01:03.382] Launching 2 futures (chunks) ... DONE
[17:01:03.382] Resolving 2 futures (chunks) ...
[17:01:03.383] resolve() on list ...
[17:01:03.383]  recursive: 0
[17:01:03.383]  length: 2
[17:01:03.383] 
[17:01:03.383] Future #1
[17:01:03.384] result() for MulticoreFuture ...
[17:01:03.385] result() for MulticoreFuture ...
[17:01:03.385] result() for MulticoreFuture ... done
[17:01:03.385] result() for MulticoreFuture ... done
[17:01:03.385] result() for MulticoreFuture ...
[17:01:03.385] result() for MulticoreFuture ... done
[17:01:03.386] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.386] - nx: 2
[17:01:03.386] - relay: TRUE
[17:01:03.386] - stdout: TRUE
[17:01:03.386] - signal: TRUE
[17:01:03.386] - resignal: FALSE
[17:01:03.387] - force: TRUE
[17:01:03.387] - relayed: [n=2] FALSE, FALSE
[17:01:03.387] - queued futures: [n=2] FALSE, FALSE
[17:01:03.387]  - until=1
[17:01:03.387]  - relaying element #1
[17:01:03.388] result() for MulticoreFuture ...
[17:01:03.388] result() for MulticoreFuture ... done
[17:01:03.388] result() for MulticoreFuture ...
[17:01:03.388] result() for MulticoreFuture ... done
[17:01:03.388] result() for MulticoreFuture ...
[17:01:03.389] result() for MulticoreFuture ... done
[17:01:03.389] result() for MulticoreFuture ...
[17:01:03.389] result() for MulticoreFuture ... done
[17:01:03.389] - relayed: [n=2] TRUE, FALSE
[17:01:03.389] - queued futures: [n=2] TRUE, FALSE
[17:01:03.390] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.390]  length: 1 (resolved future 1)
[17:01:03.390] Future #2
[17:01:03.390] result() for MulticoreFuture ...
[17:01:03.391] result() for MulticoreFuture ...
[17:01:03.391] result() for MulticoreFuture ... done
[17:01:03.391] result() for MulticoreFuture ... done
[17:01:03.391] result() for MulticoreFuture ...
[17:01:03.392] result() for MulticoreFuture ... done
[17:01:03.392] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.392] - nx: 2
[17:01:03.392] - relay: TRUE
[17:01:03.392] - stdout: TRUE
[17:01:03.393] - signal: TRUE
[17:01:03.393] - resignal: FALSE
[17:01:03.393] - force: TRUE
[17:01:03.393] - relayed: [n=2] TRUE, FALSE
[17:01:03.393] - queued futures: [n=2] TRUE, FALSE
[17:01:03.393]  - until=2
[17:01:03.393]  - relaying element #2
[17:01:03.394] result() for MulticoreFuture ...
[17:01:03.394] result() for MulticoreFuture ... done
[17:01:03.394] result() for MulticoreFuture ...
[17:01:03.394] result() for MulticoreFuture ... done
[17:01:03.394] result() for MulticoreFuture ...
[17:01:03.394] result() for MulticoreFuture ... done
[17:01:03.395] result() for MulticoreFuture ...
[17:01:03.395] result() for MulticoreFuture ... done
[17:01:03.395] - relayed: [n=2] TRUE, TRUE
[17:01:03.395] - queued futures: [n=2] TRUE, TRUE
[17:01:03.395] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.395]  length: 0 (resolved future 2)
[17:01:03.395] Relaying remaining futures
[17:01:03.395] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.396] - nx: 2
[17:01:03.396] - relay: TRUE
[17:01:03.396] - stdout: TRUE
[17:01:03.396] - signal: TRUE
[17:01:03.396] - resignal: FALSE
[17:01:03.396] - force: TRUE
[17:01:03.396] - relayed: [n=2] TRUE, TRUE
[17:01:03.396] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.396] - relayed: [n=2] TRUE, TRUE
[17:01:03.396] - queued futures: [n=2] TRUE, TRUE
[17:01:03.397] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.397] resolve() on list ... DONE
[17:01:03.397] result() for MulticoreFuture ...
[17:01:03.397] result() for MulticoreFuture ... done
[17:01:03.397] result() for MulticoreFuture ...
[17:01:03.397] result() for MulticoreFuture ... done
[17:01:03.397] result() for MulticoreFuture ...
[17:01:03.397] result() for MulticoreFuture ... done
[17:01:03.397] result() for MulticoreFuture ...
[17:01:03.398] result() for MulticoreFuture ... done
[17:01:03.398]  - Number of value chunks collected: 2
[17:01:03.398] Resolving 2 futures (chunks) ... DONE
[17:01:03.398] Reducing values from 2 chunks ...
[17:01:03.398]  - Number of values collected after concatenation: 7
[17:01:03.398]  - Number of values expected: 7
[17:01:03.398] Reducing values from 2 chunks ... DONE
[17:01:03.398] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:01:03.400] future_lapply() ...
[17:01:03.405] Number of chunks: 2
[17:01:03.405] getGlobalsAndPackagesXApply() ...
[17:01:03.405]  - future.globals: TRUE
[17:01:03.406] getGlobalsAndPackages() ...
[17:01:03.406] Searching for globals...
[17:01:03.410] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:01:03.410] Searching for globals ... DONE
[17:01:03.410] Resolving globals: FALSE
[17:01:03.410] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:01:03.411] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:01:03.411] - globals: [1] ‘FUN’
[17:01:03.411] 
[17:01:03.411] getGlobalsAndPackages() ... DONE
[17:01:03.412]  - globals found/used: [n=1] ‘FUN’
[17:01:03.412]  - needed namespaces: [n=0] 
[17:01:03.412] Finding globals ... DONE
[17:01:03.412]  - use_args: TRUE
[17:01:03.412]  - Getting '...' globals ...
[17:01:03.412] resolve() on list ...
[17:01:03.413]  recursive: 0
[17:01:03.413]  length: 1
[17:01:03.413]  elements: ‘...’
[17:01:03.413]  length: 0 (resolved future 1)
[17:01:03.413] resolve() on list ... DONE
[17:01:03.413]    - '...' content: [n=1] ‘y’
[17:01:03.413] List of 1
[17:01:03.413]  $ ...:List of 1
[17:01:03.413]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.413]  - attr(*, "where")=List of 1
[17:01:03.413]   ..$ ...:<environment: 0x55aadb410728> 
[17:01:03.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.413]  - attr(*, "resolved")= logi TRUE
[17:01:03.413]  - attr(*, "total_size")= num NA
[17:01:03.417]  - Getting '...' globals ... DONE
[17:01:03.417] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:03.417] List of 2
[17:01:03.417]  $ ...future.FUN:function (x, y)  
[17:01:03.417]  $ ...          :List of 1
[17:01:03.417]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.417]  - attr(*, "where")=List of 2
[17:01:03.417]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.417]   ..$ ...          :<environment: 0x55aadb410728> 
[17:01:03.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.417]  - attr(*, "resolved")= logi FALSE
[17:01:03.417]  - attr(*, "total_size")= num 4264
[17:01:03.420] Packages to be attached in all futures: [n=0] 
[17:01:03.420] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.421] Number of futures (= number of chunks): 2
[17:01:03.421] Launching 2 futures (chunks) ...
[17:01:03.421] Chunk #1 of 2 ...
[17:01:03.421]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.421] getGlobalsAndPackages() ...
[17:01:03.421] Searching for globals...
[17:01:03.421] 
[17:01:03.422] Searching for globals ... DONE
[17:01:03.422] - globals: [0] <none>
[17:01:03.422] getGlobalsAndPackages() ... DONE
[17:01:03.422]    + additional globals found: [n=0] 
[17:01:03.422]    + additional namespaces needed: [n=0] 
[17:01:03.422]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.422]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.422]  - seeds: <none>
[17:01:03.422]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.422] getGlobalsAndPackages() ...
[17:01:03.423] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.423] Resolving globals: FALSE
[17:01:03.423] Tweak future expression to call with '...' arguments ...
[17:01:03.423] {
[17:01:03.423]     do.call(function(...) {
[17:01:03.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.423]             on.exit(options(oopts), add = TRUE)
[17:01:03.423]         }
[17:01:03.423]         {
[17:01:03.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.423]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.423]             })
[17:01:03.423]         }
[17:01:03.423]     }, args = future.call.arguments)
[17:01:03.423] }
[17:01:03.423] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.424] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.424] 
[17:01:03.424] getGlobalsAndPackages() ... DONE
[17:01:03.424] run() for ‘Future’ ...
[17:01:03.424] - state: ‘created’
[17:01:03.424] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.428] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.429]   - Field: ‘label’
[17:01:03.429]   - Field: ‘local’
[17:01:03.429]   - Field: ‘owner’
[17:01:03.429]   - Field: ‘envir’
[17:01:03.429]   - Field: ‘workers’
[17:01:03.429]   - Field: ‘packages’
[17:01:03.429]   - Field: ‘gc’
[17:01:03.429]   - Field: ‘job’
[17:01:03.429]   - Field: ‘conditions’
[17:01:03.430]   - Field: ‘expr’
[17:01:03.430]   - Field: ‘uuid’
[17:01:03.430]   - Field: ‘seed’
[17:01:03.430]   - Field: ‘version’
[17:01:03.430]   - Field: ‘result’
[17:01:03.430]   - Field: ‘asynchronous’
[17:01:03.430]   - Field: ‘calls’
[17:01:03.430]   - Field: ‘globals’
[17:01:03.430]   - Field: ‘stdout’
[17:01:03.430]   - Field: ‘earlySignal’
[17:01:03.430]   - Field: ‘lazy’
[17:01:03.431]   - Field: ‘state’
[17:01:03.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.431] - Launch lazy future ...
[17:01:03.431] Packages needed by the future expression (n = 0): <none>
[17:01:03.431] Packages needed by future strategies (n = 0): <none>
[17:01:03.432] {
[17:01:03.432]     {
[17:01:03.432]         {
[17:01:03.432]             ...future.startTime <- base::Sys.time()
[17:01:03.432]             {
[17:01:03.432]                 {
[17:01:03.432]                   {
[17:01:03.432]                     {
[17:01:03.432]                       base::local({
[17:01:03.432]                         has_future <- base::requireNamespace("future", 
[17:01:03.432]                           quietly = TRUE)
[17:01:03.432]                         if (has_future) {
[17:01:03.432]                           ns <- base::getNamespace("future")
[17:01:03.432]                           version <- ns[[".package"]][["version"]]
[17:01:03.432]                           if (is.null(version)) 
[17:01:03.432]                             version <- utils::packageVersion("future")
[17:01:03.432]                         }
[17:01:03.432]                         else {
[17:01:03.432]                           version <- NULL
[17:01:03.432]                         }
[17:01:03.432]                         if (!has_future || version < "1.8.0") {
[17:01:03.432]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.432]                             "", base::R.version$version.string), 
[17:01:03.432]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:03.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:03.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.432]                               "release", "version")], collapse = " "), 
[17:01:03.432]                             hostname = base::Sys.info()[["nodename"]])
[17:01:03.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.432]                             info)
[17:01:03.432]                           info <- base::paste(info, collapse = "; ")
[17:01:03.432]                           if (!has_future) {
[17:01:03.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.432]                               info)
[17:01:03.432]                           }
[17:01:03.432]                           else {
[17:01:03.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.432]                               info, version)
[17:01:03.432]                           }
[17:01:03.432]                           base::stop(msg)
[17:01:03.432]                         }
[17:01:03.432]                       })
[17:01:03.432]                     }
[17:01:03.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.432]                     base::options(mc.cores = 1L)
[17:01:03.432]                   }
[17:01:03.432]                   ...future.strategy.old <- future::plan("list")
[17:01:03.432]                   options(future.plan = NULL)
[17:01:03.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.432]                 }
[17:01:03.432]                 ...future.workdir <- getwd()
[17:01:03.432]             }
[17:01:03.432]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.432]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.432]         }
[17:01:03.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.432]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.432]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.432]             base::names(...future.oldOptions))
[17:01:03.432]     }
[17:01:03.432]     if (FALSE) {
[17:01:03.432]     }
[17:01:03.432]     else {
[17:01:03.432]         if (TRUE) {
[17:01:03.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.432]                 open = "w")
[17:01:03.432]         }
[17:01:03.432]         else {
[17:01:03.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.432]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.432]         }
[17:01:03.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.432]             base::sink(type = "output", split = FALSE)
[17:01:03.432]             base::close(...future.stdout)
[17:01:03.432]         }, add = TRUE)
[17:01:03.432]     }
[17:01:03.432]     ...future.frame <- base::sys.nframe()
[17:01:03.432]     ...future.conditions <- base::list()
[17:01:03.432]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.432]     if (FALSE) {
[17:01:03.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.432]     }
[17:01:03.432]     ...future.result <- base::tryCatch({
[17:01:03.432]         base::withCallingHandlers({
[17:01:03.432]             ...future.value <- base::withVisible(base::local({
[17:01:03.432]                 withCallingHandlers({
[17:01:03.432]                   {
[17:01:03.432]                     do.call(function(...) {
[17:01:03.432]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.432]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.432]                         ...future.globals.maxSize)) {
[17:01:03.432]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.432]                         on.exit(options(oopts), add = TRUE)
[17:01:03.432]                       }
[17:01:03.432]                       {
[17:01:03.432]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.432]                           FUN = function(jj) {
[17:01:03.432]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.432]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.432]                           })
[17:01:03.432]                       }
[17:01:03.432]                     }, args = future.call.arguments)
[17:01:03.432]                   }
[17:01:03.432]                 }, immediateCondition = function(cond) {
[17:01:03.432]                   save_rds <- function (object, pathname, ...) 
[17:01:03.432]                   {
[17:01:03.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.432]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.432]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.432]                         fi_tmp[["mtime"]])
[17:01:03.432]                     }
[17:01:03.432]                     tryCatch({
[17:01:03.432]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.432]                     }, error = function(ex) {
[17:01:03.432]                       msg <- conditionMessage(ex)
[17:01:03.432]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.432]                         fi_tmp[["mtime"]], msg)
[17:01:03.432]                       ex$message <- msg
[17:01:03.432]                       stop(ex)
[17:01:03.432]                     })
[17:01:03.432]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.432]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.432]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.432]                       fi <- file.info(pathname)
[17:01:03.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.432]                         fi[["size"]], fi[["mtime"]])
[17:01:03.432]                       stop(msg)
[17:01:03.432]                     }
[17:01:03.432]                     invisible(pathname)
[17:01:03.432]                   }
[17:01:03.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.432]                     rootPath = tempdir()) 
[17:01:03.432]                   {
[17:01:03.432]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.432]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.432]                       tmpdir = path, fileext = ".rds")
[17:01:03.432]                     save_rds(obj, file)
[17:01:03.432]                   }
[17:01:03.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.432]                   {
[17:01:03.432]                     inherits <- base::inherits
[17:01:03.432]                     invokeRestart <- base::invokeRestart
[17:01:03.432]                     is.null <- base::is.null
[17:01:03.432]                     muffled <- FALSE
[17:01:03.432]                     if (inherits(cond, "message")) {
[17:01:03.432]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.432]                       if (muffled) 
[17:01:03.432]                         invokeRestart("muffleMessage")
[17:01:03.432]                     }
[17:01:03.432]                     else if (inherits(cond, "warning")) {
[17:01:03.432]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.432]                       if (muffled) 
[17:01:03.432]                         invokeRestart("muffleWarning")
[17:01:03.432]                     }
[17:01:03.432]                     else if (inherits(cond, "condition")) {
[17:01:03.432]                       if (!is.null(pattern)) {
[17:01:03.432]                         computeRestarts <- base::computeRestarts
[17:01:03.432]                         grepl <- base::grepl
[17:01:03.432]                         restarts <- computeRestarts(cond)
[17:01:03.432]                         for (restart in restarts) {
[17:01:03.432]                           name <- restart$name
[17:01:03.432]                           if (is.null(name)) 
[17:01:03.432]                             next
[17:01:03.432]                           if (!grepl(pattern, name)) 
[17:01:03.432]                             next
[17:01:03.432]                           invokeRestart(restart)
[17:01:03.432]                           muffled <- TRUE
[17:01:03.432]                           break
[17:01:03.432]                         }
[17:01:03.432]                       }
[17:01:03.432]                     }
[17:01:03.432]                     invisible(muffled)
[17:01:03.432]                   }
[17:01:03.432]                   muffleCondition(cond)
[17:01:03.432]                 })
[17:01:03.432]             }))
[17:01:03.432]             future::FutureResult(value = ...future.value$value, 
[17:01:03.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.432]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.432]                     ...future.globalenv.names))
[17:01:03.432]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.432]         }, condition = base::local({
[17:01:03.432]             c <- base::c
[17:01:03.432]             inherits <- base::inherits
[17:01:03.432]             invokeRestart <- base::invokeRestart
[17:01:03.432]             length <- base::length
[17:01:03.432]             list <- base::list
[17:01:03.432]             seq.int <- base::seq.int
[17:01:03.432]             signalCondition <- base::signalCondition
[17:01:03.432]             sys.calls <- base::sys.calls
[17:01:03.432]             `[[` <- base::`[[`
[17:01:03.432]             `+` <- base::`+`
[17:01:03.432]             `<<-` <- base::`<<-`
[17:01:03.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.432]                   3L)]
[17:01:03.432]             }
[17:01:03.432]             function(cond) {
[17:01:03.432]                 is_error <- inherits(cond, "error")
[17:01:03.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.432]                   NULL)
[17:01:03.432]                 if (is_error) {
[17:01:03.432]                   sessionInformation <- function() {
[17:01:03.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.432]                       search = base::search(), system = base::Sys.info())
[17:01:03.432]                   }
[17:01:03.432]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.432]                     cond$call), session = sessionInformation(), 
[17:01:03.432]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.432]                   signalCondition(cond)
[17:01:03.432]                 }
[17:01:03.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.432]                 "immediateCondition"))) {
[17:01:03.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.432]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.432]                   if (TRUE && !signal) {
[17:01:03.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.432]                     {
[17:01:03.432]                       inherits <- base::inherits
[17:01:03.432]                       invokeRestart <- base::invokeRestart
[17:01:03.432]                       is.null <- base::is.null
[17:01:03.432]                       muffled <- FALSE
[17:01:03.432]                       if (inherits(cond, "message")) {
[17:01:03.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.432]                         if (muffled) 
[17:01:03.432]                           invokeRestart("muffleMessage")
[17:01:03.432]                       }
[17:01:03.432]                       else if (inherits(cond, "warning")) {
[17:01:03.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.432]                         if (muffled) 
[17:01:03.432]                           invokeRestart("muffleWarning")
[17:01:03.432]                       }
[17:01:03.432]                       else if (inherits(cond, "condition")) {
[17:01:03.432]                         if (!is.null(pattern)) {
[17:01:03.432]                           computeRestarts <- base::computeRestarts
[17:01:03.432]                           grepl <- base::grepl
[17:01:03.432]                           restarts <- computeRestarts(cond)
[17:01:03.432]                           for (restart in restarts) {
[17:01:03.432]                             name <- restart$name
[17:01:03.432]                             if (is.null(name)) 
[17:01:03.432]                               next
[17:01:03.432]                             if (!grepl(pattern, name)) 
[17:01:03.432]                               next
[17:01:03.432]                             invokeRestart(restart)
[17:01:03.432]                             muffled <- TRUE
[17:01:03.432]                             break
[17:01:03.432]                           }
[17:01:03.432]                         }
[17:01:03.432]                       }
[17:01:03.432]                       invisible(muffled)
[17:01:03.432]                     }
[17:01:03.432]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.432]                   }
[17:01:03.432]                 }
[17:01:03.432]                 else {
[17:01:03.432]                   if (TRUE) {
[17:01:03.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.432]                     {
[17:01:03.432]                       inherits <- base::inherits
[17:01:03.432]                       invokeRestart <- base::invokeRestart
[17:01:03.432]                       is.null <- base::is.null
[17:01:03.432]                       muffled <- FALSE
[17:01:03.432]                       if (inherits(cond, "message")) {
[17:01:03.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.432]                         if (muffled) 
[17:01:03.432]                           invokeRestart("muffleMessage")
[17:01:03.432]                       }
[17:01:03.432]                       else if (inherits(cond, "warning")) {
[17:01:03.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.432]                         if (muffled) 
[17:01:03.432]                           invokeRestart("muffleWarning")
[17:01:03.432]                       }
[17:01:03.432]                       else if (inherits(cond, "condition")) {
[17:01:03.432]                         if (!is.null(pattern)) {
[17:01:03.432]                           computeRestarts <- base::computeRestarts
[17:01:03.432]                           grepl <- base::grepl
[17:01:03.432]                           restarts <- computeRestarts(cond)
[17:01:03.432]                           for (restart in restarts) {
[17:01:03.432]                             name <- restart$name
[17:01:03.432]                             if (is.null(name)) 
[17:01:03.432]                               next
[17:01:03.432]                             if (!grepl(pattern, name)) 
[17:01:03.432]                               next
[17:01:03.432]                             invokeRestart(restart)
[17:01:03.432]                             muffled <- TRUE
[17:01:03.432]                             break
[17:01:03.432]                           }
[17:01:03.432]                         }
[17:01:03.432]                       }
[17:01:03.432]                       invisible(muffled)
[17:01:03.432]                     }
[17:01:03.432]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.432]                   }
[17:01:03.432]                 }
[17:01:03.432]             }
[17:01:03.432]         }))
[17:01:03.432]     }, error = function(ex) {
[17:01:03.432]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.432]                 ...future.rng), started = ...future.startTime, 
[17:01:03.432]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.432]             version = "1.8"), class = "FutureResult")
[17:01:03.432]     }, finally = {
[17:01:03.432]         if (!identical(...future.workdir, getwd())) 
[17:01:03.432]             setwd(...future.workdir)
[17:01:03.432]         {
[17:01:03.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.432]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.432]             }
[17:01:03.432]             base::options(...future.oldOptions)
[17:01:03.432]             if (.Platform$OS.type == "windows") {
[17:01:03.432]                 old_names <- names(...future.oldEnvVars)
[17:01:03.432]                 envs <- base::Sys.getenv()
[17:01:03.432]                 names <- names(envs)
[17:01:03.432]                 common <- intersect(names, old_names)
[17:01:03.432]                 added <- setdiff(names, old_names)
[17:01:03.432]                 removed <- setdiff(old_names, names)
[17:01:03.432]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.432]                   envs[common]]
[17:01:03.432]                 NAMES <- toupper(changed)
[17:01:03.432]                 args <- list()
[17:01:03.432]                 for (kk in seq_along(NAMES)) {
[17:01:03.432]                   name <- changed[[kk]]
[17:01:03.432]                   NAME <- NAMES[[kk]]
[17:01:03.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.432]                     next
[17:01:03.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.432]                 }
[17:01:03.432]                 NAMES <- toupper(added)
[17:01:03.432]                 for (kk in seq_along(NAMES)) {
[17:01:03.432]                   name <- added[[kk]]
[17:01:03.432]                   NAME <- NAMES[[kk]]
[17:01:03.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.432]                     next
[17:01:03.432]                   args[[name]] <- ""
[17:01:03.432]                 }
[17:01:03.432]                 NAMES <- toupper(removed)
[17:01:03.432]                 for (kk in seq_along(NAMES)) {
[17:01:03.432]                   name <- removed[[kk]]
[17:01:03.432]                   NAME <- NAMES[[kk]]
[17:01:03.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.432]                     next
[17:01:03.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.432]                 }
[17:01:03.432]                 if (length(args) > 0) 
[17:01:03.432]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.432]             }
[17:01:03.432]             else {
[17:01:03.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.432]             }
[17:01:03.432]             {
[17:01:03.432]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.432]                   0L) {
[17:01:03.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.432]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.432]                   base::options(opts)
[17:01:03.432]                 }
[17:01:03.432]                 {
[17:01:03.432]                   {
[17:01:03.432]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.432]                     NULL
[17:01:03.432]                   }
[17:01:03.432]                   options(future.plan = NULL)
[17:01:03.432]                   if (is.na(NA_character_)) 
[17:01:03.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.432]                     .init = FALSE)
[17:01:03.432]                 }
[17:01:03.432]             }
[17:01:03.432]         }
[17:01:03.432]     })
[17:01:03.432]     if (TRUE) {
[17:01:03.432]         base::sink(type = "output", split = FALSE)
[17:01:03.432]         if (TRUE) {
[17:01:03.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.432]         }
[17:01:03.432]         else {
[17:01:03.432]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.432]         }
[17:01:03.432]         base::close(...future.stdout)
[17:01:03.432]         ...future.stdout <- NULL
[17:01:03.432]     }
[17:01:03.432]     ...future.result$conditions <- ...future.conditions
[17:01:03.432]     ...future.result$finished <- base::Sys.time()
[17:01:03.432]     ...future.result
[17:01:03.432] }
[17:01:03.434] assign_globals() ...
[17:01:03.434] List of 5
[17:01:03.434]  $ ...future.FUN            :function (x, y)  
[17:01:03.434]  $ future.call.arguments    :List of 1
[17:01:03.434]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.434]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.434]  $ ...future.elements_ii    :List of 2
[17:01:03.434]   ..$ A: num 50
[17:01:03.434]   ..$ B: num 60
[17:01:03.434]  $ ...future.seeds_ii       : NULL
[17:01:03.434]  $ ...future.globals.maxSize: NULL
[17:01:03.434]  - attr(*, "where")=List of 5
[17:01:03.434]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.434]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.434]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.434]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.434]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.434]  - attr(*, "resolved")= logi FALSE
[17:01:03.434]  - attr(*, "total_size")= num 4264
[17:01:03.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.434]  - attr(*, "already-done")= logi TRUE
[17:01:03.443] - reassign environment for ‘...future.FUN’
[17:01:03.444] - copied ‘...future.FUN’ to environment
[17:01:03.444] - copied ‘future.call.arguments’ to environment
[17:01:03.444] - copied ‘...future.elements_ii’ to environment
[17:01:03.444] - copied ‘...future.seeds_ii’ to environment
[17:01:03.444] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.444] assign_globals() ... done
[17:01:03.444] requestCore(): workers = 2
[17:01:03.447] MulticoreFuture started
[17:01:03.447] - Launch lazy future ... done
[17:01:03.447] run() for ‘MulticoreFuture’ ... done
[17:01:03.448] Created future:
[17:01:03.448] plan(): Setting new future strategy stack:
[17:01:03.448] List of future strategies:
[17:01:03.448] 1. sequential:
[17:01:03.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.448]    - tweaked: FALSE
[17:01:03.448]    - call: NULL
[17:01:03.449] plan(): nbrOfWorkers() = 1
[17:01:03.451] plan(): Setting new future strategy stack:
[17:01:03.452] List of future strategies:
[17:01:03.452] 1. multicore:
[17:01:03.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.452]    - tweaked: FALSE
[17:01:03.452]    - call: plan(strategy)
[17:01:03.457] plan(): nbrOfWorkers() = 2
[17:01:03.448] MulticoreFuture:
[17:01:03.448] Label: ‘future_sapply-1’
[17:01:03.448] Expression:
[17:01:03.448] {
[17:01:03.448]     do.call(function(...) {
[17:01:03.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.448]             on.exit(options(oopts), add = TRUE)
[17:01:03.448]         }
[17:01:03.448]         {
[17:01:03.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.448]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.448]             })
[17:01:03.448]         }
[17:01:03.448]     }, args = future.call.arguments)
[17:01:03.448] }
[17:01:03.448] Lazy evaluation: FALSE
[17:01:03.448] Asynchronous evaluation: TRUE
[17:01:03.448] Local evaluation: TRUE
[17:01:03.448] Environment: R_GlobalEnv
[17:01:03.448] Capture standard output: TRUE
[17:01:03.448] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.448] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:03.448] Packages: <none>
[17:01:03.448] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.448] Resolved: TRUE
[17:01:03.448] Value: <not collected>
[17:01:03.448] Conditions captured: <none>
[17:01:03.448] Early signaling: FALSE
[17:01:03.448] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.448] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.458] Chunk #1 of 2 ... DONE
[17:01:03.458] Chunk #2 of 2 ...
[17:01:03.458]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.459] getGlobalsAndPackages() ...
[17:01:03.459] Searching for globals...
[17:01:03.459] 
[17:01:03.459] Searching for globals ... DONE
[17:01:03.459] - globals: [0] <none>
[17:01:03.460] getGlobalsAndPackages() ... DONE
[17:01:03.460]    + additional globals found: [n=0] 
[17:01:03.460]    + additional namespaces needed: [n=0] 
[17:01:03.460]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.460]  - seeds: <none>
[17:01:03.460]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.461] getGlobalsAndPackages() ...
[17:01:03.461] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.461] Resolving globals: FALSE
[17:01:03.461] Tweak future expression to call with '...' arguments ...
[17:01:03.461] {
[17:01:03.461]     do.call(function(...) {
[17:01:03.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.461]             on.exit(options(oopts), add = TRUE)
[17:01:03.461]         }
[17:01:03.461]         {
[17:01:03.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.461]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.461]             })
[17:01:03.461]         }
[17:01:03.461]     }, args = future.call.arguments)
[17:01:03.461] }
[17:01:03.462] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.462] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.463] 
[17:01:03.463] getGlobalsAndPackages() ... DONE
[17:01:03.463] run() for ‘Future’ ...
[17:01:03.464] - state: ‘created’
[17:01:03.464] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.469] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.469]   - Field: ‘label’
[17:01:03.469]   - Field: ‘local’
[17:01:03.470]   - Field: ‘owner’
[17:01:03.470]   - Field: ‘envir’
[17:01:03.470]   - Field: ‘workers’
[17:01:03.470]   - Field: ‘packages’
[17:01:03.470]   - Field: ‘gc’
[17:01:03.470]   - Field: ‘job’
[17:01:03.470]   - Field: ‘conditions’
[17:01:03.471]   - Field: ‘expr’
[17:01:03.471]   - Field: ‘uuid’
[17:01:03.471]   - Field: ‘seed’
[17:01:03.471]   - Field: ‘version’
[17:01:03.471]   - Field: ‘result’
[17:01:03.471]   - Field: ‘asynchronous’
[17:01:03.472]   - Field: ‘calls’
[17:01:03.472]   - Field: ‘globals’
[17:01:03.472]   - Field: ‘stdout’
[17:01:03.472]   - Field: ‘earlySignal’
[17:01:03.472]   - Field: ‘lazy’
[17:01:03.472]   - Field: ‘state’
[17:01:03.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.473] - Launch lazy future ...
[17:01:03.473] Packages needed by the future expression (n = 0): <none>
[17:01:03.473] Packages needed by future strategies (n = 0): <none>
[17:01:03.474] {
[17:01:03.474]     {
[17:01:03.474]         {
[17:01:03.474]             ...future.startTime <- base::Sys.time()
[17:01:03.474]             {
[17:01:03.474]                 {
[17:01:03.474]                   {
[17:01:03.474]                     {
[17:01:03.474]                       base::local({
[17:01:03.474]                         has_future <- base::requireNamespace("future", 
[17:01:03.474]                           quietly = TRUE)
[17:01:03.474]                         if (has_future) {
[17:01:03.474]                           ns <- base::getNamespace("future")
[17:01:03.474]                           version <- ns[[".package"]][["version"]]
[17:01:03.474]                           if (is.null(version)) 
[17:01:03.474]                             version <- utils::packageVersion("future")
[17:01:03.474]                         }
[17:01:03.474]                         else {
[17:01:03.474]                           version <- NULL
[17:01:03.474]                         }
[17:01:03.474]                         if (!has_future || version < "1.8.0") {
[17:01:03.474]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.474]                             "", base::R.version$version.string), 
[17:01:03.474]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:03.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:03.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.474]                               "release", "version")], collapse = " "), 
[17:01:03.474]                             hostname = base::Sys.info()[["nodename"]])
[17:01:03.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.474]                             info)
[17:01:03.474]                           info <- base::paste(info, collapse = "; ")
[17:01:03.474]                           if (!has_future) {
[17:01:03.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.474]                               info)
[17:01:03.474]                           }
[17:01:03.474]                           else {
[17:01:03.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.474]                               info, version)
[17:01:03.474]                           }
[17:01:03.474]                           base::stop(msg)
[17:01:03.474]                         }
[17:01:03.474]                       })
[17:01:03.474]                     }
[17:01:03.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.474]                     base::options(mc.cores = 1L)
[17:01:03.474]                   }
[17:01:03.474]                   ...future.strategy.old <- future::plan("list")
[17:01:03.474]                   options(future.plan = NULL)
[17:01:03.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.474]                 }
[17:01:03.474]                 ...future.workdir <- getwd()
[17:01:03.474]             }
[17:01:03.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.474]         }
[17:01:03.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.474]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.474]             base::names(...future.oldOptions))
[17:01:03.474]     }
[17:01:03.474]     if (FALSE) {
[17:01:03.474]     }
[17:01:03.474]     else {
[17:01:03.474]         if (TRUE) {
[17:01:03.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.474]                 open = "w")
[17:01:03.474]         }
[17:01:03.474]         else {
[17:01:03.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.474]         }
[17:01:03.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.474]             base::sink(type = "output", split = FALSE)
[17:01:03.474]             base::close(...future.stdout)
[17:01:03.474]         }, add = TRUE)
[17:01:03.474]     }
[17:01:03.474]     ...future.frame <- base::sys.nframe()
[17:01:03.474]     ...future.conditions <- base::list()
[17:01:03.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.474]     if (FALSE) {
[17:01:03.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.474]     }
[17:01:03.474]     ...future.result <- base::tryCatch({
[17:01:03.474]         base::withCallingHandlers({
[17:01:03.474]             ...future.value <- base::withVisible(base::local({
[17:01:03.474]                 withCallingHandlers({
[17:01:03.474]                   {
[17:01:03.474]                     do.call(function(...) {
[17:01:03.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.474]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.474]                         ...future.globals.maxSize)) {
[17:01:03.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.474]                         on.exit(options(oopts), add = TRUE)
[17:01:03.474]                       }
[17:01:03.474]                       {
[17:01:03.474]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.474]                           FUN = function(jj) {
[17:01:03.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.474]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.474]                           })
[17:01:03.474]                       }
[17:01:03.474]                     }, args = future.call.arguments)
[17:01:03.474]                   }
[17:01:03.474]                 }, immediateCondition = function(cond) {
[17:01:03.474]                   save_rds <- function (object, pathname, ...) 
[17:01:03.474]                   {
[17:01:03.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.474]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.474]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.474]                         fi_tmp[["mtime"]])
[17:01:03.474]                     }
[17:01:03.474]                     tryCatch({
[17:01:03.474]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.474]                     }, error = function(ex) {
[17:01:03.474]                       msg <- conditionMessage(ex)
[17:01:03.474]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.474]                         fi_tmp[["mtime"]], msg)
[17:01:03.474]                       ex$message <- msg
[17:01:03.474]                       stop(ex)
[17:01:03.474]                     })
[17:01:03.474]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.474]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.474]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.474]                       fi <- file.info(pathname)
[17:01:03.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.474]                         fi[["size"]], fi[["mtime"]])
[17:01:03.474]                       stop(msg)
[17:01:03.474]                     }
[17:01:03.474]                     invisible(pathname)
[17:01:03.474]                   }
[17:01:03.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.474]                     rootPath = tempdir()) 
[17:01:03.474]                   {
[17:01:03.474]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.474]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.474]                       tmpdir = path, fileext = ".rds")
[17:01:03.474]                     save_rds(obj, file)
[17:01:03.474]                   }
[17:01:03.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.474]                   {
[17:01:03.474]                     inherits <- base::inherits
[17:01:03.474]                     invokeRestart <- base::invokeRestart
[17:01:03.474]                     is.null <- base::is.null
[17:01:03.474]                     muffled <- FALSE
[17:01:03.474]                     if (inherits(cond, "message")) {
[17:01:03.474]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.474]                       if (muffled) 
[17:01:03.474]                         invokeRestart("muffleMessage")
[17:01:03.474]                     }
[17:01:03.474]                     else if (inherits(cond, "warning")) {
[17:01:03.474]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.474]                       if (muffled) 
[17:01:03.474]                         invokeRestart("muffleWarning")
[17:01:03.474]                     }
[17:01:03.474]                     else if (inherits(cond, "condition")) {
[17:01:03.474]                       if (!is.null(pattern)) {
[17:01:03.474]                         computeRestarts <- base::computeRestarts
[17:01:03.474]                         grepl <- base::grepl
[17:01:03.474]                         restarts <- computeRestarts(cond)
[17:01:03.474]                         for (restart in restarts) {
[17:01:03.474]                           name <- restart$name
[17:01:03.474]                           if (is.null(name)) 
[17:01:03.474]                             next
[17:01:03.474]                           if (!grepl(pattern, name)) 
[17:01:03.474]                             next
[17:01:03.474]                           invokeRestart(restart)
[17:01:03.474]                           muffled <- TRUE
[17:01:03.474]                           break
[17:01:03.474]                         }
[17:01:03.474]                       }
[17:01:03.474]                     }
[17:01:03.474]                     invisible(muffled)
[17:01:03.474]                   }
[17:01:03.474]                   muffleCondition(cond)
[17:01:03.474]                 })
[17:01:03.474]             }))
[17:01:03.474]             future::FutureResult(value = ...future.value$value, 
[17:01:03.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.474]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.474]                     ...future.globalenv.names))
[17:01:03.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.474]         }, condition = base::local({
[17:01:03.474]             c <- base::c
[17:01:03.474]             inherits <- base::inherits
[17:01:03.474]             invokeRestart <- base::invokeRestart
[17:01:03.474]             length <- base::length
[17:01:03.474]             list <- base::list
[17:01:03.474]             seq.int <- base::seq.int
[17:01:03.474]             signalCondition <- base::signalCondition
[17:01:03.474]             sys.calls <- base::sys.calls
[17:01:03.474]             `[[` <- base::`[[`
[17:01:03.474]             `+` <- base::`+`
[17:01:03.474]             `<<-` <- base::`<<-`
[17:01:03.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.474]                   3L)]
[17:01:03.474]             }
[17:01:03.474]             function(cond) {
[17:01:03.474]                 is_error <- inherits(cond, "error")
[17:01:03.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.474]                   NULL)
[17:01:03.474]                 if (is_error) {
[17:01:03.474]                   sessionInformation <- function() {
[17:01:03.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.474]                       search = base::search(), system = base::Sys.info())
[17:01:03.474]                   }
[17:01:03.474]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.474]                     cond$call), session = sessionInformation(), 
[17:01:03.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.474]                   signalCondition(cond)
[17:01:03.474]                 }
[17:01:03.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.474]                 "immediateCondition"))) {
[17:01:03.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.474]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.474]                   if (TRUE && !signal) {
[17:01:03.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.474]                     {
[17:01:03.474]                       inherits <- base::inherits
[17:01:03.474]                       invokeRestart <- base::invokeRestart
[17:01:03.474]                       is.null <- base::is.null
[17:01:03.474]                       muffled <- FALSE
[17:01:03.474]                       if (inherits(cond, "message")) {
[17:01:03.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.474]                         if (muffled) 
[17:01:03.474]                           invokeRestart("muffleMessage")
[17:01:03.474]                       }
[17:01:03.474]                       else if (inherits(cond, "warning")) {
[17:01:03.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.474]                         if (muffled) 
[17:01:03.474]                           invokeRestart("muffleWarning")
[17:01:03.474]                       }
[17:01:03.474]                       else if (inherits(cond, "condition")) {
[17:01:03.474]                         if (!is.null(pattern)) {
[17:01:03.474]                           computeRestarts <- base::computeRestarts
[17:01:03.474]                           grepl <- base::grepl
[17:01:03.474]                           restarts <- computeRestarts(cond)
[17:01:03.474]                           for (restart in restarts) {
[17:01:03.474]                             name <- restart$name
[17:01:03.474]                             if (is.null(name)) 
[17:01:03.474]                               next
[17:01:03.474]                             if (!grepl(pattern, name)) 
[17:01:03.474]                               next
[17:01:03.474]                             invokeRestart(restart)
[17:01:03.474]                             muffled <- TRUE
[17:01:03.474]                             break
[17:01:03.474]                           }
[17:01:03.474]                         }
[17:01:03.474]                       }
[17:01:03.474]                       invisible(muffled)
[17:01:03.474]                     }
[17:01:03.474]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.474]                   }
[17:01:03.474]                 }
[17:01:03.474]                 else {
[17:01:03.474]                   if (TRUE) {
[17:01:03.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.474]                     {
[17:01:03.474]                       inherits <- base::inherits
[17:01:03.474]                       invokeRestart <- base::invokeRestart
[17:01:03.474]                       is.null <- base::is.null
[17:01:03.474]                       muffled <- FALSE
[17:01:03.474]                       if (inherits(cond, "message")) {
[17:01:03.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.474]                         if (muffled) 
[17:01:03.474]                           invokeRestart("muffleMessage")
[17:01:03.474]                       }
[17:01:03.474]                       else if (inherits(cond, "warning")) {
[17:01:03.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.474]                         if (muffled) 
[17:01:03.474]                           invokeRestart("muffleWarning")
[17:01:03.474]                       }
[17:01:03.474]                       else if (inherits(cond, "condition")) {
[17:01:03.474]                         if (!is.null(pattern)) {
[17:01:03.474]                           computeRestarts <- base::computeRestarts
[17:01:03.474]                           grepl <- base::grepl
[17:01:03.474]                           restarts <- computeRestarts(cond)
[17:01:03.474]                           for (restart in restarts) {
[17:01:03.474]                             name <- restart$name
[17:01:03.474]                             if (is.null(name)) 
[17:01:03.474]                               next
[17:01:03.474]                             if (!grepl(pattern, name)) 
[17:01:03.474]                               next
[17:01:03.474]                             invokeRestart(restart)
[17:01:03.474]                             muffled <- TRUE
[17:01:03.474]                             break
[17:01:03.474]                           }
[17:01:03.474]                         }
[17:01:03.474]                       }
[17:01:03.474]                       invisible(muffled)
[17:01:03.474]                     }
[17:01:03.474]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.474]                   }
[17:01:03.474]                 }
[17:01:03.474]             }
[17:01:03.474]         }))
[17:01:03.474]     }, error = function(ex) {
[17:01:03.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.474]                 ...future.rng), started = ...future.startTime, 
[17:01:03.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.474]             version = "1.8"), class = "FutureResult")
[17:01:03.474]     }, finally = {
[17:01:03.474]         if (!identical(...future.workdir, getwd())) 
[17:01:03.474]             setwd(...future.workdir)
[17:01:03.474]         {
[17:01:03.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.474]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.474]             }
[17:01:03.474]             base::options(...future.oldOptions)
[17:01:03.474]             if (.Platform$OS.type == "windows") {
[17:01:03.474]                 old_names <- names(...future.oldEnvVars)
[17:01:03.474]                 envs <- base::Sys.getenv()
[17:01:03.474]                 names <- names(envs)
[17:01:03.474]                 common <- intersect(names, old_names)
[17:01:03.474]                 added <- setdiff(names, old_names)
[17:01:03.474]                 removed <- setdiff(old_names, names)
[17:01:03.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.474]                   envs[common]]
[17:01:03.474]                 NAMES <- toupper(changed)
[17:01:03.474]                 args <- list()
[17:01:03.474]                 for (kk in seq_along(NAMES)) {
[17:01:03.474]                   name <- changed[[kk]]
[17:01:03.474]                   NAME <- NAMES[[kk]]
[17:01:03.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.474]                     next
[17:01:03.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.474]                 }
[17:01:03.474]                 NAMES <- toupper(added)
[17:01:03.474]                 for (kk in seq_along(NAMES)) {
[17:01:03.474]                   name <- added[[kk]]
[17:01:03.474]                   NAME <- NAMES[[kk]]
[17:01:03.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.474]                     next
[17:01:03.474]                   args[[name]] <- ""
[17:01:03.474]                 }
[17:01:03.474]                 NAMES <- toupper(removed)
[17:01:03.474]                 for (kk in seq_along(NAMES)) {
[17:01:03.474]                   name <- removed[[kk]]
[17:01:03.474]                   NAME <- NAMES[[kk]]
[17:01:03.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.474]                     next
[17:01:03.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.474]                 }
[17:01:03.474]                 if (length(args) > 0) 
[17:01:03.474]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.474]             }
[17:01:03.474]             else {
[17:01:03.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.474]             }
[17:01:03.474]             {
[17:01:03.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.474]                   0L) {
[17:01:03.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.474]                   base::options(opts)
[17:01:03.474]                 }
[17:01:03.474]                 {
[17:01:03.474]                   {
[17:01:03.474]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.474]                     NULL
[17:01:03.474]                   }
[17:01:03.474]                   options(future.plan = NULL)
[17:01:03.474]                   if (is.na(NA_character_)) 
[17:01:03.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.474]                     .init = FALSE)
[17:01:03.474]                 }
[17:01:03.474]             }
[17:01:03.474]         }
[17:01:03.474]     })
[17:01:03.474]     if (TRUE) {
[17:01:03.474]         base::sink(type = "output", split = FALSE)
[17:01:03.474]         if (TRUE) {
[17:01:03.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.474]         }
[17:01:03.474]         else {
[17:01:03.474]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.474]         }
[17:01:03.474]         base::close(...future.stdout)
[17:01:03.474]         ...future.stdout <- NULL
[17:01:03.474]     }
[17:01:03.474]     ...future.result$conditions <- ...future.conditions
[17:01:03.474]     ...future.result$finished <- base::Sys.time()
[17:01:03.474]     ...future.result
[17:01:03.474] }
[17:01:03.478] assign_globals() ...
[17:01:03.478] List of 5
[17:01:03.478]  $ ...future.FUN            :function (x, y)  
[17:01:03.478]  $ future.call.arguments    :List of 1
[17:01:03.478]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.478]  $ ...future.elements_ii    :List of 2
[17:01:03.478]   ..$ C: num 70
[17:01:03.478]   ..$ D: num 80
[17:01:03.478]  $ ...future.seeds_ii       : NULL
[17:01:03.478]  $ ...future.globals.maxSize: NULL
[17:01:03.478]  - attr(*, "where")=List of 5
[17:01:03.478]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.478]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.478]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.478]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.478]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.478]  - attr(*, "resolved")= logi FALSE
[17:01:03.478]  - attr(*, "total_size")= num 4264
[17:01:03.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.478]  - attr(*, "already-done")= logi TRUE
[17:01:03.491] - reassign environment for ‘...future.FUN’
[17:01:03.491] - copied ‘...future.FUN’ to environment
[17:01:03.491] - copied ‘future.call.arguments’ to environment
[17:01:03.491] - copied ‘...future.elements_ii’ to environment
[17:01:03.491] - copied ‘...future.seeds_ii’ to environment
[17:01:03.492] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.492] assign_globals() ... done
[17:01:03.492] requestCore(): workers = 2
[17:01:03.495] MulticoreFuture started
[17:01:03.496] - Launch lazy future ... done
[17:01:03.496] run() for ‘MulticoreFuture’ ... done
[17:01:03.496] plan(): Setting new future strategy stack:
[17:01:03.496] Created future:
[17:01:03.496] List of future strategies:
[17:01:03.496] 1. sequential:
[17:01:03.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.496]    - tweaked: FALSE
[17:01:03.496]    - call: NULL
[17:01:03.498] plan(): nbrOfWorkers() = 1
[17:01:03.500] plan(): Setting new future strategy stack:
[17:01:03.500] List of future strategies:
[17:01:03.500] 1. multicore:
[17:01:03.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.500]    - tweaked: FALSE
[17:01:03.500]    - call: plan(strategy)
[17:01:03.506] plan(): nbrOfWorkers() = 2
[17:01:03.497] MulticoreFuture:
[17:01:03.497] Label: ‘future_sapply-2’
[17:01:03.497] Expression:
[17:01:03.497] {
[17:01:03.497]     do.call(function(...) {
[17:01:03.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.497]             on.exit(options(oopts), add = TRUE)
[17:01:03.497]         }
[17:01:03.497]         {
[17:01:03.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.497]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.497]             })
[17:01:03.497]         }
[17:01:03.497]     }, args = future.call.arguments)
[17:01:03.497] }
[17:01:03.497] Lazy evaluation: FALSE
[17:01:03.497] Asynchronous evaluation: TRUE
[17:01:03.497] Local evaluation: TRUE
[17:01:03.497] Environment: R_GlobalEnv
[17:01:03.497] Capture standard output: TRUE
[17:01:03.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.497] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:03.497] Packages: <none>
[17:01:03.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.497] Resolved: TRUE
[17:01:03.497] Value: <not collected>
[17:01:03.497] Conditions captured: <none>
[17:01:03.497] Early signaling: FALSE
[17:01:03.497] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.497] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.507] Chunk #2 of 2 ... DONE
[17:01:03.507] Launching 2 futures (chunks) ... DONE
[17:01:03.508] Resolving 2 futures (chunks) ...
[17:01:03.508] resolve() on list ...
[17:01:03.508]  recursive: 0
[17:01:03.508]  length: 2
[17:01:03.508] 
[17:01:03.509] Future #1
[17:01:03.509] result() for MulticoreFuture ...
[17:01:03.510] result() for MulticoreFuture ...
[17:01:03.510] result() for MulticoreFuture ... done
[17:01:03.510] result() for MulticoreFuture ... done
[17:01:03.510] result() for MulticoreFuture ...
[17:01:03.510] result() for MulticoreFuture ... done
[17:01:03.511] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.511] - nx: 2
[17:01:03.511] - relay: TRUE
[17:01:03.511] - stdout: TRUE
[17:01:03.511] - signal: TRUE
[17:01:03.511] - resignal: FALSE
[17:01:03.512] - force: TRUE
[17:01:03.512] - relayed: [n=2] FALSE, FALSE
[17:01:03.512] - queued futures: [n=2] FALSE, FALSE
[17:01:03.512]  - until=1
[17:01:03.512]  - relaying element #1
[17:01:03.512] result() for MulticoreFuture ...
[17:01:03.512] result() for MulticoreFuture ... done
[17:01:03.513] result() for MulticoreFuture ...
[17:01:03.513] result() for MulticoreFuture ... done
[17:01:03.513] result() for MulticoreFuture ...
[17:01:03.513] result() for MulticoreFuture ... done
[17:01:03.513] result() for MulticoreFuture ...
[17:01:03.513] result() for MulticoreFuture ... done
[17:01:03.514] - relayed: [n=2] TRUE, FALSE
[17:01:03.514] - queued futures: [n=2] TRUE, FALSE
[17:01:03.514] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.514]  length: 1 (resolved future 1)
[17:01:03.514] Future #2
[17:01:03.514] result() for MulticoreFuture ...
[17:01:03.515] result() for MulticoreFuture ...
[17:01:03.515] result() for MulticoreFuture ... done
[17:01:03.515] result() for MulticoreFuture ... done
[17:01:03.516] result() for MulticoreFuture ...
[17:01:03.516] result() for MulticoreFuture ... done
[17:01:03.516] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.516] - nx: 2
[17:01:03.516] - relay: TRUE
[17:01:03.516] - stdout: TRUE
[17:01:03.516] - signal: TRUE
[17:01:03.517] - resignal: FALSE
[17:01:03.517] - force: TRUE
[17:01:03.517] - relayed: [n=2] TRUE, FALSE
[17:01:03.517] - queued futures: [n=2] TRUE, FALSE
[17:01:03.517]  - until=2
[17:01:03.517]  - relaying element #2
[17:01:03.517] result() for MulticoreFuture ...
[17:01:03.517] result() for MulticoreFuture ... done
[17:01:03.517] result() for MulticoreFuture ...
[17:01:03.518] result() for MulticoreFuture ... done
[17:01:03.518] result() for MulticoreFuture ...
[17:01:03.518] result() for MulticoreFuture ... done
[17:01:03.518] result() for MulticoreFuture ...
[17:01:03.518] result() for MulticoreFuture ... done
[17:01:03.518] - relayed: [n=2] TRUE, TRUE
[17:01:03.518] - queued futures: [n=2] TRUE, TRUE
[17:01:03.518] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.519]  length: 0 (resolved future 2)
[17:01:03.519] Relaying remaining futures
[17:01:03.519] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.519] - nx: 2
[17:01:03.519] - relay: TRUE
[17:01:03.519] - stdout: TRUE
[17:01:03.519] - signal: TRUE
[17:01:03.519] - resignal: FALSE
[17:01:03.519] - force: TRUE
[17:01:03.519] - relayed: [n=2] TRUE, TRUE
[17:01:03.520] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.520] - relayed: [n=2] TRUE, TRUE
[17:01:03.520] - queued futures: [n=2] TRUE, TRUE
[17:01:03.520] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.520] resolve() on list ... DONE
[17:01:03.520] result() for MulticoreFuture ...
[17:01:03.520] result() for MulticoreFuture ... done
[17:01:03.521] result() for MulticoreFuture ...
[17:01:03.521] result() for MulticoreFuture ... done
[17:01:03.521] result() for MulticoreFuture ...
[17:01:03.521] result() for MulticoreFuture ... done
[17:01:03.521] result() for MulticoreFuture ...
[17:01:03.521] result() for MulticoreFuture ... done
[17:01:03.521]  - Number of value chunks collected: 2
[17:01:03.521] Resolving 2 futures (chunks) ... DONE
[17:01:03.521] Reducing values from 2 chunks ...
[17:01:03.522]  - Number of values collected after concatenation: 4
[17:01:03.522]  - Number of values expected: 4
[17:01:03.522] Reducing values from 2 chunks ... DONE
[17:01:03.522] future_lapply() ... DONE
[17:01:03.523] future_lapply() ...
[17:01:03.533] Number of chunks: 2
[17:01:03.533] getGlobalsAndPackagesXApply() ...
[17:01:03.533]  - future.globals: TRUE
[17:01:03.533] getGlobalsAndPackages() ...
[17:01:03.533] Searching for globals...
[17:01:03.539] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:01:03.539] Searching for globals ... DONE
[17:01:03.539] Resolving globals: FALSE
[17:01:03.540] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:01:03.540] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:03.541] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.541] - packages: [1] ‘future.apply’
[17:01:03.541] getGlobalsAndPackages() ... DONE
[17:01:03.541]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.541]  - needed namespaces: [n=1] ‘future.apply’
[17:01:03.541] Finding globals ... DONE
[17:01:03.541]  - use_args: TRUE
[17:01:03.541]  - Getting '...' globals ...
[17:01:03.542] resolve() on list ...
[17:01:03.542]  recursive: 0
[17:01:03.542]  length: 1
[17:01:03.542]  elements: ‘...’
[17:01:03.542]  length: 0 (resolved future 1)
[17:01:03.542] resolve() on list ... DONE
[17:01:03.542]    - '...' content: [n=1] ‘y’
[17:01:03.542] List of 1
[17:01:03.542]  $ ...:List of 1
[17:01:03.542]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.542]  - attr(*, "where")=List of 1
[17:01:03.542]   ..$ ...:<environment: 0x55aadb42af08> 
[17:01:03.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.542]  - attr(*, "resolved")= logi TRUE
[17:01:03.542]  - attr(*, "total_size")= num NA
[17:01:03.546]  - Getting '...' globals ... DONE
[17:01:03.546] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:03.546] List of 8
[17:01:03.546]  $ ...future.FUN:function (x, ...)  
[17:01:03.546]  $ x_FUN        :function (x, y)  
[17:01:03.546]  $ times        : int 15
[17:01:03.546]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.546]  $ stop_if_not  :function (...)  
[17:01:03.546]  $ dim          : int [1:2] 3 5
[17:01:03.546]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:03.546]  $ ...          :List of 1
[17:01:03.546]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.546]  - attr(*, "where")=List of 8
[17:01:03.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:03.546]   ..$ ...          :<environment: 0x55aadb42af08> 
[17:01:03.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.546]  - attr(*, "resolved")= logi FALSE
[17:01:03.546]  - attr(*, "total_size")= num 98600
[17:01:03.555] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:03.555] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.555] Number of futures (= number of chunks): 2
[17:01:03.555] Launching 2 futures (chunks) ...
[17:01:03.555] Chunk #1 of 2 ...
[17:01:03.555]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.556] getGlobalsAndPackages() ...
[17:01:03.556] Searching for globals...
[17:01:03.556] 
[17:01:03.556] Searching for globals ... DONE
[17:01:03.556] - globals: [0] <none>
[17:01:03.556] getGlobalsAndPackages() ... DONE
[17:01:03.557]    + additional globals found: [n=0] 
[17:01:03.557]    + additional namespaces needed: [n=0] 
[17:01:03.557]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.557]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.557]  - seeds: <none>
[17:01:03.557]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.557] getGlobalsAndPackages() ...
[17:01:03.557] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.558] Resolving globals: FALSE
[17:01:03.558] Tweak future expression to call with '...' arguments ...
[17:01:03.558] {
[17:01:03.558]     do.call(function(...) {
[17:01:03.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.558]             on.exit(options(oopts), add = TRUE)
[17:01:03.558]         }
[17:01:03.558]         {
[17:01:03.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.558]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.558]             })
[17:01:03.558]         }
[17:01:03.558]     }, args = future.call.arguments)
[17:01:03.558] }
[17:01:03.558] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.559] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.559] - packages: [1] ‘future.apply’
[17:01:03.559] getGlobalsAndPackages() ... DONE
[17:01:03.560] run() for ‘Future’ ...
[17:01:03.560] - state: ‘created’
[17:01:03.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.564] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.564]   - Field: ‘label’
[17:01:03.564]   - Field: ‘local’
[17:01:03.564]   - Field: ‘owner’
[17:01:03.564]   - Field: ‘envir’
[17:01:03.565]   - Field: ‘workers’
[17:01:03.565]   - Field: ‘packages’
[17:01:03.565]   - Field: ‘gc’
[17:01:03.565]   - Field: ‘job’
[17:01:03.565]   - Field: ‘conditions’
[17:01:03.565]   - Field: ‘expr’
[17:01:03.565]   - Field: ‘uuid’
[17:01:03.565]   - Field: ‘seed’
[17:01:03.565]   - Field: ‘version’
[17:01:03.565]   - Field: ‘result’
[17:01:03.565]   - Field: ‘asynchronous’
[17:01:03.566]   - Field: ‘calls’
[17:01:03.566]   - Field: ‘globals’
[17:01:03.566]   - Field: ‘stdout’
[17:01:03.566]   - Field: ‘earlySignal’
[17:01:03.566]   - Field: ‘lazy’
[17:01:03.566]   - Field: ‘state’
[17:01:03.566] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.566] - Launch lazy future ...
[17:01:03.567] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.567] Packages needed by future strategies (n = 0): <none>
[17:01:03.567] {
[17:01:03.567]     {
[17:01:03.567]         {
[17:01:03.567]             ...future.startTime <- base::Sys.time()
[17:01:03.567]             {
[17:01:03.567]                 {
[17:01:03.567]                   {
[17:01:03.567]                     {
[17:01:03.567]                       {
[17:01:03.567]                         base::local({
[17:01:03.567]                           has_future <- base::requireNamespace("future", 
[17:01:03.567]                             quietly = TRUE)
[17:01:03.567]                           if (has_future) {
[17:01:03.567]                             ns <- base::getNamespace("future")
[17:01:03.567]                             version <- ns[[".package"]][["version"]]
[17:01:03.567]                             if (is.null(version)) 
[17:01:03.567]                               version <- utils::packageVersion("future")
[17:01:03.567]                           }
[17:01:03.567]                           else {
[17:01:03.567]                             version <- NULL
[17:01:03.567]                           }
[17:01:03.567]                           if (!has_future || version < "1.8.0") {
[17:01:03.567]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.567]                               "", base::R.version$version.string), 
[17:01:03.567]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.567]                                 base::R.version$platform, 8 * 
[17:01:03.567]                                   base::.Machine$sizeof.pointer), 
[17:01:03.567]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.567]                                 "release", "version")], collapse = " "), 
[17:01:03.567]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.567]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.567]                               info)
[17:01:03.567]                             info <- base::paste(info, collapse = "; ")
[17:01:03.567]                             if (!has_future) {
[17:01:03.567]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.567]                                 info)
[17:01:03.567]                             }
[17:01:03.567]                             else {
[17:01:03.567]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.567]                                 info, version)
[17:01:03.567]                             }
[17:01:03.567]                             base::stop(msg)
[17:01:03.567]                           }
[17:01:03.567]                         })
[17:01:03.567]                       }
[17:01:03.567]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.567]                       base::options(mc.cores = 1L)
[17:01:03.567]                     }
[17:01:03.567]                     base::local({
[17:01:03.567]                       for (pkg in "future.apply") {
[17:01:03.567]                         base::loadNamespace(pkg)
[17:01:03.567]                         base::library(pkg, character.only = TRUE)
[17:01:03.567]                       }
[17:01:03.567]                     })
[17:01:03.567]                   }
[17:01:03.567]                   ...future.strategy.old <- future::plan("list")
[17:01:03.567]                   options(future.plan = NULL)
[17:01:03.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.567]                 }
[17:01:03.567]                 ...future.workdir <- getwd()
[17:01:03.567]             }
[17:01:03.567]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.567]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.567]         }
[17:01:03.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.567]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.567]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.567]             base::names(...future.oldOptions))
[17:01:03.567]     }
[17:01:03.567]     if (FALSE) {
[17:01:03.567]     }
[17:01:03.567]     else {
[17:01:03.567]         if (TRUE) {
[17:01:03.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.567]                 open = "w")
[17:01:03.567]         }
[17:01:03.567]         else {
[17:01:03.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.567]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.567]         }
[17:01:03.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.567]             base::sink(type = "output", split = FALSE)
[17:01:03.567]             base::close(...future.stdout)
[17:01:03.567]         }, add = TRUE)
[17:01:03.567]     }
[17:01:03.567]     ...future.frame <- base::sys.nframe()
[17:01:03.567]     ...future.conditions <- base::list()
[17:01:03.567]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.567]     if (FALSE) {
[17:01:03.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.567]     }
[17:01:03.567]     ...future.result <- base::tryCatch({
[17:01:03.567]         base::withCallingHandlers({
[17:01:03.567]             ...future.value <- base::withVisible(base::local({
[17:01:03.567]                 withCallingHandlers({
[17:01:03.567]                   {
[17:01:03.567]                     do.call(function(...) {
[17:01:03.567]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.567]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.567]                         ...future.globals.maxSize)) {
[17:01:03.567]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.567]                         on.exit(options(oopts), add = TRUE)
[17:01:03.567]                       }
[17:01:03.567]                       {
[17:01:03.567]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.567]                           FUN = function(jj) {
[17:01:03.567]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.567]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.567]                           })
[17:01:03.567]                       }
[17:01:03.567]                     }, args = future.call.arguments)
[17:01:03.567]                   }
[17:01:03.567]                 }, immediateCondition = function(cond) {
[17:01:03.567]                   save_rds <- function (object, pathname, ...) 
[17:01:03.567]                   {
[17:01:03.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.567]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.567]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.567]                         fi_tmp[["mtime"]])
[17:01:03.567]                     }
[17:01:03.567]                     tryCatch({
[17:01:03.567]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.567]                     }, error = function(ex) {
[17:01:03.567]                       msg <- conditionMessage(ex)
[17:01:03.567]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.567]                         fi_tmp[["mtime"]], msg)
[17:01:03.567]                       ex$message <- msg
[17:01:03.567]                       stop(ex)
[17:01:03.567]                     })
[17:01:03.567]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.567]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.567]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.567]                       fi <- file.info(pathname)
[17:01:03.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.567]                         fi[["size"]], fi[["mtime"]])
[17:01:03.567]                       stop(msg)
[17:01:03.567]                     }
[17:01:03.567]                     invisible(pathname)
[17:01:03.567]                   }
[17:01:03.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.567]                     rootPath = tempdir()) 
[17:01:03.567]                   {
[17:01:03.567]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.567]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.567]                       tmpdir = path, fileext = ".rds")
[17:01:03.567]                     save_rds(obj, file)
[17:01:03.567]                   }
[17:01:03.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.567]                   {
[17:01:03.567]                     inherits <- base::inherits
[17:01:03.567]                     invokeRestart <- base::invokeRestart
[17:01:03.567]                     is.null <- base::is.null
[17:01:03.567]                     muffled <- FALSE
[17:01:03.567]                     if (inherits(cond, "message")) {
[17:01:03.567]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.567]                       if (muffled) 
[17:01:03.567]                         invokeRestart("muffleMessage")
[17:01:03.567]                     }
[17:01:03.567]                     else if (inherits(cond, "warning")) {
[17:01:03.567]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.567]                       if (muffled) 
[17:01:03.567]                         invokeRestart("muffleWarning")
[17:01:03.567]                     }
[17:01:03.567]                     else if (inherits(cond, "condition")) {
[17:01:03.567]                       if (!is.null(pattern)) {
[17:01:03.567]                         computeRestarts <- base::computeRestarts
[17:01:03.567]                         grepl <- base::grepl
[17:01:03.567]                         restarts <- computeRestarts(cond)
[17:01:03.567]                         for (restart in restarts) {
[17:01:03.567]                           name <- restart$name
[17:01:03.567]                           if (is.null(name)) 
[17:01:03.567]                             next
[17:01:03.567]                           if (!grepl(pattern, name)) 
[17:01:03.567]                             next
[17:01:03.567]                           invokeRestart(restart)
[17:01:03.567]                           muffled <- TRUE
[17:01:03.567]                           break
[17:01:03.567]                         }
[17:01:03.567]                       }
[17:01:03.567]                     }
[17:01:03.567]                     invisible(muffled)
[17:01:03.567]                   }
[17:01:03.567]                   muffleCondition(cond)
[17:01:03.567]                 })
[17:01:03.567]             }))
[17:01:03.567]             future::FutureResult(value = ...future.value$value, 
[17:01:03.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.567]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.567]                     ...future.globalenv.names))
[17:01:03.567]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.567]         }, condition = base::local({
[17:01:03.567]             c <- base::c
[17:01:03.567]             inherits <- base::inherits
[17:01:03.567]             invokeRestart <- base::invokeRestart
[17:01:03.567]             length <- base::length
[17:01:03.567]             list <- base::list
[17:01:03.567]             seq.int <- base::seq.int
[17:01:03.567]             signalCondition <- base::signalCondition
[17:01:03.567]             sys.calls <- base::sys.calls
[17:01:03.567]             `[[` <- base::`[[`
[17:01:03.567]             `+` <- base::`+`
[17:01:03.567]             `<<-` <- base::`<<-`
[17:01:03.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.567]                   3L)]
[17:01:03.567]             }
[17:01:03.567]             function(cond) {
[17:01:03.567]                 is_error <- inherits(cond, "error")
[17:01:03.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.567]                   NULL)
[17:01:03.567]                 if (is_error) {
[17:01:03.567]                   sessionInformation <- function() {
[17:01:03.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.567]                       search = base::search(), system = base::Sys.info())
[17:01:03.567]                   }
[17:01:03.567]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.567]                     cond$call), session = sessionInformation(), 
[17:01:03.567]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.567]                   signalCondition(cond)
[17:01:03.567]                 }
[17:01:03.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.567]                 "immediateCondition"))) {
[17:01:03.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.567]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.567]                   if (TRUE && !signal) {
[17:01:03.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.567]                     {
[17:01:03.567]                       inherits <- base::inherits
[17:01:03.567]                       invokeRestart <- base::invokeRestart
[17:01:03.567]                       is.null <- base::is.null
[17:01:03.567]                       muffled <- FALSE
[17:01:03.567]                       if (inherits(cond, "message")) {
[17:01:03.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.567]                         if (muffled) 
[17:01:03.567]                           invokeRestart("muffleMessage")
[17:01:03.567]                       }
[17:01:03.567]                       else if (inherits(cond, "warning")) {
[17:01:03.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.567]                         if (muffled) 
[17:01:03.567]                           invokeRestart("muffleWarning")
[17:01:03.567]                       }
[17:01:03.567]                       else if (inherits(cond, "condition")) {
[17:01:03.567]                         if (!is.null(pattern)) {
[17:01:03.567]                           computeRestarts <- base::computeRestarts
[17:01:03.567]                           grepl <- base::grepl
[17:01:03.567]                           restarts <- computeRestarts(cond)
[17:01:03.567]                           for (restart in restarts) {
[17:01:03.567]                             name <- restart$name
[17:01:03.567]                             if (is.null(name)) 
[17:01:03.567]                               next
[17:01:03.567]                             if (!grepl(pattern, name)) 
[17:01:03.567]                               next
[17:01:03.567]                             invokeRestart(restart)
[17:01:03.567]                             muffled <- TRUE
[17:01:03.567]                             break
[17:01:03.567]                           }
[17:01:03.567]                         }
[17:01:03.567]                       }
[17:01:03.567]                       invisible(muffled)
[17:01:03.567]                     }
[17:01:03.567]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.567]                   }
[17:01:03.567]                 }
[17:01:03.567]                 else {
[17:01:03.567]                   if (TRUE) {
[17:01:03.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.567]                     {
[17:01:03.567]                       inherits <- base::inherits
[17:01:03.567]                       invokeRestart <- base::invokeRestart
[17:01:03.567]                       is.null <- base::is.null
[17:01:03.567]                       muffled <- FALSE
[17:01:03.567]                       if (inherits(cond, "message")) {
[17:01:03.567]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.567]                         if (muffled) 
[17:01:03.567]                           invokeRestart("muffleMessage")
[17:01:03.567]                       }
[17:01:03.567]                       else if (inherits(cond, "warning")) {
[17:01:03.567]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.567]                         if (muffled) 
[17:01:03.567]                           invokeRestart("muffleWarning")
[17:01:03.567]                       }
[17:01:03.567]                       else if (inherits(cond, "condition")) {
[17:01:03.567]                         if (!is.null(pattern)) {
[17:01:03.567]                           computeRestarts <- base::computeRestarts
[17:01:03.567]                           grepl <- base::grepl
[17:01:03.567]                           restarts <- computeRestarts(cond)
[17:01:03.567]                           for (restart in restarts) {
[17:01:03.567]                             name <- restart$name
[17:01:03.567]                             if (is.null(name)) 
[17:01:03.567]                               next
[17:01:03.567]                             if (!grepl(pattern, name)) 
[17:01:03.567]                               next
[17:01:03.567]                             invokeRestart(restart)
[17:01:03.567]                             muffled <- TRUE
[17:01:03.567]                             break
[17:01:03.567]                           }
[17:01:03.567]                         }
[17:01:03.567]                       }
[17:01:03.567]                       invisible(muffled)
[17:01:03.567]                     }
[17:01:03.567]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.567]                   }
[17:01:03.567]                 }
[17:01:03.567]             }
[17:01:03.567]         }))
[17:01:03.567]     }, error = function(ex) {
[17:01:03.567]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.567]                 ...future.rng), started = ...future.startTime, 
[17:01:03.567]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.567]             version = "1.8"), class = "FutureResult")
[17:01:03.567]     }, finally = {
[17:01:03.567]         if (!identical(...future.workdir, getwd())) 
[17:01:03.567]             setwd(...future.workdir)
[17:01:03.567]         {
[17:01:03.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.567]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.567]             }
[17:01:03.567]             base::options(...future.oldOptions)
[17:01:03.567]             if (.Platform$OS.type == "windows") {
[17:01:03.567]                 old_names <- names(...future.oldEnvVars)
[17:01:03.567]                 envs <- base::Sys.getenv()
[17:01:03.567]                 names <- names(envs)
[17:01:03.567]                 common <- intersect(names, old_names)
[17:01:03.567]                 added <- setdiff(names, old_names)
[17:01:03.567]                 removed <- setdiff(old_names, names)
[17:01:03.567]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.567]                   envs[common]]
[17:01:03.567]                 NAMES <- toupper(changed)
[17:01:03.567]                 args <- list()
[17:01:03.567]                 for (kk in seq_along(NAMES)) {
[17:01:03.567]                   name <- changed[[kk]]
[17:01:03.567]                   NAME <- NAMES[[kk]]
[17:01:03.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.567]                     next
[17:01:03.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.567]                 }
[17:01:03.567]                 NAMES <- toupper(added)
[17:01:03.567]                 for (kk in seq_along(NAMES)) {
[17:01:03.567]                   name <- added[[kk]]
[17:01:03.567]                   NAME <- NAMES[[kk]]
[17:01:03.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.567]                     next
[17:01:03.567]                   args[[name]] <- ""
[17:01:03.567]                 }
[17:01:03.567]                 NAMES <- toupper(removed)
[17:01:03.567]                 for (kk in seq_along(NAMES)) {
[17:01:03.567]                   name <- removed[[kk]]
[17:01:03.567]                   NAME <- NAMES[[kk]]
[17:01:03.567]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.567]                     next
[17:01:03.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.567]                 }
[17:01:03.567]                 if (length(args) > 0) 
[17:01:03.567]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.567]             }
[17:01:03.567]             else {
[17:01:03.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.567]             }
[17:01:03.567]             {
[17:01:03.567]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.567]                   0L) {
[17:01:03.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.567]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.567]                   base::options(opts)
[17:01:03.567]                 }
[17:01:03.567]                 {
[17:01:03.567]                   {
[17:01:03.567]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.567]                     NULL
[17:01:03.567]                   }
[17:01:03.567]                   options(future.plan = NULL)
[17:01:03.567]                   if (is.na(NA_character_)) 
[17:01:03.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.567]                     .init = FALSE)
[17:01:03.567]                 }
[17:01:03.567]             }
[17:01:03.567]         }
[17:01:03.567]     })
[17:01:03.567]     if (TRUE) {
[17:01:03.567]         base::sink(type = "output", split = FALSE)
[17:01:03.567]         if (TRUE) {
[17:01:03.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.567]         }
[17:01:03.567]         else {
[17:01:03.567]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.567]         }
[17:01:03.567]         base::close(...future.stdout)
[17:01:03.567]         ...future.stdout <- NULL
[17:01:03.567]     }
[17:01:03.567]     ...future.result$conditions <- ...future.conditions
[17:01:03.567]     ...future.result$finished <- base::Sys.time()
[17:01:03.567]     ...future.result
[17:01:03.567] }
[17:01:03.570] assign_globals() ...
[17:01:03.570] List of 11
[17:01:03.570]  $ ...future.FUN            :function (x, ...)  
[17:01:03.570]  $ x_FUN                    :function (x, y)  
[17:01:03.570]  $ times                    : int 15
[17:01:03.570]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.570]  $ stop_if_not              :function (...)  
[17:01:03.570]  $ dim                      : int [1:2] 3 5
[17:01:03.570]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.570]  $ future.call.arguments    :List of 1
[17:01:03.570]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.570]  $ ...future.elements_ii    :List of 2
[17:01:03.570]   ..$ A: num 50
[17:01:03.570]   ..$ B: num 60
[17:01:03.570]  $ ...future.seeds_ii       : NULL
[17:01:03.570]  $ ...future.globals.maxSize: NULL
[17:01:03.570]  - attr(*, "where")=List of 11
[17:01:03.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.570]  - attr(*, "resolved")= logi FALSE
[17:01:03.570]  - attr(*, "total_size")= num 98600
[17:01:03.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.570]  - attr(*, "already-done")= logi TRUE
[17:01:03.581] - copied ‘...future.FUN’ to environment
[17:01:03.581] - reassign environment for ‘x_FUN’
[17:01:03.581] - copied ‘x_FUN’ to environment
[17:01:03.581] - copied ‘times’ to environment
[17:01:03.581] - copied ‘stopf’ to environment
[17:01:03.582] - copied ‘stop_if_not’ to environment
[17:01:03.582] - copied ‘dim’ to environment
[17:01:03.582] - copied ‘valid_types’ to environment
[17:01:03.582] - copied ‘future.call.arguments’ to environment
[17:01:03.582] - copied ‘...future.elements_ii’ to environment
[17:01:03.582] - copied ‘...future.seeds_ii’ to environment
[17:01:03.582] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.582] assign_globals() ... done
[17:01:03.583] requestCore(): workers = 2
[17:01:03.585] MulticoreFuture started
[17:01:03.586] - Launch lazy future ... done
[17:01:03.586] run() for ‘MulticoreFuture’ ... done
[17:01:03.587] Created future:
[17:01:03.587] plan(): Setting new future strategy stack:
[17:01:03.588] List of future strategies:
[17:01:03.588] 1. sequential:
[17:01:03.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.588]    - tweaked: FALSE
[17:01:03.588]    - call: NULL
[17:01:03.589] plan(): nbrOfWorkers() = 1
[17:01:03.592] plan(): Setting new future strategy stack:
[17:01:03.593] List of future strategies:
[17:01:03.593] 1. multicore:
[17:01:03.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.593]    - tweaked: FALSE
[17:01:03.593]    - call: plan(strategy)
[17:01:03.600] plan(): nbrOfWorkers() = 2
[17:01:03.587] MulticoreFuture:
[17:01:03.587] Label: ‘future_vapply-1’
[17:01:03.587] Expression:
[17:01:03.587] {
[17:01:03.587]     do.call(function(...) {
[17:01:03.587]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.587]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.587]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.587]             on.exit(options(oopts), add = TRUE)
[17:01:03.587]         }
[17:01:03.587]         {
[17:01:03.587]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.587]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.587]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.587]             })
[17:01:03.587]         }
[17:01:03.587]     }, args = future.call.arguments)
[17:01:03.587] }
[17:01:03.587] Lazy evaluation: FALSE
[17:01:03.587] Asynchronous evaluation: TRUE
[17:01:03.587] Local evaluation: TRUE
[17:01:03.587] Environment: R_GlobalEnv
[17:01:03.587] Capture standard output: TRUE
[17:01:03.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.587] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.587] Packages: 1 packages (‘future.apply’)
[17:01:03.587] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.587] Resolved: TRUE
[17:01:03.587] Value: <not collected>
[17:01:03.587] Conditions captured: <none>
[17:01:03.587] Early signaling: FALSE
[17:01:03.587] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.587] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.601] Chunk #1 of 2 ... DONE
[17:01:03.601] Chunk #2 of 2 ...
[17:01:03.601]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.602] getGlobalsAndPackages() ...
[17:01:03.602] Searching for globals...
[17:01:03.602] 
[17:01:03.603] Searching for globals ... DONE
[17:01:03.603] - globals: [0] <none>
[17:01:03.603] getGlobalsAndPackages() ... DONE
[17:01:03.603]    + additional globals found: [n=0] 
[17:01:03.603]    + additional namespaces needed: [n=0] 
[17:01:03.603]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.604]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.604]  - seeds: <none>
[17:01:03.604]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.604] getGlobalsAndPackages() ...
[17:01:03.604] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.604] Resolving globals: FALSE
[17:01:03.605] Tweak future expression to call with '...' arguments ...
[17:01:03.605] {
[17:01:03.605]     do.call(function(...) {
[17:01:03.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.605]             on.exit(options(oopts), add = TRUE)
[17:01:03.605]         }
[17:01:03.605]         {
[17:01:03.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.605]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.605]             })
[17:01:03.605]         }
[17:01:03.605]     }, args = future.call.arguments)
[17:01:03.605] }
[17:01:03.605] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.606] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.606] - packages: [1] ‘future.apply’
[17:01:03.607] getGlobalsAndPackages() ... DONE
[17:01:03.607] run() for ‘Future’ ...
[17:01:03.607] - state: ‘created’
[17:01:03.608] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.612] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.612]   - Field: ‘label’
[17:01:03.612]   - Field: ‘local’
[17:01:03.613]   - Field: ‘owner’
[17:01:03.613]   - Field: ‘envir’
[17:01:03.613]   - Field: ‘workers’
[17:01:03.613]   - Field: ‘packages’
[17:01:03.613]   - Field: ‘gc’
[17:01:03.613]   - Field: ‘job’
[17:01:03.613]   - Field: ‘conditions’
[17:01:03.613]   - Field: ‘expr’
[17:01:03.614]   - Field: ‘uuid’
[17:01:03.614]   - Field: ‘seed’
[17:01:03.614]   - Field: ‘version’
[17:01:03.614]   - Field: ‘result’
[17:01:03.614]   - Field: ‘asynchronous’
[17:01:03.614]   - Field: ‘calls’
[17:01:03.614]   - Field: ‘globals’
[17:01:03.615]   - Field: ‘stdout’
[17:01:03.615]   - Field: ‘earlySignal’
[17:01:03.615]   - Field: ‘lazy’
[17:01:03.615]   - Field: ‘state’
[17:01:03.615] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.615] - Launch lazy future ...
[17:01:03.616] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.616] Packages needed by future strategies (n = 0): <none>
[17:01:03.617] {
[17:01:03.617]     {
[17:01:03.617]         {
[17:01:03.617]             ...future.startTime <- base::Sys.time()
[17:01:03.617]             {
[17:01:03.617]                 {
[17:01:03.617]                   {
[17:01:03.617]                     {
[17:01:03.617]                       {
[17:01:03.617]                         base::local({
[17:01:03.617]                           has_future <- base::requireNamespace("future", 
[17:01:03.617]                             quietly = TRUE)
[17:01:03.617]                           if (has_future) {
[17:01:03.617]                             ns <- base::getNamespace("future")
[17:01:03.617]                             version <- ns[[".package"]][["version"]]
[17:01:03.617]                             if (is.null(version)) 
[17:01:03.617]                               version <- utils::packageVersion("future")
[17:01:03.617]                           }
[17:01:03.617]                           else {
[17:01:03.617]                             version <- NULL
[17:01:03.617]                           }
[17:01:03.617]                           if (!has_future || version < "1.8.0") {
[17:01:03.617]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.617]                               "", base::R.version$version.string), 
[17:01:03.617]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.617]                                 base::R.version$platform, 8 * 
[17:01:03.617]                                   base::.Machine$sizeof.pointer), 
[17:01:03.617]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.617]                                 "release", "version")], collapse = " "), 
[17:01:03.617]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.617]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.617]                               info)
[17:01:03.617]                             info <- base::paste(info, collapse = "; ")
[17:01:03.617]                             if (!has_future) {
[17:01:03.617]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.617]                                 info)
[17:01:03.617]                             }
[17:01:03.617]                             else {
[17:01:03.617]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.617]                                 info, version)
[17:01:03.617]                             }
[17:01:03.617]                             base::stop(msg)
[17:01:03.617]                           }
[17:01:03.617]                         })
[17:01:03.617]                       }
[17:01:03.617]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.617]                       base::options(mc.cores = 1L)
[17:01:03.617]                     }
[17:01:03.617]                     base::local({
[17:01:03.617]                       for (pkg in "future.apply") {
[17:01:03.617]                         base::loadNamespace(pkg)
[17:01:03.617]                         base::library(pkg, character.only = TRUE)
[17:01:03.617]                       }
[17:01:03.617]                     })
[17:01:03.617]                   }
[17:01:03.617]                   ...future.strategy.old <- future::plan("list")
[17:01:03.617]                   options(future.plan = NULL)
[17:01:03.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.617]                 }
[17:01:03.617]                 ...future.workdir <- getwd()
[17:01:03.617]             }
[17:01:03.617]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.617]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.617]         }
[17:01:03.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.617]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.617]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.617]             base::names(...future.oldOptions))
[17:01:03.617]     }
[17:01:03.617]     if (FALSE) {
[17:01:03.617]     }
[17:01:03.617]     else {
[17:01:03.617]         if (TRUE) {
[17:01:03.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.617]                 open = "w")
[17:01:03.617]         }
[17:01:03.617]         else {
[17:01:03.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.617]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.617]         }
[17:01:03.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.617]             base::sink(type = "output", split = FALSE)
[17:01:03.617]             base::close(...future.stdout)
[17:01:03.617]         }, add = TRUE)
[17:01:03.617]     }
[17:01:03.617]     ...future.frame <- base::sys.nframe()
[17:01:03.617]     ...future.conditions <- base::list()
[17:01:03.617]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.617]     if (FALSE) {
[17:01:03.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.617]     }
[17:01:03.617]     ...future.result <- base::tryCatch({
[17:01:03.617]         base::withCallingHandlers({
[17:01:03.617]             ...future.value <- base::withVisible(base::local({
[17:01:03.617]                 withCallingHandlers({
[17:01:03.617]                   {
[17:01:03.617]                     do.call(function(...) {
[17:01:03.617]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.617]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.617]                         ...future.globals.maxSize)) {
[17:01:03.617]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.617]                         on.exit(options(oopts), add = TRUE)
[17:01:03.617]                       }
[17:01:03.617]                       {
[17:01:03.617]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.617]                           FUN = function(jj) {
[17:01:03.617]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.617]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.617]                           })
[17:01:03.617]                       }
[17:01:03.617]                     }, args = future.call.arguments)
[17:01:03.617]                   }
[17:01:03.617]                 }, immediateCondition = function(cond) {
[17:01:03.617]                   save_rds <- function (object, pathname, ...) 
[17:01:03.617]                   {
[17:01:03.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.617]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.617]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.617]                         fi_tmp[["mtime"]])
[17:01:03.617]                     }
[17:01:03.617]                     tryCatch({
[17:01:03.617]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.617]                     }, error = function(ex) {
[17:01:03.617]                       msg <- conditionMessage(ex)
[17:01:03.617]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.617]                         fi_tmp[["mtime"]], msg)
[17:01:03.617]                       ex$message <- msg
[17:01:03.617]                       stop(ex)
[17:01:03.617]                     })
[17:01:03.617]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.617]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.617]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.617]                       fi <- file.info(pathname)
[17:01:03.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.617]                         fi[["size"]], fi[["mtime"]])
[17:01:03.617]                       stop(msg)
[17:01:03.617]                     }
[17:01:03.617]                     invisible(pathname)
[17:01:03.617]                   }
[17:01:03.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.617]                     rootPath = tempdir()) 
[17:01:03.617]                   {
[17:01:03.617]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.617]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.617]                       tmpdir = path, fileext = ".rds")
[17:01:03.617]                     save_rds(obj, file)
[17:01:03.617]                   }
[17:01:03.617]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.617]                   {
[17:01:03.617]                     inherits <- base::inherits
[17:01:03.617]                     invokeRestart <- base::invokeRestart
[17:01:03.617]                     is.null <- base::is.null
[17:01:03.617]                     muffled <- FALSE
[17:01:03.617]                     if (inherits(cond, "message")) {
[17:01:03.617]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.617]                       if (muffled) 
[17:01:03.617]                         invokeRestart("muffleMessage")
[17:01:03.617]                     }
[17:01:03.617]                     else if (inherits(cond, "warning")) {
[17:01:03.617]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.617]                       if (muffled) 
[17:01:03.617]                         invokeRestart("muffleWarning")
[17:01:03.617]                     }
[17:01:03.617]                     else if (inherits(cond, "condition")) {
[17:01:03.617]                       if (!is.null(pattern)) {
[17:01:03.617]                         computeRestarts <- base::computeRestarts
[17:01:03.617]                         grepl <- base::grepl
[17:01:03.617]                         restarts <- computeRestarts(cond)
[17:01:03.617]                         for (restart in restarts) {
[17:01:03.617]                           name <- restart$name
[17:01:03.617]                           if (is.null(name)) 
[17:01:03.617]                             next
[17:01:03.617]                           if (!grepl(pattern, name)) 
[17:01:03.617]                             next
[17:01:03.617]                           invokeRestart(restart)
[17:01:03.617]                           muffled <- TRUE
[17:01:03.617]                           break
[17:01:03.617]                         }
[17:01:03.617]                       }
[17:01:03.617]                     }
[17:01:03.617]                     invisible(muffled)
[17:01:03.617]                   }
[17:01:03.617]                   muffleCondition(cond)
[17:01:03.617]                 })
[17:01:03.617]             }))
[17:01:03.617]             future::FutureResult(value = ...future.value$value, 
[17:01:03.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.617]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.617]                     ...future.globalenv.names))
[17:01:03.617]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.617]         }, condition = base::local({
[17:01:03.617]             c <- base::c
[17:01:03.617]             inherits <- base::inherits
[17:01:03.617]             invokeRestart <- base::invokeRestart
[17:01:03.617]             length <- base::length
[17:01:03.617]             list <- base::list
[17:01:03.617]             seq.int <- base::seq.int
[17:01:03.617]             signalCondition <- base::signalCondition
[17:01:03.617]             sys.calls <- base::sys.calls
[17:01:03.617]             `[[` <- base::`[[`
[17:01:03.617]             `+` <- base::`+`
[17:01:03.617]             `<<-` <- base::`<<-`
[17:01:03.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.617]                   3L)]
[17:01:03.617]             }
[17:01:03.617]             function(cond) {
[17:01:03.617]                 is_error <- inherits(cond, "error")
[17:01:03.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.617]                   NULL)
[17:01:03.617]                 if (is_error) {
[17:01:03.617]                   sessionInformation <- function() {
[17:01:03.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.617]                       search = base::search(), system = base::Sys.info())
[17:01:03.617]                   }
[17:01:03.617]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.617]                     cond$call), session = sessionInformation(), 
[17:01:03.617]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.617]                   signalCondition(cond)
[17:01:03.617]                 }
[17:01:03.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.617]                 "immediateCondition"))) {
[17:01:03.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.617]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.617]                   if (TRUE && !signal) {
[17:01:03.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.617]                     {
[17:01:03.617]                       inherits <- base::inherits
[17:01:03.617]                       invokeRestart <- base::invokeRestart
[17:01:03.617]                       is.null <- base::is.null
[17:01:03.617]                       muffled <- FALSE
[17:01:03.617]                       if (inherits(cond, "message")) {
[17:01:03.617]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.617]                         if (muffled) 
[17:01:03.617]                           invokeRestart("muffleMessage")
[17:01:03.617]                       }
[17:01:03.617]                       else if (inherits(cond, "warning")) {
[17:01:03.617]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.617]                         if (muffled) 
[17:01:03.617]                           invokeRestart("muffleWarning")
[17:01:03.617]                       }
[17:01:03.617]                       else if (inherits(cond, "condition")) {
[17:01:03.617]                         if (!is.null(pattern)) {
[17:01:03.617]                           computeRestarts <- base::computeRestarts
[17:01:03.617]                           grepl <- base::grepl
[17:01:03.617]                           restarts <- computeRestarts(cond)
[17:01:03.617]                           for (restart in restarts) {
[17:01:03.617]                             name <- restart$name
[17:01:03.617]                             if (is.null(name)) 
[17:01:03.617]                               next
[17:01:03.617]                             if (!grepl(pattern, name)) 
[17:01:03.617]                               next
[17:01:03.617]                             invokeRestart(restart)
[17:01:03.617]                             muffled <- TRUE
[17:01:03.617]                             break
[17:01:03.617]                           }
[17:01:03.617]                         }
[17:01:03.617]                       }
[17:01:03.617]                       invisible(muffled)
[17:01:03.617]                     }
[17:01:03.617]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.617]                   }
[17:01:03.617]                 }
[17:01:03.617]                 else {
[17:01:03.617]                   if (TRUE) {
[17:01:03.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.617]                     {
[17:01:03.617]                       inherits <- base::inherits
[17:01:03.617]                       invokeRestart <- base::invokeRestart
[17:01:03.617]                       is.null <- base::is.null
[17:01:03.617]                       muffled <- FALSE
[17:01:03.617]                       if (inherits(cond, "message")) {
[17:01:03.617]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.617]                         if (muffled) 
[17:01:03.617]                           invokeRestart("muffleMessage")
[17:01:03.617]                       }
[17:01:03.617]                       else if (inherits(cond, "warning")) {
[17:01:03.617]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.617]                         if (muffled) 
[17:01:03.617]                           invokeRestart("muffleWarning")
[17:01:03.617]                       }
[17:01:03.617]                       else if (inherits(cond, "condition")) {
[17:01:03.617]                         if (!is.null(pattern)) {
[17:01:03.617]                           computeRestarts <- base::computeRestarts
[17:01:03.617]                           grepl <- base::grepl
[17:01:03.617]                           restarts <- computeRestarts(cond)
[17:01:03.617]                           for (restart in restarts) {
[17:01:03.617]                             name <- restart$name
[17:01:03.617]                             if (is.null(name)) 
[17:01:03.617]                               next
[17:01:03.617]                             if (!grepl(pattern, name)) 
[17:01:03.617]                               next
[17:01:03.617]                             invokeRestart(restart)
[17:01:03.617]                             muffled <- TRUE
[17:01:03.617]                             break
[17:01:03.617]                           }
[17:01:03.617]                         }
[17:01:03.617]                       }
[17:01:03.617]                       invisible(muffled)
[17:01:03.617]                     }
[17:01:03.617]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.617]                   }
[17:01:03.617]                 }
[17:01:03.617]             }
[17:01:03.617]         }))
[17:01:03.617]     }, error = function(ex) {
[17:01:03.617]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.617]                 ...future.rng), started = ...future.startTime, 
[17:01:03.617]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.617]             version = "1.8"), class = "FutureResult")
[17:01:03.617]     }, finally = {
[17:01:03.617]         if (!identical(...future.workdir, getwd())) 
[17:01:03.617]             setwd(...future.workdir)
[17:01:03.617]         {
[17:01:03.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.617]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.617]             }
[17:01:03.617]             base::options(...future.oldOptions)
[17:01:03.617]             if (.Platform$OS.type == "windows") {
[17:01:03.617]                 old_names <- names(...future.oldEnvVars)
[17:01:03.617]                 envs <- base::Sys.getenv()
[17:01:03.617]                 names <- names(envs)
[17:01:03.617]                 common <- intersect(names, old_names)
[17:01:03.617]                 added <- setdiff(names, old_names)
[17:01:03.617]                 removed <- setdiff(old_names, names)
[17:01:03.617]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.617]                   envs[common]]
[17:01:03.617]                 NAMES <- toupper(changed)
[17:01:03.617]                 args <- list()
[17:01:03.617]                 for (kk in seq_along(NAMES)) {
[17:01:03.617]                   name <- changed[[kk]]
[17:01:03.617]                   NAME <- NAMES[[kk]]
[17:01:03.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.617]                     next
[17:01:03.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.617]                 }
[17:01:03.617]                 NAMES <- toupper(added)
[17:01:03.617]                 for (kk in seq_along(NAMES)) {
[17:01:03.617]                   name <- added[[kk]]
[17:01:03.617]                   NAME <- NAMES[[kk]]
[17:01:03.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.617]                     next
[17:01:03.617]                   args[[name]] <- ""
[17:01:03.617]                 }
[17:01:03.617]                 NAMES <- toupper(removed)
[17:01:03.617]                 for (kk in seq_along(NAMES)) {
[17:01:03.617]                   name <- removed[[kk]]
[17:01:03.617]                   NAME <- NAMES[[kk]]
[17:01:03.617]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.617]                     next
[17:01:03.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.617]                 }
[17:01:03.617]                 if (length(args) > 0) 
[17:01:03.617]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.617]             }
[17:01:03.617]             else {
[17:01:03.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.617]             }
[17:01:03.617]             {
[17:01:03.617]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.617]                   0L) {
[17:01:03.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.617]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.617]                   base::options(opts)
[17:01:03.617]                 }
[17:01:03.617]                 {
[17:01:03.617]                   {
[17:01:03.617]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.617]                     NULL
[17:01:03.617]                   }
[17:01:03.617]                   options(future.plan = NULL)
[17:01:03.617]                   if (is.na(NA_character_)) 
[17:01:03.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.617]                     .init = FALSE)
[17:01:03.617]                 }
[17:01:03.617]             }
[17:01:03.617]         }
[17:01:03.617]     })
[17:01:03.617]     if (TRUE) {
[17:01:03.617]         base::sink(type = "output", split = FALSE)
[17:01:03.617]         if (TRUE) {
[17:01:03.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.617]         }
[17:01:03.617]         else {
[17:01:03.617]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.617]         }
[17:01:03.617]         base::close(...future.stdout)
[17:01:03.617]         ...future.stdout <- NULL
[17:01:03.617]     }
[17:01:03.617]     ...future.result$conditions <- ...future.conditions
[17:01:03.617]     ...future.result$finished <- base::Sys.time()
[17:01:03.617]     ...future.result
[17:01:03.617] }
[17:01:03.620] assign_globals() ...
[17:01:03.620] List of 11
[17:01:03.620]  $ ...future.FUN            :function (x, ...)  
[17:01:03.620]  $ x_FUN                    :function (x, y)  
[17:01:03.620]  $ times                    : int 15
[17:01:03.620]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.620]  $ stop_if_not              :function (...)  
[17:01:03.620]  $ dim                      : int [1:2] 3 5
[17:01:03.620]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.620]  $ future.call.arguments    :List of 1
[17:01:03.620]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:03.620]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.620]  $ ...future.elements_ii    :List of 2
[17:01:03.620]   ..$ C: num 70
[17:01:03.620]   ..$ D: num 80
[17:01:03.620]  $ ...future.seeds_ii       : NULL
[17:01:03.620]  $ ...future.globals.maxSize: NULL
[17:01:03.620]  - attr(*, "where")=List of 11
[17:01:03.620]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.620]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.620]  - attr(*, "resolved")= logi FALSE
[17:01:03.620]  - attr(*, "total_size")= num 98600
[17:01:03.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.620]  - attr(*, "already-done")= logi TRUE
[17:01:03.636] - copied ‘...future.FUN’ to environment
[17:01:03.636] - reassign environment for ‘x_FUN’
[17:01:03.636] - copied ‘x_FUN’ to environment
[17:01:03.636] - copied ‘times’ to environment
[17:01:03.637] - copied ‘stopf’ to environment
[17:01:03.637] - copied ‘stop_if_not’ to environment
[17:01:03.637] - copied ‘dim’ to environment
[17:01:03.637] - copied ‘valid_types’ to environment
[17:01:03.637] - copied ‘future.call.arguments’ to environment
[17:01:03.637] - copied ‘...future.elements_ii’ to environment
[17:01:03.637] - copied ‘...future.seeds_ii’ to environment
[17:01:03.637] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.638] assign_globals() ... done
[17:01:03.638] requestCore(): workers = 2
[17:01:03.640] MulticoreFuture started
[17:01:03.641] - Launch lazy future ... done
[17:01:03.642] run() for ‘MulticoreFuture’ ... done
[17:01:03.642] Created future:
[17:01:03.642] plan(): Setting new future strategy stack:
[17:01:03.643] List of future strategies:
[17:01:03.643] 1. sequential:
[17:01:03.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.643]    - tweaked: FALSE
[17:01:03.643]    - call: NULL
[17:01:03.645] plan(): nbrOfWorkers() = 1
[17:01:03.648] plan(): Setting new future strategy stack:
[17:01:03.648] List of future strategies:
[17:01:03.648] 1. multicore:
[17:01:03.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.648]    - tweaked: FALSE
[17:01:03.648]    - call: plan(strategy)
[17:01:03.654] plan(): nbrOfWorkers() = 2
[17:01:03.643] MulticoreFuture:
[17:01:03.643] Label: ‘future_vapply-2’
[17:01:03.643] Expression:
[17:01:03.643] {
[17:01:03.643]     do.call(function(...) {
[17:01:03.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.643]             on.exit(options(oopts), add = TRUE)
[17:01:03.643]         }
[17:01:03.643]         {
[17:01:03.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.643]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.643]             })
[17:01:03.643]         }
[17:01:03.643]     }, args = future.call.arguments)
[17:01:03.643] }
[17:01:03.643] Lazy evaluation: FALSE
[17:01:03.643] Asynchronous evaluation: TRUE
[17:01:03.643] Local evaluation: TRUE
[17:01:03.643] Environment: R_GlobalEnv
[17:01:03.643] Capture standard output: TRUE
[17:01:03.643] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.643] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.643] Packages: 1 packages (‘future.apply’)
[17:01:03.643] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.643] Resolved: TRUE
[17:01:03.643] Value: <not collected>
[17:01:03.643] Conditions captured: <none>
[17:01:03.643] Early signaling: FALSE
[17:01:03.643] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.643] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.655] Chunk #2 of 2 ... DONE
[17:01:03.655] Launching 2 futures (chunks) ... DONE
[17:01:03.656] Resolving 2 futures (chunks) ...
[17:01:03.656] resolve() on list ...
[17:01:03.656]  recursive: 0
[17:01:03.656]  length: 2
[17:01:03.656] 
[17:01:03.657] Future #1
[17:01:03.657] result() for MulticoreFuture ...
[17:01:03.658] result() for MulticoreFuture ...
[17:01:03.658] result() for MulticoreFuture ... done
[17:01:03.658] result() for MulticoreFuture ... done
[17:01:03.659] result() for MulticoreFuture ...
[17:01:03.659] result() for MulticoreFuture ... done
[17:01:03.659] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.659] - nx: 2
[17:01:03.659] - relay: TRUE
[17:01:03.660] - stdout: TRUE
[17:01:03.660] - signal: TRUE
[17:01:03.660] - resignal: FALSE
[17:01:03.660] - force: TRUE
[17:01:03.660] - relayed: [n=2] FALSE, FALSE
[17:01:03.661] - queued futures: [n=2] FALSE, FALSE
[17:01:03.661]  - until=1
[17:01:03.661]  - relaying element #1
[17:01:03.661] result() for MulticoreFuture ...
[17:01:03.661] result() for MulticoreFuture ... done
[17:01:03.662] result() for MulticoreFuture ...
[17:01:03.662] result() for MulticoreFuture ... done
[17:01:03.662] result() for MulticoreFuture ...
[17:01:03.662] result() for MulticoreFuture ... done
[17:01:03.662] result() for MulticoreFuture ...
[17:01:03.663] result() for MulticoreFuture ... done
[17:01:03.663] - relayed: [n=2] TRUE, FALSE
[17:01:03.663] - queued futures: [n=2] TRUE, FALSE
[17:01:03.663] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.663]  length: 1 (resolved future 1)
[17:01:03.664] Future #2
[17:01:03.664] result() for MulticoreFuture ...
[17:01:03.664] result() for MulticoreFuture ...
[17:01:03.665] result() for MulticoreFuture ... done
[17:01:03.665] result() for MulticoreFuture ... done
[17:01:03.665] result() for MulticoreFuture ...
[17:01:03.665] result() for MulticoreFuture ... done
[17:01:03.665] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.665] - nx: 2
[17:01:03.665] - relay: TRUE
[17:01:03.665] - stdout: TRUE
[17:01:03.666] - signal: TRUE
[17:01:03.666] - resignal: FALSE
[17:01:03.666] - force: TRUE
[17:01:03.666] - relayed: [n=2] TRUE, FALSE
[17:01:03.666] - queued futures: [n=2] TRUE, FALSE
[17:01:03.666]  - until=2
[17:01:03.666]  - relaying element #2
[17:01:03.666] result() for MulticoreFuture ...
[17:01:03.666] result() for MulticoreFuture ... done
[17:01:03.667] result() for MulticoreFuture ...
[17:01:03.667] result() for MulticoreFuture ... done
[17:01:03.667] result() for MulticoreFuture ...
[17:01:03.667] result() for MulticoreFuture ... done
[17:01:03.667] result() for MulticoreFuture ...
[17:01:03.667] result() for MulticoreFuture ... done
[17:01:03.667] - relayed: [n=2] TRUE, TRUE
[17:01:03.667] - queued futures: [n=2] TRUE, TRUE
[17:01:03.668] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.668]  length: 0 (resolved future 2)
[17:01:03.668] Relaying remaining futures
[17:01:03.668] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.668] - nx: 2
[17:01:03.668] - relay: TRUE
[17:01:03.668] - stdout: TRUE
[17:01:03.668] - signal: TRUE
[17:01:03.668] - resignal: FALSE
[17:01:03.668] - force: TRUE
[17:01:03.669] - relayed: [n=2] TRUE, TRUE
[17:01:03.669] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.669] - relayed: [n=2] TRUE, TRUE
[17:01:03.669] - queued futures: [n=2] TRUE, TRUE
[17:01:03.669] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.669] resolve() on list ... DONE
[17:01:03.669] result() for MulticoreFuture ...
[17:01:03.669] result() for MulticoreFuture ... done
[17:01:03.670] result() for MulticoreFuture ...
[17:01:03.670] result() for MulticoreFuture ... done
[17:01:03.670] result() for MulticoreFuture ...
[17:01:03.670] result() for MulticoreFuture ... done
[17:01:03.670] result() for MulticoreFuture ...
[17:01:03.670] result() for MulticoreFuture ... done
[17:01:03.670]  - Number of value chunks collected: 2
[17:01:03.670] Resolving 2 futures (chunks) ... DONE
[17:01:03.670] Reducing values from 2 chunks ...
[17:01:03.670]  - Number of values collected after concatenation: 4
[17:01:03.671]  - Number of values expected: 4
[17:01:03.671] Reducing values from 2 chunks ... DONE
[17:01:03.671] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:01:03.673] future_lapply() ...
[17:01:03.682] Number of chunks: 2
[17:01:03.682] getGlobalsAndPackagesXApply() ...
[17:01:03.682]  - future.globals: TRUE
[17:01:03.683] getGlobalsAndPackages() ...
[17:01:03.683] Searching for globals...
[17:01:03.687] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:03.687] Searching for globals ... DONE
[17:01:03.687] Resolving globals: FALSE
[17:01:03.688] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:01:03.689] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:03.689] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.689] - packages: [1] ‘future.apply’
[17:01:03.689] getGlobalsAndPackages() ... DONE
[17:01:03.689]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.689]  - needed namespaces: [n=1] ‘future.apply’
[17:01:03.689] Finding globals ... DONE
[17:01:03.690]  - use_args: TRUE
[17:01:03.690]  - Getting '...' globals ...
[17:01:03.690] resolve() on list ...
[17:01:03.690]  recursive: 0
[17:01:03.690]  length: 1
[17:01:03.690]  elements: ‘...’
[17:01:03.690]  length: 0 (resolved future 1)
[17:01:03.690] resolve() on list ... DONE
[17:01:03.691]    - '...' content: [n=0] 
[17:01:03.691] List of 1
[17:01:03.691]  $ ...: list()
[17:01:03.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.691]  - attr(*, "where")=List of 1
[17:01:03.691]   ..$ ...:<environment: 0x55aadb423d78> 
[17:01:03.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.691]  - attr(*, "resolved")= logi TRUE
[17:01:03.691]  - attr(*, "total_size")= num NA
[17:01:03.693]  - Getting '...' globals ... DONE
[17:01:03.693] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:03.694] List of 8
[17:01:03.694]  $ ...future.FUN:function (x, ...)  
[17:01:03.694]  $ x_FUN        :function (x)  
[17:01:03.694]  $ times        : int 1
[17:01:03.694]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.694]  $ stop_if_not  :function (...)  
[17:01:03.694]  $ dim          : NULL
[17:01:03.694]  $ valid_types  : chr "logical"
[17:01:03.694]  $ ...          : list()
[17:01:03.694]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.694]  - attr(*, "where")=List of 8
[17:01:03.694]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:03.694]   ..$ ...          :<environment: 0x55aadb423d78> 
[17:01:03.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.694]  - attr(*, "resolved")= logi FALSE
[17:01:03.694]  - attr(*, "total_size")= num 94200
[17:01:03.699] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:03.699] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.699] Number of futures (= number of chunks): 2
[17:01:03.699] Launching 2 futures (chunks) ...
[17:01:03.699] Chunk #1 of 2 ...
[17:01:03.700]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.700] getGlobalsAndPackages() ...
[17:01:03.700] Searching for globals...
[17:01:03.700] 
[17:01:03.700] Searching for globals ... DONE
[17:01:03.700] - globals: [0] <none>
[17:01:03.700] getGlobalsAndPackages() ... DONE
[17:01:03.700]    + additional globals found: [n=0] 
[17:01:03.701]    + additional namespaces needed: [n=0] 
[17:01:03.701]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.701]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.701]  - seeds: <none>
[17:01:03.701]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.701] getGlobalsAndPackages() ...
[17:01:03.701] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.701] Resolving globals: FALSE
[17:01:03.701] Tweak future expression to call with '...' arguments ...
[17:01:03.704] {
[17:01:03.704]     do.call(function(...) {
[17:01:03.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.704]             on.exit(options(oopts), add = TRUE)
[17:01:03.704]         }
[17:01:03.704]         {
[17:01:03.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.704]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.704]             })
[17:01:03.704]         }
[17:01:03.704]     }, args = future.call.arguments)
[17:01:03.704] }
[17:01:03.704] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.705] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.705] - packages: [1] ‘future.apply’
[17:01:03.705] getGlobalsAndPackages() ... DONE
[17:01:03.705] run() for ‘Future’ ...
[17:01:03.705] - state: ‘created’
[17:01:03.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.710] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.710]   - Field: ‘label’
[17:01:03.710]   - Field: ‘local’
[17:01:03.711]   - Field: ‘owner’
[17:01:03.711]   - Field: ‘envir’
[17:01:03.711]   - Field: ‘workers’
[17:01:03.711]   - Field: ‘packages’
[17:01:03.711]   - Field: ‘gc’
[17:01:03.711]   - Field: ‘job’
[17:01:03.711]   - Field: ‘conditions’
[17:01:03.711]   - Field: ‘expr’
[17:01:03.712]   - Field: ‘uuid’
[17:01:03.712]   - Field: ‘seed’
[17:01:03.712]   - Field: ‘version’
[17:01:03.712]   - Field: ‘result’
[17:01:03.712]   - Field: ‘asynchronous’
[17:01:03.712]   - Field: ‘calls’
[17:01:03.712]   - Field: ‘globals’
[17:01:03.712]   - Field: ‘stdout’
[17:01:03.713]   - Field: ‘earlySignal’
[17:01:03.713]   - Field: ‘lazy’
[17:01:03.713]   - Field: ‘state’
[17:01:03.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.713] - Launch lazy future ...
[17:01:03.713] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.714] Packages needed by future strategies (n = 0): <none>
[17:01:03.714] {
[17:01:03.714]     {
[17:01:03.714]         {
[17:01:03.714]             ...future.startTime <- base::Sys.time()
[17:01:03.714]             {
[17:01:03.714]                 {
[17:01:03.714]                   {
[17:01:03.714]                     {
[17:01:03.714]                       {
[17:01:03.714]                         base::local({
[17:01:03.714]                           has_future <- base::requireNamespace("future", 
[17:01:03.714]                             quietly = TRUE)
[17:01:03.714]                           if (has_future) {
[17:01:03.714]                             ns <- base::getNamespace("future")
[17:01:03.714]                             version <- ns[[".package"]][["version"]]
[17:01:03.714]                             if (is.null(version)) 
[17:01:03.714]                               version <- utils::packageVersion("future")
[17:01:03.714]                           }
[17:01:03.714]                           else {
[17:01:03.714]                             version <- NULL
[17:01:03.714]                           }
[17:01:03.714]                           if (!has_future || version < "1.8.0") {
[17:01:03.714]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.714]                               "", base::R.version$version.string), 
[17:01:03.714]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.714]                                 base::R.version$platform, 8 * 
[17:01:03.714]                                   base::.Machine$sizeof.pointer), 
[17:01:03.714]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.714]                                 "release", "version")], collapse = " "), 
[17:01:03.714]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.714]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.714]                               info)
[17:01:03.714]                             info <- base::paste(info, collapse = "; ")
[17:01:03.714]                             if (!has_future) {
[17:01:03.714]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.714]                                 info)
[17:01:03.714]                             }
[17:01:03.714]                             else {
[17:01:03.714]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.714]                                 info, version)
[17:01:03.714]                             }
[17:01:03.714]                             base::stop(msg)
[17:01:03.714]                           }
[17:01:03.714]                         })
[17:01:03.714]                       }
[17:01:03.714]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.714]                       base::options(mc.cores = 1L)
[17:01:03.714]                     }
[17:01:03.714]                     base::local({
[17:01:03.714]                       for (pkg in "future.apply") {
[17:01:03.714]                         base::loadNamespace(pkg)
[17:01:03.714]                         base::library(pkg, character.only = TRUE)
[17:01:03.714]                       }
[17:01:03.714]                     })
[17:01:03.714]                   }
[17:01:03.714]                   ...future.strategy.old <- future::plan("list")
[17:01:03.714]                   options(future.plan = NULL)
[17:01:03.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.714]                 }
[17:01:03.714]                 ...future.workdir <- getwd()
[17:01:03.714]             }
[17:01:03.714]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.714]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.714]         }
[17:01:03.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.714]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.714]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.714]             base::names(...future.oldOptions))
[17:01:03.714]     }
[17:01:03.714]     if (FALSE) {
[17:01:03.714]     }
[17:01:03.714]     else {
[17:01:03.714]         if (TRUE) {
[17:01:03.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.714]                 open = "w")
[17:01:03.714]         }
[17:01:03.714]         else {
[17:01:03.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.714]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.714]         }
[17:01:03.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.714]             base::sink(type = "output", split = FALSE)
[17:01:03.714]             base::close(...future.stdout)
[17:01:03.714]         }, add = TRUE)
[17:01:03.714]     }
[17:01:03.714]     ...future.frame <- base::sys.nframe()
[17:01:03.714]     ...future.conditions <- base::list()
[17:01:03.714]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.714]     if (FALSE) {
[17:01:03.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.714]     }
[17:01:03.714]     ...future.result <- base::tryCatch({
[17:01:03.714]         base::withCallingHandlers({
[17:01:03.714]             ...future.value <- base::withVisible(base::local({
[17:01:03.714]                 withCallingHandlers({
[17:01:03.714]                   {
[17:01:03.714]                     do.call(function(...) {
[17:01:03.714]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.714]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.714]                         ...future.globals.maxSize)) {
[17:01:03.714]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.714]                         on.exit(options(oopts), add = TRUE)
[17:01:03.714]                       }
[17:01:03.714]                       {
[17:01:03.714]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.714]                           FUN = function(jj) {
[17:01:03.714]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.714]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.714]                           })
[17:01:03.714]                       }
[17:01:03.714]                     }, args = future.call.arguments)
[17:01:03.714]                   }
[17:01:03.714]                 }, immediateCondition = function(cond) {
[17:01:03.714]                   save_rds <- function (object, pathname, ...) 
[17:01:03.714]                   {
[17:01:03.714]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.714]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.714]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.714]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.714]                         fi_tmp[["mtime"]])
[17:01:03.714]                     }
[17:01:03.714]                     tryCatch({
[17:01:03.714]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.714]                     }, error = function(ex) {
[17:01:03.714]                       msg <- conditionMessage(ex)
[17:01:03.714]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.714]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.714]                         fi_tmp[["mtime"]], msg)
[17:01:03.714]                       ex$message <- msg
[17:01:03.714]                       stop(ex)
[17:01:03.714]                     })
[17:01:03.714]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.714]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.714]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.714]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.714]                       fi <- file.info(pathname)
[17:01:03.714]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.714]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.714]                         fi[["size"]], fi[["mtime"]])
[17:01:03.714]                       stop(msg)
[17:01:03.714]                     }
[17:01:03.714]                     invisible(pathname)
[17:01:03.714]                   }
[17:01:03.714]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.714]                     rootPath = tempdir()) 
[17:01:03.714]                   {
[17:01:03.714]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.714]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.714]                       tmpdir = path, fileext = ".rds")
[17:01:03.714]                     save_rds(obj, file)
[17:01:03.714]                   }
[17:01:03.714]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.714]                   {
[17:01:03.714]                     inherits <- base::inherits
[17:01:03.714]                     invokeRestart <- base::invokeRestart
[17:01:03.714]                     is.null <- base::is.null
[17:01:03.714]                     muffled <- FALSE
[17:01:03.714]                     if (inherits(cond, "message")) {
[17:01:03.714]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.714]                       if (muffled) 
[17:01:03.714]                         invokeRestart("muffleMessage")
[17:01:03.714]                     }
[17:01:03.714]                     else if (inherits(cond, "warning")) {
[17:01:03.714]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.714]                       if (muffled) 
[17:01:03.714]                         invokeRestart("muffleWarning")
[17:01:03.714]                     }
[17:01:03.714]                     else if (inherits(cond, "condition")) {
[17:01:03.714]                       if (!is.null(pattern)) {
[17:01:03.714]                         computeRestarts <- base::computeRestarts
[17:01:03.714]                         grepl <- base::grepl
[17:01:03.714]                         restarts <- computeRestarts(cond)
[17:01:03.714]                         for (restart in restarts) {
[17:01:03.714]                           name <- restart$name
[17:01:03.714]                           if (is.null(name)) 
[17:01:03.714]                             next
[17:01:03.714]                           if (!grepl(pattern, name)) 
[17:01:03.714]                             next
[17:01:03.714]                           invokeRestart(restart)
[17:01:03.714]                           muffled <- TRUE
[17:01:03.714]                           break
[17:01:03.714]                         }
[17:01:03.714]                       }
[17:01:03.714]                     }
[17:01:03.714]                     invisible(muffled)
[17:01:03.714]                   }
[17:01:03.714]                   muffleCondition(cond)
[17:01:03.714]                 })
[17:01:03.714]             }))
[17:01:03.714]             future::FutureResult(value = ...future.value$value, 
[17:01:03.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.714]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.714]                     ...future.globalenv.names))
[17:01:03.714]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.714]         }, condition = base::local({
[17:01:03.714]             c <- base::c
[17:01:03.714]             inherits <- base::inherits
[17:01:03.714]             invokeRestart <- base::invokeRestart
[17:01:03.714]             length <- base::length
[17:01:03.714]             list <- base::list
[17:01:03.714]             seq.int <- base::seq.int
[17:01:03.714]             signalCondition <- base::signalCondition
[17:01:03.714]             sys.calls <- base::sys.calls
[17:01:03.714]             `[[` <- base::`[[`
[17:01:03.714]             `+` <- base::`+`
[17:01:03.714]             `<<-` <- base::`<<-`
[17:01:03.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.714]                   3L)]
[17:01:03.714]             }
[17:01:03.714]             function(cond) {
[17:01:03.714]                 is_error <- inherits(cond, "error")
[17:01:03.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.714]                   NULL)
[17:01:03.714]                 if (is_error) {
[17:01:03.714]                   sessionInformation <- function() {
[17:01:03.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.714]                       search = base::search(), system = base::Sys.info())
[17:01:03.714]                   }
[17:01:03.714]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.714]                     cond$call), session = sessionInformation(), 
[17:01:03.714]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.714]                   signalCondition(cond)
[17:01:03.714]                 }
[17:01:03.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.714]                 "immediateCondition"))) {
[17:01:03.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.714]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.714]                   if (TRUE && !signal) {
[17:01:03.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.714]                     {
[17:01:03.714]                       inherits <- base::inherits
[17:01:03.714]                       invokeRestart <- base::invokeRestart
[17:01:03.714]                       is.null <- base::is.null
[17:01:03.714]                       muffled <- FALSE
[17:01:03.714]                       if (inherits(cond, "message")) {
[17:01:03.714]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.714]                         if (muffled) 
[17:01:03.714]                           invokeRestart("muffleMessage")
[17:01:03.714]                       }
[17:01:03.714]                       else if (inherits(cond, "warning")) {
[17:01:03.714]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.714]                         if (muffled) 
[17:01:03.714]                           invokeRestart("muffleWarning")
[17:01:03.714]                       }
[17:01:03.714]                       else if (inherits(cond, "condition")) {
[17:01:03.714]                         if (!is.null(pattern)) {
[17:01:03.714]                           computeRestarts <- base::computeRestarts
[17:01:03.714]                           grepl <- base::grepl
[17:01:03.714]                           restarts <- computeRestarts(cond)
[17:01:03.714]                           for (restart in restarts) {
[17:01:03.714]                             name <- restart$name
[17:01:03.714]                             if (is.null(name)) 
[17:01:03.714]                               next
[17:01:03.714]                             if (!grepl(pattern, name)) 
[17:01:03.714]                               next
[17:01:03.714]                             invokeRestart(restart)
[17:01:03.714]                             muffled <- TRUE
[17:01:03.714]                             break
[17:01:03.714]                           }
[17:01:03.714]                         }
[17:01:03.714]                       }
[17:01:03.714]                       invisible(muffled)
[17:01:03.714]                     }
[17:01:03.714]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.714]                   }
[17:01:03.714]                 }
[17:01:03.714]                 else {
[17:01:03.714]                   if (TRUE) {
[17:01:03.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.714]                     {
[17:01:03.714]                       inherits <- base::inherits
[17:01:03.714]                       invokeRestart <- base::invokeRestart
[17:01:03.714]                       is.null <- base::is.null
[17:01:03.714]                       muffled <- FALSE
[17:01:03.714]                       if (inherits(cond, "message")) {
[17:01:03.714]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.714]                         if (muffled) 
[17:01:03.714]                           invokeRestart("muffleMessage")
[17:01:03.714]                       }
[17:01:03.714]                       else if (inherits(cond, "warning")) {
[17:01:03.714]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.714]                         if (muffled) 
[17:01:03.714]                           invokeRestart("muffleWarning")
[17:01:03.714]                       }
[17:01:03.714]                       else if (inherits(cond, "condition")) {
[17:01:03.714]                         if (!is.null(pattern)) {
[17:01:03.714]                           computeRestarts <- base::computeRestarts
[17:01:03.714]                           grepl <- base::grepl
[17:01:03.714]                           restarts <- computeRestarts(cond)
[17:01:03.714]                           for (restart in restarts) {
[17:01:03.714]                             name <- restart$name
[17:01:03.714]                             if (is.null(name)) 
[17:01:03.714]                               next
[17:01:03.714]                             if (!grepl(pattern, name)) 
[17:01:03.714]                               next
[17:01:03.714]                             invokeRestart(restart)
[17:01:03.714]                             muffled <- TRUE
[17:01:03.714]                             break
[17:01:03.714]                           }
[17:01:03.714]                         }
[17:01:03.714]                       }
[17:01:03.714]                       invisible(muffled)
[17:01:03.714]                     }
[17:01:03.714]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.714]                   }
[17:01:03.714]                 }
[17:01:03.714]             }
[17:01:03.714]         }))
[17:01:03.714]     }, error = function(ex) {
[17:01:03.714]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.714]                 ...future.rng), started = ...future.startTime, 
[17:01:03.714]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.714]             version = "1.8"), class = "FutureResult")
[17:01:03.714]     }, finally = {
[17:01:03.714]         if (!identical(...future.workdir, getwd())) 
[17:01:03.714]             setwd(...future.workdir)
[17:01:03.714]         {
[17:01:03.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.714]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.714]             }
[17:01:03.714]             base::options(...future.oldOptions)
[17:01:03.714]             if (.Platform$OS.type == "windows") {
[17:01:03.714]                 old_names <- names(...future.oldEnvVars)
[17:01:03.714]                 envs <- base::Sys.getenv()
[17:01:03.714]                 names <- names(envs)
[17:01:03.714]                 common <- intersect(names, old_names)
[17:01:03.714]                 added <- setdiff(names, old_names)
[17:01:03.714]                 removed <- setdiff(old_names, names)
[17:01:03.714]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.714]                   envs[common]]
[17:01:03.714]                 NAMES <- toupper(changed)
[17:01:03.714]                 args <- list()
[17:01:03.714]                 for (kk in seq_along(NAMES)) {
[17:01:03.714]                   name <- changed[[kk]]
[17:01:03.714]                   NAME <- NAMES[[kk]]
[17:01:03.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.714]                     next
[17:01:03.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.714]                 }
[17:01:03.714]                 NAMES <- toupper(added)
[17:01:03.714]                 for (kk in seq_along(NAMES)) {
[17:01:03.714]                   name <- added[[kk]]
[17:01:03.714]                   NAME <- NAMES[[kk]]
[17:01:03.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.714]                     next
[17:01:03.714]                   args[[name]] <- ""
[17:01:03.714]                 }
[17:01:03.714]                 NAMES <- toupper(removed)
[17:01:03.714]                 for (kk in seq_along(NAMES)) {
[17:01:03.714]                   name <- removed[[kk]]
[17:01:03.714]                   NAME <- NAMES[[kk]]
[17:01:03.714]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.714]                     next
[17:01:03.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.714]                 }
[17:01:03.714]                 if (length(args) > 0) 
[17:01:03.714]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.714]             }
[17:01:03.714]             else {
[17:01:03.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.714]             }
[17:01:03.714]             {
[17:01:03.714]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.714]                   0L) {
[17:01:03.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.714]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.714]                   base::options(opts)
[17:01:03.714]                 }
[17:01:03.714]                 {
[17:01:03.714]                   {
[17:01:03.714]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.714]                     NULL
[17:01:03.714]                   }
[17:01:03.714]                   options(future.plan = NULL)
[17:01:03.714]                   if (is.na(NA_character_)) 
[17:01:03.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.714]                     .init = FALSE)
[17:01:03.714]                 }
[17:01:03.714]             }
[17:01:03.714]         }
[17:01:03.714]     })
[17:01:03.714]     if (TRUE) {
[17:01:03.714]         base::sink(type = "output", split = FALSE)
[17:01:03.714]         if (TRUE) {
[17:01:03.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.714]         }
[17:01:03.714]         else {
[17:01:03.714]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.714]         }
[17:01:03.714]         base::close(...future.stdout)
[17:01:03.714]         ...future.stdout <- NULL
[17:01:03.714]     }
[17:01:03.714]     ...future.result$conditions <- ...future.conditions
[17:01:03.714]     ...future.result$finished <- base::Sys.time()
[17:01:03.714]     ...future.result
[17:01:03.714] }
[17:01:03.717] assign_globals() ...
[17:01:03.717] List of 11
[17:01:03.717]  $ ...future.FUN            :function (x, ...)  
[17:01:03.717]  $ x_FUN                    :function (x)  
[17:01:03.717]  $ times                    : int 1
[17:01:03.717]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.717]  $ stop_if_not              :function (...)  
[17:01:03.717]  $ dim                      : NULL
[17:01:03.717]  $ valid_types              : chr "logical"
[17:01:03.717]  $ future.call.arguments    : list()
[17:01:03.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.717]  $ ...future.elements_ii    :List of 6
[17:01:03.717]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:01:03.717]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:01:03.717]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:01:03.717]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:01:03.717]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:01:03.717]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:01:03.717]  $ ...future.seeds_ii       : NULL
[17:01:03.717]  $ ...future.globals.maxSize: NULL
[17:01:03.717]  - attr(*, "where")=List of 11
[17:01:03.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.717]  - attr(*, "resolved")= logi FALSE
[17:01:03.717]  - attr(*, "total_size")= num 94200
[17:01:03.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.717]  - attr(*, "already-done")= logi TRUE
[17:01:03.726] - copied ‘...future.FUN’ to environment
[17:01:03.726] - copied ‘x_FUN’ to environment
[17:01:03.726] - copied ‘times’ to environment
[17:01:03.727] - copied ‘stopf’ to environment
[17:01:03.727] - copied ‘stop_if_not’ to environment
[17:01:03.727] - copied ‘dim’ to environment
[17:01:03.727] - copied ‘valid_types’ to environment
[17:01:03.727] - copied ‘future.call.arguments’ to environment
[17:01:03.727] - copied ‘...future.elements_ii’ to environment
[17:01:03.727] - copied ‘...future.seeds_ii’ to environment
[17:01:03.727] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.727] assign_globals() ... done
[17:01:03.728] requestCore(): workers = 2
[17:01:03.730] MulticoreFuture started
[17:01:03.730] - Launch lazy future ... done
[17:01:03.730] run() for ‘MulticoreFuture’ ... done
[17:01:03.731] Created future:
[17:01:03.731] plan(): Setting new future strategy stack:
[17:01:03.732] List of future strategies:
[17:01:03.732] 1. sequential:
[17:01:03.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.732]    - tweaked: FALSE
[17:01:03.732]    - call: NULL
[17:01:03.733] plan(): nbrOfWorkers() = 1
[17:01:03.735] plan(): Setting new future strategy stack:
[17:01:03.735] List of future strategies:
[17:01:03.735] 1. multicore:
[17:01:03.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.735]    - tweaked: FALSE
[17:01:03.735]    - call: plan(strategy)
[17:01:03.731] MulticoreFuture:
[17:01:03.731] Label: ‘future_vapply-1’
[17:01:03.731] Expression:
[17:01:03.731] {
[17:01:03.731]     do.call(function(...) {
[17:01:03.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.731]             on.exit(options(oopts), add = TRUE)
[17:01:03.731]         }
[17:01:03.731]         {
[17:01:03.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.731]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.731]             })
[17:01:03.731]         }
[17:01:03.731]     }, args = future.call.arguments)
[17:01:03.731] }
[17:01:03.731] Lazy evaluation: FALSE
[17:01:03.731] Asynchronous evaluation: TRUE
[17:01:03.731] Local evaluation: TRUE
[17:01:03.731] Environment: R_GlobalEnv
[17:01:03.731] Capture standard output: TRUE
[17:01:03.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.731] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.731] Packages: 1 packages (‘future.apply’)
[17:01:03.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.731] Resolved: FALSE
[17:01:03.731] Value: <not collected>
[17:01:03.731] Conditions captured: <none>
[17:01:03.731] Early signaling: FALSE
[17:01:03.731] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.731] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.744] Chunk #1 of 2 ... DONE
[17:01:03.744] Chunk #2 of 2 ...
[17:01:03.745]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.748] getGlobalsAndPackages() ...
[17:01:03.748] plan(): nbrOfWorkers() = 2
[17:01:03.748] Searching for globals...
[17:01:03.749] 
[17:01:03.749] Searching for globals ... DONE
[17:01:03.749] - globals: [0] <none>
[17:01:03.749] getGlobalsAndPackages() ... DONE
[17:01:03.750]    + additional globals found: [n=0] 
[17:01:03.750]    + additional namespaces needed: [n=0] 
[17:01:03.750]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.750]  - seeds: <none>
[17:01:03.751]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.751] getGlobalsAndPackages() ...
[17:01:03.751] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.752] Resolving globals: FALSE
[17:01:03.752] Tweak future expression to call with '...' arguments ...
[17:01:03.752] {
[17:01:03.752]     do.call(function(...) {
[17:01:03.752]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.752]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.752]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.752]             on.exit(options(oopts), add = TRUE)
[17:01:03.752]         }
[17:01:03.752]         {
[17:01:03.752]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.752]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.752]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.752]             })
[17:01:03.752]         }
[17:01:03.752]     }, args = future.call.arguments)
[17:01:03.752] }
[17:01:03.753] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.754] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.755] - packages: [1] ‘future.apply’
[17:01:03.755] getGlobalsAndPackages() ... DONE
[17:01:03.756] run() for ‘Future’ ...
[17:01:03.756] - state: ‘created’
[17:01:03.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.761] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.762]   - Field: ‘label’
[17:01:03.762]   - Field: ‘local’
[17:01:03.762]   - Field: ‘owner’
[17:01:03.762]   - Field: ‘envir’
[17:01:03.763]   - Field: ‘workers’
[17:01:03.763]   - Field: ‘packages’
[17:01:03.763]   - Field: ‘gc’
[17:01:03.763]   - Field: ‘job’
[17:01:03.764]   - Field: ‘conditions’
[17:01:03.764]   - Field: ‘expr’
[17:01:03.764]   - Field: ‘uuid’
[17:01:03.764]   - Field: ‘seed’
[17:01:03.764]   - Field: ‘version’
[17:01:03.764]   - Field: ‘result’
[17:01:03.765]   - Field: ‘asynchronous’
[17:01:03.765]   - Field: ‘calls’
[17:01:03.765]   - Field: ‘globals’
[17:01:03.765]   - Field: ‘stdout’
[17:01:03.765]   - Field: ‘earlySignal’
[17:01:03.765]   - Field: ‘lazy’
[17:01:03.765]   - Field: ‘state’
[17:01:03.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.766] - Launch lazy future ...
[17:01:03.766] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.766] Packages needed by future strategies (n = 0): <none>
[17:01:03.767] {
[17:01:03.767]     {
[17:01:03.767]         {
[17:01:03.767]             ...future.startTime <- base::Sys.time()
[17:01:03.767]             {
[17:01:03.767]                 {
[17:01:03.767]                   {
[17:01:03.767]                     {
[17:01:03.767]                       {
[17:01:03.767]                         base::local({
[17:01:03.767]                           has_future <- base::requireNamespace("future", 
[17:01:03.767]                             quietly = TRUE)
[17:01:03.767]                           if (has_future) {
[17:01:03.767]                             ns <- base::getNamespace("future")
[17:01:03.767]                             version <- ns[[".package"]][["version"]]
[17:01:03.767]                             if (is.null(version)) 
[17:01:03.767]                               version <- utils::packageVersion("future")
[17:01:03.767]                           }
[17:01:03.767]                           else {
[17:01:03.767]                             version <- NULL
[17:01:03.767]                           }
[17:01:03.767]                           if (!has_future || version < "1.8.0") {
[17:01:03.767]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.767]                               "", base::R.version$version.string), 
[17:01:03.767]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.767]                                 base::R.version$platform, 8 * 
[17:01:03.767]                                   base::.Machine$sizeof.pointer), 
[17:01:03.767]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.767]                                 "release", "version")], collapse = " "), 
[17:01:03.767]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.767]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.767]                               info)
[17:01:03.767]                             info <- base::paste(info, collapse = "; ")
[17:01:03.767]                             if (!has_future) {
[17:01:03.767]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.767]                                 info)
[17:01:03.767]                             }
[17:01:03.767]                             else {
[17:01:03.767]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.767]                                 info, version)
[17:01:03.767]                             }
[17:01:03.767]                             base::stop(msg)
[17:01:03.767]                           }
[17:01:03.767]                         })
[17:01:03.767]                       }
[17:01:03.767]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.767]                       base::options(mc.cores = 1L)
[17:01:03.767]                     }
[17:01:03.767]                     base::local({
[17:01:03.767]                       for (pkg in "future.apply") {
[17:01:03.767]                         base::loadNamespace(pkg)
[17:01:03.767]                         base::library(pkg, character.only = TRUE)
[17:01:03.767]                       }
[17:01:03.767]                     })
[17:01:03.767]                   }
[17:01:03.767]                   ...future.strategy.old <- future::plan("list")
[17:01:03.767]                   options(future.plan = NULL)
[17:01:03.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.767]                 }
[17:01:03.767]                 ...future.workdir <- getwd()
[17:01:03.767]             }
[17:01:03.767]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.767]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.767]         }
[17:01:03.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.767]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.767]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.767]             base::names(...future.oldOptions))
[17:01:03.767]     }
[17:01:03.767]     if (FALSE) {
[17:01:03.767]     }
[17:01:03.767]     else {
[17:01:03.767]         if (TRUE) {
[17:01:03.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.767]                 open = "w")
[17:01:03.767]         }
[17:01:03.767]         else {
[17:01:03.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.767]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.767]         }
[17:01:03.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.767]             base::sink(type = "output", split = FALSE)
[17:01:03.767]             base::close(...future.stdout)
[17:01:03.767]         }, add = TRUE)
[17:01:03.767]     }
[17:01:03.767]     ...future.frame <- base::sys.nframe()
[17:01:03.767]     ...future.conditions <- base::list()
[17:01:03.767]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.767]     if (FALSE) {
[17:01:03.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.767]     }
[17:01:03.767]     ...future.result <- base::tryCatch({
[17:01:03.767]         base::withCallingHandlers({
[17:01:03.767]             ...future.value <- base::withVisible(base::local({
[17:01:03.767]                 withCallingHandlers({
[17:01:03.767]                   {
[17:01:03.767]                     do.call(function(...) {
[17:01:03.767]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.767]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.767]                         ...future.globals.maxSize)) {
[17:01:03.767]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.767]                         on.exit(options(oopts), add = TRUE)
[17:01:03.767]                       }
[17:01:03.767]                       {
[17:01:03.767]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.767]                           FUN = function(jj) {
[17:01:03.767]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.767]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.767]                           })
[17:01:03.767]                       }
[17:01:03.767]                     }, args = future.call.arguments)
[17:01:03.767]                   }
[17:01:03.767]                 }, immediateCondition = function(cond) {
[17:01:03.767]                   save_rds <- function (object, pathname, ...) 
[17:01:03.767]                   {
[17:01:03.767]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.767]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.767]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.767]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.767]                         fi_tmp[["mtime"]])
[17:01:03.767]                     }
[17:01:03.767]                     tryCatch({
[17:01:03.767]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.767]                     }, error = function(ex) {
[17:01:03.767]                       msg <- conditionMessage(ex)
[17:01:03.767]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.767]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.767]                         fi_tmp[["mtime"]], msg)
[17:01:03.767]                       ex$message <- msg
[17:01:03.767]                       stop(ex)
[17:01:03.767]                     })
[17:01:03.767]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.767]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.767]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.767]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.767]                       fi <- file.info(pathname)
[17:01:03.767]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.767]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.767]                         fi[["size"]], fi[["mtime"]])
[17:01:03.767]                       stop(msg)
[17:01:03.767]                     }
[17:01:03.767]                     invisible(pathname)
[17:01:03.767]                   }
[17:01:03.767]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.767]                     rootPath = tempdir()) 
[17:01:03.767]                   {
[17:01:03.767]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.767]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.767]                       tmpdir = path, fileext = ".rds")
[17:01:03.767]                     save_rds(obj, file)
[17:01:03.767]                   }
[17:01:03.767]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.767]                   {
[17:01:03.767]                     inherits <- base::inherits
[17:01:03.767]                     invokeRestart <- base::invokeRestart
[17:01:03.767]                     is.null <- base::is.null
[17:01:03.767]                     muffled <- FALSE
[17:01:03.767]                     if (inherits(cond, "message")) {
[17:01:03.767]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.767]                       if (muffled) 
[17:01:03.767]                         invokeRestart("muffleMessage")
[17:01:03.767]                     }
[17:01:03.767]                     else if (inherits(cond, "warning")) {
[17:01:03.767]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.767]                       if (muffled) 
[17:01:03.767]                         invokeRestart("muffleWarning")
[17:01:03.767]                     }
[17:01:03.767]                     else if (inherits(cond, "condition")) {
[17:01:03.767]                       if (!is.null(pattern)) {
[17:01:03.767]                         computeRestarts <- base::computeRestarts
[17:01:03.767]                         grepl <- base::grepl
[17:01:03.767]                         restarts <- computeRestarts(cond)
[17:01:03.767]                         for (restart in restarts) {
[17:01:03.767]                           name <- restart$name
[17:01:03.767]                           if (is.null(name)) 
[17:01:03.767]                             next
[17:01:03.767]                           if (!grepl(pattern, name)) 
[17:01:03.767]                             next
[17:01:03.767]                           invokeRestart(restart)
[17:01:03.767]                           muffled <- TRUE
[17:01:03.767]                           break
[17:01:03.767]                         }
[17:01:03.767]                       }
[17:01:03.767]                     }
[17:01:03.767]                     invisible(muffled)
[17:01:03.767]                   }
[17:01:03.767]                   muffleCondition(cond)
[17:01:03.767]                 })
[17:01:03.767]             }))
[17:01:03.767]             future::FutureResult(value = ...future.value$value, 
[17:01:03.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.767]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.767]                     ...future.globalenv.names))
[17:01:03.767]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.767]         }, condition = base::local({
[17:01:03.767]             c <- base::c
[17:01:03.767]             inherits <- base::inherits
[17:01:03.767]             invokeRestart <- base::invokeRestart
[17:01:03.767]             length <- base::length
[17:01:03.767]             list <- base::list
[17:01:03.767]             seq.int <- base::seq.int
[17:01:03.767]             signalCondition <- base::signalCondition
[17:01:03.767]             sys.calls <- base::sys.calls
[17:01:03.767]             `[[` <- base::`[[`
[17:01:03.767]             `+` <- base::`+`
[17:01:03.767]             `<<-` <- base::`<<-`
[17:01:03.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.767]                   3L)]
[17:01:03.767]             }
[17:01:03.767]             function(cond) {
[17:01:03.767]                 is_error <- inherits(cond, "error")
[17:01:03.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.767]                   NULL)
[17:01:03.767]                 if (is_error) {
[17:01:03.767]                   sessionInformation <- function() {
[17:01:03.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.767]                       search = base::search(), system = base::Sys.info())
[17:01:03.767]                   }
[17:01:03.767]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.767]                     cond$call), session = sessionInformation(), 
[17:01:03.767]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.767]                   signalCondition(cond)
[17:01:03.767]                 }
[17:01:03.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.767]                 "immediateCondition"))) {
[17:01:03.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.767]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.767]                   if (TRUE && !signal) {
[17:01:03.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.767]                     {
[17:01:03.767]                       inherits <- base::inherits
[17:01:03.767]                       invokeRestart <- base::invokeRestart
[17:01:03.767]                       is.null <- base::is.null
[17:01:03.767]                       muffled <- FALSE
[17:01:03.767]                       if (inherits(cond, "message")) {
[17:01:03.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.767]                         if (muffled) 
[17:01:03.767]                           invokeRestart("muffleMessage")
[17:01:03.767]                       }
[17:01:03.767]                       else if (inherits(cond, "warning")) {
[17:01:03.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.767]                         if (muffled) 
[17:01:03.767]                           invokeRestart("muffleWarning")
[17:01:03.767]                       }
[17:01:03.767]                       else if (inherits(cond, "condition")) {
[17:01:03.767]                         if (!is.null(pattern)) {
[17:01:03.767]                           computeRestarts <- base::computeRestarts
[17:01:03.767]                           grepl <- base::grepl
[17:01:03.767]                           restarts <- computeRestarts(cond)
[17:01:03.767]                           for (restart in restarts) {
[17:01:03.767]                             name <- restart$name
[17:01:03.767]                             if (is.null(name)) 
[17:01:03.767]                               next
[17:01:03.767]                             if (!grepl(pattern, name)) 
[17:01:03.767]                               next
[17:01:03.767]                             invokeRestart(restart)
[17:01:03.767]                             muffled <- TRUE
[17:01:03.767]                             break
[17:01:03.767]                           }
[17:01:03.767]                         }
[17:01:03.767]                       }
[17:01:03.767]                       invisible(muffled)
[17:01:03.767]                     }
[17:01:03.767]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.767]                   }
[17:01:03.767]                 }
[17:01:03.767]                 else {
[17:01:03.767]                   if (TRUE) {
[17:01:03.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.767]                     {
[17:01:03.767]                       inherits <- base::inherits
[17:01:03.767]                       invokeRestart <- base::invokeRestart
[17:01:03.767]                       is.null <- base::is.null
[17:01:03.767]                       muffled <- FALSE
[17:01:03.767]                       if (inherits(cond, "message")) {
[17:01:03.767]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.767]                         if (muffled) 
[17:01:03.767]                           invokeRestart("muffleMessage")
[17:01:03.767]                       }
[17:01:03.767]                       else if (inherits(cond, "warning")) {
[17:01:03.767]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.767]                         if (muffled) 
[17:01:03.767]                           invokeRestart("muffleWarning")
[17:01:03.767]                       }
[17:01:03.767]                       else if (inherits(cond, "condition")) {
[17:01:03.767]                         if (!is.null(pattern)) {
[17:01:03.767]                           computeRestarts <- base::computeRestarts
[17:01:03.767]                           grepl <- base::grepl
[17:01:03.767]                           restarts <- computeRestarts(cond)
[17:01:03.767]                           for (restart in restarts) {
[17:01:03.767]                             name <- restart$name
[17:01:03.767]                             if (is.null(name)) 
[17:01:03.767]                               next
[17:01:03.767]                             if (!grepl(pattern, name)) 
[17:01:03.767]                               next
[17:01:03.767]                             invokeRestart(restart)
[17:01:03.767]                             muffled <- TRUE
[17:01:03.767]                             break
[17:01:03.767]                           }
[17:01:03.767]                         }
[17:01:03.767]                       }
[17:01:03.767]                       invisible(muffled)
[17:01:03.767]                     }
[17:01:03.767]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.767]                   }
[17:01:03.767]                 }
[17:01:03.767]             }
[17:01:03.767]         }))
[17:01:03.767]     }, error = function(ex) {
[17:01:03.767]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.767]                 ...future.rng), started = ...future.startTime, 
[17:01:03.767]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.767]             version = "1.8"), class = "FutureResult")
[17:01:03.767]     }, finally = {
[17:01:03.767]         if (!identical(...future.workdir, getwd())) 
[17:01:03.767]             setwd(...future.workdir)
[17:01:03.767]         {
[17:01:03.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.767]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.767]             }
[17:01:03.767]             base::options(...future.oldOptions)
[17:01:03.767]             if (.Platform$OS.type == "windows") {
[17:01:03.767]                 old_names <- names(...future.oldEnvVars)
[17:01:03.767]                 envs <- base::Sys.getenv()
[17:01:03.767]                 names <- names(envs)
[17:01:03.767]                 common <- intersect(names, old_names)
[17:01:03.767]                 added <- setdiff(names, old_names)
[17:01:03.767]                 removed <- setdiff(old_names, names)
[17:01:03.767]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.767]                   envs[common]]
[17:01:03.767]                 NAMES <- toupper(changed)
[17:01:03.767]                 args <- list()
[17:01:03.767]                 for (kk in seq_along(NAMES)) {
[17:01:03.767]                   name <- changed[[kk]]
[17:01:03.767]                   NAME <- NAMES[[kk]]
[17:01:03.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.767]                     next
[17:01:03.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.767]                 }
[17:01:03.767]                 NAMES <- toupper(added)
[17:01:03.767]                 for (kk in seq_along(NAMES)) {
[17:01:03.767]                   name <- added[[kk]]
[17:01:03.767]                   NAME <- NAMES[[kk]]
[17:01:03.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.767]                     next
[17:01:03.767]                   args[[name]] <- ""
[17:01:03.767]                 }
[17:01:03.767]                 NAMES <- toupper(removed)
[17:01:03.767]                 for (kk in seq_along(NAMES)) {
[17:01:03.767]                   name <- removed[[kk]]
[17:01:03.767]                   NAME <- NAMES[[kk]]
[17:01:03.767]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.767]                     next
[17:01:03.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.767]                 }
[17:01:03.767]                 if (length(args) > 0) 
[17:01:03.767]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.767]             }
[17:01:03.767]             else {
[17:01:03.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.767]             }
[17:01:03.767]             {
[17:01:03.767]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.767]                   0L) {
[17:01:03.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.767]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.767]                   base::options(opts)
[17:01:03.767]                 }
[17:01:03.767]                 {
[17:01:03.767]                   {
[17:01:03.767]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.767]                     NULL
[17:01:03.767]                   }
[17:01:03.767]                   options(future.plan = NULL)
[17:01:03.767]                   if (is.na(NA_character_)) 
[17:01:03.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.767]                     .init = FALSE)
[17:01:03.767]                 }
[17:01:03.767]             }
[17:01:03.767]         }
[17:01:03.767]     })
[17:01:03.767]     if (TRUE) {
[17:01:03.767]         base::sink(type = "output", split = FALSE)
[17:01:03.767]         if (TRUE) {
[17:01:03.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.767]         }
[17:01:03.767]         else {
[17:01:03.767]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.767]         }
[17:01:03.767]         base::close(...future.stdout)
[17:01:03.767]         ...future.stdout <- NULL
[17:01:03.767]     }
[17:01:03.767]     ...future.result$conditions <- ...future.conditions
[17:01:03.767]     ...future.result$finished <- base::Sys.time()
[17:01:03.767]     ...future.result
[17:01:03.767] }
[17:01:03.770] assign_globals() ...
[17:01:03.770] List of 11
[17:01:03.770]  $ ...future.FUN            :function (x, ...)  
[17:01:03.770]  $ x_FUN                    :function (x)  
[17:01:03.770]  $ times                    : int 1
[17:01:03.770]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.770]  $ stop_if_not              :function (...)  
[17:01:03.770]  $ dim                      : NULL
[17:01:03.770]  $ valid_types              : chr "logical"
[17:01:03.770]  $ future.call.arguments    : list()
[17:01:03.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.770]  $ ...future.elements_ii    :List of 5
[17:01:03.770]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:01:03.770]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:01:03.770]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:01:03.770]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:01:03.770]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:01:03.770]  $ ...future.seeds_ii       : NULL
[17:01:03.770]  $ ...future.globals.maxSize: NULL
[17:01:03.770]  - attr(*, "where")=List of 11
[17:01:03.770]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.770]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.770]  - attr(*, "resolved")= logi FALSE
[17:01:03.770]  - attr(*, "total_size")= num 94200
[17:01:03.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.770]  - attr(*, "already-done")= logi TRUE
[17:01:03.780] - copied ‘...future.FUN’ to environment
[17:01:03.781] - copied ‘x_FUN’ to environment
[17:01:03.781] - copied ‘times’ to environment
[17:01:03.781] - copied ‘stopf’ to environment
[17:01:03.781] - copied ‘stop_if_not’ to environment
[17:01:03.781] - copied ‘dim’ to environment
[17:01:03.781] - copied ‘valid_types’ to environment
[17:01:03.781] - copied ‘future.call.arguments’ to environment
[17:01:03.781] - copied ‘...future.elements_ii’ to environment
[17:01:03.781] - copied ‘...future.seeds_ii’ to environment
[17:01:03.781] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.782] assign_globals() ... done
[17:01:03.782] requestCore(): workers = 2
[17:01:03.784] MulticoreFuture started
[17:01:03.784] - Launch lazy future ... done
[17:01:03.789] run() for ‘MulticoreFuture’ ... done
[17:01:03.789] Created future:
[17:01:03.789] plan(): Setting new future strategy stack:
[17:01:03.790] List of future strategies:
[17:01:03.790] 1. sequential:
[17:01:03.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.790]    - tweaked: FALSE
[17:01:03.790]    - call: NULL
[17:01:03.792] plan(): nbrOfWorkers() = 1
[17:01:03.794] plan(): Setting new future strategy stack:
[17:01:03.794] List of future strategies:
[17:01:03.794] 1. multicore:
[17:01:03.794]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.794]    - tweaked: FALSE
[17:01:03.794]    - call: plan(strategy)
[17:01:03.801] plan(): nbrOfWorkers() = 2
[17:01:03.790] MulticoreFuture:
[17:01:03.790] Label: ‘future_vapply-2’
[17:01:03.790] Expression:
[17:01:03.790] {
[17:01:03.790]     do.call(function(...) {
[17:01:03.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.790]             on.exit(options(oopts), add = TRUE)
[17:01:03.790]         }
[17:01:03.790]         {
[17:01:03.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.790]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.790]             })
[17:01:03.790]         }
[17:01:03.790]     }, args = future.call.arguments)
[17:01:03.790] }
[17:01:03.790] Lazy evaluation: FALSE
[17:01:03.790] Asynchronous evaluation: TRUE
[17:01:03.790] Local evaluation: TRUE
[17:01:03.790] Environment: R_GlobalEnv
[17:01:03.790] Capture standard output: TRUE
[17:01:03.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.790] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.790] Packages: 1 packages (‘future.apply’)
[17:01:03.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.790] Resolved: TRUE
[17:01:03.790] Value: <not collected>
[17:01:03.790] Conditions captured: <none>
[17:01:03.790] Early signaling: FALSE
[17:01:03.790] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.790] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.802] Chunk #2 of 2 ... DONE
[17:01:03.802] Launching 2 futures (chunks) ... DONE
[17:01:03.803] Resolving 2 futures (chunks) ...
[17:01:03.803] resolve() on list ...
[17:01:03.803]  recursive: 0
[17:01:03.803]  length: 2
[17:01:03.804] 
[17:01:03.804] Future #1
[17:01:03.804] result() for MulticoreFuture ...
[17:01:03.805] result() for MulticoreFuture ...
[17:01:03.805] result() for MulticoreFuture ... done
[17:01:03.806] result() for MulticoreFuture ... done
[17:01:03.806] result() for MulticoreFuture ...
[17:01:03.806] result() for MulticoreFuture ... done
[17:01:03.806] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.806] - nx: 2
[17:01:03.807] - relay: TRUE
[17:01:03.807] - stdout: TRUE
[17:01:03.807] - signal: TRUE
[17:01:03.807] - resignal: FALSE
[17:01:03.807] - force: TRUE
[17:01:03.808] - relayed: [n=2] FALSE, FALSE
[17:01:03.808] - queued futures: [n=2] FALSE, FALSE
[17:01:03.808]  - until=1
[17:01:03.808]  - relaying element #1
[17:01:03.808] result() for MulticoreFuture ...
[17:01:03.809] result() for MulticoreFuture ... done
[17:01:03.809] result() for MulticoreFuture ...
[17:01:03.809] result() for MulticoreFuture ... done
[17:01:03.809] result() for MulticoreFuture ...
[17:01:03.810] result() for MulticoreFuture ... done
[17:01:03.810] result() for MulticoreFuture ...
[17:01:03.810] result() for MulticoreFuture ... done
[17:01:03.810] - relayed: [n=2] TRUE, FALSE
[17:01:03.810] - queued futures: [n=2] TRUE, FALSE
[17:01:03.810] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.811]  length: 1 (resolved future 1)
[17:01:03.811] Future #2
[17:01:03.811] result() for MulticoreFuture ...
[17:01:03.812] result() for MulticoreFuture ...
[17:01:03.812] result() for MulticoreFuture ... done
[17:01:03.813] result() for MulticoreFuture ... done
[17:01:03.813] result() for MulticoreFuture ...
[17:01:03.813] result() for MulticoreFuture ... done
[17:01:03.813] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.813] - nx: 2
[17:01:03.814] - relay: TRUE
[17:01:03.814] - stdout: TRUE
[17:01:03.814] - signal: TRUE
[17:01:03.814] - resignal: FALSE
[17:01:03.814] - force: TRUE
[17:01:03.814] - relayed: [n=2] TRUE, FALSE
[17:01:03.814] - queued futures: [n=2] TRUE, FALSE
[17:01:03.814]  - until=2
[17:01:03.814]  - relaying element #2
[17:01:03.814] result() for MulticoreFuture ...
[17:01:03.815] result() for MulticoreFuture ... done
[17:01:03.815] result() for MulticoreFuture ...
[17:01:03.815] result() for MulticoreFuture ... done
[17:01:03.815] result() for MulticoreFuture ...
[17:01:03.815] result() for MulticoreFuture ... done
[17:01:03.815] result() for MulticoreFuture ...
[17:01:03.815] result() for MulticoreFuture ... done
[17:01:03.815] - relayed: [n=2] TRUE, TRUE
[17:01:03.816] - queued futures: [n=2] TRUE, TRUE
[17:01:03.816] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.816]  length: 0 (resolved future 2)
[17:01:03.816] Relaying remaining futures
[17:01:03.816] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.816] - nx: 2
[17:01:03.816] - relay: TRUE
[17:01:03.816] - stdout: TRUE
[17:01:03.816] - signal: TRUE
[17:01:03.816] - resignal: FALSE
[17:01:03.817] - force: TRUE
[17:01:03.817] - relayed: [n=2] TRUE, TRUE
[17:01:03.817] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.817] - relayed: [n=2] TRUE, TRUE
[17:01:03.817] - queued futures: [n=2] TRUE, TRUE
[17:01:03.817] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.817] resolve() on list ... DONE
[17:01:03.817] result() for MulticoreFuture ...
[17:01:03.817] result() for MulticoreFuture ... done
[17:01:03.817] result() for MulticoreFuture ...
[17:01:03.818] result() for MulticoreFuture ... done
[17:01:03.818] result() for MulticoreFuture ...
[17:01:03.818] result() for MulticoreFuture ... done
[17:01:03.818] result() for MulticoreFuture ...
[17:01:03.818] result() for MulticoreFuture ... done
[17:01:03.818]  - Number of value chunks collected: 2
[17:01:03.818] Resolving 2 futures (chunks) ... DONE
[17:01:03.818] Reducing values from 2 chunks ...
[17:01:03.818]  - Number of values collected after concatenation: 11
[17:01:03.818]  - Number of values expected: 11
[17:01:03.819] Reducing values from 2 chunks ... DONE
[17:01:03.819] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:01:03.820] future_lapply() ...
[17:01:03.826] Number of chunks: 2
[17:01:03.826] getGlobalsAndPackagesXApply() ...
[17:01:03.826]  - future.globals: TRUE
[17:01:03.826] getGlobalsAndPackages() ...
[17:01:03.826] Searching for globals...
[17:01:03.829] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:03.829] Searching for globals ... DONE
[17:01:03.829] Resolving globals: FALSE
[17:01:03.833] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:01:03.833] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:03.833] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.834] - packages: [1] ‘future.apply’
[17:01:03.834] getGlobalsAndPackages() ... DONE
[17:01:03.834]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.834]  - needed namespaces: [n=1] ‘future.apply’
[17:01:03.834] Finding globals ... DONE
[17:01:03.834]  - use_args: TRUE
[17:01:03.834]  - Getting '...' globals ...
[17:01:03.835] resolve() on list ...
[17:01:03.835]  recursive: 0
[17:01:03.835]  length: 1
[17:01:03.835]  elements: ‘...’
[17:01:03.835]  length: 0 (resolved future 1)
[17:01:03.835] resolve() on list ... DONE
[17:01:03.835]    - '...' content: [n=0] 
[17:01:03.836] List of 1
[17:01:03.836]  $ ...: list()
[17:01:03.836]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.836]  - attr(*, "where")=List of 1
[17:01:03.836]   ..$ ...:<environment: 0x55aad9c72b30> 
[17:01:03.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.836]  - attr(*, "resolved")= logi TRUE
[17:01:03.836]  - attr(*, "total_size")= num NA
[17:01:03.839]  - Getting '...' globals ... DONE
[17:01:03.839] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:03.839] List of 8
[17:01:03.839]  $ ...future.FUN:function (x, ...)  
[17:01:03.839]  $ x_FUN        :function (x)  
[17:01:03.839]  $ times        : int 1
[17:01:03.839]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.839]  $ stop_if_not  :function (...)  
[17:01:03.839]  $ dim          : NULL
[17:01:03.839]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:03.839]  $ ...          : list()
[17:01:03.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.839]  - attr(*, "where")=List of 8
[17:01:03.839]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:03.839]   ..$ ...          :<environment: 0x55aad9c72b30> 
[17:01:03.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.839]  - attr(*, "resolved")= logi FALSE
[17:01:03.839]  - attr(*, "total_size")= num 94264
[17:01:03.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:03.845] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.845] Number of futures (= number of chunks): 2
[17:01:03.845] Launching 2 futures (chunks) ...
[17:01:03.845] Chunk #1 of 2 ...
[17:01:03.845]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.845] getGlobalsAndPackages() ...
[17:01:03.845] Searching for globals...
[17:01:03.846] 
[17:01:03.846] Searching for globals ... DONE
[17:01:03.846] - globals: [0] <none>
[17:01:03.846] getGlobalsAndPackages() ... DONE
[17:01:03.846]    + additional globals found: [n=0] 
[17:01:03.846]    + additional namespaces needed: [n=0] 
[17:01:03.846]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.846]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.846]  - seeds: <none>
[17:01:03.847]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.847] getGlobalsAndPackages() ...
[17:01:03.847] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.847] Resolving globals: FALSE
[17:01:03.847] Tweak future expression to call with '...' arguments ...
[17:01:03.847] {
[17:01:03.847]     do.call(function(...) {
[17:01:03.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.847]             on.exit(options(oopts), add = TRUE)
[17:01:03.847]         }
[17:01:03.847]         {
[17:01:03.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.847]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.847]             })
[17:01:03.847]         }
[17:01:03.847]     }, args = future.call.arguments)
[17:01:03.847] }
[17:01:03.847] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.848] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.848] - packages: [1] ‘future.apply’
[17:01:03.848] getGlobalsAndPackages() ... DONE
[17:01:03.849] run() for ‘Future’ ...
[17:01:03.849] - state: ‘created’
[17:01:03.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.853] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.853]   - Field: ‘label’
[17:01:03.853]   - Field: ‘local’
[17:01:03.853]   - Field: ‘owner’
[17:01:03.853]   - Field: ‘envir’
[17:01:03.853]   - Field: ‘workers’
[17:01:03.853]   - Field: ‘packages’
[17:01:03.853]   - Field: ‘gc’
[17:01:03.854]   - Field: ‘job’
[17:01:03.854]   - Field: ‘conditions’
[17:01:03.854]   - Field: ‘expr’
[17:01:03.854]   - Field: ‘uuid’
[17:01:03.854]   - Field: ‘seed’
[17:01:03.854]   - Field: ‘version’
[17:01:03.854]   - Field: ‘result’
[17:01:03.854]   - Field: ‘asynchronous’
[17:01:03.854]   - Field: ‘calls’
[17:01:03.854]   - Field: ‘globals’
[17:01:03.854]   - Field: ‘stdout’
[17:01:03.855]   - Field: ‘earlySignal’
[17:01:03.855]   - Field: ‘lazy’
[17:01:03.855]   - Field: ‘state’
[17:01:03.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.857] - Launch lazy future ...
[17:01:03.857] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.858] Packages needed by future strategies (n = 0): <none>
[17:01:03.858] {
[17:01:03.858]     {
[17:01:03.858]         {
[17:01:03.858]             ...future.startTime <- base::Sys.time()
[17:01:03.858]             {
[17:01:03.858]                 {
[17:01:03.858]                   {
[17:01:03.858]                     {
[17:01:03.858]                       {
[17:01:03.858]                         base::local({
[17:01:03.858]                           has_future <- base::requireNamespace("future", 
[17:01:03.858]                             quietly = TRUE)
[17:01:03.858]                           if (has_future) {
[17:01:03.858]                             ns <- base::getNamespace("future")
[17:01:03.858]                             version <- ns[[".package"]][["version"]]
[17:01:03.858]                             if (is.null(version)) 
[17:01:03.858]                               version <- utils::packageVersion("future")
[17:01:03.858]                           }
[17:01:03.858]                           else {
[17:01:03.858]                             version <- NULL
[17:01:03.858]                           }
[17:01:03.858]                           if (!has_future || version < "1.8.0") {
[17:01:03.858]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.858]                               "", base::R.version$version.string), 
[17:01:03.858]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.858]                                 base::R.version$platform, 8 * 
[17:01:03.858]                                   base::.Machine$sizeof.pointer), 
[17:01:03.858]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.858]                                 "release", "version")], collapse = " "), 
[17:01:03.858]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.858]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.858]                               info)
[17:01:03.858]                             info <- base::paste(info, collapse = "; ")
[17:01:03.858]                             if (!has_future) {
[17:01:03.858]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.858]                                 info)
[17:01:03.858]                             }
[17:01:03.858]                             else {
[17:01:03.858]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.858]                                 info, version)
[17:01:03.858]                             }
[17:01:03.858]                             base::stop(msg)
[17:01:03.858]                           }
[17:01:03.858]                         })
[17:01:03.858]                       }
[17:01:03.858]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.858]                       base::options(mc.cores = 1L)
[17:01:03.858]                     }
[17:01:03.858]                     base::local({
[17:01:03.858]                       for (pkg in "future.apply") {
[17:01:03.858]                         base::loadNamespace(pkg)
[17:01:03.858]                         base::library(pkg, character.only = TRUE)
[17:01:03.858]                       }
[17:01:03.858]                     })
[17:01:03.858]                   }
[17:01:03.858]                   ...future.strategy.old <- future::plan("list")
[17:01:03.858]                   options(future.plan = NULL)
[17:01:03.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.858]                 }
[17:01:03.858]                 ...future.workdir <- getwd()
[17:01:03.858]             }
[17:01:03.858]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.858]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.858]         }
[17:01:03.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.858]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.858]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.858]             base::names(...future.oldOptions))
[17:01:03.858]     }
[17:01:03.858]     if (FALSE) {
[17:01:03.858]     }
[17:01:03.858]     else {
[17:01:03.858]         if (TRUE) {
[17:01:03.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.858]                 open = "w")
[17:01:03.858]         }
[17:01:03.858]         else {
[17:01:03.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.858]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.858]         }
[17:01:03.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.858]             base::sink(type = "output", split = FALSE)
[17:01:03.858]             base::close(...future.stdout)
[17:01:03.858]         }, add = TRUE)
[17:01:03.858]     }
[17:01:03.858]     ...future.frame <- base::sys.nframe()
[17:01:03.858]     ...future.conditions <- base::list()
[17:01:03.858]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.858]     if (FALSE) {
[17:01:03.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.858]     }
[17:01:03.858]     ...future.result <- base::tryCatch({
[17:01:03.858]         base::withCallingHandlers({
[17:01:03.858]             ...future.value <- base::withVisible(base::local({
[17:01:03.858]                 withCallingHandlers({
[17:01:03.858]                   {
[17:01:03.858]                     do.call(function(...) {
[17:01:03.858]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.858]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.858]                         ...future.globals.maxSize)) {
[17:01:03.858]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.858]                         on.exit(options(oopts), add = TRUE)
[17:01:03.858]                       }
[17:01:03.858]                       {
[17:01:03.858]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.858]                           FUN = function(jj) {
[17:01:03.858]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.858]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.858]                           })
[17:01:03.858]                       }
[17:01:03.858]                     }, args = future.call.arguments)
[17:01:03.858]                   }
[17:01:03.858]                 }, immediateCondition = function(cond) {
[17:01:03.858]                   save_rds <- function (object, pathname, ...) 
[17:01:03.858]                   {
[17:01:03.858]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.858]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.858]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.858]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.858]                         fi_tmp[["mtime"]])
[17:01:03.858]                     }
[17:01:03.858]                     tryCatch({
[17:01:03.858]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.858]                     }, error = function(ex) {
[17:01:03.858]                       msg <- conditionMessage(ex)
[17:01:03.858]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.858]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.858]                         fi_tmp[["mtime"]], msg)
[17:01:03.858]                       ex$message <- msg
[17:01:03.858]                       stop(ex)
[17:01:03.858]                     })
[17:01:03.858]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.858]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.858]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.858]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.858]                       fi <- file.info(pathname)
[17:01:03.858]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.858]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.858]                         fi[["size"]], fi[["mtime"]])
[17:01:03.858]                       stop(msg)
[17:01:03.858]                     }
[17:01:03.858]                     invisible(pathname)
[17:01:03.858]                   }
[17:01:03.858]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.858]                     rootPath = tempdir()) 
[17:01:03.858]                   {
[17:01:03.858]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.858]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.858]                       tmpdir = path, fileext = ".rds")
[17:01:03.858]                     save_rds(obj, file)
[17:01:03.858]                   }
[17:01:03.858]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.858]                   {
[17:01:03.858]                     inherits <- base::inherits
[17:01:03.858]                     invokeRestart <- base::invokeRestart
[17:01:03.858]                     is.null <- base::is.null
[17:01:03.858]                     muffled <- FALSE
[17:01:03.858]                     if (inherits(cond, "message")) {
[17:01:03.858]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.858]                       if (muffled) 
[17:01:03.858]                         invokeRestart("muffleMessage")
[17:01:03.858]                     }
[17:01:03.858]                     else if (inherits(cond, "warning")) {
[17:01:03.858]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.858]                       if (muffled) 
[17:01:03.858]                         invokeRestart("muffleWarning")
[17:01:03.858]                     }
[17:01:03.858]                     else if (inherits(cond, "condition")) {
[17:01:03.858]                       if (!is.null(pattern)) {
[17:01:03.858]                         computeRestarts <- base::computeRestarts
[17:01:03.858]                         grepl <- base::grepl
[17:01:03.858]                         restarts <- computeRestarts(cond)
[17:01:03.858]                         for (restart in restarts) {
[17:01:03.858]                           name <- restart$name
[17:01:03.858]                           if (is.null(name)) 
[17:01:03.858]                             next
[17:01:03.858]                           if (!grepl(pattern, name)) 
[17:01:03.858]                             next
[17:01:03.858]                           invokeRestart(restart)
[17:01:03.858]                           muffled <- TRUE
[17:01:03.858]                           break
[17:01:03.858]                         }
[17:01:03.858]                       }
[17:01:03.858]                     }
[17:01:03.858]                     invisible(muffled)
[17:01:03.858]                   }
[17:01:03.858]                   muffleCondition(cond)
[17:01:03.858]                 })
[17:01:03.858]             }))
[17:01:03.858]             future::FutureResult(value = ...future.value$value, 
[17:01:03.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.858]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.858]                     ...future.globalenv.names))
[17:01:03.858]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.858]         }, condition = base::local({
[17:01:03.858]             c <- base::c
[17:01:03.858]             inherits <- base::inherits
[17:01:03.858]             invokeRestart <- base::invokeRestart
[17:01:03.858]             length <- base::length
[17:01:03.858]             list <- base::list
[17:01:03.858]             seq.int <- base::seq.int
[17:01:03.858]             signalCondition <- base::signalCondition
[17:01:03.858]             sys.calls <- base::sys.calls
[17:01:03.858]             `[[` <- base::`[[`
[17:01:03.858]             `+` <- base::`+`
[17:01:03.858]             `<<-` <- base::`<<-`
[17:01:03.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.858]                   3L)]
[17:01:03.858]             }
[17:01:03.858]             function(cond) {
[17:01:03.858]                 is_error <- inherits(cond, "error")
[17:01:03.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.858]                   NULL)
[17:01:03.858]                 if (is_error) {
[17:01:03.858]                   sessionInformation <- function() {
[17:01:03.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.858]                       search = base::search(), system = base::Sys.info())
[17:01:03.858]                   }
[17:01:03.858]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.858]                     cond$call), session = sessionInformation(), 
[17:01:03.858]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.858]                   signalCondition(cond)
[17:01:03.858]                 }
[17:01:03.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.858]                 "immediateCondition"))) {
[17:01:03.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.858]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.858]                   if (TRUE && !signal) {
[17:01:03.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.858]                     {
[17:01:03.858]                       inherits <- base::inherits
[17:01:03.858]                       invokeRestart <- base::invokeRestart
[17:01:03.858]                       is.null <- base::is.null
[17:01:03.858]                       muffled <- FALSE
[17:01:03.858]                       if (inherits(cond, "message")) {
[17:01:03.858]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.858]                         if (muffled) 
[17:01:03.858]                           invokeRestart("muffleMessage")
[17:01:03.858]                       }
[17:01:03.858]                       else if (inherits(cond, "warning")) {
[17:01:03.858]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.858]                         if (muffled) 
[17:01:03.858]                           invokeRestart("muffleWarning")
[17:01:03.858]                       }
[17:01:03.858]                       else if (inherits(cond, "condition")) {
[17:01:03.858]                         if (!is.null(pattern)) {
[17:01:03.858]                           computeRestarts <- base::computeRestarts
[17:01:03.858]                           grepl <- base::grepl
[17:01:03.858]                           restarts <- computeRestarts(cond)
[17:01:03.858]                           for (restart in restarts) {
[17:01:03.858]                             name <- restart$name
[17:01:03.858]                             if (is.null(name)) 
[17:01:03.858]                               next
[17:01:03.858]                             if (!grepl(pattern, name)) 
[17:01:03.858]                               next
[17:01:03.858]                             invokeRestart(restart)
[17:01:03.858]                             muffled <- TRUE
[17:01:03.858]                             break
[17:01:03.858]                           }
[17:01:03.858]                         }
[17:01:03.858]                       }
[17:01:03.858]                       invisible(muffled)
[17:01:03.858]                     }
[17:01:03.858]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.858]                   }
[17:01:03.858]                 }
[17:01:03.858]                 else {
[17:01:03.858]                   if (TRUE) {
[17:01:03.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.858]                     {
[17:01:03.858]                       inherits <- base::inherits
[17:01:03.858]                       invokeRestart <- base::invokeRestart
[17:01:03.858]                       is.null <- base::is.null
[17:01:03.858]                       muffled <- FALSE
[17:01:03.858]                       if (inherits(cond, "message")) {
[17:01:03.858]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.858]                         if (muffled) 
[17:01:03.858]                           invokeRestart("muffleMessage")
[17:01:03.858]                       }
[17:01:03.858]                       else if (inherits(cond, "warning")) {
[17:01:03.858]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.858]                         if (muffled) 
[17:01:03.858]                           invokeRestart("muffleWarning")
[17:01:03.858]                       }
[17:01:03.858]                       else if (inherits(cond, "condition")) {
[17:01:03.858]                         if (!is.null(pattern)) {
[17:01:03.858]                           computeRestarts <- base::computeRestarts
[17:01:03.858]                           grepl <- base::grepl
[17:01:03.858]                           restarts <- computeRestarts(cond)
[17:01:03.858]                           for (restart in restarts) {
[17:01:03.858]                             name <- restart$name
[17:01:03.858]                             if (is.null(name)) 
[17:01:03.858]                               next
[17:01:03.858]                             if (!grepl(pattern, name)) 
[17:01:03.858]                               next
[17:01:03.858]                             invokeRestart(restart)
[17:01:03.858]                             muffled <- TRUE
[17:01:03.858]                             break
[17:01:03.858]                           }
[17:01:03.858]                         }
[17:01:03.858]                       }
[17:01:03.858]                       invisible(muffled)
[17:01:03.858]                     }
[17:01:03.858]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.858]                   }
[17:01:03.858]                 }
[17:01:03.858]             }
[17:01:03.858]         }))
[17:01:03.858]     }, error = function(ex) {
[17:01:03.858]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.858]                 ...future.rng), started = ...future.startTime, 
[17:01:03.858]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.858]             version = "1.8"), class = "FutureResult")
[17:01:03.858]     }, finally = {
[17:01:03.858]         if (!identical(...future.workdir, getwd())) 
[17:01:03.858]             setwd(...future.workdir)
[17:01:03.858]         {
[17:01:03.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.858]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.858]             }
[17:01:03.858]             base::options(...future.oldOptions)
[17:01:03.858]             if (.Platform$OS.type == "windows") {
[17:01:03.858]                 old_names <- names(...future.oldEnvVars)
[17:01:03.858]                 envs <- base::Sys.getenv()
[17:01:03.858]                 names <- names(envs)
[17:01:03.858]                 common <- intersect(names, old_names)
[17:01:03.858]                 added <- setdiff(names, old_names)
[17:01:03.858]                 removed <- setdiff(old_names, names)
[17:01:03.858]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.858]                   envs[common]]
[17:01:03.858]                 NAMES <- toupper(changed)
[17:01:03.858]                 args <- list()
[17:01:03.858]                 for (kk in seq_along(NAMES)) {
[17:01:03.858]                   name <- changed[[kk]]
[17:01:03.858]                   NAME <- NAMES[[kk]]
[17:01:03.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.858]                     next
[17:01:03.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.858]                 }
[17:01:03.858]                 NAMES <- toupper(added)
[17:01:03.858]                 for (kk in seq_along(NAMES)) {
[17:01:03.858]                   name <- added[[kk]]
[17:01:03.858]                   NAME <- NAMES[[kk]]
[17:01:03.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.858]                     next
[17:01:03.858]                   args[[name]] <- ""
[17:01:03.858]                 }
[17:01:03.858]                 NAMES <- toupper(removed)
[17:01:03.858]                 for (kk in seq_along(NAMES)) {
[17:01:03.858]                   name <- removed[[kk]]
[17:01:03.858]                   NAME <- NAMES[[kk]]
[17:01:03.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.858]                     next
[17:01:03.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.858]                 }
[17:01:03.858]                 if (length(args) > 0) 
[17:01:03.858]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.858]             }
[17:01:03.858]             else {
[17:01:03.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.858]             }
[17:01:03.858]             {
[17:01:03.858]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.858]                   0L) {
[17:01:03.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.858]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.858]                   base::options(opts)
[17:01:03.858]                 }
[17:01:03.858]                 {
[17:01:03.858]                   {
[17:01:03.858]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.858]                     NULL
[17:01:03.858]                   }
[17:01:03.858]                   options(future.plan = NULL)
[17:01:03.858]                   if (is.na(NA_character_)) 
[17:01:03.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.858]                     .init = FALSE)
[17:01:03.858]                 }
[17:01:03.858]             }
[17:01:03.858]         }
[17:01:03.858]     })
[17:01:03.858]     if (TRUE) {
[17:01:03.858]         base::sink(type = "output", split = FALSE)
[17:01:03.858]         if (TRUE) {
[17:01:03.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.858]         }
[17:01:03.858]         else {
[17:01:03.858]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.858]         }
[17:01:03.858]         base::close(...future.stdout)
[17:01:03.858]         ...future.stdout <- NULL
[17:01:03.858]     }
[17:01:03.858]     ...future.result$conditions <- ...future.conditions
[17:01:03.858]     ...future.result$finished <- base::Sys.time()
[17:01:03.858]     ...future.result
[17:01:03.858] }
[17:01:03.861] assign_globals() ...
[17:01:03.861] List of 11
[17:01:03.861]  $ ...future.FUN            :function (x, ...)  
[17:01:03.861]  $ x_FUN                    :function (x)  
[17:01:03.861]  $ times                    : int 1
[17:01:03.861]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.861]  $ stop_if_not              :function (...)  
[17:01:03.861]  $ dim                      : NULL
[17:01:03.861]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:03.861]  $ future.call.arguments    : list()
[17:01:03.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.861]  $ ...future.elements_ii    :List of 1
[17:01:03.861]   ..$ a: num 1
[17:01:03.861]  $ ...future.seeds_ii       : NULL
[17:01:03.861]  $ ...future.globals.maxSize: NULL
[17:01:03.861]  - attr(*, "where")=List of 11
[17:01:03.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.861]  - attr(*, "resolved")= logi FALSE
[17:01:03.861]  - attr(*, "total_size")= num 94264
[17:01:03.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.861]  - attr(*, "already-done")= logi TRUE
[17:01:03.869] - copied ‘...future.FUN’ to environment
[17:01:03.870] - copied ‘x_FUN’ to environment
[17:01:03.870] - copied ‘times’ to environment
[17:01:03.870] - copied ‘stopf’ to environment
[17:01:03.870] - copied ‘stop_if_not’ to environment
[17:01:03.870] - copied ‘dim’ to environment
[17:01:03.870] - copied ‘valid_types’ to environment
[17:01:03.870] - copied ‘future.call.arguments’ to environment
[17:01:03.870] - copied ‘...future.elements_ii’ to environment
[17:01:03.870] - copied ‘...future.seeds_ii’ to environment
[17:01:03.870] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.871] assign_globals() ... done
[17:01:03.871] requestCore(): workers = 2
[17:01:03.873] MulticoreFuture started
[17:01:03.873] - Launch lazy future ... done
[17:01:03.874] run() for ‘MulticoreFuture’ ... done
[17:01:03.874] Created future:
[17:01:03.874] plan(): Setting new future strategy stack:
[17:01:03.875] List of future strategies:
[17:01:03.875] 1. sequential:
[17:01:03.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.875]    - tweaked: FALSE
[17:01:03.875]    - call: NULL
[17:01:03.876] plan(): nbrOfWorkers() = 1
[17:01:03.878] plan(): Setting new future strategy stack:
[17:01:03.878] List of future strategies:
[17:01:03.878] 1. multicore:
[17:01:03.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.878]    - tweaked: FALSE
[17:01:03.878]    - call: plan(strategy)
[17:01:03.883] plan(): nbrOfWorkers() = 2
[17:01:03.874] MulticoreFuture:
[17:01:03.874] Label: ‘future_vapply-1’
[17:01:03.874] Expression:
[17:01:03.874] {
[17:01:03.874]     do.call(function(...) {
[17:01:03.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.874]             on.exit(options(oopts), add = TRUE)
[17:01:03.874]         }
[17:01:03.874]         {
[17:01:03.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.874]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.874]             })
[17:01:03.874]         }
[17:01:03.874]     }, args = future.call.arguments)
[17:01:03.874] }
[17:01:03.874] Lazy evaluation: FALSE
[17:01:03.874] Asynchronous evaluation: TRUE
[17:01:03.874] Local evaluation: TRUE
[17:01:03.874] Environment: R_GlobalEnv
[17:01:03.874] Capture standard output: TRUE
[17:01:03.874] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.874] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.874] Packages: 1 packages (‘future.apply’)
[17:01:03.874] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.874] Resolved: TRUE
[17:01:03.874] Value: <not collected>
[17:01:03.874] Conditions captured: <none>
[17:01:03.874] Early signaling: FALSE
[17:01:03.874] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.874] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.884] Chunk #1 of 2 ... DONE
[17:01:03.884] Chunk #2 of 2 ...
[17:01:03.885]  - Finding globals in 'X' for chunk #2 ...
[17:01:03.885] getGlobalsAndPackages() ...
[17:01:03.885] Searching for globals...
[17:01:03.885] 
[17:01:03.886] Searching for globals ... DONE
[17:01:03.886] - globals: [0] <none>
[17:01:03.886] getGlobalsAndPackages() ... DONE
[17:01:03.886]    + additional globals found: [n=0] 
[17:01:03.886]    + additional namespaces needed: [n=0] 
[17:01:03.886]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:03.886]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.886]  - seeds: <none>
[17:01:03.887]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.887] getGlobalsAndPackages() ...
[17:01:03.887] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.887] Resolving globals: FALSE
[17:01:03.887] Tweak future expression to call with '...' arguments ...
[17:01:03.888] {
[17:01:03.888]     do.call(function(...) {
[17:01:03.888]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.888]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.888]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.888]             on.exit(options(oopts), add = TRUE)
[17:01:03.888]         }
[17:01:03.888]         {
[17:01:03.888]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.888]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.888]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.888]             })
[17:01:03.888]         }
[17:01:03.888]     }, args = future.call.arguments)
[17:01:03.888] }
[17:01:03.888] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.889] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.889] - packages: [1] ‘future.apply’
[17:01:03.889] getGlobalsAndPackages() ... DONE
[17:01:03.890] run() for ‘Future’ ...
[17:01:03.890] - state: ‘created’
[17:01:03.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.895] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.895] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.895]   - Field: ‘label’
[17:01:03.896]   - Field: ‘local’
[17:01:03.896]   - Field: ‘owner’
[17:01:03.896]   - Field: ‘envir’
[17:01:03.896]   - Field: ‘workers’
[17:01:03.896]   - Field: ‘packages’
[17:01:03.896]   - Field: ‘gc’
[17:01:03.896]   - Field: ‘job’
[17:01:03.897]   - Field: ‘conditions’
[17:01:03.897]   - Field: ‘expr’
[17:01:03.897]   - Field: ‘uuid’
[17:01:03.897]   - Field: ‘seed’
[17:01:03.897]   - Field: ‘version’
[17:01:03.897]   - Field: ‘result’
[17:01:03.897]   - Field: ‘asynchronous’
[17:01:03.898]   - Field: ‘calls’
[17:01:03.898]   - Field: ‘globals’
[17:01:03.898]   - Field: ‘stdout’
[17:01:03.901]   - Field: ‘earlySignal’
[17:01:03.902]   - Field: ‘lazy’
[17:01:03.902]   - Field: ‘state’
[17:01:03.902] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.903] - Launch lazy future ...
[17:01:03.904] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.904] Packages needed by future strategies (n = 0): <none>
[17:01:03.905] {
[17:01:03.905]     {
[17:01:03.905]         {
[17:01:03.905]             ...future.startTime <- base::Sys.time()
[17:01:03.905]             {
[17:01:03.905]                 {
[17:01:03.905]                   {
[17:01:03.905]                     {
[17:01:03.905]                       {
[17:01:03.905]                         base::local({
[17:01:03.905]                           has_future <- base::requireNamespace("future", 
[17:01:03.905]                             quietly = TRUE)
[17:01:03.905]                           if (has_future) {
[17:01:03.905]                             ns <- base::getNamespace("future")
[17:01:03.905]                             version <- ns[[".package"]][["version"]]
[17:01:03.905]                             if (is.null(version)) 
[17:01:03.905]                               version <- utils::packageVersion("future")
[17:01:03.905]                           }
[17:01:03.905]                           else {
[17:01:03.905]                             version <- NULL
[17:01:03.905]                           }
[17:01:03.905]                           if (!has_future || version < "1.8.0") {
[17:01:03.905]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.905]                               "", base::R.version$version.string), 
[17:01:03.905]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.905]                                 base::R.version$platform, 8 * 
[17:01:03.905]                                   base::.Machine$sizeof.pointer), 
[17:01:03.905]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.905]                                 "release", "version")], collapse = " "), 
[17:01:03.905]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.905]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.905]                               info)
[17:01:03.905]                             info <- base::paste(info, collapse = "; ")
[17:01:03.905]                             if (!has_future) {
[17:01:03.905]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.905]                                 info)
[17:01:03.905]                             }
[17:01:03.905]                             else {
[17:01:03.905]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.905]                                 info, version)
[17:01:03.905]                             }
[17:01:03.905]                             base::stop(msg)
[17:01:03.905]                           }
[17:01:03.905]                         })
[17:01:03.905]                       }
[17:01:03.905]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.905]                       base::options(mc.cores = 1L)
[17:01:03.905]                     }
[17:01:03.905]                     base::local({
[17:01:03.905]                       for (pkg in "future.apply") {
[17:01:03.905]                         base::loadNamespace(pkg)
[17:01:03.905]                         base::library(pkg, character.only = TRUE)
[17:01:03.905]                       }
[17:01:03.905]                     })
[17:01:03.905]                   }
[17:01:03.905]                   ...future.strategy.old <- future::plan("list")
[17:01:03.905]                   options(future.plan = NULL)
[17:01:03.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.905]                 }
[17:01:03.905]                 ...future.workdir <- getwd()
[17:01:03.905]             }
[17:01:03.905]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.905]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.905]         }
[17:01:03.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.905]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.905]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.905]             base::names(...future.oldOptions))
[17:01:03.905]     }
[17:01:03.905]     if (FALSE) {
[17:01:03.905]     }
[17:01:03.905]     else {
[17:01:03.905]         if (TRUE) {
[17:01:03.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.905]                 open = "w")
[17:01:03.905]         }
[17:01:03.905]         else {
[17:01:03.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.905]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.905]         }
[17:01:03.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.905]             base::sink(type = "output", split = FALSE)
[17:01:03.905]             base::close(...future.stdout)
[17:01:03.905]         }, add = TRUE)
[17:01:03.905]     }
[17:01:03.905]     ...future.frame <- base::sys.nframe()
[17:01:03.905]     ...future.conditions <- base::list()
[17:01:03.905]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.905]     if (FALSE) {
[17:01:03.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.905]     }
[17:01:03.905]     ...future.result <- base::tryCatch({
[17:01:03.905]         base::withCallingHandlers({
[17:01:03.905]             ...future.value <- base::withVisible(base::local({
[17:01:03.905]                 withCallingHandlers({
[17:01:03.905]                   {
[17:01:03.905]                     do.call(function(...) {
[17:01:03.905]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.905]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.905]                         ...future.globals.maxSize)) {
[17:01:03.905]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.905]                         on.exit(options(oopts), add = TRUE)
[17:01:03.905]                       }
[17:01:03.905]                       {
[17:01:03.905]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.905]                           FUN = function(jj) {
[17:01:03.905]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.905]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.905]                           })
[17:01:03.905]                       }
[17:01:03.905]                     }, args = future.call.arguments)
[17:01:03.905]                   }
[17:01:03.905]                 }, immediateCondition = function(cond) {
[17:01:03.905]                   save_rds <- function (object, pathname, ...) 
[17:01:03.905]                   {
[17:01:03.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.905]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.905]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.905]                         fi_tmp[["mtime"]])
[17:01:03.905]                     }
[17:01:03.905]                     tryCatch({
[17:01:03.905]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.905]                     }, error = function(ex) {
[17:01:03.905]                       msg <- conditionMessage(ex)
[17:01:03.905]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.905]                         fi_tmp[["mtime"]], msg)
[17:01:03.905]                       ex$message <- msg
[17:01:03.905]                       stop(ex)
[17:01:03.905]                     })
[17:01:03.905]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.905]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.905]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.905]                       fi <- file.info(pathname)
[17:01:03.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.905]                         fi[["size"]], fi[["mtime"]])
[17:01:03.905]                       stop(msg)
[17:01:03.905]                     }
[17:01:03.905]                     invisible(pathname)
[17:01:03.905]                   }
[17:01:03.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.905]                     rootPath = tempdir()) 
[17:01:03.905]                   {
[17:01:03.905]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.905]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.905]                       tmpdir = path, fileext = ".rds")
[17:01:03.905]                     save_rds(obj, file)
[17:01:03.905]                   }
[17:01:03.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.905]                   {
[17:01:03.905]                     inherits <- base::inherits
[17:01:03.905]                     invokeRestart <- base::invokeRestart
[17:01:03.905]                     is.null <- base::is.null
[17:01:03.905]                     muffled <- FALSE
[17:01:03.905]                     if (inherits(cond, "message")) {
[17:01:03.905]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.905]                       if (muffled) 
[17:01:03.905]                         invokeRestart("muffleMessage")
[17:01:03.905]                     }
[17:01:03.905]                     else if (inherits(cond, "warning")) {
[17:01:03.905]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.905]                       if (muffled) 
[17:01:03.905]                         invokeRestart("muffleWarning")
[17:01:03.905]                     }
[17:01:03.905]                     else if (inherits(cond, "condition")) {
[17:01:03.905]                       if (!is.null(pattern)) {
[17:01:03.905]                         computeRestarts <- base::computeRestarts
[17:01:03.905]                         grepl <- base::grepl
[17:01:03.905]                         restarts <- computeRestarts(cond)
[17:01:03.905]                         for (restart in restarts) {
[17:01:03.905]                           name <- restart$name
[17:01:03.905]                           if (is.null(name)) 
[17:01:03.905]                             next
[17:01:03.905]                           if (!grepl(pattern, name)) 
[17:01:03.905]                             next
[17:01:03.905]                           invokeRestart(restart)
[17:01:03.905]                           muffled <- TRUE
[17:01:03.905]                           break
[17:01:03.905]                         }
[17:01:03.905]                       }
[17:01:03.905]                     }
[17:01:03.905]                     invisible(muffled)
[17:01:03.905]                   }
[17:01:03.905]                   muffleCondition(cond)
[17:01:03.905]                 })
[17:01:03.905]             }))
[17:01:03.905]             future::FutureResult(value = ...future.value$value, 
[17:01:03.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.905]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.905]                     ...future.globalenv.names))
[17:01:03.905]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.905]         }, condition = base::local({
[17:01:03.905]             c <- base::c
[17:01:03.905]             inherits <- base::inherits
[17:01:03.905]             invokeRestart <- base::invokeRestart
[17:01:03.905]             length <- base::length
[17:01:03.905]             list <- base::list
[17:01:03.905]             seq.int <- base::seq.int
[17:01:03.905]             signalCondition <- base::signalCondition
[17:01:03.905]             sys.calls <- base::sys.calls
[17:01:03.905]             `[[` <- base::`[[`
[17:01:03.905]             `+` <- base::`+`
[17:01:03.905]             `<<-` <- base::`<<-`
[17:01:03.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.905]                   3L)]
[17:01:03.905]             }
[17:01:03.905]             function(cond) {
[17:01:03.905]                 is_error <- inherits(cond, "error")
[17:01:03.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.905]                   NULL)
[17:01:03.905]                 if (is_error) {
[17:01:03.905]                   sessionInformation <- function() {
[17:01:03.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.905]                       search = base::search(), system = base::Sys.info())
[17:01:03.905]                   }
[17:01:03.905]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.905]                     cond$call), session = sessionInformation(), 
[17:01:03.905]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.905]                   signalCondition(cond)
[17:01:03.905]                 }
[17:01:03.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.905]                 "immediateCondition"))) {
[17:01:03.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.905]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.905]                   if (TRUE && !signal) {
[17:01:03.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.905]                     {
[17:01:03.905]                       inherits <- base::inherits
[17:01:03.905]                       invokeRestart <- base::invokeRestart
[17:01:03.905]                       is.null <- base::is.null
[17:01:03.905]                       muffled <- FALSE
[17:01:03.905]                       if (inherits(cond, "message")) {
[17:01:03.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.905]                         if (muffled) 
[17:01:03.905]                           invokeRestart("muffleMessage")
[17:01:03.905]                       }
[17:01:03.905]                       else if (inherits(cond, "warning")) {
[17:01:03.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.905]                         if (muffled) 
[17:01:03.905]                           invokeRestart("muffleWarning")
[17:01:03.905]                       }
[17:01:03.905]                       else if (inherits(cond, "condition")) {
[17:01:03.905]                         if (!is.null(pattern)) {
[17:01:03.905]                           computeRestarts <- base::computeRestarts
[17:01:03.905]                           grepl <- base::grepl
[17:01:03.905]                           restarts <- computeRestarts(cond)
[17:01:03.905]                           for (restart in restarts) {
[17:01:03.905]                             name <- restart$name
[17:01:03.905]                             if (is.null(name)) 
[17:01:03.905]                               next
[17:01:03.905]                             if (!grepl(pattern, name)) 
[17:01:03.905]                               next
[17:01:03.905]                             invokeRestart(restart)
[17:01:03.905]                             muffled <- TRUE
[17:01:03.905]                             break
[17:01:03.905]                           }
[17:01:03.905]                         }
[17:01:03.905]                       }
[17:01:03.905]                       invisible(muffled)
[17:01:03.905]                     }
[17:01:03.905]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.905]                   }
[17:01:03.905]                 }
[17:01:03.905]                 else {
[17:01:03.905]                   if (TRUE) {
[17:01:03.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.905]                     {
[17:01:03.905]                       inherits <- base::inherits
[17:01:03.905]                       invokeRestart <- base::invokeRestart
[17:01:03.905]                       is.null <- base::is.null
[17:01:03.905]                       muffled <- FALSE
[17:01:03.905]                       if (inherits(cond, "message")) {
[17:01:03.905]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.905]                         if (muffled) 
[17:01:03.905]                           invokeRestart("muffleMessage")
[17:01:03.905]                       }
[17:01:03.905]                       else if (inherits(cond, "warning")) {
[17:01:03.905]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.905]                         if (muffled) 
[17:01:03.905]                           invokeRestart("muffleWarning")
[17:01:03.905]                       }
[17:01:03.905]                       else if (inherits(cond, "condition")) {
[17:01:03.905]                         if (!is.null(pattern)) {
[17:01:03.905]                           computeRestarts <- base::computeRestarts
[17:01:03.905]                           grepl <- base::grepl
[17:01:03.905]                           restarts <- computeRestarts(cond)
[17:01:03.905]                           for (restart in restarts) {
[17:01:03.905]                             name <- restart$name
[17:01:03.905]                             if (is.null(name)) 
[17:01:03.905]                               next
[17:01:03.905]                             if (!grepl(pattern, name)) 
[17:01:03.905]                               next
[17:01:03.905]                             invokeRestart(restart)
[17:01:03.905]                             muffled <- TRUE
[17:01:03.905]                             break
[17:01:03.905]                           }
[17:01:03.905]                         }
[17:01:03.905]                       }
[17:01:03.905]                       invisible(muffled)
[17:01:03.905]                     }
[17:01:03.905]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.905]                   }
[17:01:03.905]                 }
[17:01:03.905]             }
[17:01:03.905]         }))
[17:01:03.905]     }, error = function(ex) {
[17:01:03.905]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.905]                 ...future.rng), started = ...future.startTime, 
[17:01:03.905]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.905]             version = "1.8"), class = "FutureResult")
[17:01:03.905]     }, finally = {
[17:01:03.905]         if (!identical(...future.workdir, getwd())) 
[17:01:03.905]             setwd(...future.workdir)
[17:01:03.905]         {
[17:01:03.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.905]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.905]             }
[17:01:03.905]             base::options(...future.oldOptions)
[17:01:03.905]             if (.Platform$OS.type == "windows") {
[17:01:03.905]                 old_names <- names(...future.oldEnvVars)
[17:01:03.905]                 envs <- base::Sys.getenv()
[17:01:03.905]                 names <- names(envs)
[17:01:03.905]                 common <- intersect(names, old_names)
[17:01:03.905]                 added <- setdiff(names, old_names)
[17:01:03.905]                 removed <- setdiff(old_names, names)
[17:01:03.905]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.905]                   envs[common]]
[17:01:03.905]                 NAMES <- toupper(changed)
[17:01:03.905]                 args <- list()
[17:01:03.905]                 for (kk in seq_along(NAMES)) {
[17:01:03.905]                   name <- changed[[kk]]
[17:01:03.905]                   NAME <- NAMES[[kk]]
[17:01:03.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.905]                     next
[17:01:03.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.905]                 }
[17:01:03.905]                 NAMES <- toupper(added)
[17:01:03.905]                 for (kk in seq_along(NAMES)) {
[17:01:03.905]                   name <- added[[kk]]
[17:01:03.905]                   NAME <- NAMES[[kk]]
[17:01:03.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.905]                     next
[17:01:03.905]                   args[[name]] <- ""
[17:01:03.905]                 }
[17:01:03.905]                 NAMES <- toupper(removed)
[17:01:03.905]                 for (kk in seq_along(NAMES)) {
[17:01:03.905]                   name <- removed[[kk]]
[17:01:03.905]                   NAME <- NAMES[[kk]]
[17:01:03.905]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.905]                     next
[17:01:03.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.905]                 }
[17:01:03.905]                 if (length(args) > 0) 
[17:01:03.905]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.905]             }
[17:01:03.905]             else {
[17:01:03.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.905]             }
[17:01:03.905]             {
[17:01:03.905]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.905]                   0L) {
[17:01:03.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.905]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.905]                   base::options(opts)
[17:01:03.905]                 }
[17:01:03.905]                 {
[17:01:03.905]                   {
[17:01:03.905]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.905]                     NULL
[17:01:03.905]                   }
[17:01:03.905]                   options(future.plan = NULL)
[17:01:03.905]                   if (is.na(NA_character_)) 
[17:01:03.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.905]                     .init = FALSE)
[17:01:03.905]                 }
[17:01:03.905]             }
[17:01:03.905]         }
[17:01:03.905]     })
[17:01:03.905]     if (TRUE) {
[17:01:03.905]         base::sink(type = "output", split = FALSE)
[17:01:03.905]         if (TRUE) {
[17:01:03.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.905]         }
[17:01:03.905]         else {
[17:01:03.905]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.905]         }
[17:01:03.905]         base::close(...future.stdout)
[17:01:03.905]         ...future.stdout <- NULL
[17:01:03.905]     }
[17:01:03.905]     ...future.result$conditions <- ...future.conditions
[17:01:03.905]     ...future.result$finished <- base::Sys.time()
[17:01:03.905]     ...future.result
[17:01:03.905] }
[17:01:03.908] assign_globals() ...
[17:01:03.908] List of 11
[17:01:03.908]  $ ...future.FUN            :function (x, ...)  
[17:01:03.908]  $ x_FUN                    :function (x)  
[17:01:03.908]  $ times                    : int 1
[17:01:03.908]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.908]  $ stop_if_not              :function (...)  
[17:01:03.908]  $ dim                      : NULL
[17:01:03.908]  $ valid_types              : chr [1:2] "logical" "integer"
[17:01:03.908]  $ future.call.arguments    : list()
[17:01:03.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.908]  $ ...future.elements_ii    :List of 2
[17:01:03.908]   ..$ b: num 2
[17:01:03.908]   ..$ c: num 3
[17:01:03.908]  $ ...future.seeds_ii       : NULL
[17:01:03.908]  $ ...future.globals.maxSize: NULL
[17:01:03.908]  - attr(*, "where")=List of 11
[17:01:03.908]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.908]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.908]  - attr(*, "resolved")= logi FALSE
[17:01:03.908]  - attr(*, "total_size")= num 94264
[17:01:03.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.908]  - attr(*, "already-done")= logi TRUE
[17:01:03.922] - copied ‘...future.FUN’ to environment
[17:01:03.922] - copied ‘x_FUN’ to environment
[17:01:03.922] - copied ‘times’ to environment
[17:01:03.922] - copied ‘stopf’ to environment
[17:01:03.922] - copied ‘stop_if_not’ to environment
[17:01:03.922] - copied ‘dim’ to environment
[17:01:03.922] - copied ‘valid_types’ to environment
[17:01:03.922] - copied ‘future.call.arguments’ to environment
[17:01:03.922] - copied ‘...future.elements_ii’ to environment
[17:01:03.923] - copied ‘...future.seeds_ii’ to environment
[17:01:03.923] - copied ‘...future.globals.maxSize’ to environment
[17:01:03.923] assign_globals() ... done
[17:01:03.923] requestCore(): workers = 2
[17:01:03.925] MulticoreFuture started
[17:01:03.926] - Launch lazy future ... done
[17:01:03.926] run() for ‘MulticoreFuture’ ... done
[17:01:03.926] Created future:
[17:01:03.927] plan(): Setting new future strategy stack:
[17:01:03.927] List of future strategies:
[17:01:03.927] 1. sequential:
[17:01:03.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:03.927]    - tweaked: FALSE
[17:01:03.927]    - call: NULL
[17:01:03.928] plan(): nbrOfWorkers() = 1
[17:01:03.930] plan(): Setting new future strategy stack:
[17:01:03.930] List of future strategies:
[17:01:03.930] 1. multicore:
[17:01:03.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:03.930]    - tweaked: FALSE
[17:01:03.930]    - call: plan(strategy)
[17:01:03.936] plan(): nbrOfWorkers() = 2
[17:01:03.926] MulticoreFuture:
[17:01:03.926] Label: ‘future_vapply-2’
[17:01:03.926] Expression:
[17:01:03.926] {
[17:01:03.926]     do.call(function(...) {
[17:01:03.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.926]             on.exit(options(oopts), add = TRUE)
[17:01:03.926]         }
[17:01:03.926]         {
[17:01:03.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.926]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.926]             })
[17:01:03.926]         }
[17:01:03.926]     }, args = future.call.arguments)
[17:01:03.926] }
[17:01:03.926] Lazy evaluation: FALSE
[17:01:03.926] Asynchronous evaluation: TRUE
[17:01:03.926] Local evaluation: TRUE
[17:01:03.926] Environment: R_GlobalEnv
[17:01:03.926] Capture standard output: TRUE
[17:01:03.926] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:03.926] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:03.926] Packages: 1 packages (‘future.apply’)
[17:01:03.926] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:03.926] Resolved: TRUE
[17:01:03.926] Value: <not collected>
[17:01:03.926] Conditions captured: <none>
[17:01:03.926] Early signaling: FALSE
[17:01:03.926] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:03.926] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.937] Chunk #2 of 2 ... DONE
[17:01:03.937] Launching 2 futures (chunks) ... DONE
[17:01:03.937] Resolving 2 futures (chunks) ...
[17:01:03.937] resolve() on list ...
[17:01:03.938]  recursive: 0
[17:01:03.938]  length: 2
[17:01:03.938] 
[17:01:03.938] Future #1
[17:01:03.938] result() for MulticoreFuture ...
[17:01:03.939] result() for MulticoreFuture ...
[17:01:03.939] result() for MulticoreFuture ... done
[17:01:03.940] result() for MulticoreFuture ... done
[17:01:03.940] result() for MulticoreFuture ...
[17:01:03.940] result() for MulticoreFuture ... done
[17:01:03.940] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:03.940] - nx: 2
[17:01:03.940] - relay: TRUE
[17:01:03.940] - stdout: TRUE
[17:01:03.940] - signal: TRUE
[17:01:03.941] - resignal: FALSE
[17:01:03.941] - force: TRUE
[17:01:03.941] - relayed: [n=2] FALSE, FALSE
[17:01:03.941] - queued futures: [n=2] FALSE, FALSE
[17:01:03.941]  - until=1
[17:01:03.941]  - relaying element #1
[17:01:03.942] result() for MulticoreFuture ...
[17:01:03.942] result() for MulticoreFuture ... done
[17:01:03.942] result() for MulticoreFuture ...
[17:01:03.942] result() for MulticoreFuture ... done
[17:01:03.942] result() for MulticoreFuture ...
[17:01:03.942] result() for MulticoreFuture ... done
[17:01:03.943] result() for MulticoreFuture ...
[17:01:03.943] result() for MulticoreFuture ... done
[17:01:03.943] - relayed: [n=2] TRUE, FALSE
[17:01:03.943] - queued futures: [n=2] TRUE, FALSE
[17:01:03.943] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:03.943]  length: 1 (resolved future 1)
[17:01:03.944] Future #2
[17:01:03.944] result() for MulticoreFuture ...
[17:01:03.945] result() for MulticoreFuture ...
[17:01:03.945] result() for MulticoreFuture ... done
[17:01:03.945] result() for MulticoreFuture ... done
[17:01:03.945] result() for MulticoreFuture ...
[17:01:03.945] result() for MulticoreFuture ... done
[17:01:03.945] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:01:03.945] - nx: 2
[17:01:03.946] - relay: TRUE
[17:01:03.946] - stdout: TRUE
[17:01:03.946] - signal: TRUE
[17:01:03.946] - resignal: FALSE
[17:01:03.946] - force: TRUE
[17:01:03.946] - relayed: [n=2] TRUE, FALSE
[17:01:03.946] - queued futures: [n=2] TRUE, FALSE
[17:01:03.946]  - until=2
[17:01:03.949]  - relaying element #2
[17:01:03.950] result() for MulticoreFuture ...
[17:01:03.950] result() for MulticoreFuture ... done
[17:01:03.950] result() for MulticoreFuture ...
[17:01:03.950] result() for MulticoreFuture ... done
[17:01:03.950] result() for MulticoreFuture ...
[17:01:03.951] result() for MulticoreFuture ... done
[17:01:03.951] result() for MulticoreFuture ...
[17:01:03.951] result() for MulticoreFuture ... done
[17:01:03.951] - relayed: [n=2] TRUE, TRUE
[17:01:03.951] - queued futures: [n=2] TRUE, TRUE
[17:01:03.952] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:01:03.952]  length: 0 (resolved future 2)
[17:01:03.952] Relaying remaining futures
[17:01:03.952] signalConditionsASAP(NULL, pos=0) ...
[17:01:03.952] - nx: 2
[17:01:03.952] - relay: TRUE
[17:01:03.952] - stdout: TRUE
[17:01:03.953] - signal: TRUE
[17:01:03.953] - resignal: FALSE
[17:01:03.953] - force: TRUE
[17:01:03.953] - relayed: [n=2] TRUE, TRUE
[17:01:03.953] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:03.953] - relayed: [n=2] TRUE, TRUE
[17:01:03.954] - queued futures: [n=2] TRUE, TRUE
[17:01:03.954] signalConditionsASAP(NULL, pos=0) ... done
[17:01:03.954] resolve() on list ... DONE
[17:01:03.954] result() for MulticoreFuture ...
[17:01:03.954] result() for MulticoreFuture ... done
[17:01:03.954] result() for MulticoreFuture ...
[17:01:03.954] result() for MulticoreFuture ... done
[17:01:03.955] result() for MulticoreFuture ...
[17:01:03.955] result() for MulticoreFuture ... done
[17:01:03.955] result() for MulticoreFuture ...
[17:01:03.955] result() for MulticoreFuture ... done
[17:01:03.955]  - Number of value chunks collected: 2
[17:01:03.955] Resolving 2 futures (chunks) ... DONE
[17:01:03.956] Reducing values from 2 chunks ...
[17:01:03.956]  - Number of values collected after concatenation: 3
[17:01:03.956]  - Number of values expected: 3
[17:01:03.956] Reducing values from 2 chunks ... DONE
[17:01:03.956] future_lapply() ... DONE
- exceptions ...
[17:01:03.956] future_lapply() ...
[17:01:03.964] Number of chunks: 2
[17:01:03.964] getGlobalsAndPackagesXApply() ...
[17:01:03.964]  - future.globals: TRUE
[17:01:03.964] getGlobalsAndPackages() ...
[17:01:03.965] Searching for globals...
[17:01:03.968] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:03.968] Searching for globals ... DONE
[17:01:03.969] Resolving globals: FALSE
[17:01:03.970] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:01:03.970] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:03.970] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.970] - packages: [1] ‘future.apply’
[17:01:03.970] getGlobalsAndPackages() ... DONE
[17:01:03.971]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:03.971]  - needed namespaces: [n=1] ‘future.apply’
[17:01:03.971] Finding globals ... DONE
[17:01:03.971]  - use_args: TRUE
[17:01:03.971]  - Getting '...' globals ...
[17:01:03.971] resolve() on list ...
[17:01:03.972]  recursive: 0
[17:01:03.972]  length: 1
[17:01:03.972]  elements: ‘...’
[17:01:03.972]  length: 0 (resolved future 1)
[17:01:03.972] resolve() on list ... DONE
[17:01:03.972]    - '...' content: [n=0] 
[17:01:03.972] List of 1
[17:01:03.972]  $ ...: list()
[17:01:03.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.972]  - attr(*, "where")=List of 1
[17:01:03.972]   ..$ ...:<environment: 0x55aad95547b0> 
[17:01:03.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.972]  - attr(*, "resolved")= logi TRUE
[17:01:03.972]  - attr(*, "total_size")= num NA
[17:01:03.975]  - Getting '...' globals ... DONE
[17:01:03.975] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:03.975] List of 8
[17:01:03.975]  $ ...future.FUN:function (x, ...)  
[17:01:03.975]  $ x_FUN        :function (x)  
[17:01:03.975]  $ times        : int 2
[17:01:03.975]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.975]  $ stop_if_not  :function (...)  
[17:01:03.975]  $ dim          : NULL
[17:01:03.975]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:03.975]  $ ...          : list()
[17:01:03.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.975]  - attr(*, "where")=List of 8
[17:01:03.975]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:03.975]   ..$ ...          :<environment: 0x55aad95547b0> 
[17:01:03.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.975]  - attr(*, "resolved")= logi FALSE
[17:01:03.975]  - attr(*, "total_size")= num 95128
[17:01:03.984] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:03.985] getGlobalsAndPackagesXApply() ... DONE
[17:01:03.985] Number of futures (= number of chunks): 2
[17:01:03.985] Launching 2 futures (chunks) ...
[17:01:03.985] Chunk #1 of 2 ...
[17:01:03.985]  - Finding globals in 'X' for chunk #1 ...
[17:01:03.985] getGlobalsAndPackages() ...
[17:01:03.986] Searching for globals...
[17:01:03.986] 
[17:01:03.986] Searching for globals ... DONE
[17:01:03.986] - globals: [0] <none>
[17:01:03.986] getGlobalsAndPackages() ... DONE
[17:01:03.986]    + additional globals found: [n=0] 
[17:01:03.986]    + additional namespaces needed: [n=0] 
[17:01:03.987]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:03.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:03.987]  - seeds: <none>
[17:01:03.987]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.987] getGlobalsAndPackages() ...
[17:01:03.987] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.987] Resolving globals: FALSE
[17:01:03.987] Tweak future expression to call with '...' arguments ...
[17:01:03.987] {
[17:01:03.987]     do.call(function(...) {
[17:01:03.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:03.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.987]             on.exit(options(oopts), add = TRUE)
[17:01:03.987]         }
[17:01:03.987]         {
[17:01:03.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:03.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.987]                 ...future.FUN(...future.X_jj, ...)
[17:01:03.987]             })
[17:01:03.987]         }
[17:01:03.987]     }, args = future.call.arguments)
[17:01:03.987] }
[17:01:03.988] Tweak future expression to call with '...' arguments ... DONE
[17:01:03.988] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:03.988] - packages: [1] ‘future.apply’
[17:01:03.988] getGlobalsAndPackages() ... DONE
[17:01:03.989] run() for ‘Future’ ...
[17:01:03.989] - state: ‘created’
[17:01:03.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:03.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:03.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:03.993]   - Field: ‘label’
[17:01:03.993]   - Field: ‘local’
[17:01:03.993]   - Field: ‘owner’
[17:01:03.993]   - Field: ‘envir’
[17:01:03.994]   - Field: ‘workers’
[17:01:03.994]   - Field: ‘packages’
[17:01:03.994]   - Field: ‘gc’
[17:01:03.994]   - Field: ‘job’
[17:01:03.994]   - Field: ‘conditions’
[17:01:03.994]   - Field: ‘expr’
[17:01:03.994]   - Field: ‘uuid’
[17:01:03.994]   - Field: ‘seed’
[17:01:03.994]   - Field: ‘version’
[17:01:03.994]   - Field: ‘result’
[17:01:03.994]   - Field: ‘asynchronous’
[17:01:03.995]   - Field: ‘calls’
[17:01:03.995]   - Field: ‘globals’
[17:01:03.995]   - Field: ‘stdout’
[17:01:03.995]   - Field: ‘earlySignal’
[17:01:03.995]   - Field: ‘lazy’
[17:01:03.995]   - Field: ‘state’
[17:01:03.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:03.995] - Launch lazy future ...
[17:01:03.996] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:03.996] Packages needed by future strategies (n = 0): <none>
[17:01:03.996] {
[17:01:03.996]     {
[17:01:03.996]         {
[17:01:03.996]             ...future.startTime <- base::Sys.time()
[17:01:03.996]             {
[17:01:03.996]                 {
[17:01:03.996]                   {
[17:01:03.996]                     {
[17:01:03.996]                       {
[17:01:03.996]                         base::local({
[17:01:03.996]                           has_future <- base::requireNamespace("future", 
[17:01:03.996]                             quietly = TRUE)
[17:01:03.996]                           if (has_future) {
[17:01:03.996]                             ns <- base::getNamespace("future")
[17:01:03.996]                             version <- ns[[".package"]][["version"]]
[17:01:03.996]                             if (is.null(version)) 
[17:01:03.996]                               version <- utils::packageVersion("future")
[17:01:03.996]                           }
[17:01:03.996]                           else {
[17:01:03.996]                             version <- NULL
[17:01:03.996]                           }
[17:01:03.996]                           if (!has_future || version < "1.8.0") {
[17:01:03.996]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:03.996]                               "", base::R.version$version.string), 
[17:01:03.996]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:03.996]                                 base::R.version$platform, 8 * 
[17:01:03.996]                                   base::.Machine$sizeof.pointer), 
[17:01:03.996]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:03.996]                                 "release", "version")], collapse = " "), 
[17:01:03.996]                               hostname = base::Sys.info()[["nodename"]])
[17:01:03.996]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:03.996]                               info)
[17:01:03.996]                             info <- base::paste(info, collapse = "; ")
[17:01:03.996]                             if (!has_future) {
[17:01:03.996]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:03.996]                                 info)
[17:01:03.996]                             }
[17:01:03.996]                             else {
[17:01:03.996]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:03.996]                                 info, version)
[17:01:03.996]                             }
[17:01:03.996]                             base::stop(msg)
[17:01:03.996]                           }
[17:01:03.996]                         })
[17:01:03.996]                       }
[17:01:03.996]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:03.996]                       base::options(mc.cores = 1L)
[17:01:03.996]                     }
[17:01:03.996]                     base::local({
[17:01:03.996]                       for (pkg in "future.apply") {
[17:01:03.996]                         base::loadNamespace(pkg)
[17:01:03.996]                         base::library(pkg, character.only = TRUE)
[17:01:03.996]                       }
[17:01:03.996]                     })
[17:01:03.996]                   }
[17:01:03.996]                   ...future.strategy.old <- future::plan("list")
[17:01:03.996]                   options(future.plan = NULL)
[17:01:03.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:03.996]                 }
[17:01:03.996]                 ...future.workdir <- getwd()
[17:01:03.996]             }
[17:01:03.996]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:03.996]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:03.996]         }
[17:01:03.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:03.996]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:03.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:03.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:03.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:03.996]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:03.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:03.996]             base::names(...future.oldOptions))
[17:01:03.996]     }
[17:01:03.996]     if (FALSE) {
[17:01:03.996]     }
[17:01:03.996]     else {
[17:01:03.996]         if (TRUE) {
[17:01:03.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:03.996]                 open = "w")
[17:01:03.996]         }
[17:01:03.996]         else {
[17:01:03.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:03.996]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:03.996]         }
[17:01:03.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:03.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:03.996]             base::sink(type = "output", split = FALSE)
[17:01:03.996]             base::close(...future.stdout)
[17:01:03.996]         }, add = TRUE)
[17:01:03.996]     }
[17:01:03.996]     ...future.frame <- base::sys.nframe()
[17:01:03.996]     ...future.conditions <- base::list()
[17:01:03.996]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:03.996]     if (FALSE) {
[17:01:03.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:03.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:03.996]     }
[17:01:03.996]     ...future.result <- base::tryCatch({
[17:01:03.996]         base::withCallingHandlers({
[17:01:03.996]             ...future.value <- base::withVisible(base::local({
[17:01:03.996]                 withCallingHandlers({
[17:01:03.996]                   {
[17:01:03.996]                     do.call(function(...) {
[17:01:03.996]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:03.996]                       if (!identical(...future.globals.maxSize.org, 
[17:01:03.996]                         ...future.globals.maxSize)) {
[17:01:03.996]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:03.996]                         on.exit(options(oopts), add = TRUE)
[17:01:03.996]                       }
[17:01:03.996]                       {
[17:01:03.996]                         lapply(seq_along(...future.elements_ii), 
[17:01:03.996]                           FUN = function(jj) {
[17:01:03.996]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:03.996]                             ...future.FUN(...future.X_jj, ...)
[17:01:03.996]                           })
[17:01:03.996]                       }
[17:01:03.996]                     }, args = future.call.arguments)
[17:01:03.996]                   }
[17:01:03.996]                 }, immediateCondition = function(cond) {
[17:01:03.996]                   save_rds <- function (object, pathname, ...) 
[17:01:03.996]                   {
[17:01:03.996]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:03.996]                     if (file_test("-f", pathname_tmp)) {
[17:01:03.996]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.996]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:03.996]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.996]                         fi_tmp[["mtime"]])
[17:01:03.996]                     }
[17:01:03.996]                     tryCatch({
[17:01:03.996]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:03.996]                     }, error = function(ex) {
[17:01:03.996]                       msg <- conditionMessage(ex)
[17:01:03.996]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.996]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:03.996]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.996]                         fi_tmp[["mtime"]], msg)
[17:01:03.996]                       ex$message <- msg
[17:01:03.996]                       stop(ex)
[17:01:03.996]                     })
[17:01:03.996]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:03.996]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:03.996]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:03.996]                       fi_tmp <- file.info(pathname_tmp)
[17:01:03.996]                       fi <- file.info(pathname)
[17:01:03.996]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:03.996]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:03.996]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:03.996]                         fi[["size"]], fi[["mtime"]])
[17:01:03.996]                       stop(msg)
[17:01:03.996]                     }
[17:01:03.996]                     invisible(pathname)
[17:01:03.996]                   }
[17:01:03.996]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:03.996]                     rootPath = tempdir()) 
[17:01:03.996]                   {
[17:01:03.996]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:03.996]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:03.996]                       tmpdir = path, fileext = ".rds")
[17:01:03.996]                     save_rds(obj, file)
[17:01:03.996]                   }
[17:01:03.996]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:03.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.996]                   {
[17:01:03.996]                     inherits <- base::inherits
[17:01:03.996]                     invokeRestart <- base::invokeRestart
[17:01:03.996]                     is.null <- base::is.null
[17:01:03.996]                     muffled <- FALSE
[17:01:03.996]                     if (inherits(cond, "message")) {
[17:01:03.996]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:03.996]                       if (muffled) 
[17:01:03.996]                         invokeRestart("muffleMessage")
[17:01:03.996]                     }
[17:01:03.996]                     else if (inherits(cond, "warning")) {
[17:01:03.996]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:03.996]                       if (muffled) 
[17:01:03.996]                         invokeRestart("muffleWarning")
[17:01:03.996]                     }
[17:01:03.996]                     else if (inherits(cond, "condition")) {
[17:01:03.996]                       if (!is.null(pattern)) {
[17:01:03.996]                         computeRestarts <- base::computeRestarts
[17:01:03.996]                         grepl <- base::grepl
[17:01:03.996]                         restarts <- computeRestarts(cond)
[17:01:03.996]                         for (restart in restarts) {
[17:01:03.996]                           name <- restart$name
[17:01:03.996]                           if (is.null(name)) 
[17:01:03.996]                             next
[17:01:03.996]                           if (!grepl(pattern, name)) 
[17:01:03.996]                             next
[17:01:03.996]                           invokeRestart(restart)
[17:01:03.996]                           muffled <- TRUE
[17:01:03.996]                           break
[17:01:03.996]                         }
[17:01:03.996]                       }
[17:01:03.996]                     }
[17:01:03.996]                     invisible(muffled)
[17:01:03.996]                   }
[17:01:03.996]                   muffleCondition(cond)
[17:01:03.996]                 })
[17:01:03.996]             }))
[17:01:03.996]             future::FutureResult(value = ...future.value$value, 
[17:01:03.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.996]                   ...future.rng), globalenv = if (FALSE) 
[17:01:03.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:03.996]                     ...future.globalenv.names))
[17:01:03.996]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:03.996]         }, condition = base::local({
[17:01:03.996]             c <- base::c
[17:01:03.996]             inherits <- base::inherits
[17:01:03.996]             invokeRestart <- base::invokeRestart
[17:01:03.996]             length <- base::length
[17:01:03.996]             list <- base::list
[17:01:03.996]             seq.int <- base::seq.int
[17:01:03.996]             signalCondition <- base::signalCondition
[17:01:03.996]             sys.calls <- base::sys.calls
[17:01:03.996]             `[[` <- base::`[[`
[17:01:03.996]             `+` <- base::`+`
[17:01:03.996]             `<<-` <- base::`<<-`
[17:01:03.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:03.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:03.996]                   3L)]
[17:01:03.996]             }
[17:01:03.996]             function(cond) {
[17:01:03.996]                 is_error <- inherits(cond, "error")
[17:01:03.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:03.996]                   NULL)
[17:01:03.996]                 if (is_error) {
[17:01:03.996]                   sessionInformation <- function() {
[17:01:03.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:03.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:03.996]                       search = base::search(), system = base::Sys.info())
[17:01:03.996]                   }
[17:01:03.996]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:03.996]                     cond$call), session = sessionInformation(), 
[17:01:03.996]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:03.996]                   signalCondition(cond)
[17:01:03.996]                 }
[17:01:03.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:03.996]                 "immediateCondition"))) {
[17:01:03.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:03.996]                   ...future.conditions[[length(...future.conditions) + 
[17:01:03.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:03.996]                   if (TRUE && !signal) {
[17:01:03.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.996]                     {
[17:01:03.996]                       inherits <- base::inherits
[17:01:03.996]                       invokeRestart <- base::invokeRestart
[17:01:03.996]                       is.null <- base::is.null
[17:01:03.996]                       muffled <- FALSE
[17:01:03.996]                       if (inherits(cond, "message")) {
[17:01:03.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.996]                         if (muffled) 
[17:01:03.996]                           invokeRestart("muffleMessage")
[17:01:03.996]                       }
[17:01:03.996]                       else if (inherits(cond, "warning")) {
[17:01:03.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.996]                         if (muffled) 
[17:01:03.996]                           invokeRestart("muffleWarning")
[17:01:03.996]                       }
[17:01:03.996]                       else if (inherits(cond, "condition")) {
[17:01:03.996]                         if (!is.null(pattern)) {
[17:01:03.996]                           computeRestarts <- base::computeRestarts
[17:01:03.996]                           grepl <- base::grepl
[17:01:03.996]                           restarts <- computeRestarts(cond)
[17:01:03.996]                           for (restart in restarts) {
[17:01:03.996]                             name <- restart$name
[17:01:03.996]                             if (is.null(name)) 
[17:01:03.996]                               next
[17:01:03.996]                             if (!grepl(pattern, name)) 
[17:01:03.996]                               next
[17:01:03.996]                             invokeRestart(restart)
[17:01:03.996]                             muffled <- TRUE
[17:01:03.996]                             break
[17:01:03.996]                           }
[17:01:03.996]                         }
[17:01:03.996]                       }
[17:01:03.996]                       invisible(muffled)
[17:01:03.996]                     }
[17:01:03.996]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.996]                   }
[17:01:03.996]                 }
[17:01:03.996]                 else {
[17:01:03.996]                   if (TRUE) {
[17:01:03.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:03.996]                     {
[17:01:03.996]                       inherits <- base::inherits
[17:01:03.996]                       invokeRestart <- base::invokeRestart
[17:01:03.996]                       is.null <- base::is.null
[17:01:03.996]                       muffled <- FALSE
[17:01:03.996]                       if (inherits(cond, "message")) {
[17:01:03.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:03.996]                         if (muffled) 
[17:01:03.996]                           invokeRestart("muffleMessage")
[17:01:03.996]                       }
[17:01:03.996]                       else if (inherits(cond, "warning")) {
[17:01:03.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:03.996]                         if (muffled) 
[17:01:03.996]                           invokeRestart("muffleWarning")
[17:01:03.996]                       }
[17:01:03.996]                       else if (inherits(cond, "condition")) {
[17:01:03.996]                         if (!is.null(pattern)) {
[17:01:03.996]                           computeRestarts <- base::computeRestarts
[17:01:03.996]                           grepl <- base::grepl
[17:01:03.996]                           restarts <- computeRestarts(cond)
[17:01:03.996]                           for (restart in restarts) {
[17:01:03.996]                             name <- restart$name
[17:01:03.996]                             if (is.null(name)) 
[17:01:03.996]                               next
[17:01:03.996]                             if (!grepl(pattern, name)) 
[17:01:03.996]                               next
[17:01:03.996]                             invokeRestart(restart)
[17:01:03.996]                             muffled <- TRUE
[17:01:03.996]                             break
[17:01:03.996]                           }
[17:01:03.996]                         }
[17:01:03.996]                       }
[17:01:03.996]                       invisible(muffled)
[17:01:03.996]                     }
[17:01:03.996]                     muffleCondition(cond, pattern = "^muffle")
[17:01:03.996]                   }
[17:01:03.996]                 }
[17:01:03.996]             }
[17:01:03.996]         }))
[17:01:03.996]     }, error = function(ex) {
[17:01:03.996]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:03.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:03.996]                 ...future.rng), started = ...future.startTime, 
[17:01:03.996]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:03.996]             version = "1.8"), class = "FutureResult")
[17:01:03.996]     }, finally = {
[17:01:03.996]         if (!identical(...future.workdir, getwd())) 
[17:01:03.996]             setwd(...future.workdir)
[17:01:03.996]         {
[17:01:03.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:03.996]                 ...future.oldOptions$nwarnings <- NULL
[17:01:03.996]             }
[17:01:03.996]             base::options(...future.oldOptions)
[17:01:03.996]             if (.Platform$OS.type == "windows") {
[17:01:03.996]                 old_names <- names(...future.oldEnvVars)
[17:01:03.996]                 envs <- base::Sys.getenv()
[17:01:03.996]                 names <- names(envs)
[17:01:03.996]                 common <- intersect(names, old_names)
[17:01:03.996]                 added <- setdiff(names, old_names)
[17:01:03.996]                 removed <- setdiff(old_names, names)
[17:01:03.996]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:03.996]                   envs[common]]
[17:01:03.996]                 NAMES <- toupper(changed)
[17:01:03.996]                 args <- list()
[17:01:03.996]                 for (kk in seq_along(NAMES)) {
[17:01:03.996]                   name <- changed[[kk]]
[17:01:03.996]                   NAME <- NAMES[[kk]]
[17:01:03.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.996]                     next
[17:01:03.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.996]                 }
[17:01:03.996]                 NAMES <- toupper(added)
[17:01:03.996]                 for (kk in seq_along(NAMES)) {
[17:01:03.996]                   name <- added[[kk]]
[17:01:03.996]                   NAME <- NAMES[[kk]]
[17:01:03.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.996]                     next
[17:01:03.996]                   args[[name]] <- ""
[17:01:03.996]                 }
[17:01:03.996]                 NAMES <- toupper(removed)
[17:01:03.996]                 for (kk in seq_along(NAMES)) {
[17:01:03.996]                   name <- removed[[kk]]
[17:01:03.996]                   NAME <- NAMES[[kk]]
[17:01:03.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:03.996]                     next
[17:01:03.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:03.996]                 }
[17:01:03.996]                 if (length(args) > 0) 
[17:01:03.996]                   base::do.call(base::Sys.setenv, args = args)
[17:01:03.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:03.996]             }
[17:01:03.996]             else {
[17:01:03.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:03.996]             }
[17:01:03.996]             {
[17:01:03.996]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:03.996]                   0L) {
[17:01:03.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:03.996]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:03.996]                   base::options(opts)
[17:01:03.996]                 }
[17:01:03.996]                 {
[17:01:03.996]                   {
[17:01:03.996]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:03.996]                     NULL
[17:01:03.996]                   }
[17:01:03.996]                   options(future.plan = NULL)
[17:01:03.996]                   if (is.na(NA_character_)) 
[17:01:03.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:03.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:03.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:03.996]                     .init = FALSE)
[17:01:03.996]                 }
[17:01:03.996]             }
[17:01:03.996]         }
[17:01:03.996]     })
[17:01:03.996]     if (TRUE) {
[17:01:03.996]         base::sink(type = "output", split = FALSE)
[17:01:03.996]         if (TRUE) {
[17:01:03.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:03.996]         }
[17:01:03.996]         else {
[17:01:03.996]             ...future.result["stdout"] <- base::list(NULL)
[17:01:03.996]         }
[17:01:03.996]         base::close(...future.stdout)
[17:01:03.996]         ...future.stdout <- NULL
[17:01:03.996]     }
[17:01:03.996]     ...future.result$conditions <- ...future.conditions
[17:01:03.996]     ...future.result$finished <- base::Sys.time()
[17:01:03.996]     ...future.result
[17:01:03.996] }
[17:01:03.999] assign_globals() ...
[17:01:03.999] List of 11
[17:01:03.999]  $ ...future.FUN            :function (x, ...)  
[17:01:03.999]  $ x_FUN                    :function (x)  
[17:01:03.999]  $ times                    : int 2
[17:01:03.999]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:03.999]  $ stop_if_not              :function (...)  
[17:01:03.999]  $ dim                      : NULL
[17:01:03.999]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:03.999]  $ future.call.arguments    : list()
[17:01:03.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:03.999]  $ ...future.elements_ii    :List of 1
[17:01:03.999]   ..$ : int 1
[17:01:03.999]  $ ...future.seeds_ii       : NULL
[17:01:03.999]  $ ...future.globals.maxSize: NULL
[17:01:03.999]  - attr(*, "where")=List of 11
[17:01:03.999]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:03.999]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:03.999]  - attr(*, "resolved")= logi FALSE
[17:01:03.999]  - attr(*, "total_size")= num 95128
[17:01:03.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:03.999]  - attr(*, "already-done")= logi TRUE
[17:01:04.009] - copied ‘...future.FUN’ to environment
[17:01:04.010] - copied ‘x_FUN’ to environment
[17:01:04.010] - copied ‘times’ to environment
[17:01:04.010] - copied ‘stopf’ to environment
[17:01:04.010] - copied ‘stop_if_not’ to environment
[17:01:04.010] - copied ‘dim’ to environment
[17:01:04.010] - copied ‘valid_types’ to environment
[17:01:04.010] - copied ‘future.call.arguments’ to environment
[17:01:04.010] - copied ‘...future.elements_ii’ to environment
[17:01:04.011] - copied ‘...future.seeds_ii’ to environment
[17:01:04.011] - copied ‘...future.globals.maxSize’ to environment
[17:01:04.011] assign_globals() ... done
[17:01:04.011] requestCore(): workers = 2
[17:01:04.014] MulticoreFuture started
[17:01:04.014] - Launch lazy future ... done
[17:01:04.015] run() for ‘MulticoreFuture’ ... done
[17:01:04.016] Created future:
[17:01:04.016] plan(): Setting new future strategy stack:
[17:01:04.016] List of future strategies:
[17:01:04.016] 1. sequential:
[17:01:04.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:04.016]    - tweaked: FALSE
[17:01:04.016]    - call: NULL
[17:01:04.018] plan(): nbrOfWorkers() = 1
[17:01:04.021] plan(): Setting new future strategy stack:
[17:01:04.021] List of future strategies:
[17:01:04.021] 1. multicore:
[17:01:04.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:04.021]    - tweaked: FALSE
[17:01:04.021]    - call: plan(strategy)
[17:01:04.027] plan(): nbrOfWorkers() = 2
[17:01:04.016] MulticoreFuture:
[17:01:04.016] Label: ‘future_vapply-1’
[17:01:04.016] Expression:
[17:01:04.016] {
[17:01:04.016]     do.call(function(...) {
[17:01:04.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.016]             on.exit(options(oopts), add = TRUE)
[17:01:04.016]         }
[17:01:04.016]         {
[17:01:04.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.016]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.016]             })
[17:01:04.016]         }
[17:01:04.016]     }, args = future.call.arguments)
[17:01:04.016] }
[17:01:04.016] Lazy evaluation: FALSE
[17:01:04.016] Asynchronous evaluation: TRUE
[17:01:04.016] Local evaluation: TRUE
[17:01:04.016] Environment: R_GlobalEnv
[17:01:04.016] Capture standard output: TRUE
[17:01:04.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:04.016] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:04.016] Packages: 1 packages (‘future.apply’)
[17:01:04.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:04.016] Resolved: FALSE
[17:01:04.016] Value: <not collected>
[17:01:04.016] Conditions captured: <none>
[17:01:04.016] Early signaling: FALSE
[17:01:04.016] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:04.016] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.031] Chunk #1 of 2 ... DONE
[17:01:04.031] Chunk #2 of 2 ...
[17:01:04.031]  - Finding globals in 'X' for chunk #2 ...
[17:01:04.031] getGlobalsAndPackages() ...
[17:01:04.032] Searching for globals...
[17:01:04.032] 
[17:01:04.032] Searching for globals ... DONE
[17:01:04.032] - globals: [0] <none>
[17:01:04.032] getGlobalsAndPackages() ... DONE
[17:01:04.033]    + additional globals found: [n=0] 
[17:01:04.033]    + additional namespaces needed: [n=0] 
[17:01:04.033]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:04.033]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:04.033]  - seeds: <none>
[17:01:04.033]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.034] getGlobalsAndPackages() ...
[17:01:04.034] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.034] Resolving globals: FALSE
[17:01:04.034] Tweak future expression to call with '...' arguments ...
[17:01:04.034] {
[17:01:04.034]     do.call(function(...) {
[17:01:04.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.034]             on.exit(options(oopts), add = TRUE)
[17:01:04.034]         }
[17:01:04.034]         {
[17:01:04.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.034]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.034]             })
[17:01:04.034]         }
[17:01:04.034]     }, args = future.call.arguments)
[17:01:04.034] }
[17:01:04.035] Tweak future expression to call with '...' arguments ... DONE
[17:01:04.035] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.036] - packages: [1] ‘future.apply’
[17:01:04.036] getGlobalsAndPackages() ... DONE
[17:01:04.036] run() for ‘Future’ ...
[17:01:04.036] - state: ‘created’
[17:01:04.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:01:04.041] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:01:04.041]   - Field: ‘label’
[17:01:04.041]   - Field: ‘local’
[17:01:04.041]   - Field: ‘owner’
[17:01:04.042]   - Field: ‘envir’
[17:01:04.042]   - Field: ‘workers’
[17:01:04.042]   - Field: ‘packages’
[17:01:04.042]   - Field: ‘gc’
[17:01:04.042]   - Field: ‘job’
[17:01:04.042]   - Field: ‘conditions’
[17:01:04.042]   - Field: ‘expr’
[17:01:04.042]   - Field: ‘uuid’
[17:01:04.043]   - Field: ‘seed’
[17:01:04.043]   - Field: ‘version’
[17:01:04.043]   - Field: ‘result’
[17:01:04.043]   - Field: ‘asynchronous’
[17:01:04.043]   - Field: ‘calls’
[17:01:04.043]   - Field: ‘globals’
[17:01:04.044]   - Field: ‘stdout’
[17:01:04.044]   - Field: ‘earlySignal’
[17:01:04.044]   - Field: ‘lazy’
[17:01:04.044]   - Field: ‘state’
[17:01:04.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:01:04.044] - Launch lazy future ...
[17:01:04.045] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:04.045] Packages needed by future strategies (n = 0): <none>
[17:01:04.046] {
[17:01:04.046]     {
[17:01:04.046]         {
[17:01:04.046]             ...future.startTime <- base::Sys.time()
[17:01:04.046]             {
[17:01:04.046]                 {
[17:01:04.046]                   {
[17:01:04.046]                     {
[17:01:04.046]                       {
[17:01:04.046]                         base::local({
[17:01:04.046]                           has_future <- base::requireNamespace("future", 
[17:01:04.046]                             quietly = TRUE)
[17:01:04.046]                           if (has_future) {
[17:01:04.046]                             ns <- base::getNamespace("future")
[17:01:04.046]                             version <- ns[[".package"]][["version"]]
[17:01:04.046]                             if (is.null(version)) 
[17:01:04.046]                               version <- utils::packageVersion("future")
[17:01:04.046]                           }
[17:01:04.046]                           else {
[17:01:04.046]                             version <- NULL
[17:01:04.046]                           }
[17:01:04.046]                           if (!has_future || version < "1.8.0") {
[17:01:04.046]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:04.046]                               "", base::R.version$version.string), 
[17:01:04.046]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:04.046]                                 base::R.version$platform, 8 * 
[17:01:04.046]                                   base::.Machine$sizeof.pointer), 
[17:01:04.046]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:04.046]                                 "release", "version")], collapse = " "), 
[17:01:04.046]                               hostname = base::Sys.info()[["nodename"]])
[17:01:04.046]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:04.046]                               info)
[17:01:04.046]                             info <- base::paste(info, collapse = "; ")
[17:01:04.046]                             if (!has_future) {
[17:01:04.046]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:04.046]                                 info)
[17:01:04.046]                             }
[17:01:04.046]                             else {
[17:01:04.046]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:04.046]                                 info, version)
[17:01:04.046]                             }
[17:01:04.046]                             base::stop(msg)
[17:01:04.046]                           }
[17:01:04.046]                         })
[17:01:04.046]                       }
[17:01:04.046]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:04.046]                       base::options(mc.cores = 1L)
[17:01:04.046]                     }
[17:01:04.046]                     base::local({
[17:01:04.046]                       for (pkg in "future.apply") {
[17:01:04.046]                         base::loadNamespace(pkg)
[17:01:04.046]                         base::library(pkg, character.only = TRUE)
[17:01:04.046]                       }
[17:01:04.046]                     })
[17:01:04.046]                   }
[17:01:04.046]                   ...future.strategy.old <- future::plan("list")
[17:01:04.046]                   options(future.plan = NULL)
[17:01:04.046]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.046]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:04.046]                 }
[17:01:04.046]                 ...future.workdir <- getwd()
[17:01:04.046]             }
[17:01:04.046]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:04.046]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:04.046]         }
[17:01:04.046]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:04.046]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:04.046]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:04.046]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:04.046]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:04.046]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:04.046]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:04.046]             base::names(...future.oldOptions))
[17:01:04.046]     }
[17:01:04.046]     if (FALSE) {
[17:01:04.046]     }
[17:01:04.046]     else {
[17:01:04.046]         if (TRUE) {
[17:01:04.046]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:04.046]                 open = "w")
[17:01:04.046]         }
[17:01:04.046]         else {
[17:01:04.046]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:04.046]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:04.046]         }
[17:01:04.046]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:04.046]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:04.046]             base::sink(type = "output", split = FALSE)
[17:01:04.046]             base::close(...future.stdout)
[17:01:04.046]         }, add = TRUE)
[17:01:04.046]     }
[17:01:04.046]     ...future.frame <- base::sys.nframe()
[17:01:04.046]     ...future.conditions <- base::list()
[17:01:04.046]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:04.046]     if (FALSE) {
[17:01:04.046]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:04.046]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:04.046]     }
[17:01:04.046]     ...future.result <- base::tryCatch({
[17:01:04.046]         base::withCallingHandlers({
[17:01:04.046]             ...future.value <- base::withVisible(base::local({
[17:01:04.046]                 withCallingHandlers({
[17:01:04.046]                   {
[17:01:04.046]                     do.call(function(...) {
[17:01:04.046]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.046]                       if (!identical(...future.globals.maxSize.org, 
[17:01:04.046]                         ...future.globals.maxSize)) {
[17:01:04.046]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.046]                         on.exit(options(oopts), add = TRUE)
[17:01:04.046]                       }
[17:01:04.046]                       {
[17:01:04.046]                         lapply(seq_along(...future.elements_ii), 
[17:01:04.046]                           FUN = function(jj) {
[17:01:04.046]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.046]                             ...future.FUN(...future.X_jj, ...)
[17:01:04.046]                           })
[17:01:04.046]                       }
[17:01:04.046]                     }, args = future.call.arguments)
[17:01:04.046]                   }
[17:01:04.046]                 }, immediateCondition = function(cond) {
[17:01:04.046]                   save_rds <- function (object, pathname, ...) 
[17:01:04.046]                   {
[17:01:04.046]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:01:04.046]                     if (file_test("-f", pathname_tmp)) {
[17:01:04.046]                       fi_tmp <- file.info(pathname_tmp)
[17:01:04.046]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:01:04.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:04.046]                         fi_tmp[["mtime"]])
[17:01:04.046]                     }
[17:01:04.046]                     tryCatch({
[17:01:04.046]                       saveRDS(object, file = pathname_tmp, ...)
[17:01:04.046]                     }, error = function(ex) {
[17:01:04.046]                       msg <- conditionMessage(ex)
[17:01:04.046]                       fi_tmp <- file.info(pathname_tmp)
[17:01:04.046]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:01:04.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:04.046]                         fi_tmp[["mtime"]], msg)
[17:01:04.046]                       ex$message <- msg
[17:01:04.046]                       stop(ex)
[17:01:04.046]                     })
[17:01:04.046]                     stopifnot(file_test("-f", pathname_tmp))
[17:01:04.046]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:01:04.046]                     if (!res || file_test("-f", pathname_tmp)) {
[17:01:04.046]                       fi_tmp <- file.info(pathname_tmp)
[17:01:04.046]                       fi <- file.info(pathname)
[17:01:04.046]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:01:04.046]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:01:04.046]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:01:04.046]                         fi[["size"]], fi[["mtime"]])
[17:01:04.046]                       stop(msg)
[17:01:04.046]                     }
[17:01:04.046]                     invisible(pathname)
[17:01:04.046]                   }
[17:01:04.046]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:01:04.046]                     rootPath = tempdir()) 
[17:01:04.046]                   {
[17:01:04.046]                     obj <- list(time = Sys.time(), condition = cond)
[17:01:04.046]                     file <- tempfile(pattern = class(cond)[1], 
[17:01:04.046]                       tmpdir = path, fileext = ".rds")
[17:01:04.046]                     save_rds(obj, file)
[17:01:04.046]                   }
[17:01:04.046]                   saveImmediateCondition(cond, path = "/tmp/RtmpvZBCzZ/.future/immediateConditions")
[17:01:04.046]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.046]                   {
[17:01:04.046]                     inherits <- base::inherits
[17:01:04.046]                     invokeRestart <- base::invokeRestart
[17:01:04.046]                     is.null <- base::is.null
[17:01:04.046]                     muffled <- FALSE
[17:01:04.046]                     if (inherits(cond, "message")) {
[17:01:04.046]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:04.046]                       if (muffled) 
[17:01:04.046]                         invokeRestart("muffleMessage")
[17:01:04.046]                     }
[17:01:04.046]                     else if (inherits(cond, "warning")) {
[17:01:04.046]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:04.046]                       if (muffled) 
[17:01:04.046]                         invokeRestart("muffleWarning")
[17:01:04.046]                     }
[17:01:04.046]                     else if (inherits(cond, "condition")) {
[17:01:04.046]                       if (!is.null(pattern)) {
[17:01:04.046]                         computeRestarts <- base::computeRestarts
[17:01:04.046]                         grepl <- base::grepl
[17:01:04.046]                         restarts <- computeRestarts(cond)
[17:01:04.046]                         for (restart in restarts) {
[17:01:04.046]                           name <- restart$name
[17:01:04.046]                           if (is.null(name)) 
[17:01:04.046]                             next
[17:01:04.046]                           if (!grepl(pattern, name)) 
[17:01:04.046]                             next
[17:01:04.046]                           invokeRestart(restart)
[17:01:04.046]                           muffled <- TRUE
[17:01:04.046]                           break
[17:01:04.046]                         }
[17:01:04.046]                       }
[17:01:04.046]                     }
[17:01:04.046]                     invisible(muffled)
[17:01:04.046]                   }
[17:01:04.046]                   muffleCondition(cond)
[17:01:04.046]                 })
[17:01:04.046]             }))
[17:01:04.046]             future::FutureResult(value = ...future.value$value, 
[17:01:04.046]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.046]                   ...future.rng), globalenv = if (FALSE) 
[17:01:04.046]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:04.046]                     ...future.globalenv.names))
[17:01:04.046]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:04.046]         }, condition = base::local({
[17:01:04.046]             c <- base::c
[17:01:04.046]             inherits <- base::inherits
[17:01:04.046]             invokeRestart <- base::invokeRestart
[17:01:04.046]             length <- base::length
[17:01:04.046]             list <- base::list
[17:01:04.046]             seq.int <- base::seq.int
[17:01:04.046]             signalCondition <- base::signalCondition
[17:01:04.046]             sys.calls <- base::sys.calls
[17:01:04.046]             `[[` <- base::`[[`
[17:01:04.046]             `+` <- base::`+`
[17:01:04.046]             `<<-` <- base::`<<-`
[17:01:04.046]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:04.046]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:04.046]                   3L)]
[17:01:04.046]             }
[17:01:04.046]             function(cond) {
[17:01:04.046]                 is_error <- inherits(cond, "error")
[17:01:04.046]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:04.046]                   NULL)
[17:01:04.046]                 if (is_error) {
[17:01:04.046]                   sessionInformation <- function() {
[17:01:04.046]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:04.046]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:04.046]                       search = base::search(), system = base::Sys.info())
[17:01:04.046]                   }
[17:01:04.046]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.046]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:04.046]                     cond$call), session = sessionInformation(), 
[17:01:04.046]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:04.046]                   signalCondition(cond)
[17:01:04.046]                 }
[17:01:04.046]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:04.046]                 "immediateCondition"))) {
[17:01:04.046]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:04.046]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.046]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:04.046]                   if (TRUE && !signal) {
[17:01:04.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.046]                     {
[17:01:04.046]                       inherits <- base::inherits
[17:01:04.046]                       invokeRestart <- base::invokeRestart
[17:01:04.046]                       is.null <- base::is.null
[17:01:04.046]                       muffled <- FALSE
[17:01:04.046]                       if (inherits(cond, "message")) {
[17:01:04.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.046]                         if (muffled) 
[17:01:04.046]                           invokeRestart("muffleMessage")
[17:01:04.046]                       }
[17:01:04.046]                       else if (inherits(cond, "warning")) {
[17:01:04.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.046]                         if (muffled) 
[17:01:04.046]                           invokeRestart("muffleWarning")
[17:01:04.046]                       }
[17:01:04.046]                       else if (inherits(cond, "condition")) {
[17:01:04.046]                         if (!is.null(pattern)) {
[17:01:04.046]                           computeRestarts <- base::computeRestarts
[17:01:04.046]                           grepl <- base::grepl
[17:01:04.046]                           restarts <- computeRestarts(cond)
[17:01:04.046]                           for (restart in restarts) {
[17:01:04.046]                             name <- restart$name
[17:01:04.046]                             if (is.null(name)) 
[17:01:04.046]                               next
[17:01:04.046]                             if (!grepl(pattern, name)) 
[17:01:04.046]                               next
[17:01:04.046]                             invokeRestart(restart)
[17:01:04.046]                             muffled <- TRUE
[17:01:04.046]                             break
[17:01:04.046]                           }
[17:01:04.046]                         }
[17:01:04.046]                       }
[17:01:04.046]                       invisible(muffled)
[17:01:04.046]                     }
[17:01:04.046]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.046]                   }
[17:01:04.046]                 }
[17:01:04.046]                 else {
[17:01:04.046]                   if (TRUE) {
[17:01:04.046]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.046]                     {
[17:01:04.046]                       inherits <- base::inherits
[17:01:04.046]                       invokeRestart <- base::invokeRestart
[17:01:04.046]                       is.null <- base::is.null
[17:01:04.046]                       muffled <- FALSE
[17:01:04.046]                       if (inherits(cond, "message")) {
[17:01:04.046]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.046]                         if (muffled) 
[17:01:04.046]                           invokeRestart("muffleMessage")
[17:01:04.046]                       }
[17:01:04.046]                       else if (inherits(cond, "warning")) {
[17:01:04.046]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.046]                         if (muffled) 
[17:01:04.046]                           invokeRestart("muffleWarning")
[17:01:04.046]                       }
[17:01:04.046]                       else if (inherits(cond, "condition")) {
[17:01:04.046]                         if (!is.null(pattern)) {
[17:01:04.046]                           computeRestarts <- base::computeRestarts
[17:01:04.046]                           grepl <- base::grepl
[17:01:04.046]                           restarts <- computeRestarts(cond)
[17:01:04.046]                           for (restart in restarts) {
[17:01:04.046]                             name <- restart$name
[17:01:04.046]                             if (is.null(name)) 
[17:01:04.046]                               next
[17:01:04.046]                             if (!grepl(pattern, name)) 
[17:01:04.046]                               next
[17:01:04.046]                             invokeRestart(restart)
[17:01:04.046]                             muffled <- TRUE
[17:01:04.046]                             break
[17:01:04.046]                           }
[17:01:04.046]                         }
[17:01:04.046]                       }
[17:01:04.046]                       invisible(muffled)
[17:01:04.046]                     }
[17:01:04.046]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.046]                   }
[17:01:04.046]                 }
[17:01:04.046]             }
[17:01:04.046]         }))
[17:01:04.046]     }, error = function(ex) {
[17:01:04.046]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:04.046]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.046]                 ...future.rng), started = ...future.startTime, 
[17:01:04.046]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:04.046]             version = "1.8"), class = "FutureResult")
[17:01:04.046]     }, finally = {
[17:01:04.046]         if (!identical(...future.workdir, getwd())) 
[17:01:04.046]             setwd(...future.workdir)
[17:01:04.046]         {
[17:01:04.046]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:04.046]                 ...future.oldOptions$nwarnings <- NULL
[17:01:04.046]             }
[17:01:04.046]             base::options(...future.oldOptions)
[17:01:04.046]             if (.Platform$OS.type == "windows") {
[17:01:04.046]                 old_names <- names(...future.oldEnvVars)
[17:01:04.046]                 envs <- base::Sys.getenv()
[17:01:04.046]                 names <- names(envs)
[17:01:04.046]                 common <- intersect(names, old_names)
[17:01:04.046]                 added <- setdiff(names, old_names)
[17:01:04.046]                 removed <- setdiff(old_names, names)
[17:01:04.046]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:04.046]                   envs[common]]
[17:01:04.046]                 NAMES <- toupper(changed)
[17:01:04.046]                 args <- list()
[17:01:04.046]                 for (kk in seq_along(NAMES)) {
[17:01:04.046]                   name <- changed[[kk]]
[17:01:04.046]                   NAME <- NAMES[[kk]]
[17:01:04.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.046]                     next
[17:01:04.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.046]                 }
[17:01:04.046]                 NAMES <- toupper(added)
[17:01:04.046]                 for (kk in seq_along(NAMES)) {
[17:01:04.046]                   name <- added[[kk]]
[17:01:04.046]                   NAME <- NAMES[[kk]]
[17:01:04.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.046]                     next
[17:01:04.046]                   args[[name]] <- ""
[17:01:04.046]                 }
[17:01:04.046]                 NAMES <- toupper(removed)
[17:01:04.046]                 for (kk in seq_along(NAMES)) {
[17:01:04.046]                   name <- removed[[kk]]
[17:01:04.046]                   NAME <- NAMES[[kk]]
[17:01:04.046]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.046]                     next
[17:01:04.046]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.046]                 }
[17:01:04.046]                 if (length(args) > 0) 
[17:01:04.046]                   base::do.call(base::Sys.setenv, args = args)
[17:01:04.046]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:04.046]             }
[17:01:04.046]             else {
[17:01:04.046]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:04.046]             }
[17:01:04.046]             {
[17:01:04.046]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:04.046]                   0L) {
[17:01:04.046]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:04.046]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:04.046]                   base::options(opts)
[17:01:04.046]                 }
[17:01:04.046]                 {
[17:01:04.046]                   {
[17:01:04.046]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:04.046]                     NULL
[17:01:04.046]                   }
[17:01:04.046]                   options(future.plan = NULL)
[17:01:04.046]                   if (is.na(NA_character_)) 
[17:01:04.046]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.046]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:04.046]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:04.046]                     .init = FALSE)
[17:01:04.046]                 }
[17:01:04.046]             }
[17:01:04.046]         }
[17:01:04.046]     })
[17:01:04.046]     if (TRUE) {
[17:01:04.046]         base::sink(type = "output", split = FALSE)
[17:01:04.046]         if (TRUE) {
[17:01:04.046]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:04.046]         }
[17:01:04.046]         else {
[17:01:04.046]             ...future.result["stdout"] <- base::list(NULL)
[17:01:04.046]         }
[17:01:04.046]         base::close(...future.stdout)
[17:01:04.046]         ...future.stdout <- NULL
[17:01:04.046]     }
[17:01:04.046]     ...future.result$conditions <- ...future.conditions
[17:01:04.046]     ...future.result$finished <- base::Sys.time()
[17:01:04.046]     ...future.result
[17:01:04.046] }
[17:01:04.049] assign_globals() ...
[17:01:04.049] List of 11
[17:01:04.049]  $ ...future.FUN            :function (x, ...)  
[17:01:04.049]  $ x_FUN                    :function (x)  
[17:01:04.049]  $ times                    : int 2
[17:01:04.049]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:04.049]  $ stop_if_not              :function (...)  
[17:01:04.049]  $ dim                      : NULL
[17:01:04.049]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:01:04.049]  $ future.call.arguments    : list()
[17:01:04.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:04.049]  $ ...future.elements_ii    :List of 2
[17:01:04.049]   ..$ : int 2
[17:01:04.049]   ..$ : int 3
[17:01:04.049]  $ ...future.seeds_ii       : NULL
[17:01:04.049]  $ ...future.globals.maxSize: NULL
[17:01:04.049]  - attr(*, "where")=List of 11
[17:01:04.049]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ times                    :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:01:04.049]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:01:04.049]  - attr(*, "resolved")= logi FALSE
[17:01:04.049]  - attr(*, "total_size")= num 95128
[17:01:04.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:04.049]  - attr(*, "already-done")= logi TRUE
[17:01:04.063] - copied ‘...future.FUN’ to environment
[17:01:04.063] - copied ‘x_FUN’ to environment
[17:01:04.063] - copied ‘times’ to environment
[17:01:04.064] - copied ‘stopf’ to environment
[17:01:04.064] - copied ‘stop_if_not’ to environment
[17:01:04.064] - copied ‘dim’ to environment
[17:01:04.064] - copied ‘valid_types’ to environment
[17:01:04.064] - copied ‘future.call.arguments’ to environment
[17:01:04.064] - copied ‘...future.elements_ii’ to environment
[17:01:04.064] - copied ‘...future.seeds_ii’ to environment
[17:01:04.065] - copied ‘...future.globals.maxSize’ to environment
[17:01:04.065] assign_globals() ... done
[17:01:04.065] requestCore(): workers = 2
[17:01:04.067] MulticoreFuture started
[17:01:04.068] - Launch lazy future ... done
[17:01:04.069] run() for ‘MulticoreFuture’ ... done
[17:01:04.069] Created future:
[17:01:04.069] plan(): Setting new future strategy stack:
[17:01:04.070] List of future strategies:
[17:01:04.070] 1. sequential:
[17:01:04.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:04.070]    - tweaked: FALSE
[17:01:04.070]    - call: NULL
[17:01:04.071] plan(): nbrOfWorkers() = 1
[17:01:04.073] plan(): Setting new future strategy stack:
[17:01:04.074] List of future strategies:
[17:01:04.074] 1. multicore:
[17:01:04.074]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:01:04.074]    - tweaked: FALSE
[17:01:04.074]    - call: plan(strategy)
[17:01:04.079] plan(): nbrOfWorkers() = 2
[17:01:04.070] MulticoreFuture:
[17:01:04.070] Label: ‘future_vapply-2’
[17:01:04.070] Expression:
[17:01:04.070] {
[17:01:04.070]     do.call(function(...) {
[17:01:04.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.070]             on.exit(options(oopts), add = TRUE)
[17:01:04.070]         }
[17:01:04.070]         {
[17:01:04.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.070]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.070]             })
[17:01:04.070]         }
[17:01:04.070]     }, args = future.call.arguments)
[17:01:04.070] }
[17:01:04.070] Lazy evaluation: FALSE
[17:01:04.070] Asynchronous evaluation: TRUE
[17:01:04.070] Local evaluation: TRUE
[17:01:04.070] Environment: R_GlobalEnv
[17:01:04.070] Capture standard output: TRUE
[17:01:04.070] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:04.070] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:04.070] Packages: 1 packages (‘future.apply’)
[17:01:04.070] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:04.070] Resolved: FALSE
[17:01:04.070] Value: <not collected>
[17:01:04.070] Conditions captured: <none>
[17:01:04.070] Early signaling: FALSE
[17:01:04.070] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:04.070] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.083] Chunk #2 of 2 ... DONE
[17:01:04.083] Launching 2 futures (chunks) ... DONE
[17:01:04.083] Resolving 2 futures (chunks) ...
[17:01:04.083] resolve() on list ...
[17:01:04.084]  recursive: 0
[17:01:04.084]  length: 2
[17:01:04.084] 
[17:01:04.084] Future #1
[17:01:04.084] result() for MulticoreFuture ...
[17:01:04.091] result() for MulticoreFuture ...
[17:01:04.091] result() for MulticoreFuture ... done
[17:01:04.091] signalConditions() ...
[17:01:04.092]  - include = ‘immediateCondition’
[17:01:04.092]  - exclude = 
[17:01:04.092]  - resignal = FALSE
[17:01:04.092]  - Number of conditions: 1
[17:01:04.092] signalConditions() ... done
[17:01:04.092] result() for MulticoreFuture ... done
[17:01:04.092] result() for MulticoreFuture ...
[17:01:04.093] result() for MulticoreFuture ... done
[17:01:04.093] signalConditions() ...
[17:01:04.093]  - include = ‘immediateCondition’
[17:01:04.093]  - exclude = 
[17:01:04.093]  - resignal = FALSE
[17:01:04.093]  - Number of conditions: 1
[17:01:04.093] signalConditions() ... done
[17:01:04.094] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:01:04.094] - nx: 2
[17:01:04.094] - relay: TRUE
[17:01:04.094] - stdout: TRUE
[17:01:04.094] - signal: TRUE
[17:01:04.094] - resignal: FALSE
[17:01:04.094] - force: TRUE
[17:01:04.095] - relayed: [n=2] FALSE, FALSE
[17:01:04.095] - queued futures: [n=2] FALSE, FALSE
[17:01:04.095]  - until=1
[17:01:04.095]  - relaying element #1
[17:01:04.095] result() for MulticoreFuture ...
[17:01:04.095] result() for MulticoreFuture ... done
[17:01:04.096] result() for MulticoreFuture ...
[17:01:04.096] result() for MulticoreFuture ... done
[17:01:04.096] signalConditions() ...
[17:01:04.096]  - include = ‘immediateCondition’
[17:01:04.096]  - exclude = 
[17:01:04.096]  - resignal = FALSE
[17:01:04.096]  - Number of conditions: 1
[17:01:04.096] signalConditions() ... done
[17:01:04.097] result() for MulticoreFuture ...
[17:01:04.097] result() for MulticoreFuture ... done
[17:01:04.097] signalConditions() ...
[17:01:04.097]  - include = ‘immediateCondition’
[17:01:04.097]  - exclude = 
[17:01:04.097]  - resignal = FALSE
[17:01:04.097]  - Number of conditions: 1
[17:01:04.098] signalConditions() ... done
[17:01:04.098] result() for MulticoreFuture ...
[17:01:04.098] result() for MulticoreFuture ... done
[17:01:04.098] signalConditions() ...
[17:01:04.098]  - include = ‘condition’
[17:01:04.098]  - exclude = ‘immediateCondition’
[17:01:04.098]  - resignal = TRUE
[17:01:04.102]  - Number of conditions: 1
[17:01:04.102]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:01:04.102] signalConditions() ... done
[17:01:04.103] - relayed: [n=2] FALSE, FALSE
[17:01:04.103] - queued futures: [n=2] TRUE, FALSE
[17:01:04.103] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:01:04.104] plan(): Setting new future strategy stack:
[17:01:04.104] List of future strategies:
[17:01:04.104] 1. sequential:
[17:01:04.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:04.104]    - tweaked: FALSE
[17:01:04.104]    - call: plan(sequential)
[17:01:04.105] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:01:04.105] plan(): Setting new future strategy stack:
[17:01:04.106] List of future strategies:
[17:01:04.106] 1. multisession:
[17:01:04.106]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:04.106]    - tweaked: FALSE
[17:01:04.106]    - call: plan(strategy)
[17:01:04.106] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:01:04.106] multisession:
[17:01:04.106] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:01:04.106] - tweaked: FALSE
[17:01:04.106] - call: plan(strategy)
[17:01:04.114] getGlobalsAndPackages() ...
[17:01:04.114] Not searching for globals
[17:01:04.114] - globals: [0] <none>
[17:01:04.115] getGlobalsAndPackages() ... DONE
[17:01:04.115] [local output] makeClusterPSOCK() ...
[17:01:04.170] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:01:04.171] [local output] Base port: 11756
[17:01:04.171] [local output] Getting setup options for 2 cluster nodes ...
[17:01:04.172] [local output]  - Node 1 of 2 ...
[17:01:04.172] [local output] localMachine=TRUE => revtunnel=FALSE

[17:01:04.173] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvZBCzZ/worker.rank=1.parallelly.parent=36646.8f2651c4c253.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpvZBCzZ/worker.rank=1.parallelly.parent=36646.8f2651c4c253.pid")'’
[17:01:04.360] - Possible to infer worker's PID: TRUE
[17:01:04.361] [local output] Rscript port: 11756

[17:01:04.361] [local output]  - Node 2 of 2 ...
[17:01:04.361] [local output] localMachine=TRUE => revtunnel=FALSE

[17:01:04.362] [local output] Rscript port: 11756

[17:01:04.362] [local output] Getting setup options for 2 cluster nodes ... done
[17:01:04.362] [local output]  - Parallel setup requested for some PSOCK nodes
[17:01:04.363] [local output] Setting up PSOCK nodes in parallel
[17:01:04.363] List of 36
[17:01:04.363]  $ worker          : chr "localhost"
[17:01:04.363]   ..- attr(*, "localhost")= logi TRUE
[17:01:04.363]  $ master          : chr "localhost"
[17:01:04.363]  $ port            : int 11756
[17:01:04.363]  $ connectTimeout  : num 120
[17:01:04.363]  $ timeout         : num 2592000
[17:01:04.363]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:01:04.363]  $ homogeneous     : logi TRUE
[17:01:04.363]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:01:04.363]  $ rscript_envs    : NULL
[17:01:04.363]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:01:04.363]  $ rscript_startup : NULL
[17:01:04.363]  $ rscript_sh      : chr "sh"
[17:01:04.363]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:01:04.363]  $ methods         : logi TRUE
[17:01:04.363]  $ socketOptions   : chr "no-delay"
[17:01:04.363]  $ useXDR          : logi FALSE
[17:01:04.363]  $ outfile         : chr "/dev/null"
[17:01:04.363]  $ renice          : int NA
[17:01:04.363]  $ rshcmd          : NULL
[17:01:04.363]  $ user            : chr(0) 
[17:01:04.363]  $ revtunnel       : logi FALSE
[17:01:04.363]  $ rshlogfile      : NULL
[17:01:04.363]  $ rshopts         : chr(0) 
[17:01:04.363]  $ rank            : int 1
[17:01:04.363]  $ manual          : logi FALSE
[17:01:04.363]  $ dryrun          : logi FALSE
[17:01:04.363]  $ quiet           : logi FALSE
[17:01:04.363]  $ setup_strategy  : chr "parallel"
[17:01:04.363]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:01:04.363]  $ pidfile         : chr "/tmp/RtmpvZBCzZ/worker.rank=1.parallelly.parent=36646.8f2651c4c253.pid"
[17:01:04.363]  $ rshcmd_label    : NULL
[17:01:04.363]  $ rsh_call        : NULL
[17:01:04.363]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:01:04.363]  $ localMachine    : logi TRUE
[17:01:04.363]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:01:04.363]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:01:04.363]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:01:04.363]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:01:04.363]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:01:04.363]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:01:04.363]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:01:04.363]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:01:04.363]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:01:04.363]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:01:04.363]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:01:04.363]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:01:04.363]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:01:04.363]  $ arguments       :List of 28
[17:01:04.363]   ..$ worker          : chr "localhost"
[17:01:04.363]   ..$ master          : NULL
[17:01:04.363]   ..$ port            : int 11756
[17:01:04.363]   ..$ connectTimeout  : num 120
[17:01:04.363]   ..$ timeout         : num 2592000
[17:01:04.363]   ..$ rscript         : NULL
[17:01:04.363]   ..$ homogeneous     : NULL
[17:01:04.363]   ..$ rscript_args    : NULL
[17:01:04.363]   ..$ rscript_envs    : NULL
[17:01:04.363]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:01:04.363]   ..$ rscript_startup : NULL
[17:01:04.363]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:01:04.363]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:01:04.363]   ..$ methods         : logi TRUE
[17:01:04.363]   ..$ socketOptions   : chr "no-delay"
[17:01:04.363]   ..$ useXDR          : logi FALSE
[17:01:04.363]   ..$ outfile         : chr "/dev/null"
[17:01:04.363]   ..$ renice          : int NA
[17:01:04.363]   ..$ rshcmd          : NULL
[17:01:04.363]   ..$ user            : NULL
[17:01:04.363]   ..$ revtunnel       : logi NA
[17:01:04.363]   ..$ rshlogfile      : NULL
[17:01:04.363]   ..$ rshopts         : NULL
[17:01:04.363]   ..$ rank            : int 1
[17:01:04.363]   ..$ manual          : logi FALSE
[17:01:04.363]   ..$ dryrun          : logi FALSE
[17:01:04.363]   ..$ quiet           : logi FALSE
[17:01:04.363]   ..$ setup_strategy  : chr "parallel"
[17:01:04.363]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:01:04.381] [local output] System call to launch all workers:
[17:01:04.381] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpvZBCzZ/worker.rank=1.parallelly.parent=36646.8f2651c4c253.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11756 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:01:04.381] [local output] Starting PSOCK main server
[17:01:04.387] [local output] Workers launched
[17:01:04.387] [local output] Waiting for workers to connect back
[17:01:04.387]  - [local output] 0 workers out of 2 ready
[17:01:04.630]  - [local output] 0 workers out of 2 ready
[17:01:04.631]  - [local output] 1 workers out of 2 ready
[17:01:04.631]  - [local output] 2 workers out of 2 ready
[17:01:04.631] [local output] Launching of workers completed
[17:01:04.631] [local output] Collecting session information from workers
[17:01:04.632] [local output]  - Worker #1 of 2
[17:01:04.633] [local output]  - Worker #2 of 2
[17:01:04.633] [local output] makeClusterPSOCK() ... done
[17:01:04.644] Packages needed by the future expression (n = 0): <none>
[17:01:04.645] Packages needed by future strategies (n = 0): <none>
[17:01:04.645] {
[17:01:04.645]     {
[17:01:04.645]         {
[17:01:04.645]             ...future.startTime <- base::Sys.time()
[17:01:04.645]             {
[17:01:04.645]                 {
[17:01:04.645]                   {
[17:01:04.645]                     {
[17:01:04.645]                       base::local({
[17:01:04.645]                         has_future <- base::requireNamespace("future", 
[17:01:04.645]                           quietly = TRUE)
[17:01:04.645]                         if (has_future) {
[17:01:04.645]                           ns <- base::getNamespace("future")
[17:01:04.645]                           version <- ns[[".package"]][["version"]]
[17:01:04.645]                           if (is.null(version)) 
[17:01:04.645]                             version <- utils::packageVersion("future")
[17:01:04.645]                         }
[17:01:04.645]                         else {
[17:01:04.645]                           version <- NULL
[17:01:04.645]                         }
[17:01:04.645]                         if (!has_future || version < "1.8.0") {
[17:01:04.645]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:04.645]                             "", base::R.version$version.string), 
[17:01:04.645]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:04.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:04.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:04.645]                               "release", "version")], collapse = " "), 
[17:01:04.645]                             hostname = base::Sys.info()[["nodename"]])
[17:01:04.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:04.645]                             info)
[17:01:04.645]                           info <- base::paste(info, collapse = "; ")
[17:01:04.645]                           if (!has_future) {
[17:01:04.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:04.645]                               info)
[17:01:04.645]                           }
[17:01:04.645]                           else {
[17:01:04.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:04.645]                               info, version)
[17:01:04.645]                           }
[17:01:04.645]                           base::stop(msg)
[17:01:04.645]                         }
[17:01:04.645]                       })
[17:01:04.645]                     }
[17:01:04.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:04.645]                     base::options(mc.cores = 1L)
[17:01:04.645]                   }
[17:01:04.645]                   ...future.strategy.old <- future::plan("list")
[17:01:04.645]                   options(future.plan = NULL)
[17:01:04.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:04.645]                 }
[17:01:04.645]                 ...future.workdir <- getwd()
[17:01:04.645]             }
[17:01:04.645]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:04.645]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:04.645]         }
[17:01:04.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:04.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:01:04.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:04.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:04.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:04.645]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:04.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:04.645]             base::names(...future.oldOptions))
[17:01:04.645]     }
[17:01:04.645]     if (FALSE) {
[17:01:04.645]     }
[17:01:04.645]     else {
[17:01:04.645]         if (TRUE) {
[17:01:04.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:04.645]                 open = "w")
[17:01:04.645]         }
[17:01:04.645]         else {
[17:01:04.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:04.645]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:04.645]         }
[17:01:04.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:04.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:04.645]             base::sink(type = "output", split = FALSE)
[17:01:04.645]             base::close(...future.stdout)
[17:01:04.645]         }, add = TRUE)
[17:01:04.645]     }
[17:01:04.645]     ...future.frame <- base::sys.nframe()
[17:01:04.645]     ...future.conditions <- base::list()
[17:01:04.645]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:04.645]     if (FALSE) {
[17:01:04.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:04.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:04.645]     }
[17:01:04.645]     ...future.result <- base::tryCatch({
[17:01:04.645]         base::withCallingHandlers({
[17:01:04.645]             ...future.value <- base::withVisible(base::local({
[17:01:04.645]                 ...future.makeSendCondition <- base::local({
[17:01:04.645]                   sendCondition <- NULL
[17:01:04.645]                   function(frame = 1L) {
[17:01:04.645]                     if (is.function(sendCondition)) 
[17:01:04.645]                       return(sendCondition)
[17:01:04.645]                     ns <- getNamespace("parallel")
[17:01:04.645]                     if (exists("sendData", mode = "function", 
[17:01:04.645]                       envir = ns)) {
[17:01:04.645]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:04.645]                         envir = ns)
[17:01:04.645]                       envir <- sys.frame(frame)
[17:01:04.645]                       master <- NULL
[17:01:04.645]                       while (!identical(envir, .GlobalEnv) && 
[17:01:04.645]                         !identical(envir, emptyenv())) {
[17:01:04.645]                         if (exists("master", mode = "list", envir = envir, 
[17:01:04.645]                           inherits = FALSE)) {
[17:01:04.645]                           master <- get("master", mode = "list", 
[17:01:04.645]                             envir = envir, inherits = FALSE)
[17:01:04.645]                           if (inherits(master, c("SOCKnode", 
[17:01:04.645]                             "SOCK0node"))) {
[17:01:04.645]                             sendCondition <<- function(cond) {
[17:01:04.645]                               data <- list(type = "VALUE", value = cond, 
[17:01:04.645]                                 success = TRUE)
[17:01:04.645]                               parallel_sendData(master, data)
[17:01:04.645]                             }
[17:01:04.645]                             return(sendCondition)
[17:01:04.645]                           }
[17:01:04.645]                         }
[17:01:04.645]                         frame <- frame + 1L
[17:01:04.645]                         envir <- sys.frame(frame)
[17:01:04.645]                       }
[17:01:04.645]                     }
[17:01:04.645]                     sendCondition <<- function(cond) NULL
[17:01:04.645]                   }
[17:01:04.645]                 })
[17:01:04.645]                 withCallingHandlers({
[17:01:04.645]                   NA
[17:01:04.645]                 }, immediateCondition = function(cond) {
[17:01:04.645]                   sendCondition <- ...future.makeSendCondition()
[17:01:04.645]                   sendCondition(cond)
[17:01:04.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.645]                   {
[17:01:04.645]                     inherits <- base::inherits
[17:01:04.645]                     invokeRestart <- base::invokeRestart
[17:01:04.645]                     is.null <- base::is.null
[17:01:04.645]                     muffled <- FALSE
[17:01:04.645]                     if (inherits(cond, "message")) {
[17:01:04.645]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:04.645]                       if (muffled) 
[17:01:04.645]                         invokeRestart("muffleMessage")
[17:01:04.645]                     }
[17:01:04.645]                     else if (inherits(cond, "warning")) {
[17:01:04.645]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:04.645]                       if (muffled) 
[17:01:04.645]                         invokeRestart("muffleWarning")
[17:01:04.645]                     }
[17:01:04.645]                     else if (inherits(cond, "condition")) {
[17:01:04.645]                       if (!is.null(pattern)) {
[17:01:04.645]                         computeRestarts <- base::computeRestarts
[17:01:04.645]                         grepl <- base::grepl
[17:01:04.645]                         restarts <- computeRestarts(cond)
[17:01:04.645]                         for (restart in restarts) {
[17:01:04.645]                           name <- restart$name
[17:01:04.645]                           if (is.null(name)) 
[17:01:04.645]                             next
[17:01:04.645]                           if (!grepl(pattern, name)) 
[17:01:04.645]                             next
[17:01:04.645]                           invokeRestart(restart)
[17:01:04.645]                           muffled <- TRUE
[17:01:04.645]                           break
[17:01:04.645]                         }
[17:01:04.645]                       }
[17:01:04.645]                     }
[17:01:04.645]                     invisible(muffled)
[17:01:04.645]                   }
[17:01:04.645]                   muffleCondition(cond)
[17:01:04.645]                 })
[17:01:04.645]             }))
[17:01:04.645]             future::FutureResult(value = ...future.value$value, 
[17:01:04.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.645]                   ...future.rng), globalenv = if (FALSE) 
[17:01:04.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:04.645]                     ...future.globalenv.names))
[17:01:04.645]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:04.645]         }, condition = base::local({
[17:01:04.645]             c <- base::c
[17:01:04.645]             inherits <- base::inherits
[17:01:04.645]             invokeRestart <- base::invokeRestart
[17:01:04.645]             length <- base::length
[17:01:04.645]             list <- base::list
[17:01:04.645]             seq.int <- base::seq.int
[17:01:04.645]             signalCondition <- base::signalCondition
[17:01:04.645]             sys.calls <- base::sys.calls
[17:01:04.645]             `[[` <- base::`[[`
[17:01:04.645]             `+` <- base::`+`
[17:01:04.645]             `<<-` <- base::`<<-`
[17:01:04.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:04.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:04.645]                   3L)]
[17:01:04.645]             }
[17:01:04.645]             function(cond) {
[17:01:04.645]                 is_error <- inherits(cond, "error")
[17:01:04.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:04.645]                   NULL)
[17:01:04.645]                 if (is_error) {
[17:01:04.645]                   sessionInformation <- function() {
[17:01:04.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:04.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:04.645]                       search = base::search(), system = base::Sys.info())
[17:01:04.645]                   }
[17:01:04.645]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:04.645]                     cond$call), session = sessionInformation(), 
[17:01:04.645]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:04.645]                   signalCondition(cond)
[17:01:04.645]                 }
[17:01:04.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:04.645]                 "immediateCondition"))) {
[17:01:04.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:04.645]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:04.645]                   if (TRUE && !signal) {
[17:01:04.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.645]                     {
[17:01:04.645]                       inherits <- base::inherits
[17:01:04.645]                       invokeRestart <- base::invokeRestart
[17:01:04.645]                       is.null <- base::is.null
[17:01:04.645]                       muffled <- FALSE
[17:01:04.645]                       if (inherits(cond, "message")) {
[17:01:04.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.645]                         if (muffled) 
[17:01:04.645]                           invokeRestart("muffleMessage")
[17:01:04.645]                       }
[17:01:04.645]                       else if (inherits(cond, "warning")) {
[17:01:04.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.645]                         if (muffled) 
[17:01:04.645]                           invokeRestart("muffleWarning")
[17:01:04.645]                       }
[17:01:04.645]                       else if (inherits(cond, "condition")) {
[17:01:04.645]                         if (!is.null(pattern)) {
[17:01:04.645]                           computeRestarts <- base::computeRestarts
[17:01:04.645]                           grepl <- base::grepl
[17:01:04.645]                           restarts <- computeRestarts(cond)
[17:01:04.645]                           for (restart in restarts) {
[17:01:04.645]                             name <- restart$name
[17:01:04.645]                             if (is.null(name)) 
[17:01:04.645]                               next
[17:01:04.645]                             if (!grepl(pattern, name)) 
[17:01:04.645]                               next
[17:01:04.645]                             invokeRestart(restart)
[17:01:04.645]                             muffled <- TRUE
[17:01:04.645]                             break
[17:01:04.645]                           }
[17:01:04.645]                         }
[17:01:04.645]                       }
[17:01:04.645]                       invisible(muffled)
[17:01:04.645]                     }
[17:01:04.645]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.645]                   }
[17:01:04.645]                 }
[17:01:04.645]                 else {
[17:01:04.645]                   if (TRUE) {
[17:01:04.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.645]                     {
[17:01:04.645]                       inherits <- base::inherits
[17:01:04.645]                       invokeRestart <- base::invokeRestart
[17:01:04.645]                       is.null <- base::is.null
[17:01:04.645]                       muffled <- FALSE
[17:01:04.645]                       if (inherits(cond, "message")) {
[17:01:04.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.645]                         if (muffled) 
[17:01:04.645]                           invokeRestart("muffleMessage")
[17:01:04.645]                       }
[17:01:04.645]                       else if (inherits(cond, "warning")) {
[17:01:04.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.645]                         if (muffled) 
[17:01:04.645]                           invokeRestart("muffleWarning")
[17:01:04.645]                       }
[17:01:04.645]                       else if (inherits(cond, "condition")) {
[17:01:04.645]                         if (!is.null(pattern)) {
[17:01:04.645]                           computeRestarts <- base::computeRestarts
[17:01:04.645]                           grepl <- base::grepl
[17:01:04.645]                           restarts <- computeRestarts(cond)
[17:01:04.645]                           for (restart in restarts) {
[17:01:04.645]                             name <- restart$name
[17:01:04.645]                             if (is.null(name)) 
[17:01:04.645]                               next
[17:01:04.645]                             if (!grepl(pattern, name)) 
[17:01:04.645]                               next
[17:01:04.645]                             invokeRestart(restart)
[17:01:04.645]                             muffled <- TRUE
[17:01:04.645]                             break
[17:01:04.645]                           }
[17:01:04.645]                         }
[17:01:04.645]                       }
[17:01:04.645]                       invisible(muffled)
[17:01:04.645]                     }
[17:01:04.645]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.645]                   }
[17:01:04.645]                 }
[17:01:04.645]             }
[17:01:04.645]         }))
[17:01:04.645]     }, error = function(ex) {
[17:01:04.645]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:04.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.645]                 ...future.rng), started = ...future.startTime, 
[17:01:04.645]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:04.645]             version = "1.8"), class = "FutureResult")
[17:01:04.645]     }, finally = {
[17:01:04.645]         if (!identical(...future.workdir, getwd())) 
[17:01:04.645]             setwd(...future.workdir)
[17:01:04.645]         {
[17:01:04.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:04.645]                 ...future.oldOptions$nwarnings <- NULL
[17:01:04.645]             }
[17:01:04.645]             base::options(...future.oldOptions)
[17:01:04.645]             if (.Platform$OS.type == "windows") {
[17:01:04.645]                 old_names <- names(...future.oldEnvVars)
[17:01:04.645]                 envs <- base::Sys.getenv()
[17:01:04.645]                 names <- names(envs)
[17:01:04.645]                 common <- intersect(names, old_names)
[17:01:04.645]                 added <- setdiff(names, old_names)
[17:01:04.645]                 removed <- setdiff(old_names, names)
[17:01:04.645]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:04.645]                   envs[common]]
[17:01:04.645]                 NAMES <- toupper(changed)
[17:01:04.645]                 args <- list()
[17:01:04.645]                 for (kk in seq_along(NAMES)) {
[17:01:04.645]                   name <- changed[[kk]]
[17:01:04.645]                   NAME <- NAMES[[kk]]
[17:01:04.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.645]                     next
[17:01:04.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.645]                 }
[17:01:04.645]                 NAMES <- toupper(added)
[17:01:04.645]                 for (kk in seq_along(NAMES)) {
[17:01:04.645]                   name <- added[[kk]]
[17:01:04.645]                   NAME <- NAMES[[kk]]
[17:01:04.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.645]                     next
[17:01:04.645]                   args[[name]] <- ""
[17:01:04.645]                 }
[17:01:04.645]                 NAMES <- toupper(removed)
[17:01:04.645]                 for (kk in seq_along(NAMES)) {
[17:01:04.645]                   name <- removed[[kk]]
[17:01:04.645]                   NAME <- NAMES[[kk]]
[17:01:04.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.645]                     next
[17:01:04.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.645]                 }
[17:01:04.645]                 if (length(args) > 0) 
[17:01:04.645]                   base::do.call(base::Sys.setenv, args = args)
[17:01:04.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:04.645]             }
[17:01:04.645]             else {
[17:01:04.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:04.645]             }
[17:01:04.645]             {
[17:01:04.645]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:04.645]                   0L) {
[17:01:04.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:04.645]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:04.645]                   base::options(opts)
[17:01:04.645]                 }
[17:01:04.645]                 {
[17:01:04.645]                   {
[17:01:04.645]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:04.645]                     NULL
[17:01:04.645]                   }
[17:01:04.645]                   options(future.plan = NULL)
[17:01:04.645]                   if (is.na(NA_character_)) 
[17:01:04.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:04.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:04.645]                     .init = FALSE)
[17:01:04.645]                 }
[17:01:04.645]             }
[17:01:04.645]         }
[17:01:04.645]     })
[17:01:04.645]     if (TRUE) {
[17:01:04.645]         base::sink(type = "output", split = FALSE)
[17:01:04.645]         if (TRUE) {
[17:01:04.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:04.645]         }
[17:01:04.645]         else {
[17:01:04.645]             ...future.result["stdout"] <- base::list(NULL)
[17:01:04.645]         }
[17:01:04.645]         base::close(...future.stdout)
[17:01:04.645]         ...future.stdout <- NULL
[17:01:04.645]     }
[17:01:04.645]     ...future.result$conditions <- ...future.conditions
[17:01:04.645]     ...future.result$finished <- base::Sys.time()
[17:01:04.645]     ...future.result
[17:01:04.645] }
[17:01:04.697] MultisessionFuture started
[17:01:04.697] result() for ClusterFuture ...
[17:01:04.698] receiveMessageFromWorker() for ClusterFuture ...
[17:01:04.698] - Validating connection of MultisessionFuture
[17:01:04.729] - received message: FutureResult
[17:01:04.729] - Received FutureResult
[17:01:04.729] - Erased future from FutureRegistry
[17:01:04.730] result() for ClusterFuture ...
[17:01:04.730] - result already collected: FutureResult
[17:01:04.730] result() for ClusterFuture ... done
[17:01:04.730] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:04.730] result() for ClusterFuture ... done
[17:01:04.730] result() for ClusterFuture ...
[17:01:04.730] - result already collected: FutureResult
[17:01:04.730] result() for ClusterFuture ... done
[17:01:04.731] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:01:04.734] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:01:04.737] future_lapply() ...
[17:01:04.743] Number of chunks: 2
[17:01:04.743] getGlobalsAndPackagesXApply() ...
[17:01:04.743]  - future.globals: TRUE
[17:01:04.743] getGlobalsAndPackages() ...
[17:01:04.743] Searching for globals...
[17:01:04.747] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:04.747] Searching for globals ... DONE
[17:01:04.747] Resolving globals: FALSE
[17:01:04.748] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:01:04.749] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:04.749] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:04.749] - packages: [1] ‘future.apply’
[17:01:04.749] getGlobalsAndPackages() ... DONE
[17:01:04.749]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:04.749]  - needed namespaces: [n=1] ‘future.apply’
[17:01:04.750] Finding globals ... DONE
[17:01:04.750]  - use_args: TRUE
[17:01:04.750]  - Getting '...' globals ...
[17:01:04.750] resolve() on list ...
[17:01:04.750]  recursive: 0
[17:01:04.750]  length: 1
[17:01:04.750]  elements: ‘...’
[17:01:04.751]  length: 0 (resolved future 1)
[17:01:04.751] resolve() on list ... DONE
[17:01:04.751]    - '...' content: [n=0] 
[17:01:04.751] List of 1
[17:01:04.751]  $ ...: list()
[17:01:04.751]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:04.751]  - attr(*, "where")=List of 1
[17:01:04.751]   ..$ ...:<environment: 0x55aadcd3fd98> 
[17:01:04.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:04.751]  - attr(*, "resolved")= logi TRUE
[17:01:04.751]  - attr(*, "total_size")= num NA
[17:01:04.754]  - Getting '...' globals ... DONE
[17:01:04.754] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:04.754] List of 8
[17:01:04.754]  $ ...future.FUN:function (x, ...)  
[17:01:04.754]  $ x_FUN        :function (x)  
[17:01:04.754]  $ times        : int 1
[17:01:04.754]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:04.754]  $ stop_if_not  :function (...)  
[17:01:04.754]  $ dim          : NULL
[17:01:04.754]  $ valid_types  : chr "character"
[17:01:04.754]  $ ...          : list()
[17:01:04.754]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:04.754]  - attr(*, "where")=List of 8
[17:01:04.754]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:04.754]   ..$ ...          :<environment: 0x55aadcd3fd98> 
[17:01:04.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:04.754]  - attr(*, "resolved")= logi FALSE
[17:01:04.754]  - attr(*, "total_size")= num 94208
[17:01:04.761] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:04.761] getGlobalsAndPackagesXApply() ... DONE
[17:01:04.761] Number of futures (= number of chunks): 2
[17:01:04.761] Launching 2 futures (chunks) ...
[17:01:04.762] Chunk #1 of 2 ...
[17:01:04.762]  - Finding globals in 'X' for chunk #1 ...
[17:01:04.762] getGlobalsAndPackages() ...
[17:01:04.762] Searching for globals...
[17:01:04.762] 
[17:01:04.762] Searching for globals ... DONE
[17:01:04.762] - globals: [0] <none>
[17:01:04.763] getGlobalsAndPackages() ... DONE
[17:01:04.763]    + additional globals found: [n=0] 
[17:01:04.763]    + additional namespaces needed: [n=0] 
[17:01:04.763]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:04.763]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:04.763]  - seeds: <none>
[17:01:04.763]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.763] getGlobalsAndPackages() ...
[17:01:04.763] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.764] Resolving globals: FALSE
[17:01:04.764] Tweak future expression to call with '...' arguments ...
[17:01:04.764] {
[17:01:04.764]     do.call(function(...) {
[17:01:04.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.764]             on.exit(options(oopts), add = TRUE)
[17:01:04.764]         }
[17:01:04.764]         {
[17:01:04.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.764]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.764]             })
[17:01:04.764]         }
[17:01:04.764]     }, args = future.call.arguments)
[17:01:04.764] }
[17:01:04.764] Tweak future expression to call with '...' arguments ... DONE
[17:01:04.765] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.765] - packages: [1] ‘future.apply’
[17:01:04.765] getGlobalsAndPackages() ... DONE
[17:01:04.765] run() for ‘Future’ ...
[17:01:04.766] - state: ‘created’
[17:01:04.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:04.780] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:04.780]   - Field: ‘node’
[17:01:04.781]   - Field: ‘label’
[17:01:04.781]   - Field: ‘local’
[17:01:04.781]   - Field: ‘owner’
[17:01:04.781]   - Field: ‘envir’
[17:01:04.781]   - Field: ‘workers’
[17:01:04.781]   - Field: ‘packages’
[17:01:04.781]   - Field: ‘gc’
[17:01:04.781]   - Field: ‘conditions’
[17:01:04.781]   - Field: ‘persistent’
[17:01:04.781]   - Field: ‘expr’
[17:01:04.782]   - Field: ‘uuid’
[17:01:04.782]   - Field: ‘seed’
[17:01:04.782]   - Field: ‘version’
[17:01:04.782]   - Field: ‘result’
[17:01:04.782]   - Field: ‘asynchronous’
[17:01:04.782]   - Field: ‘calls’
[17:01:04.782]   - Field: ‘globals’
[17:01:04.782]   - Field: ‘stdout’
[17:01:04.782]   - Field: ‘earlySignal’
[17:01:04.783]   - Field: ‘lazy’
[17:01:04.783]   - Field: ‘state’
[17:01:04.783] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:04.783] - Launch lazy future ...
[17:01:04.783] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:04.783] Packages needed by future strategies (n = 0): <none>
[17:01:04.784] {
[17:01:04.784]     {
[17:01:04.784]         {
[17:01:04.784]             ...future.startTime <- base::Sys.time()
[17:01:04.784]             {
[17:01:04.784]                 {
[17:01:04.784]                   {
[17:01:04.784]                     {
[17:01:04.784]                       {
[17:01:04.784]                         base::local({
[17:01:04.784]                           has_future <- base::requireNamespace("future", 
[17:01:04.784]                             quietly = TRUE)
[17:01:04.784]                           if (has_future) {
[17:01:04.784]                             ns <- base::getNamespace("future")
[17:01:04.784]                             version <- ns[[".package"]][["version"]]
[17:01:04.784]                             if (is.null(version)) 
[17:01:04.784]                               version <- utils::packageVersion("future")
[17:01:04.784]                           }
[17:01:04.784]                           else {
[17:01:04.784]                             version <- NULL
[17:01:04.784]                           }
[17:01:04.784]                           if (!has_future || version < "1.8.0") {
[17:01:04.784]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:04.784]                               "", base::R.version$version.string), 
[17:01:04.784]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:04.784]                                 base::R.version$platform, 8 * 
[17:01:04.784]                                   base::.Machine$sizeof.pointer), 
[17:01:04.784]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:04.784]                                 "release", "version")], collapse = " "), 
[17:01:04.784]                               hostname = base::Sys.info()[["nodename"]])
[17:01:04.784]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:04.784]                               info)
[17:01:04.784]                             info <- base::paste(info, collapse = "; ")
[17:01:04.784]                             if (!has_future) {
[17:01:04.784]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:04.784]                                 info)
[17:01:04.784]                             }
[17:01:04.784]                             else {
[17:01:04.784]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:04.784]                                 info, version)
[17:01:04.784]                             }
[17:01:04.784]                             base::stop(msg)
[17:01:04.784]                           }
[17:01:04.784]                         })
[17:01:04.784]                       }
[17:01:04.784]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:04.784]                       base::options(mc.cores = 1L)
[17:01:04.784]                     }
[17:01:04.784]                     base::local({
[17:01:04.784]                       for (pkg in "future.apply") {
[17:01:04.784]                         base::loadNamespace(pkg)
[17:01:04.784]                         base::library(pkg, character.only = TRUE)
[17:01:04.784]                       }
[17:01:04.784]                     })
[17:01:04.784]                   }
[17:01:04.784]                   ...future.strategy.old <- future::plan("list")
[17:01:04.784]                   options(future.plan = NULL)
[17:01:04.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:04.784]                 }
[17:01:04.784]                 ...future.workdir <- getwd()
[17:01:04.784]             }
[17:01:04.784]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:04.784]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:04.784]         }
[17:01:04.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:04.784]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:04.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:04.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:04.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:04.784]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:04.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:04.784]             base::names(...future.oldOptions))
[17:01:04.784]     }
[17:01:04.784]     if (FALSE) {
[17:01:04.784]     }
[17:01:04.784]     else {
[17:01:04.784]         if (TRUE) {
[17:01:04.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:04.784]                 open = "w")
[17:01:04.784]         }
[17:01:04.784]         else {
[17:01:04.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:04.784]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:04.784]         }
[17:01:04.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:04.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:04.784]             base::sink(type = "output", split = FALSE)
[17:01:04.784]             base::close(...future.stdout)
[17:01:04.784]         }, add = TRUE)
[17:01:04.784]     }
[17:01:04.784]     ...future.frame <- base::sys.nframe()
[17:01:04.784]     ...future.conditions <- base::list()
[17:01:04.784]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:04.784]     if (FALSE) {
[17:01:04.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:04.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:04.784]     }
[17:01:04.784]     ...future.result <- base::tryCatch({
[17:01:04.784]         base::withCallingHandlers({
[17:01:04.784]             ...future.value <- base::withVisible(base::local({
[17:01:04.784]                 ...future.makeSendCondition <- base::local({
[17:01:04.784]                   sendCondition <- NULL
[17:01:04.784]                   function(frame = 1L) {
[17:01:04.784]                     if (is.function(sendCondition)) 
[17:01:04.784]                       return(sendCondition)
[17:01:04.784]                     ns <- getNamespace("parallel")
[17:01:04.784]                     if (exists("sendData", mode = "function", 
[17:01:04.784]                       envir = ns)) {
[17:01:04.784]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:04.784]                         envir = ns)
[17:01:04.784]                       envir <- sys.frame(frame)
[17:01:04.784]                       master <- NULL
[17:01:04.784]                       while (!identical(envir, .GlobalEnv) && 
[17:01:04.784]                         !identical(envir, emptyenv())) {
[17:01:04.784]                         if (exists("master", mode = "list", envir = envir, 
[17:01:04.784]                           inherits = FALSE)) {
[17:01:04.784]                           master <- get("master", mode = "list", 
[17:01:04.784]                             envir = envir, inherits = FALSE)
[17:01:04.784]                           if (inherits(master, c("SOCKnode", 
[17:01:04.784]                             "SOCK0node"))) {
[17:01:04.784]                             sendCondition <<- function(cond) {
[17:01:04.784]                               data <- list(type = "VALUE", value = cond, 
[17:01:04.784]                                 success = TRUE)
[17:01:04.784]                               parallel_sendData(master, data)
[17:01:04.784]                             }
[17:01:04.784]                             return(sendCondition)
[17:01:04.784]                           }
[17:01:04.784]                         }
[17:01:04.784]                         frame <- frame + 1L
[17:01:04.784]                         envir <- sys.frame(frame)
[17:01:04.784]                       }
[17:01:04.784]                     }
[17:01:04.784]                     sendCondition <<- function(cond) NULL
[17:01:04.784]                   }
[17:01:04.784]                 })
[17:01:04.784]                 withCallingHandlers({
[17:01:04.784]                   {
[17:01:04.784]                     do.call(function(...) {
[17:01:04.784]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.784]                       if (!identical(...future.globals.maxSize.org, 
[17:01:04.784]                         ...future.globals.maxSize)) {
[17:01:04.784]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.784]                         on.exit(options(oopts), add = TRUE)
[17:01:04.784]                       }
[17:01:04.784]                       {
[17:01:04.784]                         lapply(seq_along(...future.elements_ii), 
[17:01:04.784]                           FUN = function(jj) {
[17:01:04.784]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.784]                             ...future.FUN(...future.X_jj, ...)
[17:01:04.784]                           })
[17:01:04.784]                       }
[17:01:04.784]                     }, args = future.call.arguments)
[17:01:04.784]                   }
[17:01:04.784]                 }, immediateCondition = function(cond) {
[17:01:04.784]                   sendCondition <- ...future.makeSendCondition()
[17:01:04.784]                   sendCondition(cond)
[17:01:04.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.784]                   {
[17:01:04.784]                     inherits <- base::inherits
[17:01:04.784]                     invokeRestart <- base::invokeRestart
[17:01:04.784]                     is.null <- base::is.null
[17:01:04.784]                     muffled <- FALSE
[17:01:04.784]                     if (inherits(cond, "message")) {
[17:01:04.784]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:04.784]                       if (muffled) 
[17:01:04.784]                         invokeRestart("muffleMessage")
[17:01:04.784]                     }
[17:01:04.784]                     else if (inherits(cond, "warning")) {
[17:01:04.784]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:04.784]                       if (muffled) 
[17:01:04.784]                         invokeRestart("muffleWarning")
[17:01:04.784]                     }
[17:01:04.784]                     else if (inherits(cond, "condition")) {
[17:01:04.784]                       if (!is.null(pattern)) {
[17:01:04.784]                         computeRestarts <- base::computeRestarts
[17:01:04.784]                         grepl <- base::grepl
[17:01:04.784]                         restarts <- computeRestarts(cond)
[17:01:04.784]                         for (restart in restarts) {
[17:01:04.784]                           name <- restart$name
[17:01:04.784]                           if (is.null(name)) 
[17:01:04.784]                             next
[17:01:04.784]                           if (!grepl(pattern, name)) 
[17:01:04.784]                             next
[17:01:04.784]                           invokeRestart(restart)
[17:01:04.784]                           muffled <- TRUE
[17:01:04.784]                           break
[17:01:04.784]                         }
[17:01:04.784]                       }
[17:01:04.784]                     }
[17:01:04.784]                     invisible(muffled)
[17:01:04.784]                   }
[17:01:04.784]                   muffleCondition(cond)
[17:01:04.784]                 })
[17:01:04.784]             }))
[17:01:04.784]             future::FutureResult(value = ...future.value$value, 
[17:01:04.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.784]                   ...future.rng), globalenv = if (FALSE) 
[17:01:04.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:04.784]                     ...future.globalenv.names))
[17:01:04.784]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:04.784]         }, condition = base::local({
[17:01:04.784]             c <- base::c
[17:01:04.784]             inherits <- base::inherits
[17:01:04.784]             invokeRestart <- base::invokeRestart
[17:01:04.784]             length <- base::length
[17:01:04.784]             list <- base::list
[17:01:04.784]             seq.int <- base::seq.int
[17:01:04.784]             signalCondition <- base::signalCondition
[17:01:04.784]             sys.calls <- base::sys.calls
[17:01:04.784]             `[[` <- base::`[[`
[17:01:04.784]             `+` <- base::`+`
[17:01:04.784]             `<<-` <- base::`<<-`
[17:01:04.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:04.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:04.784]                   3L)]
[17:01:04.784]             }
[17:01:04.784]             function(cond) {
[17:01:04.784]                 is_error <- inherits(cond, "error")
[17:01:04.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:04.784]                   NULL)
[17:01:04.784]                 if (is_error) {
[17:01:04.784]                   sessionInformation <- function() {
[17:01:04.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:04.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:04.784]                       search = base::search(), system = base::Sys.info())
[17:01:04.784]                   }
[17:01:04.784]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:04.784]                     cond$call), session = sessionInformation(), 
[17:01:04.784]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:04.784]                   signalCondition(cond)
[17:01:04.784]                 }
[17:01:04.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:04.784]                 "immediateCondition"))) {
[17:01:04.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:04.784]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:04.784]                   if (TRUE && !signal) {
[17:01:04.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.784]                     {
[17:01:04.784]                       inherits <- base::inherits
[17:01:04.784]                       invokeRestart <- base::invokeRestart
[17:01:04.784]                       is.null <- base::is.null
[17:01:04.784]                       muffled <- FALSE
[17:01:04.784]                       if (inherits(cond, "message")) {
[17:01:04.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.784]                         if (muffled) 
[17:01:04.784]                           invokeRestart("muffleMessage")
[17:01:04.784]                       }
[17:01:04.784]                       else if (inherits(cond, "warning")) {
[17:01:04.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.784]                         if (muffled) 
[17:01:04.784]                           invokeRestart("muffleWarning")
[17:01:04.784]                       }
[17:01:04.784]                       else if (inherits(cond, "condition")) {
[17:01:04.784]                         if (!is.null(pattern)) {
[17:01:04.784]                           computeRestarts <- base::computeRestarts
[17:01:04.784]                           grepl <- base::grepl
[17:01:04.784]                           restarts <- computeRestarts(cond)
[17:01:04.784]                           for (restart in restarts) {
[17:01:04.784]                             name <- restart$name
[17:01:04.784]                             if (is.null(name)) 
[17:01:04.784]                               next
[17:01:04.784]                             if (!grepl(pattern, name)) 
[17:01:04.784]                               next
[17:01:04.784]                             invokeRestart(restart)
[17:01:04.784]                             muffled <- TRUE
[17:01:04.784]                             break
[17:01:04.784]                           }
[17:01:04.784]                         }
[17:01:04.784]                       }
[17:01:04.784]                       invisible(muffled)
[17:01:04.784]                     }
[17:01:04.784]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.784]                   }
[17:01:04.784]                 }
[17:01:04.784]                 else {
[17:01:04.784]                   if (TRUE) {
[17:01:04.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.784]                     {
[17:01:04.784]                       inherits <- base::inherits
[17:01:04.784]                       invokeRestart <- base::invokeRestart
[17:01:04.784]                       is.null <- base::is.null
[17:01:04.784]                       muffled <- FALSE
[17:01:04.784]                       if (inherits(cond, "message")) {
[17:01:04.784]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.784]                         if (muffled) 
[17:01:04.784]                           invokeRestart("muffleMessage")
[17:01:04.784]                       }
[17:01:04.784]                       else if (inherits(cond, "warning")) {
[17:01:04.784]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.784]                         if (muffled) 
[17:01:04.784]                           invokeRestart("muffleWarning")
[17:01:04.784]                       }
[17:01:04.784]                       else if (inherits(cond, "condition")) {
[17:01:04.784]                         if (!is.null(pattern)) {
[17:01:04.784]                           computeRestarts <- base::computeRestarts
[17:01:04.784]                           grepl <- base::grepl
[17:01:04.784]                           restarts <- computeRestarts(cond)
[17:01:04.784]                           for (restart in restarts) {
[17:01:04.784]                             name <- restart$name
[17:01:04.784]                             if (is.null(name)) 
[17:01:04.784]                               next
[17:01:04.784]                             if (!grepl(pattern, name)) 
[17:01:04.784]                               next
[17:01:04.784]                             invokeRestart(restart)
[17:01:04.784]                             muffled <- TRUE
[17:01:04.784]                             break
[17:01:04.784]                           }
[17:01:04.784]                         }
[17:01:04.784]                       }
[17:01:04.784]                       invisible(muffled)
[17:01:04.784]                     }
[17:01:04.784]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.784]                   }
[17:01:04.784]                 }
[17:01:04.784]             }
[17:01:04.784]         }))
[17:01:04.784]     }, error = function(ex) {
[17:01:04.784]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:04.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.784]                 ...future.rng), started = ...future.startTime, 
[17:01:04.784]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:04.784]             version = "1.8"), class = "FutureResult")
[17:01:04.784]     }, finally = {
[17:01:04.784]         if (!identical(...future.workdir, getwd())) 
[17:01:04.784]             setwd(...future.workdir)
[17:01:04.784]         {
[17:01:04.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:04.784]                 ...future.oldOptions$nwarnings <- NULL
[17:01:04.784]             }
[17:01:04.784]             base::options(...future.oldOptions)
[17:01:04.784]             if (.Platform$OS.type == "windows") {
[17:01:04.784]                 old_names <- names(...future.oldEnvVars)
[17:01:04.784]                 envs <- base::Sys.getenv()
[17:01:04.784]                 names <- names(envs)
[17:01:04.784]                 common <- intersect(names, old_names)
[17:01:04.784]                 added <- setdiff(names, old_names)
[17:01:04.784]                 removed <- setdiff(old_names, names)
[17:01:04.784]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:04.784]                   envs[common]]
[17:01:04.784]                 NAMES <- toupper(changed)
[17:01:04.784]                 args <- list()
[17:01:04.784]                 for (kk in seq_along(NAMES)) {
[17:01:04.784]                   name <- changed[[kk]]
[17:01:04.784]                   NAME <- NAMES[[kk]]
[17:01:04.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.784]                     next
[17:01:04.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.784]                 }
[17:01:04.784]                 NAMES <- toupper(added)
[17:01:04.784]                 for (kk in seq_along(NAMES)) {
[17:01:04.784]                   name <- added[[kk]]
[17:01:04.784]                   NAME <- NAMES[[kk]]
[17:01:04.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.784]                     next
[17:01:04.784]                   args[[name]] <- ""
[17:01:04.784]                 }
[17:01:04.784]                 NAMES <- toupper(removed)
[17:01:04.784]                 for (kk in seq_along(NAMES)) {
[17:01:04.784]                   name <- removed[[kk]]
[17:01:04.784]                   NAME <- NAMES[[kk]]
[17:01:04.784]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.784]                     next
[17:01:04.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.784]                 }
[17:01:04.784]                 if (length(args) > 0) 
[17:01:04.784]                   base::do.call(base::Sys.setenv, args = args)
[17:01:04.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:04.784]             }
[17:01:04.784]             else {
[17:01:04.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:04.784]             }
[17:01:04.784]             {
[17:01:04.784]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:04.784]                   0L) {
[17:01:04.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:04.784]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:04.784]                   base::options(opts)
[17:01:04.784]                 }
[17:01:04.784]                 {
[17:01:04.784]                   {
[17:01:04.784]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:04.784]                     NULL
[17:01:04.784]                   }
[17:01:04.784]                   options(future.plan = NULL)
[17:01:04.784]                   if (is.na(NA_character_)) 
[17:01:04.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:04.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:04.784]                     .init = FALSE)
[17:01:04.784]                 }
[17:01:04.784]             }
[17:01:04.784]         }
[17:01:04.784]     })
[17:01:04.784]     if (TRUE) {
[17:01:04.784]         base::sink(type = "output", split = FALSE)
[17:01:04.784]         if (TRUE) {
[17:01:04.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:04.784]         }
[17:01:04.784]         else {
[17:01:04.784]             ...future.result["stdout"] <- base::list(NULL)
[17:01:04.784]         }
[17:01:04.784]         base::close(...future.stdout)
[17:01:04.784]         ...future.stdout <- NULL
[17:01:04.784]     }
[17:01:04.784]     ...future.result$conditions <- ...future.conditions
[17:01:04.784]     ...future.result$finished <- base::Sys.time()
[17:01:04.784]     ...future.result
[17:01:04.784] }
[17:01:04.787] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[17:01:04.787] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:04.832] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:04.832] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:01:04.832] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:01:04.832] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:04.833] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:04.833] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:04.876] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:04.876] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:04.920] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:04.920] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:04.920] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:04.921] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[17:01:04.921] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[17:01:04.921] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:04.922] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:04.922] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:01:04.922] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:01:04.922] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:04.923] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:04.923] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:04.923] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:04.923] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[17:01:04.924] MultisessionFuture started
[17:01:04.924] - Launch lazy future ... done
[17:01:04.924] run() for ‘MultisessionFuture’ ... done
[17:01:04.924] Created future:
[17:01:04.924] MultisessionFuture:
[17:01:04.924] Label: ‘future_vapply-1’
[17:01:04.924] Expression:
[17:01:04.924] {
[17:01:04.924]     do.call(function(...) {
[17:01:04.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.924]             on.exit(options(oopts), add = TRUE)
[17:01:04.924]         }
[17:01:04.924]         {
[17:01:04.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.924]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.924]             })
[17:01:04.924]         }
[17:01:04.924]     }, args = future.call.arguments)
[17:01:04.924] }
[17:01:04.924] Lazy evaluation: FALSE
[17:01:04.924] Asynchronous evaluation: TRUE
[17:01:04.924] Local evaluation: TRUE
[17:01:04.924] Environment: R_GlobalEnv
[17:01:04.924] Capture standard output: TRUE
[17:01:04.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:04.924] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:04.924] Packages: 1 packages (‘future.apply’)
[17:01:04.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:04.924] Resolved: FALSE
[17:01:04.924] Value: <not collected>
[17:01:04.924] Conditions captured: <none>
[17:01:04.924] Early signaling: FALSE
[17:01:04.924] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:04.924] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.937] Chunk #1 of 2 ... DONE
[17:01:04.937] Chunk #2 of 2 ...
[17:01:04.937]  - Finding globals in 'X' for chunk #2 ...
[17:01:04.937] getGlobalsAndPackages() ...
[17:01:04.937] Searching for globals...
[17:01:04.938] 
[17:01:04.938] Searching for globals ... DONE
[17:01:04.938] - globals: [0] <none>
[17:01:04.938] getGlobalsAndPackages() ... DONE
[17:01:04.938]    + additional globals found: [n=0] 
[17:01:04.938]    + additional namespaces needed: [n=0] 
[17:01:04.938]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:04.938]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:04.939]  - seeds: <none>
[17:01:04.939]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.939] getGlobalsAndPackages() ...
[17:01:04.939] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.939] Resolving globals: FALSE
[17:01:04.939] Tweak future expression to call with '...' arguments ...
[17:01:04.939] {
[17:01:04.939]     do.call(function(...) {
[17:01:04.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:04.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.939]             on.exit(options(oopts), add = TRUE)
[17:01:04.939]         }
[17:01:04.939]         {
[17:01:04.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:04.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.939]                 ...future.FUN(...future.X_jj, ...)
[17:01:04.939]             })
[17:01:04.939]         }
[17:01:04.939]     }, args = future.call.arguments)
[17:01:04.939] }
[17:01:04.940] Tweak future expression to call with '...' arguments ... DONE
[17:01:04.940] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:04.940] - packages: [1] ‘future.apply’
[17:01:04.941] getGlobalsAndPackages() ... DONE
[17:01:04.941] run() for ‘Future’ ...
[17:01:04.941] - state: ‘created’
[17:01:04.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:04.956] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:04.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:04.956]   - Field: ‘node’
[17:01:04.956]   - Field: ‘label’
[17:01:04.957]   - Field: ‘local’
[17:01:04.957]   - Field: ‘owner’
[17:01:04.957]   - Field: ‘envir’
[17:01:04.957]   - Field: ‘workers’
[17:01:04.957]   - Field: ‘packages’
[17:01:04.957]   - Field: ‘gc’
[17:01:04.957]   - Field: ‘conditions’
[17:01:04.957]   - Field: ‘persistent’
[17:01:04.957]   - Field: ‘expr’
[17:01:04.958]   - Field: ‘uuid’
[17:01:04.958]   - Field: ‘seed’
[17:01:04.958]   - Field: ‘version’
[17:01:04.958]   - Field: ‘result’
[17:01:04.958]   - Field: ‘asynchronous’
[17:01:04.958]   - Field: ‘calls’
[17:01:04.958]   - Field: ‘globals’
[17:01:04.958]   - Field: ‘stdout’
[17:01:04.958]   - Field: ‘earlySignal’
[17:01:04.959]   - Field: ‘lazy’
[17:01:04.959]   - Field: ‘state’
[17:01:04.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:04.959] - Launch lazy future ...
[17:01:04.959] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:04.959] Packages needed by future strategies (n = 0): <none>
[17:01:04.960] {
[17:01:04.960]     {
[17:01:04.960]         {
[17:01:04.960]             ...future.startTime <- base::Sys.time()
[17:01:04.960]             {
[17:01:04.960]                 {
[17:01:04.960]                   {
[17:01:04.960]                     {
[17:01:04.960]                       {
[17:01:04.960]                         base::local({
[17:01:04.960]                           has_future <- base::requireNamespace("future", 
[17:01:04.960]                             quietly = TRUE)
[17:01:04.960]                           if (has_future) {
[17:01:04.960]                             ns <- base::getNamespace("future")
[17:01:04.960]                             version <- ns[[".package"]][["version"]]
[17:01:04.960]                             if (is.null(version)) 
[17:01:04.960]                               version <- utils::packageVersion("future")
[17:01:04.960]                           }
[17:01:04.960]                           else {
[17:01:04.960]                             version <- NULL
[17:01:04.960]                           }
[17:01:04.960]                           if (!has_future || version < "1.8.0") {
[17:01:04.960]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:04.960]                               "", base::R.version$version.string), 
[17:01:04.960]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:04.960]                                 base::R.version$platform, 8 * 
[17:01:04.960]                                   base::.Machine$sizeof.pointer), 
[17:01:04.960]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:04.960]                                 "release", "version")], collapse = " "), 
[17:01:04.960]                               hostname = base::Sys.info()[["nodename"]])
[17:01:04.960]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:04.960]                               info)
[17:01:04.960]                             info <- base::paste(info, collapse = "; ")
[17:01:04.960]                             if (!has_future) {
[17:01:04.960]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:04.960]                                 info)
[17:01:04.960]                             }
[17:01:04.960]                             else {
[17:01:04.960]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:04.960]                                 info, version)
[17:01:04.960]                             }
[17:01:04.960]                             base::stop(msg)
[17:01:04.960]                           }
[17:01:04.960]                         })
[17:01:04.960]                       }
[17:01:04.960]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:04.960]                       base::options(mc.cores = 1L)
[17:01:04.960]                     }
[17:01:04.960]                     base::local({
[17:01:04.960]                       for (pkg in "future.apply") {
[17:01:04.960]                         base::loadNamespace(pkg)
[17:01:04.960]                         base::library(pkg, character.only = TRUE)
[17:01:04.960]                       }
[17:01:04.960]                     })
[17:01:04.960]                   }
[17:01:04.960]                   ...future.strategy.old <- future::plan("list")
[17:01:04.960]                   options(future.plan = NULL)
[17:01:04.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:04.960]                 }
[17:01:04.960]                 ...future.workdir <- getwd()
[17:01:04.960]             }
[17:01:04.960]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:04.960]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:04.960]         }
[17:01:04.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:04.960]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:04.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:04.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:04.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:04.960]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:04.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:04.960]             base::names(...future.oldOptions))
[17:01:04.960]     }
[17:01:04.960]     if (FALSE) {
[17:01:04.960]     }
[17:01:04.960]     else {
[17:01:04.960]         if (TRUE) {
[17:01:04.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:04.960]                 open = "w")
[17:01:04.960]         }
[17:01:04.960]         else {
[17:01:04.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:04.960]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:04.960]         }
[17:01:04.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:04.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:04.960]             base::sink(type = "output", split = FALSE)
[17:01:04.960]             base::close(...future.stdout)
[17:01:04.960]         }, add = TRUE)
[17:01:04.960]     }
[17:01:04.960]     ...future.frame <- base::sys.nframe()
[17:01:04.960]     ...future.conditions <- base::list()
[17:01:04.960]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:04.960]     if (FALSE) {
[17:01:04.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:04.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:04.960]     }
[17:01:04.960]     ...future.result <- base::tryCatch({
[17:01:04.960]         base::withCallingHandlers({
[17:01:04.960]             ...future.value <- base::withVisible(base::local({
[17:01:04.960]                 ...future.makeSendCondition <- base::local({
[17:01:04.960]                   sendCondition <- NULL
[17:01:04.960]                   function(frame = 1L) {
[17:01:04.960]                     if (is.function(sendCondition)) 
[17:01:04.960]                       return(sendCondition)
[17:01:04.960]                     ns <- getNamespace("parallel")
[17:01:04.960]                     if (exists("sendData", mode = "function", 
[17:01:04.960]                       envir = ns)) {
[17:01:04.960]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:04.960]                         envir = ns)
[17:01:04.960]                       envir <- sys.frame(frame)
[17:01:04.960]                       master <- NULL
[17:01:04.960]                       while (!identical(envir, .GlobalEnv) && 
[17:01:04.960]                         !identical(envir, emptyenv())) {
[17:01:04.960]                         if (exists("master", mode = "list", envir = envir, 
[17:01:04.960]                           inherits = FALSE)) {
[17:01:04.960]                           master <- get("master", mode = "list", 
[17:01:04.960]                             envir = envir, inherits = FALSE)
[17:01:04.960]                           if (inherits(master, c("SOCKnode", 
[17:01:04.960]                             "SOCK0node"))) {
[17:01:04.960]                             sendCondition <<- function(cond) {
[17:01:04.960]                               data <- list(type = "VALUE", value = cond, 
[17:01:04.960]                                 success = TRUE)
[17:01:04.960]                               parallel_sendData(master, data)
[17:01:04.960]                             }
[17:01:04.960]                             return(sendCondition)
[17:01:04.960]                           }
[17:01:04.960]                         }
[17:01:04.960]                         frame <- frame + 1L
[17:01:04.960]                         envir <- sys.frame(frame)
[17:01:04.960]                       }
[17:01:04.960]                     }
[17:01:04.960]                     sendCondition <<- function(cond) NULL
[17:01:04.960]                   }
[17:01:04.960]                 })
[17:01:04.960]                 withCallingHandlers({
[17:01:04.960]                   {
[17:01:04.960]                     do.call(function(...) {
[17:01:04.960]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:04.960]                       if (!identical(...future.globals.maxSize.org, 
[17:01:04.960]                         ...future.globals.maxSize)) {
[17:01:04.960]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:04.960]                         on.exit(options(oopts), add = TRUE)
[17:01:04.960]                       }
[17:01:04.960]                       {
[17:01:04.960]                         lapply(seq_along(...future.elements_ii), 
[17:01:04.960]                           FUN = function(jj) {
[17:01:04.960]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:04.960]                             ...future.FUN(...future.X_jj, ...)
[17:01:04.960]                           })
[17:01:04.960]                       }
[17:01:04.960]                     }, args = future.call.arguments)
[17:01:04.960]                   }
[17:01:04.960]                 }, immediateCondition = function(cond) {
[17:01:04.960]                   sendCondition <- ...future.makeSendCondition()
[17:01:04.960]                   sendCondition(cond)
[17:01:04.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.960]                   {
[17:01:04.960]                     inherits <- base::inherits
[17:01:04.960]                     invokeRestart <- base::invokeRestart
[17:01:04.960]                     is.null <- base::is.null
[17:01:04.960]                     muffled <- FALSE
[17:01:04.960]                     if (inherits(cond, "message")) {
[17:01:04.960]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:04.960]                       if (muffled) 
[17:01:04.960]                         invokeRestart("muffleMessage")
[17:01:04.960]                     }
[17:01:04.960]                     else if (inherits(cond, "warning")) {
[17:01:04.960]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:04.960]                       if (muffled) 
[17:01:04.960]                         invokeRestart("muffleWarning")
[17:01:04.960]                     }
[17:01:04.960]                     else if (inherits(cond, "condition")) {
[17:01:04.960]                       if (!is.null(pattern)) {
[17:01:04.960]                         computeRestarts <- base::computeRestarts
[17:01:04.960]                         grepl <- base::grepl
[17:01:04.960]                         restarts <- computeRestarts(cond)
[17:01:04.960]                         for (restart in restarts) {
[17:01:04.960]                           name <- restart$name
[17:01:04.960]                           if (is.null(name)) 
[17:01:04.960]                             next
[17:01:04.960]                           if (!grepl(pattern, name)) 
[17:01:04.960]                             next
[17:01:04.960]                           invokeRestart(restart)
[17:01:04.960]                           muffled <- TRUE
[17:01:04.960]                           break
[17:01:04.960]                         }
[17:01:04.960]                       }
[17:01:04.960]                     }
[17:01:04.960]                     invisible(muffled)
[17:01:04.960]                   }
[17:01:04.960]                   muffleCondition(cond)
[17:01:04.960]                 })
[17:01:04.960]             }))
[17:01:04.960]             future::FutureResult(value = ...future.value$value, 
[17:01:04.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.960]                   ...future.rng), globalenv = if (FALSE) 
[17:01:04.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:04.960]                     ...future.globalenv.names))
[17:01:04.960]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:04.960]         }, condition = base::local({
[17:01:04.960]             c <- base::c
[17:01:04.960]             inherits <- base::inherits
[17:01:04.960]             invokeRestart <- base::invokeRestart
[17:01:04.960]             length <- base::length
[17:01:04.960]             list <- base::list
[17:01:04.960]             seq.int <- base::seq.int
[17:01:04.960]             signalCondition <- base::signalCondition
[17:01:04.960]             sys.calls <- base::sys.calls
[17:01:04.960]             `[[` <- base::`[[`
[17:01:04.960]             `+` <- base::`+`
[17:01:04.960]             `<<-` <- base::`<<-`
[17:01:04.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:04.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:04.960]                   3L)]
[17:01:04.960]             }
[17:01:04.960]             function(cond) {
[17:01:04.960]                 is_error <- inherits(cond, "error")
[17:01:04.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:04.960]                   NULL)
[17:01:04.960]                 if (is_error) {
[17:01:04.960]                   sessionInformation <- function() {
[17:01:04.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:04.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:04.960]                       search = base::search(), system = base::Sys.info())
[17:01:04.960]                   }
[17:01:04.960]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:04.960]                     cond$call), session = sessionInformation(), 
[17:01:04.960]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:04.960]                   signalCondition(cond)
[17:01:04.960]                 }
[17:01:04.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:04.960]                 "immediateCondition"))) {
[17:01:04.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:04.960]                   ...future.conditions[[length(...future.conditions) + 
[17:01:04.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:04.960]                   if (TRUE && !signal) {
[17:01:04.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.960]                     {
[17:01:04.960]                       inherits <- base::inherits
[17:01:04.960]                       invokeRestart <- base::invokeRestart
[17:01:04.960]                       is.null <- base::is.null
[17:01:04.960]                       muffled <- FALSE
[17:01:04.960]                       if (inherits(cond, "message")) {
[17:01:04.960]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.960]                         if (muffled) 
[17:01:04.960]                           invokeRestart("muffleMessage")
[17:01:04.960]                       }
[17:01:04.960]                       else if (inherits(cond, "warning")) {
[17:01:04.960]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.960]                         if (muffled) 
[17:01:04.960]                           invokeRestart("muffleWarning")
[17:01:04.960]                       }
[17:01:04.960]                       else if (inherits(cond, "condition")) {
[17:01:04.960]                         if (!is.null(pattern)) {
[17:01:04.960]                           computeRestarts <- base::computeRestarts
[17:01:04.960]                           grepl <- base::grepl
[17:01:04.960]                           restarts <- computeRestarts(cond)
[17:01:04.960]                           for (restart in restarts) {
[17:01:04.960]                             name <- restart$name
[17:01:04.960]                             if (is.null(name)) 
[17:01:04.960]                               next
[17:01:04.960]                             if (!grepl(pattern, name)) 
[17:01:04.960]                               next
[17:01:04.960]                             invokeRestart(restart)
[17:01:04.960]                             muffled <- TRUE
[17:01:04.960]                             break
[17:01:04.960]                           }
[17:01:04.960]                         }
[17:01:04.960]                       }
[17:01:04.960]                       invisible(muffled)
[17:01:04.960]                     }
[17:01:04.960]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.960]                   }
[17:01:04.960]                 }
[17:01:04.960]                 else {
[17:01:04.960]                   if (TRUE) {
[17:01:04.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:04.960]                     {
[17:01:04.960]                       inherits <- base::inherits
[17:01:04.960]                       invokeRestart <- base::invokeRestart
[17:01:04.960]                       is.null <- base::is.null
[17:01:04.960]                       muffled <- FALSE
[17:01:04.960]                       if (inherits(cond, "message")) {
[17:01:04.960]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:04.960]                         if (muffled) 
[17:01:04.960]                           invokeRestart("muffleMessage")
[17:01:04.960]                       }
[17:01:04.960]                       else if (inherits(cond, "warning")) {
[17:01:04.960]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:04.960]                         if (muffled) 
[17:01:04.960]                           invokeRestart("muffleWarning")
[17:01:04.960]                       }
[17:01:04.960]                       else if (inherits(cond, "condition")) {
[17:01:04.960]                         if (!is.null(pattern)) {
[17:01:04.960]                           computeRestarts <- base::computeRestarts
[17:01:04.960]                           grepl <- base::grepl
[17:01:04.960]                           restarts <- computeRestarts(cond)
[17:01:04.960]                           for (restart in restarts) {
[17:01:04.960]                             name <- restart$name
[17:01:04.960]                             if (is.null(name)) 
[17:01:04.960]                               next
[17:01:04.960]                             if (!grepl(pattern, name)) 
[17:01:04.960]                               next
[17:01:04.960]                             invokeRestart(restart)
[17:01:04.960]                             muffled <- TRUE
[17:01:04.960]                             break
[17:01:04.960]                           }
[17:01:04.960]                         }
[17:01:04.960]                       }
[17:01:04.960]                       invisible(muffled)
[17:01:04.960]                     }
[17:01:04.960]                     muffleCondition(cond, pattern = "^muffle")
[17:01:04.960]                   }
[17:01:04.960]                 }
[17:01:04.960]             }
[17:01:04.960]         }))
[17:01:04.960]     }, error = function(ex) {
[17:01:04.960]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:04.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:04.960]                 ...future.rng), started = ...future.startTime, 
[17:01:04.960]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:04.960]             version = "1.8"), class = "FutureResult")
[17:01:04.960]     }, finally = {
[17:01:04.960]         if (!identical(...future.workdir, getwd())) 
[17:01:04.960]             setwd(...future.workdir)
[17:01:04.960]         {
[17:01:04.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:04.960]                 ...future.oldOptions$nwarnings <- NULL
[17:01:04.960]             }
[17:01:04.960]             base::options(...future.oldOptions)
[17:01:04.960]             if (.Platform$OS.type == "windows") {
[17:01:04.960]                 old_names <- names(...future.oldEnvVars)
[17:01:04.960]                 envs <- base::Sys.getenv()
[17:01:04.960]                 names <- names(envs)
[17:01:04.960]                 common <- intersect(names, old_names)
[17:01:04.960]                 added <- setdiff(names, old_names)
[17:01:04.960]                 removed <- setdiff(old_names, names)
[17:01:04.960]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:04.960]                   envs[common]]
[17:01:04.960]                 NAMES <- toupper(changed)
[17:01:04.960]                 args <- list()
[17:01:04.960]                 for (kk in seq_along(NAMES)) {
[17:01:04.960]                   name <- changed[[kk]]
[17:01:04.960]                   NAME <- NAMES[[kk]]
[17:01:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.960]                     next
[17:01:04.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.960]                 }
[17:01:04.960]                 NAMES <- toupper(added)
[17:01:04.960]                 for (kk in seq_along(NAMES)) {
[17:01:04.960]                   name <- added[[kk]]
[17:01:04.960]                   NAME <- NAMES[[kk]]
[17:01:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.960]                     next
[17:01:04.960]                   args[[name]] <- ""
[17:01:04.960]                 }
[17:01:04.960]                 NAMES <- toupper(removed)
[17:01:04.960]                 for (kk in seq_along(NAMES)) {
[17:01:04.960]                   name <- removed[[kk]]
[17:01:04.960]                   NAME <- NAMES[[kk]]
[17:01:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:04.960]                     next
[17:01:04.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:04.960]                 }
[17:01:04.960]                 if (length(args) > 0) 
[17:01:04.960]                   base::do.call(base::Sys.setenv, args = args)
[17:01:04.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:04.960]             }
[17:01:04.960]             else {
[17:01:04.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:04.960]             }
[17:01:04.960]             {
[17:01:04.960]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:04.960]                   0L) {
[17:01:04.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:04.960]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:04.960]                   base::options(opts)
[17:01:04.960]                 }
[17:01:04.960]                 {
[17:01:04.960]                   {
[17:01:04.960]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:04.960]                     NULL
[17:01:04.960]                   }
[17:01:04.960]                   options(future.plan = NULL)
[17:01:04.960]                   if (is.na(NA_character_)) 
[17:01:04.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:04.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:04.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:04.960]                     .init = FALSE)
[17:01:04.960]                 }
[17:01:04.960]             }
[17:01:04.960]         }
[17:01:04.960]     })
[17:01:04.960]     if (TRUE) {
[17:01:04.960]         base::sink(type = "output", split = FALSE)
[17:01:04.960]         if (TRUE) {
[17:01:04.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:04.960]         }
[17:01:04.960]         else {
[17:01:04.960]             ...future.result["stdout"] <- base::list(NULL)
[17:01:04.960]         }
[17:01:04.960]         base::close(...future.stdout)
[17:01:04.960]         ...future.stdout <- NULL
[17:01:04.960]     }
[17:01:04.960]     ...future.result$conditions <- ...future.conditions
[17:01:04.960]     ...future.result$finished <- base::Sys.time()
[17:01:04.960]     ...future.result
[17:01:04.960] }
[17:01:05.012] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[17:01:05.012] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:05.016] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:05.017] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:01:05.017] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:01:05.017] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:05.018] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:05.018] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:05.060] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:05.060] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:05.104] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:05.104] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:05.104] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.105] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[17:01:05.105] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[17:01:05.105] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:05.106] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.106] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[17:01:05.106] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[17:01:05.107] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:05.107] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.107] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:05.108] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.108] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[17:01:05.108] MultisessionFuture started
[17:01:05.109] - Launch lazy future ... done
[17:01:05.109] run() for ‘MultisessionFuture’ ... done
[17:01:05.109] Created future:
[17:01:05.109] MultisessionFuture:
[17:01:05.109] Label: ‘future_vapply-2’
[17:01:05.109] Expression:
[17:01:05.109] {
[17:01:05.109]     do.call(function(...) {
[17:01:05.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.109]             on.exit(options(oopts), add = TRUE)
[17:01:05.109]         }
[17:01:05.109]         {
[17:01:05.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.109]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.109]             })
[17:01:05.109]         }
[17:01:05.109]     }, args = future.call.arguments)
[17:01:05.109] }
[17:01:05.109] Lazy evaluation: FALSE
[17:01:05.109] Asynchronous evaluation: TRUE
[17:01:05.109] Local evaluation: TRUE
[17:01:05.109] Environment: R_GlobalEnv
[17:01:05.109] Capture standard output: TRUE
[17:01:05.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:05.109] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:05.109] Packages: 1 packages (‘future.apply’)
[17:01:05.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:05.109] Resolved: FALSE
[17:01:05.109] Value: <not collected>
[17:01:05.109] Conditions captured: <none>
[17:01:05.109] Early signaling: FALSE
[17:01:05.109] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:05.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.123] Chunk #2 of 2 ... DONE
[17:01:05.123] Launching 2 futures (chunks) ... DONE
[17:01:05.123] Resolving 2 futures (chunks) ...
[17:01:05.124] resolve() on list ...
[17:01:05.124]  recursive: 0
[17:01:05.124]  length: 2
[17:01:05.124] 
[17:01:05.125] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.125] - Validating connection of MultisessionFuture
[17:01:05.125] - received message: FutureResult
[17:01:05.125] - Received FutureResult
[17:01:05.125] - Erased future from FutureRegistry
[17:01:05.125] result() for ClusterFuture ...
[17:01:05.125] - result already collected: FutureResult
[17:01:05.125] result() for ClusterFuture ... done
[17:01:05.125] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.126] Future #1
[17:01:05.126] result() for ClusterFuture ...
[17:01:05.126] - result already collected: FutureResult
[17:01:05.126] result() for ClusterFuture ... done
[17:01:05.126] result() for ClusterFuture ...
[17:01:05.126] - result already collected: FutureResult
[17:01:05.126] result() for ClusterFuture ... done
[17:01:05.126] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:05.126] - nx: 2
[17:01:05.126] - relay: TRUE
[17:01:05.127] - stdout: TRUE
[17:01:05.127] - signal: TRUE
[17:01:05.127] - resignal: FALSE
[17:01:05.127] - force: TRUE
[17:01:05.127] - relayed: [n=2] FALSE, FALSE
[17:01:05.127] - queued futures: [n=2] FALSE, FALSE
[17:01:05.127]  - until=1
[17:01:05.127]  - relaying element #1
[17:01:05.127] result() for ClusterFuture ...
[17:01:05.128] - result already collected: FutureResult
[17:01:05.128] result() for ClusterFuture ... done
[17:01:05.128] result() for ClusterFuture ...
[17:01:05.128] - result already collected: FutureResult
[17:01:05.128] result() for ClusterFuture ... done
[17:01:05.128] result() for ClusterFuture ...
[17:01:05.128] - result already collected: FutureResult
[17:01:05.128] result() for ClusterFuture ... done
[17:01:05.128] result() for ClusterFuture ...
[17:01:05.128] - result already collected: FutureResult
[17:01:05.128] result() for ClusterFuture ... done
[17:01:05.128] - relayed: [n=2] TRUE, FALSE
[17:01:05.129] - queued futures: [n=2] TRUE, FALSE
[17:01:05.129] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:05.129]  length: 1 (resolved future 1)
[17:01:05.195] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.195] - Validating connection of MultisessionFuture
[17:01:05.195] - received message: FutureResult
[17:01:05.195] - Received FutureResult
[17:01:05.195] - Erased future from FutureRegistry
[17:01:05.195] result() for ClusterFuture ...
[17:01:05.195] - result already collected: FutureResult
[17:01:05.196] result() for ClusterFuture ... done
[17:01:05.196] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.196] Future #2
[17:01:05.196] result() for ClusterFuture ...
[17:01:05.196] - result already collected: FutureResult
[17:01:05.196] result() for ClusterFuture ... done
[17:01:05.196] result() for ClusterFuture ...
[17:01:05.196] - result already collected: FutureResult
[17:01:05.196] result() for ClusterFuture ... done
[17:01:05.196] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:05.196] - nx: 2
[17:01:05.196] - relay: TRUE
[17:01:05.197] - stdout: TRUE
[17:01:05.197] - signal: TRUE
[17:01:05.197] - resignal: FALSE
[17:01:05.197] - force: TRUE
[17:01:05.197] - relayed: [n=2] TRUE, FALSE
[17:01:05.197] - queued futures: [n=2] TRUE, FALSE
[17:01:05.197]  - until=2
[17:01:05.197]  - relaying element #2
[17:01:05.197] result() for ClusterFuture ...
[17:01:05.197] - result already collected: FutureResult
[17:01:05.197] result() for ClusterFuture ... done
[17:01:05.198] result() for ClusterFuture ...
[17:01:05.198] - result already collected: FutureResult
[17:01:05.198] result() for ClusterFuture ... done
[17:01:05.198] result() for ClusterFuture ...
[17:01:05.198] - result already collected: FutureResult
[17:01:05.198] result() for ClusterFuture ... done
[17:01:05.198] result() for ClusterFuture ...
[17:01:05.198] - result already collected: FutureResult
[17:01:05.198] result() for ClusterFuture ... done
[17:01:05.198] - relayed: [n=2] TRUE, TRUE
[17:01:05.198] - queued futures: [n=2] TRUE, TRUE
[17:01:05.198] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:05.199]  length: 0 (resolved future 2)
[17:01:05.199] Relaying remaining futures
[17:01:05.199] signalConditionsASAP(NULL, pos=0) ...
[17:01:05.199] - nx: 2
[17:01:05.199] - relay: TRUE
[17:01:05.199] - stdout: TRUE
[17:01:05.199] - signal: TRUE
[17:01:05.199] - resignal: FALSE
[17:01:05.199] - force: TRUE
[17:01:05.199] - relayed: [n=2] TRUE, TRUE
[17:01:05.199] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:05.200] - relayed: [n=2] TRUE, TRUE
[17:01:05.200] - queued futures: [n=2] TRUE, TRUE
[17:01:05.200] signalConditionsASAP(NULL, pos=0) ... done
[17:01:05.200] resolve() on list ... DONE
[17:01:05.200] result() for ClusterFuture ...
[17:01:05.200] - result already collected: FutureResult
[17:01:05.200] result() for ClusterFuture ... done
[17:01:05.200] result() for ClusterFuture ...
[17:01:05.200] - result already collected: FutureResult
[17:01:05.200] result() for ClusterFuture ... done
[17:01:05.200] result() for ClusterFuture ...
[17:01:05.200] - result already collected: FutureResult
[17:01:05.201] result() for ClusterFuture ... done
[17:01:05.201] result() for ClusterFuture ...
[17:01:05.201] - result already collected: FutureResult
[17:01:05.201] result() for ClusterFuture ... done
[17:01:05.201]  - Number of value chunks collected: 2
[17:01:05.201] Resolving 2 futures (chunks) ... DONE
[17:01:05.201] Reducing values from 2 chunks ...
[17:01:05.201]  - Number of values collected after concatenation: 2
[17:01:05.201]  - Number of values expected: 2
[17:01:05.201] Reducing values from 2 chunks ... DONE
[17:01:05.201] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:01:05.202] future_lapply() ...
[17:01:05.208] Number of chunks: 2
[17:01:05.208] getGlobalsAndPackagesXApply() ...
[17:01:05.208]  - future.globals: TRUE
[17:01:05.208] getGlobalsAndPackages() ...
[17:01:05.208] Searching for globals...
[17:01:05.212] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:01:05.212] Searching for globals ... DONE
[17:01:05.212] Resolving globals: FALSE
[17:01:05.213] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:01:05.213] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:05.213] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:05.214] - packages: [1] ‘future.apply’
[17:01:05.214] getGlobalsAndPackages() ... DONE
[17:01:05.214]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:05.214]  - needed namespaces: [n=1] ‘future.apply’
[17:01:05.214] Finding globals ... DONE
[17:01:05.214]  - use_args: TRUE
[17:01:05.214]  - Getting '...' globals ...
[17:01:05.214] resolve() on list ...
[17:01:05.214]  recursive: 0
[17:01:05.215]  length: 1
[17:01:05.215]  elements: ‘...’
[17:01:05.215]  length: 0 (resolved future 1)
[17:01:05.215] resolve() on list ... DONE
[17:01:05.215]    - '...' content: [n=0] 
[17:01:05.215] List of 1
[17:01:05.215]  $ ...: list()
[17:01:05.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:05.215]  - attr(*, "where")=List of 1
[17:01:05.215]   ..$ ...:<environment: 0x55aadad27300> 
[17:01:05.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:05.215]  - attr(*, "resolved")= logi TRUE
[17:01:05.215]  - attr(*, "total_size")= num NA
[17:01:05.217]  - Getting '...' globals ... DONE
[17:01:05.218] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:05.218] List of 8
[17:01:05.218]  $ ...future.FUN:function (x, ...)  
[17:01:05.218]  $ x_FUN        :function (x)  
[17:01:05.218]  $ times        : int 0
[17:01:05.218]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:05.218]  $ stop_if_not  :function (...)  
[17:01:05.218]  $ dim          : NULL
[17:01:05.218]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:05.218]  $ ...          : list()
[17:01:05.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:05.218]  - attr(*, "where")=List of 8
[17:01:05.218]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:05.218]   ..$ ...          :<environment: 0x55aadad27300> 
[17:01:05.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:05.218]  - attr(*, "resolved")= logi FALSE
[17:01:05.218]  - attr(*, "total_size")= num 95472
[17:01:05.223] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:05.223] getGlobalsAndPackagesXApply() ... DONE
[17:01:05.223] Number of futures (= number of chunks): 2
[17:01:05.223] Launching 2 futures (chunks) ...
[17:01:05.223] Chunk #1 of 2 ...
[17:01:05.224]  - Finding globals in 'X' for chunk #1 ...
[17:01:05.224] getGlobalsAndPackages() ...
[17:01:05.224] Searching for globals...
[17:01:05.224] 
[17:01:05.224] Searching for globals ... DONE
[17:01:05.224] - globals: [0] <none>
[17:01:05.224] getGlobalsAndPackages() ... DONE
[17:01:05.224]    + additional globals found: [n=0] 
[17:01:05.224]    + additional namespaces needed: [n=0] 
[17:01:05.225]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:05.225]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:05.225]  - seeds: <none>
[17:01:05.225]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.225] getGlobalsAndPackages() ...
[17:01:05.225] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.225] Resolving globals: FALSE
[17:01:05.225] Tweak future expression to call with '...' arguments ...
[17:01:05.225] {
[17:01:05.225]     do.call(function(...) {
[17:01:05.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.225]             on.exit(options(oopts), add = TRUE)
[17:01:05.225]         }
[17:01:05.225]         {
[17:01:05.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.225]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.225]             })
[17:01:05.225]         }
[17:01:05.225]     }, args = future.call.arguments)
[17:01:05.225] }
[17:01:05.226] Tweak future expression to call with '...' arguments ... DONE
[17:01:05.226] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.226] - packages: [1] ‘future.apply’
[17:01:05.226] getGlobalsAndPackages() ... DONE
[17:01:05.227] run() for ‘Future’ ...
[17:01:05.227] - state: ‘created’
[17:01:05.227] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:05.242] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:05.242]   - Field: ‘node’
[17:01:05.243]   - Field: ‘label’
[17:01:05.243]   - Field: ‘local’
[17:01:05.243]   - Field: ‘owner’
[17:01:05.243]   - Field: ‘envir’
[17:01:05.243]   - Field: ‘workers’
[17:01:05.243]   - Field: ‘packages’
[17:01:05.243]   - Field: ‘gc’
[17:01:05.243]   - Field: ‘conditions’
[17:01:05.243]   - Field: ‘persistent’
[17:01:05.243]   - Field: ‘expr’
[17:01:05.244]   - Field: ‘uuid’
[17:01:05.244]   - Field: ‘seed’
[17:01:05.244]   - Field: ‘version’
[17:01:05.244]   - Field: ‘result’
[17:01:05.244]   - Field: ‘asynchronous’
[17:01:05.244]   - Field: ‘calls’
[17:01:05.244]   - Field: ‘globals’
[17:01:05.244]   - Field: ‘stdout’
[17:01:05.244]   - Field: ‘earlySignal’
[17:01:05.244]   - Field: ‘lazy’
[17:01:05.244]   - Field: ‘state’
[17:01:05.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:05.245] - Launch lazy future ...
[17:01:05.245] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:05.245] Packages needed by future strategies (n = 0): <none>
[17:01:05.245] {
[17:01:05.245]     {
[17:01:05.245]         {
[17:01:05.245]             ...future.startTime <- base::Sys.time()
[17:01:05.245]             {
[17:01:05.245]                 {
[17:01:05.245]                   {
[17:01:05.245]                     {
[17:01:05.245]                       {
[17:01:05.245]                         base::local({
[17:01:05.245]                           has_future <- base::requireNamespace("future", 
[17:01:05.245]                             quietly = TRUE)
[17:01:05.245]                           if (has_future) {
[17:01:05.245]                             ns <- base::getNamespace("future")
[17:01:05.245]                             version <- ns[[".package"]][["version"]]
[17:01:05.245]                             if (is.null(version)) 
[17:01:05.245]                               version <- utils::packageVersion("future")
[17:01:05.245]                           }
[17:01:05.245]                           else {
[17:01:05.245]                             version <- NULL
[17:01:05.245]                           }
[17:01:05.245]                           if (!has_future || version < "1.8.0") {
[17:01:05.245]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:05.245]                               "", base::R.version$version.string), 
[17:01:05.245]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:05.245]                                 base::R.version$platform, 8 * 
[17:01:05.245]                                   base::.Machine$sizeof.pointer), 
[17:01:05.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:05.245]                                 "release", "version")], collapse = " "), 
[17:01:05.245]                               hostname = base::Sys.info()[["nodename"]])
[17:01:05.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:05.245]                               info)
[17:01:05.245]                             info <- base::paste(info, collapse = "; ")
[17:01:05.245]                             if (!has_future) {
[17:01:05.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:05.245]                                 info)
[17:01:05.245]                             }
[17:01:05.245]                             else {
[17:01:05.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:05.245]                                 info, version)
[17:01:05.245]                             }
[17:01:05.245]                             base::stop(msg)
[17:01:05.245]                           }
[17:01:05.245]                         })
[17:01:05.245]                       }
[17:01:05.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:05.245]                       base::options(mc.cores = 1L)
[17:01:05.245]                     }
[17:01:05.245]                     base::local({
[17:01:05.245]                       for (pkg in "future.apply") {
[17:01:05.245]                         base::loadNamespace(pkg)
[17:01:05.245]                         base::library(pkg, character.only = TRUE)
[17:01:05.245]                       }
[17:01:05.245]                     })
[17:01:05.245]                   }
[17:01:05.245]                   ...future.strategy.old <- future::plan("list")
[17:01:05.245]                   options(future.plan = NULL)
[17:01:05.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:05.245]                 }
[17:01:05.245]                 ...future.workdir <- getwd()
[17:01:05.245]             }
[17:01:05.245]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:05.245]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:05.245]         }
[17:01:05.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:05.245]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:05.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:05.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:05.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:05.245]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:05.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:05.245]             base::names(...future.oldOptions))
[17:01:05.245]     }
[17:01:05.245]     if (FALSE) {
[17:01:05.245]     }
[17:01:05.245]     else {
[17:01:05.245]         if (TRUE) {
[17:01:05.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:05.245]                 open = "w")
[17:01:05.245]         }
[17:01:05.245]         else {
[17:01:05.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:05.245]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:05.245]         }
[17:01:05.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:05.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:05.245]             base::sink(type = "output", split = FALSE)
[17:01:05.245]             base::close(...future.stdout)
[17:01:05.245]         }, add = TRUE)
[17:01:05.245]     }
[17:01:05.245]     ...future.frame <- base::sys.nframe()
[17:01:05.245]     ...future.conditions <- base::list()
[17:01:05.245]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:05.245]     if (FALSE) {
[17:01:05.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:05.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:05.245]     }
[17:01:05.245]     ...future.result <- base::tryCatch({
[17:01:05.245]         base::withCallingHandlers({
[17:01:05.245]             ...future.value <- base::withVisible(base::local({
[17:01:05.245]                 ...future.makeSendCondition <- base::local({
[17:01:05.245]                   sendCondition <- NULL
[17:01:05.245]                   function(frame = 1L) {
[17:01:05.245]                     if (is.function(sendCondition)) 
[17:01:05.245]                       return(sendCondition)
[17:01:05.245]                     ns <- getNamespace("parallel")
[17:01:05.245]                     if (exists("sendData", mode = "function", 
[17:01:05.245]                       envir = ns)) {
[17:01:05.245]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:05.245]                         envir = ns)
[17:01:05.245]                       envir <- sys.frame(frame)
[17:01:05.245]                       master <- NULL
[17:01:05.245]                       while (!identical(envir, .GlobalEnv) && 
[17:01:05.245]                         !identical(envir, emptyenv())) {
[17:01:05.245]                         if (exists("master", mode = "list", envir = envir, 
[17:01:05.245]                           inherits = FALSE)) {
[17:01:05.245]                           master <- get("master", mode = "list", 
[17:01:05.245]                             envir = envir, inherits = FALSE)
[17:01:05.245]                           if (inherits(master, c("SOCKnode", 
[17:01:05.245]                             "SOCK0node"))) {
[17:01:05.245]                             sendCondition <<- function(cond) {
[17:01:05.245]                               data <- list(type = "VALUE", value = cond, 
[17:01:05.245]                                 success = TRUE)
[17:01:05.245]                               parallel_sendData(master, data)
[17:01:05.245]                             }
[17:01:05.245]                             return(sendCondition)
[17:01:05.245]                           }
[17:01:05.245]                         }
[17:01:05.245]                         frame <- frame + 1L
[17:01:05.245]                         envir <- sys.frame(frame)
[17:01:05.245]                       }
[17:01:05.245]                     }
[17:01:05.245]                     sendCondition <<- function(cond) NULL
[17:01:05.245]                   }
[17:01:05.245]                 })
[17:01:05.245]                 withCallingHandlers({
[17:01:05.245]                   {
[17:01:05.245]                     do.call(function(...) {
[17:01:05.245]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.245]                       if (!identical(...future.globals.maxSize.org, 
[17:01:05.245]                         ...future.globals.maxSize)) {
[17:01:05.245]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.245]                         on.exit(options(oopts), add = TRUE)
[17:01:05.245]                       }
[17:01:05.245]                       {
[17:01:05.245]                         lapply(seq_along(...future.elements_ii), 
[17:01:05.245]                           FUN = function(jj) {
[17:01:05.245]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.245]                             ...future.FUN(...future.X_jj, ...)
[17:01:05.245]                           })
[17:01:05.245]                       }
[17:01:05.245]                     }, args = future.call.arguments)
[17:01:05.245]                   }
[17:01:05.245]                 }, immediateCondition = function(cond) {
[17:01:05.245]                   sendCondition <- ...future.makeSendCondition()
[17:01:05.245]                   sendCondition(cond)
[17:01:05.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.245]                   {
[17:01:05.245]                     inherits <- base::inherits
[17:01:05.245]                     invokeRestart <- base::invokeRestart
[17:01:05.245]                     is.null <- base::is.null
[17:01:05.245]                     muffled <- FALSE
[17:01:05.245]                     if (inherits(cond, "message")) {
[17:01:05.245]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:05.245]                       if (muffled) 
[17:01:05.245]                         invokeRestart("muffleMessage")
[17:01:05.245]                     }
[17:01:05.245]                     else if (inherits(cond, "warning")) {
[17:01:05.245]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:05.245]                       if (muffled) 
[17:01:05.245]                         invokeRestart("muffleWarning")
[17:01:05.245]                     }
[17:01:05.245]                     else if (inherits(cond, "condition")) {
[17:01:05.245]                       if (!is.null(pattern)) {
[17:01:05.245]                         computeRestarts <- base::computeRestarts
[17:01:05.245]                         grepl <- base::grepl
[17:01:05.245]                         restarts <- computeRestarts(cond)
[17:01:05.245]                         for (restart in restarts) {
[17:01:05.245]                           name <- restart$name
[17:01:05.245]                           if (is.null(name)) 
[17:01:05.245]                             next
[17:01:05.245]                           if (!grepl(pattern, name)) 
[17:01:05.245]                             next
[17:01:05.245]                           invokeRestart(restart)
[17:01:05.245]                           muffled <- TRUE
[17:01:05.245]                           break
[17:01:05.245]                         }
[17:01:05.245]                       }
[17:01:05.245]                     }
[17:01:05.245]                     invisible(muffled)
[17:01:05.245]                   }
[17:01:05.245]                   muffleCondition(cond)
[17:01:05.245]                 })
[17:01:05.245]             }))
[17:01:05.245]             future::FutureResult(value = ...future.value$value, 
[17:01:05.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.245]                   ...future.rng), globalenv = if (FALSE) 
[17:01:05.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:05.245]                     ...future.globalenv.names))
[17:01:05.245]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:05.245]         }, condition = base::local({
[17:01:05.245]             c <- base::c
[17:01:05.245]             inherits <- base::inherits
[17:01:05.245]             invokeRestart <- base::invokeRestart
[17:01:05.245]             length <- base::length
[17:01:05.245]             list <- base::list
[17:01:05.245]             seq.int <- base::seq.int
[17:01:05.245]             signalCondition <- base::signalCondition
[17:01:05.245]             sys.calls <- base::sys.calls
[17:01:05.245]             `[[` <- base::`[[`
[17:01:05.245]             `+` <- base::`+`
[17:01:05.245]             `<<-` <- base::`<<-`
[17:01:05.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:05.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:05.245]                   3L)]
[17:01:05.245]             }
[17:01:05.245]             function(cond) {
[17:01:05.245]                 is_error <- inherits(cond, "error")
[17:01:05.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:05.245]                   NULL)
[17:01:05.245]                 if (is_error) {
[17:01:05.245]                   sessionInformation <- function() {
[17:01:05.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:05.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:05.245]                       search = base::search(), system = base::Sys.info())
[17:01:05.245]                   }
[17:01:05.245]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:05.245]                     cond$call), session = sessionInformation(), 
[17:01:05.245]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:05.245]                   signalCondition(cond)
[17:01:05.245]                 }
[17:01:05.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:05.245]                 "immediateCondition"))) {
[17:01:05.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:05.245]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:05.245]                   if (TRUE && !signal) {
[17:01:05.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.245]                     {
[17:01:05.245]                       inherits <- base::inherits
[17:01:05.245]                       invokeRestart <- base::invokeRestart
[17:01:05.245]                       is.null <- base::is.null
[17:01:05.245]                       muffled <- FALSE
[17:01:05.245]                       if (inherits(cond, "message")) {
[17:01:05.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.245]                         if (muffled) 
[17:01:05.245]                           invokeRestart("muffleMessage")
[17:01:05.245]                       }
[17:01:05.245]                       else if (inherits(cond, "warning")) {
[17:01:05.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.245]                         if (muffled) 
[17:01:05.245]                           invokeRestart("muffleWarning")
[17:01:05.245]                       }
[17:01:05.245]                       else if (inherits(cond, "condition")) {
[17:01:05.245]                         if (!is.null(pattern)) {
[17:01:05.245]                           computeRestarts <- base::computeRestarts
[17:01:05.245]                           grepl <- base::grepl
[17:01:05.245]                           restarts <- computeRestarts(cond)
[17:01:05.245]                           for (restart in restarts) {
[17:01:05.245]                             name <- restart$name
[17:01:05.245]                             if (is.null(name)) 
[17:01:05.245]                               next
[17:01:05.245]                             if (!grepl(pattern, name)) 
[17:01:05.245]                               next
[17:01:05.245]                             invokeRestart(restart)
[17:01:05.245]                             muffled <- TRUE
[17:01:05.245]                             break
[17:01:05.245]                           }
[17:01:05.245]                         }
[17:01:05.245]                       }
[17:01:05.245]                       invisible(muffled)
[17:01:05.245]                     }
[17:01:05.245]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.245]                   }
[17:01:05.245]                 }
[17:01:05.245]                 else {
[17:01:05.245]                   if (TRUE) {
[17:01:05.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.245]                     {
[17:01:05.245]                       inherits <- base::inherits
[17:01:05.245]                       invokeRestart <- base::invokeRestart
[17:01:05.245]                       is.null <- base::is.null
[17:01:05.245]                       muffled <- FALSE
[17:01:05.245]                       if (inherits(cond, "message")) {
[17:01:05.245]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.245]                         if (muffled) 
[17:01:05.245]                           invokeRestart("muffleMessage")
[17:01:05.245]                       }
[17:01:05.245]                       else if (inherits(cond, "warning")) {
[17:01:05.245]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.245]                         if (muffled) 
[17:01:05.245]                           invokeRestart("muffleWarning")
[17:01:05.245]                       }
[17:01:05.245]                       else if (inherits(cond, "condition")) {
[17:01:05.245]                         if (!is.null(pattern)) {
[17:01:05.245]                           computeRestarts <- base::computeRestarts
[17:01:05.245]                           grepl <- base::grepl
[17:01:05.245]                           restarts <- computeRestarts(cond)
[17:01:05.245]                           for (restart in restarts) {
[17:01:05.245]                             name <- restart$name
[17:01:05.245]                             if (is.null(name)) 
[17:01:05.245]                               next
[17:01:05.245]                             if (!grepl(pattern, name)) 
[17:01:05.245]                               next
[17:01:05.245]                             invokeRestart(restart)
[17:01:05.245]                             muffled <- TRUE
[17:01:05.245]                             break
[17:01:05.245]                           }
[17:01:05.245]                         }
[17:01:05.245]                       }
[17:01:05.245]                       invisible(muffled)
[17:01:05.245]                     }
[17:01:05.245]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.245]                   }
[17:01:05.245]                 }
[17:01:05.245]             }
[17:01:05.245]         }))
[17:01:05.245]     }, error = function(ex) {
[17:01:05.245]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:05.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.245]                 ...future.rng), started = ...future.startTime, 
[17:01:05.245]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:05.245]             version = "1.8"), class = "FutureResult")
[17:01:05.245]     }, finally = {
[17:01:05.245]         if (!identical(...future.workdir, getwd())) 
[17:01:05.245]             setwd(...future.workdir)
[17:01:05.245]         {
[17:01:05.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:05.245]                 ...future.oldOptions$nwarnings <- NULL
[17:01:05.245]             }
[17:01:05.245]             base::options(...future.oldOptions)
[17:01:05.245]             if (.Platform$OS.type == "windows") {
[17:01:05.245]                 old_names <- names(...future.oldEnvVars)
[17:01:05.245]                 envs <- base::Sys.getenv()
[17:01:05.245]                 names <- names(envs)
[17:01:05.245]                 common <- intersect(names, old_names)
[17:01:05.245]                 added <- setdiff(names, old_names)
[17:01:05.245]                 removed <- setdiff(old_names, names)
[17:01:05.245]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:05.245]                   envs[common]]
[17:01:05.245]                 NAMES <- toupper(changed)
[17:01:05.245]                 args <- list()
[17:01:05.245]                 for (kk in seq_along(NAMES)) {
[17:01:05.245]                   name <- changed[[kk]]
[17:01:05.245]                   NAME <- NAMES[[kk]]
[17:01:05.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.245]                     next
[17:01:05.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.245]                 }
[17:01:05.245]                 NAMES <- toupper(added)
[17:01:05.245]                 for (kk in seq_along(NAMES)) {
[17:01:05.245]                   name <- added[[kk]]
[17:01:05.245]                   NAME <- NAMES[[kk]]
[17:01:05.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.245]                     next
[17:01:05.245]                   args[[name]] <- ""
[17:01:05.245]                 }
[17:01:05.245]                 NAMES <- toupper(removed)
[17:01:05.245]                 for (kk in seq_along(NAMES)) {
[17:01:05.245]                   name <- removed[[kk]]
[17:01:05.245]                   NAME <- NAMES[[kk]]
[17:01:05.245]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.245]                     next
[17:01:05.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.245]                 }
[17:01:05.245]                 if (length(args) > 0) 
[17:01:05.245]                   base::do.call(base::Sys.setenv, args = args)
[17:01:05.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:05.245]             }
[17:01:05.245]             else {
[17:01:05.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:05.245]             }
[17:01:05.245]             {
[17:01:05.245]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:05.245]                   0L) {
[17:01:05.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:05.245]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:05.245]                   base::options(opts)
[17:01:05.245]                 }
[17:01:05.245]                 {
[17:01:05.245]                   {
[17:01:05.245]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:05.245]                     NULL
[17:01:05.245]                   }
[17:01:05.245]                   options(future.plan = NULL)
[17:01:05.245]                   if (is.na(NA_character_)) 
[17:01:05.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:05.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:05.245]                     .init = FALSE)
[17:01:05.245]                 }
[17:01:05.245]             }
[17:01:05.245]         }
[17:01:05.245]     })
[17:01:05.245]     if (TRUE) {
[17:01:05.245]         base::sink(type = "output", split = FALSE)
[17:01:05.245]         if (TRUE) {
[17:01:05.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:05.245]         }
[17:01:05.245]         else {
[17:01:05.245]             ...future.result["stdout"] <- base::list(NULL)
[17:01:05.245]         }
[17:01:05.245]         base::close(...future.stdout)
[17:01:05.245]         ...future.stdout <- NULL
[17:01:05.245]     }
[17:01:05.245]     ...future.result$conditions <- ...future.conditions
[17:01:05.245]     ...future.result$finished <- base::Sys.time()
[17:01:05.245]     ...future.result
[17:01:05.245] }
[17:01:05.248] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[17:01:05.248] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:05.292] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:05.292] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:01:05.293] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:01:05.293] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:05.293] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:05.293] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:05.336] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:05.336] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:05.380] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:05.380] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:05.381] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.381] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:05.381] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:05.381] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:05.382] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.382] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:05.382] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:05.382] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:05.383] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:05.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.383] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[17:01:05.384] MultisessionFuture started
[17:01:05.384] - Launch lazy future ... done
[17:01:05.384] run() for ‘MultisessionFuture’ ... done
[17:01:05.384] Created future:
[17:01:05.386] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.386] - Validating connection of MultisessionFuture
[17:01:05.386] - received message: FutureResult
[17:01:05.386] - Received FutureResult
[17:01:05.386] - Erased future from FutureRegistry
[17:01:05.386] result() for ClusterFuture ...
[17:01:05.386] - result already collected: FutureResult
[17:01:05.387] result() for ClusterFuture ... done
[17:01:05.387] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.384] MultisessionFuture:
[17:01:05.384] Label: ‘future_vapply-1’
[17:01:05.384] Expression:
[17:01:05.384] {
[17:01:05.384]     do.call(function(...) {
[17:01:05.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.384]             on.exit(options(oopts), add = TRUE)
[17:01:05.384]         }
[17:01:05.384]         {
[17:01:05.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.384]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.384]             })
[17:01:05.384]         }
[17:01:05.384]     }, args = future.call.arguments)
[17:01:05.384] }
[17:01:05.384] Lazy evaluation: FALSE
[17:01:05.384] Asynchronous evaluation: TRUE
[17:01:05.384] Local evaluation: TRUE
[17:01:05.384] Environment: R_GlobalEnv
[17:01:05.384] Capture standard output: TRUE
[17:01:05.384] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:05.384] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:05.384] Packages: 1 packages (‘future.apply’)
[17:01:05.384] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:05.384] Resolved: TRUE
[17:01:05.384] Value: <not collected>
[17:01:05.384] Conditions captured: <none>
[17:01:05.384] Early signaling: FALSE
[17:01:05.384] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:05.384] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.387] Chunk #1 of 2 ... DONE
[17:01:05.387] Chunk #2 of 2 ...
[17:01:05.387]  - Finding globals in 'X' for chunk #2 ...
[17:01:05.387] getGlobalsAndPackages() ...
[17:01:05.387] Searching for globals...
[17:01:05.388] 
[17:01:05.388] Searching for globals ... DONE
[17:01:05.388] - globals: [0] <none>
[17:01:05.388] getGlobalsAndPackages() ... DONE
[17:01:05.388]    + additional globals found: [n=0] 
[17:01:05.388]    + additional namespaces needed: [n=0] 
[17:01:05.388]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:05.388]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:05.388]  - seeds: <none>
[17:01:05.388]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.389] getGlobalsAndPackages() ...
[17:01:05.389] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.389] Resolving globals: FALSE
[17:01:05.389] Tweak future expression to call with '...' arguments ...
[17:01:05.389] {
[17:01:05.389]     do.call(function(...) {
[17:01:05.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.389]             on.exit(options(oopts), add = TRUE)
[17:01:05.389]         }
[17:01:05.389]         {
[17:01:05.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.389]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.389]             })
[17:01:05.389]         }
[17:01:05.389]     }, args = future.call.arguments)
[17:01:05.389] }
[17:01:05.389] Tweak future expression to call with '...' arguments ... DONE
[17:01:05.390] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.390] - packages: [1] ‘future.apply’
[17:01:05.390] getGlobalsAndPackages() ... DONE
[17:01:05.390] run() for ‘Future’ ...
[17:01:05.390] - state: ‘created’
[17:01:05.390] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:05.404] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:05.405]   - Field: ‘node’
[17:01:05.405]   - Field: ‘label’
[17:01:05.405]   - Field: ‘local’
[17:01:05.405]   - Field: ‘owner’
[17:01:05.405]   - Field: ‘envir’
[17:01:05.405]   - Field: ‘workers’
[17:01:05.405]   - Field: ‘packages’
[17:01:05.405]   - Field: ‘gc’
[17:01:05.406]   - Field: ‘conditions’
[17:01:05.406]   - Field: ‘persistent’
[17:01:05.406]   - Field: ‘expr’
[17:01:05.406]   - Field: ‘uuid’
[17:01:05.406]   - Field: ‘seed’
[17:01:05.406]   - Field: ‘version’
[17:01:05.406]   - Field: ‘result’
[17:01:05.406]   - Field: ‘asynchronous’
[17:01:05.406]   - Field: ‘calls’
[17:01:05.406]   - Field: ‘globals’
[17:01:05.406]   - Field: ‘stdout’
[17:01:05.406]   - Field: ‘earlySignal’
[17:01:05.407]   - Field: ‘lazy’
[17:01:05.407]   - Field: ‘state’
[17:01:05.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:05.407] - Launch lazy future ...
[17:01:05.407] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:05.407] Packages needed by future strategies (n = 0): <none>
[17:01:05.408] {
[17:01:05.408]     {
[17:01:05.408]         {
[17:01:05.408]             ...future.startTime <- base::Sys.time()
[17:01:05.408]             {
[17:01:05.408]                 {
[17:01:05.408]                   {
[17:01:05.408]                     {
[17:01:05.408]                       {
[17:01:05.408]                         base::local({
[17:01:05.408]                           has_future <- base::requireNamespace("future", 
[17:01:05.408]                             quietly = TRUE)
[17:01:05.408]                           if (has_future) {
[17:01:05.408]                             ns <- base::getNamespace("future")
[17:01:05.408]                             version <- ns[[".package"]][["version"]]
[17:01:05.408]                             if (is.null(version)) 
[17:01:05.408]                               version <- utils::packageVersion("future")
[17:01:05.408]                           }
[17:01:05.408]                           else {
[17:01:05.408]                             version <- NULL
[17:01:05.408]                           }
[17:01:05.408]                           if (!has_future || version < "1.8.0") {
[17:01:05.408]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:05.408]                               "", base::R.version$version.string), 
[17:01:05.408]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:05.408]                                 base::R.version$platform, 8 * 
[17:01:05.408]                                   base::.Machine$sizeof.pointer), 
[17:01:05.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:05.408]                                 "release", "version")], collapse = " "), 
[17:01:05.408]                               hostname = base::Sys.info()[["nodename"]])
[17:01:05.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:05.408]                               info)
[17:01:05.408]                             info <- base::paste(info, collapse = "; ")
[17:01:05.408]                             if (!has_future) {
[17:01:05.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:05.408]                                 info)
[17:01:05.408]                             }
[17:01:05.408]                             else {
[17:01:05.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:05.408]                                 info, version)
[17:01:05.408]                             }
[17:01:05.408]                             base::stop(msg)
[17:01:05.408]                           }
[17:01:05.408]                         })
[17:01:05.408]                       }
[17:01:05.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:05.408]                       base::options(mc.cores = 1L)
[17:01:05.408]                     }
[17:01:05.408]                     base::local({
[17:01:05.408]                       for (pkg in "future.apply") {
[17:01:05.408]                         base::loadNamespace(pkg)
[17:01:05.408]                         base::library(pkg, character.only = TRUE)
[17:01:05.408]                       }
[17:01:05.408]                     })
[17:01:05.408]                   }
[17:01:05.408]                   ...future.strategy.old <- future::plan("list")
[17:01:05.408]                   options(future.plan = NULL)
[17:01:05.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:05.408]                 }
[17:01:05.408]                 ...future.workdir <- getwd()
[17:01:05.408]             }
[17:01:05.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:05.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:05.408]         }
[17:01:05.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:05.408]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:05.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:05.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:05.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:05.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:05.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:05.408]             base::names(...future.oldOptions))
[17:01:05.408]     }
[17:01:05.408]     if (FALSE) {
[17:01:05.408]     }
[17:01:05.408]     else {
[17:01:05.408]         if (TRUE) {
[17:01:05.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:05.408]                 open = "w")
[17:01:05.408]         }
[17:01:05.408]         else {
[17:01:05.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:05.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:05.408]         }
[17:01:05.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:05.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:05.408]             base::sink(type = "output", split = FALSE)
[17:01:05.408]             base::close(...future.stdout)
[17:01:05.408]         }, add = TRUE)
[17:01:05.408]     }
[17:01:05.408]     ...future.frame <- base::sys.nframe()
[17:01:05.408]     ...future.conditions <- base::list()
[17:01:05.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:05.408]     if (FALSE) {
[17:01:05.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:05.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:05.408]     }
[17:01:05.408]     ...future.result <- base::tryCatch({
[17:01:05.408]         base::withCallingHandlers({
[17:01:05.408]             ...future.value <- base::withVisible(base::local({
[17:01:05.408]                 ...future.makeSendCondition <- base::local({
[17:01:05.408]                   sendCondition <- NULL
[17:01:05.408]                   function(frame = 1L) {
[17:01:05.408]                     if (is.function(sendCondition)) 
[17:01:05.408]                       return(sendCondition)
[17:01:05.408]                     ns <- getNamespace("parallel")
[17:01:05.408]                     if (exists("sendData", mode = "function", 
[17:01:05.408]                       envir = ns)) {
[17:01:05.408]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:05.408]                         envir = ns)
[17:01:05.408]                       envir <- sys.frame(frame)
[17:01:05.408]                       master <- NULL
[17:01:05.408]                       while (!identical(envir, .GlobalEnv) && 
[17:01:05.408]                         !identical(envir, emptyenv())) {
[17:01:05.408]                         if (exists("master", mode = "list", envir = envir, 
[17:01:05.408]                           inherits = FALSE)) {
[17:01:05.408]                           master <- get("master", mode = "list", 
[17:01:05.408]                             envir = envir, inherits = FALSE)
[17:01:05.408]                           if (inherits(master, c("SOCKnode", 
[17:01:05.408]                             "SOCK0node"))) {
[17:01:05.408]                             sendCondition <<- function(cond) {
[17:01:05.408]                               data <- list(type = "VALUE", value = cond, 
[17:01:05.408]                                 success = TRUE)
[17:01:05.408]                               parallel_sendData(master, data)
[17:01:05.408]                             }
[17:01:05.408]                             return(sendCondition)
[17:01:05.408]                           }
[17:01:05.408]                         }
[17:01:05.408]                         frame <- frame + 1L
[17:01:05.408]                         envir <- sys.frame(frame)
[17:01:05.408]                       }
[17:01:05.408]                     }
[17:01:05.408]                     sendCondition <<- function(cond) NULL
[17:01:05.408]                   }
[17:01:05.408]                 })
[17:01:05.408]                 withCallingHandlers({
[17:01:05.408]                   {
[17:01:05.408]                     do.call(function(...) {
[17:01:05.408]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.408]                       if (!identical(...future.globals.maxSize.org, 
[17:01:05.408]                         ...future.globals.maxSize)) {
[17:01:05.408]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.408]                         on.exit(options(oopts), add = TRUE)
[17:01:05.408]                       }
[17:01:05.408]                       {
[17:01:05.408]                         lapply(seq_along(...future.elements_ii), 
[17:01:05.408]                           FUN = function(jj) {
[17:01:05.408]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.408]                             ...future.FUN(...future.X_jj, ...)
[17:01:05.408]                           })
[17:01:05.408]                       }
[17:01:05.408]                     }, args = future.call.arguments)
[17:01:05.408]                   }
[17:01:05.408]                 }, immediateCondition = function(cond) {
[17:01:05.408]                   sendCondition <- ...future.makeSendCondition()
[17:01:05.408]                   sendCondition(cond)
[17:01:05.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.408]                   {
[17:01:05.408]                     inherits <- base::inherits
[17:01:05.408]                     invokeRestart <- base::invokeRestart
[17:01:05.408]                     is.null <- base::is.null
[17:01:05.408]                     muffled <- FALSE
[17:01:05.408]                     if (inherits(cond, "message")) {
[17:01:05.408]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:05.408]                       if (muffled) 
[17:01:05.408]                         invokeRestart("muffleMessage")
[17:01:05.408]                     }
[17:01:05.408]                     else if (inherits(cond, "warning")) {
[17:01:05.408]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:05.408]                       if (muffled) 
[17:01:05.408]                         invokeRestart("muffleWarning")
[17:01:05.408]                     }
[17:01:05.408]                     else if (inherits(cond, "condition")) {
[17:01:05.408]                       if (!is.null(pattern)) {
[17:01:05.408]                         computeRestarts <- base::computeRestarts
[17:01:05.408]                         grepl <- base::grepl
[17:01:05.408]                         restarts <- computeRestarts(cond)
[17:01:05.408]                         for (restart in restarts) {
[17:01:05.408]                           name <- restart$name
[17:01:05.408]                           if (is.null(name)) 
[17:01:05.408]                             next
[17:01:05.408]                           if (!grepl(pattern, name)) 
[17:01:05.408]                             next
[17:01:05.408]                           invokeRestart(restart)
[17:01:05.408]                           muffled <- TRUE
[17:01:05.408]                           break
[17:01:05.408]                         }
[17:01:05.408]                       }
[17:01:05.408]                     }
[17:01:05.408]                     invisible(muffled)
[17:01:05.408]                   }
[17:01:05.408]                   muffleCondition(cond)
[17:01:05.408]                 })
[17:01:05.408]             }))
[17:01:05.408]             future::FutureResult(value = ...future.value$value, 
[17:01:05.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.408]                   ...future.rng), globalenv = if (FALSE) 
[17:01:05.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:05.408]                     ...future.globalenv.names))
[17:01:05.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:05.408]         }, condition = base::local({
[17:01:05.408]             c <- base::c
[17:01:05.408]             inherits <- base::inherits
[17:01:05.408]             invokeRestart <- base::invokeRestart
[17:01:05.408]             length <- base::length
[17:01:05.408]             list <- base::list
[17:01:05.408]             seq.int <- base::seq.int
[17:01:05.408]             signalCondition <- base::signalCondition
[17:01:05.408]             sys.calls <- base::sys.calls
[17:01:05.408]             `[[` <- base::`[[`
[17:01:05.408]             `+` <- base::`+`
[17:01:05.408]             `<<-` <- base::`<<-`
[17:01:05.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:05.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:05.408]                   3L)]
[17:01:05.408]             }
[17:01:05.408]             function(cond) {
[17:01:05.408]                 is_error <- inherits(cond, "error")
[17:01:05.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:05.408]                   NULL)
[17:01:05.408]                 if (is_error) {
[17:01:05.408]                   sessionInformation <- function() {
[17:01:05.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:05.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:05.408]                       search = base::search(), system = base::Sys.info())
[17:01:05.408]                   }
[17:01:05.408]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:05.408]                     cond$call), session = sessionInformation(), 
[17:01:05.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:05.408]                   signalCondition(cond)
[17:01:05.408]                 }
[17:01:05.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:05.408]                 "immediateCondition"))) {
[17:01:05.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:05.408]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:05.408]                   if (TRUE && !signal) {
[17:01:05.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.408]                     {
[17:01:05.408]                       inherits <- base::inherits
[17:01:05.408]                       invokeRestart <- base::invokeRestart
[17:01:05.408]                       is.null <- base::is.null
[17:01:05.408]                       muffled <- FALSE
[17:01:05.408]                       if (inherits(cond, "message")) {
[17:01:05.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.408]                         if (muffled) 
[17:01:05.408]                           invokeRestart("muffleMessage")
[17:01:05.408]                       }
[17:01:05.408]                       else if (inherits(cond, "warning")) {
[17:01:05.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.408]                         if (muffled) 
[17:01:05.408]                           invokeRestart("muffleWarning")
[17:01:05.408]                       }
[17:01:05.408]                       else if (inherits(cond, "condition")) {
[17:01:05.408]                         if (!is.null(pattern)) {
[17:01:05.408]                           computeRestarts <- base::computeRestarts
[17:01:05.408]                           grepl <- base::grepl
[17:01:05.408]                           restarts <- computeRestarts(cond)
[17:01:05.408]                           for (restart in restarts) {
[17:01:05.408]                             name <- restart$name
[17:01:05.408]                             if (is.null(name)) 
[17:01:05.408]                               next
[17:01:05.408]                             if (!grepl(pattern, name)) 
[17:01:05.408]                               next
[17:01:05.408]                             invokeRestart(restart)
[17:01:05.408]                             muffled <- TRUE
[17:01:05.408]                             break
[17:01:05.408]                           }
[17:01:05.408]                         }
[17:01:05.408]                       }
[17:01:05.408]                       invisible(muffled)
[17:01:05.408]                     }
[17:01:05.408]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.408]                   }
[17:01:05.408]                 }
[17:01:05.408]                 else {
[17:01:05.408]                   if (TRUE) {
[17:01:05.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.408]                     {
[17:01:05.408]                       inherits <- base::inherits
[17:01:05.408]                       invokeRestart <- base::invokeRestart
[17:01:05.408]                       is.null <- base::is.null
[17:01:05.408]                       muffled <- FALSE
[17:01:05.408]                       if (inherits(cond, "message")) {
[17:01:05.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.408]                         if (muffled) 
[17:01:05.408]                           invokeRestart("muffleMessage")
[17:01:05.408]                       }
[17:01:05.408]                       else if (inherits(cond, "warning")) {
[17:01:05.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.408]                         if (muffled) 
[17:01:05.408]                           invokeRestart("muffleWarning")
[17:01:05.408]                       }
[17:01:05.408]                       else if (inherits(cond, "condition")) {
[17:01:05.408]                         if (!is.null(pattern)) {
[17:01:05.408]                           computeRestarts <- base::computeRestarts
[17:01:05.408]                           grepl <- base::grepl
[17:01:05.408]                           restarts <- computeRestarts(cond)
[17:01:05.408]                           for (restart in restarts) {
[17:01:05.408]                             name <- restart$name
[17:01:05.408]                             if (is.null(name)) 
[17:01:05.408]                               next
[17:01:05.408]                             if (!grepl(pattern, name)) 
[17:01:05.408]                               next
[17:01:05.408]                             invokeRestart(restart)
[17:01:05.408]                             muffled <- TRUE
[17:01:05.408]                             break
[17:01:05.408]                           }
[17:01:05.408]                         }
[17:01:05.408]                       }
[17:01:05.408]                       invisible(muffled)
[17:01:05.408]                     }
[17:01:05.408]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.408]                   }
[17:01:05.408]                 }
[17:01:05.408]             }
[17:01:05.408]         }))
[17:01:05.408]     }, error = function(ex) {
[17:01:05.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:05.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.408]                 ...future.rng), started = ...future.startTime, 
[17:01:05.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:05.408]             version = "1.8"), class = "FutureResult")
[17:01:05.408]     }, finally = {
[17:01:05.408]         if (!identical(...future.workdir, getwd())) 
[17:01:05.408]             setwd(...future.workdir)
[17:01:05.408]         {
[17:01:05.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:05.408]                 ...future.oldOptions$nwarnings <- NULL
[17:01:05.408]             }
[17:01:05.408]             base::options(...future.oldOptions)
[17:01:05.408]             if (.Platform$OS.type == "windows") {
[17:01:05.408]                 old_names <- names(...future.oldEnvVars)
[17:01:05.408]                 envs <- base::Sys.getenv()
[17:01:05.408]                 names <- names(envs)
[17:01:05.408]                 common <- intersect(names, old_names)
[17:01:05.408]                 added <- setdiff(names, old_names)
[17:01:05.408]                 removed <- setdiff(old_names, names)
[17:01:05.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:05.408]                   envs[common]]
[17:01:05.408]                 NAMES <- toupper(changed)
[17:01:05.408]                 args <- list()
[17:01:05.408]                 for (kk in seq_along(NAMES)) {
[17:01:05.408]                   name <- changed[[kk]]
[17:01:05.408]                   NAME <- NAMES[[kk]]
[17:01:05.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.408]                     next
[17:01:05.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.408]                 }
[17:01:05.408]                 NAMES <- toupper(added)
[17:01:05.408]                 for (kk in seq_along(NAMES)) {
[17:01:05.408]                   name <- added[[kk]]
[17:01:05.408]                   NAME <- NAMES[[kk]]
[17:01:05.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.408]                     next
[17:01:05.408]                   args[[name]] <- ""
[17:01:05.408]                 }
[17:01:05.408]                 NAMES <- toupper(removed)
[17:01:05.408]                 for (kk in seq_along(NAMES)) {
[17:01:05.408]                   name <- removed[[kk]]
[17:01:05.408]                   NAME <- NAMES[[kk]]
[17:01:05.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.408]                     next
[17:01:05.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.408]                 }
[17:01:05.408]                 if (length(args) > 0) 
[17:01:05.408]                   base::do.call(base::Sys.setenv, args = args)
[17:01:05.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:05.408]             }
[17:01:05.408]             else {
[17:01:05.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:05.408]             }
[17:01:05.408]             {
[17:01:05.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:05.408]                   0L) {
[17:01:05.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:05.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:05.408]                   base::options(opts)
[17:01:05.408]                 }
[17:01:05.408]                 {
[17:01:05.408]                   {
[17:01:05.408]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:05.408]                     NULL
[17:01:05.408]                   }
[17:01:05.408]                   options(future.plan = NULL)
[17:01:05.408]                   if (is.na(NA_character_)) 
[17:01:05.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:05.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:05.408]                     .init = FALSE)
[17:01:05.408]                 }
[17:01:05.408]             }
[17:01:05.408]         }
[17:01:05.408]     })
[17:01:05.408]     if (TRUE) {
[17:01:05.408]         base::sink(type = "output", split = FALSE)
[17:01:05.408]         if (TRUE) {
[17:01:05.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:05.408]         }
[17:01:05.408]         else {
[17:01:05.408]             ...future.result["stdout"] <- base::list(NULL)
[17:01:05.408]         }
[17:01:05.408]         base::close(...future.stdout)
[17:01:05.408]         ...future.stdout <- NULL
[17:01:05.408]     }
[17:01:05.408]     ...future.result$conditions <- ...future.conditions
[17:01:05.408]     ...future.result$finished <- base::Sys.time()
[17:01:05.408]     ...future.result
[17:01:05.408] }
[17:01:05.411] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[17:01:05.411] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:05.452] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:05.452] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:01:05.453] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:01:05.453] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:05.453] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:05.453] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:05.496] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:05.496] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:05.540] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:05.540] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:05.541] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.541] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:05.541] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:05.541] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:05.542] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.542] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:05.542] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:05.542] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:05.543] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:05.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.543] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[17:01:05.544] MultisessionFuture started
[17:01:05.544] - Launch lazy future ... done
[17:01:05.544] run() for ‘MultisessionFuture’ ... done
[17:01:05.544] Created future:
[17:01:05.545] MultisessionFuture:
[17:01:05.545] Label: ‘future_vapply-2’
[17:01:05.545] Expression:
[17:01:05.545] {
[17:01:05.545]     do.call(function(...) {
[17:01:05.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.545]             on.exit(options(oopts), add = TRUE)
[17:01:05.545]         }
[17:01:05.545]         {
[17:01:05.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.545]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.545]             })
[17:01:05.545]         }
[17:01:05.545]     }, args = future.call.arguments)
[17:01:05.545] }
[17:01:05.545] Lazy evaluation: FALSE
[17:01:05.545] Asynchronous evaluation: TRUE
[17:01:05.545] Local evaluation: TRUE
[17:01:05.545] Environment: R_GlobalEnv
[17:01:05.545] Capture standard output: TRUE
[17:01:05.545] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:05.545] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:05.545] Packages: 1 packages (‘future.apply’)
[17:01:05.545] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:05.545] Resolved: FALSE
[17:01:05.545] Value: <not collected>
[17:01:05.545] Conditions captured: <none>
[17:01:05.545] Early signaling: FALSE
[17:01:05.545] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:05.545] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.556] Chunk #2 of 2 ... DONE
[17:01:05.556] Launching 2 futures (chunks) ... DONE
[17:01:05.557] Resolving 2 futures (chunks) ...
[17:01:05.557] resolve() on list ...
[17:01:05.557]  recursive: 0
[17:01:05.557]  length: 2
[17:01:05.557] 
[17:01:05.557] Future #1
[17:01:05.557] result() for ClusterFuture ...
[17:01:05.557] - result already collected: FutureResult
[17:01:05.557] result() for ClusterFuture ... done
[17:01:05.557] result() for ClusterFuture ...
[17:01:05.557] - result already collected: FutureResult
[17:01:05.558] result() for ClusterFuture ... done
[17:01:05.558] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:05.558] - nx: 2
[17:01:05.558] - relay: TRUE
[17:01:05.558] - stdout: TRUE
[17:01:05.558] - signal: TRUE
[17:01:05.558] - resignal: FALSE
[17:01:05.558] - force: TRUE
[17:01:05.558] - relayed: [n=2] FALSE, FALSE
[17:01:05.558] - queued futures: [n=2] FALSE, FALSE
[17:01:05.558]  - until=1
[17:01:05.558]  - relaying element #1
[17:01:05.559] result() for ClusterFuture ...
[17:01:05.559] - result already collected: FutureResult
[17:01:05.559] result() for ClusterFuture ... done
[17:01:05.559] result() for ClusterFuture ...
[17:01:05.559] - result already collected: FutureResult
[17:01:05.559] result() for ClusterFuture ... done
[17:01:05.559] result() for ClusterFuture ...
[17:01:05.559] - result already collected: FutureResult
[17:01:05.559] result() for ClusterFuture ... done
[17:01:05.559] result() for ClusterFuture ...
[17:01:05.559] - result already collected: FutureResult
[17:01:05.560] result() for ClusterFuture ... done
[17:01:05.560] - relayed: [n=2] TRUE, FALSE
[17:01:05.560] - queued futures: [n=2] TRUE, FALSE
[17:01:05.560] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:05.560]  length: 1 (resolved future 1)
[17:01:05.589] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.589] - Validating connection of MultisessionFuture
[17:01:05.590] - received message: FutureResult
[17:01:05.590] - Received FutureResult
[17:01:05.590] - Erased future from FutureRegistry
[17:01:05.590] result() for ClusterFuture ...
[17:01:05.590] - result already collected: FutureResult
[17:01:05.590] result() for ClusterFuture ... done
[17:01:05.590] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.590] Future #2
[17:01:05.590] result() for ClusterFuture ...
[17:01:05.590] - result already collected: FutureResult
[17:01:05.591] result() for ClusterFuture ... done
[17:01:05.591] result() for ClusterFuture ...
[17:01:05.591] - result already collected: FutureResult
[17:01:05.591] result() for ClusterFuture ... done
[17:01:05.591] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:05.591] - nx: 2
[17:01:05.591] - relay: TRUE
[17:01:05.591] - stdout: TRUE
[17:01:05.591] - signal: TRUE
[17:01:05.591] - resignal: FALSE
[17:01:05.591] - force: TRUE
[17:01:05.592] - relayed: [n=2] TRUE, FALSE
[17:01:05.592] - queued futures: [n=2] TRUE, FALSE
[17:01:05.592]  - until=2
[17:01:05.592]  - relaying element #2
[17:01:05.592] result() for ClusterFuture ...
[17:01:05.592] - result already collected: FutureResult
[17:01:05.592] result() for ClusterFuture ... done
[17:01:05.592] result() for ClusterFuture ...
[17:01:05.592] - result already collected: FutureResult
[17:01:05.592] result() for ClusterFuture ... done
[17:01:05.592] result() for ClusterFuture ...
[17:01:05.593] - result already collected: FutureResult
[17:01:05.593] result() for ClusterFuture ... done
[17:01:05.593] result() for ClusterFuture ...
[17:01:05.593] - result already collected: FutureResult
[17:01:05.593] result() for ClusterFuture ... done
[17:01:05.593] - relayed: [n=2] TRUE, TRUE
[17:01:05.593] - queued futures: [n=2] TRUE, TRUE
[17:01:05.593] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:05.593]  length: 0 (resolved future 2)
[17:01:05.593] Relaying remaining futures
[17:01:05.593] signalConditionsASAP(NULL, pos=0) ...
[17:01:05.593] - nx: 2
[17:01:05.594] - relay: TRUE
[17:01:05.594] - stdout: TRUE
[17:01:05.594] - signal: TRUE
[17:01:05.594] - resignal: FALSE
[17:01:05.594] - force: TRUE
[17:01:05.594] - relayed: [n=2] TRUE, TRUE
[17:01:05.594] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:05.594] - relayed: [n=2] TRUE, TRUE
[17:01:05.594] - queued futures: [n=2] TRUE, TRUE
[17:01:05.594] signalConditionsASAP(NULL, pos=0) ... done
[17:01:05.594] resolve() on list ... DONE
[17:01:05.594] result() for ClusterFuture ...
[17:01:05.595] - result already collected: FutureResult
[17:01:05.595] result() for ClusterFuture ... done
[17:01:05.595] result() for ClusterFuture ...
[17:01:05.595] - result already collected: FutureResult
[17:01:05.595] result() for ClusterFuture ... done
[17:01:05.595] result() for ClusterFuture ...
[17:01:05.595] - result already collected: FutureResult
[17:01:05.595] result() for ClusterFuture ... done
[17:01:05.595] result() for ClusterFuture ...
[17:01:05.595] - result already collected: FutureResult
[17:01:05.595] result() for ClusterFuture ... done
[17:01:05.596]  - Number of value chunks collected: 2
[17:01:05.596] Resolving 2 futures (chunks) ... DONE
[17:01:05.596] Reducing values from 2 chunks ...
[17:01:05.596]  - Number of values collected after concatenation: 10
[17:01:05.596]  - Number of values expected: 10
[17:01:05.596] Reducing values from 2 chunks ... DONE
[17:01:05.596] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:01:05.597] future_lapply() ...
[17:01:05.602] Number of chunks: 2
[17:01:05.602] getGlobalsAndPackagesXApply() ...
[17:01:05.602]  - future.globals: TRUE
[17:01:05.603] getGlobalsAndPackages() ...
[17:01:05.603] Searching for globals...
[17:01:05.608] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:01:05.608] Searching for globals ... DONE
[17:01:05.608] Resolving globals: FALSE
[17:01:05.609] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:01:05.609] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:05.610] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:05.610] - packages: [1] ‘future.apply’
[17:01:05.610] getGlobalsAndPackages() ... DONE
[17:01:05.610]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:05.610]  - needed namespaces: [n=1] ‘future.apply’
[17:01:05.610] Finding globals ... DONE
[17:01:05.610]  - use_args: TRUE
[17:01:05.610]  - Getting '...' globals ...
[17:01:05.611] resolve() on list ...
[17:01:05.611]  recursive: 0
[17:01:05.611]  length: 1
[17:01:05.611]  elements: ‘...’
[17:01:05.611]  length: 0 (resolved future 1)
[17:01:05.611] resolve() on list ... DONE
[17:01:05.611]    - '...' content: [n=0] 
[17:01:05.611] List of 1
[17:01:05.611]  $ ...: list()
[17:01:05.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:05.611]  - attr(*, "where")=List of 1
[17:01:05.611]   ..$ ...:<environment: 0x55aade314650> 
[17:01:05.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:05.611]  - attr(*, "resolved")= logi TRUE
[17:01:05.611]  - attr(*, "total_size")= num NA
[17:01:05.614]  - Getting '...' globals ... DONE
[17:01:05.614] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:05.614] List of 8
[17:01:05.614]  $ ...future.FUN:function (x, ...)  
[17:01:05.614]  $ x_FUN        :function (x)  
[17:01:05.614]  $ times        : int 0
[17:01:05.614]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:05.614]  $ stop_if_not  :function (...)  
[17:01:05.614]  $ dim          : NULL
[17:01:05.614]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:05.614]  $ ...          : list()
[17:01:05.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:05.614]  - attr(*, "where")=List of 8
[17:01:05.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:05.614]   ..$ ...          :<environment: 0x55aade314650> 
[17:01:05.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:05.614]  - attr(*, "resolved")= logi FALSE
[17:01:05.614]  - attr(*, "total_size")= num 95400
[17:01:05.619] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:05.619] getGlobalsAndPackagesXApply() ... DONE
[17:01:05.619] Number of futures (= number of chunks): 2
[17:01:05.619] Launching 2 futures (chunks) ...
[17:01:05.620] Chunk #1 of 2 ...
[17:01:05.620]  - Finding globals in 'X' for chunk #1 ...
[17:01:05.620] getGlobalsAndPackages() ...
[17:01:05.620] Searching for globals...
[17:01:05.620] 
[17:01:05.620] Searching for globals ... DONE
[17:01:05.620] - globals: [0] <none>
[17:01:05.620] getGlobalsAndPackages() ... DONE
[17:01:05.621]    + additional globals found: [n=0] 
[17:01:05.621]    + additional namespaces needed: [n=0] 
[17:01:05.621]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:05.621]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:05.621]  - seeds: <none>
[17:01:05.621]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.621] getGlobalsAndPackages() ...
[17:01:05.621] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.621] Resolving globals: FALSE
[17:01:05.621] Tweak future expression to call with '...' arguments ...
[17:01:05.622] {
[17:01:05.622]     do.call(function(...) {
[17:01:05.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.622]             on.exit(options(oopts), add = TRUE)
[17:01:05.622]         }
[17:01:05.622]         {
[17:01:05.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.622]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.622]             })
[17:01:05.622]         }
[17:01:05.622]     }, args = future.call.arguments)
[17:01:05.622] }
[17:01:05.622] Tweak future expression to call with '...' arguments ... DONE
[17:01:05.622] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.622] - packages: [1] ‘future.apply’
[17:01:05.623] getGlobalsAndPackages() ... DONE
[17:01:05.623] run() for ‘Future’ ...
[17:01:05.623] - state: ‘created’
[17:01:05.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:05.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:05.637]   - Field: ‘node’
[17:01:05.637]   - Field: ‘label’
[17:01:05.638]   - Field: ‘local’
[17:01:05.638]   - Field: ‘owner’
[17:01:05.638]   - Field: ‘envir’
[17:01:05.638]   - Field: ‘workers’
[17:01:05.638]   - Field: ‘packages’
[17:01:05.638]   - Field: ‘gc’
[17:01:05.638]   - Field: ‘conditions’
[17:01:05.638]   - Field: ‘persistent’
[17:01:05.638]   - Field: ‘expr’
[17:01:05.638]   - Field: ‘uuid’
[17:01:05.638]   - Field: ‘seed’
[17:01:05.639]   - Field: ‘version’
[17:01:05.639]   - Field: ‘result’
[17:01:05.639]   - Field: ‘asynchronous’
[17:01:05.639]   - Field: ‘calls’
[17:01:05.639]   - Field: ‘globals’
[17:01:05.639]   - Field: ‘stdout’
[17:01:05.639]   - Field: ‘earlySignal’
[17:01:05.639]   - Field: ‘lazy’
[17:01:05.639]   - Field: ‘state’
[17:01:05.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:05.639] - Launch lazy future ...
[17:01:05.640] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:05.640] Packages needed by future strategies (n = 0): <none>
[17:01:05.640] {
[17:01:05.640]     {
[17:01:05.640]         {
[17:01:05.640]             ...future.startTime <- base::Sys.time()
[17:01:05.640]             {
[17:01:05.640]                 {
[17:01:05.640]                   {
[17:01:05.640]                     {
[17:01:05.640]                       {
[17:01:05.640]                         base::local({
[17:01:05.640]                           has_future <- base::requireNamespace("future", 
[17:01:05.640]                             quietly = TRUE)
[17:01:05.640]                           if (has_future) {
[17:01:05.640]                             ns <- base::getNamespace("future")
[17:01:05.640]                             version <- ns[[".package"]][["version"]]
[17:01:05.640]                             if (is.null(version)) 
[17:01:05.640]                               version <- utils::packageVersion("future")
[17:01:05.640]                           }
[17:01:05.640]                           else {
[17:01:05.640]                             version <- NULL
[17:01:05.640]                           }
[17:01:05.640]                           if (!has_future || version < "1.8.0") {
[17:01:05.640]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:05.640]                               "", base::R.version$version.string), 
[17:01:05.640]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:05.640]                                 base::R.version$platform, 8 * 
[17:01:05.640]                                   base::.Machine$sizeof.pointer), 
[17:01:05.640]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:05.640]                                 "release", "version")], collapse = " "), 
[17:01:05.640]                               hostname = base::Sys.info()[["nodename"]])
[17:01:05.640]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:05.640]                               info)
[17:01:05.640]                             info <- base::paste(info, collapse = "; ")
[17:01:05.640]                             if (!has_future) {
[17:01:05.640]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:05.640]                                 info)
[17:01:05.640]                             }
[17:01:05.640]                             else {
[17:01:05.640]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:05.640]                                 info, version)
[17:01:05.640]                             }
[17:01:05.640]                             base::stop(msg)
[17:01:05.640]                           }
[17:01:05.640]                         })
[17:01:05.640]                       }
[17:01:05.640]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:05.640]                       base::options(mc.cores = 1L)
[17:01:05.640]                     }
[17:01:05.640]                     base::local({
[17:01:05.640]                       for (pkg in "future.apply") {
[17:01:05.640]                         base::loadNamespace(pkg)
[17:01:05.640]                         base::library(pkg, character.only = TRUE)
[17:01:05.640]                       }
[17:01:05.640]                     })
[17:01:05.640]                   }
[17:01:05.640]                   ...future.strategy.old <- future::plan("list")
[17:01:05.640]                   options(future.plan = NULL)
[17:01:05.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:05.640]                 }
[17:01:05.640]                 ...future.workdir <- getwd()
[17:01:05.640]             }
[17:01:05.640]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:05.640]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:05.640]         }
[17:01:05.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:05.640]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:05.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:05.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:05.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:05.640]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:05.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:05.640]             base::names(...future.oldOptions))
[17:01:05.640]     }
[17:01:05.640]     if (FALSE) {
[17:01:05.640]     }
[17:01:05.640]     else {
[17:01:05.640]         if (TRUE) {
[17:01:05.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:05.640]                 open = "w")
[17:01:05.640]         }
[17:01:05.640]         else {
[17:01:05.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:05.640]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:05.640]         }
[17:01:05.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:05.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:05.640]             base::sink(type = "output", split = FALSE)
[17:01:05.640]             base::close(...future.stdout)
[17:01:05.640]         }, add = TRUE)
[17:01:05.640]     }
[17:01:05.640]     ...future.frame <- base::sys.nframe()
[17:01:05.640]     ...future.conditions <- base::list()
[17:01:05.640]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:05.640]     if (FALSE) {
[17:01:05.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:05.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:05.640]     }
[17:01:05.640]     ...future.result <- base::tryCatch({
[17:01:05.640]         base::withCallingHandlers({
[17:01:05.640]             ...future.value <- base::withVisible(base::local({
[17:01:05.640]                 ...future.makeSendCondition <- base::local({
[17:01:05.640]                   sendCondition <- NULL
[17:01:05.640]                   function(frame = 1L) {
[17:01:05.640]                     if (is.function(sendCondition)) 
[17:01:05.640]                       return(sendCondition)
[17:01:05.640]                     ns <- getNamespace("parallel")
[17:01:05.640]                     if (exists("sendData", mode = "function", 
[17:01:05.640]                       envir = ns)) {
[17:01:05.640]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:05.640]                         envir = ns)
[17:01:05.640]                       envir <- sys.frame(frame)
[17:01:05.640]                       master <- NULL
[17:01:05.640]                       while (!identical(envir, .GlobalEnv) && 
[17:01:05.640]                         !identical(envir, emptyenv())) {
[17:01:05.640]                         if (exists("master", mode = "list", envir = envir, 
[17:01:05.640]                           inherits = FALSE)) {
[17:01:05.640]                           master <- get("master", mode = "list", 
[17:01:05.640]                             envir = envir, inherits = FALSE)
[17:01:05.640]                           if (inherits(master, c("SOCKnode", 
[17:01:05.640]                             "SOCK0node"))) {
[17:01:05.640]                             sendCondition <<- function(cond) {
[17:01:05.640]                               data <- list(type = "VALUE", value = cond, 
[17:01:05.640]                                 success = TRUE)
[17:01:05.640]                               parallel_sendData(master, data)
[17:01:05.640]                             }
[17:01:05.640]                             return(sendCondition)
[17:01:05.640]                           }
[17:01:05.640]                         }
[17:01:05.640]                         frame <- frame + 1L
[17:01:05.640]                         envir <- sys.frame(frame)
[17:01:05.640]                       }
[17:01:05.640]                     }
[17:01:05.640]                     sendCondition <<- function(cond) NULL
[17:01:05.640]                   }
[17:01:05.640]                 })
[17:01:05.640]                 withCallingHandlers({
[17:01:05.640]                   {
[17:01:05.640]                     do.call(function(...) {
[17:01:05.640]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.640]                       if (!identical(...future.globals.maxSize.org, 
[17:01:05.640]                         ...future.globals.maxSize)) {
[17:01:05.640]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.640]                         on.exit(options(oopts), add = TRUE)
[17:01:05.640]                       }
[17:01:05.640]                       {
[17:01:05.640]                         lapply(seq_along(...future.elements_ii), 
[17:01:05.640]                           FUN = function(jj) {
[17:01:05.640]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.640]                             ...future.FUN(...future.X_jj, ...)
[17:01:05.640]                           })
[17:01:05.640]                       }
[17:01:05.640]                     }, args = future.call.arguments)
[17:01:05.640]                   }
[17:01:05.640]                 }, immediateCondition = function(cond) {
[17:01:05.640]                   sendCondition <- ...future.makeSendCondition()
[17:01:05.640]                   sendCondition(cond)
[17:01:05.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.640]                   {
[17:01:05.640]                     inherits <- base::inherits
[17:01:05.640]                     invokeRestart <- base::invokeRestart
[17:01:05.640]                     is.null <- base::is.null
[17:01:05.640]                     muffled <- FALSE
[17:01:05.640]                     if (inherits(cond, "message")) {
[17:01:05.640]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:05.640]                       if (muffled) 
[17:01:05.640]                         invokeRestart("muffleMessage")
[17:01:05.640]                     }
[17:01:05.640]                     else if (inherits(cond, "warning")) {
[17:01:05.640]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:05.640]                       if (muffled) 
[17:01:05.640]                         invokeRestart("muffleWarning")
[17:01:05.640]                     }
[17:01:05.640]                     else if (inherits(cond, "condition")) {
[17:01:05.640]                       if (!is.null(pattern)) {
[17:01:05.640]                         computeRestarts <- base::computeRestarts
[17:01:05.640]                         grepl <- base::grepl
[17:01:05.640]                         restarts <- computeRestarts(cond)
[17:01:05.640]                         for (restart in restarts) {
[17:01:05.640]                           name <- restart$name
[17:01:05.640]                           if (is.null(name)) 
[17:01:05.640]                             next
[17:01:05.640]                           if (!grepl(pattern, name)) 
[17:01:05.640]                             next
[17:01:05.640]                           invokeRestart(restart)
[17:01:05.640]                           muffled <- TRUE
[17:01:05.640]                           break
[17:01:05.640]                         }
[17:01:05.640]                       }
[17:01:05.640]                     }
[17:01:05.640]                     invisible(muffled)
[17:01:05.640]                   }
[17:01:05.640]                   muffleCondition(cond)
[17:01:05.640]                 })
[17:01:05.640]             }))
[17:01:05.640]             future::FutureResult(value = ...future.value$value, 
[17:01:05.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.640]                   ...future.rng), globalenv = if (FALSE) 
[17:01:05.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:05.640]                     ...future.globalenv.names))
[17:01:05.640]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:05.640]         }, condition = base::local({
[17:01:05.640]             c <- base::c
[17:01:05.640]             inherits <- base::inherits
[17:01:05.640]             invokeRestart <- base::invokeRestart
[17:01:05.640]             length <- base::length
[17:01:05.640]             list <- base::list
[17:01:05.640]             seq.int <- base::seq.int
[17:01:05.640]             signalCondition <- base::signalCondition
[17:01:05.640]             sys.calls <- base::sys.calls
[17:01:05.640]             `[[` <- base::`[[`
[17:01:05.640]             `+` <- base::`+`
[17:01:05.640]             `<<-` <- base::`<<-`
[17:01:05.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:05.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:05.640]                   3L)]
[17:01:05.640]             }
[17:01:05.640]             function(cond) {
[17:01:05.640]                 is_error <- inherits(cond, "error")
[17:01:05.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:05.640]                   NULL)
[17:01:05.640]                 if (is_error) {
[17:01:05.640]                   sessionInformation <- function() {
[17:01:05.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:05.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:05.640]                       search = base::search(), system = base::Sys.info())
[17:01:05.640]                   }
[17:01:05.640]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:05.640]                     cond$call), session = sessionInformation(), 
[17:01:05.640]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:05.640]                   signalCondition(cond)
[17:01:05.640]                 }
[17:01:05.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:05.640]                 "immediateCondition"))) {
[17:01:05.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:05.640]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:05.640]                   if (TRUE && !signal) {
[17:01:05.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.640]                     {
[17:01:05.640]                       inherits <- base::inherits
[17:01:05.640]                       invokeRestart <- base::invokeRestart
[17:01:05.640]                       is.null <- base::is.null
[17:01:05.640]                       muffled <- FALSE
[17:01:05.640]                       if (inherits(cond, "message")) {
[17:01:05.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.640]                         if (muffled) 
[17:01:05.640]                           invokeRestart("muffleMessage")
[17:01:05.640]                       }
[17:01:05.640]                       else if (inherits(cond, "warning")) {
[17:01:05.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.640]                         if (muffled) 
[17:01:05.640]                           invokeRestart("muffleWarning")
[17:01:05.640]                       }
[17:01:05.640]                       else if (inherits(cond, "condition")) {
[17:01:05.640]                         if (!is.null(pattern)) {
[17:01:05.640]                           computeRestarts <- base::computeRestarts
[17:01:05.640]                           grepl <- base::grepl
[17:01:05.640]                           restarts <- computeRestarts(cond)
[17:01:05.640]                           for (restart in restarts) {
[17:01:05.640]                             name <- restart$name
[17:01:05.640]                             if (is.null(name)) 
[17:01:05.640]                               next
[17:01:05.640]                             if (!grepl(pattern, name)) 
[17:01:05.640]                               next
[17:01:05.640]                             invokeRestart(restart)
[17:01:05.640]                             muffled <- TRUE
[17:01:05.640]                             break
[17:01:05.640]                           }
[17:01:05.640]                         }
[17:01:05.640]                       }
[17:01:05.640]                       invisible(muffled)
[17:01:05.640]                     }
[17:01:05.640]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.640]                   }
[17:01:05.640]                 }
[17:01:05.640]                 else {
[17:01:05.640]                   if (TRUE) {
[17:01:05.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.640]                     {
[17:01:05.640]                       inherits <- base::inherits
[17:01:05.640]                       invokeRestart <- base::invokeRestart
[17:01:05.640]                       is.null <- base::is.null
[17:01:05.640]                       muffled <- FALSE
[17:01:05.640]                       if (inherits(cond, "message")) {
[17:01:05.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.640]                         if (muffled) 
[17:01:05.640]                           invokeRestart("muffleMessage")
[17:01:05.640]                       }
[17:01:05.640]                       else if (inherits(cond, "warning")) {
[17:01:05.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.640]                         if (muffled) 
[17:01:05.640]                           invokeRestart("muffleWarning")
[17:01:05.640]                       }
[17:01:05.640]                       else if (inherits(cond, "condition")) {
[17:01:05.640]                         if (!is.null(pattern)) {
[17:01:05.640]                           computeRestarts <- base::computeRestarts
[17:01:05.640]                           grepl <- base::grepl
[17:01:05.640]                           restarts <- computeRestarts(cond)
[17:01:05.640]                           for (restart in restarts) {
[17:01:05.640]                             name <- restart$name
[17:01:05.640]                             if (is.null(name)) 
[17:01:05.640]                               next
[17:01:05.640]                             if (!grepl(pattern, name)) 
[17:01:05.640]                               next
[17:01:05.640]                             invokeRestart(restart)
[17:01:05.640]                             muffled <- TRUE
[17:01:05.640]                             break
[17:01:05.640]                           }
[17:01:05.640]                         }
[17:01:05.640]                       }
[17:01:05.640]                       invisible(muffled)
[17:01:05.640]                     }
[17:01:05.640]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.640]                   }
[17:01:05.640]                 }
[17:01:05.640]             }
[17:01:05.640]         }))
[17:01:05.640]     }, error = function(ex) {
[17:01:05.640]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:05.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.640]                 ...future.rng), started = ...future.startTime, 
[17:01:05.640]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:05.640]             version = "1.8"), class = "FutureResult")
[17:01:05.640]     }, finally = {
[17:01:05.640]         if (!identical(...future.workdir, getwd())) 
[17:01:05.640]             setwd(...future.workdir)
[17:01:05.640]         {
[17:01:05.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:05.640]                 ...future.oldOptions$nwarnings <- NULL
[17:01:05.640]             }
[17:01:05.640]             base::options(...future.oldOptions)
[17:01:05.640]             if (.Platform$OS.type == "windows") {
[17:01:05.640]                 old_names <- names(...future.oldEnvVars)
[17:01:05.640]                 envs <- base::Sys.getenv()
[17:01:05.640]                 names <- names(envs)
[17:01:05.640]                 common <- intersect(names, old_names)
[17:01:05.640]                 added <- setdiff(names, old_names)
[17:01:05.640]                 removed <- setdiff(old_names, names)
[17:01:05.640]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:05.640]                   envs[common]]
[17:01:05.640]                 NAMES <- toupper(changed)
[17:01:05.640]                 args <- list()
[17:01:05.640]                 for (kk in seq_along(NAMES)) {
[17:01:05.640]                   name <- changed[[kk]]
[17:01:05.640]                   NAME <- NAMES[[kk]]
[17:01:05.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.640]                     next
[17:01:05.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.640]                 }
[17:01:05.640]                 NAMES <- toupper(added)
[17:01:05.640]                 for (kk in seq_along(NAMES)) {
[17:01:05.640]                   name <- added[[kk]]
[17:01:05.640]                   NAME <- NAMES[[kk]]
[17:01:05.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.640]                     next
[17:01:05.640]                   args[[name]] <- ""
[17:01:05.640]                 }
[17:01:05.640]                 NAMES <- toupper(removed)
[17:01:05.640]                 for (kk in seq_along(NAMES)) {
[17:01:05.640]                   name <- removed[[kk]]
[17:01:05.640]                   NAME <- NAMES[[kk]]
[17:01:05.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.640]                     next
[17:01:05.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.640]                 }
[17:01:05.640]                 if (length(args) > 0) 
[17:01:05.640]                   base::do.call(base::Sys.setenv, args = args)
[17:01:05.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:05.640]             }
[17:01:05.640]             else {
[17:01:05.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:05.640]             }
[17:01:05.640]             {
[17:01:05.640]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:05.640]                   0L) {
[17:01:05.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:05.640]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:05.640]                   base::options(opts)
[17:01:05.640]                 }
[17:01:05.640]                 {
[17:01:05.640]                   {
[17:01:05.640]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:05.640]                     NULL
[17:01:05.640]                   }
[17:01:05.640]                   options(future.plan = NULL)
[17:01:05.640]                   if (is.na(NA_character_)) 
[17:01:05.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:05.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:05.640]                     .init = FALSE)
[17:01:05.640]                 }
[17:01:05.640]             }
[17:01:05.640]         }
[17:01:05.640]     })
[17:01:05.640]     if (TRUE) {
[17:01:05.640]         base::sink(type = "output", split = FALSE)
[17:01:05.640]         if (TRUE) {
[17:01:05.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:05.640]         }
[17:01:05.640]         else {
[17:01:05.640]             ...future.result["stdout"] <- base::list(NULL)
[17:01:05.640]         }
[17:01:05.640]         base::close(...future.stdout)
[17:01:05.640]         ...future.stdout <- NULL
[17:01:05.640]     }
[17:01:05.640]     ...future.result$conditions <- ...future.conditions
[17:01:05.640]     ...future.result$finished <- base::Sys.time()
[17:01:05.640]     ...future.result
[17:01:05.640] }
[17:01:05.643] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[17:01:05.643] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:05.688] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:05.688] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:01:05.689] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:01:05.689] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:05.689] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:05.689] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:05.732] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:05.732] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:05.776] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:05.776] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:05.776] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.777] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:01:05.777] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:01:05.777] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:05.778] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.778] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:05.778] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:05.778] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:05.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:05.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:05.779] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[17:01:05.780] MultisessionFuture started
[17:01:05.780] - Launch lazy future ... done
[17:01:05.780] run() for ‘MultisessionFuture’ ... done
[17:01:05.780] Created future:
[17:01:05.780] MultisessionFuture:
[17:01:05.780] Label: ‘future_vapply-1’
[17:01:05.780] Expression:
[17:01:05.780] {
[17:01:05.780]     do.call(function(...) {
[17:01:05.780]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.780]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.780]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.780]             on.exit(options(oopts), add = TRUE)
[17:01:05.780]         }
[17:01:05.780]         {
[17:01:05.780]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.780]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.780]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.780]             })
[17:01:05.780]         }
[17:01:05.780]     }, args = future.call.arguments)
[17:01:05.780] }
[17:01:05.780] Lazy evaluation: FALSE
[17:01:05.780] Asynchronous evaluation: TRUE
[17:01:05.780] Local evaluation: TRUE
[17:01:05.780] Environment: R_GlobalEnv
[17:01:05.780] Capture standard output: TRUE
[17:01:05.780] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:05.780] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:05.780] Packages: 1 packages (‘future.apply’)
[17:01:05.780] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:05.780] Resolved: FALSE
[17:01:05.780] Value: <not collected>
[17:01:05.780] Conditions captured: <none>
[17:01:05.780] Early signaling: FALSE
[17:01:05.780] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:05.780] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.792] Chunk #1 of 2 ... DONE
[17:01:05.792] Chunk #2 of 2 ...
[17:01:05.792]  - Finding globals in 'X' for chunk #2 ...
[17:01:05.792] getGlobalsAndPackages() ...
[17:01:05.793] Searching for globals...
[17:01:05.793] 
[17:01:05.793] Searching for globals ... DONE
[17:01:05.793] - globals: [0] <none>
[17:01:05.793] getGlobalsAndPackages() ... DONE
[17:01:05.793]    + additional globals found: [n=0] 
[17:01:05.793]    + additional namespaces needed: [n=0] 
[17:01:05.793]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:05.793]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:05.794]  - seeds: <none>
[17:01:05.794]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.794] getGlobalsAndPackages() ...
[17:01:05.794] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.794] Resolving globals: FALSE
[17:01:05.794] Tweak future expression to call with '...' arguments ...
[17:01:05.794] {
[17:01:05.794]     do.call(function(...) {
[17:01:05.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.794]             on.exit(options(oopts), add = TRUE)
[17:01:05.794]         }
[17:01:05.794]         {
[17:01:05.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.794]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.794]             })
[17:01:05.794]         }
[17:01:05.794]     }, args = future.call.arguments)
[17:01:05.794] }
[17:01:05.794] Tweak future expression to call with '...' arguments ... DONE
[17:01:05.795] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:05.795] - packages: [1] ‘future.apply’
[17:01:05.795] getGlobalsAndPackages() ... DONE
[17:01:05.796] run() for ‘Future’ ...
[17:01:05.796] - state: ‘created’
[17:01:05.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:05.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:05.810]   - Field: ‘node’
[17:01:05.811]   - Field: ‘label’
[17:01:05.811]   - Field: ‘local’
[17:01:05.811]   - Field: ‘owner’
[17:01:05.811]   - Field: ‘envir’
[17:01:05.811]   - Field: ‘workers’
[17:01:05.811]   - Field: ‘packages’
[17:01:05.811]   - Field: ‘gc’
[17:01:05.811]   - Field: ‘conditions’
[17:01:05.811]   - Field: ‘persistent’
[17:01:05.811]   - Field: ‘expr’
[17:01:05.812]   - Field: ‘uuid’
[17:01:05.812]   - Field: ‘seed’
[17:01:05.812]   - Field: ‘version’
[17:01:05.812]   - Field: ‘result’
[17:01:05.812]   - Field: ‘asynchronous’
[17:01:05.812]   - Field: ‘calls’
[17:01:05.812]   - Field: ‘globals’
[17:01:05.812]   - Field: ‘stdout’
[17:01:05.812]   - Field: ‘earlySignal’
[17:01:05.812]   - Field: ‘lazy’
[17:01:05.812]   - Field: ‘state’
[17:01:05.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:05.813] - Launch lazy future ...
[17:01:05.813] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:05.813] Packages needed by future strategies (n = 0): <none>
[17:01:05.813] {
[17:01:05.813]     {
[17:01:05.813]         {
[17:01:05.813]             ...future.startTime <- base::Sys.time()
[17:01:05.813]             {
[17:01:05.813]                 {
[17:01:05.813]                   {
[17:01:05.813]                     {
[17:01:05.813]                       {
[17:01:05.813]                         base::local({
[17:01:05.813]                           has_future <- base::requireNamespace("future", 
[17:01:05.813]                             quietly = TRUE)
[17:01:05.813]                           if (has_future) {
[17:01:05.813]                             ns <- base::getNamespace("future")
[17:01:05.813]                             version <- ns[[".package"]][["version"]]
[17:01:05.813]                             if (is.null(version)) 
[17:01:05.813]                               version <- utils::packageVersion("future")
[17:01:05.813]                           }
[17:01:05.813]                           else {
[17:01:05.813]                             version <- NULL
[17:01:05.813]                           }
[17:01:05.813]                           if (!has_future || version < "1.8.0") {
[17:01:05.813]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:05.813]                               "", base::R.version$version.string), 
[17:01:05.813]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:05.813]                                 base::R.version$platform, 8 * 
[17:01:05.813]                                   base::.Machine$sizeof.pointer), 
[17:01:05.813]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:05.813]                                 "release", "version")], collapse = " "), 
[17:01:05.813]                               hostname = base::Sys.info()[["nodename"]])
[17:01:05.813]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:05.813]                               info)
[17:01:05.813]                             info <- base::paste(info, collapse = "; ")
[17:01:05.813]                             if (!has_future) {
[17:01:05.813]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:05.813]                                 info)
[17:01:05.813]                             }
[17:01:05.813]                             else {
[17:01:05.813]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:05.813]                                 info, version)
[17:01:05.813]                             }
[17:01:05.813]                             base::stop(msg)
[17:01:05.813]                           }
[17:01:05.813]                         })
[17:01:05.813]                       }
[17:01:05.813]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:05.813]                       base::options(mc.cores = 1L)
[17:01:05.813]                     }
[17:01:05.813]                     base::local({
[17:01:05.813]                       for (pkg in "future.apply") {
[17:01:05.813]                         base::loadNamespace(pkg)
[17:01:05.813]                         base::library(pkg, character.only = TRUE)
[17:01:05.813]                       }
[17:01:05.813]                     })
[17:01:05.813]                   }
[17:01:05.813]                   ...future.strategy.old <- future::plan("list")
[17:01:05.813]                   options(future.plan = NULL)
[17:01:05.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:05.813]                 }
[17:01:05.813]                 ...future.workdir <- getwd()
[17:01:05.813]             }
[17:01:05.813]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:05.813]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:05.813]         }
[17:01:05.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:05.813]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:05.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:05.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:05.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:05.813]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:05.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:05.813]             base::names(...future.oldOptions))
[17:01:05.813]     }
[17:01:05.813]     if (FALSE) {
[17:01:05.813]     }
[17:01:05.813]     else {
[17:01:05.813]         if (TRUE) {
[17:01:05.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:05.813]                 open = "w")
[17:01:05.813]         }
[17:01:05.813]         else {
[17:01:05.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:05.813]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:05.813]         }
[17:01:05.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:05.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:05.813]             base::sink(type = "output", split = FALSE)
[17:01:05.813]             base::close(...future.stdout)
[17:01:05.813]         }, add = TRUE)
[17:01:05.813]     }
[17:01:05.813]     ...future.frame <- base::sys.nframe()
[17:01:05.813]     ...future.conditions <- base::list()
[17:01:05.813]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:05.813]     if (FALSE) {
[17:01:05.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:05.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:05.813]     }
[17:01:05.813]     ...future.result <- base::tryCatch({
[17:01:05.813]         base::withCallingHandlers({
[17:01:05.813]             ...future.value <- base::withVisible(base::local({
[17:01:05.813]                 ...future.makeSendCondition <- base::local({
[17:01:05.813]                   sendCondition <- NULL
[17:01:05.813]                   function(frame = 1L) {
[17:01:05.813]                     if (is.function(sendCondition)) 
[17:01:05.813]                       return(sendCondition)
[17:01:05.813]                     ns <- getNamespace("parallel")
[17:01:05.813]                     if (exists("sendData", mode = "function", 
[17:01:05.813]                       envir = ns)) {
[17:01:05.813]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:05.813]                         envir = ns)
[17:01:05.813]                       envir <- sys.frame(frame)
[17:01:05.813]                       master <- NULL
[17:01:05.813]                       while (!identical(envir, .GlobalEnv) && 
[17:01:05.813]                         !identical(envir, emptyenv())) {
[17:01:05.813]                         if (exists("master", mode = "list", envir = envir, 
[17:01:05.813]                           inherits = FALSE)) {
[17:01:05.813]                           master <- get("master", mode = "list", 
[17:01:05.813]                             envir = envir, inherits = FALSE)
[17:01:05.813]                           if (inherits(master, c("SOCKnode", 
[17:01:05.813]                             "SOCK0node"))) {
[17:01:05.813]                             sendCondition <<- function(cond) {
[17:01:05.813]                               data <- list(type = "VALUE", value = cond, 
[17:01:05.813]                                 success = TRUE)
[17:01:05.813]                               parallel_sendData(master, data)
[17:01:05.813]                             }
[17:01:05.813]                             return(sendCondition)
[17:01:05.813]                           }
[17:01:05.813]                         }
[17:01:05.813]                         frame <- frame + 1L
[17:01:05.813]                         envir <- sys.frame(frame)
[17:01:05.813]                       }
[17:01:05.813]                     }
[17:01:05.813]                     sendCondition <<- function(cond) NULL
[17:01:05.813]                   }
[17:01:05.813]                 })
[17:01:05.813]                 withCallingHandlers({
[17:01:05.813]                   {
[17:01:05.813]                     do.call(function(...) {
[17:01:05.813]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.813]                       if (!identical(...future.globals.maxSize.org, 
[17:01:05.813]                         ...future.globals.maxSize)) {
[17:01:05.813]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.813]                         on.exit(options(oopts), add = TRUE)
[17:01:05.813]                       }
[17:01:05.813]                       {
[17:01:05.813]                         lapply(seq_along(...future.elements_ii), 
[17:01:05.813]                           FUN = function(jj) {
[17:01:05.813]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.813]                             ...future.FUN(...future.X_jj, ...)
[17:01:05.813]                           })
[17:01:05.813]                       }
[17:01:05.813]                     }, args = future.call.arguments)
[17:01:05.813]                   }
[17:01:05.813]                 }, immediateCondition = function(cond) {
[17:01:05.813]                   sendCondition <- ...future.makeSendCondition()
[17:01:05.813]                   sendCondition(cond)
[17:01:05.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.813]                   {
[17:01:05.813]                     inherits <- base::inherits
[17:01:05.813]                     invokeRestart <- base::invokeRestart
[17:01:05.813]                     is.null <- base::is.null
[17:01:05.813]                     muffled <- FALSE
[17:01:05.813]                     if (inherits(cond, "message")) {
[17:01:05.813]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:05.813]                       if (muffled) 
[17:01:05.813]                         invokeRestart("muffleMessage")
[17:01:05.813]                     }
[17:01:05.813]                     else if (inherits(cond, "warning")) {
[17:01:05.813]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:05.813]                       if (muffled) 
[17:01:05.813]                         invokeRestart("muffleWarning")
[17:01:05.813]                     }
[17:01:05.813]                     else if (inherits(cond, "condition")) {
[17:01:05.813]                       if (!is.null(pattern)) {
[17:01:05.813]                         computeRestarts <- base::computeRestarts
[17:01:05.813]                         grepl <- base::grepl
[17:01:05.813]                         restarts <- computeRestarts(cond)
[17:01:05.813]                         for (restart in restarts) {
[17:01:05.813]                           name <- restart$name
[17:01:05.813]                           if (is.null(name)) 
[17:01:05.813]                             next
[17:01:05.813]                           if (!grepl(pattern, name)) 
[17:01:05.813]                             next
[17:01:05.813]                           invokeRestart(restart)
[17:01:05.813]                           muffled <- TRUE
[17:01:05.813]                           break
[17:01:05.813]                         }
[17:01:05.813]                       }
[17:01:05.813]                     }
[17:01:05.813]                     invisible(muffled)
[17:01:05.813]                   }
[17:01:05.813]                   muffleCondition(cond)
[17:01:05.813]                 })
[17:01:05.813]             }))
[17:01:05.813]             future::FutureResult(value = ...future.value$value, 
[17:01:05.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.813]                   ...future.rng), globalenv = if (FALSE) 
[17:01:05.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:05.813]                     ...future.globalenv.names))
[17:01:05.813]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:05.813]         }, condition = base::local({
[17:01:05.813]             c <- base::c
[17:01:05.813]             inherits <- base::inherits
[17:01:05.813]             invokeRestart <- base::invokeRestart
[17:01:05.813]             length <- base::length
[17:01:05.813]             list <- base::list
[17:01:05.813]             seq.int <- base::seq.int
[17:01:05.813]             signalCondition <- base::signalCondition
[17:01:05.813]             sys.calls <- base::sys.calls
[17:01:05.813]             `[[` <- base::`[[`
[17:01:05.813]             `+` <- base::`+`
[17:01:05.813]             `<<-` <- base::`<<-`
[17:01:05.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:05.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:05.813]                   3L)]
[17:01:05.813]             }
[17:01:05.813]             function(cond) {
[17:01:05.813]                 is_error <- inherits(cond, "error")
[17:01:05.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:05.813]                   NULL)
[17:01:05.813]                 if (is_error) {
[17:01:05.813]                   sessionInformation <- function() {
[17:01:05.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:05.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:05.813]                       search = base::search(), system = base::Sys.info())
[17:01:05.813]                   }
[17:01:05.813]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:05.813]                     cond$call), session = sessionInformation(), 
[17:01:05.813]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:05.813]                   signalCondition(cond)
[17:01:05.813]                 }
[17:01:05.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:05.813]                 "immediateCondition"))) {
[17:01:05.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:05.813]                   ...future.conditions[[length(...future.conditions) + 
[17:01:05.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:05.813]                   if (TRUE && !signal) {
[17:01:05.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.813]                     {
[17:01:05.813]                       inherits <- base::inherits
[17:01:05.813]                       invokeRestart <- base::invokeRestart
[17:01:05.813]                       is.null <- base::is.null
[17:01:05.813]                       muffled <- FALSE
[17:01:05.813]                       if (inherits(cond, "message")) {
[17:01:05.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.813]                         if (muffled) 
[17:01:05.813]                           invokeRestart("muffleMessage")
[17:01:05.813]                       }
[17:01:05.813]                       else if (inherits(cond, "warning")) {
[17:01:05.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.813]                         if (muffled) 
[17:01:05.813]                           invokeRestart("muffleWarning")
[17:01:05.813]                       }
[17:01:05.813]                       else if (inherits(cond, "condition")) {
[17:01:05.813]                         if (!is.null(pattern)) {
[17:01:05.813]                           computeRestarts <- base::computeRestarts
[17:01:05.813]                           grepl <- base::grepl
[17:01:05.813]                           restarts <- computeRestarts(cond)
[17:01:05.813]                           for (restart in restarts) {
[17:01:05.813]                             name <- restart$name
[17:01:05.813]                             if (is.null(name)) 
[17:01:05.813]                               next
[17:01:05.813]                             if (!grepl(pattern, name)) 
[17:01:05.813]                               next
[17:01:05.813]                             invokeRestart(restart)
[17:01:05.813]                             muffled <- TRUE
[17:01:05.813]                             break
[17:01:05.813]                           }
[17:01:05.813]                         }
[17:01:05.813]                       }
[17:01:05.813]                       invisible(muffled)
[17:01:05.813]                     }
[17:01:05.813]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.813]                   }
[17:01:05.813]                 }
[17:01:05.813]                 else {
[17:01:05.813]                   if (TRUE) {
[17:01:05.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:05.813]                     {
[17:01:05.813]                       inherits <- base::inherits
[17:01:05.813]                       invokeRestart <- base::invokeRestart
[17:01:05.813]                       is.null <- base::is.null
[17:01:05.813]                       muffled <- FALSE
[17:01:05.813]                       if (inherits(cond, "message")) {
[17:01:05.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:05.813]                         if (muffled) 
[17:01:05.813]                           invokeRestart("muffleMessage")
[17:01:05.813]                       }
[17:01:05.813]                       else if (inherits(cond, "warning")) {
[17:01:05.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:05.813]                         if (muffled) 
[17:01:05.813]                           invokeRestart("muffleWarning")
[17:01:05.813]                       }
[17:01:05.813]                       else if (inherits(cond, "condition")) {
[17:01:05.813]                         if (!is.null(pattern)) {
[17:01:05.813]                           computeRestarts <- base::computeRestarts
[17:01:05.813]                           grepl <- base::grepl
[17:01:05.813]                           restarts <- computeRestarts(cond)
[17:01:05.813]                           for (restart in restarts) {
[17:01:05.813]                             name <- restart$name
[17:01:05.813]                             if (is.null(name)) 
[17:01:05.813]                               next
[17:01:05.813]                             if (!grepl(pattern, name)) 
[17:01:05.813]                               next
[17:01:05.813]                             invokeRestart(restart)
[17:01:05.813]                             muffled <- TRUE
[17:01:05.813]                             break
[17:01:05.813]                           }
[17:01:05.813]                         }
[17:01:05.813]                       }
[17:01:05.813]                       invisible(muffled)
[17:01:05.813]                     }
[17:01:05.813]                     muffleCondition(cond, pattern = "^muffle")
[17:01:05.813]                   }
[17:01:05.813]                 }
[17:01:05.813]             }
[17:01:05.813]         }))
[17:01:05.813]     }, error = function(ex) {
[17:01:05.813]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:05.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:05.813]                 ...future.rng), started = ...future.startTime, 
[17:01:05.813]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:05.813]             version = "1.8"), class = "FutureResult")
[17:01:05.813]     }, finally = {
[17:01:05.813]         if (!identical(...future.workdir, getwd())) 
[17:01:05.813]             setwd(...future.workdir)
[17:01:05.813]         {
[17:01:05.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:05.813]                 ...future.oldOptions$nwarnings <- NULL
[17:01:05.813]             }
[17:01:05.813]             base::options(...future.oldOptions)
[17:01:05.813]             if (.Platform$OS.type == "windows") {
[17:01:05.813]                 old_names <- names(...future.oldEnvVars)
[17:01:05.813]                 envs <- base::Sys.getenv()
[17:01:05.813]                 names <- names(envs)
[17:01:05.813]                 common <- intersect(names, old_names)
[17:01:05.813]                 added <- setdiff(names, old_names)
[17:01:05.813]                 removed <- setdiff(old_names, names)
[17:01:05.813]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:05.813]                   envs[common]]
[17:01:05.813]                 NAMES <- toupper(changed)
[17:01:05.813]                 args <- list()
[17:01:05.813]                 for (kk in seq_along(NAMES)) {
[17:01:05.813]                   name <- changed[[kk]]
[17:01:05.813]                   NAME <- NAMES[[kk]]
[17:01:05.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.813]                     next
[17:01:05.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.813]                 }
[17:01:05.813]                 NAMES <- toupper(added)
[17:01:05.813]                 for (kk in seq_along(NAMES)) {
[17:01:05.813]                   name <- added[[kk]]
[17:01:05.813]                   NAME <- NAMES[[kk]]
[17:01:05.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.813]                     next
[17:01:05.813]                   args[[name]] <- ""
[17:01:05.813]                 }
[17:01:05.813]                 NAMES <- toupper(removed)
[17:01:05.813]                 for (kk in seq_along(NAMES)) {
[17:01:05.813]                   name <- removed[[kk]]
[17:01:05.813]                   NAME <- NAMES[[kk]]
[17:01:05.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:05.813]                     next
[17:01:05.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:05.813]                 }
[17:01:05.813]                 if (length(args) > 0) 
[17:01:05.813]                   base::do.call(base::Sys.setenv, args = args)
[17:01:05.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:05.813]             }
[17:01:05.813]             else {
[17:01:05.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:05.813]             }
[17:01:05.813]             {
[17:01:05.813]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:05.813]                   0L) {
[17:01:05.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:05.813]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:05.813]                   base::options(opts)
[17:01:05.813]                 }
[17:01:05.813]                 {
[17:01:05.813]                   {
[17:01:05.813]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:05.813]                     NULL
[17:01:05.813]                   }
[17:01:05.813]                   options(future.plan = NULL)
[17:01:05.813]                   if (is.na(NA_character_)) 
[17:01:05.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:05.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:05.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:05.813]                     .init = FALSE)
[17:01:05.813]                 }
[17:01:05.813]             }
[17:01:05.813]         }
[17:01:05.813]     })
[17:01:05.813]     if (TRUE) {
[17:01:05.813]         base::sink(type = "output", split = FALSE)
[17:01:05.813]         if (TRUE) {
[17:01:05.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:05.813]         }
[17:01:05.813]         else {
[17:01:05.813]             ...future.result["stdout"] <- base::list(NULL)
[17:01:05.813]         }
[17:01:05.813]         base::close(...future.stdout)
[17:01:05.813]         ...future.stdout <- NULL
[17:01:05.813]     }
[17:01:05.813]     ...future.result$conditions <- ...future.conditions
[17:01:05.813]     ...future.result$finished <- base::Sys.time()
[17:01:05.813]     ...future.result
[17:01:05.813] }
[17:01:05.816] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[17:01:05.816] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:05.860] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:05.860] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:01:05.860] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:01:05.861] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:05.861] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:05.861] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:05.904] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:05.904] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:05.948] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:05.948] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:05.948] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.949] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:01:05.949] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:01:05.949] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:05.950] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.950] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:01:05.950] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:01:05.950] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:05.951] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.951] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:05.951] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:05.951] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[17:01:05.952] MultisessionFuture started
[17:01:05.952] - Launch lazy future ... done
[17:01:05.952] run() for ‘MultisessionFuture’ ... done
[17:01:05.952] Created future:
[17:01:05.952] MultisessionFuture:
[17:01:05.952] Label: ‘future_vapply-2’
[17:01:05.952] Expression:
[17:01:05.952] {
[17:01:05.952]     do.call(function(...) {
[17:01:05.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:05.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:05.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:05.952]             on.exit(options(oopts), add = TRUE)
[17:01:05.952]         }
[17:01:05.952]         {
[17:01:05.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:05.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:05.952]                 ...future.FUN(...future.X_jj, ...)
[17:01:05.952]             })
[17:01:05.952]         }
[17:01:05.952]     }, args = future.call.arguments)
[17:01:05.952] }
[17:01:05.952] Lazy evaluation: FALSE
[17:01:05.952] Asynchronous evaluation: TRUE
[17:01:05.952] Local evaluation: TRUE
[17:01:05.952] Environment: R_GlobalEnv
[17:01:05.952] Capture standard output: TRUE
[17:01:05.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:05.952] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:05.952] Packages: 1 packages (‘future.apply’)
[17:01:05.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:05.952] Resolved: FALSE
[17:01:05.952] Value: <not collected>
[17:01:05.952] Conditions captured: <none>
[17:01:05.952] Early signaling: FALSE
[17:01:05.952] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:05.952] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:05.964] Chunk #2 of 2 ... DONE
[17:01:05.964] Launching 2 futures (chunks) ... DONE
[17:01:05.964] Resolving 2 futures (chunks) ...
[17:01:05.965] resolve() on list ...
[17:01:05.965]  recursive: 0
[17:01:05.965]  length: 2
[17:01:05.965] 
[17:01:05.965] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.966] - Validating connection of MultisessionFuture
[17:01:05.966] - received message: FutureResult
[17:01:05.966] - Received FutureResult
[17:01:05.966] - Erased future from FutureRegistry
[17:01:05.966] result() for ClusterFuture ...
[17:01:05.966] - result already collected: FutureResult
[17:01:05.966] result() for ClusterFuture ... done
[17:01:05.966] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.966] Future #1
[17:01:05.966] result() for ClusterFuture ...
[17:01:05.967] - result already collected: FutureResult
[17:01:05.967] result() for ClusterFuture ... done
[17:01:05.967] result() for ClusterFuture ...
[17:01:05.967] - result already collected: FutureResult
[17:01:05.967] result() for ClusterFuture ... done
[17:01:05.967] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:05.967] - nx: 2
[17:01:05.967] - relay: TRUE
[17:01:05.967] - stdout: TRUE
[17:01:05.967] - signal: TRUE
[17:01:05.967] - resignal: FALSE
[17:01:05.968] - force: TRUE
[17:01:05.968] - relayed: [n=2] FALSE, FALSE
[17:01:05.968] - queued futures: [n=2] FALSE, FALSE
[17:01:05.968]  - until=1
[17:01:05.968]  - relaying element #1
[17:01:05.968] result() for ClusterFuture ...
[17:01:05.968] - result already collected: FutureResult
[17:01:05.968] result() for ClusterFuture ... done
[17:01:05.968] result() for ClusterFuture ...
[17:01:05.968] - result already collected: FutureResult
[17:01:05.968] result() for ClusterFuture ... done
[17:01:05.969] result() for ClusterFuture ...
[17:01:05.969] - result already collected: FutureResult
[17:01:05.969] result() for ClusterFuture ... done
[17:01:05.969] result() for ClusterFuture ...
[17:01:05.969] - result already collected: FutureResult
[17:01:05.969] result() for ClusterFuture ... done
[17:01:05.969] - relayed: [n=2] TRUE, FALSE
[17:01:05.969] - queued futures: [n=2] TRUE, FALSE
[17:01:05.969] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:05.969]  length: 1 (resolved future 1)
[17:01:05.997] receiveMessageFromWorker() for ClusterFuture ...
[17:01:05.997] - Validating connection of MultisessionFuture
[17:01:05.998] - received message: FutureResult
[17:01:05.998] - Received FutureResult
[17:01:05.998] - Erased future from FutureRegistry
[17:01:05.998] result() for ClusterFuture ...
[17:01:05.998] - result already collected: FutureResult
[17:01:05.998] result() for ClusterFuture ... done
[17:01:05.998] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:05.998] Future #2
[17:01:05.998] result() for ClusterFuture ...
[17:01:05.998] - result already collected: FutureResult
[17:01:05.999] result() for ClusterFuture ... done
[17:01:05.999] result() for ClusterFuture ...
[17:01:05.999] - result already collected: FutureResult
[17:01:05.999] result() for ClusterFuture ... done
[17:01:05.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:05.999] - nx: 2
[17:01:05.999] - relay: TRUE
[17:01:05.999] - stdout: TRUE
[17:01:05.999] - signal: TRUE
[17:01:05.999] - resignal: FALSE
[17:01:05.999] - force: TRUE
[17:01:05.999] - relayed: [n=2] TRUE, FALSE
[17:01:06.000] - queued futures: [n=2] TRUE, FALSE
[17:01:06.000]  - until=2
[17:01:06.000]  - relaying element #2
[17:01:06.000] result() for ClusterFuture ...
[17:01:06.000] - result already collected: FutureResult
[17:01:06.000] result() for ClusterFuture ... done
[17:01:06.000] result() for ClusterFuture ...
[17:01:06.000] - result already collected: FutureResult
[17:01:06.000] result() for ClusterFuture ... done
[17:01:06.000] result() for ClusterFuture ...
[17:01:06.000] - result already collected: FutureResult
[17:01:06.001] result() for ClusterFuture ... done
[17:01:06.001] result() for ClusterFuture ...
[17:01:06.001] - result already collected: FutureResult
[17:01:06.001] result() for ClusterFuture ... done
[17:01:06.001] - relayed: [n=2] TRUE, TRUE
[17:01:06.001] - queued futures: [n=2] TRUE, TRUE
[17:01:06.001] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:06.001]  length: 0 (resolved future 2)
[17:01:06.001] Relaying remaining futures
[17:01:06.001] signalConditionsASAP(NULL, pos=0) ...
[17:01:06.001] - nx: 2
[17:01:06.001] - relay: TRUE
[17:01:06.002] - stdout: TRUE
[17:01:06.002] - signal: TRUE
[17:01:06.002] - resignal: FALSE
[17:01:06.002] - force: TRUE
[17:01:06.002] - relayed: [n=2] TRUE, TRUE
[17:01:06.002] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:06.002] - relayed: [n=2] TRUE, TRUE
[17:01:06.002] - queued futures: [n=2] TRUE, TRUE
[17:01:06.002] signalConditionsASAP(NULL, pos=0) ... done
[17:01:06.002] resolve() on list ... DONE
[17:01:06.002] result() for ClusterFuture ...
[17:01:06.003] - result already collected: FutureResult
[17:01:06.003] result() for ClusterFuture ... done
[17:01:06.003] result() for ClusterFuture ...
[17:01:06.003] - result already collected: FutureResult
[17:01:06.003] result() for ClusterFuture ... done
[17:01:06.003] result() for ClusterFuture ...
[17:01:06.003] - result already collected: FutureResult
[17:01:06.003] result() for ClusterFuture ... done
[17:01:06.003] result() for ClusterFuture ...
[17:01:06.003] - result already collected: FutureResult
[17:01:06.003] result() for ClusterFuture ... done
[17:01:06.004]  - Number of value chunks collected: 2
[17:01:06.004] Resolving 2 futures (chunks) ... DONE
[17:01:06.004] Reducing values from 2 chunks ...
[17:01:06.004]  - Number of values collected after concatenation: 10
[17:01:06.004]  - Number of values expected: 10
[17:01:06.004] Reducing values from 2 chunks ... DONE
[17:01:06.004] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:01:06.005] future_lapply() ...
[17:01:06.010] Number of chunks: 2
[17:01:06.011] getGlobalsAndPackagesXApply() ...
[17:01:06.011]  - future.globals: TRUE
[17:01:06.011] getGlobalsAndPackages() ...
[17:01:06.011] Searching for globals...
[17:01:06.014] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:06.014] Searching for globals ... DONE
[17:01:06.014] Resolving globals: FALSE
[17:01:06.015] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:01:06.015] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:06.015] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.015] - packages: [1] ‘future.apply’
[17:01:06.016] getGlobalsAndPackages() ... DONE
[17:01:06.016]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.016]  - needed namespaces: [n=1] ‘future.apply’
[17:01:06.016] Finding globals ... DONE
[17:01:06.016]  - use_args: TRUE
[17:01:06.016]  - Getting '...' globals ...
[17:01:06.016] resolve() on list ...
[17:01:06.016]  recursive: 0
[17:01:06.017]  length: 1
[17:01:06.017]  elements: ‘...’
[17:01:06.017]  length: 0 (resolved future 1)
[17:01:06.017] resolve() on list ... DONE
[17:01:06.017]    - '...' content: [n=0] 
[17:01:06.017] List of 1
[17:01:06.017]  $ ...: list()
[17:01:06.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.017]  - attr(*, "where")=List of 1
[17:01:06.017]   ..$ ...:<environment: 0x55aadd87ac68> 
[17:01:06.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.017]  - attr(*, "resolved")= logi TRUE
[17:01:06.017]  - attr(*, "total_size")= num NA
[17:01:06.019]  - Getting '...' globals ... DONE
[17:01:06.020] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:06.020] List of 8
[17:01:06.020]  $ ...future.FUN:function (x, ...)  
[17:01:06.020]  $ x_FUN        :function (x)  
[17:01:06.020]  $ times        : int 1
[17:01:06.020]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:06.020]  $ stop_if_not  :function (...)  
[17:01:06.020]  $ dim          : NULL
[17:01:06.020]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:06.020]  $ ...          : list()
[17:01:06.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.020]  - attr(*, "where")=List of 8
[17:01:06.020]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:06.020]   ..$ ...          :<environment: 0x55aadd87ac68> 
[17:01:06.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.020]  - attr(*, "resolved")= logi FALSE
[17:01:06.020]  - attr(*, "total_size")= num 94336
[17:01:06.025] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:06.025] getGlobalsAndPackagesXApply() ... DONE
[17:01:06.025] Number of futures (= number of chunks): 2
[17:01:06.025] Launching 2 futures (chunks) ...
[17:01:06.025] Chunk #1 of 2 ...
[17:01:06.026]  - Finding globals in 'X' for chunk #1 ...
[17:01:06.026] getGlobalsAndPackages() ...
[17:01:06.026] Searching for globals...
[17:01:06.026] 
[17:01:06.026] Searching for globals ... DONE
[17:01:06.026] - globals: [0] <none>
[17:01:06.026] getGlobalsAndPackages() ... DONE
[17:01:06.026]    + additional globals found: [n=0] 
[17:01:06.026]    + additional namespaces needed: [n=0] 
[17:01:06.026]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:06.027]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:06.027]  - seeds: <none>
[17:01:06.027]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.027] getGlobalsAndPackages() ...
[17:01:06.027] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.027] Resolving globals: FALSE
[17:01:06.027] Tweak future expression to call with '...' arguments ...
[17:01:06.027] {
[17:01:06.027]     do.call(function(...) {
[17:01:06.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.027]             on.exit(options(oopts), add = TRUE)
[17:01:06.027]         }
[17:01:06.027]         {
[17:01:06.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.027]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.027]             })
[17:01:06.027]         }
[17:01:06.027]     }, args = future.call.arguments)
[17:01:06.027] }
[17:01:06.028] Tweak future expression to call with '...' arguments ... DONE
[17:01:06.030] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.030] - packages: [1] ‘future.apply’
[17:01:06.030] getGlobalsAndPackages() ... DONE
[17:01:06.031] run() for ‘Future’ ...
[17:01:06.031] - state: ‘created’
[17:01:06.031] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:06.046] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:06.046]   - Field: ‘node’
[17:01:06.046]   - Field: ‘label’
[17:01:06.046]   - Field: ‘local’
[17:01:06.046]   - Field: ‘owner’
[17:01:06.046]   - Field: ‘envir’
[17:01:06.046]   - Field: ‘workers’
[17:01:06.047]   - Field: ‘packages’
[17:01:06.047]   - Field: ‘gc’
[17:01:06.047]   - Field: ‘conditions’
[17:01:06.047]   - Field: ‘persistent’
[17:01:06.047]   - Field: ‘expr’
[17:01:06.047]   - Field: ‘uuid’
[17:01:06.047]   - Field: ‘seed’
[17:01:06.047]   - Field: ‘version’
[17:01:06.047]   - Field: ‘result’
[17:01:06.047]   - Field: ‘asynchronous’
[17:01:06.048]   - Field: ‘calls’
[17:01:06.048]   - Field: ‘globals’
[17:01:06.048]   - Field: ‘stdout’
[17:01:06.048]   - Field: ‘earlySignal’
[17:01:06.048]   - Field: ‘lazy’
[17:01:06.048]   - Field: ‘state’
[17:01:06.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:06.048] - Launch lazy future ...
[17:01:06.048] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:06.049] Packages needed by future strategies (n = 0): <none>
[17:01:06.049] {
[17:01:06.049]     {
[17:01:06.049]         {
[17:01:06.049]             ...future.startTime <- base::Sys.time()
[17:01:06.049]             {
[17:01:06.049]                 {
[17:01:06.049]                   {
[17:01:06.049]                     {
[17:01:06.049]                       {
[17:01:06.049]                         base::local({
[17:01:06.049]                           has_future <- base::requireNamespace("future", 
[17:01:06.049]                             quietly = TRUE)
[17:01:06.049]                           if (has_future) {
[17:01:06.049]                             ns <- base::getNamespace("future")
[17:01:06.049]                             version <- ns[[".package"]][["version"]]
[17:01:06.049]                             if (is.null(version)) 
[17:01:06.049]                               version <- utils::packageVersion("future")
[17:01:06.049]                           }
[17:01:06.049]                           else {
[17:01:06.049]                             version <- NULL
[17:01:06.049]                           }
[17:01:06.049]                           if (!has_future || version < "1.8.0") {
[17:01:06.049]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:06.049]                               "", base::R.version$version.string), 
[17:01:06.049]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:06.049]                                 base::R.version$platform, 8 * 
[17:01:06.049]                                   base::.Machine$sizeof.pointer), 
[17:01:06.049]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:06.049]                                 "release", "version")], collapse = " "), 
[17:01:06.049]                               hostname = base::Sys.info()[["nodename"]])
[17:01:06.049]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:06.049]                               info)
[17:01:06.049]                             info <- base::paste(info, collapse = "; ")
[17:01:06.049]                             if (!has_future) {
[17:01:06.049]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:06.049]                                 info)
[17:01:06.049]                             }
[17:01:06.049]                             else {
[17:01:06.049]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:06.049]                                 info, version)
[17:01:06.049]                             }
[17:01:06.049]                             base::stop(msg)
[17:01:06.049]                           }
[17:01:06.049]                         })
[17:01:06.049]                       }
[17:01:06.049]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:06.049]                       base::options(mc.cores = 1L)
[17:01:06.049]                     }
[17:01:06.049]                     base::local({
[17:01:06.049]                       for (pkg in "future.apply") {
[17:01:06.049]                         base::loadNamespace(pkg)
[17:01:06.049]                         base::library(pkg, character.only = TRUE)
[17:01:06.049]                       }
[17:01:06.049]                     })
[17:01:06.049]                   }
[17:01:06.049]                   ...future.strategy.old <- future::plan("list")
[17:01:06.049]                   options(future.plan = NULL)
[17:01:06.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:06.049]                 }
[17:01:06.049]                 ...future.workdir <- getwd()
[17:01:06.049]             }
[17:01:06.049]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:06.049]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:06.049]         }
[17:01:06.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:06.049]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:06.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:06.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:06.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:06.049]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:06.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:06.049]             base::names(...future.oldOptions))
[17:01:06.049]     }
[17:01:06.049]     if (FALSE) {
[17:01:06.049]     }
[17:01:06.049]     else {
[17:01:06.049]         if (TRUE) {
[17:01:06.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:06.049]                 open = "w")
[17:01:06.049]         }
[17:01:06.049]         else {
[17:01:06.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:06.049]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:06.049]         }
[17:01:06.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:06.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:06.049]             base::sink(type = "output", split = FALSE)
[17:01:06.049]             base::close(...future.stdout)
[17:01:06.049]         }, add = TRUE)
[17:01:06.049]     }
[17:01:06.049]     ...future.frame <- base::sys.nframe()
[17:01:06.049]     ...future.conditions <- base::list()
[17:01:06.049]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:06.049]     if (FALSE) {
[17:01:06.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:06.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:06.049]     }
[17:01:06.049]     ...future.result <- base::tryCatch({
[17:01:06.049]         base::withCallingHandlers({
[17:01:06.049]             ...future.value <- base::withVisible(base::local({
[17:01:06.049]                 ...future.makeSendCondition <- base::local({
[17:01:06.049]                   sendCondition <- NULL
[17:01:06.049]                   function(frame = 1L) {
[17:01:06.049]                     if (is.function(sendCondition)) 
[17:01:06.049]                       return(sendCondition)
[17:01:06.049]                     ns <- getNamespace("parallel")
[17:01:06.049]                     if (exists("sendData", mode = "function", 
[17:01:06.049]                       envir = ns)) {
[17:01:06.049]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:06.049]                         envir = ns)
[17:01:06.049]                       envir <- sys.frame(frame)
[17:01:06.049]                       master <- NULL
[17:01:06.049]                       while (!identical(envir, .GlobalEnv) && 
[17:01:06.049]                         !identical(envir, emptyenv())) {
[17:01:06.049]                         if (exists("master", mode = "list", envir = envir, 
[17:01:06.049]                           inherits = FALSE)) {
[17:01:06.049]                           master <- get("master", mode = "list", 
[17:01:06.049]                             envir = envir, inherits = FALSE)
[17:01:06.049]                           if (inherits(master, c("SOCKnode", 
[17:01:06.049]                             "SOCK0node"))) {
[17:01:06.049]                             sendCondition <<- function(cond) {
[17:01:06.049]                               data <- list(type = "VALUE", value = cond, 
[17:01:06.049]                                 success = TRUE)
[17:01:06.049]                               parallel_sendData(master, data)
[17:01:06.049]                             }
[17:01:06.049]                             return(sendCondition)
[17:01:06.049]                           }
[17:01:06.049]                         }
[17:01:06.049]                         frame <- frame + 1L
[17:01:06.049]                         envir <- sys.frame(frame)
[17:01:06.049]                       }
[17:01:06.049]                     }
[17:01:06.049]                     sendCondition <<- function(cond) NULL
[17:01:06.049]                   }
[17:01:06.049]                 })
[17:01:06.049]                 withCallingHandlers({
[17:01:06.049]                   {
[17:01:06.049]                     do.call(function(...) {
[17:01:06.049]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.049]                       if (!identical(...future.globals.maxSize.org, 
[17:01:06.049]                         ...future.globals.maxSize)) {
[17:01:06.049]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.049]                         on.exit(options(oopts), add = TRUE)
[17:01:06.049]                       }
[17:01:06.049]                       {
[17:01:06.049]                         lapply(seq_along(...future.elements_ii), 
[17:01:06.049]                           FUN = function(jj) {
[17:01:06.049]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.049]                             ...future.FUN(...future.X_jj, ...)
[17:01:06.049]                           })
[17:01:06.049]                       }
[17:01:06.049]                     }, args = future.call.arguments)
[17:01:06.049]                   }
[17:01:06.049]                 }, immediateCondition = function(cond) {
[17:01:06.049]                   sendCondition <- ...future.makeSendCondition()
[17:01:06.049]                   sendCondition(cond)
[17:01:06.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.049]                   {
[17:01:06.049]                     inherits <- base::inherits
[17:01:06.049]                     invokeRestart <- base::invokeRestart
[17:01:06.049]                     is.null <- base::is.null
[17:01:06.049]                     muffled <- FALSE
[17:01:06.049]                     if (inherits(cond, "message")) {
[17:01:06.049]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:06.049]                       if (muffled) 
[17:01:06.049]                         invokeRestart("muffleMessage")
[17:01:06.049]                     }
[17:01:06.049]                     else if (inherits(cond, "warning")) {
[17:01:06.049]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:06.049]                       if (muffled) 
[17:01:06.049]                         invokeRestart("muffleWarning")
[17:01:06.049]                     }
[17:01:06.049]                     else if (inherits(cond, "condition")) {
[17:01:06.049]                       if (!is.null(pattern)) {
[17:01:06.049]                         computeRestarts <- base::computeRestarts
[17:01:06.049]                         grepl <- base::grepl
[17:01:06.049]                         restarts <- computeRestarts(cond)
[17:01:06.049]                         for (restart in restarts) {
[17:01:06.049]                           name <- restart$name
[17:01:06.049]                           if (is.null(name)) 
[17:01:06.049]                             next
[17:01:06.049]                           if (!grepl(pattern, name)) 
[17:01:06.049]                             next
[17:01:06.049]                           invokeRestart(restart)
[17:01:06.049]                           muffled <- TRUE
[17:01:06.049]                           break
[17:01:06.049]                         }
[17:01:06.049]                       }
[17:01:06.049]                     }
[17:01:06.049]                     invisible(muffled)
[17:01:06.049]                   }
[17:01:06.049]                   muffleCondition(cond)
[17:01:06.049]                 })
[17:01:06.049]             }))
[17:01:06.049]             future::FutureResult(value = ...future.value$value, 
[17:01:06.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.049]                   ...future.rng), globalenv = if (FALSE) 
[17:01:06.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:06.049]                     ...future.globalenv.names))
[17:01:06.049]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:06.049]         }, condition = base::local({
[17:01:06.049]             c <- base::c
[17:01:06.049]             inherits <- base::inherits
[17:01:06.049]             invokeRestart <- base::invokeRestart
[17:01:06.049]             length <- base::length
[17:01:06.049]             list <- base::list
[17:01:06.049]             seq.int <- base::seq.int
[17:01:06.049]             signalCondition <- base::signalCondition
[17:01:06.049]             sys.calls <- base::sys.calls
[17:01:06.049]             `[[` <- base::`[[`
[17:01:06.049]             `+` <- base::`+`
[17:01:06.049]             `<<-` <- base::`<<-`
[17:01:06.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:06.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:06.049]                   3L)]
[17:01:06.049]             }
[17:01:06.049]             function(cond) {
[17:01:06.049]                 is_error <- inherits(cond, "error")
[17:01:06.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:06.049]                   NULL)
[17:01:06.049]                 if (is_error) {
[17:01:06.049]                   sessionInformation <- function() {
[17:01:06.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:06.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:06.049]                       search = base::search(), system = base::Sys.info())
[17:01:06.049]                   }
[17:01:06.049]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:06.049]                     cond$call), session = sessionInformation(), 
[17:01:06.049]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:06.049]                   signalCondition(cond)
[17:01:06.049]                 }
[17:01:06.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:06.049]                 "immediateCondition"))) {
[17:01:06.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:06.049]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:06.049]                   if (TRUE && !signal) {
[17:01:06.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.049]                     {
[17:01:06.049]                       inherits <- base::inherits
[17:01:06.049]                       invokeRestart <- base::invokeRestart
[17:01:06.049]                       is.null <- base::is.null
[17:01:06.049]                       muffled <- FALSE
[17:01:06.049]                       if (inherits(cond, "message")) {
[17:01:06.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.049]                         if (muffled) 
[17:01:06.049]                           invokeRestart("muffleMessage")
[17:01:06.049]                       }
[17:01:06.049]                       else if (inherits(cond, "warning")) {
[17:01:06.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.049]                         if (muffled) 
[17:01:06.049]                           invokeRestart("muffleWarning")
[17:01:06.049]                       }
[17:01:06.049]                       else if (inherits(cond, "condition")) {
[17:01:06.049]                         if (!is.null(pattern)) {
[17:01:06.049]                           computeRestarts <- base::computeRestarts
[17:01:06.049]                           grepl <- base::grepl
[17:01:06.049]                           restarts <- computeRestarts(cond)
[17:01:06.049]                           for (restart in restarts) {
[17:01:06.049]                             name <- restart$name
[17:01:06.049]                             if (is.null(name)) 
[17:01:06.049]                               next
[17:01:06.049]                             if (!grepl(pattern, name)) 
[17:01:06.049]                               next
[17:01:06.049]                             invokeRestart(restart)
[17:01:06.049]                             muffled <- TRUE
[17:01:06.049]                             break
[17:01:06.049]                           }
[17:01:06.049]                         }
[17:01:06.049]                       }
[17:01:06.049]                       invisible(muffled)
[17:01:06.049]                     }
[17:01:06.049]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.049]                   }
[17:01:06.049]                 }
[17:01:06.049]                 else {
[17:01:06.049]                   if (TRUE) {
[17:01:06.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.049]                     {
[17:01:06.049]                       inherits <- base::inherits
[17:01:06.049]                       invokeRestart <- base::invokeRestart
[17:01:06.049]                       is.null <- base::is.null
[17:01:06.049]                       muffled <- FALSE
[17:01:06.049]                       if (inherits(cond, "message")) {
[17:01:06.049]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.049]                         if (muffled) 
[17:01:06.049]                           invokeRestart("muffleMessage")
[17:01:06.049]                       }
[17:01:06.049]                       else if (inherits(cond, "warning")) {
[17:01:06.049]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.049]                         if (muffled) 
[17:01:06.049]                           invokeRestart("muffleWarning")
[17:01:06.049]                       }
[17:01:06.049]                       else if (inherits(cond, "condition")) {
[17:01:06.049]                         if (!is.null(pattern)) {
[17:01:06.049]                           computeRestarts <- base::computeRestarts
[17:01:06.049]                           grepl <- base::grepl
[17:01:06.049]                           restarts <- computeRestarts(cond)
[17:01:06.049]                           for (restart in restarts) {
[17:01:06.049]                             name <- restart$name
[17:01:06.049]                             if (is.null(name)) 
[17:01:06.049]                               next
[17:01:06.049]                             if (!grepl(pattern, name)) 
[17:01:06.049]                               next
[17:01:06.049]                             invokeRestart(restart)
[17:01:06.049]                             muffled <- TRUE
[17:01:06.049]                             break
[17:01:06.049]                           }
[17:01:06.049]                         }
[17:01:06.049]                       }
[17:01:06.049]                       invisible(muffled)
[17:01:06.049]                     }
[17:01:06.049]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.049]                   }
[17:01:06.049]                 }
[17:01:06.049]             }
[17:01:06.049]         }))
[17:01:06.049]     }, error = function(ex) {
[17:01:06.049]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:06.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.049]                 ...future.rng), started = ...future.startTime, 
[17:01:06.049]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:06.049]             version = "1.8"), class = "FutureResult")
[17:01:06.049]     }, finally = {
[17:01:06.049]         if (!identical(...future.workdir, getwd())) 
[17:01:06.049]             setwd(...future.workdir)
[17:01:06.049]         {
[17:01:06.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:06.049]                 ...future.oldOptions$nwarnings <- NULL
[17:01:06.049]             }
[17:01:06.049]             base::options(...future.oldOptions)
[17:01:06.049]             if (.Platform$OS.type == "windows") {
[17:01:06.049]                 old_names <- names(...future.oldEnvVars)
[17:01:06.049]                 envs <- base::Sys.getenv()
[17:01:06.049]                 names <- names(envs)
[17:01:06.049]                 common <- intersect(names, old_names)
[17:01:06.049]                 added <- setdiff(names, old_names)
[17:01:06.049]                 removed <- setdiff(old_names, names)
[17:01:06.049]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:06.049]                   envs[common]]
[17:01:06.049]                 NAMES <- toupper(changed)
[17:01:06.049]                 args <- list()
[17:01:06.049]                 for (kk in seq_along(NAMES)) {
[17:01:06.049]                   name <- changed[[kk]]
[17:01:06.049]                   NAME <- NAMES[[kk]]
[17:01:06.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.049]                     next
[17:01:06.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.049]                 }
[17:01:06.049]                 NAMES <- toupper(added)
[17:01:06.049]                 for (kk in seq_along(NAMES)) {
[17:01:06.049]                   name <- added[[kk]]
[17:01:06.049]                   NAME <- NAMES[[kk]]
[17:01:06.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.049]                     next
[17:01:06.049]                   args[[name]] <- ""
[17:01:06.049]                 }
[17:01:06.049]                 NAMES <- toupper(removed)
[17:01:06.049]                 for (kk in seq_along(NAMES)) {
[17:01:06.049]                   name <- removed[[kk]]
[17:01:06.049]                   NAME <- NAMES[[kk]]
[17:01:06.049]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.049]                     next
[17:01:06.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.049]                 }
[17:01:06.049]                 if (length(args) > 0) 
[17:01:06.049]                   base::do.call(base::Sys.setenv, args = args)
[17:01:06.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:06.049]             }
[17:01:06.049]             else {
[17:01:06.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:06.049]             }
[17:01:06.049]             {
[17:01:06.049]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:06.049]                   0L) {
[17:01:06.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:06.049]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:06.049]                   base::options(opts)
[17:01:06.049]                 }
[17:01:06.049]                 {
[17:01:06.049]                   {
[17:01:06.049]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:06.049]                     NULL
[17:01:06.049]                   }
[17:01:06.049]                   options(future.plan = NULL)
[17:01:06.049]                   if (is.na(NA_character_)) 
[17:01:06.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:06.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:06.049]                     .init = FALSE)
[17:01:06.049]                 }
[17:01:06.049]             }
[17:01:06.049]         }
[17:01:06.049]     })
[17:01:06.049]     if (TRUE) {
[17:01:06.049]         base::sink(type = "output", split = FALSE)
[17:01:06.049]         if (TRUE) {
[17:01:06.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:06.049]         }
[17:01:06.049]         else {
[17:01:06.049]             ...future.result["stdout"] <- base::list(NULL)
[17:01:06.049]         }
[17:01:06.049]         base::close(...future.stdout)
[17:01:06.049]         ...future.stdout <- NULL
[17:01:06.049]     }
[17:01:06.049]     ...future.result$conditions <- ...future.conditions
[17:01:06.049]     ...future.result$finished <- base::Sys.time()
[17:01:06.049]     ...future.result
[17:01:06.049] }
[17:01:06.052] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[17:01:06.052] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:06.096] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:06.096] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:01:06.097] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:01:06.097] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:06.097] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:06.097] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:06.140] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:06.140] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:06.184] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:06.184] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:06.184] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.185] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:06.185] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:06.185] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:06.186] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.186] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:06.186] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:06.186] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:06.187] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.187] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:06.187] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.187] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[17:01:06.188] MultisessionFuture started
[17:01:06.188] - Launch lazy future ... done
[17:01:06.188] run() for ‘MultisessionFuture’ ... done
[17:01:06.188] Created future:
[17:01:06.189] MultisessionFuture:
[17:01:06.189] Label: ‘future_vapply-1’
[17:01:06.189] Expression:
[17:01:06.189] {
[17:01:06.189]     do.call(function(...) {
[17:01:06.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.189]             on.exit(options(oopts), add = TRUE)
[17:01:06.189]         }
[17:01:06.189]         {
[17:01:06.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.189]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.189]             })
[17:01:06.189]         }
[17:01:06.189]     }, args = future.call.arguments)
[17:01:06.189] }
[17:01:06.189] Lazy evaluation: FALSE
[17:01:06.189] Asynchronous evaluation: TRUE
[17:01:06.189] Local evaluation: TRUE
[17:01:06.189] Environment: R_GlobalEnv
[17:01:06.189] Capture standard output: TRUE
[17:01:06.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:06.189] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:06.189] Packages: 1 packages (‘future.apply’)
[17:01:06.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:06.189] Resolved: FALSE
[17:01:06.189] Value: <not collected>
[17:01:06.189] Conditions captured: <none>
[17:01:06.189] Early signaling: FALSE
[17:01:06.189] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:06.189] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.200] Chunk #1 of 2 ... DONE
[17:01:06.200] Chunk #2 of 2 ...
[17:01:06.201]  - Finding globals in 'X' for chunk #2 ...
[17:01:06.201] getGlobalsAndPackages() ...
[17:01:06.201] Searching for globals...
[17:01:06.201] 
[17:01:06.201] Searching for globals ... DONE
[17:01:06.201] - globals: [0] <none>
[17:01:06.201] getGlobalsAndPackages() ... DONE
[17:01:06.201]    + additional globals found: [n=0] 
[17:01:06.202]    + additional namespaces needed: [n=0] 
[17:01:06.202]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:06.202]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:06.202]  - seeds: <none>
[17:01:06.202]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.202] getGlobalsAndPackages() ...
[17:01:06.202] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.202] Resolving globals: FALSE
[17:01:06.202] Tweak future expression to call with '...' arguments ...
[17:01:06.202] {
[17:01:06.202]     do.call(function(...) {
[17:01:06.202]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.202]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.202]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.202]             on.exit(options(oopts), add = TRUE)
[17:01:06.202]         }
[17:01:06.202]         {
[17:01:06.202]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.202]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.202]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.202]             })
[17:01:06.202]         }
[17:01:06.202]     }, args = future.call.arguments)
[17:01:06.202] }
[17:01:06.203] Tweak future expression to call with '...' arguments ... DONE
[17:01:06.203] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.203] - packages: [1] ‘future.apply’
[17:01:06.203] getGlobalsAndPackages() ... DONE
[17:01:06.204] run() for ‘Future’ ...
[17:01:06.204] - state: ‘created’
[17:01:06.204] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:06.219] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:06.219]   - Field: ‘node’
[17:01:06.220]   - Field: ‘label’
[17:01:06.220]   - Field: ‘local’
[17:01:06.220]   - Field: ‘owner’
[17:01:06.220]   - Field: ‘envir’
[17:01:06.220]   - Field: ‘workers’
[17:01:06.220]   - Field: ‘packages’
[17:01:06.220]   - Field: ‘gc’
[17:01:06.220]   - Field: ‘conditions’
[17:01:06.220]   - Field: ‘persistent’
[17:01:06.220]   - Field: ‘expr’
[17:01:06.221]   - Field: ‘uuid’
[17:01:06.221]   - Field: ‘seed’
[17:01:06.221]   - Field: ‘version’
[17:01:06.221]   - Field: ‘result’
[17:01:06.221]   - Field: ‘asynchronous’
[17:01:06.221]   - Field: ‘calls’
[17:01:06.221]   - Field: ‘globals’
[17:01:06.221]   - Field: ‘stdout’
[17:01:06.221]   - Field: ‘earlySignal’
[17:01:06.221]   - Field: ‘lazy’
[17:01:06.221]   - Field: ‘state’
[17:01:06.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:06.222] - Launch lazy future ...
[17:01:06.222] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:06.222] Packages needed by future strategies (n = 0): <none>
[17:01:06.223] {
[17:01:06.223]     {
[17:01:06.223]         {
[17:01:06.223]             ...future.startTime <- base::Sys.time()
[17:01:06.223]             {
[17:01:06.223]                 {
[17:01:06.223]                   {
[17:01:06.223]                     {
[17:01:06.223]                       {
[17:01:06.223]                         base::local({
[17:01:06.223]                           has_future <- base::requireNamespace("future", 
[17:01:06.223]                             quietly = TRUE)
[17:01:06.223]                           if (has_future) {
[17:01:06.223]                             ns <- base::getNamespace("future")
[17:01:06.223]                             version <- ns[[".package"]][["version"]]
[17:01:06.223]                             if (is.null(version)) 
[17:01:06.223]                               version <- utils::packageVersion("future")
[17:01:06.223]                           }
[17:01:06.223]                           else {
[17:01:06.223]                             version <- NULL
[17:01:06.223]                           }
[17:01:06.223]                           if (!has_future || version < "1.8.0") {
[17:01:06.223]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:06.223]                               "", base::R.version$version.string), 
[17:01:06.223]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:06.223]                                 base::R.version$platform, 8 * 
[17:01:06.223]                                   base::.Machine$sizeof.pointer), 
[17:01:06.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:06.223]                                 "release", "version")], collapse = " "), 
[17:01:06.223]                               hostname = base::Sys.info()[["nodename"]])
[17:01:06.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:06.223]                               info)
[17:01:06.223]                             info <- base::paste(info, collapse = "; ")
[17:01:06.223]                             if (!has_future) {
[17:01:06.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:06.223]                                 info)
[17:01:06.223]                             }
[17:01:06.223]                             else {
[17:01:06.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:06.223]                                 info, version)
[17:01:06.223]                             }
[17:01:06.223]                             base::stop(msg)
[17:01:06.223]                           }
[17:01:06.223]                         })
[17:01:06.223]                       }
[17:01:06.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:06.223]                       base::options(mc.cores = 1L)
[17:01:06.223]                     }
[17:01:06.223]                     base::local({
[17:01:06.223]                       for (pkg in "future.apply") {
[17:01:06.223]                         base::loadNamespace(pkg)
[17:01:06.223]                         base::library(pkg, character.only = TRUE)
[17:01:06.223]                       }
[17:01:06.223]                     })
[17:01:06.223]                   }
[17:01:06.223]                   ...future.strategy.old <- future::plan("list")
[17:01:06.223]                   options(future.plan = NULL)
[17:01:06.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:06.223]                 }
[17:01:06.223]                 ...future.workdir <- getwd()
[17:01:06.223]             }
[17:01:06.223]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:06.223]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:06.223]         }
[17:01:06.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:06.223]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:06.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:06.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:06.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:06.223]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:06.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:06.223]             base::names(...future.oldOptions))
[17:01:06.223]     }
[17:01:06.223]     if (FALSE) {
[17:01:06.223]     }
[17:01:06.223]     else {
[17:01:06.223]         if (TRUE) {
[17:01:06.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:06.223]                 open = "w")
[17:01:06.223]         }
[17:01:06.223]         else {
[17:01:06.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:06.223]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:06.223]         }
[17:01:06.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:06.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:06.223]             base::sink(type = "output", split = FALSE)
[17:01:06.223]             base::close(...future.stdout)
[17:01:06.223]         }, add = TRUE)
[17:01:06.223]     }
[17:01:06.223]     ...future.frame <- base::sys.nframe()
[17:01:06.223]     ...future.conditions <- base::list()
[17:01:06.223]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:06.223]     if (FALSE) {
[17:01:06.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:06.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:06.223]     }
[17:01:06.223]     ...future.result <- base::tryCatch({
[17:01:06.223]         base::withCallingHandlers({
[17:01:06.223]             ...future.value <- base::withVisible(base::local({
[17:01:06.223]                 ...future.makeSendCondition <- base::local({
[17:01:06.223]                   sendCondition <- NULL
[17:01:06.223]                   function(frame = 1L) {
[17:01:06.223]                     if (is.function(sendCondition)) 
[17:01:06.223]                       return(sendCondition)
[17:01:06.223]                     ns <- getNamespace("parallel")
[17:01:06.223]                     if (exists("sendData", mode = "function", 
[17:01:06.223]                       envir = ns)) {
[17:01:06.223]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:06.223]                         envir = ns)
[17:01:06.223]                       envir <- sys.frame(frame)
[17:01:06.223]                       master <- NULL
[17:01:06.223]                       while (!identical(envir, .GlobalEnv) && 
[17:01:06.223]                         !identical(envir, emptyenv())) {
[17:01:06.223]                         if (exists("master", mode = "list", envir = envir, 
[17:01:06.223]                           inherits = FALSE)) {
[17:01:06.223]                           master <- get("master", mode = "list", 
[17:01:06.223]                             envir = envir, inherits = FALSE)
[17:01:06.223]                           if (inherits(master, c("SOCKnode", 
[17:01:06.223]                             "SOCK0node"))) {
[17:01:06.223]                             sendCondition <<- function(cond) {
[17:01:06.223]                               data <- list(type = "VALUE", value = cond, 
[17:01:06.223]                                 success = TRUE)
[17:01:06.223]                               parallel_sendData(master, data)
[17:01:06.223]                             }
[17:01:06.223]                             return(sendCondition)
[17:01:06.223]                           }
[17:01:06.223]                         }
[17:01:06.223]                         frame <- frame + 1L
[17:01:06.223]                         envir <- sys.frame(frame)
[17:01:06.223]                       }
[17:01:06.223]                     }
[17:01:06.223]                     sendCondition <<- function(cond) NULL
[17:01:06.223]                   }
[17:01:06.223]                 })
[17:01:06.223]                 withCallingHandlers({
[17:01:06.223]                   {
[17:01:06.223]                     do.call(function(...) {
[17:01:06.223]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.223]                       if (!identical(...future.globals.maxSize.org, 
[17:01:06.223]                         ...future.globals.maxSize)) {
[17:01:06.223]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.223]                         on.exit(options(oopts), add = TRUE)
[17:01:06.223]                       }
[17:01:06.223]                       {
[17:01:06.223]                         lapply(seq_along(...future.elements_ii), 
[17:01:06.223]                           FUN = function(jj) {
[17:01:06.223]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.223]                             ...future.FUN(...future.X_jj, ...)
[17:01:06.223]                           })
[17:01:06.223]                       }
[17:01:06.223]                     }, args = future.call.arguments)
[17:01:06.223]                   }
[17:01:06.223]                 }, immediateCondition = function(cond) {
[17:01:06.223]                   sendCondition <- ...future.makeSendCondition()
[17:01:06.223]                   sendCondition(cond)
[17:01:06.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.223]                   {
[17:01:06.223]                     inherits <- base::inherits
[17:01:06.223]                     invokeRestart <- base::invokeRestart
[17:01:06.223]                     is.null <- base::is.null
[17:01:06.223]                     muffled <- FALSE
[17:01:06.223]                     if (inherits(cond, "message")) {
[17:01:06.223]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:06.223]                       if (muffled) 
[17:01:06.223]                         invokeRestart("muffleMessage")
[17:01:06.223]                     }
[17:01:06.223]                     else if (inherits(cond, "warning")) {
[17:01:06.223]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:06.223]                       if (muffled) 
[17:01:06.223]                         invokeRestart("muffleWarning")
[17:01:06.223]                     }
[17:01:06.223]                     else if (inherits(cond, "condition")) {
[17:01:06.223]                       if (!is.null(pattern)) {
[17:01:06.223]                         computeRestarts <- base::computeRestarts
[17:01:06.223]                         grepl <- base::grepl
[17:01:06.223]                         restarts <- computeRestarts(cond)
[17:01:06.223]                         for (restart in restarts) {
[17:01:06.223]                           name <- restart$name
[17:01:06.223]                           if (is.null(name)) 
[17:01:06.223]                             next
[17:01:06.223]                           if (!grepl(pattern, name)) 
[17:01:06.223]                             next
[17:01:06.223]                           invokeRestart(restart)
[17:01:06.223]                           muffled <- TRUE
[17:01:06.223]                           break
[17:01:06.223]                         }
[17:01:06.223]                       }
[17:01:06.223]                     }
[17:01:06.223]                     invisible(muffled)
[17:01:06.223]                   }
[17:01:06.223]                   muffleCondition(cond)
[17:01:06.223]                 })
[17:01:06.223]             }))
[17:01:06.223]             future::FutureResult(value = ...future.value$value, 
[17:01:06.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.223]                   ...future.rng), globalenv = if (FALSE) 
[17:01:06.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:06.223]                     ...future.globalenv.names))
[17:01:06.223]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:06.223]         }, condition = base::local({
[17:01:06.223]             c <- base::c
[17:01:06.223]             inherits <- base::inherits
[17:01:06.223]             invokeRestart <- base::invokeRestart
[17:01:06.223]             length <- base::length
[17:01:06.223]             list <- base::list
[17:01:06.223]             seq.int <- base::seq.int
[17:01:06.223]             signalCondition <- base::signalCondition
[17:01:06.223]             sys.calls <- base::sys.calls
[17:01:06.223]             `[[` <- base::`[[`
[17:01:06.223]             `+` <- base::`+`
[17:01:06.223]             `<<-` <- base::`<<-`
[17:01:06.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:06.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:06.223]                   3L)]
[17:01:06.223]             }
[17:01:06.223]             function(cond) {
[17:01:06.223]                 is_error <- inherits(cond, "error")
[17:01:06.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:06.223]                   NULL)
[17:01:06.223]                 if (is_error) {
[17:01:06.223]                   sessionInformation <- function() {
[17:01:06.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:06.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:06.223]                       search = base::search(), system = base::Sys.info())
[17:01:06.223]                   }
[17:01:06.223]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:06.223]                     cond$call), session = sessionInformation(), 
[17:01:06.223]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:06.223]                   signalCondition(cond)
[17:01:06.223]                 }
[17:01:06.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:06.223]                 "immediateCondition"))) {
[17:01:06.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:06.223]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:06.223]                   if (TRUE && !signal) {
[17:01:06.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.223]                     {
[17:01:06.223]                       inherits <- base::inherits
[17:01:06.223]                       invokeRestart <- base::invokeRestart
[17:01:06.223]                       is.null <- base::is.null
[17:01:06.223]                       muffled <- FALSE
[17:01:06.223]                       if (inherits(cond, "message")) {
[17:01:06.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.223]                         if (muffled) 
[17:01:06.223]                           invokeRestart("muffleMessage")
[17:01:06.223]                       }
[17:01:06.223]                       else if (inherits(cond, "warning")) {
[17:01:06.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.223]                         if (muffled) 
[17:01:06.223]                           invokeRestart("muffleWarning")
[17:01:06.223]                       }
[17:01:06.223]                       else if (inherits(cond, "condition")) {
[17:01:06.223]                         if (!is.null(pattern)) {
[17:01:06.223]                           computeRestarts <- base::computeRestarts
[17:01:06.223]                           grepl <- base::grepl
[17:01:06.223]                           restarts <- computeRestarts(cond)
[17:01:06.223]                           for (restart in restarts) {
[17:01:06.223]                             name <- restart$name
[17:01:06.223]                             if (is.null(name)) 
[17:01:06.223]                               next
[17:01:06.223]                             if (!grepl(pattern, name)) 
[17:01:06.223]                               next
[17:01:06.223]                             invokeRestart(restart)
[17:01:06.223]                             muffled <- TRUE
[17:01:06.223]                             break
[17:01:06.223]                           }
[17:01:06.223]                         }
[17:01:06.223]                       }
[17:01:06.223]                       invisible(muffled)
[17:01:06.223]                     }
[17:01:06.223]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.223]                   }
[17:01:06.223]                 }
[17:01:06.223]                 else {
[17:01:06.223]                   if (TRUE) {
[17:01:06.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.223]                     {
[17:01:06.223]                       inherits <- base::inherits
[17:01:06.223]                       invokeRestart <- base::invokeRestart
[17:01:06.223]                       is.null <- base::is.null
[17:01:06.223]                       muffled <- FALSE
[17:01:06.223]                       if (inherits(cond, "message")) {
[17:01:06.223]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.223]                         if (muffled) 
[17:01:06.223]                           invokeRestart("muffleMessage")
[17:01:06.223]                       }
[17:01:06.223]                       else if (inherits(cond, "warning")) {
[17:01:06.223]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.223]                         if (muffled) 
[17:01:06.223]                           invokeRestart("muffleWarning")
[17:01:06.223]                       }
[17:01:06.223]                       else if (inherits(cond, "condition")) {
[17:01:06.223]                         if (!is.null(pattern)) {
[17:01:06.223]                           computeRestarts <- base::computeRestarts
[17:01:06.223]                           grepl <- base::grepl
[17:01:06.223]                           restarts <- computeRestarts(cond)
[17:01:06.223]                           for (restart in restarts) {
[17:01:06.223]                             name <- restart$name
[17:01:06.223]                             if (is.null(name)) 
[17:01:06.223]                               next
[17:01:06.223]                             if (!grepl(pattern, name)) 
[17:01:06.223]                               next
[17:01:06.223]                             invokeRestart(restart)
[17:01:06.223]                             muffled <- TRUE
[17:01:06.223]                             break
[17:01:06.223]                           }
[17:01:06.223]                         }
[17:01:06.223]                       }
[17:01:06.223]                       invisible(muffled)
[17:01:06.223]                     }
[17:01:06.223]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.223]                   }
[17:01:06.223]                 }
[17:01:06.223]             }
[17:01:06.223]         }))
[17:01:06.223]     }, error = function(ex) {
[17:01:06.223]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:06.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.223]                 ...future.rng), started = ...future.startTime, 
[17:01:06.223]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:06.223]             version = "1.8"), class = "FutureResult")
[17:01:06.223]     }, finally = {
[17:01:06.223]         if (!identical(...future.workdir, getwd())) 
[17:01:06.223]             setwd(...future.workdir)
[17:01:06.223]         {
[17:01:06.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:06.223]                 ...future.oldOptions$nwarnings <- NULL
[17:01:06.223]             }
[17:01:06.223]             base::options(...future.oldOptions)
[17:01:06.223]             if (.Platform$OS.type == "windows") {
[17:01:06.223]                 old_names <- names(...future.oldEnvVars)
[17:01:06.223]                 envs <- base::Sys.getenv()
[17:01:06.223]                 names <- names(envs)
[17:01:06.223]                 common <- intersect(names, old_names)
[17:01:06.223]                 added <- setdiff(names, old_names)
[17:01:06.223]                 removed <- setdiff(old_names, names)
[17:01:06.223]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:06.223]                   envs[common]]
[17:01:06.223]                 NAMES <- toupper(changed)
[17:01:06.223]                 args <- list()
[17:01:06.223]                 for (kk in seq_along(NAMES)) {
[17:01:06.223]                   name <- changed[[kk]]
[17:01:06.223]                   NAME <- NAMES[[kk]]
[17:01:06.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.223]                     next
[17:01:06.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.223]                 }
[17:01:06.223]                 NAMES <- toupper(added)
[17:01:06.223]                 for (kk in seq_along(NAMES)) {
[17:01:06.223]                   name <- added[[kk]]
[17:01:06.223]                   NAME <- NAMES[[kk]]
[17:01:06.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.223]                     next
[17:01:06.223]                   args[[name]] <- ""
[17:01:06.223]                 }
[17:01:06.223]                 NAMES <- toupper(removed)
[17:01:06.223]                 for (kk in seq_along(NAMES)) {
[17:01:06.223]                   name <- removed[[kk]]
[17:01:06.223]                   NAME <- NAMES[[kk]]
[17:01:06.223]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.223]                     next
[17:01:06.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.223]                 }
[17:01:06.223]                 if (length(args) > 0) 
[17:01:06.223]                   base::do.call(base::Sys.setenv, args = args)
[17:01:06.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:06.223]             }
[17:01:06.223]             else {
[17:01:06.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:06.223]             }
[17:01:06.223]             {
[17:01:06.223]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:06.223]                   0L) {
[17:01:06.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:06.223]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:06.223]                   base::options(opts)
[17:01:06.223]                 }
[17:01:06.223]                 {
[17:01:06.223]                   {
[17:01:06.223]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:06.223]                     NULL
[17:01:06.223]                   }
[17:01:06.223]                   options(future.plan = NULL)
[17:01:06.223]                   if (is.na(NA_character_)) 
[17:01:06.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:06.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:06.223]                     .init = FALSE)
[17:01:06.223]                 }
[17:01:06.223]             }
[17:01:06.223]         }
[17:01:06.223]     })
[17:01:06.223]     if (TRUE) {
[17:01:06.223]         base::sink(type = "output", split = FALSE)
[17:01:06.223]         if (TRUE) {
[17:01:06.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:06.223]         }
[17:01:06.223]         else {
[17:01:06.223]             ...future.result["stdout"] <- base::list(NULL)
[17:01:06.223]         }
[17:01:06.223]         base::close(...future.stdout)
[17:01:06.223]         ...future.stdout <- NULL
[17:01:06.223]     }
[17:01:06.223]     ...future.result$conditions <- ...future.conditions
[17:01:06.223]     ...future.result$finished <- base::Sys.time()
[17:01:06.223]     ...future.result
[17:01:06.223] }
[17:01:06.225] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[17:01:06.226] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:06.268] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:06.268] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:01:06.268] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:01:06.269] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:06.269] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:06.269] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:06.312] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:06.312] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:06.356] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:06.356] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:06.356] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.357] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:01:06.357] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:01:06.357] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:06.358] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.358] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:01:06.358] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:01:06.358] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:06.359] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:06.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.359] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[17:01:06.360] MultisessionFuture started
[17:01:06.360] - Launch lazy future ... done
[17:01:06.360] run() for ‘MultisessionFuture’ ... done
[17:01:06.360] Created future:
[17:01:06.360] MultisessionFuture:
[17:01:06.360] Label: ‘future_vapply-2’
[17:01:06.360] Expression:
[17:01:06.360] {
[17:01:06.360]     do.call(function(...) {
[17:01:06.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.360]             on.exit(options(oopts), add = TRUE)
[17:01:06.360]         }
[17:01:06.360]         {
[17:01:06.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.360]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.360]             })
[17:01:06.360]         }
[17:01:06.360]     }, args = future.call.arguments)
[17:01:06.360] }
[17:01:06.360] Lazy evaluation: FALSE
[17:01:06.360] Asynchronous evaluation: TRUE
[17:01:06.360] Local evaluation: TRUE
[17:01:06.360] Environment: R_GlobalEnv
[17:01:06.360] Capture standard output: TRUE
[17:01:06.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:06.360] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:06.360] Packages: 1 packages (‘future.apply’)
[17:01:06.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:06.360] Resolved: FALSE
[17:01:06.360] Value: <not collected>
[17:01:06.360] Conditions captured: <none>
[17:01:06.360] Early signaling: FALSE
[17:01:06.360] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:06.360] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.372] Chunk #2 of 2 ... DONE
[17:01:06.372] Launching 2 futures (chunks) ... DONE
[17:01:06.372] Resolving 2 futures (chunks) ...
[17:01:06.373] resolve() on list ...
[17:01:06.373]  recursive: 0
[17:01:06.373]  length: 2
[17:01:06.373] 
[17:01:06.373] receiveMessageFromWorker() for ClusterFuture ...
[17:01:06.373] - Validating connection of MultisessionFuture
[17:01:06.374] - received message: FutureResult
[17:01:06.374] - Received FutureResult
[17:01:06.374] - Erased future from FutureRegistry
[17:01:06.374] result() for ClusterFuture ...
[17:01:06.374] - result already collected: FutureResult
[17:01:06.374] result() for ClusterFuture ... done
[17:01:06.374] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:06.374] Future #1
[17:01:06.374] result() for ClusterFuture ...
[17:01:06.375] - result already collected: FutureResult
[17:01:06.375] result() for ClusterFuture ... done
[17:01:06.375] result() for ClusterFuture ...
[17:01:06.375] - result already collected: FutureResult
[17:01:06.375] result() for ClusterFuture ... done
[17:01:06.375] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:06.375] - nx: 2
[17:01:06.375] - relay: TRUE
[17:01:06.375] - stdout: TRUE
[17:01:06.375] - signal: TRUE
[17:01:06.375] - resignal: FALSE
[17:01:06.376] - force: TRUE
[17:01:06.376] - relayed: [n=2] FALSE, FALSE
[17:01:06.376] - queued futures: [n=2] FALSE, FALSE
[17:01:06.376]  - until=1
[17:01:06.376]  - relaying element #1
[17:01:06.376] result() for ClusterFuture ...
[17:01:06.376] - result already collected: FutureResult
[17:01:06.376] result() for ClusterFuture ... done
[17:01:06.376] result() for ClusterFuture ...
[17:01:06.376] - result already collected: FutureResult
[17:01:06.376] result() for ClusterFuture ... done
[17:01:06.376] result() for ClusterFuture ...
[17:01:06.377] - result already collected: FutureResult
[17:01:06.377] result() for ClusterFuture ... done
[17:01:06.377] result() for ClusterFuture ...
[17:01:06.377] - result already collected: FutureResult
[17:01:06.377] result() for ClusterFuture ... done
[17:01:06.377] - relayed: [n=2] TRUE, FALSE
[17:01:06.377] - queued futures: [n=2] TRUE, FALSE
[17:01:06.377] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:06.377]  length: 1 (resolved future 1)
[17:01:06.405] receiveMessageFromWorker() for ClusterFuture ...
[17:01:06.405] - Validating connection of MultisessionFuture
[17:01:06.405] - received message: FutureResult
[17:01:06.406] - Received FutureResult
[17:01:06.406] - Erased future from FutureRegistry
[17:01:06.406] result() for ClusterFuture ...
[17:01:06.406] - result already collected: FutureResult
[17:01:06.406] result() for ClusterFuture ... done
[17:01:06.406] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:06.406] Future #2
[17:01:06.406] result() for ClusterFuture ...
[17:01:06.406] - result already collected: FutureResult
[17:01:06.406] result() for ClusterFuture ... done
[17:01:06.407] result() for ClusterFuture ...
[17:01:06.407] - result already collected: FutureResult
[17:01:06.407] result() for ClusterFuture ... done
[17:01:06.407] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:06.407] - nx: 2
[17:01:06.407] - relay: TRUE
[17:01:06.407] - stdout: TRUE
[17:01:06.407] - signal: TRUE
[17:01:06.407] - resignal: FALSE
[17:01:06.407] - force: TRUE
[17:01:06.407] - relayed: [n=2] TRUE, FALSE
[17:01:06.407] - queued futures: [n=2] TRUE, FALSE
[17:01:06.408]  - until=2
[17:01:06.408]  - relaying element #2
[17:01:06.408] result() for ClusterFuture ...
[17:01:06.408] - result already collected: FutureResult
[17:01:06.408] result() for ClusterFuture ... done
[17:01:06.408] result() for ClusterFuture ...
[17:01:06.408] - result already collected: FutureResult
[17:01:06.408] result() for ClusterFuture ... done
[17:01:06.408] result() for ClusterFuture ...
[17:01:06.408] - result already collected: FutureResult
[17:01:06.408] result() for ClusterFuture ... done
[17:01:06.409] result() for ClusterFuture ...
[17:01:06.409] - result already collected: FutureResult
[17:01:06.409] result() for ClusterFuture ... done
[17:01:06.409] - relayed: [n=2] TRUE, TRUE
[17:01:06.409] - queued futures: [n=2] TRUE, TRUE
[17:01:06.409] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:06.409]  length: 0 (resolved future 2)
[17:01:06.409] Relaying remaining futures
[17:01:06.409] signalConditionsASAP(NULL, pos=0) ...
[17:01:06.409] - nx: 2
[17:01:06.409] - relay: TRUE
[17:01:06.409] - stdout: TRUE
[17:01:06.410] - signal: TRUE
[17:01:06.410] - resignal: FALSE
[17:01:06.410] - force: TRUE
[17:01:06.410] - relayed: [n=2] TRUE, TRUE
[17:01:06.410] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:06.410] - relayed: [n=2] TRUE, TRUE
[17:01:06.410] - queued futures: [n=2] TRUE, TRUE
[17:01:06.410] signalConditionsASAP(NULL, pos=0) ... done
[17:01:06.410] resolve() on list ... DONE
[17:01:06.410] result() for ClusterFuture ...
[17:01:06.410] - result already collected: FutureResult
[17:01:06.410] result() for ClusterFuture ... done
[17:01:06.411] result() for ClusterFuture ...
[17:01:06.411] - result already collected: FutureResult
[17:01:06.411] result() for ClusterFuture ... done
[17:01:06.411] result() for ClusterFuture ...
[17:01:06.411] - result already collected: FutureResult
[17:01:06.411] result() for ClusterFuture ... done
[17:01:06.411] result() for ClusterFuture ...
[17:01:06.411] - result already collected: FutureResult
[17:01:06.411] result() for ClusterFuture ... done
[17:01:06.411]  - Number of value chunks collected: 2
[17:01:06.411] Resolving 2 futures (chunks) ... DONE
[17:01:06.412] Reducing values from 2 chunks ...
[17:01:06.412]  - Number of values collected after concatenation: 10
[17:01:06.412]  - Number of values expected: 10
[17:01:06.412] Reducing values from 2 chunks ... DONE
[17:01:06.412] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:01:06.413] future_lapply() ...
[17:01:06.418] Number of chunks: 2
[17:01:06.418] getGlobalsAndPackagesXApply() ...
[17:01:06.419]  - future.globals: TRUE
[17:01:06.419] getGlobalsAndPackages() ...
[17:01:06.419] Searching for globals...
[17:01:06.422] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:01:06.423] Searching for globals ... DONE
[17:01:06.423] Resolving globals: FALSE
[17:01:06.424] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:01:06.424] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:06.424] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.424] - packages: [1] ‘future.apply’
[17:01:06.424] getGlobalsAndPackages() ... DONE
[17:01:06.425]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.425]  - needed namespaces: [n=1] ‘future.apply’
[17:01:06.425] Finding globals ... DONE
[17:01:06.425]  - use_args: TRUE
[17:01:06.425]  - Getting '...' globals ...
[17:01:06.425] resolve() on list ...
[17:01:06.425]  recursive: 0
[17:01:06.425]  length: 1
[17:01:06.425]  elements: ‘...’
[17:01:06.426]  length: 0 (resolved future 1)
[17:01:06.426] resolve() on list ... DONE
[17:01:06.426]    - '...' content: [n=0] 
[17:01:06.426] List of 1
[17:01:06.426]  $ ...: list()
[17:01:06.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.426]  - attr(*, "where")=List of 1
[17:01:06.426]   ..$ ...:<environment: 0x55aadcfcd038> 
[17:01:06.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.426]  - attr(*, "resolved")= logi TRUE
[17:01:06.426]  - attr(*, "total_size")= num NA
[17:01:06.428]  - Getting '...' globals ... DONE
[17:01:06.429] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:06.429] List of 8
[17:01:06.429]  $ ...future.FUN:function (x, ...)  
[17:01:06.429]  $ x_FUN        :function (x)  
[17:01:06.429]  $ times        : int 2
[17:01:06.429]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:06.429]  $ stop_if_not  :function (...)  
[17:01:06.429]  $ dim          : NULL
[17:01:06.429]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:06.429]  $ ...          : list()
[17:01:06.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.429]  - attr(*, "where")=List of 8
[17:01:06.429]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:06.429]   ..$ ...          :<environment: 0x55aadcfcd038> 
[17:01:06.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.429]  - attr(*, "resolved")= logi FALSE
[17:01:06.429]  - attr(*, "total_size")= num 96456
[17:01:06.434] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:06.434] getGlobalsAndPackagesXApply() ... DONE
[17:01:06.434] Number of futures (= number of chunks): 2
[17:01:06.434] Launching 2 futures (chunks) ...
[17:01:06.434] Chunk #1 of 2 ...
[17:01:06.434]  - Finding globals in 'X' for chunk #1 ...
[17:01:06.434] getGlobalsAndPackages() ...
[17:01:06.435] Searching for globals...
[17:01:06.435] 
[17:01:06.435] Searching for globals ... DONE
[17:01:06.435] - globals: [0] <none>
[17:01:06.435] getGlobalsAndPackages() ... DONE
[17:01:06.435]    + additional globals found: [n=0] 
[17:01:06.435]    + additional namespaces needed: [n=0] 
[17:01:06.435]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:06.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:06.436]  - seeds: <none>
[17:01:06.436]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.436] getGlobalsAndPackages() ...
[17:01:06.436] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.436] Resolving globals: FALSE
[17:01:06.436] Tweak future expression to call with '...' arguments ...
[17:01:06.436] {
[17:01:06.436]     do.call(function(...) {
[17:01:06.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.436]             on.exit(options(oopts), add = TRUE)
[17:01:06.436]         }
[17:01:06.436]         {
[17:01:06.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.436]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.436]             })
[17:01:06.436]         }
[17:01:06.436]     }, args = future.call.arguments)
[17:01:06.436] }
[17:01:06.436] Tweak future expression to call with '...' arguments ... DONE
[17:01:06.437] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.437] - packages: [1] ‘future.apply’
[17:01:06.437] getGlobalsAndPackages() ... DONE
[17:01:06.437] run() for ‘Future’ ...
[17:01:06.438] - state: ‘created’
[17:01:06.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:06.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:06.452]   - Field: ‘node’
[17:01:06.452]   - Field: ‘label’
[17:01:06.452]   - Field: ‘local’
[17:01:06.452]   - Field: ‘owner’
[17:01:06.452]   - Field: ‘envir’
[17:01:06.452]   - Field: ‘workers’
[17:01:06.453]   - Field: ‘packages’
[17:01:06.453]   - Field: ‘gc’
[17:01:06.453]   - Field: ‘conditions’
[17:01:06.453]   - Field: ‘persistent’
[17:01:06.453]   - Field: ‘expr’
[17:01:06.453]   - Field: ‘uuid’
[17:01:06.453]   - Field: ‘seed’
[17:01:06.453]   - Field: ‘version’
[17:01:06.453]   - Field: ‘result’
[17:01:06.453]   - Field: ‘asynchronous’
[17:01:06.453]   - Field: ‘calls’
[17:01:06.454]   - Field: ‘globals’
[17:01:06.454]   - Field: ‘stdout’
[17:01:06.454]   - Field: ‘earlySignal’
[17:01:06.454]   - Field: ‘lazy’
[17:01:06.454]   - Field: ‘state’
[17:01:06.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:06.454] - Launch lazy future ...
[17:01:06.454] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:06.454] Packages needed by future strategies (n = 0): <none>
[17:01:06.455] {
[17:01:06.455]     {
[17:01:06.455]         {
[17:01:06.455]             ...future.startTime <- base::Sys.time()
[17:01:06.455]             {
[17:01:06.455]                 {
[17:01:06.455]                   {
[17:01:06.455]                     {
[17:01:06.455]                       {
[17:01:06.455]                         base::local({
[17:01:06.455]                           has_future <- base::requireNamespace("future", 
[17:01:06.455]                             quietly = TRUE)
[17:01:06.455]                           if (has_future) {
[17:01:06.455]                             ns <- base::getNamespace("future")
[17:01:06.455]                             version <- ns[[".package"]][["version"]]
[17:01:06.455]                             if (is.null(version)) 
[17:01:06.455]                               version <- utils::packageVersion("future")
[17:01:06.455]                           }
[17:01:06.455]                           else {
[17:01:06.455]                             version <- NULL
[17:01:06.455]                           }
[17:01:06.455]                           if (!has_future || version < "1.8.0") {
[17:01:06.455]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:06.455]                               "", base::R.version$version.string), 
[17:01:06.455]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:06.455]                                 base::R.version$platform, 8 * 
[17:01:06.455]                                   base::.Machine$sizeof.pointer), 
[17:01:06.455]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:06.455]                                 "release", "version")], collapse = " "), 
[17:01:06.455]                               hostname = base::Sys.info()[["nodename"]])
[17:01:06.455]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:06.455]                               info)
[17:01:06.455]                             info <- base::paste(info, collapse = "; ")
[17:01:06.455]                             if (!has_future) {
[17:01:06.455]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:06.455]                                 info)
[17:01:06.455]                             }
[17:01:06.455]                             else {
[17:01:06.455]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:06.455]                                 info, version)
[17:01:06.455]                             }
[17:01:06.455]                             base::stop(msg)
[17:01:06.455]                           }
[17:01:06.455]                         })
[17:01:06.455]                       }
[17:01:06.455]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:06.455]                       base::options(mc.cores = 1L)
[17:01:06.455]                     }
[17:01:06.455]                     base::local({
[17:01:06.455]                       for (pkg in "future.apply") {
[17:01:06.455]                         base::loadNamespace(pkg)
[17:01:06.455]                         base::library(pkg, character.only = TRUE)
[17:01:06.455]                       }
[17:01:06.455]                     })
[17:01:06.455]                   }
[17:01:06.455]                   ...future.strategy.old <- future::plan("list")
[17:01:06.455]                   options(future.plan = NULL)
[17:01:06.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:06.455]                 }
[17:01:06.455]                 ...future.workdir <- getwd()
[17:01:06.455]             }
[17:01:06.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:06.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:06.455]         }
[17:01:06.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:06.455]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:06.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:06.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:06.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:06.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:06.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:06.455]             base::names(...future.oldOptions))
[17:01:06.455]     }
[17:01:06.455]     if (FALSE) {
[17:01:06.455]     }
[17:01:06.455]     else {
[17:01:06.455]         if (TRUE) {
[17:01:06.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:06.455]                 open = "w")
[17:01:06.455]         }
[17:01:06.455]         else {
[17:01:06.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:06.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:06.455]         }
[17:01:06.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:06.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:06.455]             base::sink(type = "output", split = FALSE)
[17:01:06.455]             base::close(...future.stdout)
[17:01:06.455]         }, add = TRUE)
[17:01:06.455]     }
[17:01:06.455]     ...future.frame <- base::sys.nframe()
[17:01:06.455]     ...future.conditions <- base::list()
[17:01:06.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:06.455]     if (FALSE) {
[17:01:06.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:06.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:06.455]     }
[17:01:06.455]     ...future.result <- base::tryCatch({
[17:01:06.455]         base::withCallingHandlers({
[17:01:06.455]             ...future.value <- base::withVisible(base::local({
[17:01:06.455]                 ...future.makeSendCondition <- base::local({
[17:01:06.455]                   sendCondition <- NULL
[17:01:06.455]                   function(frame = 1L) {
[17:01:06.455]                     if (is.function(sendCondition)) 
[17:01:06.455]                       return(sendCondition)
[17:01:06.455]                     ns <- getNamespace("parallel")
[17:01:06.455]                     if (exists("sendData", mode = "function", 
[17:01:06.455]                       envir = ns)) {
[17:01:06.455]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:06.455]                         envir = ns)
[17:01:06.455]                       envir <- sys.frame(frame)
[17:01:06.455]                       master <- NULL
[17:01:06.455]                       while (!identical(envir, .GlobalEnv) && 
[17:01:06.455]                         !identical(envir, emptyenv())) {
[17:01:06.455]                         if (exists("master", mode = "list", envir = envir, 
[17:01:06.455]                           inherits = FALSE)) {
[17:01:06.455]                           master <- get("master", mode = "list", 
[17:01:06.455]                             envir = envir, inherits = FALSE)
[17:01:06.455]                           if (inherits(master, c("SOCKnode", 
[17:01:06.455]                             "SOCK0node"))) {
[17:01:06.455]                             sendCondition <<- function(cond) {
[17:01:06.455]                               data <- list(type = "VALUE", value = cond, 
[17:01:06.455]                                 success = TRUE)
[17:01:06.455]                               parallel_sendData(master, data)
[17:01:06.455]                             }
[17:01:06.455]                             return(sendCondition)
[17:01:06.455]                           }
[17:01:06.455]                         }
[17:01:06.455]                         frame <- frame + 1L
[17:01:06.455]                         envir <- sys.frame(frame)
[17:01:06.455]                       }
[17:01:06.455]                     }
[17:01:06.455]                     sendCondition <<- function(cond) NULL
[17:01:06.455]                   }
[17:01:06.455]                 })
[17:01:06.455]                 withCallingHandlers({
[17:01:06.455]                   {
[17:01:06.455]                     do.call(function(...) {
[17:01:06.455]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.455]                       if (!identical(...future.globals.maxSize.org, 
[17:01:06.455]                         ...future.globals.maxSize)) {
[17:01:06.455]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.455]                         on.exit(options(oopts), add = TRUE)
[17:01:06.455]                       }
[17:01:06.455]                       {
[17:01:06.455]                         lapply(seq_along(...future.elements_ii), 
[17:01:06.455]                           FUN = function(jj) {
[17:01:06.455]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.455]                             ...future.FUN(...future.X_jj, ...)
[17:01:06.455]                           })
[17:01:06.455]                       }
[17:01:06.455]                     }, args = future.call.arguments)
[17:01:06.455]                   }
[17:01:06.455]                 }, immediateCondition = function(cond) {
[17:01:06.455]                   sendCondition <- ...future.makeSendCondition()
[17:01:06.455]                   sendCondition(cond)
[17:01:06.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.455]                   {
[17:01:06.455]                     inherits <- base::inherits
[17:01:06.455]                     invokeRestart <- base::invokeRestart
[17:01:06.455]                     is.null <- base::is.null
[17:01:06.455]                     muffled <- FALSE
[17:01:06.455]                     if (inherits(cond, "message")) {
[17:01:06.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:06.455]                       if (muffled) 
[17:01:06.455]                         invokeRestart("muffleMessage")
[17:01:06.455]                     }
[17:01:06.455]                     else if (inherits(cond, "warning")) {
[17:01:06.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:06.455]                       if (muffled) 
[17:01:06.455]                         invokeRestart("muffleWarning")
[17:01:06.455]                     }
[17:01:06.455]                     else if (inherits(cond, "condition")) {
[17:01:06.455]                       if (!is.null(pattern)) {
[17:01:06.455]                         computeRestarts <- base::computeRestarts
[17:01:06.455]                         grepl <- base::grepl
[17:01:06.455]                         restarts <- computeRestarts(cond)
[17:01:06.455]                         for (restart in restarts) {
[17:01:06.455]                           name <- restart$name
[17:01:06.455]                           if (is.null(name)) 
[17:01:06.455]                             next
[17:01:06.455]                           if (!grepl(pattern, name)) 
[17:01:06.455]                             next
[17:01:06.455]                           invokeRestart(restart)
[17:01:06.455]                           muffled <- TRUE
[17:01:06.455]                           break
[17:01:06.455]                         }
[17:01:06.455]                       }
[17:01:06.455]                     }
[17:01:06.455]                     invisible(muffled)
[17:01:06.455]                   }
[17:01:06.455]                   muffleCondition(cond)
[17:01:06.455]                 })
[17:01:06.455]             }))
[17:01:06.455]             future::FutureResult(value = ...future.value$value, 
[17:01:06.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.455]                   ...future.rng), globalenv = if (FALSE) 
[17:01:06.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:06.455]                     ...future.globalenv.names))
[17:01:06.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:06.455]         }, condition = base::local({
[17:01:06.455]             c <- base::c
[17:01:06.455]             inherits <- base::inherits
[17:01:06.455]             invokeRestart <- base::invokeRestart
[17:01:06.455]             length <- base::length
[17:01:06.455]             list <- base::list
[17:01:06.455]             seq.int <- base::seq.int
[17:01:06.455]             signalCondition <- base::signalCondition
[17:01:06.455]             sys.calls <- base::sys.calls
[17:01:06.455]             `[[` <- base::`[[`
[17:01:06.455]             `+` <- base::`+`
[17:01:06.455]             `<<-` <- base::`<<-`
[17:01:06.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:06.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:06.455]                   3L)]
[17:01:06.455]             }
[17:01:06.455]             function(cond) {
[17:01:06.455]                 is_error <- inherits(cond, "error")
[17:01:06.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:06.455]                   NULL)
[17:01:06.455]                 if (is_error) {
[17:01:06.455]                   sessionInformation <- function() {
[17:01:06.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:06.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:06.455]                       search = base::search(), system = base::Sys.info())
[17:01:06.455]                   }
[17:01:06.455]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:06.455]                     cond$call), session = sessionInformation(), 
[17:01:06.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:06.455]                   signalCondition(cond)
[17:01:06.455]                 }
[17:01:06.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:06.455]                 "immediateCondition"))) {
[17:01:06.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:06.455]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:06.455]                   if (TRUE && !signal) {
[17:01:06.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.455]                     {
[17:01:06.455]                       inherits <- base::inherits
[17:01:06.455]                       invokeRestart <- base::invokeRestart
[17:01:06.455]                       is.null <- base::is.null
[17:01:06.455]                       muffled <- FALSE
[17:01:06.455]                       if (inherits(cond, "message")) {
[17:01:06.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.455]                         if (muffled) 
[17:01:06.455]                           invokeRestart("muffleMessage")
[17:01:06.455]                       }
[17:01:06.455]                       else if (inherits(cond, "warning")) {
[17:01:06.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.455]                         if (muffled) 
[17:01:06.455]                           invokeRestart("muffleWarning")
[17:01:06.455]                       }
[17:01:06.455]                       else if (inherits(cond, "condition")) {
[17:01:06.455]                         if (!is.null(pattern)) {
[17:01:06.455]                           computeRestarts <- base::computeRestarts
[17:01:06.455]                           grepl <- base::grepl
[17:01:06.455]                           restarts <- computeRestarts(cond)
[17:01:06.455]                           for (restart in restarts) {
[17:01:06.455]                             name <- restart$name
[17:01:06.455]                             if (is.null(name)) 
[17:01:06.455]                               next
[17:01:06.455]                             if (!grepl(pattern, name)) 
[17:01:06.455]                               next
[17:01:06.455]                             invokeRestart(restart)
[17:01:06.455]                             muffled <- TRUE
[17:01:06.455]                             break
[17:01:06.455]                           }
[17:01:06.455]                         }
[17:01:06.455]                       }
[17:01:06.455]                       invisible(muffled)
[17:01:06.455]                     }
[17:01:06.455]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.455]                   }
[17:01:06.455]                 }
[17:01:06.455]                 else {
[17:01:06.455]                   if (TRUE) {
[17:01:06.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.455]                     {
[17:01:06.455]                       inherits <- base::inherits
[17:01:06.455]                       invokeRestart <- base::invokeRestart
[17:01:06.455]                       is.null <- base::is.null
[17:01:06.455]                       muffled <- FALSE
[17:01:06.455]                       if (inherits(cond, "message")) {
[17:01:06.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.455]                         if (muffled) 
[17:01:06.455]                           invokeRestart("muffleMessage")
[17:01:06.455]                       }
[17:01:06.455]                       else if (inherits(cond, "warning")) {
[17:01:06.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.455]                         if (muffled) 
[17:01:06.455]                           invokeRestart("muffleWarning")
[17:01:06.455]                       }
[17:01:06.455]                       else if (inherits(cond, "condition")) {
[17:01:06.455]                         if (!is.null(pattern)) {
[17:01:06.455]                           computeRestarts <- base::computeRestarts
[17:01:06.455]                           grepl <- base::grepl
[17:01:06.455]                           restarts <- computeRestarts(cond)
[17:01:06.455]                           for (restart in restarts) {
[17:01:06.455]                             name <- restart$name
[17:01:06.455]                             if (is.null(name)) 
[17:01:06.455]                               next
[17:01:06.455]                             if (!grepl(pattern, name)) 
[17:01:06.455]                               next
[17:01:06.455]                             invokeRestart(restart)
[17:01:06.455]                             muffled <- TRUE
[17:01:06.455]                             break
[17:01:06.455]                           }
[17:01:06.455]                         }
[17:01:06.455]                       }
[17:01:06.455]                       invisible(muffled)
[17:01:06.455]                     }
[17:01:06.455]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.455]                   }
[17:01:06.455]                 }
[17:01:06.455]             }
[17:01:06.455]         }))
[17:01:06.455]     }, error = function(ex) {
[17:01:06.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:06.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.455]                 ...future.rng), started = ...future.startTime, 
[17:01:06.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:06.455]             version = "1.8"), class = "FutureResult")
[17:01:06.455]     }, finally = {
[17:01:06.455]         if (!identical(...future.workdir, getwd())) 
[17:01:06.455]             setwd(...future.workdir)
[17:01:06.455]         {
[17:01:06.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:06.455]                 ...future.oldOptions$nwarnings <- NULL
[17:01:06.455]             }
[17:01:06.455]             base::options(...future.oldOptions)
[17:01:06.455]             if (.Platform$OS.type == "windows") {
[17:01:06.455]                 old_names <- names(...future.oldEnvVars)
[17:01:06.455]                 envs <- base::Sys.getenv()
[17:01:06.455]                 names <- names(envs)
[17:01:06.455]                 common <- intersect(names, old_names)
[17:01:06.455]                 added <- setdiff(names, old_names)
[17:01:06.455]                 removed <- setdiff(old_names, names)
[17:01:06.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:06.455]                   envs[common]]
[17:01:06.455]                 NAMES <- toupper(changed)
[17:01:06.455]                 args <- list()
[17:01:06.455]                 for (kk in seq_along(NAMES)) {
[17:01:06.455]                   name <- changed[[kk]]
[17:01:06.455]                   NAME <- NAMES[[kk]]
[17:01:06.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.455]                     next
[17:01:06.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.455]                 }
[17:01:06.455]                 NAMES <- toupper(added)
[17:01:06.455]                 for (kk in seq_along(NAMES)) {
[17:01:06.455]                   name <- added[[kk]]
[17:01:06.455]                   NAME <- NAMES[[kk]]
[17:01:06.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.455]                     next
[17:01:06.455]                   args[[name]] <- ""
[17:01:06.455]                 }
[17:01:06.455]                 NAMES <- toupper(removed)
[17:01:06.455]                 for (kk in seq_along(NAMES)) {
[17:01:06.455]                   name <- removed[[kk]]
[17:01:06.455]                   NAME <- NAMES[[kk]]
[17:01:06.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.455]                     next
[17:01:06.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.455]                 }
[17:01:06.455]                 if (length(args) > 0) 
[17:01:06.455]                   base::do.call(base::Sys.setenv, args = args)
[17:01:06.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:06.455]             }
[17:01:06.455]             else {
[17:01:06.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:06.455]             }
[17:01:06.455]             {
[17:01:06.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:06.455]                   0L) {
[17:01:06.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:06.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:06.455]                   base::options(opts)
[17:01:06.455]                 }
[17:01:06.455]                 {
[17:01:06.455]                   {
[17:01:06.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:06.455]                     NULL
[17:01:06.455]                   }
[17:01:06.455]                   options(future.plan = NULL)
[17:01:06.455]                   if (is.na(NA_character_)) 
[17:01:06.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:06.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:06.455]                     .init = FALSE)
[17:01:06.455]                 }
[17:01:06.455]             }
[17:01:06.455]         }
[17:01:06.455]     })
[17:01:06.455]     if (TRUE) {
[17:01:06.455]         base::sink(type = "output", split = FALSE)
[17:01:06.455]         if (TRUE) {
[17:01:06.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:06.455]         }
[17:01:06.455]         else {
[17:01:06.455]             ...future.result["stdout"] <- base::list(NULL)
[17:01:06.455]         }
[17:01:06.455]         base::close(...future.stdout)
[17:01:06.455]         ...future.stdout <- NULL
[17:01:06.455]     }
[17:01:06.455]     ...future.result$conditions <- ...future.conditions
[17:01:06.455]     ...future.result$finished <- base::Sys.time()
[17:01:06.455]     ...future.result
[17:01:06.455] }
[17:01:06.458] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[17:01:06.458] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:06.500] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:06.500] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[17:01:06.500] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[17:01:06.501] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:06.501] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:06.501] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:06.544] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:06.544] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:06.588] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:06.588] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:06.588] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.588] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:06.589] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:06.589] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:06.589] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.590] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:06.590] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:06.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:06.591] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:06.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:06.591] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[17:01:06.592] MultisessionFuture started
[17:01:06.592] - Launch lazy future ... done
[17:01:06.592] run() for ‘MultisessionFuture’ ... done
[17:01:06.592] Created future:
[17:01:06.592] MultisessionFuture:
[17:01:06.592] Label: ‘future_vapply-1’
[17:01:06.592] Expression:
[17:01:06.592] {
[17:01:06.592]     do.call(function(...) {
[17:01:06.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.592]             on.exit(options(oopts), add = TRUE)
[17:01:06.592]         }
[17:01:06.592]         {
[17:01:06.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.592]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.592]             })
[17:01:06.592]         }
[17:01:06.592]     }, args = future.call.arguments)
[17:01:06.592] }
[17:01:06.592] Lazy evaluation: FALSE
[17:01:06.592] Asynchronous evaluation: TRUE
[17:01:06.592] Local evaluation: TRUE
[17:01:06.592] Environment: R_GlobalEnv
[17:01:06.592] Capture standard output: TRUE
[17:01:06.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:06.592] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:06.592] Packages: 1 packages (‘future.apply’)
[17:01:06.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:06.592] Resolved: FALSE
[17:01:06.592] Value: <not collected>
[17:01:06.592] Conditions captured: <none>
[17:01:06.592] Early signaling: FALSE
[17:01:06.592] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:06.592] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.604] Chunk #1 of 2 ... DONE
[17:01:06.604] Chunk #2 of 2 ...
[17:01:06.604]  - Finding globals in 'X' for chunk #2 ...
[17:01:06.605] getGlobalsAndPackages() ...
[17:01:06.605] Searching for globals...
[17:01:06.605] 
[17:01:06.605] Searching for globals ... DONE
[17:01:06.605] - globals: [0] <none>
[17:01:06.605] getGlobalsAndPackages() ... DONE
[17:01:06.605]    + additional globals found: [n=0] 
[17:01:06.605]    + additional namespaces needed: [n=0] 
[17:01:06.605]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:06.606]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:06.606]  - seeds: <none>
[17:01:06.606]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.606] getGlobalsAndPackages() ...
[17:01:06.606] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.606] Resolving globals: FALSE
[17:01:06.606] Tweak future expression to call with '...' arguments ...
[17:01:06.606] {
[17:01:06.606]     do.call(function(...) {
[17:01:06.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.606]             on.exit(options(oopts), add = TRUE)
[17:01:06.606]         }
[17:01:06.606]         {
[17:01:06.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.606]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.606]             })
[17:01:06.606]         }
[17:01:06.606]     }, args = future.call.arguments)
[17:01:06.606] }
[17:01:06.606] Tweak future expression to call with '...' arguments ... DONE
[17:01:06.607] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.607] - packages: [1] ‘future.apply’
[17:01:06.607] getGlobalsAndPackages() ... DONE
[17:01:06.608] run() for ‘Future’ ...
[17:01:06.608] - state: ‘created’
[17:01:06.608] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:06.624] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:06.624]   - Field: ‘node’
[17:01:06.624]   - Field: ‘label’
[17:01:06.625]   - Field: ‘local’
[17:01:06.625]   - Field: ‘owner’
[17:01:06.625]   - Field: ‘envir’
[17:01:06.625]   - Field: ‘workers’
[17:01:06.625]   - Field: ‘packages’
[17:01:06.625]   - Field: ‘gc’
[17:01:06.625]   - Field: ‘conditions’
[17:01:06.625]   - Field: ‘persistent’
[17:01:06.625]   - Field: ‘expr’
[17:01:06.625]   - Field: ‘uuid’
[17:01:06.625]   - Field: ‘seed’
[17:01:06.626]   - Field: ‘version’
[17:01:06.626]   - Field: ‘result’
[17:01:06.626]   - Field: ‘asynchronous’
[17:01:06.626]   - Field: ‘calls’
[17:01:06.626]   - Field: ‘globals’
[17:01:06.626]   - Field: ‘stdout’
[17:01:06.626]   - Field: ‘earlySignal’
[17:01:06.626]   - Field: ‘lazy’
[17:01:06.626]   - Field: ‘state’
[17:01:06.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:06.626] - Launch lazy future ...
[17:01:06.627] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:06.627] Packages needed by future strategies (n = 0): <none>
[17:01:06.627] {
[17:01:06.627]     {
[17:01:06.627]         {
[17:01:06.627]             ...future.startTime <- base::Sys.time()
[17:01:06.627]             {
[17:01:06.627]                 {
[17:01:06.627]                   {
[17:01:06.627]                     {
[17:01:06.627]                       {
[17:01:06.627]                         base::local({
[17:01:06.627]                           has_future <- base::requireNamespace("future", 
[17:01:06.627]                             quietly = TRUE)
[17:01:06.627]                           if (has_future) {
[17:01:06.627]                             ns <- base::getNamespace("future")
[17:01:06.627]                             version <- ns[[".package"]][["version"]]
[17:01:06.627]                             if (is.null(version)) 
[17:01:06.627]                               version <- utils::packageVersion("future")
[17:01:06.627]                           }
[17:01:06.627]                           else {
[17:01:06.627]                             version <- NULL
[17:01:06.627]                           }
[17:01:06.627]                           if (!has_future || version < "1.8.0") {
[17:01:06.627]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:06.627]                               "", base::R.version$version.string), 
[17:01:06.627]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:06.627]                                 base::R.version$platform, 8 * 
[17:01:06.627]                                   base::.Machine$sizeof.pointer), 
[17:01:06.627]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:06.627]                                 "release", "version")], collapse = " "), 
[17:01:06.627]                               hostname = base::Sys.info()[["nodename"]])
[17:01:06.627]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:06.627]                               info)
[17:01:06.627]                             info <- base::paste(info, collapse = "; ")
[17:01:06.627]                             if (!has_future) {
[17:01:06.627]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:06.627]                                 info)
[17:01:06.627]                             }
[17:01:06.627]                             else {
[17:01:06.627]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:06.627]                                 info, version)
[17:01:06.627]                             }
[17:01:06.627]                             base::stop(msg)
[17:01:06.627]                           }
[17:01:06.627]                         })
[17:01:06.627]                       }
[17:01:06.627]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:06.627]                       base::options(mc.cores = 1L)
[17:01:06.627]                     }
[17:01:06.627]                     base::local({
[17:01:06.627]                       for (pkg in "future.apply") {
[17:01:06.627]                         base::loadNamespace(pkg)
[17:01:06.627]                         base::library(pkg, character.only = TRUE)
[17:01:06.627]                       }
[17:01:06.627]                     })
[17:01:06.627]                   }
[17:01:06.627]                   ...future.strategy.old <- future::plan("list")
[17:01:06.627]                   options(future.plan = NULL)
[17:01:06.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:06.627]                 }
[17:01:06.627]                 ...future.workdir <- getwd()
[17:01:06.627]             }
[17:01:06.627]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:06.627]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:06.627]         }
[17:01:06.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:06.627]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:06.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:06.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:06.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:06.627]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:06.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:06.627]             base::names(...future.oldOptions))
[17:01:06.627]     }
[17:01:06.627]     if (FALSE) {
[17:01:06.627]     }
[17:01:06.627]     else {
[17:01:06.627]         if (TRUE) {
[17:01:06.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:06.627]                 open = "w")
[17:01:06.627]         }
[17:01:06.627]         else {
[17:01:06.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:06.627]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:06.627]         }
[17:01:06.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:06.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:06.627]             base::sink(type = "output", split = FALSE)
[17:01:06.627]             base::close(...future.stdout)
[17:01:06.627]         }, add = TRUE)
[17:01:06.627]     }
[17:01:06.627]     ...future.frame <- base::sys.nframe()
[17:01:06.627]     ...future.conditions <- base::list()
[17:01:06.627]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:06.627]     if (FALSE) {
[17:01:06.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:06.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:06.627]     }
[17:01:06.627]     ...future.result <- base::tryCatch({
[17:01:06.627]         base::withCallingHandlers({
[17:01:06.627]             ...future.value <- base::withVisible(base::local({
[17:01:06.627]                 ...future.makeSendCondition <- base::local({
[17:01:06.627]                   sendCondition <- NULL
[17:01:06.627]                   function(frame = 1L) {
[17:01:06.627]                     if (is.function(sendCondition)) 
[17:01:06.627]                       return(sendCondition)
[17:01:06.627]                     ns <- getNamespace("parallel")
[17:01:06.627]                     if (exists("sendData", mode = "function", 
[17:01:06.627]                       envir = ns)) {
[17:01:06.627]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:06.627]                         envir = ns)
[17:01:06.627]                       envir <- sys.frame(frame)
[17:01:06.627]                       master <- NULL
[17:01:06.627]                       while (!identical(envir, .GlobalEnv) && 
[17:01:06.627]                         !identical(envir, emptyenv())) {
[17:01:06.627]                         if (exists("master", mode = "list", envir = envir, 
[17:01:06.627]                           inherits = FALSE)) {
[17:01:06.627]                           master <- get("master", mode = "list", 
[17:01:06.627]                             envir = envir, inherits = FALSE)
[17:01:06.627]                           if (inherits(master, c("SOCKnode", 
[17:01:06.627]                             "SOCK0node"))) {
[17:01:06.627]                             sendCondition <<- function(cond) {
[17:01:06.627]                               data <- list(type = "VALUE", value = cond, 
[17:01:06.627]                                 success = TRUE)
[17:01:06.627]                               parallel_sendData(master, data)
[17:01:06.627]                             }
[17:01:06.627]                             return(sendCondition)
[17:01:06.627]                           }
[17:01:06.627]                         }
[17:01:06.627]                         frame <- frame + 1L
[17:01:06.627]                         envir <- sys.frame(frame)
[17:01:06.627]                       }
[17:01:06.627]                     }
[17:01:06.627]                     sendCondition <<- function(cond) NULL
[17:01:06.627]                   }
[17:01:06.627]                 })
[17:01:06.627]                 withCallingHandlers({
[17:01:06.627]                   {
[17:01:06.627]                     do.call(function(...) {
[17:01:06.627]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.627]                       if (!identical(...future.globals.maxSize.org, 
[17:01:06.627]                         ...future.globals.maxSize)) {
[17:01:06.627]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.627]                         on.exit(options(oopts), add = TRUE)
[17:01:06.627]                       }
[17:01:06.627]                       {
[17:01:06.627]                         lapply(seq_along(...future.elements_ii), 
[17:01:06.627]                           FUN = function(jj) {
[17:01:06.627]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.627]                             ...future.FUN(...future.X_jj, ...)
[17:01:06.627]                           })
[17:01:06.627]                       }
[17:01:06.627]                     }, args = future.call.arguments)
[17:01:06.627]                   }
[17:01:06.627]                 }, immediateCondition = function(cond) {
[17:01:06.627]                   sendCondition <- ...future.makeSendCondition()
[17:01:06.627]                   sendCondition(cond)
[17:01:06.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.627]                   {
[17:01:06.627]                     inherits <- base::inherits
[17:01:06.627]                     invokeRestart <- base::invokeRestart
[17:01:06.627]                     is.null <- base::is.null
[17:01:06.627]                     muffled <- FALSE
[17:01:06.627]                     if (inherits(cond, "message")) {
[17:01:06.627]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:06.627]                       if (muffled) 
[17:01:06.627]                         invokeRestart("muffleMessage")
[17:01:06.627]                     }
[17:01:06.627]                     else if (inherits(cond, "warning")) {
[17:01:06.627]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:06.627]                       if (muffled) 
[17:01:06.627]                         invokeRestart("muffleWarning")
[17:01:06.627]                     }
[17:01:06.627]                     else if (inherits(cond, "condition")) {
[17:01:06.627]                       if (!is.null(pattern)) {
[17:01:06.627]                         computeRestarts <- base::computeRestarts
[17:01:06.627]                         grepl <- base::grepl
[17:01:06.627]                         restarts <- computeRestarts(cond)
[17:01:06.627]                         for (restart in restarts) {
[17:01:06.627]                           name <- restart$name
[17:01:06.627]                           if (is.null(name)) 
[17:01:06.627]                             next
[17:01:06.627]                           if (!grepl(pattern, name)) 
[17:01:06.627]                             next
[17:01:06.627]                           invokeRestart(restart)
[17:01:06.627]                           muffled <- TRUE
[17:01:06.627]                           break
[17:01:06.627]                         }
[17:01:06.627]                       }
[17:01:06.627]                     }
[17:01:06.627]                     invisible(muffled)
[17:01:06.627]                   }
[17:01:06.627]                   muffleCondition(cond)
[17:01:06.627]                 })
[17:01:06.627]             }))
[17:01:06.627]             future::FutureResult(value = ...future.value$value, 
[17:01:06.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.627]                   ...future.rng), globalenv = if (FALSE) 
[17:01:06.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:06.627]                     ...future.globalenv.names))
[17:01:06.627]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:06.627]         }, condition = base::local({
[17:01:06.627]             c <- base::c
[17:01:06.627]             inherits <- base::inherits
[17:01:06.627]             invokeRestart <- base::invokeRestart
[17:01:06.627]             length <- base::length
[17:01:06.627]             list <- base::list
[17:01:06.627]             seq.int <- base::seq.int
[17:01:06.627]             signalCondition <- base::signalCondition
[17:01:06.627]             sys.calls <- base::sys.calls
[17:01:06.627]             `[[` <- base::`[[`
[17:01:06.627]             `+` <- base::`+`
[17:01:06.627]             `<<-` <- base::`<<-`
[17:01:06.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:06.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:06.627]                   3L)]
[17:01:06.627]             }
[17:01:06.627]             function(cond) {
[17:01:06.627]                 is_error <- inherits(cond, "error")
[17:01:06.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:06.627]                   NULL)
[17:01:06.627]                 if (is_error) {
[17:01:06.627]                   sessionInformation <- function() {
[17:01:06.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:06.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:06.627]                       search = base::search(), system = base::Sys.info())
[17:01:06.627]                   }
[17:01:06.627]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:06.627]                     cond$call), session = sessionInformation(), 
[17:01:06.627]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:06.627]                   signalCondition(cond)
[17:01:06.627]                 }
[17:01:06.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:06.627]                 "immediateCondition"))) {
[17:01:06.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:06.627]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:06.627]                   if (TRUE && !signal) {
[17:01:06.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.627]                     {
[17:01:06.627]                       inherits <- base::inherits
[17:01:06.627]                       invokeRestart <- base::invokeRestart
[17:01:06.627]                       is.null <- base::is.null
[17:01:06.627]                       muffled <- FALSE
[17:01:06.627]                       if (inherits(cond, "message")) {
[17:01:06.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.627]                         if (muffled) 
[17:01:06.627]                           invokeRestart("muffleMessage")
[17:01:06.627]                       }
[17:01:06.627]                       else if (inherits(cond, "warning")) {
[17:01:06.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.627]                         if (muffled) 
[17:01:06.627]                           invokeRestart("muffleWarning")
[17:01:06.627]                       }
[17:01:06.627]                       else if (inherits(cond, "condition")) {
[17:01:06.627]                         if (!is.null(pattern)) {
[17:01:06.627]                           computeRestarts <- base::computeRestarts
[17:01:06.627]                           grepl <- base::grepl
[17:01:06.627]                           restarts <- computeRestarts(cond)
[17:01:06.627]                           for (restart in restarts) {
[17:01:06.627]                             name <- restart$name
[17:01:06.627]                             if (is.null(name)) 
[17:01:06.627]                               next
[17:01:06.627]                             if (!grepl(pattern, name)) 
[17:01:06.627]                               next
[17:01:06.627]                             invokeRestart(restart)
[17:01:06.627]                             muffled <- TRUE
[17:01:06.627]                             break
[17:01:06.627]                           }
[17:01:06.627]                         }
[17:01:06.627]                       }
[17:01:06.627]                       invisible(muffled)
[17:01:06.627]                     }
[17:01:06.627]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.627]                   }
[17:01:06.627]                 }
[17:01:06.627]                 else {
[17:01:06.627]                   if (TRUE) {
[17:01:06.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.627]                     {
[17:01:06.627]                       inherits <- base::inherits
[17:01:06.627]                       invokeRestart <- base::invokeRestart
[17:01:06.627]                       is.null <- base::is.null
[17:01:06.627]                       muffled <- FALSE
[17:01:06.627]                       if (inherits(cond, "message")) {
[17:01:06.627]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.627]                         if (muffled) 
[17:01:06.627]                           invokeRestart("muffleMessage")
[17:01:06.627]                       }
[17:01:06.627]                       else if (inherits(cond, "warning")) {
[17:01:06.627]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.627]                         if (muffled) 
[17:01:06.627]                           invokeRestart("muffleWarning")
[17:01:06.627]                       }
[17:01:06.627]                       else if (inherits(cond, "condition")) {
[17:01:06.627]                         if (!is.null(pattern)) {
[17:01:06.627]                           computeRestarts <- base::computeRestarts
[17:01:06.627]                           grepl <- base::grepl
[17:01:06.627]                           restarts <- computeRestarts(cond)
[17:01:06.627]                           for (restart in restarts) {
[17:01:06.627]                             name <- restart$name
[17:01:06.627]                             if (is.null(name)) 
[17:01:06.627]                               next
[17:01:06.627]                             if (!grepl(pattern, name)) 
[17:01:06.627]                               next
[17:01:06.627]                             invokeRestart(restart)
[17:01:06.627]                             muffled <- TRUE
[17:01:06.627]                             break
[17:01:06.627]                           }
[17:01:06.627]                         }
[17:01:06.627]                       }
[17:01:06.627]                       invisible(muffled)
[17:01:06.627]                     }
[17:01:06.627]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.627]                   }
[17:01:06.627]                 }
[17:01:06.627]             }
[17:01:06.627]         }))
[17:01:06.627]     }, error = function(ex) {
[17:01:06.627]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:06.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.627]                 ...future.rng), started = ...future.startTime, 
[17:01:06.627]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:06.627]             version = "1.8"), class = "FutureResult")
[17:01:06.627]     }, finally = {
[17:01:06.627]         if (!identical(...future.workdir, getwd())) 
[17:01:06.627]             setwd(...future.workdir)
[17:01:06.627]         {
[17:01:06.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:06.627]                 ...future.oldOptions$nwarnings <- NULL
[17:01:06.627]             }
[17:01:06.627]             base::options(...future.oldOptions)
[17:01:06.627]             if (.Platform$OS.type == "windows") {
[17:01:06.627]                 old_names <- names(...future.oldEnvVars)
[17:01:06.627]                 envs <- base::Sys.getenv()
[17:01:06.627]                 names <- names(envs)
[17:01:06.627]                 common <- intersect(names, old_names)
[17:01:06.627]                 added <- setdiff(names, old_names)
[17:01:06.627]                 removed <- setdiff(old_names, names)
[17:01:06.627]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:06.627]                   envs[common]]
[17:01:06.627]                 NAMES <- toupper(changed)
[17:01:06.627]                 args <- list()
[17:01:06.627]                 for (kk in seq_along(NAMES)) {
[17:01:06.627]                   name <- changed[[kk]]
[17:01:06.627]                   NAME <- NAMES[[kk]]
[17:01:06.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.627]                     next
[17:01:06.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.627]                 }
[17:01:06.627]                 NAMES <- toupper(added)
[17:01:06.627]                 for (kk in seq_along(NAMES)) {
[17:01:06.627]                   name <- added[[kk]]
[17:01:06.627]                   NAME <- NAMES[[kk]]
[17:01:06.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.627]                     next
[17:01:06.627]                   args[[name]] <- ""
[17:01:06.627]                 }
[17:01:06.627]                 NAMES <- toupper(removed)
[17:01:06.627]                 for (kk in seq_along(NAMES)) {
[17:01:06.627]                   name <- removed[[kk]]
[17:01:06.627]                   NAME <- NAMES[[kk]]
[17:01:06.627]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.627]                     next
[17:01:06.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.627]                 }
[17:01:06.627]                 if (length(args) > 0) 
[17:01:06.627]                   base::do.call(base::Sys.setenv, args = args)
[17:01:06.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:06.627]             }
[17:01:06.627]             else {
[17:01:06.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:06.627]             }
[17:01:06.627]             {
[17:01:06.627]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:06.627]                   0L) {
[17:01:06.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:06.627]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:06.627]                   base::options(opts)
[17:01:06.627]                 }
[17:01:06.627]                 {
[17:01:06.627]                   {
[17:01:06.627]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:06.627]                     NULL
[17:01:06.627]                   }
[17:01:06.627]                   options(future.plan = NULL)
[17:01:06.627]                   if (is.na(NA_character_)) 
[17:01:06.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:06.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:06.627]                     .init = FALSE)
[17:01:06.627]                 }
[17:01:06.627]             }
[17:01:06.627]         }
[17:01:06.627]     })
[17:01:06.627]     if (TRUE) {
[17:01:06.627]         base::sink(type = "output", split = FALSE)
[17:01:06.627]         if (TRUE) {
[17:01:06.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:06.627]         }
[17:01:06.627]         else {
[17:01:06.627]             ...future.result["stdout"] <- base::list(NULL)
[17:01:06.627]         }
[17:01:06.627]         base::close(...future.stdout)
[17:01:06.627]         ...future.stdout <- NULL
[17:01:06.627]     }
[17:01:06.627]     ...future.result$conditions <- ...future.conditions
[17:01:06.627]     ...future.result$finished <- base::Sys.time()
[17:01:06.627]     ...future.result
[17:01:06.627] }
[17:01:06.630] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[17:01:06.630] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:06.672] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:06.672] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[17:01:06.672] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[17:01:06.673] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:06.673] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:06.673] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:06.716] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:06.716] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:06.760] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:06.760] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:06.760] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.760] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:01:06.761] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:01:06.761] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:06.761] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.762] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:01:06.762] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:01:06.762] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:06.763] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.763] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:06.763] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:06.763] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[17:01:06.764] MultisessionFuture started
[17:01:06.764] - Launch lazy future ... done
[17:01:06.764] run() for ‘MultisessionFuture’ ... done
[17:01:06.764] Created future:
[17:01:06.764] MultisessionFuture:
[17:01:06.764] Label: ‘future_vapply-2’
[17:01:06.764] Expression:
[17:01:06.764] {
[17:01:06.764]     do.call(function(...) {
[17:01:06.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.764]             on.exit(options(oopts), add = TRUE)
[17:01:06.764]         }
[17:01:06.764]         {
[17:01:06.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.764]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.764]             })
[17:01:06.764]         }
[17:01:06.764]     }, args = future.call.arguments)
[17:01:06.764] }
[17:01:06.764] Lazy evaluation: FALSE
[17:01:06.764] Asynchronous evaluation: TRUE
[17:01:06.764] Local evaluation: TRUE
[17:01:06.764] Environment: R_GlobalEnv
[17:01:06.764] Capture standard output: TRUE
[17:01:06.764] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:06.764] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:06.764] Packages: 1 packages (‘future.apply’)
[17:01:06.764] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:06.764] Resolved: FALSE
[17:01:06.764] Value: <not collected>
[17:01:06.764] Conditions captured: <none>
[17:01:06.764] Early signaling: FALSE
[17:01:06.764] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:06.764] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.776] Chunk #2 of 2 ... DONE
[17:01:06.776] Launching 2 futures (chunks) ... DONE
[17:01:06.776] Resolving 2 futures (chunks) ...
[17:01:06.776] resolve() on list ...
[17:01:06.777]  recursive: 0
[17:01:06.777]  length: 2
[17:01:06.777] 
[17:01:06.777] receiveMessageFromWorker() for ClusterFuture ...
[17:01:06.777] - Validating connection of MultisessionFuture
[17:01:06.777] - received message: FutureResult
[17:01:06.778] - Received FutureResult
[17:01:06.778] - Erased future from FutureRegistry
[17:01:06.778] result() for ClusterFuture ...
[17:01:06.778] - result already collected: FutureResult
[17:01:06.778] result() for ClusterFuture ... done
[17:01:06.778] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:06.778] Future #1
[17:01:06.778] result() for ClusterFuture ...
[17:01:06.778] - result already collected: FutureResult
[17:01:06.778] result() for ClusterFuture ... done
[17:01:06.778] result() for ClusterFuture ...
[17:01:06.779] - result already collected: FutureResult
[17:01:06.779] result() for ClusterFuture ... done
[17:01:06.779] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:06.779] - nx: 2
[17:01:06.779] - relay: TRUE
[17:01:06.779] - stdout: TRUE
[17:01:06.779] - signal: TRUE
[17:01:06.779] - resignal: FALSE
[17:01:06.779] - force: TRUE
[17:01:06.779] - relayed: [n=2] FALSE, FALSE
[17:01:06.779] - queued futures: [n=2] FALSE, FALSE
[17:01:06.780]  - until=1
[17:01:06.780]  - relaying element #1
[17:01:06.780] result() for ClusterFuture ...
[17:01:06.780] - result already collected: FutureResult
[17:01:06.780] result() for ClusterFuture ... done
[17:01:06.780] result() for ClusterFuture ...
[17:01:06.780] - result already collected: FutureResult
[17:01:06.780] result() for ClusterFuture ... done
[17:01:06.780] result() for ClusterFuture ...
[17:01:06.780] - result already collected: FutureResult
[17:01:06.780] result() for ClusterFuture ... done
[17:01:06.781] result() for ClusterFuture ...
[17:01:06.781] - result already collected: FutureResult
[17:01:06.781] result() for ClusterFuture ... done
[17:01:06.781] - relayed: [n=2] TRUE, FALSE
[17:01:06.781] - queued futures: [n=2] TRUE, FALSE
[17:01:06.781] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:06.781]  length: 1 (resolved future 1)
[17:01:06.809] receiveMessageFromWorker() for ClusterFuture ...
[17:01:06.809] - Validating connection of MultisessionFuture
[17:01:06.809] - received message: FutureResult
[17:01:06.809] - Received FutureResult
[17:01:06.810] - Erased future from FutureRegistry
[17:01:06.810] result() for ClusterFuture ...
[17:01:06.810] - result already collected: FutureResult
[17:01:06.810] result() for ClusterFuture ... done
[17:01:06.810] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:06.810] Future #2
[17:01:06.810] result() for ClusterFuture ...
[17:01:06.810] - result already collected: FutureResult
[17:01:06.810] result() for ClusterFuture ... done
[17:01:06.810] result() for ClusterFuture ...
[17:01:06.811] - result already collected: FutureResult
[17:01:06.811] result() for ClusterFuture ... done
[17:01:06.811] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:06.811] - nx: 2
[17:01:06.811] - relay: TRUE
[17:01:06.811] - stdout: TRUE
[17:01:06.811] - signal: TRUE
[17:01:06.811] - resignal: FALSE
[17:01:06.811] - force: TRUE
[17:01:06.811] - relayed: [n=2] TRUE, FALSE
[17:01:06.811] - queued futures: [n=2] TRUE, FALSE
[17:01:06.812]  - until=2
[17:01:06.812]  - relaying element #2
[17:01:06.812] result() for ClusterFuture ...
[17:01:06.812] - result already collected: FutureResult
[17:01:06.812] result() for ClusterFuture ... done
[17:01:06.812] result() for ClusterFuture ...
[17:01:06.812] - result already collected: FutureResult
[17:01:06.812] result() for ClusterFuture ... done
[17:01:06.812] result() for ClusterFuture ...
[17:01:06.812] - result already collected: FutureResult
[17:01:06.812] result() for ClusterFuture ... done
[17:01:06.813] result() for ClusterFuture ...
[17:01:06.813] - result already collected: FutureResult
[17:01:06.813] result() for ClusterFuture ... done
[17:01:06.813] - relayed: [n=2] TRUE, TRUE
[17:01:06.813] - queued futures: [n=2] TRUE, TRUE
[17:01:06.813] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:06.813]  length: 0 (resolved future 2)
[17:01:06.813] Relaying remaining futures
[17:01:06.813] signalConditionsASAP(NULL, pos=0) ...
[17:01:06.813] - nx: 2
[17:01:06.813] - relay: TRUE
[17:01:06.814] - stdout: TRUE
[17:01:06.814] - signal: TRUE
[17:01:06.814] - resignal: FALSE
[17:01:06.814] - force: TRUE
[17:01:06.814] - relayed: [n=2] TRUE, TRUE
[17:01:06.814] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:06.814] - relayed: [n=2] TRUE, TRUE
[17:01:06.814] - queued futures: [n=2] TRUE, TRUE
[17:01:06.814] signalConditionsASAP(NULL, pos=0) ... done
[17:01:06.814] resolve() on list ... DONE
[17:01:06.814] result() for ClusterFuture ...
[17:01:06.815] - result already collected: FutureResult
[17:01:06.815] result() for ClusterFuture ... done
[17:01:06.815] result() for ClusterFuture ...
[17:01:06.815] - result already collected: FutureResult
[17:01:06.815] result() for ClusterFuture ... done
[17:01:06.815] result() for ClusterFuture ...
[17:01:06.815] - result already collected: FutureResult
[17:01:06.815] result() for ClusterFuture ... done
[17:01:06.815] result() for ClusterFuture ...
[17:01:06.815] - result already collected: FutureResult
[17:01:06.815] result() for ClusterFuture ... done
[17:01:06.816]  - Number of value chunks collected: 2
[17:01:06.816] Resolving 2 futures (chunks) ... DONE
[17:01:06.816] Reducing values from 2 chunks ...
[17:01:06.816]  - Number of values collected after concatenation: 10
[17:01:06.816]  - Number of values expected: 10
[17:01:06.816] Reducing values from 2 chunks ... DONE
[17:01:06.816] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:06.817] future_lapply() ...
[17:01:06.822] Number of chunks: 2
[17:01:06.822] getGlobalsAndPackagesXApply() ...
[17:01:06.822]  - future.globals: TRUE
[17:01:06.823] getGlobalsAndPackages() ...
[17:01:06.823] Searching for globals...
[17:01:06.826] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:06.826] Searching for globals ... DONE
[17:01:06.826] Resolving globals: FALSE
[17:01:06.827] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:01:06.828] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:06.828] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.828] - packages: [1] ‘future.apply’
[17:01:06.828] getGlobalsAndPackages() ... DONE
[17:01:06.828]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:06.828]  - needed namespaces: [n=1] ‘future.apply’
[17:01:06.828] Finding globals ... DONE
[17:01:06.828]  - use_args: TRUE
[17:01:06.828]  - Getting '...' globals ...
[17:01:06.829] resolve() on list ...
[17:01:06.829]  recursive: 0
[17:01:06.829]  length: 1
[17:01:06.829]  elements: ‘...’
[17:01:06.829]  length: 0 (resolved future 1)
[17:01:06.829] resolve() on list ... DONE
[17:01:06.829]    - '...' content: [n=0] 
[17:01:06.829] List of 1
[17:01:06.829]  $ ...: list()
[17:01:06.829]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.829]  - attr(*, "where")=List of 1
[17:01:06.829]   ..$ ...:<environment: 0x55aadc458cf8> 
[17:01:06.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.829]  - attr(*, "resolved")= logi TRUE
[17:01:06.829]  - attr(*, "total_size")= num NA
[17:01:06.832]  - Getting '...' globals ... DONE
[17:01:06.832] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:06.832] List of 8
[17:01:06.832]  $ ...future.FUN:function (x, ...)  
[17:01:06.832]  $ x_FUN        :function (x)  
[17:01:06.832]  $ times        : int 4
[17:01:06.832]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:06.832]  $ stop_if_not  :function (...)  
[17:01:06.832]  $ dim          : int [1:2] 2 2
[17:01:06.832]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:06.832]  $ ...          : list()
[17:01:06.832]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:06.832]  - attr(*, "where")=List of 8
[17:01:06.832]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:06.832]   ..$ ...          :<environment: 0x55aadc458cf8> 
[17:01:06.832]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:06.832]  - attr(*, "resolved")= logi FALSE
[17:01:06.832]  - attr(*, "total_size")= num 97232
[17:01:06.837] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:06.837] getGlobalsAndPackagesXApply() ... DONE
[17:01:06.838] Number of futures (= number of chunks): 2
[17:01:06.838] Launching 2 futures (chunks) ...
[17:01:06.838] Chunk #1 of 2 ...
[17:01:06.838]  - Finding globals in 'X' for chunk #1 ...
[17:01:06.838] getGlobalsAndPackages() ...
[17:01:06.838] Searching for globals...
[17:01:06.838] 
[17:01:06.838] Searching for globals ... DONE
[17:01:06.839] - globals: [0] <none>
[17:01:06.839] getGlobalsAndPackages() ... DONE
[17:01:06.839]    + additional globals found: [n=0] 
[17:01:06.839]    + additional namespaces needed: [n=0] 
[17:01:06.839]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:06.839]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:06.839]  - seeds: <none>
[17:01:06.839]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.839] getGlobalsAndPackages() ...
[17:01:06.839] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.840] Resolving globals: FALSE
[17:01:06.840] Tweak future expression to call with '...' arguments ...
[17:01:06.840] {
[17:01:06.840]     do.call(function(...) {
[17:01:06.840]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.840]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:06.840]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.840]             on.exit(options(oopts), add = TRUE)
[17:01:06.840]         }
[17:01:06.840]         {
[17:01:06.840]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:06.840]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.840]                 ...future.FUN(...future.X_jj, ...)
[17:01:06.840]             })
[17:01:06.840]         }
[17:01:06.840]     }, args = future.call.arguments)
[17:01:06.840] }
[17:01:06.840] Tweak future expression to call with '...' arguments ... DONE
[17:01:06.840] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:06.841] - packages: [1] ‘future.apply’
[17:01:06.841] getGlobalsAndPackages() ... DONE
[17:01:06.841] run() for ‘Future’ ...
[17:01:06.841] - state: ‘created’
[17:01:06.841] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:06.859] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:06.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:06.860]   - Field: ‘node’
[17:01:06.860]   - Field: ‘label’
[17:01:06.860]   - Field: ‘local’
[17:01:06.860]   - Field: ‘owner’
[17:01:06.860]   - Field: ‘envir’
[17:01:06.861]   - Field: ‘workers’
[17:01:06.861]   - Field: ‘packages’
[17:01:06.861]   - Field: ‘gc’
[17:01:06.861]   - Field: ‘conditions’
[17:01:06.861]   - Field: ‘persistent’
[17:01:06.861]   - Field: ‘expr’
[17:01:06.862]   - Field: ‘uuid’
[17:01:06.862]   - Field: ‘seed’
[17:01:06.862]   - Field: ‘version’
[17:01:06.862]   - Field: ‘result’
[17:01:06.862]   - Field: ‘asynchronous’
[17:01:06.862]   - Field: ‘calls’
[17:01:06.863]   - Field: ‘globals’
[17:01:06.863]   - Field: ‘stdout’
[17:01:06.863]   - Field: ‘earlySignal’
[17:01:06.863]   - Field: ‘lazy’
[17:01:06.863]   - Field: ‘state’
[17:01:06.864] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:06.864] - Launch lazy future ...
[17:01:06.864] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:06.864] Packages needed by future strategies (n = 0): <none>
[17:01:06.865] {
[17:01:06.865]     {
[17:01:06.865]         {
[17:01:06.865]             ...future.startTime <- base::Sys.time()
[17:01:06.865]             {
[17:01:06.865]                 {
[17:01:06.865]                   {
[17:01:06.865]                     {
[17:01:06.865]                       {
[17:01:06.865]                         base::local({
[17:01:06.865]                           has_future <- base::requireNamespace("future", 
[17:01:06.865]                             quietly = TRUE)
[17:01:06.865]                           if (has_future) {
[17:01:06.865]                             ns <- base::getNamespace("future")
[17:01:06.865]                             version <- ns[[".package"]][["version"]]
[17:01:06.865]                             if (is.null(version)) 
[17:01:06.865]                               version <- utils::packageVersion("future")
[17:01:06.865]                           }
[17:01:06.865]                           else {
[17:01:06.865]                             version <- NULL
[17:01:06.865]                           }
[17:01:06.865]                           if (!has_future || version < "1.8.0") {
[17:01:06.865]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:06.865]                               "", base::R.version$version.string), 
[17:01:06.865]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:06.865]                                 base::R.version$platform, 8 * 
[17:01:06.865]                                   base::.Machine$sizeof.pointer), 
[17:01:06.865]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:06.865]                                 "release", "version")], collapse = " "), 
[17:01:06.865]                               hostname = base::Sys.info()[["nodename"]])
[17:01:06.865]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:06.865]                               info)
[17:01:06.865]                             info <- base::paste(info, collapse = "; ")
[17:01:06.865]                             if (!has_future) {
[17:01:06.865]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:06.865]                                 info)
[17:01:06.865]                             }
[17:01:06.865]                             else {
[17:01:06.865]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:06.865]                                 info, version)
[17:01:06.865]                             }
[17:01:06.865]                             base::stop(msg)
[17:01:06.865]                           }
[17:01:06.865]                         })
[17:01:06.865]                       }
[17:01:06.865]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:06.865]                       base::options(mc.cores = 1L)
[17:01:06.865]                     }
[17:01:06.865]                     base::local({
[17:01:06.865]                       for (pkg in "future.apply") {
[17:01:06.865]                         base::loadNamespace(pkg)
[17:01:06.865]                         base::library(pkg, character.only = TRUE)
[17:01:06.865]                       }
[17:01:06.865]                     })
[17:01:06.865]                   }
[17:01:06.865]                   ...future.strategy.old <- future::plan("list")
[17:01:06.865]                   options(future.plan = NULL)
[17:01:06.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:06.865]                 }
[17:01:06.865]                 ...future.workdir <- getwd()
[17:01:06.865]             }
[17:01:06.865]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:06.865]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:06.865]         }
[17:01:06.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:06.865]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:06.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:06.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:06.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:06.865]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:06.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:06.865]             base::names(...future.oldOptions))
[17:01:06.865]     }
[17:01:06.865]     if (FALSE) {
[17:01:06.865]     }
[17:01:06.865]     else {
[17:01:06.865]         if (TRUE) {
[17:01:06.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:06.865]                 open = "w")
[17:01:06.865]         }
[17:01:06.865]         else {
[17:01:06.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:06.865]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:06.865]         }
[17:01:06.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:06.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:06.865]             base::sink(type = "output", split = FALSE)
[17:01:06.865]             base::close(...future.stdout)
[17:01:06.865]         }, add = TRUE)
[17:01:06.865]     }
[17:01:06.865]     ...future.frame <- base::sys.nframe()
[17:01:06.865]     ...future.conditions <- base::list()
[17:01:06.865]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:06.865]     if (FALSE) {
[17:01:06.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:06.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:06.865]     }
[17:01:06.865]     ...future.result <- base::tryCatch({
[17:01:06.865]         base::withCallingHandlers({
[17:01:06.865]             ...future.value <- base::withVisible(base::local({
[17:01:06.865]                 ...future.makeSendCondition <- base::local({
[17:01:06.865]                   sendCondition <- NULL
[17:01:06.865]                   function(frame = 1L) {
[17:01:06.865]                     if (is.function(sendCondition)) 
[17:01:06.865]                       return(sendCondition)
[17:01:06.865]                     ns <- getNamespace("parallel")
[17:01:06.865]                     if (exists("sendData", mode = "function", 
[17:01:06.865]                       envir = ns)) {
[17:01:06.865]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:06.865]                         envir = ns)
[17:01:06.865]                       envir <- sys.frame(frame)
[17:01:06.865]                       master <- NULL
[17:01:06.865]                       while (!identical(envir, .GlobalEnv) && 
[17:01:06.865]                         !identical(envir, emptyenv())) {
[17:01:06.865]                         if (exists("master", mode = "list", envir = envir, 
[17:01:06.865]                           inherits = FALSE)) {
[17:01:06.865]                           master <- get("master", mode = "list", 
[17:01:06.865]                             envir = envir, inherits = FALSE)
[17:01:06.865]                           if (inherits(master, c("SOCKnode", 
[17:01:06.865]                             "SOCK0node"))) {
[17:01:06.865]                             sendCondition <<- function(cond) {
[17:01:06.865]                               data <- list(type = "VALUE", value = cond, 
[17:01:06.865]                                 success = TRUE)
[17:01:06.865]                               parallel_sendData(master, data)
[17:01:06.865]                             }
[17:01:06.865]                             return(sendCondition)
[17:01:06.865]                           }
[17:01:06.865]                         }
[17:01:06.865]                         frame <- frame + 1L
[17:01:06.865]                         envir <- sys.frame(frame)
[17:01:06.865]                       }
[17:01:06.865]                     }
[17:01:06.865]                     sendCondition <<- function(cond) NULL
[17:01:06.865]                   }
[17:01:06.865]                 })
[17:01:06.865]                 withCallingHandlers({
[17:01:06.865]                   {
[17:01:06.865]                     do.call(function(...) {
[17:01:06.865]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:06.865]                       if (!identical(...future.globals.maxSize.org, 
[17:01:06.865]                         ...future.globals.maxSize)) {
[17:01:06.865]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:06.865]                         on.exit(options(oopts), add = TRUE)
[17:01:06.865]                       }
[17:01:06.865]                       {
[17:01:06.865]                         lapply(seq_along(...future.elements_ii), 
[17:01:06.865]                           FUN = function(jj) {
[17:01:06.865]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:06.865]                             ...future.FUN(...future.X_jj, ...)
[17:01:06.865]                           })
[17:01:06.865]                       }
[17:01:06.865]                     }, args = future.call.arguments)
[17:01:06.865]                   }
[17:01:06.865]                 }, immediateCondition = function(cond) {
[17:01:06.865]                   sendCondition <- ...future.makeSendCondition()
[17:01:06.865]                   sendCondition(cond)
[17:01:06.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.865]                   {
[17:01:06.865]                     inherits <- base::inherits
[17:01:06.865]                     invokeRestart <- base::invokeRestart
[17:01:06.865]                     is.null <- base::is.null
[17:01:06.865]                     muffled <- FALSE
[17:01:06.865]                     if (inherits(cond, "message")) {
[17:01:06.865]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:06.865]                       if (muffled) 
[17:01:06.865]                         invokeRestart("muffleMessage")
[17:01:06.865]                     }
[17:01:06.865]                     else if (inherits(cond, "warning")) {
[17:01:06.865]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:06.865]                       if (muffled) 
[17:01:06.865]                         invokeRestart("muffleWarning")
[17:01:06.865]                     }
[17:01:06.865]                     else if (inherits(cond, "condition")) {
[17:01:06.865]                       if (!is.null(pattern)) {
[17:01:06.865]                         computeRestarts <- base::computeRestarts
[17:01:06.865]                         grepl <- base::grepl
[17:01:06.865]                         restarts <- computeRestarts(cond)
[17:01:06.865]                         for (restart in restarts) {
[17:01:06.865]                           name <- restart$name
[17:01:06.865]                           if (is.null(name)) 
[17:01:06.865]                             next
[17:01:06.865]                           if (!grepl(pattern, name)) 
[17:01:06.865]                             next
[17:01:06.865]                           invokeRestart(restart)
[17:01:06.865]                           muffled <- TRUE
[17:01:06.865]                           break
[17:01:06.865]                         }
[17:01:06.865]                       }
[17:01:06.865]                     }
[17:01:06.865]                     invisible(muffled)
[17:01:06.865]                   }
[17:01:06.865]                   muffleCondition(cond)
[17:01:06.865]                 })
[17:01:06.865]             }))
[17:01:06.865]             future::FutureResult(value = ...future.value$value, 
[17:01:06.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.865]                   ...future.rng), globalenv = if (FALSE) 
[17:01:06.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:06.865]                     ...future.globalenv.names))
[17:01:06.865]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:06.865]         }, condition = base::local({
[17:01:06.865]             c <- base::c
[17:01:06.865]             inherits <- base::inherits
[17:01:06.865]             invokeRestart <- base::invokeRestart
[17:01:06.865]             length <- base::length
[17:01:06.865]             list <- base::list
[17:01:06.865]             seq.int <- base::seq.int
[17:01:06.865]             signalCondition <- base::signalCondition
[17:01:06.865]             sys.calls <- base::sys.calls
[17:01:06.865]             `[[` <- base::`[[`
[17:01:06.865]             `+` <- base::`+`
[17:01:06.865]             `<<-` <- base::`<<-`
[17:01:06.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:06.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:06.865]                   3L)]
[17:01:06.865]             }
[17:01:06.865]             function(cond) {
[17:01:06.865]                 is_error <- inherits(cond, "error")
[17:01:06.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:06.865]                   NULL)
[17:01:06.865]                 if (is_error) {
[17:01:06.865]                   sessionInformation <- function() {
[17:01:06.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:06.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:06.865]                       search = base::search(), system = base::Sys.info())
[17:01:06.865]                   }
[17:01:06.865]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:06.865]                     cond$call), session = sessionInformation(), 
[17:01:06.865]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:06.865]                   signalCondition(cond)
[17:01:06.865]                 }
[17:01:06.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:06.865]                 "immediateCondition"))) {
[17:01:06.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:06.865]                   ...future.conditions[[length(...future.conditions) + 
[17:01:06.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:06.865]                   if (TRUE && !signal) {
[17:01:06.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.865]                     {
[17:01:06.865]                       inherits <- base::inherits
[17:01:06.865]                       invokeRestart <- base::invokeRestart
[17:01:06.865]                       is.null <- base::is.null
[17:01:06.865]                       muffled <- FALSE
[17:01:06.865]                       if (inherits(cond, "message")) {
[17:01:06.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.865]                         if (muffled) 
[17:01:06.865]                           invokeRestart("muffleMessage")
[17:01:06.865]                       }
[17:01:06.865]                       else if (inherits(cond, "warning")) {
[17:01:06.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.865]                         if (muffled) 
[17:01:06.865]                           invokeRestart("muffleWarning")
[17:01:06.865]                       }
[17:01:06.865]                       else if (inherits(cond, "condition")) {
[17:01:06.865]                         if (!is.null(pattern)) {
[17:01:06.865]                           computeRestarts <- base::computeRestarts
[17:01:06.865]                           grepl <- base::grepl
[17:01:06.865]                           restarts <- computeRestarts(cond)
[17:01:06.865]                           for (restart in restarts) {
[17:01:06.865]                             name <- restart$name
[17:01:06.865]                             if (is.null(name)) 
[17:01:06.865]                               next
[17:01:06.865]                             if (!grepl(pattern, name)) 
[17:01:06.865]                               next
[17:01:06.865]                             invokeRestart(restart)
[17:01:06.865]                             muffled <- TRUE
[17:01:06.865]                             break
[17:01:06.865]                           }
[17:01:06.865]                         }
[17:01:06.865]                       }
[17:01:06.865]                       invisible(muffled)
[17:01:06.865]                     }
[17:01:06.865]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.865]                   }
[17:01:06.865]                 }
[17:01:06.865]                 else {
[17:01:06.865]                   if (TRUE) {
[17:01:06.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:06.865]                     {
[17:01:06.865]                       inherits <- base::inherits
[17:01:06.865]                       invokeRestart <- base::invokeRestart
[17:01:06.865]                       is.null <- base::is.null
[17:01:06.865]                       muffled <- FALSE
[17:01:06.865]                       if (inherits(cond, "message")) {
[17:01:06.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:06.865]                         if (muffled) 
[17:01:06.865]                           invokeRestart("muffleMessage")
[17:01:06.865]                       }
[17:01:06.865]                       else if (inherits(cond, "warning")) {
[17:01:06.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:06.865]                         if (muffled) 
[17:01:06.865]                           invokeRestart("muffleWarning")
[17:01:06.865]                       }
[17:01:06.865]                       else if (inherits(cond, "condition")) {
[17:01:06.865]                         if (!is.null(pattern)) {
[17:01:06.865]                           computeRestarts <- base::computeRestarts
[17:01:06.865]                           grepl <- base::grepl
[17:01:06.865]                           restarts <- computeRestarts(cond)
[17:01:06.865]                           for (restart in restarts) {
[17:01:06.865]                             name <- restart$name
[17:01:06.865]                             if (is.null(name)) 
[17:01:06.865]                               next
[17:01:06.865]                             if (!grepl(pattern, name)) 
[17:01:06.865]                               next
[17:01:06.865]                             invokeRestart(restart)
[17:01:06.865]                             muffled <- TRUE
[17:01:06.865]                             break
[17:01:06.865]                           }
[17:01:06.865]                         }
[17:01:06.865]                       }
[17:01:06.865]                       invisible(muffled)
[17:01:06.865]                     }
[17:01:06.865]                     muffleCondition(cond, pattern = "^muffle")
[17:01:06.865]                   }
[17:01:06.865]                 }
[17:01:06.865]             }
[17:01:06.865]         }))
[17:01:06.865]     }, error = function(ex) {
[17:01:06.865]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:06.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:06.865]                 ...future.rng), started = ...future.startTime, 
[17:01:06.865]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:06.865]             version = "1.8"), class = "FutureResult")
[17:01:06.865]     }, finally = {
[17:01:06.865]         if (!identical(...future.workdir, getwd())) 
[17:01:06.865]             setwd(...future.workdir)
[17:01:06.865]         {
[17:01:06.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:06.865]                 ...future.oldOptions$nwarnings <- NULL
[17:01:06.865]             }
[17:01:06.865]             base::options(...future.oldOptions)
[17:01:06.865]             if (.Platform$OS.type == "windows") {
[17:01:06.865]                 old_names <- names(...future.oldEnvVars)
[17:01:06.865]                 envs <- base::Sys.getenv()
[17:01:06.865]                 names <- names(envs)
[17:01:06.865]                 common <- intersect(names, old_names)
[17:01:06.865]                 added <- setdiff(names, old_names)
[17:01:06.865]                 removed <- setdiff(old_names, names)
[17:01:06.865]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:06.865]                   envs[common]]
[17:01:06.865]                 NAMES <- toupper(changed)
[17:01:06.865]                 args <- list()
[17:01:06.865]                 for (kk in seq_along(NAMES)) {
[17:01:06.865]                   name <- changed[[kk]]
[17:01:06.865]                   NAME <- NAMES[[kk]]
[17:01:06.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.865]                     next
[17:01:06.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.865]                 }
[17:01:06.865]                 NAMES <- toupper(added)
[17:01:06.865]                 for (kk in seq_along(NAMES)) {
[17:01:06.865]                   name <- added[[kk]]
[17:01:06.865]                   NAME <- NAMES[[kk]]
[17:01:06.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.865]                     next
[17:01:06.865]                   args[[name]] <- ""
[17:01:06.865]                 }
[17:01:06.865]                 NAMES <- toupper(removed)
[17:01:06.865]                 for (kk in seq_along(NAMES)) {
[17:01:06.865]                   name <- removed[[kk]]
[17:01:06.865]                   NAME <- NAMES[[kk]]
[17:01:06.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:06.865]                     next
[17:01:06.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:06.865]                 }
[17:01:06.865]                 if (length(args) > 0) 
[17:01:06.865]                   base::do.call(base::Sys.setenv, args = args)
[17:01:06.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:06.865]             }
[17:01:06.865]             else {
[17:01:06.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:06.865]             }
[17:01:06.865]             {
[17:01:06.865]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:06.865]                   0L) {
[17:01:06.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:06.865]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:06.865]                   base::options(opts)
[17:01:06.865]                 }
[17:01:06.865]                 {
[17:01:06.865]                   {
[17:01:06.865]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:06.865]                     NULL
[17:01:06.865]                   }
[17:01:06.865]                   options(future.plan = NULL)
[17:01:06.865]                   if (is.na(NA_character_)) 
[17:01:06.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:06.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:06.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:06.865]                     .init = FALSE)
[17:01:06.865]                 }
[17:01:06.865]             }
[17:01:06.865]         }
[17:01:06.865]     })
[17:01:06.865]     if (TRUE) {
[17:01:06.865]         base::sink(type = "output", split = FALSE)
[17:01:06.865]         if (TRUE) {
[17:01:06.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:06.865]         }
[17:01:06.865]         else {
[17:01:06.865]             ...future.result["stdout"] <- base::list(NULL)
[17:01:06.865]         }
[17:01:06.865]         base::close(...future.stdout)
[17:01:06.865]         ...future.stdout <- NULL
[17:01:06.865]     }
[17:01:06.865]     ...future.result$conditions <- ...future.conditions
[17:01:06.865]     ...future.result$finished <- base::Sys.time()
[17:01:06.865]     ...future.result
[17:01:06.865] }
[17:01:06.870] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[17:01:06.870] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:06.912] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:06.912] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:01:06.912] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:01:06.913] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:06.913] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:06.913] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:06.956] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:06.956] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:07.000] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:07.000] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:07.000] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.001] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:01:07.001] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:01:07.001] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:07.002] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.002] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:07.002] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:07.002] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:07.002] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.003] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:07.003] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.003] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[17:01:07.003] MultisessionFuture started
[17:01:07.004] - Launch lazy future ... done
[17:01:07.004] run() for ‘MultisessionFuture’ ... done
[17:01:07.004] Created future:
[17:01:07.004] MultisessionFuture:
[17:01:07.004] Label: ‘future_vapply-1’
[17:01:07.004] Expression:
[17:01:07.004] {
[17:01:07.004]     do.call(function(...) {
[17:01:07.004]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.004]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.004]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.004]             on.exit(options(oopts), add = TRUE)
[17:01:07.004]         }
[17:01:07.004]         {
[17:01:07.004]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.004]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.004]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.004]             })
[17:01:07.004]         }
[17:01:07.004]     }, args = future.call.arguments)
[17:01:07.004] }
[17:01:07.004] Lazy evaluation: FALSE
[17:01:07.004] Asynchronous evaluation: TRUE
[17:01:07.004] Local evaluation: TRUE
[17:01:07.004] Environment: R_GlobalEnv
[17:01:07.004] Capture standard output: TRUE
[17:01:07.004] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.004] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.004] Packages: 1 packages (‘future.apply’)
[17:01:07.004] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.004] Resolved: FALSE
[17:01:07.004] Value: <not collected>
[17:01:07.004] Conditions captured: <none>
[17:01:07.004] Early signaling: FALSE
[17:01:07.004] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.004] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.016] Chunk #1 of 2 ... DONE
[17:01:07.016] Chunk #2 of 2 ...
[17:01:07.016]  - Finding globals in 'X' for chunk #2 ...
[17:01:07.016] getGlobalsAndPackages() ...
[17:01:07.016] Searching for globals...
[17:01:07.016] 
[17:01:07.017] Searching for globals ... DONE
[17:01:07.017] - globals: [0] <none>
[17:01:07.017] getGlobalsAndPackages() ... DONE
[17:01:07.017]    + additional globals found: [n=0] 
[17:01:07.017]    + additional namespaces needed: [n=0] 
[17:01:07.017]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:07.017]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:07.017]  - seeds: <none>
[17:01:07.017]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.017] getGlobalsAndPackages() ...
[17:01:07.017] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.018] Resolving globals: FALSE
[17:01:07.018] Tweak future expression to call with '...' arguments ...
[17:01:07.018] {
[17:01:07.018]     do.call(function(...) {
[17:01:07.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.018]             on.exit(options(oopts), add = TRUE)
[17:01:07.018]         }
[17:01:07.018]         {
[17:01:07.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.018]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.018]             })
[17:01:07.018]         }
[17:01:07.018]     }, args = future.call.arguments)
[17:01:07.018] }
[17:01:07.018] Tweak future expression to call with '...' arguments ... DONE
[17:01:07.019] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.019] - packages: [1] ‘future.apply’
[17:01:07.019] getGlobalsAndPackages() ... DONE
[17:01:07.019] run() for ‘Future’ ...
[17:01:07.019] - state: ‘created’
[17:01:07.019] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:07.033] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:07.034]   - Field: ‘node’
[17:01:07.034]   - Field: ‘label’
[17:01:07.034]   - Field: ‘local’
[17:01:07.034]   - Field: ‘owner’
[17:01:07.034]   - Field: ‘envir’
[17:01:07.034]   - Field: ‘workers’
[17:01:07.034]   - Field: ‘packages’
[17:01:07.034]   - Field: ‘gc’
[17:01:07.034]   - Field: ‘conditions’
[17:01:07.034]   - Field: ‘persistent’
[17:01:07.035]   - Field: ‘expr’
[17:01:07.035]   - Field: ‘uuid’
[17:01:07.035]   - Field: ‘seed’
[17:01:07.035]   - Field: ‘version’
[17:01:07.035]   - Field: ‘result’
[17:01:07.035]   - Field: ‘asynchronous’
[17:01:07.035]   - Field: ‘calls’
[17:01:07.035]   - Field: ‘globals’
[17:01:07.035]   - Field: ‘stdout’
[17:01:07.035]   - Field: ‘earlySignal’
[17:01:07.035]   - Field: ‘lazy’
[17:01:07.036]   - Field: ‘state’
[17:01:07.036] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:07.036] - Launch lazy future ...
[17:01:07.036] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:07.036] Packages needed by future strategies (n = 0): <none>
[17:01:07.037] {
[17:01:07.037]     {
[17:01:07.037]         {
[17:01:07.037]             ...future.startTime <- base::Sys.time()
[17:01:07.037]             {
[17:01:07.037]                 {
[17:01:07.037]                   {
[17:01:07.037]                     {
[17:01:07.037]                       {
[17:01:07.037]                         base::local({
[17:01:07.037]                           has_future <- base::requireNamespace("future", 
[17:01:07.037]                             quietly = TRUE)
[17:01:07.037]                           if (has_future) {
[17:01:07.037]                             ns <- base::getNamespace("future")
[17:01:07.037]                             version <- ns[[".package"]][["version"]]
[17:01:07.037]                             if (is.null(version)) 
[17:01:07.037]                               version <- utils::packageVersion("future")
[17:01:07.037]                           }
[17:01:07.037]                           else {
[17:01:07.037]                             version <- NULL
[17:01:07.037]                           }
[17:01:07.037]                           if (!has_future || version < "1.8.0") {
[17:01:07.037]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:07.037]                               "", base::R.version$version.string), 
[17:01:07.037]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:07.037]                                 base::R.version$platform, 8 * 
[17:01:07.037]                                   base::.Machine$sizeof.pointer), 
[17:01:07.037]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:07.037]                                 "release", "version")], collapse = " "), 
[17:01:07.037]                               hostname = base::Sys.info()[["nodename"]])
[17:01:07.037]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:07.037]                               info)
[17:01:07.037]                             info <- base::paste(info, collapse = "; ")
[17:01:07.037]                             if (!has_future) {
[17:01:07.037]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:07.037]                                 info)
[17:01:07.037]                             }
[17:01:07.037]                             else {
[17:01:07.037]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:07.037]                                 info, version)
[17:01:07.037]                             }
[17:01:07.037]                             base::stop(msg)
[17:01:07.037]                           }
[17:01:07.037]                         })
[17:01:07.037]                       }
[17:01:07.037]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:07.037]                       base::options(mc.cores = 1L)
[17:01:07.037]                     }
[17:01:07.037]                     base::local({
[17:01:07.037]                       for (pkg in "future.apply") {
[17:01:07.037]                         base::loadNamespace(pkg)
[17:01:07.037]                         base::library(pkg, character.only = TRUE)
[17:01:07.037]                       }
[17:01:07.037]                     })
[17:01:07.037]                   }
[17:01:07.037]                   ...future.strategy.old <- future::plan("list")
[17:01:07.037]                   options(future.plan = NULL)
[17:01:07.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:07.037]                 }
[17:01:07.037]                 ...future.workdir <- getwd()
[17:01:07.037]             }
[17:01:07.037]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:07.037]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:07.037]         }
[17:01:07.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:07.037]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:07.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:07.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:07.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:07.037]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:07.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:07.037]             base::names(...future.oldOptions))
[17:01:07.037]     }
[17:01:07.037]     if (FALSE) {
[17:01:07.037]     }
[17:01:07.037]     else {
[17:01:07.037]         if (TRUE) {
[17:01:07.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:07.037]                 open = "w")
[17:01:07.037]         }
[17:01:07.037]         else {
[17:01:07.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:07.037]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:07.037]         }
[17:01:07.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:07.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:07.037]             base::sink(type = "output", split = FALSE)
[17:01:07.037]             base::close(...future.stdout)
[17:01:07.037]         }, add = TRUE)
[17:01:07.037]     }
[17:01:07.037]     ...future.frame <- base::sys.nframe()
[17:01:07.037]     ...future.conditions <- base::list()
[17:01:07.037]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:07.037]     if (FALSE) {
[17:01:07.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:07.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:07.037]     }
[17:01:07.037]     ...future.result <- base::tryCatch({
[17:01:07.037]         base::withCallingHandlers({
[17:01:07.037]             ...future.value <- base::withVisible(base::local({
[17:01:07.037]                 ...future.makeSendCondition <- base::local({
[17:01:07.037]                   sendCondition <- NULL
[17:01:07.037]                   function(frame = 1L) {
[17:01:07.037]                     if (is.function(sendCondition)) 
[17:01:07.037]                       return(sendCondition)
[17:01:07.037]                     ns <- getNamespace("parallel")
[17:01:07.037]                     if (exists("sendData", mode = "function", 
[17:01:07.037]                       envir = ns)) {
[17:01:07.037]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:07.037]                         envir = ns)
[17:01:07.037]                       envir <- sys.frame(frame)
[17:01:07.037]                       master <- NULL
[17:01:07.037]                       while (!identical(envir, .GlobalEnv) && 
[17:01:07.037]                         !identical(envir, emptyenv())) {
[17:01:07.037]                         if (exists("master", mode = "list", envir = envir, 
[17:01:07.037]                           inherits = FALSE)) {
[17:01:07.037]                           master <- get("master", mode = "list", 
[17:01:07.037]                             envir = envir, inherits = FALSE)
[17:01:07.037]                           if (inherits(master, c("SOCKnode", 
[17:01:07.037]                             "SOCK0node"))) {
[17:01:07.037]                             sendCondition <<- function(cond) {
[17:01:07.037]                               data <- list(type = "VALUE", value = cond, 
[17:01:07.037]                                 success = TRUE)
[17:01:07.037]                               parallel_sendData(master, data)
[17:01:07.037]                             }
[17:01:07.037]                             return(sendCondition)
[17:01:07.037]                           }
[17:01:07.037]                         }
[17:01:07.037]                         frame <- frame + 1L
[17:01:07.037]                         envir <- sys.frame(frame)
[17:01:07.037]                       }
[17:01:07.037]                     }
[17:01:07.037]                     sendCondition <<- function(cond) NULL
[17:01:07.037]                   }
[17:01:07.037]                 })
[17:01:07.037]                 withCallingHandlers({
[17:01:07.037]                   {
[17:01:07.037]                     do.call(function(...) {
[17:01:07.037]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.037]                       if (!identical(...future.globals.maxSize.org, 
[17:01:07.037]                         ...future.globals.maxSize)) {
[17:01:07.037]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.037]                         on.exit(options(oopts), add = TRUE)
[17:01:07.037]                       }
[17:01:07.037]                       {
[17:01:07.037]                         lapply(seq_along(...future.elements_ii), 
[17:01:07.037]                           FUN = function(jj) {
[17:01:07.037]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.037]                             ...future.FUN(...future.X_jj, ...)
[17:01:07.037]                           })
[17:01:07.037]                       }
[17:01:07.037]                     }, args = future.call.arguments)
[17:01:07.037]                   }
[17:01:07.037]                 }, immediateCondition = function(cond) {
[17:01:07.037]                   sendCondition <- ...future.makeSendCondition()
[17:01:07.037]                   sendCondition(cond)
[17:01:07.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.037]                   {
[17:01:07.037]                     inherits <- base::inherits
[17:01:07.037]                     invokeRestart <- base::invokeRestart
[17:01:07.037]                     is.null <- base::is.null
[17:01:07.037]                     muffled <- FALSE
[17:01:07.037]                     if (inherits(cond, "message")) {
[17:01:07.037]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:07.037]                       if (muffled) 
[17:01:07.037]                         invokeRestart("muffleMessage")
[17:01:07.037]                     }
[17:01:07.037]                     else if (inherits(cond, "warning")) {
[17:01:07.037]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:07.037]                       if (muffled) 
[17:01:07.037]                         invokeRestart("muffleWarning")
[17:01:07.037]                     }
[17:01:07.037]                     else if (inherits(cond, "condition")) {
[17:01:07.037]                       if (!is.null(pattern)) {
[17:01:07.037]                         computeRestarts <- base::computeRestarts
[17:01:07.037]                         grepl <- base::grepl
[17:01:07.037]                         restarts <- computeRestarts(cond)
[17:01:07.037]                         for (restart in restarts) {
[17:01:07.037]                           name <- restart$name
[17:01:07.037]                           if (is.null(name)) 
[17:01:07.037]                             next
[17:01:07.037]                           if (!grepl(pattern, name)) 
[17:01:07.037]                             next
[17:01:07.037]                           invokeRestart(restart)
[17:01:07.037]                           muffled <- TRUE
[17:01:07.037]                           break
[17:01:07.037]                         }
[17:01:07.037]                       }
[17:01:07.037]                     }
[17:01:07.037]                     invisible(muffled)
[17:01:07.037]                   }
[17:01:07.037]                   muffleCondition(cond)
[17:01:07.037]                 })
[17:01:07.037]             }))
[17:01:07.037]             future::FutureResult(value = ...future.value$value, 
[17:01:07.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.037]                   ...future.rng), globalenv = if (FALSE) 
[17:01:07.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:07.037]                     ...future.globalenv.names))
[17:01:07.037]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:07.037]         }, condition = base::local({
[17:01:07.037]             c <- base::c
[17:01:07.037]             inherits <- base::inherits
[17:01:07.037]             invokeRestart <- base::invokeRestart
[17:01:07.037]             length <- base::length
[17:01:07.037]             list <- base::list
[17:01:07.037]             seq.int <- base::seq.int
[17:01:07.037]             signalCondition <- base::signalCondition
[17:01:07.037]             sys.calls <- base::sys.calls
[17:01:07.037]             `[[` <- base::`[[`
[17:01:07.037]             `+` <- base::`+`
[17:01:07.037]             `<<-` <- base::`<<-`
[17:01:07.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:07.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:07.037]                   3L)]
[17:01:07.037]             }
[17:01:07.037]             function(cond) {
[17:01:07.037]                 is_error <- inherits(cond, "error")
[17:01:07.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:07.037]                   NULL)
[17:01:07.037]                 if (is_error) {
[17:01:07.037]                   sessionInformation <- function() {
[17:01:07.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:07.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:07.037]                       search = base::search(), system = base::Sys.info())
[17:01:07.037]                   }
[17:01:07.037]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:07.037]                     cond$call), session = sessionInformation(), 
[17:01:07.037]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:07.037]                   signalCondition(cond)
[17:01:07.037]                 }
[17:01:07.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:07.037]                 "immediateCondition"))) {
[17:01:07.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:07.037]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:07.037]                   if (TRUE && !signal) {
[17:01:07.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.037]                     {
[17:01:07.037]                       inherits <- base::inherits
[17:01:07.037]                       invokeRestart <- base::invokeRestart
[17:01:07.037]                       is.null <- base::is.null
[17:01:07.037]                       muffled <- FALSE
[17:01:07.037]                       if (inherits(cond, "message")) {
[17:01:07.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.037]                         if (muffled) 
[17:01:07.037]                           invokeRestart("muffleMessage")
[17:01:07.037]                       }
[17:01:07.037]                       else if (inherits(cond, "warning")) {
[17:01:07.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.037]                         if (muffled) 
[17:01:07.037]                           invokeRestart("muffleWarning")
[17:01:07.037]                       }
[17:01:07.037]                       else if (inherits(cond, "condition")) {
[17:01:07.037]                         if (!is.null(pattern)) {
[17:01:07.037]                           computeRestarts <- base::computeRestarts
[17:01:07.037]                           grepl <- base::grepl
[17:01:07.037]                           restarts <- computeRestarts(cond)
[17:01:07.037]                           for (restart in restarts) {
[17:01:07.037]                             name <- restart$name
[17:01:07.037]                             if (is.null(name)) 
[17:01:07.037]                               next
[17:01:07.037]                             if (!grepl(pattern, name)) 
[17:01:07.037]                               next
[17:01:07.037]                             invokeRestart(restart)
[17:01:07.037]                             muffled <- TRUE
[17:01:07.037]                             break
[17:01:07.037]                           }
[17:01:07.037]                         }
[17:01:07.037]                       }
[17:01:07.037]                       invisible(muffled)
[17:01:07.037]                     }
[17:01:07.037]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.037]                   }
[17:01:07.037]                 }
[17:01:07.037]                 else {
[17:01:07.037]                   if (TRUE) {
[17:01:07.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.037]                     {
[17:01:07.037]                       inherits <- base::inherits
[17:01:07.037]                       invokeRestart <- base::invokeRestart
[17:01:07.037]                       is.null <- base::is.null
[17:01:07.037]                       muffled <- FALSE
[17:01:07.037]                       if (inherits(cond, "message")) {
[17:01:07.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.037]                         if (muffled) 
[17:01:07.037]                           invokeRestart("muffleMessage")
[17:01:07.037]                       }
[17:01:07.037]                       else if (inherits(cond, "warning")) {
[17:01:07.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.037]                         if (muffled) 
[17:01:07.037]                           invokeRestart("muffleWarning")
[17:01:07.037]                       }
[17:01:07.037]                       else if (inherits(cond, "condition")) {
[17:01:07.037]                         if (!is.null(pattern)) {
[17:01:07.037]                           computeRestarts <- base::computeRestarts
[17:01:07.037]                           grepl <- base::grepl
[17:01:07.037]                           restarts <- computeRestarts(cond)
[17:01:07.037]                           for (restart in restarts) {
[17:01:07.037]                             name <- restart$name
[17:01:07.037]                             if (is.null(name)) 
[17:01:07.037]                               next
[17:01:07.037]                             if (!grepl(pattern, name)) 
[17:01:07.037]                               next
[17:01:07.037]                             invokeRestart(restart)
[17:01:07.037]                             muffled <- TRUE
[17:01:07.037]                             break
[17:01:07.037]                           }
[17:01:07.037]                         }
[17:01:07.037]                       }
[17:01:07.037]                       invisible(muffled)
[17:01:07.037]                     }
[17:01:07.037]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.037]                   }
[17:01:07.037]                 }
[17:01:07.037]             }
[17:01:07.037]         }))
[17:01:07.037]     }, error = function(ex) {
[17:01:07.037]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:07.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.037]                 ...future.rng), started = ...future.startTime, 
[17:01:07.037]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:07.037]             version = "1.8"), class = "FutureResult")
[17:01:07.037]     }, finally = {
[17:01:07.037]         if (!identical(...future.workdir, getwd())) 
[17:01:07.037]             setwd(...future.workdir)
[17:01:07.037]         {
[17:01:07.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:07.037]                 ...future.oldOptions$nwarnings <- NULL
[17:01:07.037]             }
[17:01:07.037]             base::options(...future.oldOptions)
[17:01:07.037]             if (.Platform$OS.type == "windows") {
[17:01:07.037]                 old_names <- names(...future.oldEnvVars)
[17:01:07.037]                 envs <- base::Sys.getenv()
[17:01:07.037]                 names <- names(envs)
[17:01:07.037]                 common <- intersect(names, old_names)
[17:01:07.037]                 added <- setdiff(names, old_names)
[17:01:07.037]                 removed <- setdiff(old_names, names)
[17:01:07.037]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:07.037]                   envs[common]]
[17:01:07.037]                 NAMES <- toupper(changed)
[17:01:07.037]                 args <- list()
[17:01:07.037]                 for (kk in seq_along(NAMES)) {
[17:01:07.037]                   name <- changed[[kk]]
[17:01:07.037]                   NAME <- NAMES[[kk]]
[17:01:07.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.037]                     next
[17:01:07.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.037]                 }
[17:01:07.037]                 NAMES <- toupper(added)
[17:01:07.037]                 for (kk in seq_along(NAMES)) {
[17:01:07.037]                   name <- added[[kk]]
[17:01:07.037]                   NAME <- NAMES[[kk]]
[17:01:07.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.037]                     next
[17:01:07.037]                   args[[name]] <- ""
[17:01:07.037]                 }
[17:01:07.037]                 NAMES <- toupper(removed)
[17:01:07.037]                 for (kk in seq_along(NAMES)) {
[17:01:07.037]                   name <- removed[[kk]]
[17:01:07.037]                   NAME <- NAMES[[kk]]
[17:01:07.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.037]                     next
[17:01:07.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.037]                 }
[17:01:07.037]                 if (length(args) > 0) 
[17:01:07.037]                   base::do.call(base::Sys.setenv, args = args)
[17:01:07.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:07.037]             }
[17:01:07.037]             else {
[17:01:07.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:07.037]             }
[17:01:07.037]             {
[17:01:07.037]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:07.037]                   0L) {
[17:01:07.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:07.037]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:07.037]                   base::options(opts)
[17:01:07.037]                 }
[17:01:07.037]                 {
[17:01:07.037]                   {
[17:01:07.037]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:07.037]                     NULL
[17:01:07.037]                   }
[17:01:07.037]                   options(future.plan = NULL)
[17:01:07.037]                   if (is.na(NA_character_)) 
[17:01:07.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:07.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:07.037]                     .init = FALSE)
[17:01:07.037]                 }
[17:01:07.037]             }
[17:01:07.037]         }
[17:01:07.037]     })
[17:01:07.037]     if (TRUE) {
[17:01:07.037]         base::sink(type = "output", split = FALSE)
[17:01:07.037]         if (TRUE) {
[17:01:07.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:07.037]         }
[17:01:07.037]         else {
[17:01:07.037]             ...future.result["stdout"] <- base::list(NULL)
[17:01:07.037]         }
[17:01:07.037]         base::close(...future.stdout)
[17:01:07.037]         ...future.stdout <- NULL
[17:01:07.037]     }
[17:01:07.037]     ...future.result$conditions <- ...future.conditions
[17:01:07.037]     ...future.result$finished <- base::Sys.time()
[17:01:07.037]     ...future.result
[17:01:07.037] }
[17:01:07.039] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[17:01:07.040] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:07.084] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:07.084] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[17:01:07.085] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[17:01:07.085] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:07.085] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:07.085] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:07.128] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:07.128] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:07.172] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:07.172] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:01:07.172] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:01:07.173] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:01:07.173] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:01:07.173] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:07.174] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.174] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:01:07.174] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:01:07.174] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:07.175] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.175] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:07.175] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.175] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[17:01:07.176] MultisessionFuture started
[17:01:07.176] - Launch lazy future ... done
[17:01:07.176] run() for ‘MultisessionFuture’ ... done
[17:01:07.176] Created future:
[17:01:07.177] MultisessionFuture:
[17:01:07.177] Label: ‘future_vapply-2’
[17:01:07.177] Expression:
[17:01:07.177] {
[17:01:07.177]     do.call(function(...) {
[17:01:07.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.177]             on.exit(options(oopts), add = TRUE)
[17:01:07.177]         }
[17:01:07.177]         {
[17:01:07.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.177]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.177]             })
[17:01:07.177]         }
[17:01:07.177]     }, args = future.call.arguments)
[17:01:07.177] }
[17:01:07.177] Lazy evaluation: FALSE
[17:01:07.177] Asynchronous evaluation: TRUE
[17:01:07.177] Local evaluation: TRUE
[17:01:07.177] Environment: R_GlobalEnv
[17:01:07.177] Capture standard output: TRUE
[17:01:07.177] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.177] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.177] Packages: 1 packages (‘future.apply’)
[17:01:07.177] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.177] Resolved: FALSE
[17:01:07.177] Value: <not collected>
[17:01:07.177] Conditions captured: <none>
[17:01:07.177] Early signaling: FALSE
[17:01:07.177] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.177] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.188] Chunk #2 of 2 ... DONE
[17:01:07.188] Launching 2 futures (chunks) ... DONE
[17:01:07.189] Resolving 2 futures (chunks) ...
[17:01:07.189] resolve() on list ...
[17:01:07.189]  recursive: 0
[17:01:07.189]  length: 2
[17:01:07.189] 
[17:01:07.189] receiveMessageFromWorker() for ClusterFuture ...
[17:01:07.189] - Validating connection of MultisessionFuture
[17:01:07.190] - received message: FutureResult
[17:01:07.190] - Received FutureResult
[17:01:07.190] - Erased future from FutureRegistry
[17:01:07.190] result() for ClusterFuture ...
[17:01:07.190] - result already collected: FutureResult
[17:01:07.190] result() for ClusterFuture ... done
[17:01:07.190] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:07.190] Future #1
[17:01:07.190] result() for ClusterFuture ...
[17:01:07.190] - result already collected: FutureResult
[17:01:07.191] result() for ClusterFuture ... done
[17:01:07.191] result() for ClusterFuture ...
[17:01:07.191] - result already collected: FutureResult
[17:01:07.191] result() for ClusterFuture ... done
[17:01:07.191] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:07.191] - nx: 2
[17:01:07.191] - relay: TRUE
[17:01:07.191] - stdout: TRUE
[17:01:07.191] - signal: TRUE
[17:01:07.191] - resignal: FALSE
[17:01:07.191] - force: TRUE
[17:01:07.192] - relayed: [n=2] FALSE, FALSE
[17:01:07.192] - queued futures: [n=2] FALSE, FALSE
[17:01:07.192]  - until=1
[17:01:07.192]  - relaying element #1
[17:01:07.192] result() for ClusterFuture ...
[17:01:07.192] - result already collected: FutureResult
[17:01:07.192] result() for ClusterFuture ... done
[17:01:07.192] result() for ClusterFuture ...
[17:01:07.192] - result already collected: FutureResult
[17:01:07.192] result() for ClusterFuture ... done
[17:01:07.192] result() for ClusterFuture ...
[17:01:07.192] - result already collected: FutureResult
[17:01:07.193] result() for ClusterFuture ... done
[17:01:07.193] result() for ClusterFuture ...
[17:01:07.193] - result already collected: FutureResult
[17:01:07.193] result() for ClusterFuture ... done
[17:01:07.193] - relayed: [n=2] TRUE, FALSE
[17:01:07.193] - queued futures: [n=2] TRUE, FALSE
[17:01:07.193] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:07.193]  length: 1 (resolved future 1)
[17:01:07.221] receiveMessageFromWorker() for ClusterFuture ...
[17:01:07.221] - Validating connection of MultisessionFuture
[17:01:07.222] - received message: FutureResult
[17:01:07.222] - Received FutureResult
[17:01:07.222] - Erased future from FutureRegistry
[17:01:07.222] result() for ClusterFuture ...
[17:01:07.222] - result already collected: FutureResult
[17:01:07.222] result() for ClusterFuture ... done
[17:01:07.222] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:07.222] Future #2
[17:01:07.222] result() for ClusterFuture ...
[17:01:07.225] - result already collected: FutureResult
[17:01:07.225] result() for ClusterFuture ... done
[17:01:07.225] result() for ClusterFuture ...
[17:01:07.225] - result already collected: FutureResult
[17:01:07.225] result() for ClusterFuture ... done
[17:01:07.225] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:07.225] - nx: 2
[17:01:07.225] - relay: TRUE
[17:01:07.226] - stdout: TRUE
[17:01:07.226] - signal: TRUE
[17:01:07.226] - resignal: FALSE
[17:01:07.226] - force: TRUE
[17:01:07.226] - relayed: [n=2] TRUE, FALSE
[17:01:07.226] - queued futures: [n=2] TRUE, FALSE
[17:01:07.226]  - until=2
[17:01:07.226]  - relaying element #2
[17:01:07.226] result() for ClusterFuture ...
[17:01:07.226] - result already collected: FutureResult
[17:01:07.226] result() for ClusterFuture ... done
[17:01:07.226] result() for ClusterFuture ...
[17:01:07.226] - result already collected: FutureResult
[17:01:07.227] result() for ClusterFuture ... done
[17:01:07.227] result() for ClusterFuture ...
[17:01:07.227] - result already collected: FutureResult
[17:01:07.227] result() for ClusterFuture ... done
[17:01:07.227] result() for ClusterFuture ...
[17:01:07.227] - result already collected: FutureResult
[17:01:07.227] result() for ClusterFuture ... done
[17:01:07.227] - relayed: [n=2] TRUE, TRUE
[17:01:07.227] - queued futures: [n=2] TRUE, TRUE
[17:01:07.227] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:07.227]  length: 0 (resolved future 2)
[17:01:07.228] Relaying remaining futures
[17:01:07.228] signalConditionsASAP(NULL, pos=0) ...
[17:01:07.228] - nx: 2
[17:01:07.228] - relay: TRUE
[17:01:07.228] - stdout: TRUE
[17:01:07.228] - signal: TRUE
[17:01:07.228] - resignal: FALSE
[17:01:07.228] - force: TRUE
[17:01:07.228] - relayed: [n=2] TRUE, TRUE
[17:01:07.228] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:07.228] - relayed: [n=2] TRUE, TRUE
[17:01:07.229] - queued futures: [n=2] TRUE, TRUE
[17:01:07.229] signalConditionsASAP(NULL, pos=0) ... done
[17:01:07.229] resolve() on list ... DONE
[17:01:07.229] result() for ClusterFuture ...
[17:01:07.229] - result already collected: FutureResult
[17:01:07.229] result() for ClusterFuture ... done
[17:01:07.229] result() for ClusterFuture ...
[17:01:07.229] - result already collected: FutureResult
[17:01:07.229] result() for ClusterFuture ... done
[17:01:07.229] result() for ClusterFuture ...
[17:01:07.229] - result already collected: FutureResult
[17:01:07.229] result() for ClusterFuture ... done
[17:01:07.230] result() for ClusterFuture ...
[17:01:07.230] - result already collected: FutureResult
[17:01:07.230] result() for ClusterFuture ... done
[17:01:07.230]  - Number of value chunks collected: 2
[17:01:07.230] Resolving 2 futures (chunks) ... DONE
[17:01:07.230] Reducing values from 2 chunks ...
[17:01:07.230]  - Number of values collected after concatenation: 10
[17:01:07.230]  - Number of values expected: 10
[17:01:07.230] Reducing values from 2 chunks ... DONE
[17:01:07.230] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:01:07.231] future_lapply() ...
[17:01:07.237] Number of chunks: 2
[17:01:07.237] getGlobalsAndPackagesXApply() ...
[17:01:07.237]  - future.globals: TRUE
[17:01:07.237] getGlobalsAndPackages() ...
[17:01:07.237] Searching for globals...
[17:01:07.241] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:01:07.241] Searching for globals ... DONE
[17:01:07.241] Resolving globals: FALSE
[17:01:07.242] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:01:07.242] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:07.243] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:07.243] - packages: [1] ‘future.apply’
[17:01:07.243] getGlobalsAndPackages() ... DONE
[17:01:07.243]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:07.243]  - needed namespaces: [n=1] ‘future.apply’
[17:01:07.243] Finding globals ... DONE
[17:01:07.243]  - use_args: TRUE
[17:01:07.243]  - Getting '...' globals ...
[17:01:07.244] resolve() on list ...
[17:01:07.244]  recursive: 0
[17:01:07.244]  length: 1
[17:01:07.244]  elements: ‘...’
[17:01:07.244]  length: 0 (resolved future 1)
[17:01:07.244] resolve() on list ... DONE
[17:01:07.244]    - '...' content: [n=0] 
[17:01:07.244] List of 1
[17:01:07.244]  $ ...: list()
[17:01:07.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:07.244]  - attr(*, "where")=List of 1
[17:01:07.244]   ..$ ...:<environment: 0x55aadb6b9388> 
[17:01:07.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:07.244]  - attr(*, "resolved")= logi TRUE
[17:01:07.244]  - attr(*, "total_size")= num NA
[17:01:07.247]  - Getting '...' globals ... DONE
[17:01:07.247] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:07.247] List of 8
[17:01:07.247]  $ ...future.FUN:function (x, ...)  
[17:01:07.247]  $ x_FUN        :function (x)  
[17:01:07.247]  $ times        : int 4
[17:01:07.247]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:07.247]  $ stop_if_not  :function (...)  
[17:01:07.247]  $ dim          : int [1:2] 2 2
[17:01:07.247]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:07.247]  $ ...          : list()
[17:01:07.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:07.247]  - attr(*, "where")=List of 8
[17:01:07.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:07.247]   ..$ ...          :<environment: 0x55aadb6b9388> 
[17:01:07.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:07.247]  - attr(*, "resolved")= logi FALSE
[17:01:07.247]  - attr(*, "total_size")= num 97304
[17:01:07.253] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:07.253] getGlobalsAndPackagesXApply() ... DONE
[17:01:07.253] Number of futures (= number of chunks): 2
[17:01:07.253] Launching 2 futures (chunks) ...
[17:01:07.253] Chunk #1 of 2 ...
[17:01:07.253]  - Finding globals in 'X' for chunk #1 ...
[17:01:07.253] getGlobalsAndPackages() ...
[17:01:07.253] Searching for globals...
[17:01:07.254] 
[17:01:07.254] Searching for globals ... DONE
[17:01:07.254] - globals: [0] <none>
[17:01:07.254] getGlobalsAndPackages() ... DONE
[17:01:07.254]    + additional globals found: [n=0] 
[17:01:07.254]    + additional namespaces needed: [n=0] 
[17:01:07.254]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:07.254]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:07.254]  - seeds: <none>
[17:01:07.254]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.255] getGlobalsAndPackages() ...
[17:01:07.255] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.255] Resolving globals: FALSE
[17:01:07.255] Tweak future expression to call with '...' arguments ...
[17:01:07.255] {
[17:01:07.255]     do.call(function(...) {
[17:01:07.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.255]             on.exit(options(oopts), add = TRUE)
[17:01:07.255]         }
[17:01:07.255]         {
[17:01:07.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.255]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.255]             })
[17:01:07.255]         }
[17:01:07.255]     }, args = future.call.arguments)
[17:01:07.255] }
[17:01:07.255] Tweak future expression to call with '...' arguments ... DONE
[17:01:07.256] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.256] - packages: [1] ‘future.apply’
[17:01:07.256] getGlobalsAndPackages() ... DONE
[17:01:07.256] run() for ‘Future’ ...
[17:01:07.256] - state: ‘created’
[17:01:07.257] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:07.271] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:07.271]   - Field: ‘node’
[17:01:07.271]   - Field: ‘label’
[17:01:07.271]   - Field: ‘local’
[17:01:07.271]   - Field: ‘owner’
[17:01:07.271]   - Field: ‘envir’
[17:01:07.271]   - Field: ‘workers’
[17:01:07.271]   - Field: ‘packages’
[17:01:07.272]   - Field: ‘gc’
[17:01:07.272]   - Field: ‘conditions’
[17:01:07.272]   - Field: ‘persistent’
[17:01:07.272]   - Field: ‘expr’
[17:01:07.272]   - Field: ‘uuid’
[17:01:07.272]   - Field: ‘seed’
[17:01:07.272]   - Field: ‘version’
[17:01:07.272]   - Field: ‘result’
[17:01:07.272]   - Field: ‘asynchronous’
[17:01:07.272]   - Field: ‘calls’
[17:01:07.272]   - Field: ‘globals’
[17:01:07.273]   - Field: ‘stdout’
[17:01:07.273]   - Field: ‘earlySignal’
[17:01:07.273]   - Field: ‘lazy’
[17:01:07.273]   - Field: ‘state’
[17:01:07.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:07.273] - Launch lazy future ...
[17:01:07.273] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:07.273] Packages needed by future strategies (n = 0): <none>
[17:01:07.274] {
[17:01:07.274]     {
[17:01:07.274]         {
[17:01:07.274]             ...future.startTime <- base::Sys.time()
[17:01:07.274]             {
[17:01:07.274]                 {
[17:01:07.274]                   {
[17:01:07.274]                     {
[17:01:07.274]                       {
[17:01:07.274]                         base::local({
[17:01:07.274]                           has_future <- base::requireNamespace("future", 
[17:01:07.274]                             quietly = TRUE)
[17:01:07.274]                           if (has_future) {
[17:01:07.274]                             ns <- base::getNamespace("future")
[17:01:07.274]                             version <- ns[[".package"]][["version"]]
[17:01:07.274]                             if (is.null(version)) 
[17:01:07.274]                               version <- utils::packageVersion("future")
[17:01:07.274]                           }
[17:01:07.274]                           else {
[17:01:07.274]                             version <- NULL
[17:01:07.274]                           }
[17:01:07.274]                           if (!has_future || version < "1.8.0") {
[17:01:07.274]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:07.274]                               "", base::R.version$version.string), 
[17:01:07.274]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:07.274]                                 base::R.version$platform, 8 * 
[17:01:07.274]                                   base::.Machine$sizeof.pointer), 
[17:01:07.274]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:07.274]                                 "release", "version")], collapse = " "), 
[17:01:07.274]                               hostname = base::Sys.info()[["nodename"]])
[17:01:07.274]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:07.274]                               info)
[17:01:07.274]                             info <- base::paste(info, collapse = "; ")
[17:01:07.274]                             if (!has_future) {
[17:01:07.274]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:07.274]                                 info)
[17:01:07.274]                             }
[17:01:07.274]                             else {
[17:01:07.274]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:07.274]                                 info, version)
[17:01:07.274]                             }
[17:01:07.274]                             base::stop(msg)
[17:01:07.274]                           }
[17:01:07.274]                         })
[17:01:07.274]                       }
[17:01:07.274]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:07.274]                       base::options(mc.cores = 1L)
[17:01:07.274]                     }
[17:01:07.274]                     base::local({
[17:01:07.274]                       for (pkg in "future.apply") {
[17:01:07.274]                         base::loadNamespace(pkg)
[17:01:07.274]                         base::library(pkg, character.only = TRUE)
[17:01:07.274]                       }
[17:01:07.274]                     })
[17:01:07.274]                   }
[17:01:07.274]                   ...future.strategy.old <- future::plan("list")
[17:01:07.274]                   options(future.plan = NULL)
[17:01:07.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:07.274]                 }
[17:01:07.274]                 ...future.workdir <- getwd()
[17:01:07.274]             }
[17:01:07.274]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:07.274]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:07.274]         }
[17:01:07.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:07.274]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:07.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:07.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:07.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:07.274]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:07.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:07.274]             base::names(...future.oldOptions))
[17:01:07.274]     }
[17:01:07.274]     if (FALSE) {
[17:01:07.274]     }
[17:01:07.274]     else {
[17:01:07.274]         if (TRUE) {
[17:01:07.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:07.274]                 open = "w")
[17:01:07.274]         }
[17:01:07.274]         else {
[17:01:07.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:07.274]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:07.274]         }
[17:01:07.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:07.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:07.274]             base::sink(type = "output", split = FALSE)
[17:01:07.274]             base::close(...future.stdout)
[17:01:07.274]         }, add = TRUE)
[17:01:07.274]     }
[17:01:07.274]     ...future.frame <- base::sys.nframe()
[17:01:07.274]     ...future.conditions <- base::list()
[17:01:07.274]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:07.274]     if (FALSE) {
[17:01:07.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:07.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:07.274]     }
[17:01:07.274]     ...future.result <- base::tryCatch({
[17:01:07.274]         base::withCallingHandlers({
[17:01:07.274]             ...future.value <- base::withVisible(base::local({
[17:01:07.274]                 ...future.makeSendCondition <- base::local({
[17:01:07.274]                   sendCondition <- NULL
[17:01:07.274]                   function(frame = 1L) {
[17:01:07.274]                     if (is.function(sendCondition)) 
[17:01:07.274]                       return(sendCondition)
[17:01:07.274]                     ns <- getNamespace("parallel")
[17:01:07.274]                     if (exists("sendData", mode = "function", 
[17:01:07.274]                       envir = ns)) {
[17:01:07.274]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:07.274]                         envir = ns)
[17:01:07.274]                       envir <- sys.frame(frame)
[17:01:07.274]                       master <- NULL
[17:01:07.274]                       while (!identical(envir, .GlobalEnv) && 
[17:01:07.274]                         !identical(envir, emptyenv())) {
[17:01:07.274]                         if (exists("master", mode = "list", envir = envir, 
[17:01:07.274]                           inherits = FALSE)) {
[17:01:07.274]                           master <- get("master", mode = "list", 
[17:01:07.274]                             envir = envir, inherits = FALSE)
[17:01:07.274]                           if (inherits(master, c("SOCKnode", 
[17:01:07.274]                             "SOCK0node"))) {
[17:01:07.274]                             sendCondition <<- function(cond) {
[17:01:07.274]                               data <- list(type = "VALUE", value = cond, 
[17:01:07.274]                                 success = TRUE)
[17:01:07.274]                               parallel_sendData(master, data)
[17:01:07.274]                             }
[17:01:07.274]                             return(sendCondition)
[17:01:07.274]                           }
[17:01:07.274]                         }
[17:01:07.274]                         frame <- frame + 1L
[17:01:07.274]                         envir <- sys.frame(frame)
[17:01:07.274]                       }
[17:01:07.274]                     }
[17:01:07.274]                     sendCondition <<- function(cond) NULL
[17:01:07.274]                   }
[17:01:07.274]                 })
[17:01:07.274]                 withCallingHandlers({
[17:01:07.274]                   {
[17:01:07.274]                     do.call(function(...) {
[17:01:07.274]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.274]                       if (!identical(...future.globals.maxSize.org, 
[17:01:07.274]                         ...future.globals.maxSize)) {
[17:01:07.274]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.274]                         on.exit(options(oopts), add = TRUE)
[17:01:07.274]                       }
[17:01:07.274]                       {
[17:01:07.274]                         lapply(seq_along(...future.elements_ii), 
[17:01:07.274]                           FUN = function(jj) {
[17:01:07.274]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.274]                             ...future.FUN(...future.X_jj, ...)
[17:01:07.274]                           })
[17:01:07.274]                       }
[17:01:07.274]                     }, args = future.call.arguments)
[17:01:07.274]                   }
[17:01:07.274]                 }, immediateCondition = function(cond) {
[17:01:07.274]                   sendCondition <- ...future.makeSendCondition()
[17:01:07.274]                   sendCondition(cond)
[17:01:07.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.274]                   {
[17:01:07.274]                     inherits <- base::inherits
[17:01:07.274]                     invokeRestart <- base::invokeRestart
[17:01:07.274]                     is.null <- base::is.null
[17:01:07.274]                     muffled <- FALSE
[17:01:07.274]                     if (inherits(cond, "message")) {
[17:01:07.274]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:07.274]                       if (muffled) 
[17:01:07.274]                         invokeRestart("muffleMessage")
[17:01:07.274]                     }
[17:01:07.274]                     else if (inherits(cond, "warning")) {
[17:01:07.274]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:07.274]                       if (muffled) 
[17:01:07.274]                         invokeRestart("muffleWarning")
[17:01:07.274]                     }
[17:01:07.274]                     else if (inherits(cond, "condition")) {
[17:01:07.274]                       if (!is.null(pattern)) {
[17:01:07.274]                         computeRestarts <- base::computeRestarts
[17:01:07.274]                         grepl <- base::grepl
[17:01:07.274]                         restarts <- computeRestarts(cond)
[17:01:07.274]                         for (restart in restarts) {
[17:01:07.274]                           name <- restart$name
[17:01:07.274]                           if (is.null(name)) 
[17:01:07.274]                             next
[17:01:07.274]                           if (!grepl(pattern, name)) 
[17:01:07.274]                             next
[17:01:07.274]                           invokeRestart(restart)
[17:01:07.274]                           muffled <- TRUE
[17:01:07.274]                           break
[17:01:07.274]                         }
[17:01:07.274]                       }
[17:01:07.274]                     }
[17:01:07.274]                     invisible(muffled)
[17:01:07.274]                   }
[17:01:07.274]                   muffleCondition(cond)
[17:01:07.274]                 })
[17:01:07.274]             }))
[17:01:07.274]             future::FutureResult(value = ...future.value$value, 
[17:01:07.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.274]                   ...future.rng), globalenv = if (FALSE) 
[17:01:07.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:07.274]                     ...future.globalenv.names))
[17:01:07.274]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:07.274]         }, condition = base::local({
[17:01:07.274]             c <- base::c
[17:01:07.274]             inherits <- base::inherits
[17:01:07.274]             invokeRestart <- base::invokeRestart
[17:01:07.274]             length <- base::length
[17:01:07.274]             list <- base::list
[17:01:07.274]             seq.int <- base::seq.int
[17:01:07.274]             signalCondition <- base::signalCondition
[17:01:07.274]             sys.calls <- base::sys.calls
[17:01:07.274]             `[[` <- base::`[[`
[17:01:07.274]             `+` <- base::`+`
[17:01:07.274]             `<<-` <- base::`<<-`
[17:01:07.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:07.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:07.274]                   3L)]
[17:01:07.274]             }
[17:01:07.274]             function(cond) {
[17:01:07.274]                 is_error <- inherits(cond, "error")
[17:01:07.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:07.274]                   NULL)
[17:01:07.274]                 if (is_error) {
[17:01:07.274]                   sessionInformation <- function() {
[17:01:07.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:07.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:07.274]                       search = base::search(), system = base::Sys.info())
[17:01:07.274]                   }
[17:01:07.274]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:07.274]                     cond$call), session = sessionInformation(), 
[17:01:07.274]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:07.274]                   signalCondition(cond)
[17:01:07.274]                 }
[17:01:07.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:07.274]                 "immediateCondition"))) {
[17:01:07.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:07.274]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:07.274]                   if (TRUE && !signal) {
[17:01:07.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.274]                     {
[17:01:07.274]                       inherits <- base::inherits
[17:01:07.274]                       invokeRestart <- base::invokeRestart
[17:01:07.274]                       is.null <- base::is.null
[17:01:07.274]                       muffled <- FALSE
[17:01:07.274]                       if (inherits(cond, "message")) {
[17:01:07.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.274]                         if (muffled) 
[17:01:07.274]                           invokeRestart("muffleMessage")
[17:01:07.274]                       }
[17:01:07.274]                       else if (inherits(cond, "warning")) {
[17:01:07.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.274]                         if (muffled) 
[17:01:07.274]                           invokeRestart("muffleWarning")
[17:01:07.274]                       }
[17:01:07.274]                       else if (inherits(cond, "condition")) {
[17:01:07.274]                         if (!is.null(pattern)) {
[17:01:07.274]                           computeRestarts <- base::computeRestarts
[17:01:07.274]                           grepl <- base::grepl
[17:01:07.274]                           restarts <- computeRestarts(cond)
[17:01:07.274]                           for (restart in restarts) {
[17:01:07.274]                             name <- restart$name
[17:01:07.274]                             if (is.null(name)) 
[17:01:07.274]                               next
[17:01:07.274]                             if (!grepl(pattern, name)) 
[17:01:07.274]                               next
[17:01:07.274]                             invokeRestart(restart)
[17:01:07.274]                             muffled <- TRUE
[17:01:07.274]                             break
[17:01:07.274]                           }
[17:01:07.274]                         }
[17:01:07.274]                       }
[17:01:07.274]                       invisible(muffled)
[17:01:07.274]                     }
[17:01:07.274]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.274]                   }
[17:01:07.274]                 }
[17:01:07.274]                 else {
[17:01:07.274]                   if (TRUE) {
[17:01:07.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.274]                     {
[17:01:07.274]                       inherits <- base::inherits
[17:01:07.274]                       invokeRestart <- base::invokeRestart
[17:01:07.274]                       is.null <- base::is.null
[17:01:07.274]                       muffled <- FALSE
[17:01:07.274]                       if (inherits(cond, "message")) {
[17:01:07.274]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.274]                         if (muffled) 
[17:01:07.274]                           invokeRestart("muffleMessage")
[17:01:07.274]                       }
[17:01:07.274]                       else if (inherits(cond, "warning")) {
[17:01:07.274]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.274]                         if (muffled) 
[17:01:07.274]                           invokeRestart("muffleWarning")
[17:01:07.274]                       }
[17:01:07.274]                       else if (inherits(cond, "condition")) {
[17:01:07.274]                         if (!is.null(pattern)) {
[17:01:07.274]                           computeRestarts <- base::computeRestarts
[17:01:07.274]                           grepl <- base::grepl
[17:01:07.274]                           restarts <- computeRestarts(cond)
[17:01:07.274]                           for (restart in restarts) {
[17:01:07.274]                             name <- restart$name
[17:01:07.274]                             if (is.null(name)) 
[17:01:07.274]                               next
[17:01:07.274]                             if (!grepl(pattern, name)) 
[17:01:07.274]                               next
[17:01:07.274]                             invokeRestart(restart)
[17:01:07.274]                             muffled <- TRUE
[17:01:07.274]                             break
[17:01:07.274]                           }
[17:01:07.274]                         }
[17:01:07.274]                       }
[17:01:07.274]                       invisible(muffled)
[17:01:07.274]                     }
[17:01:07.274]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.274]                   }
[17:01:07.274]                 }
[17:01:07.274]             }
[17:01:07.274]         }))
[17:01:07.274]     }, error = function(ex) {
[17:01:07.274]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:07.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.274]                 ...future.rng), started = ...future.startTime, 
[17:01:07.274]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:07.274]             version = "1.8"), class = "FutureResult")
[17:01:07.274]     }, finally = {
[17:01:07.274]         if (!identical(...future.workdir, getwd())) 
[17:01:07.274]             setwd(...future.workdir)
[17:01:07.274]         {
[17:01:07.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:07.274]                 ...future.oldOptions$nwarnings <- NULL
[17:01:07.274]             }
[17:01:07.274]             base::options(...future.oldOptions)
[17:01:07.274]             if (.Platform$OS.type == "windows") {
[17:01:07.274]                 old_names <- names(...future.oldEnvVars)
[17:01:07.274]                 envs <- base::Sys.getenv()
[17:01:07.274]                 names <- names(envs)
[17:01:07.274]                 common <- intersect(names, old_names)
[17:01:07.274]                 added <- setdiff(names, old_names)
[17:01:07.274]                 removed <- setdiff(old_names, names)
[17:01:07.274]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:07.274]                   envs[common]]
[17:01:07.274]                 NAMES <- toupper(changed)
[17:01:07.274]                 args <- list()
[17:01:07.274]                 for (kk in seq_along(NAMES)) {
[17:01:07.274]                   name <- changed[[kk]]
[17:01:07.274]                   NAME <- NAMES[[kk]]
[17:01:07.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.274]                     next
[17:01:07.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.274]                 }
[17:01:07.274]                 NAMES <- toupper(added)
[17:01:07.274]                 for (kk in seq_along(NAMES)) {
[17:01:07.274]                   name <- added[[kk]]
[17:01:07.274]                   NAME <- NAMES[[kk]]
[17:01:07.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.274]                     next
[17:01:07.274]                   args[[name]] <- ""
[17:01:07.274]                 }
[17:01:07.274]                 NAMES <- toupper(removed)
[17:01:07.274]                 for (kk in seq_along(NAMES)) {
[17:01:07.274]                   name <- removed[[kk]]
[17:01:07.274]                   NAME <- NAMES[[kk]]
[17:01:07.274]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.274]                     next
[17:01:07.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.274]                 }
[17:01:07.274]                 if (length(args) > 0) 
[17:01:07.274]                   base::do.call(base::Sys.setenv, args = args)
[17:01:07.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:07.274]             }
[17:01:07.274]             else {
[17:01:07.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:07.274]             }
[17:01:07.274]             {
[17:01:07.274]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:07.274]                   0L) {
[17:01:07.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:07.274]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:07.274]                   base::options(opts)
[17:01:07.274]                 }
[17:01:07.274]                 {
[17:01:07.274]                   {
[17:01:07.274]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:07.274]                     NULL
[17:01:07.274]                   }
[17:01:07.274]                   options(future.plan = NULL)
[17:01:07.274]                   if (is.na(NA_character_)) 
[17:01:07.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:07.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:07.274]                     .init = FALSE)
[17:01:07.274]                 }
[17:01:07.274]             }
[17:01:07.274]         }
[17:01:07.274]     })
[17:01:07.274]     if (TRUE) {
[17:01:07.274]         base::sink(type = "output", split = FALSE)
[17:01:07.274]         if (TRUE) {
[17:01:07.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:07.274]         }
[17:01:07.274]         else {
[17:01:07.274]             ...future.result["stdout"] <- base::list(NULL)
[17:01:07.274]         }
[17:01:07.274]         base::close(...future.stdout)
[17:01:07.274]         ...future.stdout <- NULL
[17:01:07.274]     }
[17:01:07.274]     ...future.result$conditions <- ...future.conditions
[17:01:07.274]     ...future.result$finished <- base::Sys.time()
[17:01:07.274]     ...future.result
[17:01:07.274] }
[17:01:07.277] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:01:07.277] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:07.320] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:07.320] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:01:07.320] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:01:07.321] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:07.321] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.321] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:07.364] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:07.364] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:07.408] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:07.408] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:07.408] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.409] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:07.409] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:07.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:07.410] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.410] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:07.410] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:07.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:07.411] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.411] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:07.411] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.411] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:01:07.412] MultisessionFuture started
[17:01:07.412] - Launch lazy future ... done
[17:01:07.412] run() for ‘MultisessionFuture’ ... done
[17:01:07.412] Created future:
[17:01:07.414] receiveMessageFromWorker() for ClusterFuture ...
[17:01:07.414] - Validating connection of MultisessionFuture
[17:01:07.414] - received message: FutureResult
[17:01:07.414] - Received FutureResult
[17:01:07.414] - Erased future from FutureRegistry
[17:01:07.414] result() for ClusterFuture ...
[17:01:07.414] - result already collected: FutureResult
[17:01:07.415] result() for ClusterFuture ... done
[17:01:07.415] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:07.412] MultisessionFuture:
[17:01:07.412] Label: ‘future_vapply-1’
[17:01:07.412] Expression:
[17:01:07.412] {
[17:01:07.412]     do.call(function(...) {
[17:01:07.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.412]             on.exit(options(oopts), add = TRUE)
[17:01:07.412]         }
[17:01:07.412]         {
[17:01:07.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.412]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.412]             })
[17:01:07.412]         }
[17:01:07.412]     }, args = future.call.arguments)
[17:01:07.412] }
[17:01:07.412] Lazy evaluation: FALSE
[17:01:07.412] Asynchronous evaluation: TRUE
[17:01:07.412] Local evaluation: TRUE
[17:01:07.412] Environment: R_GlobalEnv
[17:01:07.412] Capture standard output: TRUE
[17:01:07.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.412] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.412] Packages: 1 packages (‘future.apply’)
[17:01:07.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.412] Resolved: TRUE
[17:01:07.412] Value: <not collected>
[17:01:07.412] Conditions captured: <none>
[17:01:07.412] Early signaling: FALSE
[17:01:07.412] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.415] Chunk #1 of 2 ... DONE
[17:01:07.415] Chunk #2 of 2 ...
[17:01:07.415]  - Finding globals in 'X' for chunk #2 ...
[17:01:07.415] getGlobalsAndPackages() ...
[17:01:07.415] Searching for globals...
[17:01:07.416] 
[17:01:07.416] Searching for globals ... DONE
[17:01:07.416] - globals: [0] <none>
[17:01:07.416] getGlobalsAndPackages() ... DONE
[17:01:07.416]    + additional globals found: [n=0] 
[17:01:07.416]    + additional namespaces needed: [n=0] 
[17:01:07.416]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:07.416]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:07.416]  - seeds: <none>
[17:01:07.416]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.416] getGlobalsAndPackages() ...
[17:01:07.417] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.417] Resolving globals: FALSE
[17:01:07.417] Tweak future expression to call with '...' arguments ...
[17:01:07.417] {
[17:01:07.417]     do.call(function(...) {
[17:01:07.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.417]             on.exit(options(oopts), add = TRUE)
[17:01:07.417]         }
[17:01:07.417]         {
[17:01:07.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.417]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.417]             })
[17:01:07.417]         }
[17:01:07.417]     }, args = future.call.arguments)
[17:01:07.417] }
[17:01:07.417] Tweak future expression to call with '...' arguments ... DONE
[17:01:07.418] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.418] - packages: [1] ‘future.apply’
[17:01:07.418] getGlobalsAndPackages() ... DONE
[17:01:07.418] run() for ‘Future’ ...
[17:01:07.418] - state: ‘created’
[17:01:07.418] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:07.433] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:07.433]   - Field: ‘node’
[17:01:07.433]   - Field: ‘label’
[17:01:07.433]   - Field: ‘local’
[17:01:07.433]   - Field: ‘owner’
[17:01:07.433]   - Field: ‘envir’
[17:01:07.433]   - Field: ‘workers’
[17:01:07.433]   - Field: ‘packages’
[17:01:07.434]   - Field: ‘gc’
[17:01:07.434]   - Field: ‘conditions’
[17:01:07.434]   - Field: ‘persistent’
[17:01:07.434]   - Field: ‘expr’
[17:01:07.434]   - Field: ‘uuid’
[17:01:07.434]   - Field: ‘seed’
[17:01:07.434]   - Field: ‘version’
[17:01:07.434]   - Field: ‘result’
[17:01:07.434]   - Field: ‘asynchronous’
[17:01:07.434]   - Field: ‘calls’
[17:01:07.434]   - Field: ‘globals’
[17:01:07.435]   - Field: ‘stdout’
[17:01:07.435]   - Field: ‘earlySignal’
[17:01:07.435]   - Field: ‘lazy’
[17:01:07.435]   - Field: ‘state’
[17:01:07.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:07.435] - Launch lazy future ...
[17:01:07.435] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:07.435] Packages needed by future strategies (n = 0): <none>
[17:01:07.436] {
[17:01:07.436]     {
[17:01:07.436]         {
[17:01:07.436]             ...future.startTime <- base::Sys.time()
[17:01:07.436]             {
[17:01:07.436]                 {
[17:01:07.436]                   {
[17:01:07.436]                     {
[17:01:07.436]                       {
[17:01:07.436]                         base::local({
[17:01:07.436]                           has_future <- base::requireNamespace("future", 
[17:01:07.436]                             quietly = TRUE)
[17:01:07.436]                           if (has_future) {
[17:01:07.436]                             ns <- base::getNamespace("future")
[17:01:07.436]                             version <- ns[[".package"]][["version"]]
[17:01:07.436]                             if (is.null(version)) 
[17:01:07.436]                               version <- utils::packageVersion("future")
[17:01:07.436]                           }
[17:01:07.436]                           else {
[17:01:07.436]                             version <- NULL
[17:01:07.436]                           }
[17:01:07.436]                           if (!has_future || version < "1.8.0") {
[17:01:07.436]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:07.436]                               "", base::R.version$version.string), 
[17:01:07.436]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:07.436]                                 base::R.version$platform, 8 * 
[17:01:07.436]                                   base::.Machine$sizeof.pointer), 
[17:01:07.436]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:07.436]                                 "release", "version")], collapse = " "), 
[17:01:07.436]                               hostname = base::Sys.info()[["nodename"]])
[17:01:07.436]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:07.436]                               info)
[17:01:07.436]                             info <- base::paste(info, collapse = "; ")
[17:01:07.436]                             if (!has_future) {
[17:01:07.436]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:07.436]                                 info)
[17:01:07.436]                             }
[17:01:07.436]                             else {
[17:01:07.436]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:07.436]                                 info, version)
[17:01:07.436]                             }
[17:01:07.436]                             base::stop(msg)
[17:01:07.436]                           }
[17:01:07.436]                         })
[17:01:07.436]                       }
[17:01:07.436]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:07.436]                       base::options(mc.cores = 1L)
[17:01:07.436]                     }
[17:01:07.436]                     base::local({
[17:01:07.436]                       for (pkg in "future.apply") {
[17:01:07.436]                         base::loadNamespace(pkg)
[17:01:07.436]                         base::library(pkg, character.only = TRUE)
[17:01:07.436]                       }
[17:01:07.436]                     })
[17:01:07.436]                   }
[17:01:07.436]                   ...future.strategy.old <- future::plan("list")
[17:01:07.436]                   options(future.plan = NULL)
[17:01:07.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:07.436]                 }
[17:01:07.436]                 ...future.workdir <- getwd()
[17:01:07.436]             }
[17:01:07.436]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:07.436]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:07.436]         }
[17:01:07.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:07.436]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:07.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:07.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:07.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:07.436]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:07.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:07.436]             base::names(...future.oldOptions))
[17:01:07.436]     }
[17:01:07.436]     if (FALSE) {
[17:01:07.436]     }
[17:01:07.436]     else {
[17:01:07.436]         if (TRUE) {
[17:01:07.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:07.436]                 open = "w")
[17:01:07.436]         }
[17:01:07.436]         else {
[17:01:07.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:07.436]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:07.436]         }
[17:01:07.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:07.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:07.436]             base::sink(type = "output", split = FALSE)
[17:01:07.436]             base::close(...future.stdout)
[17:01:07.436]         }, add = TRUE)
[17:01:07.436]     }
[17:01:07.436]     ...future.frame <- base::sys.nframe()
[17:01:07.436]     ...future.conditions <- base::list()
[17:01:07.436]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:07.436]     if (FALSE) {
[17:01:07.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:07.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:07.436]     }
[17:01:07.436]     ...future.result <- base::tryCatch({
[17:01:07.436]         base::withCallingHandlers({
[17:01:07.436]             ...future.value <- base::withVisible(base::local({
[17:01:07.436]                 ...future.makeSendCondition <- base::local({
[17:01:07.436]                   sendCondition <- NULL
[17:01:07.436]                   function(frame = 1L) {
[17:01:07.436]                     if (is.function(sendCondition)) 
[17:01:07.436]                       return(sendCondition)
[17:01:07.436]                     ns <- getNamespace("parallel")
[17:01:07.436]                     if (exists("sendData", mode = "function", 
[17:01:07.436]                       envir = ns)) {
[17:01:07.436]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:07.436]                         envir = ns)
[17:01:07.436]                       envir <- sys.frame(frame)
[17:01:07.436]                       master <- NULL
[17:01:07.436]                       while (!identical(envir, .GlobalEnv) && 
[17:01:07.436]                         !identical(envir, emptyenv())) {
[17:01:07.436]                         if (exists("master", mode = "list", envir = envir, 
[17:01:07.436]                           inherits = FALSE)) {
[17:01:07.436]                           master <- get("master", mode = "list", 
[17:01:07.436]                             envir = envir, inherits = FALSE)
[17:01:07.436]                           if (inherits(master, c("SOCKnode", 
[17:01:07.436]                             "SOCK0node"))) {
[17:01:07.436]                             sendCondition <<- function(cond) {
[17:01:07.436]                               data <- list(type = "VALUE", value = cond, 
[17:01:07.436]                                 success = TRUE)
[17:01:07.436]                               parallel_sendData(master, data)
[17:01:07.436]                             }
[17:01:07.436]                             return(sendCondition)
[17:01:07.436]                           }
[17:01:07.436]                         }
[17:01:07.436]                         frame <- frame + 1L
[17:01:07.436]                         envir <- sys.frame(frame)
[17:01:07.436]                       }
[17:01:07.436]                     }
[17:01:07.436]                     sendCondition <<- function(cond) NULL
[17:01:07.436]                   }
[17:01:07.436]                 })
[17:01:07.436]                 withCallingHandlers({
[17:01:07.436]                   {
[17:01:07.436]                     do.call(function(...) {
[17:01:07.436]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.436]                       if (!identical(...future.globals.maxSize.org, 
[17:01:07.436]                         ...future.globals.maxSize)) {
[17:01:07.436]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.436]                         on.exit(options(oopts), add = TRUE)
[17:01:07.436]                       }
[17:01:07.436]                       {
[17:01:07.436]                         lapply(seq_along(...future.elements_ii), 
[17:01:07.436]                           FUN = function(jj) {
[17:01:07.436]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.436]                             ...future.FUN(...future.X_jj, ...)
[17:01:07.436]                           })
[17:01:07.436]                       }
[17:01:07.436]                     }, args = future.call.arguments)
[17:01:07.436]                   }
[17:01:07.436]                 }, immediateCondition = function(cond) {
[17:01:07.436]                   sendCondition <- ...future.makeSendCondition()
[17:01:07.436]                   sendCondition(cond)
[17:01:07.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.436]                   {
[17:01:07.436]                     inherits <- base::inherits
[17:01:07.436]                     invokeRestart <- base::invokeRestart
[17:01:07.436]                     is.null <- base::is.null
[17:01:07.436]                     muffled <- FALSE
[17:01:07.436]                     if (inherits(cond, "message")) {
[17:01:07.436]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:07.436]                       if (muffled) 
[17:01:07.436]                         invokeRestart("muffleMessage")
[17:01:07.436]                     }
[17:01:07.436]                     else if (inherits(cond, "warning")) {
[17:01:07.436]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:07.436]                       if (muffled) 
[17:01:07.436]                         invokeRestart("muffleWarning")
[17:01:07.436]                     }
[17:01:07.436]                     else if (inherits(cond, "condition")) {
[17:01:07.436]                       if (!is.null(pattern)) {
[17:01:07.436]                         computeRestarts <- base::computeRestarts
[17:01:07.436]                         grepl <- base::grepl
[17:01:07.436]                         restarts <- computeRestarts(cond)
[17:01:07.436]                         for (restart in restarts) {
[17:01:07.436]                           name <- restart$name
[17:01:07.436]                           if (is.null(name)) 
[17:01:07.436]                             next
[17:01:07.436]                           if (!grepl(pattern, name)) 
[17:01:07.436]                             next
[17:01:07.436]                           invokeRestart(restart)
[17:01:07.436]                           muffled <- TRUE
[17:01:07.436]                           break
[17:01:07.436]                         }
[17:01:07.436]                       }
[17:01:07.436]                     }
[17:01:07.436]                     invisible(muffled)
[17:01:07.436]                   }
[17:01:07.436]                   muffleCondition(cond)
[17:01:07.436]                 })
[17:01:07.436]             }))
[17:01:07.436]             future::FutureResult(value = ...future.value$value, 
[17:01:07.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.436]                   ...future.rng), globalenv = if (FALSE) 
[17:01:07.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:07.436]                     ...future.globalenv.names))
[17:01:07.436]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:07.436]         }, condition = base::local({
[17:01:07.436]             c <- base::c
[17:01:07.436]             inherits <- base::inherits
[17:01:07.436]             invokeRestart <- base::invokeRestart
[17:01:07.436]             length <- base::length
[17:01:07.436]             list <- base::list
[17:01:07.436]             seq.int <- base::seq.int
[17:01:07.436]             signalCondition <- base::signalCondition
[17:01:07.436]             sys.calls <- base::sys.calls
[17:01:07.436]             `[[` <- base::`[[`
[17:01:07.436]             `+` <- base::`+`
[17:01:07.436]             `<<-` <- base::`<<-`
[17:01:07.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:07.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:07.436]                   3L)]
[17:01:07.436]             }
[17:01:07.436]             function(cond) {
[17:01:07.436]                 is_error <- inherits(cond, "error")
[17:01:07.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:07.436]                   NULL)
[17:01:07.436]                 if (is_error) {
[17:01:07.436]                   sessionInformation <- function() {
[17:01:07.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:07.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:07.436]                       search = base::search(), system = base::Sys.info())
[17:01:07.436]                   }
[17:01:07.436]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:07.436]                     cond$call), session = sessionInformation(), 
[17:01:07.436]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:07.436]                   signalCondition(cond)
[17:01:07.436]                 }
[17:01:07.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:07.436]                 "immediateCondition"))) {
[17:01:07.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:07.436]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:07.436]                   if (TRUE && !signal) {
[17:01:07.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.436]                     {
[17:01:07.436]                       inherits <- base::inherits
[17:01:07.436]                       invokeRestart <- base::invokeRestart
[17:01:07.436]                       is.null <- base::is.null
[17:01:07.436]                       muffled <- FALSE
[17:01:07.436]                       if (inherits(cond, "message")) {
[17:01:07.436]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.436]                         if (muffled) 
[17:01:07.436]                           invokeRestart("muffleMessage")
[17:01:07.436]                       }
[17:01:07.436]                       else if (inherits(cond, "warning")) {
[17:01:07.436]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.436]                         if (muffled) 
[17:01:07.436]                           invokeRestart("muffleWarning")
[17:01:07.436]                       }
[17:01:07.436]                       else if (inherits(cond, "condition")) {
[17:01:07.436]                         if (!is.null(pattern)) {
[17:01:07.436]                           computeRestarts <- base::computeRestarts
[17:01:07.436]                           grepl <- base::grepl
[17:01:07.436]                           restarts <- computeRestarts(cond)
[17:01:07.436]                           for (restart in restarts) {
[17:01:07.436]                             name <- restart$name
[17:01:07.436]                             if (is.null(name)) 
[17:01:07.436]                               next
[17:01:07.436]                             if (!grepl(pattern, name)) 
[17:01:07.436]                               next
[17:01:07.436]                             invokeRestart(restart)
[17:01:07.436]                             muffled <- TRUE
[17:01:07.436]                             break
[17:01:07.436]                           }
[17:01:07.436]                         }
[17:01:07.436]                       }
[17:01:07.436]                       invisible(muffled)
[17:01:07.436]                     }
[17:01:07.436]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.436]                   }
[17:01:07.436]                 }
[17:01:07.436]                 else {
[17:01:07.436]                   if (TRUE) {
[17:01:07.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.436]                     {
[17:01:07.436]                       inherits <- base::inherits
[17:01:07.436]                       invokeRestart <- base::invokeRestart
[17:01:07.436]                       is.null <- base::is.null
[17:01:07.436]                       muffled <- FALSE
[17:01:07.436]                       if (inherits(cond, "message")) {
[17:01:07.436]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.436]                         if (muffled) 
[17:01:07.436]                           invokeRestart("muffleMessage")
[17:01:07.436]                       }
[17:01:07.436]                       else if (inherits(cond, "warning")) {
[17:01:07.436]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.436]                         if (muffled) 
[17:01:07.436]                           invokeRestart("muffleWarning")
[17:01:07.436]                       }
[17:01:07.436]                       else if (inherits(cond, "condition")) {
[17:01:07.436]                         if (!is.null(pattern)) {
[17:01:07.436]                           computeRestarts <- base::computeRestarts
[17:01:07.436]                           grepl <- base::grepl
[17:01:07.436]                           restarts <- computeRestarts(cond)
[17:01:07.436]                           for (restart in restarts) {
[17:01:07.436]                             name <- restart$name
[17:01:07.436]                             if (is.null(name)) 
[17:01:07.436]                               next
[17:01:07.436]                             if (!grepl(pattern, name)) 
[17:01:07.436]                               next
[17:01:07.436]                             invokeRestart(restart)
[17:01:07.436]                             muffled <- TRUE
[17:01:07.436]                             break
[17:01:07.436]                           }
[17:01:07.436]                         }
[17:01:07.436]                       }
[17:01:07.436]                       invisible(muffled)
[17:01:07.436]                     }
[17:01:07.436]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.436]                   }
[17:01:07.436]                 }
[17:01:07.436]             }
[17:01:07.436]         }))
[17:01:07.436]     }, error = function(ex) {
[17:01:07.436]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:07.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.436]                 ...future.rng), started = ...future.startTime, 
[17:01:07.436]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:07.436]             version = "1.8"), class = "FutureResult")
[17:01:07.436]     }, finally = {
[17:01:07.436]         if (!identical(...future.workdir, getwd())) 
[17:01:07.436]             setwd(...future.workdir)
[17:01:07.436]         {
[17:01:07.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:07.436]                 ...future.oldOptions$nwarnings <- NULL
[17:01:07.436]             }
[17:01:07.436]             base::options(...future.oldOptions)
[17:01:07.436]             if (.Platform$OS.type == "windows") {
[17:01:07.436]                 old_names <- names(...future.oldEnvVars)
[17:01:07.436]                 envs <- base::Sys.getenv()
[17:01:07.436]                 names <- names(envs)
[17:01:07.436]                 common <- intersect(names, old_names)
[17:01:07.436]                 added <- setdiff(names, old_names)
[17:01:07.436]                 removed <- setdiff(old_names, names)
[17:01:07.436]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:07.436]                   envs[common]]
[17:01:07.436]                 NAMES <- toupper(changed)
[17:01:07.436]                 args <- list()
[17:01:07.436]                 for (kk in seq_along(NAMES)) {
[17:01:07.436]                   name <- changed[[kk]]
[17:01:07.436]                   NAME <- NAMES[[kk]]
[17:01:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.436]                     next
[17:01:07.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.436]                 }
[17:01:07.436]                 NAMES <- toupper(added)
[17:01:07.436]                 for (kk in seq_along(NAMES)) {
[17:01:07.436]                   name <- added[[kk]]
[17:01:07.436]                   NAME <- NAMES[[kk]]
[17:01:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.436]                     next
[17:01:07.436]                   args[[name]] <- ""
[17:01:07.436]                 }
[17:01:07.436]                 NAMES <- toupper(removed)
[17:01:07.436]                 for (kk in seq_along(NAMES)) {
[17:01:07.436]                   name <- removed[[kk]]
[17:01:07.436]                   NAME <- NAMES[[kk]]
[17:01:07.436]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.436]                     next
[17:01:07.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.436]                 }
[17:01:07.436]                 if (length(args) > 0) 
[17:01:07.436]                   base::do.call(base::Sys.setenv, args = args)
[17:01:07.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:07.436]             }
[17:01:07.436]             else {
[17:01:07.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:07.436]             }
[17:01:07.436]             {
[17:01:07.436]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:07.436]                   0L) {
[17:01:07.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:07.436]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:07.436]                   base::options(opts)
[17:01:07.436]                 }
[17:01:07.436]                 {
[17:01:07.436]                   {
[17:01:07.436]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:07.436]                     NULL
[17:01:07.436]                   }
[17:01:07.436]                   options(future.plan = NULL)
[17:01:07.436]                   if (is.na(NA_character_)) 
[17:01:07.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:07.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:07.436]                     .init = FALSE)
[17:01:07.436]                 }
[17:01:07.436]             }
[17:01:07.436]         }
[17:01:07.436]     })
[17:01:07.436]     if (TRUE) {
[17:01:07.436]         base::sink(type = "output", split = FALSE)
[17:01:07.436]         if (TRUE) {
[17:01:07.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:07.436]         }
[17:01:07.436]         else {
[17:01:07.436]             ...future.result["stdout"] <- base::list(NULL)
[17:01:07.436]         }
[17:01:07.436]         base::close(...future.stdout)
[17:01:07.436]         ...future.stdout <- NULL
[17:01:07.436]     }
[17:01:07.436]     ...future.result$conditions <- ...future.conditions
[17:01:07.436]     ...future.result$finished <- base::Sys.time()
[17:01:07.436]     ...future.result
[17:01:07.436] }
[17:01:07.439] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:01:07.439] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:07.480] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:07.480] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:01:07.481] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:01:07.481] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:07.481] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.481] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:07.524] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:07.524] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:07.568] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:07.568] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:07.569] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.569] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:07.569] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:07.569] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:07.570] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.570] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:07.570] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:07.571] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:07.571] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.571] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:07.571] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.571] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:01:07.572] MultisessionFuture started
[17:01:07.572] - Launch lazy future ... done
[17:01:07.572] run() for ‘MultisessionFuture’ ... done
[17:01:07.573] Created future:
[17:01:07.573] MultisessionFuture:
[17:01:07.573] Label: ‘future_vapply-2’
[17:01:07.573] Expression:
[17:01:07.573] {
[17:01:07.573]     do.call(function(...) {
[17:01:07.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.573]             on.exit(options(oopts), add = TRUE)
[17:01:07.573]         }
[17:01:07.573]         {
[17:01:07.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.573]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.573]             })
[17:01:07.573]         }
[17:01:07.573]     }, args = future.call.arguments)
[17:01:07.573] }
[17:01:07.573] Lazy evaluation: FALSE
[17:01:07.573] Asynchronous evaluation: TRUE
[17:01:07.573] Local evaluation: TRUE
[17:01:07.573] Environment: R_GlobalEnv
[17:01:07.573] Capture standard output: TRUE
[17:01:07.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.573] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.573] Packages: 1 packages (‘future.apply’)
[17:01:07.573] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.573] Resolved: FALSE
[17:01:07.573] Value: <not collected>
[17:01:07.573] Conditions captured: <none>
[17:01:07.573] Early signaling: FALSE
[17:01:07.573] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.573] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.585] Chunk #2 of 2 ... DONE
[17:01:07.585] Launching 2 futures (chunks) ... DONE
[17:01:07.585] Resolving 2 futures (chunks) ...
[17:01:07.585] resolve() on list ...
[17:01:07.585]  recursive: 0
[17:01:07.585]  length: 2
[17:01:07.585] 
[17:01:07.585] Future #1
[17:01:07.585] result() for ClusterFuture ...
[17:01:07.586] - result already collected: FutureResult
[17:01:07.586] result() for ClusterFuture ... done
[17:01:07.586] result() for ClusterFuture ...
[17:01:07.586] - result already collected: FutureResult
[17:01:07.586] result() for ClusterFuture ... done
[17:01:07.586] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:07.586] - nx: 2
[17:01:07.586] - relay: TRUE
[17:01:07.586] - stdout: TRUE
[17:01:07.586] - signal: TRUE
[17:01:07.586] - resignal: FALSE
[17:01:07.586] - force: TRUE
[17:01:07.587] - relayed: [n=2] FALSE, FALSE
[17:01:07.587] - queued futures: [n=2] FALSE, FALSE
[17:01:07.587]  - until=1
[17:01:07.587]  - relaying element #1
[17:01:07.587] result() for ClusterFuture ...
[17:01:07.587] - result already collected: FutureResult
[17:01:07.587] result() for ClusterFuture ... done
[17:01:07.587] result() for ClusterFuture ...
[17:01:07.587] - result already collected: FutureResult
[17:01:07.587] result() for ClusterFuture ... done
[17:01:07.587] result() for ClusterFuture ...
[17:01:07.588] - result already collected: FutureResult
[17:01:07.588] result() for ClusterFuture ... done
[17:01:07.588] result() for ClusterFuture ...
[17:01:07.588] - result already collected: FutureResult
[17:01:07.588] result() for ClusterFuture ... done
[17:01:07.588] - relayed: [n=2] TRUE, FALSE
[17:01:07.588] - queued futures: [n=2] TRUE, FALSE
[17:01:07.588] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:07.588]  length: 1 (resolved future 1)
[17:01:07.617] receiveMessageFromWorker() for ClusterFuture ...
[17:01:07.617] - Validating connection of MultisessionFuture
[17:01:07.618] - received message: FutureResult
[17:01:07.618] - Received FutureResult
[17:01:07.618] - Erased future from FutureRegistry
[17:01:07.618] result() for ClusterFuture ...
[17:01:07.618] - result already collected: FutureResult
[17:01:07.618] result() for ClusterFuture ... done
[17:01:07.618] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:07.618] Future #2
[17:01:07.618] result() for ClusterFuture ...
[17:01:07.618] - result already collected: FutureResult
[17:01:07.618] result() for ClusterFuture ... done
[17:01:07.619] result() for ClusterFuture ...
[17:01:07.619] - result already collected: FutureResult
[17:01:07.619] result() for ClusterFuture ... done
[17:01:07.619] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:07.619] - nx: 2
[17:01:07.619] - relay: TRUE
[17:01:07.619] - stdout: TRUE
[17:01:07.619] - signal: TRUE
[17:01:07.619] - resignal: FALSE
[17:01:07.619] - force: TRUE
[17:01:07.619] - relayed: [n=2] TRUE, FALSE
[17:01:07.619] - queued futures: [n=2] TRUE, FALSE
[17:01:07.620]  - until=2
[17:01:07.620]  - relaying element #2
[17:01:07.620] result() for ClusterFuture ...
[17:01:07.620] - result already collected: FutureResult
[17:01:07.620] result() for ClusterFuture ... done
[17:01:07.620] result() for ClusterFuture ...
[17:01:07.620] - result already collected: FutureResult
[17:01:07.620] result() for ClusterFuture ... done
[17:01:07.620] result() for ClusterFuture ...
[17:01:07.620] - result already collected: FutureResult
[17:01:07.620] result() for ClusterFuture ... done
[17:01:07.621] result() for ClusterFuture ...
[17:01:07.621] - result already collected: FutureResult
[17:01:07.621] result() for ClusterFuture ... done
[17:01:07.621] - relayed: [n=2] TRUE, TRUE
[17:01:07.621] - queued futures: [n=2] TRUE, TRUE
[17:01:07.621] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:07.621]  length: 0 (resolved future 2)
[17:01:07.621] Relaying remaining futures
[17:01:07.621] signalConditionsASAP(NULL, pos=0) ...
[17:01:07.621] - nx: 2
[17:01:07.621] - relay: TRUE
[17:01:07.621] - stdout: TRUE
[17:01:07.622] - signal: TRUE
[17:01:07.622] - resignal: FALSE
[17:01:07.622] - force: TRUE
[17:01:07.622] - relayed: [n=2] TRUE, TRUE
[17:01:07.622] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:07.622] - relayed: [n=2] TRUE, TRUE
[17:01:07.622] - queued futures: [n=2] TRUE, TRUE
[17:01:07.622] signalConditionsASAP(NULL, pos=0) ... done
[17:01:07.622] resolve() on list ... DONE
[17:01:07.622] result() for ClusterFuture ...
[17:01:07.622] - result already collected: FutureResult
[17:01:07.623] result() for ClusterFuture ... done
[17:01:07.623] result() for ClusterFuture ...
[17:01:07.623] - result already collected: FutureResult
[17:01:07.623] result() for ClusterFuture ... done
[17:01:07.623] result() for ClusterFuture ...
[17:01:07.623] - result already collected: FutureResult
[17:01:07.623] result() for ClusterFuture ... done
[17:01:07.623] result() for ClusterFuture ...
[17:01:07.623] - result already collected: FutureResult
[17:01:07.623] result() for ClusterFuture ... done
[17:01:07.623]  - Number of value chunks collected: 2
[17:01:07.624] Resolving 2 futures (chunks) ... DONE
[17:01:07.624] Reducing values from 2 chunks ...
[17:01:07.624]  - Number of values collected after concatenation: 10
[17:01:07.624]  - Number of values expected: 10
[17:01:07.624] Reducing values from 2 chunks ... DONE
[17:01:07.624] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:01:07.626] future_lapply() ...
[17:01:07.631] Number of chunks: 2
[17:01:07.631] getGlobalsAndPackagesXApply() ...
[17:01:07.632]  - future.globals: TRUE
[17:01:07.632] getGlobalsAndPackages() ...
[17:01:07.632] Searching for globals...
[17:01:07.635] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:01:07.636] Searching for globals ... DONE
[17:01:07.636] Resolving globals: FALSE
[17:01:07.639] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:01:07.639] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:07.639] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:07.639] - packages: [1] ‘future.apply’
[17:01:07.640] getGlobalsAndPackages() ... DONE
[17:01:07.640]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:07.640]  - needed namespaces: [n=1] ‘future.apply’
[17:01:07.640] Finding globals ... DONE
[17:01:07.640]  - use_args: TRUE
[17:01:07.640]  - Getting '...' globals ...
[17:01:07.640] resolve() on list ...
[17:01:07.640]  recursive: 0
[17:01:07.641]  length: 1
[17:01:07.641]  elements: ‘...’
[17:01:07.641]  length: 0 (resolved future 1)
[17:01:07.641] resolve() on list ... DONE
[17:01:07.641]    - '...' content: [n=0] 
[17:01:07.641] List of 1
[17:01:07.641]  $ ...: list()
[17:01:07.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:07.641]  - attr(*, "where")=List of 1
[17:01:07.641]   ..$ ...:<environment: 0x55aaddefce88> 
[17:01:07.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:07.641]  - attr(*, "resolved")= logi TRUE
[17:01:07.641]  - attr(*, "total_size")= num NA
[17:01:07.643]  - Getting '...' globals ... DONE
[17:01:07.644] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:07.644] List of 8
[17:01:07.644]  $ ...future.FUN:function (x, ...)  
[17:01:07.644]  $ x_FUN        :function (x)  
[17:01:07.644]  $ times        : int 4
[17:01:07.644]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:07.644]  $ stop_if_not  :function (...)  
[17:01:07.644]  $ dim          : int [1:2] 2 2
[17:01:07.644]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:07.644]  $ ...          : list()
[17:01:07.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:07.644]  - attr(*, "where")=List of 8
[17:01:07.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:07.644]   ..$ ...          :<environment: 0x55aaddefce88> 
[17:01:07.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:07.644]  - attr(*, "resolved")= logi FALSE
[17:01:07.644]  - attr(*, "total_size")= num 105552
[17:01:07.649] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:07.649] getGlobalsAndPackagesXApply() ... DONE
[17:01:07.649] Number of futures (= number of chunks): 2
[17:01:07.649] Launching 2 futures (chunks) ...
[17:01:07.649] Chunk #1 of 2 ...
[17:01:07.650]  - Finding globals in 'X' for chunk #1 ...
[17:01:07.650] getGlobalsAndPackages() ...
[17:01:07.650] Searching for globals...
[17:01:07.650] 
[17:01:07.650] Searching for globals ... DONE
[17:01:07.650] - globals: [0] <none>
[17:01:07.650] getGlobalsAndPackages() ... DONE
[17:01:07.650]    + additional globals found: [n=0] 
[17:01:07.650]    + additional namespaces needed: [n=0] 
[17:01:07.651]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:07.651]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:07.651]  - seeds: <none>
[17:01:07.651]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.651] getGlobalsAndPackages() ...
[17:01:07.651] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.651] Resolving globals: FALSE
[17:01:07.651] Tweak future expression to call with '...' arguments ...
[17:01:07.651] {
[17:01:07.651]     do.call(function(...) {
[17:01:07.651]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.651]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.651]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.651]             on.exit(options(oopts), add = TRUE)
[17:01:07.651]         }
[17:01:07.651]         {
[17:01:07.651]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.651]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.651]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.651]             })
[17:01:07.651]         }
[17:01:07.651]     }, args = future.call.arguments)
[17:01:07.651] }
[17:01:07.652] Tweak future expression to call with '...' arguments ... DONE
[17:01:07.652] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.652] - packages: [1] ‘future.apply’
[17:01:07.652] getGlobalsAndPackages() ... DONE
[17:01:07.653] run() for ‘Future’ ...
[17:01:07.653] - state: ‘created’
[17:01:07.653] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:07.668] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:07.669]   - Field: ‘node’
[17:01:07.669]   - Field: ‘label’
[17:01:07.669]   - Field: ‘local’
[17:01:07.669]   - Field: ‘owner’
[17:01:07.669]   - Field: ‘envir’
[17:01:07.669]   - Field: ‘workers’
[17:01:07.669]   - Field: ‘packages’
[17:01:07.669]   - Field: ‘gc’
[17:01:07.669]   - Field: ‘conditions’
[17:01:07.669]   - Field: ‘persistent’
[17:01:07.670]   - Field: ‘expr’
[17:01:07.670]   - Field: ‘uuid’
[17:01:07.670]   - Field: ‘seed’
[17:01:07.670]   - Field: ‘version’
[17:01:07.670]   - Field: ‘result’
[17:01:07.670]   - Field: ‘asynchronous’
[17:01:07.670]   - Field: ‘calls’
[17:01:07.670]   - Field: ‘globals’
[17:01:07.670]   - Field: ‘stdout’
[17:01:07.670]   - Field: ‘earlySignal’
[17:01:07.670]   - Field: ‘lazy’
[17:01:07.671]   - Field: ‘state’
[17:01:07.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:07.671] - Launch lazy future ...
[17:01:07.671] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:07.671] Packages needed by future strategies (n = 0): <none>
[17:01:07.672] {
[17:01:07.672]     {
[17:01:07.672]         {
[17:01:07.672]             ...future.startTime <- base::Sys.time()
[17:01:07.672]             {
[17:01:07.672]                 {
[17:01:07.672]                   {
[17:01:07.672]                     {
[17:01:07.672]                       {
[17:01:07.672]                         base::local({
[17:01:07.672]                           has_future <- base::requireNamespace("future", 
[17:01:07.672]                             quietly = TRUE)
[17:01:07.672]                           if (has_future) {
[17:01:07.672]                             ns <- base::getNamespace("future")
[17:01:07.672]                             version <- ns[[".package"]][["version"]]
[17:01:07.672]                             if (is.null(version)) 
[17:01:07.672]                               version <- utils::packageVersion("future")
[17:01:07.672]                           }
[17:01:07.672]                           else {
[17:01:07.672]                             version <- NULL
[17:01:07.672]                           }
[17:01:07.672]                           if (!has_future || version < "1.8.0") {
[17:01:07.672]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:07.672]                               "", base::R.version$version.string), 
[17:01:07.672]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:07.672]                                 base::R.version$platform, 8 * 
[17:01:07.672]                                   base::.Machine$sizeof.pointer), 
[17:01:07.672]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:07.672]                                 "release", "version")], collapse = " "), 
[17:01:07.672]                               hostname = base::Sys.info()[["nodename"]])
[17:01:07.672]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:07.672]                               info)
[17:01:07.672]                             info <- base::paste(info, collapse = "; ")
[17:01:07.672]                             if (!has_future) {
[17:01:07.672]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:07.672]                                 info)
[17:01:07.672]                             }
[17:01:07.672]                             else {
[17:01:07.672]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:07.672]                                 info, version)
[17:01:07.672]                             }
[17:01:07.672]                             base::stop(msg)
[17:01:07.672]                           }
[17:01:07.672]                         })
[17:01:07.672]                       }
[17:01:07.672]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:07.672]                       base::options(mc.cores = 1L)
[17:01:07.672]                     }
[17:01:07.672]                     base::local({
[17:01:07.672]                       for (pkg in "future.apply") {
[17:01:07.672]                         base::loadNamespace(pkg)
[17:01:07.672]                         base::library(pkg, character.only = TRUE)
[17:01:07.672]                       }
[17:01:07.672]                     })
[17:01:07.672]                   }
[17:01:07.672]                   ...future.strategy.old <- future::plan("list")
[17:01:07.672]                   options(future.plan = NULL)
[17:01:07.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:07.672]                 }
[17:01:07.672]                 ...future.workdir <- getwd()
[17:01:07.672]             }
[17:01:07.672]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:07.672]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:07.672]         }
[17:01:07.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:07.672]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:07.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:07.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:07.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:07.672]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:07.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:07.672]             base::names(...future.oldOptions))
[17:01:07.672]     }
[17:01:07.672]     if (FALSE) {
[17:01:07.672]     }
[17:01:07.672]     else {
[17:01:07.672]         if (TRUE) {
[17:01:07.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:07.672]                 open = "w")
[17:01:07.672]         }
[17:01:07.672]         else {
[17:01:07.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:07.672]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:07.672]         }
[17:01:07.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:07.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:07.672]             base::sink(type = "output", split = FALSE)
[17:01:07.672]             base::close(...future.stdout)
[17:01:07.672]         }, add = TRUE)
[17:01:07.672]     }
[17:01:07.672]     ...future.frame <- base::sys.nframe()
[17:01:07.672]     ...future.conditions <- base::list()
[17:01:07.672]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:07.672]     if (FALSE) {
[17:01:07.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:07.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:07.672]     }
[17:01:07.672]     ...future.result <- base::tryCatch({
[17:01:07.672]         base::withCallingHandlers({
[17:01:07.672]             ...future.value <- base::withVisible(base::local({
[17:01:07.672]                 ...future.makeSendCondition <- base::local({
[17:01:07.672]                   sendCondition <- NULL
[17:01:07.672]                   function(frame = 1L) {
[17:01:07.672]                     if (is.function(sendCondition)) 
[17:01:07.672]                       return(sendCondition)
[17:01:07.672]                     ns <- getNamespace("parallel")
[17:01:07.672]                     if (exists("sendData", mode = "function", 
[17:01:07.672]                       envir = ns)) {
[17:01:07.672]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:07.672]                         envir = ns)
[17:01:07.672]                       envir <- sys.frame(frame)
[17:01:07.672]                       master <- NULL
[17:01:07.672]                       while (!identical(envir, .GlobalEnv) && 
[17:01:07.672]                         !identical(envir, emptyenv())) {
[17:01:07.672]                         if (exists("master", mode = "list", envir = envir, 
[17:01:07.672]                           inherits = FALSE)) {
[17:01:07.672]                           master <- get("master", mode = "list", 
[17:01:07.672]                             envir = envir, inherits = FALSE)
[17:01:07.672]                           if (inherits(master, c("SOCKnode", 
[17:01:07.672]                             "SOCK0node"))) {
[17:01:07.672]                             sendCondition <<- function(cond) {
[17:01:07.672]                               data <- list(type = "VALUE", value = cond, 
[17:01:07.672]                                 success = TRUE)
[17:01:07.672]                               parallel_sendData(master, data)
[17:01:07.672]                             }
[17:01:07.672]                             return(sendCondition)
[17:01:07.672]                           }
[17:01:07.672]                         }
[17:01:07.672]                         frame <- frame + 1L
[17:01:07.672]                         envir <- sys.frame(frame)
[17:01:07.672]                       }
[17:01:07.672]                     }
[17:01:07.672]                     sendCondition <<- function(cond) NULL
[17:01:07.672]                   }
[17:01:07.672]                 })
[17:01:07.672]                 withCallingHandlers({
[17:01:07.672]                   {
[17:01:07.672]                     do.call(function(...) {
[17:01:07.672]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.672]                       if (!identical(...future.globals.maxSize.org, 
[17:01:07.672]                         ...future.globals.maxSize)) {
[17:01:07.672]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.672]                         on.exit(options(oopts), add = TRUE)
[17:01:07.672]                       }
[17:01:07.672]                       {
[17:01:07.672]                         lapply(seq_along(...future.elements_ii), 
[17:01:07.672]                           FUN = function(jj) {
[17:01:07.672]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.672]                             ...future.FUN(...future.X_jj, ...)
[17:01:07.672]                           })
[17:01:07.672]                       }
[17:01:07.672]                     }, args = future.call.arguments)
[17:01:07.672]                   }
[17:01:07.672]                 }, immediateCondition = function(cond) {
[17:01:07.672]                   sendCondition <- ...future.makeSendCondition()
[17:01:07.672]                   sendCondition(cond)
[17:01:07.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.672]                   {
[17:01:07.672]                     inherits <- base::inherits
[17:01:07.672]                     invokeRestart <- base::invokeRestart
[17:01:07.672]                     is.null <- base::is.null
[17:01:07.672]                     muffled <- FALSE
[17:01:07.672]                     if (inherits(cond, "message")) {
[17:01:07.672]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:07.672]                       if (muffled) 
[17:01:07.672]                         invokeRestart("muffleMessage")
[17:01:07.672]                     }
[17:01:07.672]                     else if (inherits(cond, "warning")) {
[17:01:07.672]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:07.672]                       if (muffled) 
[17:01:07.672]                         invokeRestart("muffleWarning")
[17:01:07.672]                     }
[17:01:07.672]                     else if (inherits(cond, "condition")) {
[17:01:07.672]                       if (!is.null(pattern)) {
[17:01:07.672]                         computeRestarts <- base::computeRestarts
[17:01:07.672]                         grepl <- base::grepl
[17:01:07.672]                         restarts <- computeRestarts(cond)
[17:01:07.672]                         for (restart in restarts) {
[17:01:07.672]                           name <- restart$name
[17:01:07.672]                           if (is.null(name)) 
[17:01:07.672]                             next
[17:01:07.672]                           if (!grepl(pattern, name)) 
[17:01:07.672]                             next
[17:01:07.672]                           invokeRestart(restart)
[17:01:07.672]                           muffled <- TRUE
[17:01:07.672]                           break
[17:01:07.672]                         }
[17:01:07.672]                       }
[17:01:07.672]                     }
[17:01:07.672]                     invisible(muffled)
[17:01:07.672]                   }
[17:01:07.672]                   muffleCondition(cond)
[17:01:07.672]                 })
[17:01:07.672]             }))
[17:01:07.672]             future::FutureResult(value = ...future.value$value, 
[17:01:07.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.672]                   ...future.rng), globalenv = if (FALSE) 
[17:01:07.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:07.672]                     ...future.globalenv.names))
[17:01:07.672]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:07.672]         }, condition = base::local({
[17:01:07.672]             c <- base::c
[17:01:07.672]             inherits <- base::inherits
[17:01:07.672]             invokeRestart <- base::invokeRestart
[17:01:07.672]             length <- base::length
[17:01:07.672]             list <- base::list
[17:01:07.672]             seq.int <- base::seq.int
[17:01:07.672]             signalCondition <- base::signalCondition
[17:01:07.672]             sys.calls <- base::sys.calls
[17:01:07.672]             `[[` <- base::`[[`
[17:01:07.672]             `+` <- base::`+`
[17:01:07.672]             `<<-` <- base::`<<-`
[17:01:07.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:07.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:07.672]                   3L)]
[17:01:07.672]             }
[17:01:07.672]             function(cond) {
[17:01:07.672]                 is_error <- inherits(cond, "error")
[17:01:07.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:07.672]                   NULL)
[17:01:07.672]                 if (is_error) {
[17:01:07.672]                   sessionInformation <- function() {
[17:01:07.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:07.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:07.672]                       search = base::search(), system = base::Sys.info())
[17:01:07.672]                   }
[17:01:07.672]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:07.672]                     cond$call), session = sessionInformation(), 
[17:01:07.672]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:07.672]                   signalCondition(cond)
[17:01:07.672]                 }
[17:01:07.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:07.672]                 "immediateCondition"))) {
[17:01:07.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:07.672]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:07.672]                   if (TRUE && !signal) {
[17:01:07.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.672]                     {
[17:01:07.672]                       inherits <- base::inherits
[17:01:07.672]                       invokeRestart <- base::invokeRestart
[17:01:07.672]                       is.null <- base::is.null
[17:01:07.672]                       muffled <- FALSE
[17:01:07.672]                       if (inherits(cond, "message")) {
[17:01:07.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.672]                         if (muffled) 
[17:01:07.672]                           invokeRestart("muffleMessage")
[17:01:07.672]                       }
[17:01:07.672]                       else if (inherits(cond, "warning")) {
[17:01:07.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.672]                         if (muffled) 
[17:01:07.672]                           invokeRestart("muffleWarning")
[17:01:07.672]                       }
[17:01:07.672]                       else if (inherits(cond, "condition")) {
[17:01:07.672]                         if (!is.null(pattern)) {
[17:01:07.672]                           computeRestarts <- base::computeRestarts
[17:01:07.672]                           grepl <- base::grepl
[17:01:07.672]                           restarts <- computeRestarts(cond)
[17:01:07.672]                           for (restart in restarts) {
[17:01:07.672]                             name <- restart$name
[17:01:07.672]                             if (is.null(name)) 
[17:01:07.672]                               next
[17:01:07.672]                             if (!grepl(pattern, name)) 
[17:01:07.672]                               next
[17:01:07.672]                             invokeRestart(restart)
[17:01:07.672]                             muffled <- TRUE
[17:01:07.672]                             break
[17:01:07.672]                           }
[17:01:07.672]                         }
[17:01:07.672]                       }
[17:01:07.672]                       invisible(muffled)
[17:01:07.672]                     }
[17:01:07.672]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.672]                   }
[17:01:07.672]                 }
[17:01:07.672]                 else {
[17:01:07.672]                   if (TRUE) {
[17:01:07.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.672]                     {
[17:01:07.672]                       inherits <- base::inherits
[17:01:07.672]                       invokeRestart <- base::invokeRestart
[17:01:07.672]                       is.null <- base::is.null
[17:01:07.672]                       muffled <- FALSE
[17:01:07.672]                       if (inherits(cond, "message")) {
[17:01:07.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.672]                         if (muffled) 
[17:01:07.672]                           invokeRestart("muffleMessage")
[17:01:07.672]                       }
[17:01:07.672]                       else if (inherits(cond, "warning")) {
[17:01:07.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.672]                         if (muffled) 
[17:01:07.672]                           invokeRestart("muffleWarning")
[17:01:07.672]                       }
[17:01:07.672]                       else if (inherits(cond, "condition")) {
[17:01:07.672]                         if (!is.null(pattern)) {
[17:01:07.672]                           computeRestarts <- base::computeRestarts
[17:01:07.672]                           grepl <- base::grepl
[17:01:07.672]                           restarts <- computeRestarts(cond)
[17:01:07.672]                           for (restart in restarts) {
[17:01:07.672]                             name <- restart$name
[17:01:07.672]                             if (is.null(name)) 
[17:01:07.672]                               next
[17:01:07.672]                             if (!grepl(pattern, name)) 
[17:01:07.672]                               next
[17:01:07.672]                             invokeRestart(restart)
[17:01:07.672]                             muffled <- TRUE
[17:01:07.672]                             break
[17:01:07.672]                           }
[17:01:07.672]                         }
[17:01:07.672]                       }
[17:01:07.672]                       invisible(muffled)
[17:01:07.672]                     }
[17:01:07.672]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.672]                   }
[17:01:07.672]                 }
[17:01:07.672]             }
[17:01:07.672]         }))
[17:01:07.672]     }, error = function(ex) {
[17:01:07.672]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:07.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.672]                 ...future.rng), started = ...future.startTime, 
[17:01:07.672]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:07.672]             version = "1.8"), class = "FutureResult")
[17:01:07.672]     }, finally = {
[17:01:07.672]         if (!identical(...future.workdir, getwd())) 
[17:01:07.672]             setwd(...future.workdir)
[17:01:07.672]         {
[17:01:07.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:07.672]                 ...future.oldOptions$nwarnings <- NULL
[17:01:07.672]             }
[17:01:07.672]             base::options(...future.oldOptions)
[17:01:07.672]             if (.Platform$OS.type == "windows") {
[17:01:07.672]                 old_names <- names(...future.oldEnvVars)
[17:01:07.672]                 envs <- base::Sys.getenv()
[17:01:07.672]                 names <- names(envs)
[17:01:07.672]                 common <- intersect(names, old_names)
[17:01:07.672]                 added <- setdiff(names, old_names)
[17:01:07.672]                 removed <- setdiff(old_names, names)
[17:01:07.672]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:07.672]                   envs[common]]
[17:01:07.672]                 NAMES <- toupper(changed)
[17:01:07.672]                 args <- list()
[17:01:07.672]                 for (kk in seq_along(NAMES)) {
[17:01:07.672]                   name <- changed[[kk]]
[17:01:07.672]                   NAME <- NAMES[[kk]]
[17:01:07.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.672]                     next
[17:01:07.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.672]                 }
[17:01:07.672]                 NAMES <- toupper(added)
[17:01:07.672]                 for (kk in seq_along(NAMES)) {
[17:01:07.672]                   name <- added[[kk]]
[17:01:07.672]                   NAME <- NAMES[[kk]]
[17:01:07.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.672]                     next
[17:01:07.672]                   args[[name]] <- ""
[17:01:07.672]                 }
[17:01:07.672]                 NAMES <- toupper(removed)
[17:01:07.672]                 for (kk in seq_along(NAMES)) {
[17:01:07.672]                   name <- removed[[kk]]
[17:01:07.672]                   NAME <- NAMES[[kk]]
[17:01:07.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.672]                     next
[17:01:07.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.672]                 }
[17:01:07.672]                 if (length(args) > 0) 
[17:01:07.672]                   base::do.call(base::Sys.setenv, args = args)
[17:01:07.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:07.672]             }
[17:01:07.672]             else {
[17:01:07.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:07.672]             }
[17:01:07.672]             {
[17:01:07.672]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:07.672]                   0L) {
[17:01:07.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:07.672]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:07.672]                   base::options(opts)
[17:01:07.672]                 }
[17:01:07.672]                 {
[17:01:07.672]                   {
[17:01:07.672]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:07.672]                     NULL
[17:01:07.672]                   }
[17:01:07.672]                   options(future.plan = NULL)
[17:01:07.672]                   if (is.na(NA_character_)) 
[17:01:07.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:07.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:07.672]                     .init = FALSE)
[17:01:07.672]                 }
[17:01:07.672]             }
[17:01:07.672]         }
[17:01:07.672]     })
[17:01:07.672]     if (TRUE) {
[17:01:07.672]         base::sink(type = "output", split = FALSE)
[17:01:07.672]         if (TRUE) {
[17:01:07.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:07.672]         }
[17:01:07.672]         else {
[17:01:07.672]             ...future.result["stdout"] <- base::list(NULL)
[17:01:07.672]         }
[17:01:07.672]         base::close(...future.stdout)
[17:01:07.672]         ...future.stdout <- NULL
[17:01:07.672]     }
[17:01:07.672]     ...future.result$conditions <- ...future.conditions
[17:01:07.672]     ...future.result$finished <- base::Sys.time()
[17:01:07.672]     ...future.result
[17:01:07.672] }
[17:01:07.674] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[17:01:07.675] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:07.716] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:07.716] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[17:01:07.716] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[17:01:07.717] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:07.717] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.717] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:07.760] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:07.760] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:07.804] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:07.804] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:07.804] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:07.805] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:07.805] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:07.805] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:07.806] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.806] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:01:07.806] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:01:07.806] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:07.807] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.807] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:07.807] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:07.807] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[17:01:07.808] MultisessionFuture started
[17:01:07.808] - Launch lazy future ... done
[17:01:07.808] run() for ‘MultisessionFuture’ ... done
[17:01:07.808] Created future:
[17:01:07.808] MultisessionFuture:
[17:01:07.808] Label: ‘future_vapply-1’
[17:01:07.808] Expression:
[17:01:07.808] {
[17:01:07.808]     do.call(function(...) {
[17:01:07.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.808]             on.exit(options(oopts), add = TRUE)
[17:01:07.808]         }
[17:01:07.808]         {
[17:01:07.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.808]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.808]             })
[17:01:07.808]         }
[17:01:07.808]     }, args = future.call.arguments)
[17:01:07.808] }
[17:01:07.808] Lazy evaluation: FALSE
[17:01:07.808] Asynchronous evaluation: TRUE
[17:01:07.808] Local evaluation: TRUE
[17:01:07.808] Environment: R_GlobalEnv
[17:01:07.808] Capture standard output: TRUE
[17:01:07.808] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.808] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.808] Packages: 1 packages (‘future.apply’)
[17:01:07.808] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.808] Resolved: FALSE
[17:01:07.808] Value: <not collected>
[17:01:07.808] Conditions captured: <none>
[17:01:07.808] Early signaling: FALSE
[17:01:07.808] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.808] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.820] Chunk #1 of 2 ... DONE
[17:01:07.820] Chunk #2 of 2 ...
[17:01:07.820]  - Finding globals in 'X' for chunk #2 ...
[17:01:07.820] getGlobalsAndPackages() ...
[17:01:07.821] Searching for globals...
[17:01:07.821] 
[17:01:07.821] Searching for globals ... DONE
[17:01:07.821] - globals: [0] <none>
[17:01:07.821] getGlobalsAndPackages() ... DONE
[17:01:07.821]    + additional globals found: [n=0] 
[17:01:07.821]    + additional namespaces needed: [n=0] 
[17:01:07.821]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:07.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:07.822]  - seeds: <none>
[17:01:07.822]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.822] getGlobalsAndPackages() ...
[17:01:07.822] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.822] Resolving globals: FALSE
[17:01:07.822] Tweak future expression to call with '...' arguments ...
[17:01:07.822] {
[17:01:07.822]     do.call(function(...) {
[17:01:07.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.822]             on.exit(options(oopts), add = TRUE)
[17:01:07.822]         }
[17:01:07.822]         {
[17:01:07.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.822]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.822]             })
[17:01:07.822]         }
[17:01:07.822]     }, args = future.call.arguments)
[17:01:07.822] }
[17:01:07.822] Tweak future expression to call with '...' arguments ... DONE
[17:01:07.823] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:07.823] - packages: [1] ‘future.apply’
[17:01:07.823] getGlobalsAndPackages() ... DONE
[17:01:07.823] run() for ‘Future’ ...
[17:01:07.824] - state: ‘created’
[17:01:07.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:07.838] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:07.838]   - Field: ‘node’
[17:01:07.838]   - Field: ‘label’
[17:01:07.838]   - Field: ‘local’
[17:01:07.838]   - Field: ‘owner’
[17:01:07.838]   - Field: ‘envir’
[17:01:07.839]   - Field: ‘workers’
[17:01:07.839]   - Field: ‘packages’
[17:01:07.839]   - Field: ‘gc’
[17:01:07.839]   - Field: ‘conditions’
[17:01:07.839]   - Field: ‘persistent’
[17:01:07.839]   - Field: ‘expr’
[17:01:07.839]   - Field: ‘uuid’
[17:01:07.839]   - Field: ‘seed’
[17:01:07.839]   - Field: ‘version’
[17:01:07.839]   - Field: ‘result’
[17:01:07.840]   - Field: ‘asynchronous’
[17:01:07.840]   - Field: ‘calls’
[17:01:07.840]   - Field: ‘globals’
[17:01:07.840]   - Field: ‘stdout’
[17:01:07.840]   - Field: ‘earlySignal’
[17:01:07.840]   - Field: ‘lazy’
[17:01:07.840]   - Field: ‘state’
[17:01:07.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:07.840] - Launch lazy future ...
[17:01:07.841] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:07.841] Packages needed by future strategies (n = 0): <none>
[17:01:07.841] {
[17:01:07.841]     {
[17:01:07.841]         {
[17:01:07.841]             ...future.startTime <- base::Sys.time()
[17:01:07.841]             {
[17:01:07.841]                 {
[17:01:07.841]                   {
[17:01:07.841]                     {
[17:01:07.841]                       {
[17:01:07.841]                         base::local({
[17:01:07.841]                           has_future <- base::requireNamespace("future", 
[17:01:07.841]                             quietly = TRUE)
[17:01:07.841]                           if (has_future) {
[17:01:07.841]                             ns <- base::getNamespace("future")
[17:01:07.841]                             version <- ns[[".package"]][["version"]]
[17:01:07.841]                             if (is.null(version)) 
[17:01:07.841]                               version <- utils::packageVersion("future")
[17:01:07.841]                           }
[17:01:07.841]                           else {
[17:01:07.841]                             version <- NULL
[17:01:07.841]                           }
[17:01:07.841]                           if (!has_future || version < "1.8.0") {
[17:01:07.841]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:07.841]                               "", base::R.version$version.string), 
[17:01:07.841]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:07.841]                                 base::R.version$platform, 8 * 
[17:01:07.841]                                   base::.Machine$sizeof.pointer), 
[17:01:07.841]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:07.841]                                 "release", "version")], collapse = " "), 
[17:01:07.841]                               hostname = base::Sys.info()[["nodename"]])
[17:01:07.841]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:07.841]                               info)
[17:01:07.841]                             info <- base::paste(info, collapse = "; ")
[17:01:07.841]                             if (!has_future) {
[17:01:07.841]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:07.841]                                 info)
[17:01:07.841]                             }
[17:01:07.841]                             else {
[17:01:07.841]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:07.841]                                 info, version)
[17:01:07.841]                             }
[17:01:07.841]                             base::stop(msg)
[17:01:07.841]                           }
[17:01:07.841]                         })
[17:01:07.841]                       }
[17:01:07.841]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:07.841]                       base::options(mc.cores = 1L)
[17:01:07.841]                     }
[17:01:07.841]                     base::local({
[17:01:07.841]                       for (pkg in "future.apply") {
[17:01:07.841]                         base::loadNamespace(pkg)
[17:01:07.841]                         base::library(pkg, character.only = TRUE)
[17:01:07.841]                       }
[17:01:07.841]                     })
[17:01:07.841]                   }
[17:01:07.841]                   ...future.strategy.old <- future::plan("list")
[17:01:07.841]                   options(future.plan = NULL)
[17:01:07.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:07.841]                 }
[17:01:07.841]                 ...future.workdir <- getwd()
[17:01:07.841]             }
[17:01:07.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:07.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:07.841]         }
[17:01:07.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:07.841]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:07.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:07.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:07.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:07.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:07.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:07.841]             base::names(...future.oldOptions))
[17:01:07.841]     }
[17:01:07.841]     if (FALSE) {
[17:01:07.841]     }
[17:01:07.841]     else {
[17:01:07.841]         if (TRUE) {
[17:01:07.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:07.841]                 open = "w")
[17:01:07.841]         }
[17:01:07.841]         else {
[17:01:07.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:07.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:07.841]         }
[17:01:07.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:07.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:07.841]             base::sink(type = "output", split = FALSE)
[17:01:07.841]             base::close(...future.stdout)
[17:01:07.841]         }, add = TRUE)
[17:01:07.841]     }
[17:01:07.841]     ...future.frame <- base::sys.nframe()
[17:01:07.841]     ...future.conditions <- base::list()
[17:01:07.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:07.841]     if (FALSE) {
[17:01:07.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:07.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:07.841]     }
[17:01:07.841]     ...future.result <- base::tryCatch({
[17:01:07.841]         base::withCallingHandlers({
[17:01:07.841]             ...future.value <- base::withVisible(base::local({
[17:01:07.841]                 ...future.makeSendCondition <- base::local({
[17:01:07.841]                   sendCondition <- NULL
[17:01:07.841]                   function(frame = 1L) {
[17:01:07.841]                     if (is.function(sendCondition)) 
[17:01:07.841]                       return(sendCondition)
[17:01:07.841]                     ns <- getNamespace("parallel")
[17:01:07.841]                     if (exists("sendData", mode = "function", 
[17:01:07.841]                       envir = ns)) {
[17:01:07.841]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:07.841]                         envir = ns)
[17:01:07.841]                       envir <- sys.frame(frame)
[17:01:07.841]                       master <- NULL
[17:01:07.841]                       while (!identical(envir, .GlobalEnv) && 
[17:01:07.841]                         !identical(envir, emptyenv())) {
[17:01:07.841]                         if (exists("master", mode = "list", envir = envir, 
[17:01:07.841]                           inherits = FALSE)) {
[17:01:07.841]                           master <- get("master", mode = "list", 
[17:01:07.841]                             envir = envir, inherits = FALSE)
[17:01:07.841]                           if (inherits(master, c("SOCKnode", 
[17:01:07.841]                             "SOCK0node"))) {
[17:01:07.841]                             sendCondition <<- function(cond) {
[17:01:07.841]                               data <- list(type = "VALUE", value = cond, 
[17:01:07.841]                                 success = TRUE)
[17:01:07.841]                               parallel_sendData(master, data)
[17:01:07.841]                             }
[17:01:07.841]                             return(sendCondition)
[17:01:07.841]                           }
[17:01:07.841]                         }
[17:01:07.841]                         frame <- frame + 1L
[17:01:07.841]                         envir <- sys.frame(frame)
[17:01:07.841]                       }
[17:01:07.841]                     }
[17:01:07.841]                     sendCondition <<- function(cond) NULL
[17:01:07.841]                   }
[17:01:07.841]                 })
[17:01:07.841]                 withCallingHandlers({
[17:01:07.841]                   {
[17:01:07.841]                     do.call(function(...) {
[17:01:07.841]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.841]                       if (!identical(...future.globals.maxSize.org, 
[17:01:07.841]                         ...future.globals.maxSize)) {
[17:01:07.841]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.841]                         on.exit(options(oopts), add = TRUE)
[17:01:07.841]                       }
[17:01:07.841]                       {
[17:01:07.841]                         lapply(seq_along(...future.elements_ii), 
[17:01:07.841]                           FUN = function(jj) {
[17:01:07.841]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.841]                             ...future.FUN(...future.X_jj, ...)
[17:01:07.841]                           })
[17:01:07.841]                       }
[17:01:07.841]                     }, args = future.call.arguments)
[17:01:07.841]                   }
[17:01:07.841]                 }, immediateCondition = function(cond) {
[17:01:07.841]                   sendCondition <- ...future.makeSendCondition()
[17:01:07.841]                   sendCondition(cond)
[17:01:07.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.841]                   {
[17:01:07.841]                     inherits <- base::inherits
[17:01:07.841]                     invokeRestart <- base::invokeRestart
[17:01:07.841]                     is.null <- base::is.null
[17:01:07.841]                     muffled <- FALSE
[17:01:07.841]                     if (inherits(cond, "message")) {
[17:01:07.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:07.841]                       if (muffled) 
[17:01:07.841]                         invokeRestart("muffleMessage")
[17:01:07.841]                     }
[17:01:07.841]                     else if (inherits(cond, "warning")) {
[17:01:07.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:07.841]                       if (muffled) 
[17:01:07.841]                         invokeRestart("muffleWarning")
[17:01:07.841]                     }
[17:01:07.841]                     else if (inherits(cond, "condition")) {
[17:01:07.841]                       if (!is.null(pattern)) {
[17:01:07.841]                         computeRestarts <- base::computeRestarts
[17:01:07.841]                         grepl <- base::grepl
[17:01:07.841]                         restarts <- computeRestarts(cond)
[17:01:07.841]                         for (restart in restarts) {
[17:01:07.841]                           name <- restart$name
[17:01:07.841]                           if (is.null(name)) 
[17:01:07.841]                             next
[17:01:07.841]                           if (!grepl(pattern, name)) 
[17:01:07.841]                             next
[17:01:07.841]                           invokeRestart(restart)
[17:01:07.841]                           muffled <- TRUE
[17:01:07.841]                           break
[17:01:07.841]                         }
[17:01:07.841]                       }
[17:01:07.841]                     }
[17:01:07.841]                     invisible(muffled)
[17:01:07.841]                   }
[17:01:07.841]                   muffleCondition(cond)
[17:01:07.841]                 })
[17:01:07.841]             }))
[17:01:07.841]             future::FutureResult(value = ...future.value$value, 
[17:01:07.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.841]                   ...future.rng), globalenv = if (FALSE) 
[17:01:07.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:07.841]                     ...future.globalenv.names))
[17:01:07.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:07.841]         }, condition = base::local({
[17:01:07.841]             c <- base::c
[17:01:07.841]             inherits <- base::inherits
[17:01:07.841]             invokeRestart <- base::invokeRestart
[17:01:07.841]             length <- base::length
[17:01:07.841]             list <- base::list
[17:01:07.841]             seq.int <- base::seq.int
[17:01:07.841]             signalCondition <- base::signalCondition
[17:01:07.841]             sys.calls <- base::sys.calls
[17:01:07.841]             `[[` <- base::`[[`
[17:01:07.841]             `+` <- base::`+`
[17:01:07.841]             `<<-` <- base::`<<-`
[17:01:07.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:07.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:07.841]                   3L)]
[17:01:07.841]             }
[17:01:07.841]             function(cond) {
[17:01:07.841]                 is_error <- inherits(cond, "error")
[17:01:07.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:07.841]                   NULL)
[17:01:07.841]                 if (is_error) {
[17:01:07.841]                   sessionInformation <- function() {
[17:01:07.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:07.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:07.841]                       search = base::search(), system = base::Sys.info())
[17:01:07.841]                   }
[17:01:07.841]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:07.841]                     cond$call), session = sessionInformation(), 
[17:01:07.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:07.841]                   signalCondition(cond)
[17:01:07.841]                 }
[17:01:07.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:07.841]                 "immediateCondition"))) {
[17:01:07.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:07.841]                   ...future.conditions[[length(...future.conditions) + 
[17:01:07.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:07.841]                   if (TRUE && !signal) {
[17:01:07.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.841]                     {
[17:01:07.841]                       inherits <- base::inherits
[17:01:07.841]                       invokeRestart <- base::invokeRestart
[17:01:07.841]                       is.null <- base::is.null
[17:01:07.841]                       muffled <- FALSE
[17:01:07.841]                       if (inherits(cond, "message")) {
[17:01:07.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.841]                         if (muffled) 
[17:01:07.841]                           invokeRestart("muffleMessage")
[17:01:07.841]                       }
[17:01:07.841]                       else if (inherits(cond, "warning")) {
[17:01:07.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.841]                         if (muffled) 
[17:01:07.841]                           invokeRestart("muffleWarning")
[17:01:07.841]                       }
[17:01:07.841]                       else if (inherits(cond, "condition")) {
[17:01:07.841]                         if (!is.null(pattern)) {
[17:01:07.841]                           computeRestarts <- base::computeRestarts
[17:01:07.841]                           grepl <- base::grepl
[17:01:07.841]                           restarts <- computeRestarts(cond)
[17:01:07.841]                           for (restart in restarts) {
[17:01:07.841]                             name <- restart$name
[17:01:07.841]                             if (is.null(name)) 
[17:01:07.841]                               next
[17:01:07.841]                             if (!grepl(pattern, name)) 
[17:01:07.841]                               next
[17:01:07.841]                             invokeRestart(restart)
[17:01:07.841]                             muffled <- TRUE
[17:01:07.841]                             break
[17:01:07.841]                           }
[17:01:07.841]                         }
[17:01:07.841]                       }
[17:01:07.841]                       invisible(muffled)
[17:01:07.841]                     }
[17:01:07.841]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.841]                   }
[17:01:07.841]                 }
[17:01:07.841]                 else {
[17:01:07.841]                   if (TRUE) {
[17:01:07.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:07.841]                     {
[17:01:07.841]                       inherits <- base::inherits
[17:01:07.841]                       invokeRestart <- base::invokeRestart
[17:01:07.841]                       is.null <- base::is.null
[17:01:07.841]                       muffled <- FALSE
[17:01:07.841]                       if (inherits(cond, "message")) {
[17:01:07.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:07.841]                         if (muffled) 
[17:01:07.841]                           invokeRestart("muffleMessage")
[17:01:07.841]                       }
[17:01:07.841]                       else if (inherits(cond, "warning")) {
[17:01:07.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:07.841]                         if (muffled) 
[17:01:07.841]                           invokeRestart("muffleWarning")
[17:01:07.841]                       }
[17:01:07.841]                       else if (inherits(cond, "condition")) {
[17:01:07.841]                         if (!is.null(pattern)) {
[17:01:07.841]                           computeRestarts <- base::computeRestarts
[17:01:07.841]                           grepl <- base::grepl
[17:01:07.841]                           restarts <- computeRestarts(cond)
[17:01:07.841]                           for (restart in restarts) {
[17:01:07.841]                             name <- restart$name
[17:01:07.841]                             if (is.null(name)) 
[17:01:07.841]                               next
[17:01:07.841]                             if (!grepl(pattern, name)) 
[17:01:07.841]                               next
[17:01:07.841]                             invokeRestart(restart)
[17:01:07.841]                             muffled <- TRUE
[17:01:07.841]                             break
[17:01:07.841]                           }
[17:01:07.841]                         }
[17:01:07.841]                       }
[17:01:07.841]                       invisible(muffled)
[17:01:07.841]                     }
[17:01:07.841]                     muffleCondition(cond, pattern = "^muffle")
[17:01:07.841]                   }
[17:01:07.841]                 }
[17:01:07.841]             }
[17:01:07.841]         }))
[17:01:07.841]     }, error = function(ex) {
[17:01:07.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:07.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:07.841]                 ...future.rng), started = ...future.startTime, 
[17:01:07.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:07.841]             version = "1.8"), class = "FutureResult")
[17:01:07.841]     }, finally = {
[17:01:07.841]         if (!identical(...future.workdir, getwd())) 
[17:01:07.841]             setwd(...future.workdir)
[17:01:07.841]         {
[17:01:07.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:07.841]                 ...future.oldOptions$nwarnings <- NULL
[17:01:07.841]             }
[17:01:07.841]             base::options(...future.oldOptions)
[17:01:07.841]             if (.Platform$OS.type == "windows") {
[17:01:07.841]                 old_names <- names(...future.oldEnvVars)
[17:01:07.841]                 envs <- base::Sys.getenv()
[17:01:07.841]                 names <- names(envs)
[17:01:07.841]                 common <- intersect(names, old_names)
[17:01:07.841]                 added <- setdiff(names, old_names)
[17:01:07.841]                 removed <- setdiff(old_names, names)
[17:01:07.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:07.841]                   envs[common]]
[17:01:07.841]                 NAMES <- toupper(changed)
[17:01:07.841]                 args <- list()
[17:01:07.841]                 for (kk in seq_along(NAMES)) {
[17:01:07.841]                   name <- changed[[kk]]
[17:01:07.841]                   NAME <- NAMES[[kk]]
[17:01:07.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.841]                     next
[17:01:07.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.841]                 }
[17:01:07.841]                 NAMES <- toupper(added)
[17:01:07.841]                 for (kk in seq_along(NAMES)) {
[17:01:07.841]                   name <- added[[kk]]
[17:01:07.841]                   NAME <- NAMES[[kk]]
[17:01:07.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.841]                     next
[17:01:07.841]                   args[[name]] <- ""
[17:01:07.841]                 }
[17:01:07.841]                 NAMES <- toupper(removed)
[17:01:07.841]                 for (kk in seq_along(NAMES)) {
[17:01:07.841]                   name <- removed[[kk]]
[17:01:07.841]                   NAME <- NAMES[[kk]]
[17:01:07.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:07.841]                     next
[17:01:07.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:07.841]                 }
[17:01:07.841]                 if (length(args) > 0) 
[17:01:07.841]                   base::do.call(base::Sys.setenv, args = args)
[17:01:07.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:07.841]             }
[17:01:07.841]             else {
[17:01:07.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:07.841]             }
[17:01:07.841]             {
[17:01:07.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:07.841]                   0L) {
[17:01:07.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:07.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:07.841]                   base::options(opts)
[17:01:07.841]                 }
[17:01:07.841]                 {
[17:01:07.841]                   {
[17:01:07.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:07.841]                     NULL
[17:01:07.841]                   }
[17:01:07.841]                   options(future.plan = NULL)
[17:01:07.841]                   if (is.na(NA_character_)) 
[17:01:07.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:07.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:07.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:07.841]                     .init = FALSE)
[17:01:07.841]                 }
[17:01:07.841]             }
[17:01:07.841]         }
[17:01:07.841]     })
[17:01:07.841]     if (TRUE) {
[17:01:07.841]         base::sink(type = "output", split = FALSE)
[17:01:07.841]         if (TRUE) {
[17:01:07.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:07.841]         }
[17:01:07.841]         else {
[17:01:07.841]             ...future.result["stdout"] <- base::list(NULL)
[17:01:07.841]         }
[17:01:07.841]         base::close(...future.stdout)
[17:01:07.841]         ...future.stdout <- NULL
[17:01:07.841]     }
[17:01:07.841]     ...future.result$conditions <- ...future.conditions
[17:01:07.841]     ...future.result$finished <- base::Sys.time()
[17:01:07.841]     ...future.result
[17:01:07.841] }
[17:01:07.844] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[17:01:07.844] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:07.888] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:07.888] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[17:01:07.889] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[17:01:07.889] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:07.889] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:07.889] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:07.932] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:07.932] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:07.976] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:07.976] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:01:07.977] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:01:07.977] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:01:07.977] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:01:07.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:07.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.978] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:01:07.978] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:01:07.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:07.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:07.979] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:07.980] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[17:01:07.980] MultisessionFuture started
[17:01:07.980] - Launch lazy future ... done
[17:01:07.980] run() for ‘MultisessionFuture’ ... done
[17:01:07.980] Created future:
[17:01:07.981] MultisessionFuture:
[17:01:07.981] Label: ‘future_vapply-2’
[17:01:07.981] Expression:
[17:01:07.981] {
[17:01:07.981]     do.call(function(...) {
[17:01:07.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:07.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:07.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:07.981]             on.exit(options(oopts), add = TRUE)
[17:01:07.981]         }
[17:01:07.981]         {
[17:01:07.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:07.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:07.981]                 ...future.FUN(...future.X_jj, ...)
[17:01:07.981]             })
[17:01:07.981]         }
[17:01:07.981]     }, args = future.call.arguments)
[17:01:07.981] }
[17:01:07.981] Lazy evaluation: FALSE
[17:01:07.981] Asynchronous evaluation: TRUE
[17:01:07.981] Local evaluation: TRUE
[17:01:07.981] Environment: R_GlobalEnv
[17:01:07.981] Capture standard output: TRUE
[17:01:07.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:07.981] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:07.981] Packages: 1 packages (‘future.apply’)
[17:01:07.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:07.981] Resolved: FALSE
[17:01:07.981] Value: <not collected>
[17:01:07.981] Conditions captured: <none>
[17:01:07.981] Early signaling: FALSE
[17:01:07.981] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:07.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:07.992] Chunk #2 of 2 ... DONE
[17:01:07.992] Launching 2 futures (chunks) ... DONE
[17:01:07.992] Resolving 2 futures (chunks) ...
[17:01:07.993] resolve() on list ...
[17:01:07.993]  recursive: 0
[17:01:07.993]  length: 2
[17:01:07.993] 
[17:01:07.993] receiveMessageFromWorker() for ClusterFuture ...
[17:01:07.993] - Validating connection of MultisessionFuture
[17:01:07.994] - received message: FutureResult
[17:01:07.994] - Received FutureResult
[17:01:07.994] - Erased future from FutureRegistry
[17:01:07.994] result() for ClusterFuture ...
[17:01:07.994] - result already collected: FutureResult
[17:01:07.994] result() for ClusterFuture ... done
[17:01:07.994] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:07.994] Future #1
[17:01:07.994] result() for ClusterFuture ...
[17:01:07.994] - result already collected: FutureResult
[17:01:07.995] result() for ClusterFuture ... done
[17:01:07.995] result() for ClusterFuture ...
[17:01:07.995] - result already collected: FutureResult
[17:01:07.995] result() for ClusterFuture ... done
[17:01:07.995] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:07.995] - nx: 2
[17:01:07.995] - relay: TRUE
[17:01:07.995] - stdout: TRUE
[17:01:07.995] - signal: TRUE
[17:01:07.995] - resignal: FALSE
[17:01:07.995] - force: TRUE
[17:01:07.995] - relayed: [n=2] FALSE, FALSE
[17:01:07.996] - queued futures: [n=2] FALSE, FALSE
[17:01:07.996]  - until=1
[17:01:07.996]  - relaying element #1
[17:01:07.996] result() for ClusterFuture ...
[17:01:07.996] - result already collected: FutureResult
[17:01:07.996] result() for ClusterFuture ... done
[17:01:07.996] result() for ClusterFuture ...
[17:01:07.996] - result already collected: FutureResult
[17:01:07.996] result() for ClusterFuture ... done
[17:01:07.996] result() for ClusterFuture ...
[17:01:07.996] - result already collected: FutureResult
[17:01:07.997] result() for ClusterFuture ... done
[17:01:07.997] result() for ClusterFuture ...
[17:01:07.997] - result already collected: FutureResult
[17:01:07.997] result() for ClusterFuture ... done
[17:01:07.997] - relayed: [n=2] TRUE, FALSE
[17:01:07.997] - queued futures: [n=2] TRUE, FALSE
[17:01:07.997] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:07.997]  length: 1 (resolved future 1)
[17:01:08.025] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.025] - Validating connection of MultisessionFuture
[17:01:08.025] - received message: FutureResult
[17:01:08.026] - Received FutureResult
[17:01:08.026] - Erased future from FutureRegistry
[17:01:08.026] result() for ClusterFuture ...
[17:01:08.026] - result already collected: FutureResult
[17:01:08.026] result() for ClusterFuture ... done
[17:01:08.026] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.026] Future #2
[17:01:08.026] result() for ClusterFuture ...
[17:01:08.026] - result already collected: FutureResult
[17:01:08.026] result() for ClusterFuture ... done
[17:01:08.027] result() for ClusterFuture ...
[17:01:08.027] - result already collected: FutureResult
[17:01:08.027] result() for ClusterFuture ... done
[17:01:08.027] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:08.027] - nx: 2
[17:01:08.027] - relay: TRUE
[17:01:08.027] - stdout: TRUE
[17:01:08.027] - signal: TRUE
[17:01:08.027] - resignal: FALSE
[17:01:08.027] - force: TRUE
[17:01:08.027] - relayed: [n=2] TRUE, FALSE
[17:01:08.028] - queued futures: [n=2] TRUE, FALSE
[17:01:08.028]  - until=2
[17:01:08.028]  - relaying element #2
[17:01:08.028] result() for ClusterFuture ...
[17:01:08.028] - result already collected: FutureResult
[17:01:08.028] result() for ClusterFuture ... done
[17:01:08.028] result() for ClusterFuture ...
[17:01:08.028] - result already collected: FutureResult
[17:01:08.028] result() for ClusterFuture ... done
[17:01:08.028] result() for ClusterFuture ...
[17:01:08.028] - result already collected: FutureResult
[17:01:08.029] result() for ClusterFuture ... done
[17:01:08.029] result() for ClusterFuture ...
[17:01:08.029] - result already collected: FutureResult
[17:01:08.029] result() for ClusterFuture ... done
[17:01:08.029] - relayed: [n=2] TRUE, TRUE
[17:01:08.029] - queued futures: [n=2] TRUE, TRUE
[17:01:08.029] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:08.029]  length: 0 (resolved future 2)
[17:01:08.029] Relaying remaining futures
[17:01:08.029] signalConditionsASAP(NULL, pos=0) ...
[17:01:08.029] - nx: 2
[17:01:08.029] - relay: TRUE
[17:01:08.030] - stdout: TRUE
[17:01:08.030] - signal: TRUE
[17:01:08.030] - resignal: FALSE
[17:01:08.030] - force: TRUE
[17:01:08.030] - relayed: [n=2] TRUE, TRUE
[17:01:08.030] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:08.030] - relayed: [n=2] TRUE, TRUE
[17:01:08.030] - queued futures: [n=2] TRUE, TRUE
[17:01:08.030] signalConditionsASAP(NULL, pos=0) ... done
[17:01:08.030] resolve() on list ... DONE
[17:01:08.030] result() for ClusterFuture ...
[17:01:08.030] - result already collected: FutureResult
[17:01:08.031] result() for ClusterFuture ... done
[17:01:08.031] result() for ClusterFuture ...
[17:01:08.031] - result already collected: FutureResult
[17:01:08.031] result() for ClusterFuture ... done
[17:01:08.031] result() for ClusterFuture ...
[17:01:08.031] - result already collected: FutureResult
[17:01:08.031] result() for ClusterFuture ... done
[17:01:08.031] result() for ClusterFuture ...
[17:01:08.031] - result already collected: FutureResult
[17:01:08.031] result() for ClusterFuture ... done
[17:01:08.031]  - Number of value chunks collected: 2
[17:01:08.032] Resolving 2 futures (chunks) ... DONE
[17:01:08.032] Reducing values from 2 chunks ...
[17:01:08.032]  - Number of values collected after concatenation: 10
[17:01:08.032]  - Number of values expected: 10
[17:01:08.032] Reducing values from 2 chunks ... DONE
[17:01:08.032] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:01:08.034] future_lapply() ...
[17:01:08.040] Number of chunks: 2
[17:01:08.040] getGlobalsAndPackagesXApply() ...
[17:01:08.040]  - future.globals: TRUE
[17:01:08.040] getGlobalsAndPackages() ...
[17:01:08.040] Searching for globals...
[17:01:08.043] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:01:08.044] Searching for globals ... DONE
[17:01:08.044] Resolving globals: FALSE
[17:01:08.044] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:01:08.045] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:08.045] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:08.045] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.045] getGlobalsAndPackages() ... DONE
[17:01:08.045]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:08.045]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:08.046] Finding globals ... DONE
[17:01:08.046]  - use_args: TRUE
[17:01:08.046]  - Getting '...' globals ...
[17:01:08.046] resolve() on list ...
[17:01:08.046]  recursive: 0
[17:01:08.046]  length: 1
[17:01:08.046]  elements: ‘...’
[17:01:08.046]  length: 0 (resolved future 1)
[17:01:08.047] resolve() on list ... DONE
[17:01:08.047]    - '...' content: [n=0] 
[17:01:08.047] List of 1
[17:01:08.047]  $ ...: list()
[17:01:08.047]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.047]  - attr(*, "where")=List of 1
[17:01:08.047]   ..$ ...:<environment: 0x55aadd6e0d68> 
[17:01:08.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.047]  - attr(*, "resolved")= logi TRUE
[17:01:08.047]  - attr(*, "total_size")= num NA
[17:01:08.049]  - Getting '...' globals ... DONE
[17:01:08.049] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:08.049] List of 8
[17:01:08.049]  $ ...future.FUN:function (x, ...)  
[17:01:08.049]  $ x_FUN        :function (x, ...)  
[17:01:08.049]  $ times        : int 5
[17:01:08.049]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:08.049]  $ stop_if_not  :function (...)  
[17:01:08.049]  $ dim          : NULL
[17:01:08.049]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:08.049]  $ ...          : list()
[17:01:08.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.049]  - attr(*, "where")=List of 8
[17:01:08.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:08.049]   ..$ ...          :<environment: 0x55aadd6e0d68> 
[17:01:08.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.049]  - attr(*, "resolved")= logi FALSE
[17:01:08.049]  - attr(*, "total_size")= num 95528
[17:01:08.054] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:08.055] getGlobalsAndPackagesXApply() ... DONE
[17:01:08.055] Number of futures (= number of chunks): 2
[17:01:08.055] Launching 2 futures (chunks) ...
[17:01:08.055] Chunk #1 of 2 ...
[17:01:08.055]  - Finding globals in 'X' for chunk #1 ...
[17:01:08.055] getGlobalsAndPackages() ...
[17:01:08.055] Searching for globals...
[17:01:08.056] 
[17:01:08.056] Searching for globals ... DONE
[17:01:08.056] - globals: [0] <none>
[17:01:08.056] getGlobalsAndPackages() ... DONE
[17:01:08.056]    + additional globals found: [n=0] 
[17:01:08.056]    + additional namespaces needed: [n=0] 
[17:01:08.056]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:08.056]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.056]  - seeds: <none>
[17:01:08.056]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.056] getGlobalsAndPackages() ...
[17:01:08.057] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.057] Resolving globals: FALSE
[17:01:08.057] Tweak future expression to call with '...' arguments ...
[17:01:08.057] {
[17:01:08.057]     do.call(function(...) {
[17:01:08.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.057]             on.exit(options(oopts), add = TRUE)
[17:01:08.057]         }
[17:01:08.057]         {
[17:01:08.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.057]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.057]             })
[17:01:08.057]         }
[17:01:08.057]     }, args = future.call.arguments)
[17:01:08.057] }
[17:01:08.057] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.058] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.058] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.060] getGlobalsAndPackages() ... DONE
[17:01:08.060] run() for ‘Future’ ...
[17:01:08.061] - state: ‘created’
[17:01:08.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.076]   - Field: ‘node’
[17:01:08.076]   - Field: ‘label’
[17:01:08.076]   - Field: ‘local’
[17:01:08.076]   - Field: ‘owner’
[17:01:08.076]   - Field: ‘envir’
[17:01:08.076]   - Field: ‘workers’
[17:01:08.076]   - Field: ‘packages’
[17:01:08.076]   - Field: ‘gc’
[17:01:08.076]   - Field: ‘conditions’
[17:01:08.076]   - Field: ‘persistent’
[17:01:08.077]   - Field: ‘expr’
[17:01:08.077]   - Field: ‘uuid’
[17:01:08.077]   - Field: ‘seed’
[17:01:08.077]   - Field: ‘version’
[17:01:08.077]   - Field: ‘result’
[17:01:08.077]   - Field: ‘asynchronous’
[17:01:08.077]   - Field: ‘calls’
[17:01:08.077]   - Field: ‘globals’
[17:01:08.077]   - Field: ‘stdout’
[17:01:08.077]   - Field: ‘earlySignal’
[17:01:08.077]   - Field: ‘lazy’
[17:01:08.077]   - Field: ‘state’
[17:01:08.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.078] - Launch lazy future ...
[17:01:08.078] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:08.078] Packages needed by future strategies (n = 0): <none>
[17:01:08.079] {
[17:01:08.079]     {
[17:01:08.079]         {
[17:01:08.079]             ...future.startTime <- base::Sys.time()
[17:01:08.079]             {
[17:01:08.079]                 {
[17:01:08.079]                   {
[17:01:08.079]                     {
[17:01:08.079]                       {
[17:01:08.079]                         base::local({
[17:01:08.079]                           has_future <- base::requireNamespace("future", 
[17:01:08.079]                             quietly = TRUE)
[17:01:08.079]                           if (has_future) {
[17:01:08.079]                             ns <- base::getNamespace("future")
[17:01:08.079]                             version <- ns[[".package"]][["version"]]
[17:01:08.079]                             if (is.null(version)) 
[17:01:08.079]                               version <- utils::packageVersion("future")
[17:01:08.079]                           }
[17:01:08.079]                           else {
[17:01:08.079]                             version <- NULL
[17:01:08.079]                           }
[17:01:08.079]                           if (!has_future || version < "1.8.0") {
[17:01:08.079]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.079]                               "", base::R.version$version.string), 
[17:01:08.079]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.079]                                 base::R.version$platform, 8 * 
[17:01:08.079]                                   base::.Machine$sizeof.pointer), 
[17:01:08.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.079]                                 "release", "version")], collapse = " "), 
[17:01:08.079]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.079]                               info)
[17:01:08.079]                             info <- base::paste(info, collapse = "; ")
[17:01:08.079]                             if (!has_future) {
[17:01:08.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.079]                                 info)
[17:01:08.079]                             }
[17:01:08.079]                             else {
[17:01:08.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.079]                                 info, version)
[17:01:08.079]                             }
[17:01:08.079]                             base::stop(msg)
[17:01:08.079]                           }
[17:01:08.079]                         })
[17:01:08.079]                       }
[17:01:08.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.079]                       base::options(mc.cores = 1L)
[17:01:08.079]                     }
[17:01:08.079]                     base::local({
[17:01:08.079]                       for (pkg in c("stats", "future.apply")) {
[17:01:08.079]                         base::loadNamespace(pkg)
[17:01:08.079]                         base::library(pkg, character.only = TRUE)
[17:01:08.079]                       }
[17:01:08.079]                     })
[17:01:08.079]                   }
[17:01:08.079]                   ...future.strategy.old <- future::plan("list")
[17:01:08.079]                   options(future.plan = NULL)
[17:01:08.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.079]                 }
[17:01:08.079]                 ...future.workdir <- getwd()
[17:01:08.079]             }
[17:01:08.079]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.079]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.079]         }
[17:01:08.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.079]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.079]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.079]             base::names(...future.oldOptions))
[17:01:08.079]     }
[17:01:08.079]     if (FALSE) {
[17:01:08.079]     }
[17:01:08.079]     else {
[17:01:08.079]         if (TRUE) {
[17:01:08.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.079]                 open = "w")
[17:01:08.079]         }
[17:01:08.079]         else {
[17:01:08.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.079]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.079]         }
[17:01:08.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.079]             base::sink(type = "output", split = FALSE)
[17:01:08.079]             base::close(...future.stdout)
[17:01:08.079]         }, add = TRUE)
[17:01:08.079]     }
[17:01:08.079]     ...future.frame <- base::sys.nframe()
[17:01:08.079]     ...future.conditions <- base::list()
[17:01:08.079]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.079]     if (FALSE) {
[17:01:08.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.079]     }
[17:01:08.079]     ...future.result <- base::tryCatch({
[17:01:08.079]         base::withCallingHandlers({
[17:01:08.079]             ...future.value <- base::withVisible(base::local({
[17:01:08.079]                 ...future.makeSendCondition <- base::local({
[17:01:08.079]                   sendCondition <- NULL
[17:01:08.079]                   function(frame = 1L) {
[17:01:08.079]                     if (is.function(sendCondition)) 
[17:01:08.079]                       return(sendCondition)
[17:01:08.079]                     ns <- getNamespace("parallel")
[17:01:08.079]                     if (exists("sendData", mode = "function", 
[17:01:08.079]                       envir = ns)) {
[17:01:08.079]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.079]                         envir = ns)
[17:01:08.079]                       envir <- sys.frame(frame)
[17:01:08.079]                       master <- NULL
[17:01:08.079]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.079]                         !identical(envir, emptyenv())) {
[17:01:08.079]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.079]                           inherits = FALSE)) {
[17:01:08.079]                           master <- get("master", mode = "list", 
[17:01:08.079]                             envir = envir, inherits = FALSE)
[17:01:08.079]                           if (inherits(master, c("SOCKnode", 
[17:01:08.079]                             "SOCK0node"))) {
[17:01:08.079]                             sendCondition <<- function(cond) {
[17:01:08.079]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.079]                                 success = TRUE)
[17:01:08.079]                               parallel_sendData(master, data)
[17:01:08.079]                             }
[17:01:08.079]                             return(sendCondition)
[17:01:08.079]                           }
[17:01:08.079]                         }
[17:01:08.079]                         frame <- frame + 1L
[17:01:08.079]                         envir <- sys.frame(frame)
[17:01:08.079]                       }
[17:01:08.079]                     }
[17:01:08.079]                     sendCondition <<- function(cond) NULL
[17:01:08.079]                   }
[17:01:08.079]                 })
[17:01:08.079]                 withCallingHandlers({
[17:01:08.079]                   {
[17:01:08.079]                     do.call(function(...) {
[17:01:08.079]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.079]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.079]                         ...future.globals.maxSize)) {
[17:01:08.079]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.079]                         on.exit(options(oopts), add = TRUE)
[17:01:08.079]                       }
[17:01:08.079]                       {
[17:01:08.079]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.079]                           FUN = function(jj) {
[17:01:08.079]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.079]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.079]                           })
[17:01:08.079]                       }
[17:01:08.079]                     }, args = future.call.arguments)
[17:01:08.079]                   }
[17:01:08.079]                 }, immediateCondition = function(cond) {
[17:01:08.079]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.079]                   sendCondition(cond)
[17:01:08.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.079]                   {
[17:01:08.079]                     inherits <- base::inherits
[17:01:08.079]                     invokeRestart <- base::invokeRestart
[17:01:08.079]                     is.null <- base::is.null
[17:01:08.079]                     muffled <- FALSE
[17:01:08.079]                     if (inherits(cond, "message")) {
[17:01:08.079]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.079]                       if (muffled) 
[17:01:08.079]                         invokeRestart("muffleMessage")
[17:01:08.079]                     }
[17:01:08.079]                     else if (inherits(cond, "warning")) {
[17:01:08.079]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.079]                       if (muffled) 
[17:01:08.079]                         invokeRestart("muffleWarning")
[17:01:08.079]                     }
[17:01:08.079]                     else if (inherits(cond, "condition")) {
[17:01:08.079]                       if (!is.null(pattern)) {
[17:01:08.079]                         computeRestarts <- base::computeRestarts
[17:01:08.079]                         grepl <- base::grepl
[17:01:08.079]                         restarts <- computeRestarts(cond)
[17:01:08.079]                         for (restart in restarts) {
[17:01:08.079]                           name <- restart$name
[17:01:08.079]                           if (is.null(name)) 
[17:01:08.079]                             next
[17:01:08.079]                           if (!grepl(pattern, name)) 
[17:01:08.079]                             next
[17:01:08.079]                           invokeRestart(restart)
[17:01:08.079]                           muffled <- TRUE
[17:01:08.079]                           break
[17:01:08.079]                         }
[17:01:08.079]                       }
[17:01:08.079]                     }
[17:01:08.079]                     invisible(muffled)
[17:01:08.079]                   }
[17:01:08.079]                   muffleCondition(cond)
[17:01:08.079]                 })
[17:01:08.079]             }))
[17:01:08.079]             future::FutureResult(value = ...future.value$value, 
[17:01:08.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.079]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.079]                     ...future.globalenv.names))
[17:01:08.079]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.079]         }, condition = base::local({
[17:01:08.079]             c <- base::c
[17:01:08.079]             inherits <- base::inherits
[17:01:08.079]             invokeRestart <- base::invokeRestart
[17:01:08.079]             length <- base::length
[17:01:08.079]             list <- base::list
[17:01:08.079]             seq.int <- base::seq.int
[17:01:08.079]             signalCondition <- base::signalCondition
[17:01:08.079]             sys.calls <- base::sys.calls
[17:01:08.079]             `[[` <- base::`[[`
[17:01:08.079]             `+` <- base::`+`
[17:01:08.079]             `<<-` <- base::`<<-`
[17:01:08.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.079]                   3L)]
[17:01:08.079]             }
[17:01:08.079]             function(cond) {
[17:01:08.079]                 is_error <- inherits(cond, "error")
[17:01:08.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.079]                   NULL)
[17:01:08.079]                 if (is_error) {
[17:01:08.079]                   sessionInformation <- function() {
[17:01:08.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.079]                       search = base::search(), system = base::Sys.info())
[17:01:08.079]                   }
[17:01:08.079]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.079]                     cond$call), session = sessionInformation(), 
[17:01:08.079]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.079]                   signalCondition(cond)
[17:01:08.079]                 }
[17:01:08.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.079]                 "immediateCondition"))) {
[17:01:08.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.079]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.079]                   if (TRUE && !signal) {
[17:01:08.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.079]                     {
[17:01:08.079]                       inherits <- base::inherits
[17:01:08.079]                       invokeRestart <- base::invokeRestart
[17:01:08.079]                       is.null <- base::is.null
[17:01:08.079]                       muffled <- FALSE
[17:01:08.079]                       if (inherits(cond, "message")) {
[17:01:08.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.079]                         if (muffled) 
[17:01:08.079]                           invokeRestart("muffleMessage")
[17:01:08.079]                       }
[17:01:08.079]                       else if (inherits(cond, "warning")) {
[17:01:08.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.079]                         if (muffled) 
[17:01:08.079]                           invokeRestart("muffleWarning")
[17:01:08.079]                       }
[17:01:08.079]                       else if (inherits(cond, "condition")) {
[17:01:08.079]                         if (!is.null(pattern)) {
[17:01:08.079]                           computeRestarts <- base::computeRestarts
[17:01:08.079]                           grepl <- base::grepl
[17:01:08.079]                           restarts <- computeRestarts(cond)
[17:01:08.079]                           for (restart in restarts) {
[17:01:08.079]                             name <- restart$name
[17:01:08.079]                             if (is.null(name)) 
[17:01:08.079]                               next
[17:01:08.079]                             if (!grepl(pattern, name)) 
[17:01:08.079]                               next
[17:01:08.079]                             invokeRestart(restart)
[17:01:08.079]                             muffled <- TRUE
[17:01:08.079]                             break
[17:01:08.079]                           }
[17:01:08.079]                         }
[17:01:08.079]                       }
[17:01:08.079]                       invisible(muffled)
[17:01:08.079]                     }
[17:01:08.079]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.079]                   }
[17:01:08.079]                 }
[17:01:08.079]                 else {
[17:01:08.079]                   if (TRUE) {
[17:01:08.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.079]                     {
[17:01:08.079]                       inherits <- base::inherits
[17:01:08.079]                       invokeRestart <- base::invokeRestart
[17:01:08.079]                       is.null <- base::is.null
[17:01:08.079]                       muffled <- FALSE
[17:01:08.079]                       if (inherits(cond, "message")) {
[17:01:08.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.079]                         if (muffled) 
[17:01:08.079]                           invokeRestart("muffleMessage")
[17:01:08.079]                       }
[17:01:08.079]                       else if (inherits(cond, "warning")) {
[17:01:08.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.079]                         if (muffled) 
[17:01:08.079]                           invokeRestart("muffleWarning")
[17:01:08.079]                       }
[17:01:08.079]                       else if (inherits(cond, "condition")) {
[17:01:08.079]                         if (!is.null(pattern)) {
[17:01:08.079]                           computeRestarts <- base::computeRestarts
[17:01:08.079]                           grepl <- base::grepl
[17:01:08.079]                           restarts <- computeRestarts(cond)
[17:01:08.079]                           for (restart in restarts) {
[17:01:08.079]                             name <- restart$name
[17:01:08.079]                             if (is.null(name)) 
[17:01:08.079]                               next
[17:01:08.079]                             if (!grepl(pattern, name)) 
[17:01:08.079]                               next
[17:01:08.079]                             invokeRestart(restart)
[17:01:08.079]                             muffled <- TRUE
[17:01:08.079]                             break
[17:01:08.079]                           }
[17:01:08.079]                         }
[17:01:08.079]                       }
[17:01:08.079]                       invisible(muffled)
[17:01:08.079]                     }
[17:01:08.079]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.079]                   }
[17:01:08.079]                 }
[17:01:08.079]             }
[17:01:08.079]         }))
[17:01:08.079]     }, error = function(ex) {
[17:01:08.079]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.079]                 ...future.rng), started = ...future.startTime, 
[17:01:08.079]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.079]             version = "1.8"), class = "FutureResult")
[17:01:08.079]     }, finally = {
[17:01:08.079]         if (!identical(...future.workdir, getwd())) 
[17:01:08.079]             setwd(...future.workdir)
[17:01:08.079]         {
[17:01:08.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.079]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.079]             }
[17:01:08.079]             base::options(...future.oldOptions)
[17:01:08.079]             if (.Platform$OS.type == "windows") {
[17:01:08.079]                 old_names <- names(...future.oldEnvVars)
[17:01:08.079]                 envs <- base::Sys.getenv()
[17:01:08.079]                 names <- names(envs)
[17:01:08.079]                 common <- intersect(names, old_names)
[17:01:08.079]                 added <- setdiff(names, old_names)
[17:01:08.079]                 removed <- setdiff(old_names, names)
[17:01:08.079]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.079]                   envs[common]]
[17:01:08.079]                 NAMES <- toupper(changed)
[17:01:08.079]                 args <- list()
[17:01:08.079]                 for (kk in seq_along(NAMES)) {
[17:01:08.079]                   name <- changed[[kk]]
[17:01:08.079]                   NAME <- NAMES[[kk]]
[17:01:08.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.079]                     next
[17:01:08.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.079]                 }
[17:01:08.079]                 NAMES <- toupper(added)
[17:01:08.079]                 for (kk in seq_along(NAMES)) {
[17:01:08.079]                   name <- added[[kk]]
[17:01:08.079]                   NAME <- NAMES[[kk]]
[17:01:08.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.079]                     next
[17:01:08.079]                   args[[name]] <- ""
[17:01:08.079]                 }
[17:01:08.079]                 NAMES <- toupper(removed)
[17:01:08.079]                 for (kk in seq_along(NAMES)) {
[17:01:08.079]                   name <- removed[[kk]]
[17:01:08.079]                   NAME <- NAMES[[kk]]
[17:01:08.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.079]                     next
[17:01:08.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.079]                 }
[17:01:08.079]                 if (length(args) > 0) 
[17:01:08.079]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.079]             }
[17:01:08.079]             else {
[17:01:08.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.079]             }
[17:01:08.079]             {
[17:01:08.079]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.079]                   0L) {
[17:01:08.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.079]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.079]                   base::options(opts)
[17:01:08.079]                 }
[17:01:08.079]                 {
[17:01:08.079]                   {
[17:01:08.079]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.079]                     NULL
[17:01:08.079]                   }
[17:01:08.079]                   options(future.plan = NULL)
[17:01:08.079]                   if (is.na(NA_character_)) 
[17:01:08.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.079]                     .init = FALSE)
[17:01:08.079]                 }
[17:01:08.079]             }
[17:01:08.079]         }
[17:01:08.079]     })
[17:01:08.079]     if (TRUE) {
[17:01:08.079]         base::sink(type = "output", split = FALSE)
[17:01:08.079]         if (TRUE) {
[17:01:08.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.079]         }
[17:01:08.079]         else {
[17:01:08.079]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.079]         }
[17:01:08.079]         base::close(...future.stdout)
[17:01:08.079]         ...future.stdout <- NULL
[17:01:08.079]     }
[17:01:08.079]     ...future.result$conditions <- ...future.conditions
[17:01:08.079]     ...future.result$finished <- base::Sys.time()
[17:01:08.079]     ...future.result
[17:01:08.079] }
[17:01:08.081] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[17:01:08.082] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:08.124] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:08.124] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[17:01:08.124] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:01:08.125] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:08.125] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:08.125] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:08.168] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:08.168] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:08.212] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:08.212] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:08.212] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.213] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:08.213] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:08.213] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:08.213] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.213] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:01:08.214] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:01:08.214] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:08.214] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.214] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:08.215] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.215] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[17:01:08.215] MultisessionFuture started
[17:01:08.215] - Launch lazy future ... done
[17:01:08.215] run() for ‘MultisessionFuture’ ... done
[17:01:08.216] Created future:
[17:01:08.216] MultisessionFuture:
[17:01:08.216] Label: ‘future_vapply-1’
[17:01:08.216] Expression:
[17:01:08.216] {
[17:01:08.216]     do.call(function(...) {
[17:01:08.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.216]             on.exit(options(oopts), add = TRUE)
[17:01:08.216]         }
[17:01:08.216]         {
[17:01:08.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.216]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.216]             })
[17:01:08.216]         }
[17:01:08.216]     }, args = future.call.arguments)
[17:01:08.216] }
[17:01:08.216] Lazy evaluation: FALSE
[17:01:08.216] Asynchronous evaluation: TRUE
[17:01:08.216] Local evaluation: TRUE
[17:01:08.216] Environment: R_GlobalEnv
[17:01:08.216] Capture standard output: TRUE
[17:01:08.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:08.216] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:08.216] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:08.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:08.216] Resolved: FALSE
[17:01:08.216] Value: <not collected>
[17:01:08.216] Conditions captured: <none>
[17:01:08.216] Early signaling: FALSE
[17:01:08.216] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:08.216] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.227] Chunk #1 of 2 ... DONE
[17:01:08.228] Chunk #2 of 2 ...
[17:01:08.228]  - Finding globals in 'X' for chunk #2 ...
[17:01:08.228] getGlobalsAndPackages() ...
[17:01:08.228] Searching for globals...
[17:01:08.228] 
[17:01:08.228] Searching for globals ... DONE
[17:01:08.229] - globals: [0] <none>
[17:01:08.229] getGlobalsAndPackages() ... DONE
[17:01:08.229]    + additional globals found: [n=0] 
[17:01:08.229]    + additional namespaces needed: [n=0] 
[17:01:08.229]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:08.229]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.229]  - seeds: <none>
[17:01:08.229]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.229] getGlobalsAndPackages() ...
[17:01:08.229] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.229] Resolving globals: FALSE
[17:01:08.230] Tweak future expression to call with '...' arguments ...
[17:01:08.230] {
[17:01:08.230]     do.call(function(...) {
[17:01:08.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.230]             on.exit(options(oopts), add = TRUE)
[17:01:08.230]         }
[17:01:08.230]         {
[17:01:08.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.230]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.230]             })
[17:01:08.230]         }
[17:01:08.230]     }, args = future.call.arguments)
[17:01:08.230] }
[17:01:08.230] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.231] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.231] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.231] getGlobalsAndPackages() ... DONE
[17:01:08.231] run() for ‘Future’ ...
[17:01:08.231] - state: ‘created’
[17:01:08.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.248]   - Field: ‘node’
[17:01:08.248]   - Field: ‘label’
[17:01:08.248]   - Field: ‘local’
[17:01:08.248]   - Field: ‘owner’
[17:01:08.248]   - Field: ‘envir’
[17:01:08.248]   - Field: ‘workers’
[17:01:08.248]   - Field: ‘packages’
[17:01:08.248]   - Field: ‘gc’
[17:01:08.248]   - Field: ‘conditions’
[17:01:08.248]   - Field: ‘persistent’
[17:01:08.249]   - Field: ‘expr’
[17:01:08.249]   - Field: ‘uuid’
[17:01:08.249]   - Field: ‘seed’
[17:01:08.249]   - Field: ‘version’
[17:01:08.249]   - Field: ‘result’
[17:01:08.249]   - Field: ‘asynchronous’
[17:01:08.249]   - Field: ‘calls’
[17:01:08.249]   - Field: ‘globals’
[17:01:08.249]   - Field: ‘stdout’
[17:01:08.249]   - Field: ‘earlySignal’
[17:01:08.250]   - Field: ‘lazy’
[17:01:08.250]   - Field: ‘state’
[17:01:08.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.250] - Launch lazy future ...
[17:01:08.250] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:08.250] Packages needed by future strategies (n = 0): <none>
[17:01:08.251] {
[17:01:08.251]     {
[17:01:08.251]         {
[17:01:08.251]             ...future.startTime <- base::Sys.time()
[17:01:08.251]             {
[17:01:08.251]                 {
[17:01:08.251]                   {
[17:01:08.251]                     {
[17:01:08.251]                       {
[17:01:08.251]                         base::local({
[17:01:08.251]                           has_future <- base::requireNamespace("future", 
[17:01:08.251]                             quietly = TRUE)
[17:01:08.251]                           if (has_future) {
[17:01:08.251]                             ns <- base::getNamespace("future")
[17:01:08.251]                             version <- ns[[".package"]][["version"]]
[17:01:08.251]                             if (is.null(version)) 
[17:01:08.251]                               version <- utils::packageVersion("future")
[17:01:08.251]                           }
[17:01:08.251]                           else {
[17:01:08.251]                             version <- NULL
[17:01:08.251]                           }
[17:01:08.251]                           if (!has_future || version < "1.8.0") {
[17:01:08.251]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.251]                               "", base::R.version$version.string), 
[17:01:08.251]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.251]                                 base::R.version$platform, 8 * 
[17:01:08.251]                                   base::.Machine$sizeof.pointer), 
[17:01:08.251]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.251]                                 "release", "version")], collapse = " "), 
[17:01:08.251]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.251]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.251]                               info)
[17:01:08.251]                             info <- base::paste(info, collapse = "; ")
[17:01:08.251]                             if (!has_future) {
[17:01:08.251]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.251]                                 info)
[17:01:08.251]                             }
[17:01:08.251]                             else {
[17:01:08.251]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.251]                                 info, version)
[17:01:08.251]                             }
[17:01:08.251]                             base::stop(msg)
[17:01:08.251]                           }
[17:01:08.251]                         })
[17:01:08.251]                       }
[17:01:08.251]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.251]                       base::options(mc.cores = 1L)
[17:01:08.251]                     }
[17:01:08.251]                     base::local({
[17:01:08.251]                       for (pkg in c("stats", "future.apply")) {
[17:01:08.251]                         base::loadNamespace(pkg)
[17:01:08.251]                         base::library(pkg, character.only = TRUE)
[17:01:08.251]                       }
[17:01:08.251]                     })
[17:01:08.251]                   }
[17:01:08.251]                   ...future.strategy.old <- future::plan("list")
[17:01:08.251]                   options(future.plan = NULL)
[17:01:08.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.251]                 }
[17:01:08.251]                 ...future.workdir <- getwd()
[17:01:08.251]             }
[17:01:08.251]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.251]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.251]         }
[17:01:08.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.251]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.251]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.251]             base::names(...future.oldOptions))
[17:01:08.251]     }
[17:01:08.251]     if (FALSE) {
[17:01:08.251]     }
[17:01:08.251]     else {
[17:01:08.251]         if (TRUE) {
[17:01:08.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.251]                 open = "w")
[17:01:08.251]         }
[17:01:08.251]         else {
[17:01:08.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.251]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.251]         }
[17:01:08.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.251]             base::sink(type = "output", split = FALSE)
[17:01:08.251]             base::close(...future.stdout)
[17:01:08.251]         }, add = TRUE)
[17:01:08.251]     }
[17:01:08.251]     ...future.frame <- base::sys.nframe()
[17:01:08.251]     ...future.conditions <- base::list()
[17:01:08.251]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.251]     if (FALSE) {
[17:01:08.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.251]     }
[17:01:08.251]     ...future.result <- base::tryCatch({
[17:01:08.251]         base::withCallingHandlers({
[17:01:08.251]             ...future.value <- base::withVisible(base::local({
[17:01:08.251]                 ...future.makeSendCondition <- base::local({
[17:01:08.251]                   sendCondition <- NULL
[17:01:08.251]                   function(frame = 1L) {
[17:01:08.251]                     if (is.function(sendCondition)) 
[17:01:08.251]                       return(sendCondition)
[17:01:08.251]                     ns <- getNamespace("parallel")
[17:01:08.251]                     if (exists("sendData", mode = "function", 
[17:01:08.251]                       envir = ns)) {
[17:01:08.251]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.251]                         envir = ns)
[17:01:08.251]                       envir <- sys.frame(frame)
[17:01:08.251]                       master <- NULL
[17:01:08.251]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.251]                         !identical(envir, emptyenv())) {
[17:01:08.251]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.251]                           inherits = FALSE)) {
[17:01:08.251]                           master <- get("master", mode = "list", 
[17:01:08.251]                             envir = envir, inherits = FALSE)
[17:01:08.251]                           if (inherits(master, c("SOCKnode", 
[17:01:08.251]                             "SOCK0node"))) {
[17:01:08.251]                             sendCondition <<- function(cond) {
[17:01:08.251]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.251]                                 success = TRUE)
[17:01:08.251]                               parallel_sendData(master, data)
[17:01:08.251]                             }
[17:01:08.251]                             return(sendCondition)
[17:01:08.251]                           }
[17:01:08.251]                         }
[17:01:08.251]                         frame <- frame + 1L
[17:01:08.251]                         envir <- sys.frame(frame)
[17:01:08.251]                       }
[17:01:08.251]                     }
[17:01:08.251]                     sendCondition <<- function(cond) NULL
[17:01:08.251]                   }
[17:01:08.251]                 })
[17:01:08.251]                 withCallingHandlers({
[17:01:08.251]                   {
[17:01:08.251]                     do.call(function(...) {
[17:01:08.251]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.251]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.251]                         ...future.globals.maxSize)) {
[17:01:08.251]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.251]                         on.exit(options(oopts), add = TRUE)
[17:01:08.251]                       }
[17:01:08.251]                       {
[17:01:08.251]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.251]                           FUN = function(jj) {
[17:01:08.251]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.251]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.251]                           })
[17:01:08.251]                       }
[17:01:08.251]                     }, args = future.call.arguments)
[17:01:08.251]                   }
[17:01:08.251]                 }, immediateCondition = function(cond) {
[17:01:08.251]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.251]                   sendCondition(cond)
[17:01:08.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.251]                   {
[17:01:08.251]                     inherits <- base::inherits
[17:01:08.251]                     invokeRestart <- base::invokeRestart
[17:01:08.251]                     is.null <- base::is.null
[17:01:08.251]                     muffled <- FALSE
[17:01:08.251]                     if (inherits(cond, "message")) {
[17:01:08.251]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.251]                       if (muffled) 
[17:01:08.251]                         invokeRestart("muffleMessage")
[17:01:08.251]                     }
[17:01:08.251]                     else if (inherits(cond, "warning")) {
[17:01:08.251]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.251]                       if (muffled) 
[17:01:08.251]                         invokeRestart("muffleWarning")
[17:01:08.251]                     }
[17:01:08.251]                     else if (inherits(cond, "condition")) {
[17:01:08.251]                       if (!is.null(pattern)) {
[17:01:08.251]                         computeRestarts <- base::computeRestarts
[17:01:08.251]                         grepl <- base::grepl
[17:01:08.251]                         restarts <- computeRestarts(cond)
[17:01:08.251]                         for (restart in restarts) {
[17:01:08.251]                           name <- restart$name
[17:01:08.251]                           if (is.null(name)) 
[17:01:08.251]                             next
[17:01:08.251]                           if (!grepl(pattern, name)) 
[17:01:08.251]                             next
[17:01:08.251]                           invokeRestart(restart)
[17:01:08.251]                           muffled <- TRUE
[17:01:08.251]                           break
[17:01:08.251]                         }
[17:01:08.251]                       }
[17:01:08.251]                     }
[17:01:08.251]                     invisible(muffled)
[17:01:08.251]                   }
[17:01:08.251]                   muffleCondition(cond)
[17:01:08.251]                 })
[17:01:08.251]             }))
[17:01:08.251]             future::FutureResult(value = ...future.value$value, 
[17:01:08.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.251]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.251]                     ...future.globalenv.names))
[17:01:08.251]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.251]         }, condition = base::local({
[17:01:08.251]             c <- base::c
[17:01:08.251]             inherits <- base::inherits
[17:01:08.251]             invokeRestart <- base::invokeRestart
[17:01:08.251]             length <- base::length
[17:01:08.251]             list <- base::list
[17:01:08.251]             seq.int <- base::seq.int
[17:01:08.251]             signalCondition <- base::signalCondition
[17:01:08.251]             sys.calls <- base::sys.calls
[17:01:08.251]             `[[` <- base::`[[`
[17:01:08.251]             `+` <- base::`+`
[17:01:08.251]             `<<-` <- base::`<<-`
[17:01:08.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.251]                   3L)]
[17:01:08.251]             }
[17:01:08.251]             function(cond) {
[17:01:08.251]                 is_error <- inherits(cond, "error")
[17:01:08.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.251]                   NULL)
[17:01:08.251]                 if (is_error) {
[17:01:08.251]                   sessionInformation <- function() {
[17:01:08.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.251]                       search = base::search(), system = base::Sys.info())
[17:01:08.251]                   }
[17:01:08.251]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.251]                     cond$call), session = sessionInformation(), 
[17:01:08.251]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.251]                   signalCondition(cond)
[17:01:08.251]                 }
[17:01:08.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.251]                 "immediateCondition"))) {
[17:01:08.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.251]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.251]                   if (TRUE && !signal) {
[17:01:08.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.251]                     {
[17:01:08.251]                       inherits <- base::inherits
[17:01:08.251]                       invokeRestart <- base::invokeRestart
[17:01:08.251]                       is.null <- base::is.null
[17:01:08.251]                       muffled <- FALSE
[17:01:08.251]                       if (inherits(cond, "message")) {
[17:01:08.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.251]                         if (muffled) 
[17:01:08.251]                           invokeRestart("muffleMessage")
[17:01:08.251]                       }
[17:01:08.251]                       else if (inherits(cond, "warning")) {
[17:01:08.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.251]                         if (muffled) 
[17:01:08.251]                           invokeRestart("muffleWarning")
[17:01:08.251]                       }
[17:01:08.251]                       else if (inherits(cond, "condition")) {
[17:01:08.251]                         if (!is.null(pattern)) {
[17:01:08.251]                           computeRestarts <- base::computeRestarts
[17:01:08.251]                           grepl <- base::grepl
[17:01:08.251]                           restarts <- computeRestarts(cond)
[17:01:08.251]                           for (restart in restarts) {
[17:01:08.251]                             name <- restart$name
[17:01:08.251]                             if (is.null(name)) 
[17:01:08.251]                               next
[17:01:08.251]                             if (!grepl(pattern, name)) 
[17:01:08.251]                               next
[17:01:08.251]                             invokeRestart(restart)
[17:01:08.251]                             muffled <- TRUE
[17:01:08.251]                             break
[17:01:08.251]                           }
[17:01:08.251]                         }
[17:01:08.251]                       }
[17:01:08.251]                       invisible(muffled)
[17:01:08.251]                     }
[17:01:08.251]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.251]                   }
[17:01:08.251]                 }
[17:01:08.251]                 else {
[17:01:08.251]                   if (TRUE) {
[17:01:08.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.251]                     {
[17:01:08.251]                       inherits <- base::inherits
[17:01:08.251]                       invokeRestart <- base::invokeRestart
[17:01:08.251]                       is.null <- base::is.null
[17:01:08.251]                       muffled <- FALSE
[17:01:08.251]                       if (inherits(cond, "message")) {
[17:01:08.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.251]                         if (muffled) 
[17:01:08.251]                           invokeRestart("muffleMessage")
[17:01:08.251]                       }
[17:01:08.251]                       else if (inherits(cond, "warning")) {
[17:01:08.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.251]                         if (muffled) 
[17:01:08.251]                           invokeRestart("muffleWarning")
[17:01:08.251]                       }
[17:01:08.251]                       else if (inherits(cond, "condition")) {
[17:01:08.251]                         if (!is.null(pattern)) {
[17:01:08.251]                           computeRestarts <- base::computeRestarts
[17:01:08.251]                           grepl <- base::grepl
[17:01:08.251]                           restarts <- computeRestarts(cond)
[17:01:08.251]                           for (restart in restarts) {
[17:01:08.251]                             name <- restart$name
[17:01:08.251]                             if (is.null(name)) 
[17:01:08.251]                               next
[17:01:08.251]                             if (!grepl(pattern, name)) 
[17:01:08.251]                               next
[17:01:08.251]                             invokeRestart(restart)
[17:01:08.251]                             muffled <- TRUE
[17:01:08.251]                             break
[17:01:08.251]                           }
[17:01:08.251]                         }
[17:01:08.251]                       }
[17:01:08.251]                       invisible(muffled)
[17:01:08.251]                     }
[17:01:08.251]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.251]                   }
[17:01:08.251]                 }
[17:01:08.251]             }
[17:01:08.251]         }))
[17:01:08.251]     }, error = function(ex) {
[17:01:08.251]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.251]                 ...future.rng), started = ...future.startTime, 
[17:01:08.251]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.251]             version = "1.8"), class = "FutureResult")
[17:01:08.251]     }, finally = {
[17:01:08.251]         if (!identical(...future.workdir, getwd())) 
[17:01:08.251]             setwd(...future.workdir)
[17:01:08.251]         {
[17:01:08.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.251]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.251]             }
[17:01:08.251]             base::options(...future.oldOptions)
[17:01:08.251]             if (.Platform$OS.type == "windows") {
[17:01:08.251]                 old_names <- names(...future.oldEnvVars)
[17:01:08.251]                 envs <- base::Sys.getenv()
[17:01:08.251]                 names <- names(envs)
[17:01:08.251]                 common <- intersect(names, old_names)
[17:01:08.251]                 added <- setdiff(names, old_names)
[17:01:08.251]                 removed <- setdiff(old_names, names)
[17:01:08.251]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.251]                   envs[common]]
[17:01:08.251]                 NAMES <- toupper(changed)
[17:01:08.251]                 args <- list()
[17:01:08.251]                 for (kk in seq_along(NAMES)) {
[17:01:08.251]                   name <- changed[[kk]]
[17:01:08.251]                   NAME <- NAMES[[kk]]
[17:01:08.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.251]                     next
[17:01:08.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.251]                 }
[17:01:08.251]                 NAMES <- toupper(added)
[17:01:08.251]                 for (kk in seq_along(NAMES)) {
[17:01:08.251]                   name <- added[[kk]]
[17:01:08.251]                   NAME <- NAMES[[kk]]
[17:01:08.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.251]                     next
[17:01:08.251]                   args[[name]] <- ""
[17:01:08.251]                 }
[17:01:08.251]                 NAMES <- toupper(removed)
[17:01:08.251]                 for (kk in seq_along(NAMES)) {
[17:01:08.251]                   name <- removed[[kk]]
[17:01:08.251]                   NAME <- NAMES[[kk]]
[17:01:08.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.251]                     next
[17:01:08.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.251]                 }
[17:01:08.251]                 if (length(args) > 0) 
[17:01:08.251]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.251]             }
[17:01:08.251]             else {
[17:01:08.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.251]             }
[17:01:08.251]             {
[17:01:08.251]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.251]                   0L) {
[17:01:08.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.251]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.251]                   base::options(opts)
[17:01:08.251]                 }
[17:01:08.251]                 {
[17:01:08.251]                   {
[17:01:08.251]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.251]                     NULL
[17:01:08.251]                   }
[17:01:08.251]                   options(future.plan = NULL)
[17:01:08.251]                   if (is.na(NA_character_)) 
[17:01:08.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.251]                     .init = FALSE)
[17:01:08.251]                 }
[17:01:08.251]             }
[17:01:08.251]         }
[17:01:08.251]     })
[17:01:08.251]     if (TRUE) {
[17:01:08.251]         base::sink(type = "output", split = FALSE)
[17:01:08.251]         if (TRUE) {
[17:01:08.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.251]         }
[17:01:08.251]         else {
[17:01:08.251]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.251]         }
[17:01:08.251]         base::close(...future.stdout)
[17:01:08.251]         ...future.stdout <- NULL
[17:01:08.251]     }
[17:01:08.251]     ...future.result$conditions <- ...future.conditions
[17:01:08.251]     ...future.result$finished <- base::Sys.time()
[17:01:08.251]     ...future.result
[17:01:08.251] }
[17:01:08.254] Exporting 11 global objects (93.29 KiB) to cluster node #2 ...
[17:01:08.254] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:08.296] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:08.296] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ...
[17:01:08.296] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #2 ... DONE
[17:01:08.297] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:08.297] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:08.297] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:08.340] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:08.340] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:08.384] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:08.384] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:08.384] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.385] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:01:08.385] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:01:08.385] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:08.386] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.386] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ...
[17:01:08.386] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #2 ... DONE
[17:01:08.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:08.387] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:08.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.387] Exporting 11 global objects (93.29 KiB) to cluster node #2 ... DONE
[17:01:08.388] MultisessionFuture started
[17:01:08.388] - Launch lazy future ... done
[17:01:08.388] run() for ‘MultisessionFuture’ ... done
[17:01:08.388] Created future:
[17:01:08.392] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.392] - Validating connection of MultisessionFuture
[17:01:08.392] - received message: FutureResult
[17:01:08.392] - Received FutureResult
[17:01:08.392] - Erased future from FutureRegistry
[17:01:08.392] result() for ClusterFuture ...
[17:01:08.392] - result already collected: FutureResult
[17:01:08.393] result() for ClusterFuture ... done
[17:01:08.393] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.388] MultisessionFuture:
[17:01:08.388] Label: ‘future_vapply-2’
[17:01:08.388] Expression:
[17:01:08.388] {
[17:01:08.388]     do.call(function(...) {
[17:01:08.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.388]             on.exit(options(oopts), add = TRUE)
[17:01:08.388]         }
[17:01:08.388]         {
[17:01:08.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.388]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.388]             })
[17:01:08.388]         }
[17:01:08.388]     }, args = future.call.arguments)
[17:01:08.388] }
[17:01:08.388] Lazy evaluation: FALSE
[17:01:08.388] Asynchronous evaluation: TRUE
[17:01:08.388] Local evaluation: TRUE
[17:01:08.388] Environment: R_GlobalEnv
[17:01:08.388] Capture standard output: TRUE
[17:01:08.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:08.388] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:08.388] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:08.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:08.388] Resolved: TRUE
[17:01:08.388] Value: <not collected>
[17:01:08.388] Conditions captured: <none>
[17:01:08.388] Early signaling: FALSE
[17:01:08.388] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:08.388] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.393] Chunk #2 of 2 ... DONE
[17:01:08.393] Launching 2 futures (chunks) ... DONE
[17:01:08.393] Resolving 2 futures (chunks) ...
[17:01:08.393] resolve() on list ...
[17:01:08.393]  recursive: 0
[17:01:08.393]  length: 2
[17:01:08.393] 
[17:01:08.394] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.394] - Validating connection of MultisessionFuture
[17:01:08.394] - received message: FutureResult
[17:01:08.394] - Received FutureResult
[17:01:08.394] - Erased future from FutureRegistry
[17:01:08.395] result() for ClusterFuture ...
[17:01:08.395] - result already collected: FutureResult
[17:01:08.395] result() for ClusterFuture ... done
[17:01:08.395] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.395] Future #1
[17:01:08.395] result() for ClusterFuture ...
[17:01:08.395] - result already collected: FutureResult
[17:01:08.395] result() for ClusterFuture ... done
[17:01:08.395] result() for ClusterFuture ...
[17:01:08.395] - result already collected: FutureResult
[17:01:08.395] result() for ClusterFuture ... done
[17:01:08.396] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:08.396] - nx: 2
[17:01:08.396] - relay: TRUE
[17:01:08.396] - stdout: TRUE
[17:01:08.396] - signal: TRUE
[17:01:08.396] - resignal: FALSE
[17:01:08.396] - force: TRUE
[17:01:08.396] - relayed: [n=2] FALSE, FALSE
[17:01:08.396] - queued futures: [n=2] FALSE, FALSE
[17:01:08.396]  - until=1
[17:01:08.396]  - relaying element #1
[17:01:08.396] result() for ClusterFuture ...
[17:01:08.397] - result already collected: FutureResult
[17:01:08.397] result() for ClusterFuture ... done
[17:01:08.397] result() for ClusterFuture ...
[17:01:08.397] - result already collected: FutureResult
[17:01:08.397] result() for ClusterFuture ... done
[17:01:08.397] result() for ClusterFuture ...
[17:01:08.397] - result already collected: FutureResult
[17:01:08.397] result() for ClusterFuture ... done
[17:01:08.397] result() for ClusterFuture ...
[17:01:08.397] - result already collected: FutureResult
[17:01:08.397] result() for ClusterFuture ... done
[17:01:08.398] - relayed: [n=2] TRUE, FALSE
[17:01:08.398] - queued futures: [n=2] TRUE, FALSE
[17:01:08.398] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:08.398]  length: 1 (resolved future 1)
[17:01:08.398] Future #2
[17:01:08.398] result() for ClusterFuture ...
[17:01:08.398] - result already collected: FutureResult
[17:01:08.398] result() for ClusterFuture ... done
[17:01:08.398] result() for ClusterFuture ...
[17:01:08.398] - result already collected: FutureResult
[17:01:08.398] result() for ClusterFuture ... done
[17:01:08.399] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:08.399] - nx: 2
[17:01:08.399] - relay: TRUE
[17:01:08.399] - stdout: TRUE
[17:01:08.399] - signal: TRUE
[17:01:08.399] - resignal: FALSE
[17:01:08.399] - force: TRUE
[17:01:08.399] - relayed: [n=2] TRUE, FALSE
[17:01:08.399] - queued futures: [n=2] TRUE, FALSE
[17:01:08.399]  - until=2
[17:01:08.399]  - relaying element #2
[17:01:08.400] result() for ClusterFuture ...
[17:01:08.400] - result already collected: FutureResult
[17:01:08.400] result() for ClusterFuture ... done
[17:01:08.400] result() for ClusterFuture ...
[17:01:08.400] - result already collected: FutureResult
[17:01:08.400] result() for ClusterFuture ... done
[17:01:08.400] result() for ClusterFuture ...
[17:01:08.400] - result already collected: FutureResult
[17:01:08.400] result() for ClusterFuture ... done
[17:01:08.400] result() for ClusterFuture ...
[17:01:08.400] - result already collected: FutureResult
[17:01:08.400] result() for ClusterFuture ... done
[17:01:08.401] - relayed: [n=2] TRUE, TRUE
[17:01:08.401] - queued futures: [n=2] TRUE, TRUE
[17:01:08.401] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:08.401]  length: 0 (resolved future 2)
[17:01:08.401] Relaying remaining futures
[17:01:08.401] signalConditionsASAP(NULL, pos=0) ...
[17:01:08.401] - nx: 2
[17:01:08.401] - relay: TRUE
[17:01:08.401] - stdout: TRUE
[17:01:08.401] - signal: TRUE
[17:01:08.401] - resignal: FALSE
[17:01:08.401] - force: TRUE
[17:01:08.402] - relayed: [n=2] TRUE, TRUE
[17:01:08.402] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:08.402] - relayed: [n=2] TRUE, TRUE
[17:01:08.402] - queued futures: [n=2] TRUE, TRUE
[17:01:08.402] signalConditionsASAP(NULL, pos=0) ... done
[17:01:08.402] resolve() on list ... DONE
[17:01:08.402] result() for ClusterFuture ...
[17:01:08.402] - result already collected: FutureResult
[17:01:08.402] result() for ClusterFuture ... done
[17:01:08.402] result() for ClusterFuture ...
[17:01:08.402] - result already collected: FutureResult
[17:01:08.403] result() for ClusterFuture ... done
[17:01:08.403] result() for ClusterFuture ...
[17:01:08.403] - result already collected: FutureResult
[17:01:08.403] result() for ClusterFuture ... done
[17:01:08.403] result() for ClusterFuture ...
[17:01:08.403] - result already collected: FutureResult
[17:01:08.403] result() for ClusterFuture ... done
[17:01:08.403]  - Number of value chunks collected: 2
[17:01:08.403] Resolving 2 futures (chunks) ... DONE
[17:01:08.403] Reducing values from 2 chunks ...
[17:01:08.403]  - Number of values collected after concatenation: 3
[17:01:08.403]  - Number of values expected: 3
[17:01:08.404] Reducing values from 2 chunks ... DONE
[17:01:08.404] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:01:08.405] future_lapply() ...
[17:01:08.413] Number of chunks: 2
[17:01:08.413] getGlobalsAndPackagesXApply() ...
[17:01:08.413]  - future.globals: TRUE
[17:01:08.413] getGlobalsAndPackages() ...
[17:01:08.413] Searching for globals...
[17:01:08.418] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:08.418] Searching for globals ... DONE
[17:01:08.418] Resolving globals: FALSE
[17:01:08.419] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:01:08.419] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:01:08.419] - globals: [1] ‘FUN’
[17:01:08.419] - packages: [1] ‘stats’
[17:01:08.419] getGlobalsAndPackages() ... DONE
[17:01:08.419]  - globals found/used: [n=1] ‘FUN’
[17:01:08.420]  - needed namespaces: [n=1] ‘stats’
[17:01:08.420] Finding globals ... DONE
[17:01:08.420]  - use_args: TRUE
[17:01:08.420]  - Getting '...' globals ...
[17:01:08.420] resolve() on list ...
[17:01:08.420]  recursive: 0
[17:01:08.420]  length: 1
[17:01:08.420]  elements: ‘...’
[17:01:08.421]  length: 0 (resolved future 1)
[17:01:08.421] resolve() on list ... DONE
[17:01:08.421]    - '...' content: [n=0] 
[17:01:08.421] List of 1
[17:01:08.421]  $ ...: list()
[17:01:08.421]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.421]  - attr(*, "where")=List of 1
[17:01:08.421]   ..$ ...:<environment: 0x55aadcfe1eb8> 
[17:01:08.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.421]  - attr(*, "resolved")= logi TRUE
[17:01:08.421]  - attr(*, "total_size")= num NA
[17:01:08.423]  - Getting '...' globals ... DONE
[17:01:08.423] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:08.424] List of 2
[17:01:08.424]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:01:08.424]  $ ...          : list()
[17:01:08.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.424]  - attr(*, "where")=List of 2
[17:01:08.424]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:08.424]   ..$ ...          :<environment: 0x55aadcfe1eb8> 
[17:01:08.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.424]  - attr(*, "resolved")= logi FALSE
[17:01:08.424]  - attr(*, "total_size")= num 46960
[17:01:08.426] Packages to be attached in all futures: [n=1] ‘stats’
[17:01:08.426] getGlobalsAndPackagesXApply() ... DONE
[17:01:08.426] Number of futures (= number of chunks): 2
[17:01:08.426] Launching 2 futures (chunks) ...
[17:01:08.427] Chunk #1 of 2 ...
[17:01:08.427]  - Finding globals in 'X' for chunk #1 ...
[17:01:08.427] getGlobalsAndPackages() ...
[17:01:08.427] Searching for globals...
[17:01:08.427] 
[17:01:08.427] Searching for globals ... DONE
[17:01:08.427] - globals: [0] <none>
[17:01:08.427] getGlobalsAndPackages() ... DONE
[17:01:08.427]    + additional globals found: [n=0] 
[17:01:08.428]    + additional namespaces needed: [n=0] 
[17:01:08.428]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:08.428]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.428]  - seeds: <none>
[17:01:08.428]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.428] getGlobalsAndPackages() ...
[17:01:08.428] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.428] Resolving globals: FALSE
[17:01:08.428] Tweak future expression to call with '...' arguments ...
[17:01:08.428] {
[17:01:08.428]     do.call(function(...) {
[17:01:08.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.428]             on.exit(options(oopts), add = TRUE)
[17:01:08.428]         }
[17:01:08.428]         {
[17:01:08.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.428]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.428]             })
[17:01:08.428]         }
[17:01:08.428]     }, args = future.call.arguments)
[17:01:08.428] }
[17:01:08.429] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.429] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.429] - packages: [1] ‘stats’
[17:01:08.429] getGlobalsAndPackages() ... DONE
[17:01:08.430] run() for ‘Future’ ...
[17:01:08.430] - state: ‘created’
[17:01:08.430] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.444] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.444] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.444]   - Field: ‘node’
[17:01:08.444]   - Field: ‘label’
[17:01:08.444]   - Field: ‘local’
[17:01:08.444]   - Field: ‘owner’
[17:01:08.445]   - Field: ‘envir’
[17:01:08.445]   - Field: ‘workers’
[17:01:08.445]   - Field: ‘packages’
[17:01:08.445]   - Field: ‘gc’
[17:01:08.445]   - Field: ‘conditions’
[17:01:08.445]   - Field: ‘persistent’
[17:01:08.445]   - Field: ‘expr’
[17:01:08.445]   - Field: ‘uuid’
[17:01:08.445]   - Field: ‘seed’
[17:01:08.445]   - Field: ‘version’
[17:01:08.445]   - Field: ‘result’
[17:01:08.445]   - Field: ‘asynchronous’
[17:01:08.446]   - Field: ‘calls’
[17:01:08.446]   - Field: ‘globals’
[17:01:08.446]   - Field: ‘stdout’
[17:01:08.446]   - Field: ‘earlySignal’
[17:01:08.446]   - Field: ‘lazy’
[17:01:08.446]   - Field: ‘state’
[17:01:08.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.446] - Launch lazy future ...
[17:01:08.446] Packages needed by the future expression (n = 1): ‘stats’
[17:01:08.447] Packages needed by future strategies (n = 0): <none>
[17:01:08.447] {
[17:01:08.447]     {
[17:01:08.447]         {
[17:01:08.447]             ...future.startTime <- base::Sys.time()
[17:01:08.447]             {
[17:01:08.447]                 {
[17:01:08.447]                   {
[17:01:08.447]                     {
[17:01:08.447]                       {
[17:01:08.447]                         base::local({
[17:01:08.447]                           has_future <- base::requireNamespace("future", 
[17:01:08.447]                             quietly = TRUE)
[17:01:08.447]                           if (has_future) {
[17:01:08.447]                             ns <- base::getNamespace("future")
[17:01:08.447]                             version <- ns[[".package"]][["version"]]
[17:01:08.447]                             if (is.null(version)) 
[17:01:08.447]                               version <- utils::packageVersion("future")
[17:01:08.447]                           }
[17:01:08.447]                           else {
[17:01:08.447]                             version <- NULL
[17:01:08.447]                           }
[17:01:08.447]                           if (!has_future || version < "1.8.0") {
[17:01:08.447]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.447]                               "", base::R.version$version.string), 
[17:01:08.447]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.447]                                 base::R.version$platform, 8 * 
[17:01:08.447]                                   base::.Machine$sizeof.pointer), 
[17:01:08.447]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.447]                                 "release", "version")], collapse = " "), 
[17:01:08.447]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.447]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.447]                               info)
[17:01:08.447]                             info <- base::paste(info, collapse = "; ")
[17:01:08.447]                             if (!has_future) {
[17:01:08.447]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.447]                                 info)
[17:01:08.447]                             }
[17:01:08.447]                             else {
[17:01:08.447]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.447]                                 info, version)
[17:01:08.447]                             }
[17:01:08.447]                             base::stop(msg)
[17:01:08.447]                           }
[17:01:08.447]                         })
[17:01:08.447]                       }
[17:01:08.447]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.447]                       base::options(mc.cores = 1L)
[17:01:08.447]                     }
[17:01:08.447]                     base::local({
[17:01:08.447]                       for (pkg in "stats") {
[17:01:08.447]                         base::loadNamespace(pkg)
[17:01:08.447]                         base::library(pkg, character.only = TRUE)
[17:01:08.447]                       }
[17:01:08.447]                     })
[17:01:08.447]                   }
[17:01:08.447]                   ...future.strategy.old <- future::plan("list")
[17:01:08.447]                   options(future.plan = NULL)
[17:01:08.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.447]                 }
[17:01:08.447]                 ...future.workdir <- getwd()
[17:01:08.447]             }
[17:01:08.447]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.447]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.447]         }
[17:01:08.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.447]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.447]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.447]             base::names(...future.oldOptions))
[17:01:08.447]     }
[17:01:08.447]     if (FALSE) {
[17:01:08.447]     }
[17:01:08.447]     else {
[17:01:08.447]         if (TRUE) {
[17:01:08.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.447]                 open = "w")
[17:01:08.447]         }
[17:01:08.447]         else {
[17:01:08.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.447]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.447]         }
[17:01:08.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.447]             base::sink(type = "output", split = FALSE)
[17:01:08.447]             base::close(...future.stdout)
[17:01:08.447]         }, add = TRUE)
[17:01:08.447]     }
[17:01:08.447]     ...future.frame <- base::sys.nframe()
[17:01:08.447]     ...future.conditions <- base::list()
[17:01:08.447]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.447]     if (FALSE) {
[17:01:08.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.447]     }
[17:01:08.447]     ...future.result <- base::tryCatch({
[17:01:08.447]         base::withCallingHandlers({
[17:01:08.447]             ...future.value <- base::withVisible(base::local({
[17:01:08.447]                 ...future.makeSendCondition <- base::local({
[17:01:08.447]                   sendCondition <- NULL
[17:01:08.447]                   function(frame = 1L) {
[17:01:08.447]                     if (is.function(sendCondition)) 
[17:01:08.447]                       return(sendCondition)
[17:01:08.447]                     ns <- getNamespace("parallel")
[17:01:08.447]                     if (exists("sendData", mode = "function", 
[17:01:08.447]                       envir = ns)) {
[17:01:08.447]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.447]                         envir = ns)
[17:01:08.447]                       envir <- sys.frame(frame)
[17:01:08.447]                       master <- NULL
[17:01:08.447]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.447]                         !identical(envir, emptyenv())) {
[17:01:08.447]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.447]                           inherits = FALSE)) {
[17:01:08.447]                           master <- get("master", mode = "list", 
[17:01:08.447]                             envir = envir, inherits = FALSE)
[17:01:08.447]                           if (inherits(master, c("SOCKnode", 
[17:01:08.447]                             "SOCK0node"))) {
[17:01:08.447]                             sendCondition <<- function(cond) {
[17:01:08.447]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.447]                                 success = TRUE)
[17:01:08.447]                               parallel_sendData(master, data)
[17:01:08.447]                             }
[17:01:08.447]                             return(sendCondition)
[17:01:08.447]                           }
[17:01:08.447]                         }
[17:01:08.447]                         frame <- frame + 1L
[17:01:08.447]                         envir <- sys.frame(frame)
[17:01:08.447]                       }
[17:01:08.447]                     }
[17:01:08.447]                     sendCondition <<- function(cond) NULL
[17:01:08.447]                   }
[17:01:08.447]                 })
[17:01:08.447]                 withCallingHandlers({
[17:01:08.447]                   {
[17:01:08.447]                     do.call(function(...) {
[17:01:08.447]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.447]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.447]                         ...future.globals.maxSize)) {
[17:01:08.447]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.447]                         on.exit(options(oopts), add = TRUE)
[17:01:08.447]                       }
[17:01:08.447]                       {
[17:01:08.447]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.447]                           FUN = function(jj) {
[17:01:08.447]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.447]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.447]                           })
[17:01:08.447]                       }
[17:01:08.447]                     }, args = future.call.arguments)
[17:01:08.447]                   }
[17:01:08.447]                 }, immediateCondition = function(cond) {
[17:01:08.447]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.447]                   sendCondition(cond)
[17:01:08.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.447]                   {
[17:01:08.447]                     inherits <- base::inherits
[17:01:08.447]                     invokeRestart <- base::invokeRestart
[17:01:08.447]                     is.null <- base::is.null
[17:01:08.447]                     muffled <- FALSE
[17:01:08.447]                     if (inherits(cond, "message")) {
[17:01:08.447]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.447]                       if (muffled) 
[17:01:08.447]                         invokeRestart("muffleMessage")
[17:01:08.447]                     }
[17:01:08.447]                     else if (inherits(cond, "warning")) {
[17:01:08.447]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.447]                       if (muffled) 
[17:01:08.447]                         invokeRestart("muffleWarning")
[17:01:08.447]                     }
[17:01:08.447]                     else if (inherits(cond, "condition")) {
[17:01:08.447]                       if (!is.null(pattern)) {
[17:01:08.447]                         computeRestarts <- base::computeRestarts
[17:01:08.447]                         grepl <- base::grepl
[17:01:08.447]                         restarts <- computeRestarts(cond)
[17:01:08.447]                         for (restart in restarts) {
[17:01:08.447]                           name <- restart$name
[17:01:08.447]                           if (is.null(name)) 
[17:01:08.447]                             next
[17:01:08.447]                           if (!grepl(pattern, name)) 
[17:01:08.447]                             next
[17:01:08.447]                           invokeRestart(restart)
[17:01:08.447]                           muffled <- TRUE
[17:01:08.447]                           break
[17:01:08.447]                         }
[17:01:08.447]                       }
[17:01:08.447]                     }
[17:01:08.447]                     invisible(muffled)
[17:01:08.447]                   }
[17:01:08.447]                   muffleCondition(cond)
[17:01:08.447]                 })
[17:01:08.447]             }))
[17:01:08.447]             future::FutureResult(value = ...future.value$value, 
[17:01:08.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.447]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.447]                     ...future.globalenv.names))
[17:01:08.447]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.447]         }, condition = base::local({
[17:01:08.447]             c <- base::c
[17:01:08.447]             inherits <- base::inherits
[17:01:08.447]             invokeRestart <- base::invokeRestart
[17:01:08.447]             length <- base::length
[17:01:08.447]             list <- base::list
[17:01:08.447]             seq.int <- base::seq.int
[17:01:08.447]             signalCondition <- base::signalCondition
[17:01:08.447]             sys.calls <- base::sys.calls
[17:01:08.447]             `[[` <- base::`[[`
[17:01:08.447]             `+` <- base::`+`
[17:01:08.447]             `<<-` <- base::`<<-`
[17:01:08.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.447]                   3L)]
[17:01:08.447]             }
[17:01:08.447]             function(cond) {
[17:01:08.447]                 is_error <- inherits(cond, "error")
[17:01:08.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.447]                   NULL)
[17:01:08.447]                 if (is_error) {
[17:01:08.447]                   sessionInformation <- function() {
[17:01:08.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.447]                       search = base::search(), system = base::Sys.info())
[17:01:08.447]                   }
[17:01:08.447]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.447]                     cond$call), session = sessionInformation(), 
[17:01:08.447]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.447]                   signalCondition(cond)
[17:01:08.447]                 }
[17:01:08.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.447]                 "immediateCondition"))) {
[17:01:08.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.447]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.447]                   if (TRUE && !signal) {
[17:01:08.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.447]                     {
[17:01:08.447]                       inherits <- base::inherits
[17:01:08.447]                       invokeRestart <- base::invokeRestart
[17:01:08.447]                       is.null <- base::is.null
[17:01:08.447]                       muffled <- FALSE
[17:01:08.447]                       if (inherits(cond, "message")) {
[17:01:08.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.447]                         if (muffled) 
[17:01:08.447]                           invokeRestart("muffleMessage")
[17:01:08.447]                       }
[17:01:08.447]                       else if (inherits(cond, "warning")) {
[17:01:08.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.447]                         if (muffled) 
[17:01:08.447]                           invokeRestart("muffleWarning")
[17:01:08.447]                       }
[17:01:08.447]                       else if (inherits(cond, "condition")) {
[17:01:08.447]                         if (!is.null(pattern)) {
[17:01:08.447]                           computeRestarts <- base::computeRestarts
[17:01:08.447]                           grepl <- base::grepl
[17:01:08.447]                           restarts <- computeRestarts(cond)
[17:01:08.447]                           for (restart in restarts) {
[17:01:08.447]                             name <- restart$name
[17:01:08.447]                             if (is.null(name)) 
[17:01:08.447]                               next
[17:01:08.447]                             if (!grepl(pattern, name)) 
[17:01:08.447]                               next
[17:01:08.447]                             invokeRestart(restart)
[17:01:08.447]                             muffled <- TRUE
[17:01:08.447]                             break
[17:01:08.447]                           }
[17:01:08.447]                         }
[17:01:08.447]                       }
[17:01:08.447]                       invisible(muffled)
[17:01:08.447]                     }
[17:01:08.447]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.447]                   }
[17:01:08.447]                 }
[17:01:08.447]                 else {
[17:01:08.447]                   if (TRUE) {
[17:01:08.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.447]                     {
[17:01:08.447]                       inherits <- base::inherits
[17:01:08.447]                       invokeRestart <- base::invokeRestart
[17:01:08.447]                       is.null <- base::is.null
[17:01:08.447]                       muffled <- FALSE
[17:01:08.447]                       if (inherits(cond, "message")) {
[17:01:08.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.447]                         if (muffled) 
[17:01:08.447]                           invokeRestart("muffleMessage")
[17:01:08.447]                       }
[17:01:08.447]                       else if (inherits(cond, "warning")) {
[17:01:08.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.447]                         if (muffled) 
[17:01:08.447]                           invokeRestart("muffleWarning")
[17:01:08.447]                       }
[17:01:08.447]                       else if (inherits(cond, "condition")) {
[17:01:08.447]                         if (!is.null(pattern)) {
[17:01:08.447]                           computeRestarts <- base::computeRestarts
[17:01:08.447]                           grepl <- base::grepl
[17:01:08.447]                           restarts <- computeRestarts(cond)
[17:01:08.447]                           for (restart in restarts) {
[17:01:08.447]                             name <- restart$name
[17:01:08.447]                             if (is.null(name)) 
[17:01:08.447]                               next
[17:01:08.447]                             if (!grepl(pattern, name)) 
[17:01:08.447]                               next
[17:01:08.447]                             invokeRestart(restart)
[17:01:08.447]                             muffled <- TRUE
[17:01:08.447]                             break
[17:01:08.447]                           }
[17:01:08.447]                         }
[17:01:08.447]                       }
[17:01:08.447]                       invisible(muffled)
[17:01:08.447]                     }
[17:01:08.447]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.447]                   }
[17:01:08.447]                 }
[17:01:08.447]             }
[17:01:08.447]         }))
[17:01:08.447]     }, error = function(ex) {
[17:01:08.447]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.447]                 ...future.rng), started = ...future.startTime, 
[17:01:08.447]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.447]             version = "1.8"), class = "FutureResult")
[17:01:08.447]     }, finally = {
[17:01:08.447]         if (!identical(...future.workdir, getwd())) 
[17:01:08.447]             setwd(...future.workdir)
[17:01:08.447]         {
[17:01:08.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.447]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.447]             }
[17:01:08.447]             base::options(...future.oldOptions)
[17:01:08.447]             if (.Platform$OS.type == "windows") {
[17:01:08.447]                 old_names <- names(...future.oldEnvVars)
[17:01:08.447]                 envs <- base::Sys.getenv()
[17:01:08.447]                 names <- names(envs)
[17:01:08.447]                 common <- intersect(names, old_names)
[17:01:08.447]                 added <- setdiff(names, old_names)
[17:01:08.447]                 removed <- setdiff(old_names, names)
[17:01:08.447]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.447]                   envs[common]]
[17:01:08.447]                 NAMES <- toupper(changed)
[17:01:08.447]                 args <- list()
[17:01:08.447]                 for (kk in seq_along(NAMES)) {
[17:01:08.447]                   name <- changed[[kk]]
[17:01:08.447]                   NAME <- NAMES[[kk]]
[17:01:08.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.447]                     next
[17:01:08.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.447]                 }
[17:01:08.447]                 NAMES <- toupper(added)
[17:01:08.447]                 for (kk in seq_along(NAMES)) {
[17:01:08.447]                   name <- added[[kk]]
[17:01:08.447]                   NAME <- NAMES[[kk]]
[17:01:08.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.447]                     next
[17:01:08.447]                   args[[name]] <- ""
[17:01:08.447]                 }
[17:01:08.447]                 NAMES <- toupper(removed)
[17:01:08.447]                 for (kk in seq_along(NAMES)) {
[17:01:08.447]                   name <- removed[[kk]]
[17:01:08.447]                   NAME <- NAMES[[kk]]
[17:01:08.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.447]                     next
[17:01:08.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.447]                 }
[17:01:08.447]                 if (length(args) > 0) 
[17:01:08.447]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.447]             }
[17:01:08.447]             else {
[17:01:08.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.447]             }
[17:01:08.447]             {
[17:01:08.447]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.447]                   0L) {
[17:01:08.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.447]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.447]                   base::options(opts)
[17:01:08.447]                 }
[17:01:08.447]                 {
[17:01:08.447]                   {
[17:01:08.447]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.447]                     NULL
[17:01:08.447]                   }
[17:01:08.447]                   options(future.plan = NULL)
[17:01:08.447]                   if (is.na(NA_character_)) 
[17:01:08.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.447]                     .init = FALSE)
[17:01:08.447]                 }
[17:01:08.447]             }
[17:01:08.447]         }
[17:01:08.447]     })
[17:01:08.447]     if (TRUE) {
[17:01:08.447]         base::sink(type = "output", split = FALSE)
[17:01:08.447]         if (TRUE) {
[17:01:08.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.447]         }
[17:01:08.447]         else {
[17:01:08.447]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.447]         }
[17:01:08.447]         base::close(...future.stdout)
[17:01:08.447]         ...future.stdout <- NULL
[17:01:08.447]     }
[17:01:08.447]     ...future.result$conditions <- ...future.conditions
[17:01:08.447]     ...future.result$finished <- base::Sys.time()
[17:01:08.447]     ...future.result
[17:01:08.447] }
[17:01:08.450] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[17:01:08.450] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[17:01:08.492] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:01:08.492] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:08.493] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.493] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:01:08.493] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:01:08.493] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:08.494] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.494] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:08.494] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.494] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[17:01:08.495] MultisessionFuture started
[17:01:08.495] - Launch lazy future ... done
[17:01:08.495] run() for ‘MultisessionFuture’ ... done
[17:01:08.495] Created future:
[17:01:08.495] MultisessionFuture:
[17:01:08.495] Label: ‘future_sapply-1’
[17:01:08.495] Expression:
[17:01:08.495] {
[17:01:08.495]     do.call(function(...) {
[17:01:08.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.495]             on.exit(options(oopts), add = TRUE)
[17:01:08.495]         }
[17:01:08.495]         {
[17:01:08.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.495]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.495]             })
[17:01:08.495]         }
[17:01:08.495]     }, args = future.call.arguments)
[17:01:08.495] }
[17:01:08.495] Lazy evaluation: FALSE
[17:01:08.495] Asynchronous evaluation: TRUE
[17:01:08.495] Local evaluation: TRUE
[17:01:08.495] Environment: R_GlobalEnv
[17:01:08.495] Capture standard output: TRUE
[17:01:08.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:08.495] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:08.495] Packages: 1 packages (‘stats’)
[17:01:08.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:08.495] Resolved: FALSE
[17:01:08.495] Value: <not collected>
[17:01:08.495] Conditions captured: <none>
[17:01:08.495] Early signaling: FALSE
[17:01:08.495] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:08.495] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.507] Chunk #1 of 2 ... DONE
[17:01:08.507] Chunk #2 of 2 ...
[17:01:08.507]  - Finding globals in 'X' for chunk #2 ...
[17:01:08.507] getGlobalsAndPackages() ...
[17:01:08.507] Searching for globals...
[17:01:08.508] 
[17:01:08.508] Searching for globals ... DONE
[17:01:08.508] - globals: [0] <none>
[17:01:08.508] getGlobalsAndPackages() ... DONE
[17:01:08.508]    + additional globals found: [n=0] 
[17:01:08.508]    + additional namespaces needed: [n=0] 
[17:01:08.508]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:08.508]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.508]  - seeds: <none>
[17:01:08.509]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.509] getGlobalsAndPackages() ...
[17:01:08.509] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.509] Resolving globals: FALSE
[17:01:08.509] Tweak future expression to call with '...' arguments ...
[17:01:08.509] {
[17:01:08.509]     do.call(function(...) {
[17:01:08.509]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.509]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.509]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.509]             on.exit(options(oopts), add = TRUE)
[17:01:08.509]         }
[17:01:08.509]         {
[17:01:08.509]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.509]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.509]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.509]             })
[17:01:08.509]         }
[17:01:08.509]     }, args = future.call.arguments)
[17:01:08.509] }
[17:01:08.509] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.510] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.510] - packages: [1] ‘stats’
[17:01:08.510] getGlobalsAndPackages() ... DONE
[17:01:08.510] run() for ‘Future’ ...
[17:01:08.510] - state: ‘created’
[17:01:08.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.528]   - Field: ‘node’
[17:01:08.528]   - Field: ‘label’
[17:01:08.528]   - Field: ‘local’
[17:01:08.529]   - Field: ‘owner’
[17:01:08.529]   - Field: ‘envir’
[17:01:08.529]   - Field: ‘workers’
[17:01:08.529]   - Field: ‘packages’
[17:01:08.529]   - Field: ‘gc’
[17:01:08.529]   - Field: ‘conditions’
[17:01:08.529]   - Field: ‘persistent’
[17:01:08.529]   - Field: ‘expr’
[17:01:08.529]   - Field: ‘uuid’
[17:01:08.529]   - Field: ‘seed’
[17:01:08.529]   - Field: ‘version’
[17:01:08.530]   - Field: ‘result’
[17:01:08.530]   - Field: ‘asynchronous’
[17:01:08.530]   - Field: ‘calls’
[17:01:08.530]   - Field: ‘globals’
[17:01:08.530]   - Field: ‘stdout’
[17:01:08.530]   - Field: ‘earlySignal’
[17:01:08.530]   - Field: ‘lazy’
[17:01:08.530]   - Field: ‘state’
[17:01:08.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.530] - Launch lazy future ...
[17:01:08.531] Packages needed by the future expression (n = 1): ‘stats’
[17:01:08.531] Packages needed by future strategies (n = 0): <none>
[17:01:08.531] {
[17:01:08.531]     {
[17:01:08.531]         {
[17:01:08.531]             ...future.startTime <- base::Sys.time()
[17:01:08.531]             {
[17:01:08.531]                 {
[17:01:08.531]                   {
[17:01:08.531]                     {
[17:01:08.531]                       {
[17:01:08.531]                         base::local({
[17:01:08.531]                           has_future <- base::requireNamespace("future", 
[17:01:08.531]                             quietly = TRUE)
[17:01:08.531]                           if (has_future) {
[17:01:08.531]                             ns <- base::getNamespace("future")
[17:01:08.531]                             version <- ns[[".package"]][["version"]]
[17:01:08.531]                             if (is.null(version)) 
[17:01:08.531]                               version <- utils::packageVersion("future")
[17:01:08.531]                           }
[17:01:08.531]                           else {
[17:01:08.531]                             version <- NULL
[17:01:08.531]                           }
[17:01:08.531]                           if (!has_future || version < "1.8.0") {
[17:01:08.531]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.531]                               "", base::R.version$version.string), 
[17:01:08.531]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.531]                                 base::R.version$platform, 8 * 
[17:01:08.531]                                   base::.Machine$sizeof.pointer), 
[17:01:08.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.531]                                 "release", "version")], collapse = " "), 
[17:01:08.531]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.531]                               info)
[17:01:08.531]                             info <- base::paste(info, collapse = "; ")
[17:01:08.531]                             if (!has_future) {
[17:01:08.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.531]                                 info)
[17:01:08.531]                             }
[17:01:08.531]                             else {
[17:01:08.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.531]                                 info, version)
[17:01:08.531]                             }
[17:01:08.531]                             base::stop(msg)
[17:01:08.531]                           }
[17:01:08.531]                         })
[17:01:08.531]                       }
[17:01:08.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.531]                       base::options(mc.cores = 1L)
[17:01:08.531]                     }
[17:01:08.531]                     base::local({
[17:01:08.531]                       for (pkg in "stats") {
[17:01:08.531]                         base::loadNamespace(pkg)
[17:01:08.531]                         base::library(pkg, character.only = TRUE)
[17:01:08.531]                       }
[17:01:08.531]                     })
[17:01:08.531]                   }
[17:01:08.531]                   ...future.strategy.old <- future::plan("list")
[17:01:08.531]                   options(future.plan = NULL)
[17:01:08.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.531]                 }
[17:01:08.531]                 ...future.workdir <- getwd()
[17:01:08.531]             }
[17:01:08.531]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.531]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.531]         }
[17:01:08.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.531]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.531]             base::names(...future.oldOptions))
[17:01:08.531]     }
[17:01:08.531]     if (FALSE) {
[17:01:08.531]     }
[17:01:08.531]     else {
[17:01:08.531]         if (TRUE) {
[17:01:08.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.531]                 open = "w")
[17:01:08.531]         }
[17:01:08.531]         else {
[17:01:08.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.531]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.531]         }
[17:01:08.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.531]             base::sink(type = "output", split = FALSE)
[17:01:08.531]             base::close(...future.stdout)
[17:01:08.531]         }, add = TRUE)
[17:01:08.531]     }
[17:01:08.531]     ...future.frame <- base::sys.nframe()
[17:01:08.531]     ...future.conditions <- base::list()
[17:01:08.531]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.531]     if (FALSE) {
[17:01:08.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.531]     }
[17:01:08.531]     ...future.result <- base::tryCatch({
[17:01:08.531]         base::withCallingHandlers({
[17:01:08.531]             ...future.value <- base::withVisible(base::local({
[17:01:08.531]                 ...future.makeSendCondition <- base::local({
[17:01:08.531]                   sendCondition <- NULL
[17:01:08.531]                   function(frame = 1L) {
[17:01:08.531]                     if (is.function(sendCondition)) 
[17:01:08.531]                       return(sendCondition)
[17:01:08.531]                     ns <- getNamespace("parallel")
[17:01:08.531]                     if (exists("sendData", mode = "function", 
[17:01:08.531]                       envir = ns)) {
[17:01:08.531]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.531]                         envir = ns)
[17:01:08.531]                       envir <- sys.frame(frame)
[17:01:08.531]                       master <- NULL
[17:01:08.531]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.531]                         !identical(envir, emptyenv())) {
[17:01:08.531]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.531]                           inherits = FALSE)) {
[17:01:08.531]                           master <- get("master", mode = "list", 
[17:01:08.531]                             envir = envir, inherits = FALSE)
[17:01:08.531]                           if (inherits(master, c("SOCKnode", 
[17:01:08.531]                             "SOCK0node"))) {
[17:01:08.531]                             sendCondition <<- function(cond) {
[17:01:08.531]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.531]                                 success = TRUE)
[17:01:08.531]                               parallel_sendData(master, data)
[17:01:08.531]                             }
[17:01:08.531]                             return(sendCondition)
[17:01:08.531]                           }
[17:01:08.531]                         }
[17:01:08.531]                         frame <- frame + 1L
[17:01:08.531]                         envir <- sys.frame(frame)
[17:01:08.531]                       }
[17:01:08.531]                     }
[17:01:08.531]                     sendCondition <<- function(cond) NULL
[17:01:08.531]                   }
[17:01:08.531]                 })
[17:01:08.531]                 withCallingHandlers({
[17:01:08.531]                   {
[17:01:08.531]                     do.call(function(...) {
[17:01:08.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.531]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.531]                         ...future.globals.maxSize)) {
[17:01:08.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.531]                         on.exit(options(oopts), add = TRUE)
[17:01:08.531]                       }
[17:01:08.531]                       {
[17:01:08.531]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.531]                           FUN = function(jj) {
[17:01:08.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.531]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.531]                           })
[17:01:08.531]                       }
[17:01:08.531]                     }, args = future.call.arguments)
[17:01:08.531]                   }
[17:01:08.531]                 }, immediateCondition = function(cond) {
[17:01:08.531]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.531]                   sendCondition(cond)
[17:01:08.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.531]                   {
[17:01:08.531]                     inherits <- base::inherits
[17:01:08.531]                     invokeRestart <- base::invokeRestart
[17:01:08.531]                     is.null <- base::is.null
[17:01:08.531]                     muffled <- FALSE
[17:01:08.531]                     if (inherits(cond, "message")) {
[17:01:08.531]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.531]                       if (muffled) 
[17:01:08.531]                         invokeRestart("muffleMessage")
[17:01:08.531]                     }
[17:01:08.531]                     else if (inherits(cond, "warning")) {
[17:01:08.531]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.531]                       if (muffled) 
[17:01:08.531]                         invokeRestart("muffleWarning")
[17:01:08.531]                     }
[17:01:08.531]                     else if (inherits(cond, "condition")) {
[17:01:08.531]                       if (!is.null(pattern)) {
[17:01:08.531]                         computeRestarts <- base::computeRestarts
[17:01:08.531]                         grepl <- base::grepl
[17:01:08.531]                         restarts <- computeRestarts(cond)
[17:01:08.531]                         for (restart in restarts) {
[17:01:08.531]                           name <- restart$name
[17:01:08.531]                           if (is.null(name)) 
[17:01:08.531]                             next
[17:01:08.531]                           if (!grepl(pattern, name)) 
[17:01:08.531]                             next
[17:01:08.531]                           invokeRestart(restart)
[17:01:08.531]                           muffled <- TRUE
[17:01:08.531]                           break
[17:01:08.531]                         }
[17:01:08.531]                       }
[17:01:08.531]                     }
[17:01:08.531]                     invisible(muffled)
[17:01:08.531]                   }
[17:01:08.531]                   muffleCondition(cond)
[17:01:08.531]                 })
[17:01:08.531]             }))
[17:01:08.531]             future::FutureResult(value = ...future.value$value, 
[17:01:08.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.531]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.531]                     ...future.globalenv.names))
[17:01:08.531]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.531]         }, condition = base::local({
[17:01:08.531]             c <- base::c
[17:01:08.531]             inherits <- base::inherits
[17:01:08.531]             invokeRestart <- base::invokeRestart
[17:01:08.531]             length <- base::length
[17:01:08.531]             list <- base::list
[17:01:08.531]             seq.int <- base::seq.int
[17:01:08.531]             signalCondition <- base::signalCondition
[17:01:08.531]             sys.calls <- base::sys.calls
[17:01:08.531]             `[[` <- base::`[[`
[17:01:08.531]             `+` <- base::`+`
[17:01:08.531]             `<<-` <- base::`<<-`
[17:01:08.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.531]                   3L)]
[17:01:08.531]             }
[17:01:08.531]             function(cond) {
[17:01:08.531]                 is_error <- inherits(cond, "error")
[17:01:08.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.531]                   NULL)
[17:01:08.531]                 if (is_error) {
[17:01:08.531]                   sessionInformation <- function() {
[17:01:08.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.531]                       search = base::search(), system = base::Sys.info())
[17:01:08.531]                   }
[17:01:08.531]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.531]                     cond$call), session = sessionInformation(), 
[17:01:08.531]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.531]                   signalCondition(cond)
[17:01:08.531]                 }
[17:01:08.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.531]                 "immediateCondition"))) {
[17:01:08.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.531]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.531]                   if (TRUE && !signal) {
[17:01:08.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.531]                     {
[17:01:08.531]                       inherits <- base::inherits
[17:01:08.531]                       invokeRestart <- base::invokeRestart
[17:01:08.531]                       is.null <- base::is.null
[17:01:08.531]                       muffled <- FALSE
[17:01:08.531]                       if (inherits(cond, "message")) {
[17:01:08.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.531]                         if (muffled) 
[17:01:08.531]                           invokeRestart("muffleMessage")
[17:01:08.531]                       }
[17:01:08.531]                       else if (inherits(cond, "warning")) {
[17:01:08.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.531]                         if (muffled) 
[17:01:08.531]                           invokeRestart("muffleWarning")
[17:01:08.531]                       }
[17:01:08.531]                       else if (inherits(cond, "condition")) {
[17:01:08.531]                         if (!is.null(pattern)) {
[17:01:08.531]                           computeRestarts <- base::computeRestarts
[17:01:08.531]                           grepl <- base::grepl
[17:01:08.531]                           restarts <- computeRestarts(cond)
[17:01:08.531]                           for (restart in restarts) {
[17:01:08.531]                             name <- restart$name
[17:01:08.531]                             if (is.null(name)) 
[17:01:08.531]                               next
[17:01:08.531]                             if (!grepl(pattern, name)) 
[17:01:08.531]                               next
[17:01:08.531]                             invokeRestart(restart)
[17:01:08.531]                             muffled <- TRUE
[17:01:08.531]                             break
[17:01:08.531]                           }
[17:01:08.531]                         }
[17:01:08.531]                       }
[17:01:08.531]                       invisible(muffled)
[17:01:08.531]                     }
[17:01:08.531]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.531]                   }
[17:01:08.531]                 }
[17:01:08.531]                 else {
[17:01:08.531]                   if (TRUE) {
[17:01:08.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.531]                     {
[17:01:08.531]                       inherits <- base::inherits
[17:01:08.531]                       invokeRestart <- base::invokeRestart
[17:01:08.531]                       is.null <- base::is.null
[17:01:08.531]                       muffled <- FALSE
[17:01:08.531]                       if (inherits(cond, "message")) {
[17:01:08.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.531]                         if (muffled) 
[17:01:08.531]                           invokeRestart("muffleMessage")
[17:01:08.531]                       }
[17:01:08.531]                       else if (inherits(cond, "warning")) {
[17:01:08.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.531]                         if (muffled) 
[17:01:08.531]                           invokeRestart("muffleWarning")
[17:01:08.531]                       }
[17:01:08.531]                       else if (inherits(cond, "condition")) {
[17:01:08.531]                         if (!is.null(pattern)) {
[17:01:08.531]                           computeRestarts <- base::computeRestarts
[17:01:08.531]                           grepl <- base::grepl
[17:01:08.531]                           restarts <- computeRestarts(cond)
[17:01:08.531]                           for (restart in restarts) {
[17:01:08.531]                             name <- restart$name
[17:01:08.531]                             if (is.null(name)) 
[17:01:08.531]                               next
[17:01:08.531]                             if (!grepl(pattern, name)) 
[17:01:08.531]                               next
[17:01:08.531]                             invokeRestart(restart)
[17:01:08.531]                             muffled <- TRUE
[17:01:08.531]                             break
[17:01:08.531]                           }
[17:01:08.531]                         }
[17:01:08.531]                       }
[17:01:08.531]                       invisible(muffled)
[17:01:08.531]                     }
[17:01:08.531]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.531]                   }
[17:01:08.531]                 }
[17:01:08.531]             }
[17:01:08.531]         }))
[17:01:08.531]     }, error = function(ex) {
[17:01:08.531]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.531]                 ...future.rng), started = ...future.startTime, 
[17:01:08.531]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.531]             version = "1.8"), class = "FutureResult")
[17:01:08.531]     }, finally = {
[17:01:08.531]         if (!identical(...future.workdir, getwd())) 
[17:01:08.531]             setwd(...future.workdir)
[17:01:08.531]         {
[17:01:08.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.531]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.531]             }
[17:01:08.531]             base::options(...future.oldOptions)
[17:01:08.531]             if (.Platform$OS.type == "windows") {
[17:01:08.531]                 old_names <- names(...future.oldEnvVars)
[17:01:08.531]                 envs <- base::Sys.getenv()
[17:01:08.531]                 names <- names(envs)
[17:01:08.531]                 common <- intersect(names, old_names)
[17:01:08.531]                 added <- setdiff(names, old_names)
[17:01:08.531]                 removed <- setdiff(old_names, names)
[17:01:08.531]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.531]                   envs[common]]
[17:01:08.531]                 NAMES <- toupper(changed)
[17:01:08.531]                 args <- list()
[17:01:08.531]                 for (kk in seq_along(NAMES)) {
[17:01:08.531]                   name <- changed[[kk]]
[17:01:08.531]                   NAME <- NAMES[[kk]]
[17:01:08.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.531]                     next
[17:01:08.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.531]                 }
[17:01:08.531]                 NAMES <- toupper(added)
[17:01:08.531]                 for (kk in seq_along(NAMES)) {
[17:01:08.531]                   name <- added[[kk]]
[17:01:08.531]                   NAME <- NAMES[[kk]]
[17:01:08.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.531]                     next
[17:01:08.531]                   args[[name]] <- ""
[17:01:08.531]                 }
[17:01:08.531]                 NAMES <- toupper(removed)
[17:01:08.531]                 for (kk in seq_along(NAMES)) {
[17:01:08.531]                   name <- removed[[kk]]
[17:01:08.531]                   NAME <- NAMES[[kk]]
[17:01:08.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.531]                     next
[17:01:08.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.531]                 }
[17:01:08.531]                 if (length(args) > 0) 
[17:01:08.531]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.531]             }
[17:01:08.531]             else {
[17:01:08.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.531]             }
[17:01:08.531]             {
[17:01:08.531]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.531]                   0L) {
[17:01:08.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.531]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.531]                   base::options(opts)
[17:01:08.531]                 }
[17:01:08.531]                 {
[17:01:08.531]                   {
[17:01:08.531]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.531]                     NULL
[17:01:08.531]                   }
[17:01:08.531]                   options(future.plan = NULL)
[17:01:08.531]                   if (is.na(NA_character_)) 
[17:01:08.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.531]                     .init = FALSE)
[17:01:08.531]                 }
[17:01:08.531]             }
[17:01:08.531]         }
[17:01:08.531]     })
[17:01:08.531]     if (TRUE) {
[17:01:08.531]         base::sink(type = "output", split = FALSE)
[17:01:08.531]         if (TRUE) {
[17:01:08.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.531]         }
[17:01:08.531]         else {
[17:01:08.531]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.531]         }
[17:01:08.531]         base::close(...future.stdout)
[17:01:08.531]         ...future.stdout <- NULL
[17:01:08.531]     }
[17:01:08.531]     ...future.result$conditions <- ...future.conditions
[17:01:08.531]     ...future.result$finished <- base::Sys.time()
[17:01:08.531]     ...future.result
[17:01:08.531] }
[17:01:08.534] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[17:01:08.534] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[17:01:08.576] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:01:08.576] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:08.577] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.577] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:01:08.577] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:01:08.577] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:08.578] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.578] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:08.578] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:08.578] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[17:01:08.579] MultisessionFuture started
[17:01:08.579] - Launch lazy future ... done
[17:01:08.579] run() for ‘MultisessionFuture’ ... done
[17:01:08.579] Created future:
[17:01:08.579] MultisessionFuture:
[17:01:08.579] Label: ‘future_sapply-2’
[17:01:08.579] Expression:
[17:01:08.579] {
[17:01:08.579]     do.call(function(...) {
[17:01:08.579]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.579]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.579]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.579]             on.exit(options(oopts), add = TRUE)
[17:01:08.579]         }
[17:01:08.579]         {
[17:01:08.579]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.579]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.579]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.579]             })
[17:01:08.579]         }
[17:01:08.579]     }, args = future.call.arguments)
[17:01:08.579] }
[17:01:08.579] Lazy evaluation: FALSE
[17:01:08.579] Asynchronous evaluation: TRUE
[17:01:08.579] Local evaluation: TRUE
[17:01:08.579] Environment: R_GlobalEnv
[17:01:08.579] Capture standard output: TRUE
[17:01:08.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:08.579] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:08.579] Packages: 1 packages (‘stats’)
[17:01:08.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:08.579] Resolved: FALSE
[17:01:08.579] Value: <not collected>
[17:01:08.579] Conditions captured: <none>
[17:01:08.579] Early signaling: FALSE
[17:01:08.579] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:08.579] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.591] Chunk #2 of 2 ... DONE
[17:01:08.591] Launching 2 futures (chunks) ... DONE
[17:01:08.591] Resolving 2 futures (chunks) ...
[17:01:08.591] resolve() on list ...
[17:01:08.592]  recursive: 0
[17:01:08.592]  length: 2
[17:01:08.592] 
[17:01:08.592] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.592] - Validating connection of MultisessionFuture
[17:01:08.592] - received message: FutureResult
[17:01:08.593] - Received FutureResult
[17:01:08.593] - Erased future from FutureRegistry
[17:01:08.593] result() for ClusterFuture ...
[17:01:08.593] - result already collected: FutureResult
[17:01:08.593] result() for ClusterFuture ... done
[17:01:08.593] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.593] Future #1
[17:01:08.593] result() for ClusterFuture ...
[17:01:08.593] - result already collected: FutureResult
[17:01:08.593] result() for ClusterFuture ... done
[17:01:08.593] result() for ClusterFuture ...
[17:01:08.594] - result already collected: FutureResult
[17:01:08.594] result() for ClusterFuture ... done
[17:01:08.594] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:08.594] - nx: 2
[17:01:08.594] - relay: TRUE
[17:01:08.594] - stdout: TRUE
[17:01:08.594] - signal: TRUE
[17:01:08.594] - resignal: FALSE
[17:01:08.594] - force: TRUE
[17:01:08.594] - relayed: [n=2] FALSE, FALSE
[17:01:08.594] - queued futures: [n=2] FALSE, FALSE
[17:01:08.595]  - until=1
[17:01:08.595]  - relaying element #1
[17:01:08.595] result() for ClusterFuture ...
[17:01:08.595] - result already collected: FutureResult
[17:01:08.595] result() for ClusterFuture ... done
[17:01:08.595] result() for ClusterFuture ...
[17:01:08.595] - result already collected: FutureResult
[17:01:08.595] result() for ClusterFuture ... done
[17:01:08.595] result() for ClusterFuture ...
[17:01:08.595] - result already collected: FutureResult
[17:01:08.595] result() for ClusterFuture ... done
[17:01:08.596] result() for ClusterFuture ...
[17:01:08.596] - result already collected: FutureResult
[17:01:08.596] result() for ClusterFuture ... done
[17:01:08.596] - relayed: [n=2] TRUE, FALSE
[17:01:08.596] - queued futures: [n=2] TRUE, FALSE
[17:01:08.596] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:08.596]  length: 1 (resolved future 1)
[17:01:08.621] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.621] - Validating connection of MultisessionFuture
[17:01:08.622] - received message: FutureResult
[17:01:08.622] - Received FutureResult
[17:01:08.622] - Erased future from FutureRegistry
[17:01:08.622] result() for ClusterFuture ...
[17:01:08.622] - result already collected: FutureResult
[17:01:08.622] result() for ClusterFuture ... done
[17:01:08.622] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.622] Future #2
[17:01:08.622] result() for ClusterFuture ...
[17:01:08.622] - result already collected: FutureResult
[17:01:08.623] result() for ClusterFuture ... done
[17:01:08.623] result() for ClusterFuture ...
[17:01:08.623] - result already collected: FutureResult
[17:01:08.623] result() for ClusterFuture ... done
[17:01:08.623] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:08.623] - nx: 2
[17:01:08.623] - relay: TRUE
[17:01:08.623] - stdout: TRUE
[17:01:08.623] - signal: TRUE
[17:01:08.623] - resignal: FALSE
[17:01:08.623] - force: TRUE
[17:01:08.624] - relayed: [n=2] TRUE, FALSE
[17:01:08.624] - queued futures: [n=2] TRUE, FALSE
[17:01:08.624]  - until=2
[17:01:08.624]  - relaying element #2
[17:01:08.624] result() for ClusterFuture ...
[17:01:08.624] - result already collected: FutureResult
[17:01:08.624] result() for ClusterFuture ... done
[17:01:08.624] result() for ClusterFuture ...
[17:01:08.624] - result already collected: FutureResult
[17:01:08.624] result() for ClusterFuture ... done
[17:01:08.625] result() for ClusterFuture ...
[17:01:08.625] - result already collected: FutureResult
[17:01:08.625] result() for ClusterFuture ... done
[17:01:08.625] result() for ClusterFuture ...
[17:01:08.625] - result already collected: FutureResult
[17:01:08.625] result() for ClusterFuture ... done
[17:01:08.625] - relayed: [n=2] TRUE, TRUE
[17:01:08.625] - queued futures: [n=2] TRUE, TRUE
[17:01:08.625] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:08.625]  length: 0 (resolved future 2)
[17:01:08.625] Relaying remaining futures
[17:01:08.626] signalConditionsASAP(NULL, pos=0) ...
[17:01:08.626] - nx: 2
[17:01:08.626] - relay: TRUE
[17:01:08.626] - stdout: TRUE
[17:01:08.626] - signal: TRUE
[17:01:08.626] - resignal: FALSE
[17:01:08.626] - force: TRUE
[17:01:08.626] - relayed: [n=2] TRUE, TRUE
[17:01:08.626] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:08.626] - relayed: [n=2] TRUE, TRUE
[17:01:08.626] - queued futures: [n=2] TRUE, TRUE
[17:01:08.627] signalConditionsASAP(NULL, pos=0) ... done
[17:01:08.627] resolve() on list ... DONE
[17:01:08.627] result() for ClusterFuture ...
[17:01:08.627] - result already collected: FutureResult
[17:01:08.627] result() for ClusterFuture ... done
[17:01:08.627] result() for ClusterFuture ...
[17:01:08.627] - result already collected: FutureResult
[17:01:08.627] result() for ClusterFuture ... done
[17:01:08.627] result() for ClusterFuture ...
[17:01:08.627] - result already collected: FutureResult
[17:01:08.627] result() for ClusterFuture ... done
[17:01:08.628] result() for ClusterFuture ...
[17:01:08.628] - result already collected: FutureResult
[17:01:08.628] result() for ClusterFuture ... done
[17:01:08.628]  - Number of value chunks collected: 2
[17:01:08.628] Resolving 2 futures (chunks) ... DONE
[17:01:08.628] Reducing values from 2 chunks ...
[17:01:08.628]  - Number of values collected after concatenation: 7
[17:01:08.628]  - Number of values expected: 7
[17:01:08.628] Reducing values from 2 chunks ... DONE
[17:01:08.628] future_lapply() ... DONE
[17:01:08.629] future_lapply() ...
[17:01:08.635] Number of chunks: 2
[17:01:08.635] getGlobalsAndPackagesXApply() ...
[17:01:08.635]  - future.globals: TRUE
[17:01:08.635] getGlobalsAndPackages() ...
[17:01:08.635] Searching for globals...
[17:01:08.642] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:01:08.642] Searching for globals ... DONE
[17:01:08.642] Resolving globals: FALSE
[17:01:08.644] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:01:08.644] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:01:08.644] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:08.644] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.644] getGlobalsAndPackages() ... DONE
[17:01:08.645]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:08.645]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:01:08.645] Finding globals ... DONE
[17:01:08.645]  - use_args: TRUE
[17:01:08.645]  - Getting '...' globals ...
[17:01:08.645] resolve() on list ...
[17:01:08.645]  recursive: 0
[17:01:08.645]  length: 1
[17:01:08.645]  elements: ‘...’
[17:01:08.646]  length: 0 (resolved future 1)
[17:01:08.646] resolve() on list ... DONE
[17:01:08.646]    - '...' content: [n=0] 
[17:01:08.646] List of 1
[17:01:08.646]  $ ...: list()
[17:01:08.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.646]  - attr(*, "where")=List of 1
[17:01:08.646]   ..$ ...:<environment: 0x55aadc118af8> 
[17:01:08.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.646]  - attr(*, "resolved")= logi TRUE
[17:01:08.646]  - attr(*, "total_size")= num NA
[17:01:08.648]  - Getting '...' globals ... DONE
[17:01:08.649] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:08.649] List of 8
[17:01:08.649]  $ ...future.FUN:function (x, ...)  
[17:01:08.649]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:01:08.649]  $ times        : int 5
[17:01:08.649]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:08.649]  $ stop_if_not  :function (...)  
[17:01:08.649]  $ dim          : NULL
[17:01:08.649]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:08.649]  $ ...          : list()
[17:01:08.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:08.649]  - attr(*, "where")=List of 8
[17:01:08.649]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:08.649]   ..$ ...          :<environment: 0x55aadc118af8> 
[17:01:08.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:08.649]  - attr(*, "resolved")= logi FALSE
[17:01:08.649]  - attr(*, "total_size")= num 141240
[17:01:08.654] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:01:08.654] getGlobalsAndPackagesXApply() ... DONE
[17:01:08.654] Number of futures (= number of chunks): 2
[17:01:08.654] Launching 2 futures (chunks) ...
[17:01:08.654] Chunk #1 of 2 ...
[17:01:08.654]  - Finding globals in 'X' for chunk #1 ...
[17:01:08.655] getGlobalsAndPackages() ...
[17:01:08.655] Searching for globals...
[17:01:08.655] 
[17:01:08.655] Searching for globals ... DONE
[17:01:08.655] - globals: [0] <none>
[17:01:08.655] getGlobalsAndPackages() ... DONE
[17:01:08.655]    + additional globals found: [n=0] 
[17:01:08.655]    + additional namespaces needed: [n=0] 
[17:01:08.655]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:08.656]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.656]  - seeds: <none>
[17:01:08.656]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.656] getGlobalsAndPackages() ...
[17:01:08.656] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.656] Resolving globals: FALSE
[17:01:08.656] Tweak future expression to call with '...' arguments ...
[17:01:08.656] {
[17:01:08.656]     do.call(function(...) {
[17:01:08.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.656]             on.exit(options(oopts), add = TRUE)
[17:01:08.656]         }
[17:01:08.656]         {
[17:01:08.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.656]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.656]             })
[17:01:08.656]         }
[17:01:08.656]     }, args = future.call.arguments)
[17:01:08.656] }
[17:01:08.657] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.657] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.657] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.657] getGlobalsAndPackages() ... DONE
[17:01:08.658] run() for ‘Future’ ...
[17:01:08.658] - state: ‘created’
[17:01:08.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.672]   - Field: ‘node’
[17:01:08.672]   - Field: ‘label’
[17:01:08.672]   - Field: ‘local’
[17:01:08.672]   - Field: ‘owner’
[17:01:08.672]   - Field: ‘envir’
[17:01:08.672]   - Field: ‘workers’
[17:01:08.673]   - Field: ‘packages’
[17:01:08.673]   - Field: ‘gc’
[17:01:08.673]   - Field: ‘conditions’
[17:01:08.673]   - Field: ‘persistent’
[17:01:08.673]   - Field: ‘expr’
[17:01:08.673]   - Field: ‘uuid’
[17:01:08.673]   - Field: ‘seed’
[17:01:08.673]   - Field: ‘version’
[17:01:08.673]   - Field: ‘result’
[17:01:08.673]   - Field: ‘asynchronous’
[17:01:08.673]   - Field: ‘calls’
[17:01:08.674]   - Field: ‘globals’
[17:01:08.674]   - Field: ‘stdout’
[17:01:08.674]   - Field: ‘earlySignal’
[17:01:08.674]   - Field: ‘lazy’
[17:01:08.674]   - Field: ‘state’
[17:01:08.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.674] - Launch lazy future ...
[17:01:08.674] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:08.675] Packages needed by future strategies (n = 0): <none>
[17:01:08.675] {
[17:01:08.675]     {
[17:01:08.675]         {
[17:01:08.675]             ...future.startTime <- base::Sys.time()
[17:01:08.675]             {
[17:01:08.675]                 {
[17:01:08.675]                   {
[17:01:08.675]                     {
[17:01:08.675]                       {
[17:01:08.675]                         base::local({
[17:01:08.675]                           has_future <- base::requireNamespace("future", 
[17:01:08.675]                             quietly = TRUE)
[17:01:08.675]                           if (has_future) {
[17:01:08.675]                             ns <- base::getNamespace("future")
[17:01:08.675]                             version <- ns[[".package"]][["version"]]
[17:01:08.675]                             if (is.null(version)) 
[17:01:08.675]                               version <- utils::packageVersion("future")
[17:01:08.675]                           }
[17:01:08.675]                           else {
[17:01:08.675]                             version <- NULL
[17:01:08.675]                           }
[17:01:08.675]                           if (!has_future || version < "1.8.0") {
[17:01:08.675]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.675]                               "", base::R.version$version.string), 
[17:01:08.675]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.675]                                 base::R.version$platform, 8 * 
[17:01:08.675]                                   base::.Machine$sizeof.pointer), 
[17:01:08.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.675]                                 "release", "version")], collapse = " "), 
[17:01:08.675]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.675]                               info)
[17:01:08.675]                             info <- base::paste(info, collapse = "; ")
[17:01:08.675]                             if (!has_future) {
[17:01:08.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.675]                                 info)
[17:01:08.675]                             }
[17:01:08.675]                             else {
[17:01:08.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.675]                                 info, version)
[17:01:08.675]                             }
[17:01:08.675]                             base::stop(msg)
[17:01:08.675]                           }
[17:01:08.675]                         })
[17:01:08.675]                       }
[17:01:08.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.675]                       base::options(mc.cores = 1L)
[17:01:08.675]                     }
[17:01:08.675]                     base::local({
[17:01:08.675]                       for (pkg in c("stats", "future.apply")) {
[17:01:08.675]                         base::loadNamespace(pkg)
[17:01:08.675]                         base::library(pkg, character.only = TRUE)
[17:01:08.675]                       }
[17:01:08.675]                     })
[17:01:08.675]                   }
[17:01:08.675]                   ...future.strategy.old <- future::plan("list")
[17:01:08.675]                   options(future.plan = NULL)
[17:01:08.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.675]                 }
[17:01:08.675]                 ...future.workdir <- getwd()
[17:01:08.675]             }
[17:01:08.675]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.675]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.675]         }
[17:01:08.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.675]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.675]             base::names(...future.oldOptions))
[17:01:08.675]     }
[17:01:08.675]     if (FALSE) {
[17:01:08.675]     }
[17:01:08.675]     else {
[17:01:08.675]         if (TRUE) {
[17:01:08.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.675]                 open = "w")
[17:01:08.675]         }
[17:01:08.675]         else {
[17:01:08.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.675]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.675]         }
[17:01:08.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.675]             base::sink(type = "output", split = FALSE)
[17:01:08.675]             base::close(...future.stdout)
[17:01:08.675]         }, add = TRUE)
[17:01:08.675]     }
[17:01:08.675]     ...future.frame <- base::sys.nframe()
[17:01:08.675]     ...future.conditions <- base::list()
[17:01:08.675]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.675]     if (FALSE) {
[17:01:08.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.675]     }
[17:01:08.675]     ...future.result <- base::tryCatch({
[17:01:08.675]         base::withCallingHandlers({
[17:01:08.675]             ...future.value <- base::withVisible(base::local({
[17:01:08.675]                 ...future.makeSendCondition <- base::local({
[17:01:08.675]                   sendCondition <- NULL
[17:01:08.675]                   function(frame = 1L) {
[17:01:08.675]                     if (is.function(sendCondition)) 
[17:01:08.675]                       return(sendCondition)
[17:01:08.675]                     ns <- getNamespace("parallel")
[17:01:08.675]                     if (exists("sendData", mode = "function", 
[17:01:08.675]                       envir = ns)) {
[17:01:08.675]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.675]                         envir = ns)
[17:01:08.675]                       envir <- sys.frame(frame)
[17:01:08.675]                       master <- NULL
[17:01:08.675]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.675]                         !identical(envir, emptyenv())) {
[17:01:08.675]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.675]                           inherits = FALSE)) {
[17:01:08.675]                           master <- get("master", mode = "list", 
[17:01:08.675]                             envir = envir, inherits = FALSE)
[17:01:08.675]                           if (inherits(master, c("SOCKnode", 
[17:01:08.675]                             "SOCK0node"))) {
[17:01:08.675]                             sendCondition <<- function(cond) {
[17:01:08.675]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.675]                                 success = TRUE)
[17:01:08.675]                               parallel_sendData(master, data)
[17:01:08.675]                             }
[17:01:08.675]                             return(sendCondition)
[17:01:08.675]                           }
[17:01:08.675]                         }
[17:01:08.675]                         frame <- frame + 1L
[17:01:08.675]                         envir <- sys.frame(frame)
[17:01:08.675]                       }
[17:01:08.675]                     }
[17:01:08.675]                     sendCondition <<- function(cond) NULL
[17:01:08.675]                   }
[17:01:08.675]                 })
[17:01:08.675]                 withCallingHandlers({
[17:01:08.675]                   {
[17:01:08.675]                     do.call(function(...) {
[17:01:08.675]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.675]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.675]                         ...future.globals.maxSize)) {
[17:01:08.675]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.675]                         on.exit(options(oopts), add = TRUE)
[17:01:08.675]                       }
[17:01:08.675]                       {
[17:01:08.675]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.675]                           FUN = function(jj) {
[17:01:08.675]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.675]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.675]                           })
[17:01:08.675]                       }
[17:01:08.675]                     }, args = future.call.arguments)
[17:01:08.675]                   }
[17:01:08.675]                 }, immediateCondition = function(cond) {
[17:01:08.675]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.675]                   sendCondition(cond)
[17:01:08.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.675]                   {
[17:01:08.675]                     inherits <- base::inherits
[17:01:08.675]                     invokeRestart <- base::invokeRestart
[17:01:08.675]                     is.null <- base::is.null
[17:01:08.675]                     muffled <- FALSE
[17:01:08.675]                     if (inherits(cond, "message")) {
[17:01:08.675]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.675]                       if (muffled) 
[17:01:08.675]                         invokeRestart("muffleMessage")
[17:01:08.675]                     }
[17:01:08.675]                     else if (inherits(cond, "warning")) {
[17:01:08.675]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.675]                       if (muffled) 
[17:01:08.675]                         invokeRestart("muffleWarning")
[17:01:08.675]                     }
[17:01:08.675]                     else if (inherits(cond, "condition")) {
[17:01:08.675]                       if (!is.null(pattern)) {
[17:01:08.675]                         computeRestarts <- base::computeRestarts
[17:01:08.675]                         grepl <- base::grepl
[17:01:08.675]                         restarts <- computeRestarts(cond)
[17:01:08.675]                         for (restart in restarts) {
[17:01:08.675]                           name <- restart$name
[17:01:08.675]                           if (is.null(name)) 
[17:01:08.675]                             next
[17:01:08.675]                           if (!grepl(pattern, name)) 
[17:01:08.675]                             next
[17:01:08.675]                           invokeRestart(restart)
[17:01:08.675]                           muffled <- TRUE
[17:01:08.675]                           break
[17:01:08.675]                         }
[17:01:08.675]                       }
[17:01:08.675]                     }
[17:01:08.675]                     invisible(muffled)
[17:01:08.675]                   }
[17:01:08.675]                   muffleCondition(cond)
[17:01:08.675]                 })
[17:01:08.675]             }))
[17:01:08.675]             future::FutureResult(value = ...future.value$value, 
[17:01:08.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.675]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.675]                     ...future.globalenv.names))
[17:01:08.675]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.675]         }, condition = base::local({
[17:01:08.675]             c <- base::c
[17:01:08.675]             inherits <- base::inherits
[17:01:08.675]             invokeRestart <- base::invokeRestart
[17:01:08.675]             length <- base::length
[17:01:08.675]             list <- base::list
[17:01:08.675]             seq.int <- base::seq.int
[17:01:08.675]             signalCondition <- base::signalCondition
[17:01:08.675]             sys.calls <- base::sys.calls
[17:01:08.675]             `[[` <- base::`[[`
[17:01:08.675]             `+` <- base::`+`
[17:01:08.675]             `<<-` <- base::`<<-`
[17:01:08.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.675]                   3L)]
[17:01:08.675]             }
[17:01:08.675]             function(cond) {
[17:01:08.675]                 is_error <- inherits(cond, "error")
[17:01:08.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.675]                   NULL)
[17:01:08.675]                 if (is_error) {
[17:01:08.675]                   sessionInformation <- function() {
[17:01:08.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.675]                       search = base::search(), system = base::Sys.info())
[17:01:08.675]                   }
[17:01:08.675]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.675]                     cond$call), session = sessionInformation(), 
[17:01:08.675]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.675]                   signalCondition(cond)
[17:01:08.675]                 }
[17:01:08.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.675]                 "immediateCondition"))) {
[17:01:08.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.675]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.675]                   if (TRUE && !signal) {
[17:01:08.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.675]                     {
[17:01:08.675]                       inherits <- base::inherits
[17:01:08.675]                       invokeRestart <- base::invokeRestart
[17:01:08.675]                       is.null <- base::is.null
[17:01:08.675]                       muffled <- FALSE
[17:01:08.675]                       if (inherits(cond, "message")) {
[17:01:08.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.675]                         if (muffled) 
[17:01:08.675]                           invokeRestart("muffleMessage")
[17:01:08.675]                       }
[17:01:08.675]                       else if (inherits(cond, "warning")) {
[17:01:08.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.675]                         if (muffled) 
[17:01:08.675]                           invokeRestart("muffleWarning")
[17:01:08.675]                       }
[17:01:08.675]                       else if (inherits(cond, "condition")) {
[17:01:08.675]                         if (!is.null(pattern)) {
[17:01:08.675]                           computeRestarts <- base::computeRestarts
[17:01:08.675]                           grepl <- base::grepl
[17:01:08.675]                           restarts <- computeRestarts(cond)
[17:01:08.675]                           for (restart in restarts) {
[17:01:08.675]                             name <- restart$name
[17:01:08.675]                             if (is.null(name)) 
[17:01:08.675]                               next
[17:01:08.675]                             if (!grepl(pattern, name)) 
[17:01:08.675]                               next
[17:01:08.675]                             invokeRestart(restart)
[17:01:08.675]                             muffled <- TRUE
[17:01:08.675]                             break
[17:01:08.675]                           }
[17:01:08.675]                         }
[17:01:08.675]                       }
[17:01:08.675]                       invisible(muffled)
[17:01:08.675]                     }
[17:01:08.675]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.675]                   }
[17:01:08.675]                 }
[17:01:08.675]                 else {
[17:01:08.675]                   if (TRUE) {
[17:01:08.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.675]                     {
[17:01:08.675]                       inherits <- base::inherits
[17:01:08.675]                       invokeRestart <- base::invokeRestart
[17:01:08.675]                       is.null <- base::is.null
[17:01:08.675]                       muffled <- FALSE
[17:01:08.675]                       if (inherits(cond, "message")) {
[17:01:08.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.675]                         if (muffled) 
[17:01:08.675]                           invokeRestart("muffleMessage")
[17:01:08.675]                       }
[17:01:08.675]                       else if (inherits(cond, "warning")) {
[17:01:08.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.675]                         if (muffled) 
[17:01:08.675]                           invokeRestart("muffleWarning")
[17:01:08.675]                       }
[17:01:08.675]                       else if (inherits(cond, "condition")) {
[17:01:08.675]                         if (!is.null(pattern)) {
[17:01:08.675]                           computeRestarts <- base::computeRestarts
[17:01:08.675]                           grepl <- base::grepl
[17:01:08.675]                           restarts <- computeRestarts(cond)
[17:01:08.675]                           for (restart in restarts) {
[17:01:08.675]                             name <- restart$name
[17:01:08.675]                             if (is.null(name)) 
[17:01:08.675]                               next
[17:01:08.675]                             if (!grepl(pattern, name)) 
[17:01:08.675]                               next
[17:01:08.675]                             invokeRestart(restart)
[17:01:08.675]                             muffled <- TRUE
[17:01:08.675]                             break
[17:01:08.675]                           }
[17:01:08.675]                         }
[17:01:08.675]                       }
[17:01:08.675]                       invisible(muffled)
[17:01:08.675]                     }
[17:01:08.675]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.675]                   }
[17:01:08.675]                 }
[17:01:08.675]             }
[17:01:08.675]         }))
[17:01:08.675]     }, error = function(ex) {
[17:01:08.675]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.675]                 ...future.rng), started = ...future.startTime, 
[17:01:08.675]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.675]             version = "1.8"), class = "FutureResult")
[17:01:08.675]     }, finally = {
[17:01:08.675]         if (!identical(...future.workdir, getwd())) 
[17:01:08.675]             setwd(...future.workdir)
[17:01:08.675]         {
[17:01:08.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.675]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.675]             }
[17:01:08.675]             base::options(...future.oldOptions)
[17:01:08.675]             if (.Platform$OS.type == "windows") {
[17:01:08.675]                 old_names <- names(...future.oldEnvVars)
[17:01:08.675]                 envs <- base::Sys.getenv()
[17:01:08.675]                 names <- names(envs)
[17:01:08.675]                 common <- intersect(names, old_names)
[17:01:08.675]                 added <- setdiff(names, old_names)
[17:01:08.675]                 removed <- setdiff(old_names, names)
[17:01:08.675]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.675]                   envs[common]]
[17:01:08.675]                 NAMES <- toupper(changed)
[17:01:08.675]                 args <- list()
[17:01:08.675]                 for (kk in seq_along(NAMES)) {
[17:01:08.675]                   name <- changed[[kk]]
[17:01:08.675]                   NAME <- NAMES[[kk]]
[17:01:08.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.675]                     next
[17:01:08.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.675]                 }
[17:01:08.675]                 NAMES <- toupper(added)
[17:01:08.675]                 for (kk in seq_along(NAMES)) {
[17:01:08.675]                   name <- added[[kk]]
[17:01:08.675]                   NAME <- NAMES[[kk]]
[17:01:08.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.675]                     next
[17:01:08.675]                   args[[name]] <- ""
[17:01:08.675]                 }
[17:01:08.675]                 NAMES <- toupper(removed)
[17:01:08.675]                 for (kk in seq_along(NAMES)) {
[17:01:08.675]                   name <- removed[[kk]]
[17:01:08.675]                   NAME <- NAMES[[kk]]
[17:01:08.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.675]                     next
[17:01:08.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.675]                 }
[17:01:08.675]                 if (length(args) > 0) 
[17:01:08.675]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.675]             }
[17:01:08.675]             else {
[17:01:08.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.675]             }
[17:01:08.675]             {
[17:01:08.675]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.675]                   0L) {
[17:01:08.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.675]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.675]                   base::options(opts)
[17:01:08.675]                 }
[17:01:08.675]                 {
[17:01:08.675]                   {
[17:01:08.675]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.675]                     NULL
[17:01:08.675]                   }
[17:01:08.675]                   options(future.plan = NULL)
[17:01:08.675]                   if (is.na(NA_character_)) 
[17:01:08.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.675]                     .init = FALSE)
[17:01:08.675]                 }
[17:01:08.675]             }
[17:01:08.675]         }
[17:01:08.675]     })
[17:01:08.675]     if (TRUE) {
[17:01:08.675]         base::sink(type = "output", split = FALSE)
[17:01:08.675]         if (TRUE) {
[17:01:08.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.675]         }
[17:01:08.675]         else {
[17:01:08.675]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.675]         }
[17:01:08.675]         base::close(...future.stdout)
[17:01:08.675]         ...future.stdout <- NULL
[17:01:08.675]     }
[17:01:08.675]     ...future.result$conditions <- ...future.conditions
[17:01:08.675]     ...future.result$finished <- base::Sys.time()
[17:01:08.675]     ...future.result
[17:01:08.675] }
[17:01:08.678] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[17:01:08.678] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:08.720] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:08.720] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[17:01:08.764] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:01:08.764] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:08.764] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:08.765] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:08.808] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:08.808] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:08.852] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:08.852] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:08.853] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.853] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:08.853] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:08.853] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:08.854] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.854] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:01:08.854] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:01:08.854] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:08.855] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:08.855] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:08.855] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[17:01:08.856] MultisessionFuture started
[17:01:08.856] - Launch lazy future ... done
[17:01:08.856] run() for ‘MultisessionFuture’ ... done
[17:01:08.856] Created future:
[17:01:08.858] receiveMessageFromWorker() for ClusterFuture ...
[17:01:08.858] - Validating connection of MultisessionFuture
[17:01:08.858] - received message: FutureResult
[17:01:08.858] - Received FutureResult
[17:01:08.858] - Erased future from FutureRegistry
[17:01:08.858] result() for ClusterFuture ...
[17:01:08.858] - result already collected: FutureResult
[17:01:08.859] result() for ClusterFuture ... done
[17:01:08.859] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:08.856] MultisessionFuture:
[17:01:08.856] Label: ‘future_vapply-1’
[17:01:08.856] Expression:
[17:01:08.856] {
[17:01:08.856]     do.call(function(...) {
[17:01:08.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.856]             on.exit(options(oopts), add = TRUE)
[17:01:08.856]         }
[17:01:08.856]         {
[17:01:08.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.856]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.856]             })
[17:01:08.856]         }
[17:01:08.856]     }, args = future.call.arguments)
[17:01:08.856] }
[17:01:08.856] Lazy evaluation: FALSE
[17:01:08.856] Asynchronous evaluation: TRUE
[17:01:08.856] Local evaluation: TRUE
[17:01:08.856] Environment: R_GlobalEnv
[17:01:08.856] Capture standard output: TRUE
[17:01:08.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:08.856] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:08.856] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:08.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:08.856] Resolved: TRUE
[17:01:08.856] Value: <not collected>
[17:01:08.856] Conditions captured: <none>
[17:01:08.856] Early signaling: FALSE
[17:01:08.856] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:08.856] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.859] Chunk #1 of 2 ... DONE
[17:01:08.859] Chunk #2 of 2 ...
[17:01:08.859]  - Finding globals in 'X' for chunk #2 ...
[17:01:08.859] getGlobalsAndPackages() ...
[17:01:08.859] Searching for globals...
[17:01:08.860] 
[17:01:08.860] Searching for globals ... DONE
[17:01:08.860] - globals: [0] <none>
[17:01:08.860] getGlobalsAndPackages() ... DONE
[17:01:08.860]    + additional globals found: [n=0] 
[17:01:08.860]    + additional namespaces needed: [n=0] 
[17:01:08.860]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:08.860]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:08.860]  - seeds: <none>
[17:01:08.860]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.861] getGlobalsAndPackages() ...
[17:01:08.861] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.861] Resolving globals: FALSE
[17:01:08.861] Tweak future expression to call with '...' arguments ...
[17:01:08.861] {
[17:01:08.861]     do.call(function(...) {
[17:01:08.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:08.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.861]             on.exit(options(oopts), add = TRUE)
[17:01:08.861]         }
[17:01:08.861]         {
[17:01:08.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:08.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.861]                 ...future.FUN(...future.X_jj, ...)
[17:01:08.861]             })
[17:01:08.861]         }
[17:01:08.861]     }, args = future.call.arguments)
[17:01:08.861] }
[17:01:08.861] Tweak future expression to call with '...' arguments ... DONE
[17:01:08.862] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:08.862] - packages: [2] ‘stats’, ‘future.apply’
[17:01:08.862] getGlobalsAndPackages() ... DONE
[17:01:08.862] run() for ‘Future’ ...
[17:01:08.862] - state: ‘created’
[17:01:08.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:08.877] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:08.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:08.877]   - Field: ‘node’
[17:01:08.877]   - Field: ‘label’
[17:01:08.877]   - Field: ‘local’
[17:01:08.878]   - Field: ‘owner’
[17:01:08.878]   - Field: ‘envir’
[17:01:08.878]   - Field: ‘workers’
[17:01:08.878]   - Field: ‘packages’
[17:01:08.878]   - Field: ‘gc’
[17:01:08.878]   - Field: ‘conditions’
[17:01:08.878]   - Field: ‘persistent’
[17:01:08.878]   - Field: ‘expr’
[17:01:08.878]   - Field: ‘uuid’
[17:01:08.878]   - Field: ‘seed’
[17:01:08.878]   - Field: ‘version’
[17:01:08.878]   - Field: ‘result’
[17:01:08.879]   - Field: ‘asynchronous’
[17:01:08.879]   - Field: ‘calls’
[17:01:08.879]   - Field: ‘globals’
[17:01:08.879]   - Field: ‘stdout’
[17:01:08.879]   - Field: ‘earlySignal’
[17:01:08.879]   - Field: ‘lazy’
[17:01:08.879]   - Field: ‘state’
[17:01:08.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:08.879] - Launch lazy future ...
[17:01:08.880] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:01:08.880] Packages needed by future strategies (n = 0): <none>
[17:01:08.880] {
[17:01:08.880]     {
[17:01:08.880]         {
[17:01:08.880]             ...future.startTime <- base::Sys.time()
[17:01:08.880]             {
[17:01:08.880]                 {
[17:01:08.880]                   {
[17:01:08.880]                     {
[17:01:08.880]                       {
[17:01:08.880]                         base::local({
[17:01:08.880]                           has_future <- base::requireNamespace("future", 
[17:01:08.880]                             quietly = TRUE)
[17:01:08.880]                           if (has_future) {
[17:01:08.880]                             ns <- base::getNamespace("future")
[17:01:08.880]                             version <- ns[[".package"]][["version"]]
[17:01:08.880]                             if (is.null(version)) 
[17:01:08.880]                               version <- utils::packageVersion("future")
[17:01:08.880]                           }
[17:01:08.880]                           else {
[17:01:08.880]                             version <- NULL
[17:01:08.880]                           }
[17:01:08.880]                           if (!has_future || version < "1.8.0") {
[17:01:08.880]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:08.880]                               "", base::R.version$version.string), 
[17:01:08.880]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:08.880]                                 base::R.version$platform, 8 * 
[17:01:08.880]                                   base::.Machine$sizeof.pointer), 
[17:01:08.880]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:08.880]                                 "release", "version")], collapse = " "), 
[17:01:08.880]                               hostname = base::Sys.info()[["nodename"]])
[17:01:08.880]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:08.880]                               info)
[17:01:08.880]                             info <- base::paste(info, collapse = "; ")
[17:01:08.880]                             if (!has_future) {
[17:01:08.880]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:08.880]                                 info)
[17:01:08.880]                             }
[17:01:08.880]                             else {
[17:01:08.880]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:08.880]                                 info, version)
[17:01:08.880]                             }
[17:01:08.880]                             base::stop(msg)
[17:01:08.880]                           }
[17:01:08.880]                         })
[17:01:08.880]                       }
[17:01:08.880]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:08.880]                       base::options(mc.cores = 1L)
[17:01:08.880]                     }
[17:01:08.880]                     base::local({
[17:01:08.880]                       for (pkg in c("stats", "future.apply")) {
[17:01:08.880]                         base::loadNamespace(pkg)
[17:01:08.880]                         base::library(pkg, character.only = TRUE)
[17:01:08.880]                       }
[17:01:08.880]                     })
[17:01:08.880]                   }
[17:01:08.880]                   ...future.strategy.old <- future::plan("list")
[17:01:08.880]                   options(future.plan = NULL)
[17:01:08.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:08.880]                 }
[17:01:08.880]                 ...future.workdir <- getwd()
[17:01:08.880]             }
[17:01:08.880]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:08.880]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:08.880]         }
[17:01:08.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:08.880]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:08.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:08.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:08.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:08.880]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:08.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:08.880]             base::names(...future.oldOptions))
[17:01:08.880]     }
[17:01:08.880]     if (FALSE) {
[17:01:08.880]     }
[17:01:08.880]     else {
[17:01:08.880]         if (TRUE) {
[17:01:08.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:08.880]                 open = "w")
[17:01:08.880]         }
[17:01:08.880]         else {
[17:01:08.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:08.880]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:08.880]         }
[17:01:08.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:08.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:08.880]             base::sink(type = "output", split = FALSE)
[17:01:08.880]             base::close(...future.stdout)
[17:01:08.880]         }, add = TRUE)
[17:01:08.880]     }
[17:01:08.880]     ...future.frame <- base::sys.nframe()
[17:01:08.880]     ...future.conditions <- base::list()
[17:01:08.880]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:08.880]     if (FALSE) {
[17:01:08.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:08.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:08.880]     }
[17:01:08.880]     ...future.result <- base::tryCatch({
[17:01:08.880]         base::withCallingHandlers({
[17:01:08.880]             ...future.value <- base::withVisible(base::local({
[17:01:08.880]                 ...future.makeSendCondition <- base::local({
[17:01:08.880]                   sendCondition <- NULL
[17:01:08.880]                   function(frame = 1L) {
[17:01:08.880]                     if (is.function(sendCondition)) 
[17:01:08.880]                       return(sendCondition)
[17:01:08.880]                     ns <- getNamespace("parallel")
[17:01:08.880]                     if (exists("sendData", mode = "function", 
[17:01:08.880]                       envir = ns)) {
[17:01:08.880]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:08.880]                         envir = ns)
[17:01:08.880]                       envir <- sys.frame(frame)
[17:01:08.880]                       master <- NULL
[17:01:08.880]                       while (!identical(envir, .GlobalEnv) && 
[17:01:08.880]                         !identical(envir, emptyenv())) {
[17:01:08.880]                         if (exists("master", mode = "list", envir = envir, 
[17:01:08.880]                           inherits = FALSE)) {
[17:01:08.880]                           master <- get("master", mode = "list", 
[17:01:08.880]                             envir = envir, inherits = FALSE)
[17:01:08.880]                           if (inherits(master, c("SOCKnode", 
[17:01:08.880]                             "SOCK0node"))) {
[17:01:08.880]                             sendCondition <<- function(cond) {
[17:01:08.880]                               data <- list(type = "VALUE", value = cond, 
[17:01:08.880]                                 success = TRUE)
[17:01:08.880]                               parallel_sendData(master, data)
[17:01:08.880]                             }
[17:01:08.880]                             return(sendCondition)
[17:01:08.880]                           }
[17:01:08.880]                         }
[17:01:08.880]                         frame <- frame + 1L
[17:01:08.880]                         envir <- sys.frame(frame)
[17:01:08.880]                       }
[17:01:08.880]                     }
[17:01:08.880]                     sendCondition <<- function(cond) NULL
[17:01:08.880]                   }
[17:01:08.880]                 })
[17:01:08.880]                 withCallingHandlers({
[17:01:08.880]                   {
[17:01:08.880]                     do.call(function(...) {
[17:01:08.880]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:08.880]                       if (!identical(...future.globals.maxSize.org, 
[17:01:08.880]                         ...future.globals.maxSize)) {
[17:01:08.880]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:08.880]                         on.exit(options(oopts), add = TRUE)
[17:01:08.880]                       }
[17:01:08.880]                       {
[17:01:08.880]                         lapply(seq_along(...future.elements_ii), 
[17:01:08.880]                           FUN = function(jj) {
[17:01:08.880]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:08.880]                             ...future.FUN(...future.X_jj, ...)
[17:01:08.880]                           })
[17:01:08.880]                       }
[17:01:08.880]                     }, args = future.call.arguments)
[17:01:08.880]                   }
[17:01:08.880]                 }, immediateCondition = function(cond) {
[17:01:08.880]                   sendCondition <- ...future.makeSendCondition()
[17:01:08.880]                   sendCondition(cond)
[17:01:08.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.880]                   {
[17:01:08.880]                     inherits <- base::inherits
[17:01:08.880]                     invokeRestart <- base::invokeRestart
[17:01:08.880]                     is.null <- base::is.null
[17:01:08.880]                     muffled <- FALSE
[17:01:08.880]                     if (inherits(cond, "message")) {
[17:01:08.880]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:08.880]                       if (muffled) 
[17:01:08.880]                         invokeRestart("muffleMessage")
[17:01:08.880]                     }
[17:01:08.880]                     else if (inherits(cond, "warning")) {
[17:01:08.880]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:08.880]                       if (muffled) 
[17:01:08.880]                         invokeRestart("muffleWarning")
[17:01:08.880]                     }
[17:01:08.880]                     else if (inherits(cond, "condition")) {
[17:01:08.880]                       if (!is.null(pattern)) {
[17:01:08.880]                         computeRestarts <- base::computeRestarts
[17:01:08.880]                         grepl <- base::grepl
[17:01:08.880]                         restarts <- computeRestarts(cond)
[17:01:08.880]                         for (restart in restarts) {
[17:01:08.880]                           name <- restart$name
[17:01:08.880]                           if (is.null(name)) 
[17:01:08.880]                             next
[17:01:08.880]                           if (!grepl(pattern, name)) 
[17:01:08.880]                             next
[17:01:08.880]                           invokeRestart(restart)
[17:01:08.880]                           muffled <- TRUE
[17:01:08.880]                           break
[17:01:08.880]                         }
[17:01:08.880]                       }
[17:01:08.880]                     }
[17:01:08.880]                     invisible(muffled)
[17:01:08.880]                   }
[17:01:08.880]                   muffleCondition(cond)
[17:01:08.880]                 })
[17:01:08.880]             }))
[17:01:08.880]             future::FutureResult(value = ...future.value$value, 
[17:01:08.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.880]                   ...future.rng), globalenv = if (FALSE) 
[17:01:08.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:08.880]                     ...future.globalenv.names))
[17:01:08.880]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:08.880]         }, condition = base::local({
[17:01:08.880]             c <- base::c
[17:01:08.880]             inherits <- base::inherits
[17:01:08.880]             invokeRestart <- base::invokeRestart
[17:01:08.880]             length <- base::length
[17:01:08.880]             list <- base::list
[17:01:08.880]             seq.int <- base::seq.int
[17:01:08.880]             signalCondition <- base::signalCondition
[17:01:08.880]             sys.calls <- base::sys.calls
[17:01:08.880]             `[[` <- base::`[[`
[17:01:08.880]             `+` <- base::`+`
[17:01:08.880]             `<<-` <- base::`<<-`
[17:01:08.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:08.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:08.880]                   3L)]
[17:01:08.880]             }
[17:01:08.880]             function(cond) {
[17:01:08.880]                 is_error <- inherits(cond, "error")
[17:01:08.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:08.880]                   NULL)
[17:01:08.880]                 if (is_error) {
[17:01:08.880]                   sessionInformation <- function() {
[17:01:08.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:08.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:08.880]                       search = base::search(), system = base::Sys.info())
[17:01:08.880]                   }
[17:01:08.880]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:08.880]                     cond$call), session = sessionInformation(), 
[17:01:08.880]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:08.880]                   signalCondition(cond)
[17:01:08.880]                 }
[17:01:08.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:08.880]                 "immediateCondition"))) {
[17:01:08.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:08.880]                   ...future.conditions[[length(...future.conditions) + 
[17:01:08.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:08.880]                   if (TRUE && !signal) {
[17:01:08.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.880]                     {
[17:01:08.880]                       inherits <- base::inherits
[17:01:08.880]                       invokeRestart <- base::invokeRestart
[17:01:08.880]                       is.null <- base::is.null
[17:01:08.880]                       muffled <- FALSE
[17:01:08.880]                       if (inherits(cond, "message")) {
[17:01:08.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.880]                         if (muffled) 
[17:01:08.880]                           invokeRestart("muffleMessage")
[17:01:08.880]                       }
[17:01:08.880]                       else if (inherits(cond, "warning")) {
[17:01:08.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.880]                         if (muffled) 
[17:01:08.880]                           invokeRestart("muffleWarning")
[17:01:08.880]                       }
[17:01:08.880]                       else if (inherits(cond, "condition")) {
[17:01:08.880]                         if (!is.null(pattern)) {
[17:01:08.880]                           computeRestarts <- base::computeRestarts
[17:01:08.880]                           grepl <- base::grepl
[17:01:08.880]                           restarts <- computeRestarts(cond)
[17:01:08.880]                           for (restart in restarts) {
[17:01:08.880]                             name <- restart$name
[17:01:08.880]                             if (is.null(name)) 
[17:01:08.880]                               next
[17:01:08.880]                             if (!grepl(pattern, name)) 
[17:01:08.880]                               next
[17:01:08.880]                             invokeRestart(restart)
[17:01:08.880]                             muffled <- TRUE
[17:01:08.880]                             break
[17:01:08.880]                           }
[17:01:08.880]                         }
[17:01:08.880]                       }
[17:01:08.880]                       invisible(muffled)
[17:01:08.880]                     }
[17:01:08.880]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.880]                   }
[17:01:08.880]                 }
[17:01:08.880]                 else {
[17:01:08.880]                   if (TRUE) {
[17:01:08.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:08.880]                     {
[17:01:08.880]                       inherits <- base::inherits
[17:01:08.880]                       invokeRestart <- base::invokeRestart
[17:01:08.880]                       is.null <- base::is.null
[17:01:08.880]                       muffled <- FALSE
[17:01:08.880]                       if (inherits(cond, "message")) {
[17:01:08.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:08.880]                         if (muffled) 
[17:01:08.880]                           invokeRestart("muffleMessage")
[17:01:08.880]                       }
[17:01:08.880]                       else if (inherits(cond, "warning")) {
[17:01:08.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:08.880]                         if (muffled) 
[17:01:08.880]                           invokeRestart("muffleWarning")
[17:01:08.880]                       }
[17:01:08.880]                       else if (inherits(cond, "condition")) {
[17:01:08.880]                         if (!is.null(pattern)) {
[17:01:08.880]                           computeRestarts <- base::computeRestarts
[17:01:08.880]                           grepl <- base::grepl
[17:01:08.880]                           restarts <- computeRestarts(cond)
[17:01:08.880]                           for (restart in restarts) {
[17:01:08.880]                             name <- restart$name
[17:01:08.880]                             if (is.null(name)) 
[17:01:08.880]                               next
[17:01:08.880]                             if (!grepl(pattern, name)) 
[17:01:08.880]                               next
[17:01:08.880]                             invokeRestart(restart)
[17:01:08.880]                             muffled <- TRUE
[17:01:08.880]                             break
[17:01:08.880]                           }
[17:01:08.880]                         }
[17:01:08.880]                       }
[17:01:08.880]                       invisible(muffled)
[17:01:08.880]                     }
[17:01:08.880]                     muffleCondition(cond, pattern = "^muffle")
[17:01:08.880]                   }
[17:01:08.880]                 }
[17:01:08.880]             }
[17:01:08.880]         }))
[17:01:08.880]     }, error = function(ex) {
[17:01:08.880]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:08.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:08.880]                 ...future.rng), started = ...future.startTime, 
[17:01:08.880]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:08.880]             version = "1.8"), class = "FutureResult")
[17:01:08.880]     }, finally = {
[17:01:08.880]         if (!identical(...future.workdir, getwd())) 
[17:01:08.880]             setwd(...future.workdir)
[17:01:08.880]         {
[17:01:08.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:08.880]                 ...future.oldOptions$nwarnings <- NULL
[17:01:08.880]             }
[17:01:08.880]             base::options(...future.oldOptions)
[17:01:08.880]             if (.Platform$OS.type == "windows") {
[17:01:08.880]                 old_names <- names(...future.oldEnvVars)
[17:01:08.880]                 envs <- base::Sys.getenv()
[17:01:08.880]                 names <- names(envs)
[17:01:08.880]                 common <- intersect(names, old_names)
[17:01:08.880]                 added <- setdiff(names, old_names)
[17:01:08.880]                 removed <- setdiff(old_names, names)
[17:01:08.880]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:08.880]                   envs[common]]
[17:01:08.880]                 NAMES <- toupper(changed)
[17:01:08.880]                 args <- list()
[17:01:08.880]                 for (kk in seq_along(NAMES)) {
[17:01:08.880]                   name <- changed[[kk]]
[17:01:08.880]                   NAME <- NAMES[[kk]]
[17:01:08.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.880]                     next
[17:01:08.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.880]                 }
[17:01:08.880]                 NAMES <- toupper(added)
[17:01:08.880]                 for (kk in seq_along(NAMES)) {
[17:01:08.880]                   name <- added[[kk]]
[17:01:08.880]                   NAME <- NAMES[[kk]]
[17:01:08.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.880]                     next
[17:01:08.880]                   args[[name]] <- ""
[17:01:08.880]                 }
[17:01:08.880]                 NAMES <- toupper(removed)
[17:01:08.880]                 for (kk in seq_along(NAMES)) {
[17:01:08.880]                   name <- removed[[kk]]
[17:01:08.880]                   NAME <- NAMES[[kk]]
[17:01:08.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:08.880]                     next
[17:01:08.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:08.880]                 }
[17:01:08.880]                 if (length(args) > 0) 
[17:01:08.880]                   base::do.call(base::Sys.setenv, args = args)
[17:01:08.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:08.880]             }
[17:01:08.880]             else {
[17:01:08.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:08.880]             }
[17:01:08.880]             {
[17:01:08.880]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:08.880]                   0L) {
[17:01:08.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:08.880]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:08.880]                   base::options(opts)
[17:01:08.880]                 }
[17:01:08.880]                 {
[17:01:08.880]                   {
[17:01:08.880]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:08.880]                     NULL
[17:01:08.880]                   }
[17:01:08.880]                   options(future.plan = NULL)
[17:01:08.880]                   if (is.na(NA_character_)) 
[17:01:08.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:08.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:08.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:08.880]                     .init = FALSE)
[17:01:08.880]                 }
[17:01:08.880]             }
[17:01:08.880]         }
[17:01:08.880]     })
[17:01:08.880]     if (TRUE) {
[17:01:08.880]         base::sink(type = "output", split = FALSE)
[17:01:08.880]         if (TRUE) {
[17:01:08.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:08.880]         }
[17:01:08.880]         else {
[17:01:08.880]             ...future.result["stdout"] <- base::list(NULL)
[17:01:08.880]         }
[17:01:08.880]         base::close(...future.stdout)
[17:01:08.880]         ...future.stdout <- NULL
[17:01:08.880]     }
[17:01:08.880]     ...future.result$conditions <- ...future.conditions
[17:01:08.880]     ...future.result$finished <- base::Sys.time()
[17:01:08.880]     ...future.result
[17:01:08.880] }
[17:01:08.883] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[17:01:08.883] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:08.928] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:08.928] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[17:01:08.972] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:01:08.972] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:08.972] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:08.973] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:09.016] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:09.016] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:09.060] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:09.060] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:09.060] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.061] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:09.061] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:09.061] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:09.062] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.062] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ...
[17:01:09.062] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ... DONE
[17:01:09.062] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:09.063] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:09.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.063] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[17:01:09.064] MultisessionFuture started
[17:01:09.064] - Launch lazy future ... done
[17:01:09.064] run() for ‘MultisessionFuture’ ... done
[17:01:09.064] Created future:
[17:01:09.065] MultisessionFuture:
[17:01:09.065] Label: ‘future_vapply-2’
[17:01:09.065] Expression:
[17:01:09.065] {
[17:01:09.065]     do.call(function(...) {
[17:01:09.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.065]             on.exit(options(oopts), add = TRUE)
[17:01:09.065]         }
[17:01:09.065]         {
[17:01:09.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.065]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.065]             })
[17:01:09.065]         }
[17:01:09.065]     }, args = future.call.arguments)
[17:01:09.065] }
[17:01:09.065] Lazy evaluation: FALSE
[17:01:09.065] Asynchronous evaluation: TRUE
[17:01:09.065] Local evaluation: TRUE
[17:01:09.065] Environment: R_GlobalEnv
[17:01:09.065] Capture standard output: TRUE
[17:01:09.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.065] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:09.065] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:01:09.065] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.065] Resolved: FALSE
[17:01:09.065] Value: <not collected>
[17:01:09.065] Conditions captured: <none>
[17:01:09.065] Early signaling: FALSE
[17:01:09.065] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.065] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.076] Chunk #2 of 2 ... DONE
[17:01:09.076] Launching 2 futures (chunks) ... DONE
[17:01:09.077] Resolving 2 futures (chunks) ...
[17:01:09.077] resolve() on list ...
[17:01:09.085]  recursive: 0
[17:01:09.085]  length: 2
[17:01:09.085] 
[17:01:09.085] Future #1
[17:01:09.086] result() for ClusterFuture ...
[17:01:09.086] - result already collected: FutureResult
[17:01:09.086] result() for ClusterFuture ... done
[17:01:09.086] result() for ClusterFuture ...
[17:01:09.086] - result already collected: FutureResult
[17:01:09.086] result() for ClusterFuture ... done
[17:01:09.086] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:09.086] - nx: 2
[17:01:09.086] - relay: TRUE
[17:01:09.086] - stdout: TRUE
[17:01:09.086] - signal: TRUE
[17:01:09.087] - resignal: FALSE
[17:01:09.087] - force: TRUE
[17:01:09.087] - relayed: [n=2] FALSE, FALSE
[17:01:09.087] - queued futures: [n=2] FALSE, FALSE
[17:01:09.087]  - until=1
[17:01:09.087]  - relaying element #1
[17:01:09.087] result() for ClusterFuture ...
[17:01:09.087] - result already collected: FutureResult
[17:01:09.087] result() for ClusterFuture ... done
[17:01:09.087] result() for ClusterFuture ...
[17:01:09.087] - result already collected: FutureResult
[17:01:09.088] result() for ClusterFuture ... done
[17:01:09.088] result() for ClusterFuture ...
[17:01:09.088] - result already collected: FutureResult
[17:01:09.088] result() for ClusterFuture ... done
[17:01:09.088] result() for ClusterFuture ...
[17:01:09.088] - result already collected: FutureResult
[17:01:09.088] result() for ClusterFuture ... done
[17:01:09.088] - relayed: [n=2] TRUE, FALSE
[17:01:09.088] - queued futures: [n=2] TRUE, FALSE
[17:01:09.088] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:09.088]  length: 1 (resolved future 1)
[17:01:09.110] receiveMessageFromWorker() for ClusterFuture ...
[17:01:09.110] - Validating connection of MultisessionFuture
[17:01:09.110] - received message: FutureResult
[17:01:09.110] - Received FutureResult
[17:01:09.111] - Erased future from FutureRegistry
[17:01:09.111] result() for ClusterFuture ...
[17:01:09.111] - result already collected: FutureResult
[17:01:09.111] result() for ClusterFuture ... done
[17:01:09.111] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:09.111] Future #2
[17:01:09.112] result() for ClusterFuture ...
[17:01:09.112] - result already collected: FutureResult
[17:01:09.112] result() for ClusterFuture ... done
[17:01:09.112] result() for ClusterFuture ...
[17:01:09.112] - result already collected: FutureResult
[17:01:09.112] result() for ClusterFuture ... done
[17:01:09.112] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:09.112] - nx: 2
[17:01:09.112] - relay: TRUE
[17:01:09.113] - stdout: TRUE
[17:01:09.113] - signal: TRUE
[17:01:09.113] - resignal: FALSE
[17:01:09.113] - force: TRUE
[17:01:09.113] - relayed: [n=2] TRUE, FALSE
[17:01:09.113] - queued futures: [n=2] TRUE, FALSE
[17:01:09.113]  - until=2
[17:01:09.113]  - relaying element #2
[17:01:09.113] result() for ClusterFuture ...
[17:01:09.113] - result already collected: FutureResult
[17:01:09.113] result() for ClusterFuture ... done
[17:01:09.113] result() for ClusterFuture ...
[17:01:09.114] - result already collected: FutureResult
[17:01:09.114] result() for ClusterFuture ... done
[17:01:09.114] result() for ClusterFuture ...
[17:01:09.114] - result already collected: FutureResult
[17:01:09.114] result() for ClusterFuture ... done
[17:01:09.114] result() for ClusterFuture ...
[17:01:09.114] - result already collected: FutureResult
[17:01:09.114] result() for ClusterFuture ... done
[17:01:09.114] - relayed: [n=2] TRUE, TRUE
[17:01:09.114] - queued futures: [n=2] TRUE, TRUE
[17:01:09.114] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:09.115]  length: 0 (resolved future 2)
[17:01:09.115] Relaying remaining futures
[17:01:09.115] signalConditionsASAP(NULL, pos=0) ...
[17:01:09.115] - nx: 2
[17:01:09.115] - relay: TRUE
[17:01:09.115] - stdout: TRUE
[17:01:09.115] - signal: TRUE
[17:01:09.115] - resignal: FALSE
[17:01:09.115] - force: TRUE
[17:01:09.115] - relayed: [n=2] TRUE, TRUE
[17:01:09.115] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:09.115] - relayed: [n=2] TRUE, TRUE
[17:01:09.116] - queued futures: [n=2] TRUE, TRUE
[17:01:09.116] signalConditionsASAP(NULL, pos=0) ... done
[17:01:09.116] resolve() on list ... DONE
[17:01:09.116] result() for ClusterFuture ...
[17:01:09.116] - result already collected: FutureResult
[17:01:09.116] result() for ClusterFuture ... done
[17:01:09.116] result() for ClusterFuture ...
[17:01:09.116] - result already collected: FutureResult
[17:01:09.116] result() for ClusterFuture ... done
[17:01:09.116] result() for ClusterFuture ...
[17:01:09.116] - result already collected: FutureResult
[17:01:09.117] result() for ClusterFuture ... done
[17:01:09.117] result() for ClusterFuture ...
[17:01:09.117] - result already collected: FutureResult
[17:01:09.117] result() for ClusterFuture ... done
[17:01:09.117]  - Number of value chunks collected: 2
[17:01:09.117] Resolving 2 futures (chunks) ... DONE
[17:01:09.117] Reducing values from 2 chunks ...
[17:01:09.117]  - Number of values collected after concatenation: 7
[17:01:09.117]  - Number of values expected: 7
[17:01:09.117] Reducing values from 2 chunks ... DONE
[17:01:09.117] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:01:09.119] future_lapply() ...
[17:01:09.123] Number of chunks: 2
[17:01:09.123] getGlobalsAndPackagesXApply() ...
[17:01:09.124]  - future.globals: TRUE
[17:01:09.124] getGlobalsAndPackages() ...
[17:01:09.124] Searching for globals...
[17:01:09.125] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:01:09.125] Searching for globals ... DONE
[17:01:09.125] Resolving globals: FALSE
[17:01:09.126] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:01:09.126] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:01:09.126] - globals: [1] ‘FUN’
[17:01:09.126] 
[17:01:09.126] getGlobalsAndPackages() ... DONE
[17:01:09.126]  - globals found/used: [n=1] ‘FUN’
[17:01:09.126]  - needed namespaces: [n=0] 
[17:01:09.127] Finding globals ... DONE
[17:01:09.127]  - use_args: TRUE
[17:01:09.127]  - Getting '...' globals ...
[17:01:09.127] resolve() on list ...
[17:01:09.127]  recursive: 0
[17:01:09.127]  length: 1
[17:01:09.127]  elements: ‘...’
[17:01:09.128]  length: 0 (resolved future 1)
[17:01:09.128] resolve() on list ... DONE
[17:01:09.128]    - '...' content: [n=1] ‘y’
[17:01:09.128] List of 1
[17:01:09.128]  $ ...:List of 1
[17:01:09.128]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:09.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.128]  - attr(*, "where")=List of 1
[17:01:09.128]   ..$ ...:<environment: 0x55aadb35a8a8> 
[17:01:09.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.128]  - attr(*, "resolved")= logi TRUE
[17:01:09.128]  - attr(*, "total_size")= num NA
[17:01:09.131]  - Getting '...' globals ... DONE
[17:01:09.131] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:01:09.131] List of 2
[17:01:09.131]  $ ...future.FUN:function (x, y)  
[17:01:09.131]  $ ...          :List of 1
[17:01:09.131]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:09.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.131]  - attr(*, "where")=List of 2
[17:01:09.131]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:09.131]   ..$ ...          :<environment: 0x55aadb35a8a8> 
[17:01:09.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.131]  - attr(*, "resolved")= logi FALSE
[17:01:09.131]  - attr(*, "total_size")= num 4264
[17:01:09.134] Packages to be attached in all futures: [n=0] 
[17:01:09.134] getGlobalsAndPackagesXApply() ... DONE
[17:01:09.134] Number of futures (= number of chunks): 2
[17:01:09.134] Launching 2 futures (chunks) ...
[17:01:09.135] Chunk #1 of 2 ...
[17:01:09.135]  - Finding globals in 'X' for chunk #1 ...
[17:01:09.135] getGlobalsAndPackages() ...
[17:01:09.135] Searching for globals...
[17:01:09.135] 
[17:01:09.135] Searching for globals ... DONE
[17:01:09.135] - globals: [0] <none>
[17:01:09.136] getGlobalsAndPackages() ... DONE
[17:01:09.136]    + additional globals found: [n=0] 
[17:01:09.136]    + additional namespaces needed: [n=0] 
[17:01:09.136]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:09.136]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.136]  - seeds: <none>
[17:01:09.136]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.136] getGlobalsAndPackages() ...
[17:01:09.136] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.136] Resolving globals: FALSE
[17:01:09.137] Tweak future expression to call with '...' arguments ...
[17:01:09.137] {
[17:01:09.137]     do.call(function(...) {
[17:01:09.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.137]             on.exit(options(oopts), add = TRUE)
[17:01:09.137]         }
[17:01:09.137]         {
[17:01:09.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.137]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.137]             })
[17:01:09.137]         }
[17:01:09.137]     }, args = future.call.arguments)
[17:01:09.137] }
[17:01:09.137] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.137] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.137] 
[17:01:09.137] getGlobalsAndPackages() ... DONE
[17:01:09.138] run() for ‘Future’ ...
[17:01:09.138] - state: ‘created’
[17:01:09.138] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.153] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.154]   - Field: ‘node’
[17:01:09.154]   - Field: ‘label’
[17:01:09.154]   - Field: ‘local’
[17:01:09.154]   - Field: ‘owner’
[17:01:09.154]   - Field: ‘envir’
[17:01:09.154]   - Field: ‘workers’
[17:01:09.154]   - Field: ‘packages’
[17:01:09.154]   - Field: ‘gc’
[17:01:09.154]   - Field: ‘conditions’
[17:01:09.155]   - Field: ‘persistent’
[17:01:09.155]   - Field: ‘expr’
[17:01:09.155]   - Field: ‘uuid’
[17:01:09.155]   - Field: ‘seed’
[17:01:09.155]   - Field: ‘version’
[17:01:09.155]   - Field: ‘result’
[17:01:09.155]   - Field: ‘asynchronous’
[17:01:09.155]   - Field: ‘calls’
[17:01:09.155]   - Field: ‘globals’
[17:01:09.155]   - Field: ‘stdout’
[17:01:09.156]   - Field: ‘earlySignal’
[17:01:09.156]   - Field: ‘lazy’
[17:01:09.156]   - Field: ‘state’
[17:01:09.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.156] - Launch lazy future ...
[17:01:09.156] Packages needed by the future expression (n = 0): <none>
[17:01:09.156] Packages needed by future strategies (n = 0): <none>
[17:01:09.157] {
[17:01:09.157]     {
[17:01:09.157]         {
[17:01:09.157]             ...future.startTime <- base::Sys.time()
[17:01:09.157]             {
[17:01:09.157]                 {
[17:01:09.157]                   {
[17:01:09.157]                     {
[17:01:09.157]                       base::local({
[17:01:09.157]                         has_future <- base::requireNamespace("future", 
[17:01:09.157]                           quietly = TRUE)
[17:01:09.157]                         if (has_future) {
[17:01:09.157]                           ns <- base::getNamespace("future")
[17:01:09.157]                           version <- ns[[".package"]][["version"]]
[17:01:09.157]                           if (is.null(version)) 
[17:01:09.157]                             version <- utils::packageVersion("future")
[17:01:09.157]                         }
[17:01:09.157]                         else {
[17:01:09.157]                           version <- NULL
[17:01:09.157]                         }
[17:01:09.157]                         if (!has_future || version < "1.8.0") {
[17:01:09.157]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.157]                             "", base::R.version$version.string), 
[17:01:09.157]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:09.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:09.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.157]                               "release", "version")], collapse = " "), 
[17:01:09.157]                             hostname = base::Sys.info()[["nodename"]])
[17:01:09.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.157]                             info)
[17:01:09.157]                           info <- base::paste(info, collapse = "; ")
[17:01:09.157]                           if (!has_future) {
[17:01:09.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.157]                               info)
[17:01:09.157]                           }
[17:01:09.157]                           else {
[17:01:09.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.157]                               info, version)
[17:01:09.157]                           }
[17:01:09.157]                           base::stop(msg)
[17:01:09.157]                         }
[17:01:09.157]                       })
[17:01:09.157]                     }
[17:01:09.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.157]                     base::options(mc.cores = 1L)
[17:01:09.157]                   }
[17:01:09.157]                   ...future.strategy.old <- future::plan("list")
[17:01:09.157]                   options(future.plan = NULL)
[17:01:09.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.157]                 }
[17:01:09.157]                 ...future.workdir <- getwd()
[17:01:09.157]             }
[17:01:09.157]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.157]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.157]         }
[17:01:09.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.157]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.157]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.157]             base::names(...future.oldOptions))
[17:01:09.157]     }
[17:01:09.157]     if (FALSE) {
[17:01:09.157]     }
[17:01:09.157]     else {
[17:01:09.157]         if (TRUE) {
[17:01:09.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.157]                 open = "w")
[17:01:09.157]         }
[17:01:09.157]         else {
[17:01:09.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.157]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.157]         }
[17:01:09.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.157]             base::sink(type = "output", split = FALSE)
[17:01:09.157]             base::close(...future.stdout)
[17:01:09.157]         }, add = TRUE)
[17:01:09.157]     }
[17:01:09.157]     ...future.frame <- base::sys.nframe()
[17:01:09.157]     ...future.conditions <- base::list()
[17:01:09.157]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.157]     if (FALSE) {
[17:01:09.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.157]     }
[17:01:09.157]     ...future.result <- base::tryCatch({
[17:01:09.157]         base::withCallingHandlers({
[17:01:09.157]             ...future.value <- base::withVisible(base::local({
[17:01:09.157]                 ...future.makeSendCondition <- base::local({
[17:01:09.157]                   sendCondition <- NULL
[17:01:09.157]                   function(frame = 1L) {
[17:01:09.157]                     if (is.function(sendCondition)) 
[17:01:09.157]                       return(sendCondition)
[17:01:09.157]                     ns <- getNamespace("parallel")
[17:01:09.157]                     if (exists("sendData", mode = "function", 
[17:01:09.157]                       envir = ns)) {
[17:01:09.157]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.157]                         envir = ns)
[17:01:09.157]                       envir <- sys.frame(frame)
[17:01:09.157]                       master <- NULL
[17:01:09.157]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.157]                         !identical(envir, emptyenv())) {
[17:01:09.157]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.157]                           inherits = FALSE)) {
[17:01:09.157]                           master <- get("master", mode = "list", 
[17:01:09.157]                             envir = envir, inherits = FALSE)
[17:01:09.157]                           if (inherits(master, c("SOCKnode", 
[17:01:09.157]                             "SOCK0node"))) {
[17:01:09.157]                             sendCondition <<- function(cond) {
[17:01:09.157]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.157]                                 success = TRUE)
[17:01:09.157]                               parallel_sendData(master, data)
[17:01:09.157]                             }
[17:01:09.157]                             return(sendCondition)
[17:01:09.157]                           }
[17:01:09.157]                         }
[17:01:09.157]                         frame <- frame + 1L
[17:01:09.157]                         envir <- sys.frame(frame)
[17:01:09.157]                       }
[17:01:09.157]                     }
[17:01:09.157]                     sendCondition <<- function(cond) NULL
[17:01:09.157]                   }
[17:01:09.157]                 })
[17:01:09.157]                 withCallingHandlers({
[17:01:09.157]                   {
[17:01:09.157]                     do.call(function(...) {
[17:01:09.157]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.157]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.157]                         ...future.globals.maxSize)) {
[17:01:09.157]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.157]                         on.exit(options(oopts), add = TRUE)
[17:01:09.157]                       }
[17:01:09.157]                       {
[17:01:09.157]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.157]                           FUN = function(jj) {
[17:01:09.157]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.157]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.157]                           })
[17:01:09.157]                       }
[17:01:09.157]                     }, args = future.call.arguments)
[17:01:09.157]                   }
[17:01:09.157]                 }, immediateCondition = function(cond) {
[17:01:09.157]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.157]                   sendCondition(cond)
[17:01:09.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.157]                   {
[17:01:09.157]                     inherits <- base::inherits
[17:01:09.157]                     invokeRestart <- base::invokeRestart
[17:01:09.157]                     is.null <- base::is.null
[17:01:09.157]                     muffled <- FALSE
[17:01:09.157]                     if (inherits(cond, "message")) {
[17:01:09.157]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.157]                       if (muffled) 
[17:01:09.157]                         invokeRestart("muffleMessage")
[17:01:09.157]                     }
[17:01:09.157]                     else if (inherits(cond, "warning")) {
[17:01:09.157]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.157]                       if (muffled) 
[17:01:09.157]                         invokeRestart("muffleWarning")
[17:01:09.157]                     }
[17:01:09.157]                     else if (inherits(cond, "condition")) {
[17:01:09.157]                       if (!is.null(pattern)) {
[17:01:09.157]                         computeRestarts <- base::computeRestarts
[17:01:09.157]                         grepl <- base::grepl
[17:01:09.157]                         restarts <- computeRestarts(cond)
[17:01:09.157]                         for (restart in restarts) {
[17:01:09.157]                           name <- restart$name
[17:01:09.157]                           if (is.null(name)) 
[17:01:09.157]                             next
[17:01:09.157]                           if (!grepl(pattern, name)) 
[17:01:09.157]                             next
[17:01:09.157]                           invokeRestart(restart)
[17:01:09.157]                           muffled <- TRUE
[17:01:09.157]                           break
[17:01:09.157]                         }
[17:01:09.157]                       }
[17:01:09.157]                     }
[17:01:09.157]                     invisible(muffled)
[17:01:09.157]                   }
[17:01:09.157]                   muffleCondition(cond)
[17:01:09.157]                 })
[17:01:09.157]             }))
[17:01:09.157]             future::FutureResult(value = ...future.value$value, 
[17:01:09.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.157]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.157]                     ...future.globalenv.names))
[17:01:09.157]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.157]         }, condition = base::local({
[17:01:09.157]             c <- base::c
[17:01:09.157]             inherits <- base::inherits
[17:01:09.157]             invokeRestart <- base::invokeRestart
[17:01:09.157]             length <- base::length
[17:01:09.157]             list <- base::list
[17:01:09.157]             seq.int <- base::seq.int
[17:01:09.157]             signalCondition <- base::signalCondition
[17:01:09.157]             sys.calls <- base::sys.calls
[17:01:09.157]             `[[` <- base::`[[`
[17:01:09.157]             `+` <- base::`+`
[17:01:09.157]             `<<-` <- base::`<<-`
[17:01:09.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.157]                   3L)]
[17:01:09.157]             }
[17:01:09.157]             function(cond) {
[17:01:09.157]                 is_error <- inherits(cond, "error")
[17:01:09.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.157]                   NULL)
[17:01:09.157]                 if (is_error) {
[17:01:09.157]                   sessionInformation <- function() {
[17:01:09.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.157]                       search = base::search(), system = base::Sys.info())
[17:01:09.157]                   }
[17:01:09.157]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.157]                     cond$call), session = sessionInformation(), 
[17:01:09.157]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.157]                   signalCondition(cond)
[17:01:09.157]                 }
[17:01:09.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.157]                 "immediateCondition"))) {
[17:01:09.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.157]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.157]                   if (TRUE && !signal) {
[17:01:09.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.157]                     {
[17:01:09.157]                       inherits <- base::inherits
[17:01:09.157]                       invokeRestart <- base::invokeRestart
[17:01:09.157]                       is.null <- base::is.null
[17:01:09.157]                       muffled <- FALSE
[17:01:09.157]                       if (inherits(cond, "message")) {
[17:01:09.157]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.157]                         if (muffled) 
[17:01:09.157]                           invokeRestart("muffleMessage")
[17:01:09.157]                       }
[17:01:09.157]                       else if (inherits(cond, "warning")) {
[17:01:09.157]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.157]                         if (muffled) 
[17:01:09.157]                           invokeRestart("muffleWarning")
[17:01:09.157]                       }
[17:01:09.157]                       else if (inherits(cond, "condition")) {
[17:01:09.157]                         if (!is.null(pattern)) {
[17:01:09.157]                           computeRestarts <- base::computeRestarts
[17:01:09.157]                           grepl <- base::grepl
[17:01:09.157]                           restarts <- computeRestarts(cond)
[17:01:09.157]                           for (restart in restarts) {
[17:01:09.157]                             name <- restart$name
[17:01:09.157]                             if (is.null(name)) 
[17:01:09.157]                               next
[17:01:09.157]                             if (!grepl(pattern, name)) 
[17:01:09.157]                               next
[17:01:09.157]                             invokeRestart(restart)
[17:01:09.157]                             muffled <- TRUE
[17:01:09.157]                             break
[17:01:09.157]                           }
[17:01:09.157]                         }
[17:01:09.157]                       }
[17:01:09.157]                       invisible(muffled)
[17:01:09.157]                     }
[17:01:09.157]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.157]                   }
[17:01:09.157]                 }
[17:01:09.157]                 else {
[17:01:09.157]                   if (TRUE) {
[17:01:09.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.157]                     {
[17:01:09.157]                       inherits <- base::inherits
[17:01:09.157]                       invokeRestart <- base::invokeRestart
[17:01:09.157]                       is.null <- base::is.null
[17:01:09.157]                       muffled <- FALSE
[17:01:09.157]                       if (inherits(cond, "message")) {
[17:01:09.157]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.157]                         if (muffled) 
[17:01:09.157]                           invokeRestart("muffleMessage")
[17:01:09.157]                       }
[17:01:09.157]                       else if (inherits(cond, "warning")) {
[17:01:09.157]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.157]                         if (muffled) 
[17:01:09.157]                           invokeRestart("muffleWarning")
[17:01:09.157]                       }
[17:01:09.157]                       else if (inherits(cond, "condition")) {
[17:01:09.157]                         if (!is.null(pattern)) {
[17:01:09.157]                           computeRestarts <- base::computeRestarts
[17:01:09.157]                           grepl <- base::grepl
[17:01:09.157]                           restarts <- computeRestarts(cond)
[17:01:09.157]                           for (restart in restarts) {
[17:01:09.157]                             name <- restart$name
[17:01:09.157]                             if (is.null(name)) 
[17:01:09.157]                               next
[17:01:09.157]                             if (!grepl(pattern, name)) 
[17:01:09.157]                               next
[17:01:09.157]                             invokeRestart(restart)
[17:01:09.157]                             muffled <- TRUE
[17:01:09.157]                             break
[17:01:09.157]                           }
[17:01:09.157]                         }
[17:01:09.157]                       }
[17:01:09.157]                       invisible(muffled)
[17:01:09.157]                     }
[17:01:09.157]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.157]                   }
[17:01:09.157]                 }
[17:01:09.157]             }
[17:01:09.157]         }))
[17:01:09.157]     }, error = function(ex) {
[17:01:09.157]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.157]                 ...future.rng), started = ...future.startTime, 
[17:01:09.157]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.157]             version = "1.8"), class = "FutureResult")
[17:01:09.157]     }, finally = {
[17:01:09.157]         if (!identical(...future.workdir, getwd())) 
[17:01:09.157]             setwd(...future.workdir)
[17:01:09.157]         {
[17:01:09.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.157]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.157]             }
[17:01:09.157]             base::options(...future.oldOptions)
[17:01:09.157]             if (.Platform$OS.type == "windows") {
[17:01:09.157]                 old_names <- names(...future.oldEnvVars)
[17:01:09.157]                 envs <- base::Sys.getenv()
[17:01:09.157]                 names <- names(envs)
[17:01:09.157]                 common <- intersect(names, old_names)
[17:01:09.157]                 added <- setdiff(names, old_names)
[17:01:09.157]                 removed <- setdiff(old_names, names)
[17:01:09.157]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.157]                   envs[common]]
[17:01:09.157]                 NAMES <- toupper(changed)
[17:01:09.157]                 args <- list()
[17:01:09.157]                 for (kk in seq_along(NAMES)) {
[17:01:09.157]                   name <- changed[[kk]]
[17:01:09.157]                   NAME <- NAMES[[kk]]
[17:01:09.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.157]                     next
[17:01:09.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.157]                 }
[17:01:09.157]                 NAMES <- toupper(added)
[17:01:09.157]                 for (kk in seq_along(NAMES)) {
[17:01:09.157]                   name <- added[[kk]]
[17:01:09.157]                   NAME <- NAMES[[kk]]
[17:01:09.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.157]                     next
[17:01:09.157]                   args[[name]] <- ""
[17:01:09.157]                 }
[17:01:09.157]                 NAMES <- toupper(removed)
[17:01:09.157]                 for (kk in seq_along(NAMES)) {
[17:01:09.157]                   name <- removed[[kk]]
[17:01:09.157]                   NAME <- NAMES[[kk]]
[17:01:09.157]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.157]                     next
[17:01:09.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.157]                 }
[17:01:09.157]                 if (length(args) > 0) 
[17:01:09.157]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.157]             }
[17:01:09.157]             else {
[17:01:09.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.157]             }
[17:01:09.157]             {
[17:01:09.157]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.157]                   0L) {
[17:01:09.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.157]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.157]                   base::options(opts)
[17:01:09.157]                 }
[17:01:09.157]                 {
[17:01:09.157]                   {
[17:01:09.157]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.157]                     NULL
[17:01:09.157]                   }
[17:01:09.157]                   options(future.plan = NULL)
[17:01:09.157]                   if (is.na(NA_character_)) 
[17:01:09.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.157]                     .init = FALSE)
[17:01:09.157]                 }
[17:01:09.157]             }
[17:01:09.157]         }
[17:01:09.157]     })
[17:01:09.157]     if (TRUE) {
[17:01:09.157]         base::sink(type = "output", split = FALSE)
[17:01:09.157]         if (TRUE) {
[17:01:09.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.157]         }
[17:01:09.157]         else {
[17:01:09.157]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.157]         }
[17:01:09.157]         base::close(...future.stdout)
[17:01:09.157]         ...future.stdout <- NULL
[17:01:09.157]     }
[17:01:09.157]     ...future.result$conditions <- ...future.conditions
[17:01:09.157]     ...future.result$finished <- base::Sys.time()
[17:01:09.157]     ...future.result
[17:01:09.157] }
[17:01:09.160] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[17:01:09.160] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[17:01:09.160] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:01:09.160] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:01:09.161] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:01:09.161] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:09.161] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:09.162] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:09.162] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.162] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:09.162] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.163] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[17:01:09.163] MultisessionFuture started
[17:01:09.163] - Launch lazy future ... done
[17:01:09.163] run() for ‘MultisessionFuture’ ... done
[17:01:09.164] Created future:
[17:01:09.164] MultisessionFuture:
[17:01:09.164] Label: ‘future_sapply-1’
[17:01:09.164] Expression:
[17:01:09.164] {
[17:01:09.164]     do.call(function(...) {
[17:01:09.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.164]             on.exit(options(oopts), add = TRUE)
[17:01:09.164]         }
[17:01:09.164]         {
[17:01:09.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.164]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.164]             })
[17:01:09.164]         }
[17:01:09.164]     }, args = future.call.arguments)
[17:01:09.164] }
[17:01:09.164] Lazy evaluation: FALSE
[17:01:09.164] Asynchronous evaluation: TRUE
[17:01:09.164] Local evaluation: TRUE
[17:01:09.164] Environment: R_GlobalEnv
[17:01:09.164] Capture standard output: TRUE
[17:01:09.164] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.164] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:09.164] Packages: <none>
[17:01:09.164] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.164] Resolved: FALSE
[17:01:09.164] Value: <not collected>
[17:01:09.164] Conditions captured: <none>
[17:01:09.164] Early signaling: FALSE
[17:01:09.164] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.164] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.175] Chunk #1 of 2 ... DONE
[17:01:09.176] Chunk #2 of 2 ...
[17:01:09.176]  - Finding globals in 'X' for chunk #2 ...
[17:01:09.176] getGlobalsAndPackages() ...
[17:01:09.176] Searching for globals...
[17:01:09.176] 
[17:01:09.176] Searching for globals ... DONE
[17:01:09.176] - globals: [0] <none>
[17:01:09.177] getGlobalsAndPackages() ... DONE
[17:01:09.177]    + additional globals found: [n=0] 
[17:01:09.177]    + additional namespaces needed: [n=0] 
[17:01:09.177]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:09.177]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.177]  - seeds: <none>
[17:01:09.177]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.177] getGlobalsAndPackages() ...
[17:01:09.177] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.177] Resolving globals: FALSE
[17:01:09.178] Tweak future expression to call with '...' arguments ...
[17:01:09.178] {
[17:01:09.178]     do.call(function(...) {
[17:01:09.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.178]             on.exit(options(oopts), add = TRUE)
[17:01:09.178]         }
[17:01:09.178]         {
[17:01:09.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.178]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.178]             })
[17:01:09.178]         }
[17:01:09.178]     }, args = future.call.arguments)
[17:01:09.178] }
[17:01:09.178] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.178] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.178] 
[17:01:09.178] getGlobalsAndPackages() ... DONE
[17:01:09.179] run() for ‘Future’ ...
[17:01:09.179] - state: ‘created’
[17:01:09.179] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.193] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.193]   - Field: ‘node’
[17:01:09.193]   - Field: ‘label’
[17:01:09.194]   - Field: ‘local’
[17:01:09.194]   - Field: ‘owner’
[17:01:09.194]   - Field: ‘envir’
[17:01:09.194]   - Field: ‘workers’
[17:01:09.194]   - Field: ‘packages’
[17:01:09.194]   - Field: ‘gc’
[17:01:09.194]   - Field: ‘conditions’
[17:01:09.194]   - Field: ‘persistent’
[17:01:09.194]   - Field: ‘expr’
[17:01:09.194]   - Field: ‘uuid’
[17:01:09.194]   - Field: ‘seed’
[17:01:09.195]   - Field: ‘version’
[17:01:09.195]   - Field: ‘result’
[17:01:09.195]   - Field: ‘asynchronous’
[17:01:09.195]   - Field: ‘calls’
[17:01:09.195]   - Field: ‘globals’
[17:01:09.195]   - Field: ‘stdout’
[17:01:09.195]   - Field: ‘earlySignal’
[17:01:09.195]   - Field: ‘lazy’
[17:01:09.195]   - Field: ‘state’
[17:01:09.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.195] - Launch lazy future ...
[17:01:09.196] Packages needed by the future expression (n = 0): <none>
[17:01:09.196] Packages needed by future strategies (n = 0): <none>
[17:01:09.196] {
[17:01:09.196]     {
[17:01:09.196]         {
[17:01:09.196]             ...future.startTime <- base::Sys.time()
[17:01:09.196]             {
[17:01:09.196]                 {
[17:01:09.196]                   {
[17:01:09.196]                     {
[17:01:09.196]                       base::local({
[17:01:09.196]                         has_future <- base::requireNamespace("future", 
[17:01:09.196]                           quietly = TRUE)
[17:01:09.196]                         if (has_future) {
[17:01:09.196]                           ns <- base::getNamespace("future")
[17:01:09.196]                           version <- ns[[".package"]][["version"]]
[17:01:09.196]                           if (is.null(version)) 
[17:01:09.196]                             version <- utils::packageVersion("future")
[17:01:09.196]                         }
[17:01:09.196]                         else {
[17:01:09.196]                           version <- NULL
[17:01:09.196]                         }
[17:01:09.196]                         if (!has_future || version < "1.8.0") {
[17:01:09.196]                           info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.196]                             "", base::R.version$version.string), 
[17:01:09.196]                             platform = base::sprintf("%s (%s-bit)", 
[17:01:09.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:01:09.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.196]                               "release", "version")], collapse = " "), 
[17:01:09.196]                             hostname = base::Sys.info()[["nodename"]])
[17:01:09.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.196]                             info)
[17:01:09.196]                           info <- base::paste(info, collapse = "; ")
[17:01:09.196]                           if (!has_future) {
[17:01:09.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.196]                               info)
[17:01:09.196]                           }
[17:01:09.196]                           else {
[17:01:09.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.196]                               info, version)
[17:01:09.196]                           }
[17:01:09.196]                           base::stop(msg)
[17:01:09.196]                         }
[17:01:09.196]                       })
[17:01:09.196]                     }
[17:01:09.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.196]                     base::options(mc.cores = 1L)
[17:01:09.196]                   }
[17:01:09.196]                   ...future.strategy.old <- future::plan("list")
[17:01:09.196]                   options(future.plan = NULL)
[17:01:09.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.196]                 }
[17:01:09.196]                 ...future.workdir <- getwd()
[17:01:09.196]             }
[17:01:09.196]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.196]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.196]         }
[17:01:09.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.196]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.196]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.196]             base::names(...future.oldOptions))
[17:01:09.196]     }
[17:01:09.196]     if (FALSE) {
[17:01:09.196]     }
[17:01:09.196]     else {
[17:01:09.196]         if (TRUE) {
[17:01:09.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.196]                 open = "w")
[17:01:09.196]         }
[17:01:09.196]         else {
[17:01:09.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.196]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.196]         }
[17:01:09.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.196]             base::sink(type = "output", split = FALSE)
[17:01:09.196]             base::close(...future.stdout)
[17:01:09.196]         }, add = TRUE)
[17:01:09.196]     }
[17:01:09.196]     ...future.frame <- base::sys.nframe()
[17:01:09.196]     ...future.conditions <- base::list()
[17:01:09.196]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.196]     if (FALSE) {
[17:01:09.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.196]     }
[17:01:09.196]     ...future.result <- base::tryCatch({
[17:01:09.196]         base::withCallingHandlers({
[17:01:09.196]             ...future.value <- base::withVisible(base::local({
[17:01:09.196]                 ...future.makeSendCondition <- base::local({
[17:01:09.196]                   sendCondition <- NULL
[17:01:09.196]                   function(frame = 1L) {
[17:01:09.196]                     if (is.function(sendCondition)) 
[17:01:09.196]                       return(sendCondition)
[17:01:09.196]                     ns <- getNamespace("parallel")
[17:01:09.196]                     if (exists("sendData", mode = "function", 
[17:01:09.196]                       envir = ns)) {
[17:01:09.196]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.196]                         envir = ns)
[17:01:09.196]                       envir <- sys.frame(frame)
[17:01:09.196]                       master <- NULL
[17:01:09.196]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.196]                         !identical(envir, emptyenv())) {
[17:01:09.196]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.196]                           inherits = FALSE)) {
[17:01:09.196]                           master <- get("master", mode = "list", 
[17:01:09.196]                             envir = envir, inherits = FALSE)
[17:01:09.196]                           if (inherits(master, c("SOCKnode", 
[17:01:09.196]                             "SOCK0node"))) {
[17:01:09.196]                             sendCondition <<- function(cond) {
[17:01:09.196]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.196]                                 success = TRUE)
[17:01:09.196]                               parallel_sendData(master, data)
[17:01:09.196]                             }
[17:01:09.196]                             return(sendCondition)
[17:01:09.196]                           }
[17:01:09.196]                         }
[17:01:09.196]                         frame <- frame + 1L
[17:01:09.196]                         envir <- sys.frame(frame)
[17:01:09.196]                       }
[17:01:09.196]                     }
[17:01:09.196]                     sendCondition <<- function(cond) NULL
[17:01:09.196]                   }
[17:01:09.196]                 })
[17:01:09.196]                 withCallingHandlers({
[17:01:09.196]                   {
[17:01:09.196]                     do.call(function(...) {
[17:01:09.196]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.196]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.196]                         ...future.globals.maxSize)) {
[17:01:09.196]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.196]                         on.exit(options(oopts), add = TRUE)
[17:01:09.196]                       }
[17:01:09.196]                       {
[17:01:09.196]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.196]                           FUN = function(jj) {
[17:01:09.196]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.196]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.196]                           })
[17:01:09.196]                       }
[17:01:09.196]                     }, args = future.call.arguments)
[17:01:09.196]                   }
[17:01:09.196]                 }, immediateCondition = function(cond) {
[17:01:09.196]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.196]                   sendCondition(cond)
[17:01:09.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.196]                   {
[17:01:09.196]                     inherits <- base::inherits
[17:01:09.196]                     invokeRestart <- base::invokeRestart
[17:01:09.196]                     is.null <- base::is.null
[17:01:09.196]                     muffled <- FALSE
[17:01:09.196]                     if (inherits(cond, "message")) {
[17:01:09.196]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.196]                       if (muffled) 
[17:01:09.196]                         invokeRestart("muffleMessage")
[17:01:09.196]                     }
[17:01:09.196]                     else if (inherits(cond, "warning")) {
[17:01:09.196]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.196]                       if (muffled) 
[17:01:09.196]                         invokeRestart("muffleWarning")
[17:01:09.196]                     }
[17:01:09.196]                     else if (inherits(cond, "condition")) {
[17:01:09.196]                       if (!is.null(pattern)) {
[17:01:09.196]                         computeRestarts <- base::computeRestarts
[17:01:09.196]                         grepl <- base::grepl
[17:01:09.196]                         restarts <- computeRestarts(cond)
[17:01:09.196]                         for (restart in restarts) {
[17:01:09.196]                           name <- restart$name
[17:01:09.196]                           if (is.null(name)) 
[17:01:09.196]                             next
[17:01:09.196]                           if (!grepl(pattern, name)) 
[17:01:09.196]                             next
[17:01:09.196]                           invokeRestart(restart)
[17:01:09.196]                           muffled <- TRUE
[17:01:09.196]                           break
[17:01:09.196]                         }
[17:01:09.196]                       }
[17:01:09.196]                     }
[17:01:09.196]                     invisible(muffled)
[17:01:09.196]                   }
[17:01:09.196]                   muffleCondition(cond)
[17:01:09.196]                 })
[17:01:09.196]             }))
[17:01:09.196]             future::FutureResult(value = ...future.value$value, 
[17:01:09.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.196]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.196]                     ...future.globalenv.names))
[17:01:09.196]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.196]         }, condition = base::local({
[17:01:09.196]             c <- base::c
[17:01:09.196]             inherits <- base::inherits
[17:01:09.196]             invokeRestart <- base::invokeRestart
[17:01:09.196]             length <- base::length
[17:01:09.196]             list <- base::list
[17:01:09.196]             seq.int <- base::seq.int
[17:01:09.196]             signalCondition <- base::signalCondition
[17:01:09.196]             sys.calls <- base::sys.calls
[17:01:09.196]             `[[` <- base::`[[`
[17:01:09.196]             `+` <- base::`+`
[17:01:09.196]             `<<-` <- base::`<<-`
[17:01:09.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.196]                   3L)]
[17:01:09.196]             }
[17:01:09.196]             function(cond) {
[17:01:09.196]                 is_error <- inherits(cond, "error")
[17:01:09.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.196]                   NULL)
[17:01:09.196]                 if (is_error) {
[17:01:09.196]                   sessionInformation <- function() {
[17:01:09.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.196]                       search = base::search(), system = base::Sys.info())
[17:01:09.196]                   }
[17:01:09.196]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.196]                     cond$call), session = sessionInformation(), 
[17:01:09.196]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.196]                   signalCondition(cond)
[17:01:09.196]                 }
[17:01:09.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.196]                 "immediateCondition"))) {
[17:01:09.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.196]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.196]                   if (TRUE && !signal) {
[17:01:09.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.196]                     {
[17:01:09.196]                       inherits <- base::inherits
[17:01:09.196]                       invokeRestart <- base::invokeRestart
[17:01:09.196]                       is.null <- base::is.null
[17:01:09.196]                       muffled <- FALSE
[17:01:09.196]                       if (inherits(cond, "message")) {
[17:01:09.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.196]                         if (muffled) 
[17:01:09.196]                           invokeRestart("muffleMessage")
[17:01:09.196]                       }
[17:01:09.196]                       else if (inherits(cond, "warning")) {
[17:01:09.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.196]                         if (muffled) 
[17:01:09.196]                           invokeRestart("muffleWarning")
[17:01:09.196]                       }
[17:01:09.196]                       else if (inherits(cond, "condition")) {
[17:01:09.196]                         if (!is.null(pattern)) {
[17:01:09.196]                           computeRestarts <- base::computeRestarts
[17:01:09.196]                           grepl <- base::grepl
[17:01:09.196]                           restarts <- computeRestarts(cond)
[17:01:09.196]                           for (restart in restarts) {
[17:01:09.196]                             name <- restart$name
[17:01:09.196]                             if (is.null(name)) 
[17:01:09.196]                               next
[17:01:09.196]                             if (!grepl(pattern, name)) 
[17:01:09.196]                               next
[17:01:09.196]                             invokeRestart(restart)
[17:01:09.196]                             muffled <- TRUE
[17:01:09.196]                             break
[17:01:09.196]                           }
[17:01:09.196]                         }
[17:01:09.196]                       }
[17:01:09.196]                       invisible(muffled)
[17:01:09.196]                     }
[17:01:09.196]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.196]                   }
[17:01:09.196]                 }
[17:01:09.196]                 else {
[17:01:09.196]                   if (TRUE) {
[17:01:09.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.196]                     {
[17:01:09.196]                       inherits <- base::inherits
[17:01:09.196]                       invokeRestart <- base::invokeRestart
[17:01:09.196]                       is.null <- base::is.null
[17:01:09.196]                       muffled <- FALSE
[17:01:09.196]                       if (inherits(cond, "message")) {
[17:01:09.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.196]                         if (muffled) 
[17:01:09.196]                           invokeRestart("muffleMessage")
[17:01:09.196]                       }
[17:01:09.196]                       else if (inherits(cond, "warning")) {
[17:01:09.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.196]                         if (muffled) 
[17:01:09.196]                           invokeRestart("muffleWarning")
[17:01:09.196]                       }
[17:01:09.196]                       else if (inherits(cond, "condition")) {
[17:01:09.196]                         if (!is.null(pattern)) {
[17:01:09.196]                           computeRestarts <- base::computeRestarts
[17:01:09.196]                           grepl <- base::grepl
[17:01:09.196]                           restarts <- computeRestarts(cond)
[17:01:09.196]                           for (restart in restarts) {
[17:01:09.196]                             name <- restart$name
[17:01:09.196]                             if (is.null(name)) 
[17:01:09.196]                               next
[17:01:09.196]                             if (!grepl(pattern, name)) 
[17:01:09.196]                               next
[17:01:09.196]                             invokeRestart(restart)
[17:01:09.196]                             muffled <- TRUE
[17:01:09.196]                             break
[17:01:09.196]                           }
[17:01:09.196]                         }
[17:01:09.196]                       }
[17:01:09.196]                       invisible(muffled)
[17:01:09.196]                     }
[17:01:09.196]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.196]                   }
[17:01:09.196]                 }
[17:01:09.196]             }
[17:01:09.196]         }))
[17:01:09.196]     }, error = function(ex) {
[17:01:09.196]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.196]                 ...future.rng), started = ...future.startTime, 
[17:01:09.196]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.196]             version = "1.8"), class = "FutureResult")
[17:01:09.196]     }, finally = {
[17:01:09.196]         if (!identical(...future.workdir, getwd())) 
[17:01:09.196]             setwd(...future.workdir)
[17:01:09.196]         {
[17:01:09.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.196]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.196]             }
[17:01:09.196]             base::options(...future.oldOptions)
[17:01:09.196]             if (.Platform$OS.type == "windows") {
[17:01:09.196]                 old_names <- names(...future.oldEnvVars)
[17:01:09.196]                 envs <- base::Sys.getenv()
[17:01:09.196]                 names <- names(envs)
[17:01:09.196]                 common <- intersect(names, old_names)
[17:01:09.196]                 added <- setdiff(names, old_names)
[17:01:09.196]                 removed <- setdiff(old_names, names)
[17:01:09.196]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.196]                   envs[common]]
[17:01:09.196]                 NAMES <- toupper(changed)
[17:01:09.196]                 args <- list()
[17:01:09.196]                 for (kk in seq_along(NAMES)) {
[17:01:09.196]                   name <- changed[[kk]]
[17:01:09.196]                   NAME <- NAMES[[kk]]
[17:01:09.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.196]                     next
[17:01:09.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.196]                 }
[17:01:09.196]                 NAMES <- toupper(added)
[17:01:09.196]                 for (kk in seq_along(NAMES)) {
[17:01:09.196]                   name <- added[[kk]]
[17:01:09.196]                   NAME <- NAMES[[kk]]
[17:01:09.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.196]                     next
[17:01:09.196]                   args[[name]] <- ""
[17:01:09.196]                 }
[17:01:09.196]                 NAMES <- toupper(removed)
[17:01:09.196]                 for (kk in seq_along(NAMES)) {
[17:01:09.196]                   name <- removed[[kk]]
[17:01:09.196]                   NAME <- NAMES[[kk]]
[17:01:09.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.196]                     next
[17:01:09.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.196]                 }
[17:01:09.196]                 if (length(args) > 0) 
[17:01:09.196]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.196]             }
[17:01:09.196]             else {
[17:01:09.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.196]             }
[17:01:09.196]             {
[17:01:09.196]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.196]                   0L) {
[17:01:09.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.196]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.196]                   base::options(opts)
[17:01:09.196]                 }
[17:01:09.196]                 {
[17:01:09.196]                   {
[17:01:09.196]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.196]                     NULL
[17:01:09.196]                   }
[17:01:09.196]                   options(future.plan = NULL)
[17:01:09.196]                   if (is.na(NA_character_)) 
[17:01:09.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.196]                     .init = FALSE)
[17:01:09.196]                 }
[17:01:09.196]             }
[17:01:09.196]         }
[17:01:09.196]     })
[17:01:09.196]     if (TRUE) {
[17:01:09.196]         base::sink(type = "output", split = FALSE)
[17:01:09.196]         if (TRUE) {
[17:01:09.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.196]         }
[17:01:09.196]         else {
[17:01:09.196]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.196]         }
[17:01:09.196]         base::close(...future.stdout)
[17:01:09.196]         ...future.stdout <- NULL
[17:01:09.196]     }
[17:01:09.196]     ...future.result$conditions <- ...future.conditions
[17:01:09.196]     ...future.result$finished <- base::Sys.time()
[17:01:09.196]     ...future.result
[17:01:09.196] }
[17:01:09.199] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[17:01:09.199] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[17:01:09.200] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:01:09.200] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:01:09.200] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:01:09.200] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:09.201] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:09.201] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:09.201] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:09.201] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:09.202] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:09.202] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[17:01:09.202] MultisessionFuture started
[17:01:09.203] - Launch lazy future ... done
[17:01:09.203] run() for ‘MultisessionFuture’ ... done
[17:01:09.203] Created future:
[17:01:09.203] MultisessionFuture:
[17:01:09.203] Label: ‘future_sapply-2’
[17:01:09.203] Expression:
[17:01:09.203] {
[17:01:09.203]     do.call(function(...) {
[17:01:09.203]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.203]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.203]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.203]             on.exit(options(oopts), add = TRUE)
[17:01:09.203]         }
[17:01:09.203]         {
[17:01:09.203]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.203]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.203]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.203]             })
[17:01:09.203]         }
[17:01:09.203]     }, args = future.call.arguments)
[17:01:09.203] }
[17:01:09.203] Lazy evaluation: FALSE
[17:01:09.203] Asynchronous evaluation: TRUE
[17:01:09.203] Local evaluation: TRUE
[17:01:09.203] Environment: R_GlobalEnv
[17:01:09.203] Capture standard output: TRUE
[17:01:09.203] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.203] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:01:09.203] Packages: <none>
[17:01:09.203] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.203] Resolved: FALSE
[17:01:09.203] Value: <not collected>
[17:01:09.203] Conditions captured: <none>
[17:01:09.203] Early signaling: FALSE
[17:01:09.203] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.203] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.215] Chunk #2 of 2 ... DONE
[17:01:09.215] Launching 2 futures (chunks) ... DONE
[17:01:09.215] Resolving 2 futures (chunks) ...
[17:01:09.215] resolve() on list ...
[17:01:09.215]  recursive: 0
[17:01:09.215]  length: 2
[17:01:09.215] 
[17:01:09.216] receiveMessageFromWorker() for ClusterFuture ...
[17:01:09.216] - Validating connection of MultisessionFuture
[17:01:09.216] - received message: FutureResult
[17:01:09.216] - Received FutureResult
[17:01:09.216] - Erased future from FutureRegistry
[17:01:09.216] result() for ClusterFuture ...
[17:01:09.217] - result already collected: FutureResult
[17:01:09.217] result() for ClusterFuture ... done
[17:01:09.217] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:09.217] Future #1
[17:01:09.217] result() for ClusterFuture ...
[17:01:09.217] - result already collected: FutureResult
[17:01:09.217] result() for ClusterFuture ... done
[17:01:09.217] result() for ClusterFuture ...
[17:01:09.217] - result already collected: FutureResult
[17:01:09.217] result() for ClusterFuture ... done
[17:01:09.217] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:09.218] - nx: 2
[17:01:09.218] - relay: TRUE
[17:01:09.218] - stdout: TRUE
[17:01:09.218] - signal: TRUE
[17:01:09.218] - resignal: FALSE
[17:01:09.218] - force: TRUE
[17:01:09.218] - relayed: [n=2] FALSE, FALSE
[17:01:09.218] - queued futures: [n=2] FALSE, FALSE
[17:01:09.218]  - until=1
[17:01:09.218]  - relaying element #1
[17:01:09.218] result() for ClusterFuture ...
[17:01:09.218] - result already collected: FutureResult
[17:01:09.219] result() for ClusterFuture ... done
[17:01:09.219] result() for ClusterFuture ...
[17:01:09.219] - result already collected: FutureResult
[17:01:09.219] result() for ClusterFuture ... done
[17:01:09.219] result() for ClusterFuture ...
[17:01:09.219] - result already collected: FutureResult
[17:01:09.219] result() for ClusterFuture ... done
[17:01:09.219] result() for ClusterFuture ...
[17:01:09.219] - result already collected: FutureResult
[17:01:09.219] result() for ClusterFuture ... done
[17:01:09.219] - relayed: [n=2] TRUE, FALSE
[17:01:09.220] - queued futures: [n=2] TRUE, FALSE
[17:01:09.220] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:09.220]  length: 1 (resolved future 1)
[17:01:09.245] receiveMessageFromWorker() for ClusterFuture ...
[17:01:09.246] - Validating connection of MultisessionFuture
[17:01:09.246] - received message: FutureResult
[17:01:09.246] - Received FutureResult
[17:01:09.246] - Erased future from FutureRegistry
[17:01:09.246] result() for ClusterFuture ...
[17:01:09.246] - result already collected: FutureResult
[17:01:09.246] result() for ClusterFuture ... done
[17:01:09.246] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:09.247] Future #2
[17:01:09.247] result() for ClusterFuture ...
[17:01:09.247] - result already collected: FutureResult
[17:01:09.247] result() for ClusterFuture ... done
[17:01:09.247] result() for ClusterFuture ...
[17:01:09.247] - result already collected: FutureResult
[17:01:09.247] result() for ClusterFuture ... done
[17:01:09.247] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:09.247] - nx: 2
[17:01:09.247] - relay: TRUE
[17:01:09.247] - stdout: TRUE
[17:01:09.248] - signal: TRUE
[17:01:09.248] - resignal: FALSE
[17:01:09.248] - force: TRUE
[17:01:09.248] - relayed: [n=2] TRUE, FALSE
[17:01:09.248] - queued futures: [n=2] TRUE, FALSE
[17:01:09.248]  - until=2
[17:01:09.248]  - relaying element #2
[17:01:09.248] result() for ClusterFuture ...
[17:01:09.248] - result already collected: FutureResult
[17:01:09.248] result() for ClusterFuture ... done
[17:01:09.248] result() for ClusterFuture ...
[17:01:09.248] - result already collected: FutureResult
[17:01:09.249] result() for ClusterFuture ... done
[17:01:09.249] result() for ClusterFuture ...
[17:01:09.249] - result already collected: FutureResult
[17:01:09.249] result() for ClusterFuture ... done
[17:01:09.249] result() for ClusterFuture ...
[17:01:09.249] - result already collected: FutureResult
[17:01:09.249] result() for ClusterFuture ... done
[17:01:09.249] - relayed: [n=2] TRUE, TRUE
[17:01:09.249] - queued futures: [n=2] TRUE, TRUE
[17:01:09.249] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:09.250]  length: 0 (resolved future 2)
[17:01:09.250] Relaying remaining futures
[17:01:09.250] signalConditionsASAP(NULL, pos=0) ...
[17:01:09.250] - nx: 2
[17:01:09.250] - relay: TRUE
[17:01:09.250] - stdout: TRUE
[17:01:09.250] - signal: TRUE
[17:01:09.250] - resignal: FALSE
[17:01:09.250] - force: TRUE
[17:01:09.250] - relayed: [n=2] TRUE, TRUE
[17:01:09.250] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:09.250] - relayed: [n=2] TRUE, TRUE
[17:01:09.251] - queued futures: [n=2] TRUE, TRUE
[17:01:09.251] signalConditionsASAP(NULL, pos=0) ... done
[17:01:09.251] resolve() on list ... DONE
[17:01:09.251] result() for ClusterFuture ...
[17:01:09.251] - result already collected: FutureResult
[17:01:09.251] result() for ClusterFuture ... done
[17:01:09.251] result() for ClusterFuture ...
[17:01:09.251] - result already collected: FutureResult
[17:01:09.251] result() for ClusterFuture ... done
[17:01:09.251] result() for ClusterFuture ...
[17:01:09.251] - result already collected: FutureResult
[17:01:09.252] result() for ClusterFuture ... done
[17:01:09.252] result() for ClusterFuture ...
[17:01:09.252] - result already collected: FutureResult
[17:01:09.252] result() for ClusterFuture ... done
[17:01:09.252]  - Number of value chunks collected: 2
[17:01:09.252] Resolving 2 futures (chunks) ... DONE
[17:01:09.252] Reducing values from 2 chunks ...
[17:01:09.252]  - Number of values collected after concatenation: 4
[17:01:09.252]  - Number of values expected: 4
[17:01:09.252] Reducing values from 2 chunks ... DONE
[17:01:09.252] future_lapply() ... DONE
[17:01:09.253] future_lapply() ...
[17:01:09.258] Number of chunks: 2
[17:01:09.258] getGlobalsAndPackagesXApply() ...
[17:01:09.259]  - future.globals: TRUE
[17:01:09.259] getGlobalsAndPackages() ...
[17:01:09.259] Searching for globals...
[17:01:09.262] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:01:09.262] Searching for globals ... DONE
[17:01:09.263] Resolving globals: FALSE
[17:01:09.264] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:01:09.264] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:09.264] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:09.264] - packages: [1] ‘future.apply’
[17:01:09.264] getGlobalsAndPackages() ... DONE
[17:01:09.264]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:09.265]  - needed namespaces: [n=1] ‘future.apply’
[17:01:09.265] Finding globals ... DONE
[17:01:09.265]  - use_args: TRUE
[17:01:09.265]  - Getting '...' globals ...
[17:01:09.265] resolve() on list ...
[17:01:09.265]  recursive: 0
[17:01:09.265]  length: 1
[17:01:09.265]  elements: ‘...’
[17:01:09.266]  length: 0 (resolved future 1)
[17:01:09.266] resolve() on list ... DONE
[17:01:09.266]    - '...' content: [n=1] ‘y’
[17:01:09.266] List of 1
[17:01:09.266]  $ ...:List of 1
[17:01:09.266]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:09.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.266]  - attr(*, "where")=List of 1
[17:01:09.266]   ..$ ...:<environment: 0x55aaddcaba40> 
[17:01:09.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.266]  - attr(*, "resolved")= logi TRUE
[17:01:09.266]  - attr(*, "total_size")= num NA
[17:01:09.269]  - Getting '...' globals ... DONE
[17:01:09.269] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:09.269] List of 8
[17:01:09.269]  $ ...future.FUN:function (x, ...)  
[17:01:09.269]  $ x_FUN        :function (x, y)  
[17:01:09.269]  $ times        : int 15
[17:01:09.269]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:09.269]  $ stop_if_not  :function (...)  
[17:01:09.269]  $ dim          : int [1:2] 3 5
[17:01:09.269]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:09.269]  $ ...          :List of 1
[17:01:09.269]   ..$ y: num [1:5] 2 4 6 8 10
[17:01:09.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.269]  - attr(*, "where")=List of 8
[17:01:09.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:09.269]   ..$ ...          :<environment: 0x55aaddcaba40> 
[17:01:09.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.269]  - attr(*, "resolved")= logi FALSE
[17:01:09.269]  - attr(*, "total_size")= num 98600
[17:01:09.278] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:09.278] getGlobalsAndPackagesXApply() ... DONE
[17:01:09.278] Number of futures (= number of chunks): 2
[17:01:09.278] Launching 2 futures (chunks) ...
[17:01:09.278] Chunk #1 of 2 ...
[17:01:09.278]  - Finding globals in 'X' for chunk #1 ...
[17:01:09.278] getGlobalsAndPackages() ...
[17:01:09.278] Searching for globals...
[17:01:09.279] 
[17:01:09.279] Searching for globals ... DONE
[17:01:09.279] - globals: [0] <none>
[17:01:09.279] getGlobalsAndPackages() ... DONE
[17:01:09.279]    + additional globals found: [n=0] 
[17:01:09.279]    + additional namespaces needed: [n=0] 
[17:01:09.279]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:09.279]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.279]  - seeds: <none>
[17:01:09.279]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.280] getGlobalsAndPackages() ...
[17:01:09.280] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.280] Resolving globals: FALSE
[17:01:09.280] Tweak future expression to call with '...' arguments ...
[17:01:09.280] {
[17:01:09.280]     do.call(function(...) {
[17:01:09.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.280]             on.exit(options(oopts), add = TRUE)
[17:01:09.280]         }
[17:01:09.280]         {
[17:01:09.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.280]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.280]             })
[17:01:09.280]         }
[17:01:09.280]     }, args = future.call.arguments)
[17:01:09.280] }
[17:01:09.280] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.281] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.281] - packages: [1] ‘future.apply’
[17:01:09.281] getGlobalsAndPackages() ... DONE
[17:01:09.281] run() for ‘Future’ ...
[17:01:09.281] - state: ‘created’
[17:01:09.282] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.296] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.296]   - Field: ‘node’
[17:01:09.296]   - Field: ‘label’
[17:01:09.296]   - Field: ‘local’
[17:01:09.296]   - Field: ‘owner’
[17:01:09.296]   - Field: ‘envir’
[17:01:09.296]   - Field: ‘workers’
[17:01:09.297]   - Field: ‘packages’
[17:01:09.297]   - Field: ‘gc’
[17:01:09.297]   - Field: ‘conditions’
[17:01:09.297]   - Field: ‘persistent’
[17:01:09.297]   - Field: ‘expr’
[17:01:09.297]   - Field: ‘uuid’
[17:01:09.297]   - Field: ‘seed’
[17:01:09.297]   - Field: ‘version’
[17:01:09.297]   - Field: ‘result’
[17:01:09.297]   - Field: ‘asynchronous’
[17:01:09.297]   - Field: ‘calls’
[17:01:09.298]   - Field: ‘globals’
[17:01:09.298]   - Field: ‘stdout’
[17:01:09.298]   - Field: ‘earlySignal’
[17:01:09.298]   - Field: ‘lazy’
[17:01:09.298]   - Field: ‘state’
[17:01:09.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.298] - Launch lazy future ...
[17:01:09.298] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:09.299] Packages needed by future strategies (n = 0): <none>
[17:01:09.299] {
[17:01:09.299]     {
[17:01:09.299]         {
[17:01:09.299]             ...future.startTime <- base::Sys.time()
[17:01:09.299]             {
[17:01:09.299]                 {
[17:01:09.299]                   {
[17:01:09.299]                     {
[17:01:09.299]                       {
[17:01:09.299]                         base::local({
[17:01:09.299]                           has_future <- base::requireNamespace("future", 
[17:01:09.299]                             quietly = TRUE)
[17:01:09.299]                           if (has_future) {
[17:01:09.299]                             ns <- base::getNamespace("future")
[17:01:09.299]                             version <- ns[[".package"]][["version"]]
[17:01:09.299]                             if (is.null(version)) 
[17:01:09.299]                               version <- utils::packageVersion("future")
[17:01:09.299]                           }
[17:01:09.299]                           else {
[17:01:09.299]                             version <- NULL
[17:01:09.299]                           }
[17:01:09.299]                           if (!has_future || version < "1.8.0") {
[17:01:09.299]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.299]                               "", base::R.version$version.string), 
[17:01:09.299]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:09.299]                                 base::R.version$platform, 8 * 
[17:01:09.299]                                   base::.Machine$sizeof.pointer), 
[17:01:09.299]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.299]                                 "release", "version")], collapse = " "), 
[17:01:09.299]                               hostname = base::Sys.info()[["nodename"]])
[17:01:09.299]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.299]                               info)
[17:01:09.299]                             info <- base::paste(info, collapse = "; ")
[17:01:09.299]                             if (!has_future) {
[17:01:09.299]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.299]                                 info)
[17:01:09.299]                             }
[17:01:09.299]                             else {
[17:01:09.299]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.299]                                 info, version)
[17:01:09.299]                             }
[17:01:09.299]                             base::stop(msg)
[17:01:09.299]                           }
[17:01:09.299]                         })
[17:01:09.299]                       }
[17:01:09.299]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.299]                       base::options(mc.cores = 1L)
[17:01:09.299]                     }
[17:01:09.299]                     base::local({
[17:01:09.299]                       for (pkg in "future.apply") {
[17:01:09.299]                         base::loadNamespace(pkg)
[17:01:09.299]                         base::library(pkg, character.only = TRUE)
[17:01:09.299]                       }
[17:01:09.299]                     })
[17:01:09.299]                   }
[17:01:09.299]                   ...future.strategy.old <- future::plan("list")
[17:01:09.299]                   options(future.plan = NULL)
[17:01:09.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.299]                 }
[17:01:09.299]                 ...future.workdir <- getwd()
[17:01:09.299]             }
[17:01:09.299]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.299]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.299]         }
[17:01:09.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.299]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.299]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.299]             base::names(...future.oldOptions))
[17:01:09.299]     }
[17:01:09.299]     if (FALSE) {
[17:01:09.299]     }
[17:01:09.299]     else {
[17:01:09.299]         if (TRUE) {
[17:01:09.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.299]                 open = "w")
[17:01:09.299]         }
[17:01:09.299]         else {
[17:01:09.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.299]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.299]         }
[17:01:09.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.299]             base::sink(type = "output", split = FALSE)
[17:01:09.299]             base::close(...future.stdout)
[17:01:09.299]         }, add = TRUE)
[17:01:09.299]     }
[17:01:09.299]     ...future.frame <- base::sys.nframe()
[17:01:09.299]     ...future.conditions <- base::list()
[17:01:09.299]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.299]     if (FALSE) {
[17:01:09.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.299]     }
[17:01:09.299]     ...future.result <- base::tryCatch({
[17:01:09.299]         base::withCallingHandlers({
[17:01:09.299]             ...future.value <- base::withVisible(base::local({
[17:01:09.299]                 ...future.makeSendCondition <- base::local({
[17:01:09.299]                   sendCondition <- NULL
[17:01:09.299]                   function(frame = 1L) {
[17:01:09.299]                     if (is.function(sendCondition)) 
[17:01:09.299]                       return(sendCondition)
[17:01:09.299]                     ns <- getNamespace("parallel")
[17:01:09.299]                     if (exists("sendData", mode = "function", 
[17:01:09.299]                       envir = ns)) {
[17:01:09.299]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.299]                         envir = ns)
[17:01:09.299]                       envir <- sys.frame(frame)
[17:01:09.299]                       master <- NULL
[17:01:09.299]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.299]                         !identical(envir, emptyenv())) {
[17:01:09.299]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.299]                           inherits = FALSE)) {
[17:01:09.299]                           master <- get("master", mode = "list", 
[17:01:09.299]                             envir = envir, inherits = FALSE)
[17:01:09.299]                           if (inherits(master, c("SOCKnode", 
[17:01:09.299]                             "SOCK0node"))) {
[17:01:09.299]                             sendCondition <<- function(cond) {
[17:01:09.299]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.299]                                 success = TRUE)
[17:01:09.299]                               parallel_sendData(master, data)
[17:01:09.299]                             }
[17:01:09.299]                             return(sendCondition)
[17:01:09.299]                           }
[17:01:09.299]                         }
[17:01:09.299]                         frame <- frame + 1L
[17:01:09.299]                         envir <- sys.frame(frame)
[17:01:09.299]                       }
[17:01:09.299]                     }
[17:01:09.299]                     sendCondition <<- function(cond) NULL
[17:01:09.299]                   }
[17:01:09.299]                 })
[17:01:09.299]                 withCallingHandlers({
[17:01:09.299]                   {
[17:01:09.299]                     do.call(function(...) {
[17:01:09.299]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.299]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.299]                         ...future.globals.maxSize)) {
[17:01:09.299]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.299]                         on.exit(options(oopts), add = TRUE)
[17:01:09.299]                       }
[17:01:09.299]                       {
[17:01:09.299]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.299]                           FUN = function(jj) {
[17:01:09.299]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.299]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.299]                           })
[17:01:09.299]                       }
[17:01:09.299]                     }, args = future.call.arguments)
[17:01:09.299]                   }
[17:01:09.299]                 }, immediateCondition = function(cond) {
[17:01:09.299]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.299]                   sendCondition(cond)
[17:01:09.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.299]                   {
[17:01:09.299]                     inherits <- base::inherits
[17:01:09.299]                     invokeRestart <- base::invokeRestart
[17:01:09.299]                     is.null <- base::is.null
[17:01:09.299]                     muffled <- FALSE
[17:01:09.299]                     if (inherits(cond, "message")) {
[17:01:09.299]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.299]                       if (muffled) 
[17:01:09.299]                         invokeRestart("muffleMessage")
[17:01:09.299]                     }
[17:01:09.299]                     else if (inherits(cond, "warning")) {
[17:01:09.299]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.299]                       if (muffled) 
[17:01:09.299]                         invokeRestart("muffleWarning")
[17:01:09.299]                     }
[17:01:09.299]                     else if (inherits(cond, "condition")) {
[17:01:09.299]                       if (!is.null(pattern)) {
[17:01:09.299]                         computeRestarts <- base::computeRestarts
[17:01:09.299]                         grepl <- base::grepl
[17:01:09.299]                         restarts <- computeRestarts(cond)
[17:01:09.299]                         for (restart in restarts) {
[17:01:09.299]                           name <- restart$name
[17:01:09.299]                           if (is.null(name)) 
[17:01:09.299]                             next
[17:01:09.299]                           if (!grepl(pattern, name)) 
[17:01:09.299]                             next
[17:01:09.299]                           invokeRestart(restart)
[17:01:09.299]                           muffled <- TRUE
[17:01:09.299]                           break
[17:01:09.299]                         }
[17:01:09.299]                       }
[17:01:09.299]                     }
[17:01:09.299]                     invisible(muffled)
[17:01:09.299]                   }
[17:01:09.299]                   muffleCondition(cond)
[17:01:09.299]                 })
[17:01:09.299]             }))
[17:01:09.299]             future::FutureResult(value = ...future.value$value, 
[17:01:09.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.299]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.299]                     ...future.globalenv.names))
[17:01:09.299]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.299]         }, condition = base::local({
[17:01:09.299]             c <- base::c
[17:01:09.299]             inherits <- base::inherits
[17:01:09.299]             invokeRestart <- base::invokeRestart
[17:01:09.299]             length <- base::length
[17:01:09.299]             list <- base::list
[17:01:09.299]             seq.int <- base::seq.int
[17:01:09.299]             signalCondition <- base::signalCondition
[17:01:09.299]             sys.calls <- base::sys.calls
[17:01:09.299]             `[[` <- base::`[[`
[17:01:09.299]             `+` <- base::`+`
[17:01:09.299]             `<<-` <- base::`<<-`
[17:01:09.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.299]                   3L)]
[17:01:09.299]             }
[17:01:09.299]             function(cond) {
[17:01:09.299]                 is_error <- inherits(cond, "error")
[17:01:09.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.299]                   NULL)
[17:01:09.299]                 if (is_error) {
[17:01:09.299]                   sessionInformation <- function() {
[17:01:09.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.299]                       search = base::search(), system = base::Sys.info())
[17:01:09.299]                   }
[17:01:09.299]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.299]                     cond$call), session = sessionInformation(), 
[17:01:09.299]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.299]                   signalCondition(cond)
[17:01:09.299]                 }
[17:01:09.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.299]                 "immediateCondition"))) {
[17:01:09.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.299]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.299]                   if (TRUE && !signal) {
[17:01:09.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.299]                     {
[17:01:09.299]                       inherits <- base::inherits
[17:01:09.299]                       invokeRestart <- base::invokeRestart
[17:01:09.299]                       is.null <- base::is.null
[17:01:09.299]                       muffled <- FALSE
[17:01:09.299]                       if (inherits(cond, "message")) {
[17:01:09.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.299]                         if (muffled) 
[17:01:09.299]                           invokeRestart("muffleMessage")
[17:01:09.299]                       }
[17:01:09.299]                       else if (inherits(cond, "warning")) {
[17:01:09.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.299]                         if (muffled) 
[17:01:09.299]                           invokeRestart("muffleWarning")
[17:01:09.299]                       }
[17:01:09.299]                       else if (inherits(cond, "condition")) {
[17:01:09.299]                         if (!is.null(pattern)) {
[17:01:09.299]                           computeRestarts <- base::computeRestarts
[17:01:09.299]                           grepl <- base::grepl
[17:01:09.299]                           restarts <- computeRestarts(cond)
[17:01:09.299]                           for (restart in restarts) {
[17:01:09.299]                             name <- restart$name
[17:01:09.299]                             if (is.null(name)) 
[17:01:09.299]                               next
[17:01:09.299]                             if (!grepl(pattern, name)) 
[17:01:09.299]                               next
[17:01:09.299]                             invokeRestart(restart)
[17:01:09.299]                             muffled <- TRUE
[17:01:09.299]                             break
[17:01:09.299]                           }
[17:01:09.299]                         }
[17:01:09.299]                       }
[17:01:09.299]                       invisible(muffled)
[17:01:09.299]                     }
[17:01:09.299]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.299]                   }
[17:01:09.299]                 }
[17:01:09.299]                 else {
[17:01:09.299]                   if (TRUE) {
[17:01:09.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.299]                     {
[17:01:09.299]                       inherits <- base::inherits
[17:01:09.299]                       invokeRestart <- base::invokeRestart
[17:01:09.299]                       is.null <- base::is.null
[17:01:09.299]                       muffled <- FALSE
[17:01:09.299]                       if (inherits(cond, "message")) {
[17:01:09.299]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.299]                         if (muffled) 
[17:01:09.299]                           invokeRestart("muffleMessage")
[17:01:09.299]                       }
[17:01:09.299]                       else if (inherits(cond, "warning")) {
[17:01:09.299]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.299]                         if (muffled) 
[17:01:09.299]                           invokeRestart("muffleWarning")
[17:01:09.299]                       }
[17:01:09.299]                       else if (inherits(cond, "condition")) {
[17:01:09.299]                         if (!is.null(pattern)) {
[17:01:09.299]                           computeRestarts <- base::computeRestarts
[17:01:09.299]                           grepl <- base::grepl
[17:01:09.299]                           restarts <- computeRestarts(cond)
[17:01:09.299]                           for (restart in restarts) {
[17:01:09.299]                             name <- restart$name
[17:01:09.299]                             if (is.null(name)) 
[17:01:09.299]                               next
[17:01:09.299]                             if (!grepl(pattern, name)) 
[17:01:09.299]                               next
[17:01:09.299]                             invokeRestart(restart)
[17:01:09.299]                             muffled <- TRUE
[17:01:09.299]                             break
[17:01:09.299]                           }
[17:01:09.299]                         }
[17:01:09.299]                       }
[17:01:09.299]                       invisible(muffled)
[17:01:09.299]                     }
[17:01:09.299]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.299]                   }
[17:01:09.299]                 }
[17:01:09.299]             }
[17:01:09.299]         }))
[17:01:09.299]     }, error = function(ex) {
[17:01:09.299]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.299]                 ...future.rng), started = ...future.startTime, 
[17:01:09.299]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.299]             version = "1.8"), class = "FutureResult")
[17:01:09.299]     }, finally = {
[17:01:09.299]         if (!identical(...future.workdir, getwd())) 
[17:01:09.299]             setwd(...future.workdir)
[17:01:09.299]         {
[17:01:09.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.299]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.299]             }
[17:01:09.299]             base::options(...future.oldOptions)
[17:01:09.299]             if (.Platform$OS.type == "windows") {
[17:01:09.299]                 old_names <- names(...future.oldEnvVars)
[17:01:09.299]                 envs <- base::Sys.getenv()
[17:01:09.299]                 names <- names(envs)
[17:01:09.299]                 common <- intersect(names, old_names)
[17:01:09.299]                 added <- setdiff(names, old_names)
[17:01:09.299]                 removed <- setdiff(old_names, names)
[17:01:09.299]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.299]                   envs[common]]
[17:01:09.299]                 NAMES <- toupper(changed)
[17:01:09.299]                 args <- list()
[17:01:09.299]                 for (kk in seq_along(NAMES)) {
[17:01:09.299]                   name <- changed[[kk]]
[17:01:09.299]                   NAME <- NAMES[[kk]]
[17:01:09.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.299]                     next
[17:01:09.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.299]                 }
[17:01:09.299]                 NAMES <- toupper(added)
[17:01:09.299]                 for (kk in seq_along(NAMES)) {
[17:01:09.299]                   name <- added[[kk]]
[17:01:09.299]                   NAME <- NAMES[[kk]]
[17:01:09.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.299]                     next
[17:01:09.299]                   args[[name]] <- ""
[17:01:09.299]                 }
[17:01:09.299]                 NAMES <- toupper(removed)
[17:01:09.299]                 for (kk in seq_along(NAMES)) {
[17:01:09.299]                   name <- removed[[kk]]
[17:01:09.299]                   NAME <- NAMES[[kk]]
[17:01:09.299]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.299]                     next
[17:01:09.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.299]                 }
[17:01:09.299]                 if (length(args) > 0) 
[17:01:09.299]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.299]             }
[17:01:09.299]             else {
[17:01:09.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.299]             }
[17:01:09.299]             {
[17:01:09.299]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.299]                   0L) {
[17:01:09.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.299]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.299]                   base::options(opts)
[17:01:09.299]                 }
[17:01:09.299]                 {
[17:01:09.299]                   {
[17:01:09.299]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.299]                     NULL
[17:01:09.299]                   }
[17:01:09.299]                   options(future.plan = NULL)
[17:01:09.299]                   if (is.na(NA_character_)) 
[17:01:09.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.299]                     .init = FALSE)
[17:01:09.299]                 }
[17:01:09.299]             }
[17:01:09.299]         }
[17:01:09.299]     })
[17:01:09.299]     if (TRUE) {
[17:01:09.299]         base::sink(type = "output", split = FALSE)
[17:01:09.299]         if (TRUE) {
[17:01:09.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.299]         }
[17:01:09.299]         else {
[17:01:09.299]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.299]         }
[17:01:09.299]         base::close(...future.stdout)
[17:01:09.299]         ...future.stdout <- NULL
[17:01:09.299]     }
[17:01:09.299]     ...future.result$conditions <- ...future.conditions
[17:01:09.299]     ...future.result$finished <- base::Sys.time()
[17:01:09.299]     ...future.result
[17:01:09.299] }
[17:01:09.302] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[17:01:09.302] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:09.344] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:09.344] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[17:01:09.344] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:01:09.345] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:09.345] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.345] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:09.388] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:09.388] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:09.432] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:09.432] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:09.432] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.433] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:09.433] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:09.433] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:01:09.434] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:01:09.434] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:09.434] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:09.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:09.435] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.435] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:09.435] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.435] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[17:01:09.436] MultisessionFuture started
[17:01:09.436] - Launch lazy future ... done
[17:01:09.436] run() for ‘MultisessionFuture’ ... done
[17:01:09.436] Created future:
[17:01:09.438] receiveMessageFromWorker() for ClusterFuture ...
[17:01:09.438] - Validating connection of MultisessionFuture
[17:01:09.438] - received message: FutureResult
[17:01:09.438] - Received FutureResult
[17:01:09.438] - Erased future from FutureRegistry
[17:01:09.439] result() for ClusterFuture ...
[17:01:09.439] - result already collected: FutureResult
[17:01:09.439] result() for ClusterFuture ... done
[17:01:09.439] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:09.436] MultisessionFuture:
[17:01:09.436] Label: ‘future_vapply-1’
[17:01:09.436] Expression:
[17:01:09.436] {
[17:01:09.436]     do.call(function(...) {
[17:01:09.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.436]             on.exit(options(oopts), add = TRUE)
[17:01:09.436]         }
[17:01:09.436]         {
[17:01:09.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.436]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.436]             })
[17:01:09.436]         }
[17:01:09.436]     }, args = future.call.arguments)
[17:01:09.436] }
[17:01:09.436] Lazy evaluation: FALSE
[17:01:09.436] Asynchronous evaluation: TRUE
[17:01:09.436] Local evaluation: TRUE
[17:01:09.436] Environment: R_GlobalEnv
[17:01:09.436] Capture standard output: TRUE
[17:01:09.436] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.436] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:09.436] Packages: 1 packages (‘future.apply’)
[17:01:09.436] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.436] Resolved: TRUE
[17:01:09.436] Value: <not collected>
[17:01:09.436] Conditions captured: <none>
[17:01:09.436] Early signaling: FALSE
[17:01:09.436] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.436] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.439] Chunk #1 of 2 ... DONE
[17:01:09.439] Chunk #2 of 2 ...
[17:01:09.439]  - Finding globals in 'X' for chunk #2 ...
[17:01:09.439] getGlobalsAndPackages() ...
[17:01:09.440] Searching for globals...
[17:01:09.440] 
[17:01:09.440] Searching for globals ... DONE
[17:01:09.440] - globals: [0] <none>
[17:01:09.440] getGlobalsAndPackages() ... DONE
[17:01:09.440]    + additional globals found: [n=0] 
[17:01:09.440]    + additional namespaces needed: [n=0] 
[17:01:09.440]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:09.440]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.441]  - seeds: <none>
[17:01:09.441]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.441] getGlobalsAndPackages() ...
[17:01:09.441] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.441] Resolving globals: FALSE
[17:01:09.441] Tweak future expression to call with '...' arguments ...
[17:01:09.441] {
[17:01:09.441]     do.call(function(...) {
[17:01:09.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.441]             on.exit(options(oopts), add = TRUE)
[17:01:09.441]         }
[17:01:09.441]         {
[17:01:09.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.441]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.441]             })
[17:01:09.441]         }
[17:01:09.441]     }, args = future.call.arguments)
[17:01:09.441] }
[17:01:09.441] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.442] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.442] - packages: [1] ‘future.apply’
[17:01:09.442] getGlobalsAndPackages() ... DONE
[17:01:09.442] run() for ‘Future’ ...
[17:01:09.443] - state: ‘created’
[17:01:09.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.457]   - Field: ‘node’
[17:01:09.458]   - Field: ‘label’
[17:01:09.458]   - Field: ‘local’
[17:01:09.458]   - Field: ‘owner’
[17:01:09.458]   - Field: ‘envir’
[17:01:09.458]   - Field: ‘workers’
[17:01:09.458]   - Field: ‘packages’
[17:01:09.458]   - Field: ‘gc’
[17:01:09.458]   - Field: ‘conditions’
[17:01:09.458]   - Field: ‘persistent’
[17:01:09.458]   - Field: ‘expr’
[17:01:09.458]   - Field: ‘uuid’
[17:01:09.459]   - Field: ‘seed’
[17:01:09.459]   - Field: ‘version’
[17:01:09.459]   - Field: ‘result’
[17:01:09.459]   - Field: ‘asynchronous’
[17:01:09.459]   - Field: ‘calls’
[17:01:09.459]   - Field: ‘globals’
[17:01:09.459]   - Field: ‘stdout’
[17:01:09.459]   - Field: ‘earlySignal’
[17:01:09.459]   - Field: ‘lazy’
[17:01:09.459]   - Field: ‘state’
[17:01:09.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.460] - Launch lazy future ...
[17:01:09.460] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:09.460] Packages needed by future strategies (n = 0): <none>
[17:01:09.461] {
[17:01:09.461]     {
[17:01:09.461]         {
[17:01:09.461]             ...future.startTime <- base::Sys.time()
[17:01:09.461]             {
[17:01:09.461]                 {
[17:01:09.461]                   {
[17:01:09.461]                     {
[17:01:09.461]                       {
[17:01:09.461]                         base::local({
[17:01:09.461]                           has_future <- base::requireNamespace("future", 
[17:01:09.461]                             quietly = TRUE)
[17:01:09.461]                           if (has_future) {
[17:01:09.461]                             ns <- base::getNamespace("future")
[17:01:09.461]                             version <- ns[[".package"]][["version"]]
[17:01:09.461]                             if (is.null(version)) 
[17:01:09.461]                               version <- utils::packageVersion("future")
[17:01:09.461]                           }
[17:01:09.461]                           else {
[17:01:09.461]                             version <- NULL
[17:01:09.461]                           }
[17:01:09.461]                           if (!has_future || version < "1.8.0") {
[17:01:09.461]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.461]                               "", base::R.version$version.string), 
[17:01:09.461]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:09.461]                                 base::R.version$platform, 8 * 
[17:01:09.461]                                   base::.Machine$sizeof.pointer), 
[17:01:09.461]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.461]                                 "release", "version")], collapse = " "), 
[17:01:09.461]                               hostname = base::Sys.info()[["nodename"]])
[17:01:09.461]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.461]                               info)
[17:01:09.461]                             info <- base::paste(info, collapse = "; ")
[17:01:09.461]                             if (!has_future) {
[17:01:09.461]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.461]                                 info)
[17:01:09.461]                             }
[17:01:09.461]                             else {
[17:01:09.461]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.461]                                 info, version)
[17:01:09.461]                             }
[17:01:09.461]                             base::stop(msg)
[17:01:09.461]                           }
[17:01:09.461]                         })
[17:01:09.461]                       }
[17:01:09.461]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.461]                       base::options(mc.cores = 1L)
[17:01:09.461]                     }
[17:01:09.461]                     base::local({
[17:01:09.461]                       for (pkg in "future.apply") {
[17:01:09.461]                         base::loadNamespace(pkg)
[17:01:09.461]                         base::library(pkg, character.only = TRUE)
[17:01:09.461]                       }
[17:01:09.461]                     })
[17:01:09.461]                   }
[17:01:09.461]                   ...future.strategy.old <- future::plan("list")
[17:01:09.461]                   options(future.plan = NULL)
[17:01:09.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.461]                 }
[17:01:09.461]                 ...future.workdir <- getwd()
[17:01:09.461]             }
[17:01:09.461]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.461]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.461]         }
[17:01:09.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.461]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.461]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.461]             base::names(...future.oldOptions))
[17:01:09.461]     }
[17:01:09.461]     if (FALSE) {
[17:01:09.461]     }
[17:01:09.461]     else {
[17:01:09.461]         if (TRUE) {
[17:01:09.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.461]                 open = "w")
[17:01:09.461]         }
[17:01:09.461]         else {
[17:01:09.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.461]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.461]         }
[17:01:09.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.461]             base::sink(type = "output", split = FALSE)
[17:01:09.461]             base::close(...future.stdout)
[17:01:09.461]         }, add = TRUE)
[17:01:09.461]     }
[17:01:09.461]     ...future.frame <- base::sys.nframe()
[17:01:09.461]     ...future.conditions <- base::list()
[17:01:09.461]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.461]     if (FALSE) {
[17:01:09.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.461]     }
[17:01:09.461]     ...future.result <- base::tryCatch({
[17:01:09.461]         base::withCallingHandlers({
[17:01:09.461]             ...future.value <- base::withVisible(base::local({
[17:01:09.461]                 ...future.makeSendCondition <- base::local({
[17:01:09.461]                   sendCondition <- NULL
[17:01:09.461]                   function(frame = 1L) {
[17:01:09.461]                     if (is.function(sendCondition)) 
[17:01:09.461]                       return(sendCondition)
[17:01:09.461]                     ns <- getNamespace("parallel")
[17:01:09.461]                     if (exists("sendData", mode = "function", 
[17:01:09.461]                       envir = ns)) {
[17:01:09.461]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.461]                         envir = ns)
[17:01:09.461]                       envir <- sys.frame(frame)
[17:01:09.461]                       master <- NULL
[17:01:09.461]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.461]                         !identical(envir, emptyenv())) {
[17:01:09.461]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.461]                           inherits = FALSE)) {
[17:01:09.461]                           master <- get("master", mode = "list", 
[17:01:09.461]                             envir = envir, inherits = FALSE)
[17:01:09.461]                           if (inherits(master, c("SOCKnode", 
[17:01:09.461]                             "SOCK0node"))) {
[17:01:09.461]                             sendCondition <<- function(cond) {
[17:01:09.461]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.461]                                 success = TRUE)
[17:01:09.461]                               parallel_sendData(master, data)
[17:01:09.461]                             }
[17:01:09.461]                             return(sendCondition)
[17:01:09.461]                           }
[17:01:09.461]                         }
[17:01:09.461]                         frame <- frame + 1L
[17:01:09.461]                         envir <- sys.frame(frame)
[17:01:09.461]                       }
[17:01:09.461]                     }
[17:01:09.461]                     sendCondition <<- function(cond) NULL
[17:01:09.461]                   }
[17:01:09.461]                 })
[17:01:09.461]                 withCallingHandlers({
[17:01:09.461]                   {
[17:01:09.461]                     do.call(function(...) {
[17:01:09.461]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.461]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.461]                         ...future.globals.maxSize)) {
[17:01:09.461]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.461]                         on.exit(options(oopts), add = TRUE)
[17:01:09.461]                       }
[17:01:09.461]                       {
[17:01:09.461]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.461]                           FUN = function(jj) {
[17:01:09.461]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.461]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.461]                           })
[17:01:09.461]                       }
[17:01:09.461]                     }, args = future.call.arguments)
[17:01:09.461]                   }
[17:01:09.461]                 }, immediateCondition = function(cond) {
[17:01:09.461]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.461]                   sendCondition(cond)
[17:01:09.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.461]                   {
[17:01:09.461]                     inherits <- base::inherits
[17:01:09.461]                     invokeRestart <- base::invokeRestart
[17:01:09.461]                     is.null <- base::is.null
[17:01:09.461]                     muffled <- FALSE
[17:01:09.461]                     if (inherits(cond, "message")) {
[17:01:09.461]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.461]                       if (muffled) 
[17:01:09.461]                         invokeRestart("muffleMessage")
[17:01:09.461]                     }
[17:01:09.461]                     else if (inherits(cond, "warning")) {
[17:01:09.461]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.461]                       if (muffled) 
[17:01:09.461]                         invokeRestart("muffleWarning")
[17:01:09.461]                     }
[17:01:09.461]                     else if (inherits(cond, "condition")) {
[17:01:09.461]                       if (!is.null(pattern)) {
[17:01:09.461]                         computeRestarts <- base::computeRestarts
[17:01:09.461]                         grepl <- base::grepl
[17:01:09.461]                         restarts <- computeRestarts(cond)
[17:01:09.461]                         for (restart in restarts) {
[17:01:09.461]                           name <- restart$name
[17:01:09.461]                           if (is.null(name)) 
[17:01:09.461]                             next
[17:01:09.461]                           if (!grepl(pattern, name)) 
[17:01:09.461]                             next
[17:01:09.461]                           invokeRestart(restart)
[17:01:09.461]                           muffled <- TRUE
[17:01:09.461]                           break
[17:01:09.461]                         }
[17:01:09.461]                       }
[17:01:09.461]                     }
[17:01:09.461]                     invisible(muffled)
[17:01:09.461]                   }
[17:01:09.461]                   muffleCondition(cond)
[17:01:09.461]                 })
[17:01:09.461]             }))
[17:01:09.461]             future::FutureResult(value = ...future.value$value, 
[17:01:09.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.461]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.461]                     ...future.globalenv.names))
[17:01:09.461]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.461]         }, condition = base::local({
[17:01:09.461]             c <- base::c
[17:01:09.461]             inherits <- base::inherits
[17:01:09.461]             invokeRestart <- base::invokeRestart
[17:01:09.461]             length <- base::length
[17:01:09.461]             list <- base::list
[17:01:09.461]             seq.int <- base::seq.int
[17:01:09.461]             signalCondition <- base::signalCondition
[17:01:09.461]             sys.calls <- base::sys.calls
[17:01:09.461]             `[[` <- base::`[[`
[17:01:09.461]             `+` <- base::`+`
[17:01:09.461]             `<<-` <- base::`<<-`
[17:01:09.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.461]                   3L)]
[17:01:09.461]             }
[17:01:09.461]             function(cond) {
[17:01:09.461]                 is_error <- inherits(cond, "error")
[17:01:09.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.461]                   NULL)
[17:01:09.461]                 if (is_error) {
[17:01:09.461]                   sessionInformation <- function() {
[17:01:09.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.461]                       search = base::search(), system = base::Sys.info())
[17:01:09.461]                   }
[17:01:09.461]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.461]                     cond$call), session = sessionInformation(), 
[17:01:09.461]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.461]                   signalCondition(cond)
[17:01:09.461]                 }
[17:01:09.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.461]                 "immediateCondition"))) {
[17:01:09.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.461]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.461]                   if (TRUE && !signal) {
[17:01:09.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.461]                     {
[17:01:09.461]                       inherits <- base::inherits
[17:01:09.461]                       invokeRestart <- base::invokeRestart
[17:01:09.461]                       is.null <- base::is.null
[17:01:09.461]                       muffled <- FALSE
[17:01:09.461]                       if (inherits(cond, "message")) {
[17:01:09.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.461]                         if (muffled) 
[17:01:09.461]                           invokeRestart("muffleMessage")
[17:01:09.461]                       }
[17:01:09.461]                       else if (inherits(cond, "warning")) {
[17:01:09.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.461]                         if (muffled) 
[17:01:09.461]                           invokeRestart("muffleWarning")
[17:01:09.461]                       }
[17:01:09.461]                       else if (inherits(cond, "condition")) {
[17:01:09.461]                         if (!is.null(pattern)) {
[17:01:09.461]                           computeRestarts <- base::computeRestarts
[17:01:09.461]                           grepl <- base::grepl
[17:01:09.461]                           restarts <- computeRestarts(cond)
[17:01:09.461]                           for (restart in restarts) {
[17:01:09.461]                             name <- restart$name
[17:01:09.461]                             if (is.null(name)) 
[17:01:09.461]                               next
[17:01:09.461]                             if (!grepl(pattern, name)) 
[17:01:09.461]                               next
[17:01:09.461]                             invokeRestart(restart)
[17:01:09.461]                             muffled <- TRUE
[17:01:09.461]                             break
[17:01:09.461]                           }
[17:01:09.461]                         }
[17:01:09.461]                       }
[17:01:09.461]                       invisible(muffled)
[17:01:09.461]                     }
[17:01:09.461]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.461]                   }
[17:01:09.461]                 }
[17:01:09.461]                 else {
[17:01:09.461]                   if (TRUE) {
[17:01:09.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.461]                     {
[17:01:09.461]                       inherits <- base::inherits
[17:01:09.461]                       invokeRestart <- base::invokeRestart
[17:01:09.461]                       is.null <- base::is.null
[17:01:09.461]                       muffled <- FALSE
[17:01:09.461]                       if (inherits(cond, "message")) {
[17:01:09.461]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.461]                         if (muffled) 
[17:01:09.461]                           invokeRestart("muffleMessage")
[17:01:09.461]                       }
[17:01:09.461]                       else if (inherits(cond, "warning")) {
[17:01:09.461]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.461]                         if (muffled) 
[17:01:09.461]                           invokeRestart("muffleWarning")
[17:01:09.461]                       }
[17:01:09.461]                       else if (inherits(cond, "condition")) {
[17:01:09.461]                         if (!is.null(pattern)) {
[17:01:09.461]                           computeRestarts <- base::computeRestarts
[17:01:09.461]                           grepl <- base::grepl
[17:01:09.461]                           restarts <- computeRestarts(cond)
[17:01:09.461]                           for (restart in restarts) {
[17:01:09.461]                             name <- restart$name
[17:01:09.461]                             if (is.null(name)) 
[17:01:09.461]                               next
[17:01:09.461]                             if (!grepl(pattern, name)) 
[17:01:09.461]                               next
[17:01:09.461]                             invokeRestart(restart)
[17:01:09.461]                             muffled <- TRUE
[17:01:09.461]                             break
[17:01:09.461]                           }
[17:01:09.461]                         }
[17:01:09.461]                       }
[17:01:09.461]                       invisible(muffled)
[17:01:09.461]                     }
[17:01:09.461]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.461]                   }
[17:01:09.461]                 }
[17:01:09.461]             }
[17:01:09.461]         }))
[17:01:09.461]     }, error = function(ex) {
[17:01:09.461]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.461]                 ...future.rng), started = ...future.startTime, 
[17:01:09.461]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.461]             version = "1.8"), class = "FutureResult")
[17:01:09.461]     }, finally = {
[17:01:09.461]         if (!identical(...future.workdir, getwd())) 
[17:01:09.461]             setwd(...future.workdir)
[17:01:09.461]         {
[17:01:09.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.461]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.461]             }
[17:01:09.461]             base::options(...future.oldOptions)
[17:01:09.461]             if (.Platform$OS.type == "windows") {
[17:01:09.461]                 old_names <- names(...future.oldEnvVars)
[17:01:09.461]                 envs <- base::Sys.getenv()
[17:01:09.461]                 names <- names(envs)
[17:01:09.461]                 common <- intersect(names, old_names)
[17:01:09.461]                 added <- setdiff(names, old_names)
[17:01:09.461]                 removed <- setdiff(old_names, names)
[17:01:09.461]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.461]                   envs[common]]
[17:01:09.461]                 NAMES <- toupper(changed)
[17:01:09.461]                 args <- list()
[17:01:09.461]                 for (kk in seq_along(NAMES)) {
[17:01:09.461]                   name <- changed[[kk]]
[17:01:09.461]                   NAME <- NAMES[[kk]]
[17:01:09.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.461]                     next
[17:01:09.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.461]                 }
[17:01:09.461]                 NAMES <- toupper(added)
[17:01:09.461]                 for (kk in seq_along(NAMES)) {
[17:01:09.461]                   name <- added[[kk]]
[17:01:09.461]                   NAME <- NAMES[[kk]]
[17:01:09.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.461]                     next
[17:01:09.461]                   args[[name]] <- ""
[17:01:09.461]                 }
[17:01:09.461]                 NAMES <- toupper(removed)
[17:01:09.461]                 for (kk in seq_along(NAMES)) {
[17:01:09.461]                   name <- removed[[kk]]
[17:01:09.461]                   NAME <- NAMES[[kk]]
[17:01:09.461]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.461]                     next
[17:01:09.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.461]                 }
[17:01:09.461]                 if (length(args) > 0) 
[17:01:09.461]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.461]             }
[17:01:09.461]             else {
[17:01:09.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.461]             }
[17:01:09.461]             {
[17:01:09.461]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.461]                   0L) {
[17:01:09.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.461]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.461]                   base::options(opts)
[17:01:09.461]                 }
[17:01:09.461]                 {
[17:01:09.461]                   {
[17:01:09.461]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.461]                     NULL
[17:01:09.461]                   }
[17:01:09.461]                   options(future.plan = NULL)
[17:01:09.461]                   if (is.na(NA_character_)) 
[17:01:09.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.461]                     .init = FALSE)
[17:01:09.461]                 }
[17:01:09.461]             }
[17:01:09.461]         }
[17:01:09.461]     })
[17:01:09.461]     if (TRUE) {
[17:01:09.461]         base::sink(type = "output", split = FALSE)
[17:01:09.461]         if (TRUE) {
[17:01:09.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.461]         }
[17:01:09.461]         else {
[17:01:09.461]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.461]         }
[17:01:09.461]         base::close(...future.stdout)
[17:01:09.461]         ...future.stdout <- NULL
[17:01:09.461]     }
[17:01:09.461]     ...future.result$conditions <- ...future.conditions
[17:01:09.461]     ...future.result$finished <- base::Sys.time()
[17:01:09.461]     ...future.result
[17:01:09.461] }
[17:01:09.463] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[17:01:09.464] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:09.508] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:09.508] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[17:01:09.509] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:01:09.509] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:09.509] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.509] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:09.552] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:09.552] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:09.596] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:09.596] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:01:09.597] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.597] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:09.597] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:09.597] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:01:09.598] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:01:09.598] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:01:09.598] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:01:09.598] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:09.599] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:09.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.599] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[17:01:09.600] MultisessionFuture started
[17:01:09.600] - Launch lazy future ... done
[17:01:09.600] run() for ‘MultisessionFuture’ ... done
[17:01:09.600] Created future:
[17:01:09.600] MultisessionFuture:
[17:01:09.600] Label: ‘future_vapply-2’
[17:01:09.600] Expression:
[17:01:09.600] {
[17:01:09.600]     do.call(function(...) {
[17:01:09.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.600]             on.exit(options(oopts), add = TRUE)
[17:01:09.600]         }
[17:01:09.600]         {
[17:01:09.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.600]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.600]             })
[17:01:09.600]         }
[17:01:09.600]     }, args = future.call.arguments)
[17:01:09.600] }
[17:01:09.600] Lazy evaluation: FALSE
[17:01:09.600] Asynchronous evaluation: TRUE
[17:01:09.600] Local evaluation: TRUE
[17:01:09.600] Environment: R_GlobalEnv
[17:01:09.600] Capture standard output: TRUE
[17:01:09.600] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.600] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:09.600] Packages: 1 packages (‘future.apply’)
[17:01:09.600] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.600] Resolved: FALSE
[17:01:09.600] Value: <not collected>
[17:01:09.600] Conditions captured: <none>
[17:01:09.600] Early signaling: FALSE
[17:01:09.600] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.600] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.612] Chunk #2 of 2 ... DONE
[17:01:09.612] Launching 2 futures (chunks) ... DONE
[17:01:09.612] Resolving 2 futures (chunks) ...
[17:01:09.613] resolve() on list ...
[17:01:09.613]  recursive: 0
[17:01:09.613]  length: 2
[17:01:09.613] 
[17:01:09.613] Future #1
[17:01:09.613] result() for ClusterFuture ...
[17:01:09.613] - result already collected: FutureResult
[17:01:09.613] result() for ClusterFuture ... done
[17:01:09.613] result() for ClusterFuture ...
[17:01:09.614] - result already collected: FutureResult
[17:01:09.614] result() for ClusterFuture ... done
[17:01:09.614] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:09.614] - nx: 2
[17:01:09.614] - relay: TRUE
[17:01:09.614] - stdout: TRUE
[17:01:09.614] - signal: TRUE
[17:01:09.614] - resignal: FALSE
[17:01:09.614] - force: TRUE
[17:01:09.614] - relayed: [n=2] FALSE, FALSE
[17:01:09.614] - queued futures: [n=2] FALSE, FALSE
[17:01:09.614]  - until=1
[17:01:09.615]  - relaying element #1
[17:01:09.615] result() for ClusterFuture ...
[17:01:09.615] - result already collected: FutureResult
[17:01:09.615] result() for ClusterFuture ... done
[17:01:09.615] result() for ClusterFuture ...
[17:01:09.615] - result already collected: FutureResult
[17:01:09.615] result() for ClusterFuture ... done
[17:01:09.615] result() for ClusterFuture ...
[17:01:09.615] - result already collected: FutureResult
[17:01:09.615] result() for ClusterFuture ... done
[17:01:09.616] result() for ClusterFuture ...
[17:01:09.616] - result already collected: FutureResult
[17:01:09.616] result() for ClusterFuture ... done
[17:01:09.616] - relayed: [n=2] TRUE, FALSE
[17:01:09.616] - queued futures: [n=2] TRUE, FALSE
[17:01:09.616] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:09.616]  length: 1 (resolved future 1)
[17:01:09.645] receiveMessageFromWorker() for ClusterFuture ...
[17:01:09.645] - Validating connection of MultisessionFuture
[17:01:09.646] - received message: FutureResult
[17:01:09.646] - Received FutureResult
[17:01:09.646] - Erased future from FutureRegistry
[17:01:09.646] result() for ClusterFuture ...
[17:01:09.646] - result already collected: FutureResult
[17:01:09.646] result() for ClusterFuture ... done
[17:01:09.646] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:09.646] Future #2
[17:01:09.646] result() for ClusterFuture ...
[17:01:09.646] - result already collected: FutureResult
[17:01:09.646] result() for ClusterFuture ... done
[17:01:09.647] result() for ClusterFuture ...
[17:01:09.647] - result already collected: FutureResult
[17:01:09.647] result() for ClusterFuture ... done
[17:01:09.647] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:09.647] - nx: 2
[17:01:09.647] - relay: TRUE
[17:01:09.647] - stdout: TRUE
[17:01:09.647] - signal: TRUE
[17:01:09.647] - resignal: FALSE
[17:01:09.647] - force: TRUE
[17:01:09.647] - relayed: [n=2] TRUE, FALSE
[17:01:09.648] - queued futures: [n=2] TRUE, FALSE
[17:01:09.648]  - until=2
[17:01:09.648]  - relaying element #2
[17:01:09.648] result() for ClusterFuture ...
[17:01:09.648] - result already collected: FutureResult
[17:01:09.648] result() for ClusterFuture ... done
[17:01:09.648] result() for ClusterFuture ...
[17:01:09.648] - result already collected: FutureResult
[17:01:09.648] result() for ClusterFuture ... done
[17:01:09.648] result() for ClusterFuture ...
[17:01:09.648] - result already collected: FutureResult
[17:01:09.649] result() for ClusterFuture ... done
[17:01:09.649] result() for ClusterFuture ...
[17:01:09.649] - result already collected: FutureResult
[17:01:09.649] result() for ClusterFuture ... done
[17:01:09.649] - relayed: [n=2] TRUE, TRUE
[17:01:09.649] - queued futures: [n=2] TRUE, TRUE
[17:01:09.649] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:09.649]  length: 0 (resolved future 2)
[17:01:09.649] Relaying remaining futures
[17:01:09.649] signalConditionsASAP(NULL, pos=0) ...
[17:01:09.649] - nx: 2
[17:01:09.649] - relay: TRUE
[17:01:09.650] - stdout: TRUE
[17:01:09.650] - signal: TRUE
[17:01:09.650] - resignal: FALSE
[17:01:09.650] - force: TRUE
[17:01:09.650] - relayed: [n=2] TRUE, TRUE
[17:01:09.650] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:09.650] - relayed: [n=2] TRUE, TRUE
[17:01:09.650] - queued futures: [n=2] TRUE, TRUE
[17:01:09.650] signalConditionsASAP(NULL, pos=0) ... done
[17:01:09.650] resolve() on list ... DONE
[17:01:09.650] result() for ClusterFuture ...
[17:01:09.651] - result already collected: FutureResult
[17:01:09.651] result() for ClusterFuture ... done
[17:01:09.651] result() for ClusterFuture ...
[17:01:09.651] - result already collected: FutureResult
[17:01:09.651] result() for ClusterFuture ... done
[17:01:09.651] result() for ClusterFuture ...
[17:01:09.651] - result already collected: FutureResult
[17:01:09.651] result() for ClusterFuture ... done
[17:01:09.651] result() for ClusterFuture ...
[17:01:09.651] - result already collected: FutureResult
[17:01:09.651] result() for ClusterFuture ... done
[17:01:09.652]  - Number of value chunks collected: 2
[17:01:09.652] Resolving 2 futures (chunks) ... DONE
[17:01:09.652] Reducing values from 2 chunks ...
[17:01:09.652]  - Number of values collected after concatenation: 4
[17:01:09.652]  - Number of values expected: 4
[17:01:09.652] Reducing values from 2 chunks ... DONE
[17:01:09.652] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:01:09.654] future_lapply() ...
[17:01:09.659] Number of chunks: 2
[17:01:09.659] getGlobalsAndPackagesXApply() ...
[17:01:09.659]  - future.globals: TRUE
[17:01:09.659] getGlobalsAndPackages() ...
[17:01:09.660] Searching for globals...
[17:01:09.662] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:09.663] Searching for globals ... DONE
[17:01:09.663] Resolving globals: FALSE
[17:01:09.664] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:01:09.664] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:09.664] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:09.664] - packages: [1] ‘future.apply’
[17:01:09.664] getGlobalsAndPackages() ... DONE
[17:01:09.664]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:09.665]  - needed namespaces: [n=1] ‘future.apply’
[17:01:09.665] Finding globals ... DONE
[17:01:09.665]  - use_args: TRUE
[17:01:09.665]  - Getting '...' globals ...
[17:01:09.665] resolve() on list ...
[17:01:09.665]  recursive: 0
[17:01:09.665]  length: 1
[17:01:09.665]  elements: ‘...’
[17:01:09.666]  length: 0 (resolved future 1)
[17:01:09.666] resolve() on list ... DONE
[17:01:09.666]    - '...' content: [n=0] 
[17:01:09.666] List of 1
[17:01:09.666]  $ ...: list()
[17:01:09.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.666]  - attr(*, "where")=List of 1
[17:01:09.666]   ..$ ...:<environment: 0x55aaddc0e338> 
[17:01:09.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.666]  - attr(*, "resolved")= logi TRUE
[17:01:09.666]  - attr(*, "total_size")= num NA
[17:01:09.668]  - Getting '...' globals ... DONE
[17:01:09.668] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:09.669] List of 8
[17:01:09.669]  $ ...future.FUN:function (x, ...)  
[17:01:09.669]  $ x_FUN        :function (x)  
[17:01:09.669]  $ times        : int 1
[17:01:09.669]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:09.669]  $ stop_if_not  :function (...)  
[17:01:09.669]  $ dim          : NULL
[17:01:09.669]  $ valid_types  : chr "logical"
[17:01:09.669]  $ ...          : list()
[17:01:09.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:09.669]  - attr(*, "where")=List of 8
[17:01:09.669]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:09.669]   ..$ ...          :<environment: 0x55aaddc0e338> 
[17:01:09.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:09.669]  - attr(*, "resolved")= logi FALSE
[17:01:09.669]  - attr(*, "total_size")= num 94200
[17:01:09.674] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:09.674] getGlobalsAndPackagesXApply() ... DONE
[17:01:09.674] Number of futures (= number of chunks): 2
[17:01:09.674] Launching 2 futures (chunks) ...
[17:01:09.674] Chunk #1 of 2 ...
[17:01:09.674]  - Finding globals in 'X' for chunk #1 ...
[17:01:09.674] getGlobalsAndPackages() ...
[17:01:09.675] Searching for globals...
[17:01:09.675] 
[17:01:09.675] Searching for globals ... DONE
[17:01:09.675] - globals: [0] <none>
[17:01:09.675] getGlobalsAndPackages() ... DONE
[17:01:09.675]    + additional globals found: [n=0] 
[17:01:09.675]    + additional namespaces needed: [n=0] 
[17:01:09.675]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:09.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.676]  - seeds: <none>
[17:01:09.676]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.676] getGlobalsAndPackages() ...
[17:01:09.676] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.676] Resolving globals: FALSE
[17:01:09.676] Tweak future expression to call with '...' arguments ...
[17:01:09.676] {
[17:01:09.676]     do.call(function(...) {
[17:01:09.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.676]             on.exit(options(oopts), add = TRUE)
[17:01:09.676]         }
[17:01:09.676]         {
[17:01:09.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.676]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.676]             })
[17:01:09.676]         }
[17:01:09.676]     }, args = future.call.arguments)
[17:01:09.676] }
[17:01:09.676] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.677] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.677] - packages: [1] ‘future.apply’
[17:01:09.677] getGlobalsAndPackages() ... DONE
[17:01:09.677] run() for ‘Future’ ...
[17:01:09.678] - state: ‘created’
[17:01:09.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.692] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.692]   - Field: ‘node’
[17:01:09.692]   - Field: ‘label’
[17:01:09.692]   - Field: ‘local’
[17:01:09.692]   - Field: ‘owner’
[17:01:09.692]   - Field: ‘envir’
[17:01:09.692]   - Field: ‘workers’
[17:01:09.693]   - Field: ‘packages’
[17:01:09.693]   - Field: ‘gc’
[17:01:09.693]   - Field: ‘conditions’
[17:01:09.693]   - Field: ‘persistent’
[17:01:09.693]   - Field: ‘expr’
[17:01:09.693]   - Field: ‘uuid’
[17:01:09.693]   - Field: ‘seed’
[17:01:09.693]   - Field: ‘version’
[17:01:09.693]   - Field: ‘result’
[17:01:09.693]   - Field: ‘asynchronous’
[17:01:09.693]   - Field: ‘calls’
[17:01:09.694]   - Field: ‘globals’
[17:01:09.694]   - Field: ‘stdout’
[17:01:09.694]   - Field: ‘earlySignal’
[17:01:09.694]   - Field: ‘lazy’
[17:01:09.694]   - Field: ‘state’
[17:01:09.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.694] - Launch lazy future ...
[17:01:09.694] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:09.694] Packages needed by future strategies (n = 0): <none>
[17:01:09.695] {
[17:01:09.695]     {
[17:01:09.695]         {
[17:01:09.695]             ...future.startTime <- base::Sys.time()
[17:01:09.695]             {
[17:01:09.695]                 {
[17:01:09.695]                   {
[17:01:09.695]                     {
[17:01:09.695]                       {
[17:01:09.695]                         base::local({
[17:01:09.695]                           has_future <- base::requireNamespace("future", 
[17:01:09.695]                             quietly = TRUE)
[17:01:09.695]                           if (has_future) {
[17:01:09.695]                             ns <- base::getNamespace("future")
[17:01:09.695]                             version <- ns[[".package"]][["version"]]
[17:01:09.695]                             if (is.null(version)) 
[17:01:09.695]                               version <- utils::packageVersion("future")
[17:01:09.695]                           }
[17:01:09.695]                           else {
[17:01:09.695]                             version <- NULL
[17:01:09.695]                           }
[17:01:09.695]                           if (!has_future || version < "1.8.0") {
[17:01:09.695]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.695]                               "", base::R.version$version.string), 
[17:01:09.695]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:09.695]                                 base::R.version$platform, 8 * 
[17:01:09.695]                                   base::.Machine$sizeof.pointer), 
[17:01:09.695]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.695]                                 "release", "version")], collapse = " "), 
[17:01:09.695]                               hostname = base::Sys.info()[["nodename"]])
[17:01:09.695]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.695]                               info)
[17:01:09.695]                             info <- base::paste(info, collapse = "; ")
[17:01:09.695]                             if (!has_future) {
[17:01:09.695]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.695]                                 info)
[17:01:09.695]                             }
[17:01:09.695]                             else {
[17:01:09.695]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.695]                                 info, version)
[17:01:09.695]                             }
[17:01:09.695]                             base::stop(msg)
[17:01:09.695]                           }
[17:01:09.695]                         })
[17:01:09.695]                       }
[17:01:09.695]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.695]                       base::options(mc.cores = 1L)
[17:01:09.695]                     }
[17:01:09.695]                     base::local({
[17:01:09.695]                       for (pkg in "future.apply") {
[17:01:09.695]                         base::loadNamespace(pkg)
[17:01:09.695]                         base::library(pkg, character.only = TRUE)
[17:01:09.695]                       }
[17:01:09.695]                     })
[17:01:09.695]                   }
[17:01:09.695]                   ...future.strategy.old <- future::plan("list")
[17:01:09.695]                   options(future.plan = NULL)
[17:01:09.695]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.695]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.695]                 }
[17:01:09.695]                 ...future.workdir <- getwd()
[17:01:09.695]             }
[17:01:09.695]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.695]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.695]         }
[17:01:09.695]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.695]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.695]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.695]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.695]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.695]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.695]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.695]             base::names(...future.oldOptions))
[17:01:09.695]     }
[17:01:09.695]     if (FALSE) {
[17:01:09.695]     }
[17:01:09.695]     else {
[17:01:09.695]         if (TRUE) {
[17:01:09.695]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.695]                 open = "w")
[17:01:09.695]         }
[17:01:09.695]         else {
[17:01:09.695]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.695]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.695]         }
[17:01:09.695]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.695]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.695]             base::sink(type = "output", split = FALSE)
[17:01:09.695]             base::close(...future.stdout)
[17:01:09.695]         }, add = TRUE)
[17:01:09.695]     }
[17:01:09.695]     ...future.frame <- base::sys.nframe()
[17:01:09.695]     ...future.conditions <- base::list()
[17:01:09.695]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.695]     if (FALSE) {
[17:01:09.695]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.695]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.695]     }
[17:01:09.695]     ...future.result <- base::tryCatch({
[17:01:09.695]         base::withCallingHandlers({
[17:01:09.695]             ...future.value <- base::withVisible(base::local({
[17:01:09.695]                 ...future.makeSendCondition <- base::local({
[17:01:09.695]                   sendCondition <- NULL
[17:01:09.695]                   function(frame = 1L) {
[17:01:09.695]                     if (is.function(sendCondition)) 
[17:01:09.695]                       return(sendCondition)
[17:01:09.695]                     ns <- getNamespace("parallel")
[17:01:09.695]                     if (exists("sendData", mode = "function", 
[17:01:09.695]                       envir = ns)) {
[17:01:09.695]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.695]                         envir = ns)
[17:01:09.695]                       envir <- sys.frame(frame)
[17:01:09.695]                       master <- NULL
[17:01:09.695]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.695]                         !identical(envir, emptyenv())) {
[17:01:09.695]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.695]                           inherits = FALSE)) {
[17:01:09.695]                           master <- get("master", mode = "list", 
[17:01:09.695]                             envir = envir, inherits = FALSE)
[17:01:09.695]                           if (inherits(master, c("SOCKnode", 
[17:01:09.695]                             "SOCK0node"))) {
[17:01:09.695]                             sendCondition <<- function(cond) {
[17:01:09.695]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.695]                                 success = TRUE)
[17:01:09.695]                               parallel_sendData(master, data)
[17:01:09.695]                             }
[17:01:09.695]                             return(sendCondition)
[17:01:09.695]                           }
[17:01:09.695]                         }
[17:01:09.695]                         frame <- frame + 1L
[17:01:09.695]                         envir <- sys.frame(frame)
[17:01:09.695]                       }
[17:01:09.695]                     }
[17:01:09.695]                     sendCondition <<- function(cond) NULL
[17:01:09.695]                   }
[17:01:09.695]                 })
[17:01:09.695]                 withCallingHandlers({
[17:01:09.695]                   {
[17:01:09.695]                     do.call(function(...) {
[17:01:09.695]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.695]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.695]                         ...future.globals.maxSize)) {
[17:01:09.695]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.695]                         on.exit(options(oopts), add = TRUE)
[17:01:09.695]                       }
[17:01:09.695]                       {
[17:01:09.695]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.695]                           FUN = function(jj) {
[17:01:09.695]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.695]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.695]                           })
[17:01:09.695]                       }
[17:01:09.695]                     }, args = future.call.arguments)
[17:01:09.695]                   }
[17:01:09.695]                 }, immediateCondition = function(cond) {
[17:01:09.695]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.695]                   sendCondition(cond)
[17:01:09.695]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.695]                   {
[17:01:09.695]                     inherits <- base::inherits
[17:01:09.695]                     invokeRestart <- base::invokeRestart
[17:01:09.695]                     is.null <- base::is.null
[17:01:09.695]                     muffled <- FALSE
[17:01:09.695]                     if (inherits(cond, "message")) {
[17:01:09.695]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.695]                       if (muffled) 
[17:01:09.695]                         invokeRestart("muffleMessage")
[17:01:09.695]                     }
[17:01:09.695]                     else if (inherits(cond, "warning")) {
[17:01:09.695]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.695]                       if (muffled) 
[17:01:09.695]                         invokeRestart("muffleWarning")
[17:01:09.695]                     }
[17:01:09.695]                     else if (inherits(cond, "condition")) {
[17:01:09.695]                       if (!is.null(pattern)) {
[17:01:09.695]                         computeRestarts <- base::computeRestarts
[17:01:09.695]                         grepl <- base::grepl
[17:01:09.695]                         restarts <- computeRestarts(cond)
[17:01:09.695]                         for (restart in restarts) {
[17:01:09.695]                           name <- restart$name
[17:01:09.695]                           if (is.null(name)) 
[17:01:09.695]                             next
[17:01:09.695]                           if (!grepl(pattern, name)) 
[17:01:09.695]                             next
[17:01:09.695]                           invokeRestart(restart)
[17:01:09.695]                           muffled <- TRUE
[17:01:09.695]                           break
[17:01:09.695]                         }
[17:01:09.695]                       }
[17:01:09.695]                     }
[17:01:09.695]                     invisible(muffled)
[17:01:09.695]                   }
[17:01:09.695]                   muffleCondition(cond)
[17:01:09.695]                 })
[17:01:09.695]             }))
[17:01:09.695]             future::FutureResult(value = ...future.value$value, 
[17:01:09.695]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.695]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.695]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.695]                     ...future.globalenv.names))
[17:01:09.695]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.695]         }, condition = base::local({
[17:01:09.695]             c <- base::c
[17:01:09.695]             inherits <- base::inherits
[17:01:09.695]             invokeRestart <- base::invokeRestart
[17:01:09.695]             length <- base::length
[17:01:09.695]             list <- base::list
[17:01:09.695]             seq.int <- base::seq.int
[17:01:09.695]             signalCondition <- base::signalCondition
[17:01:09.695]             sys.calls <- base::sys.calls
[17:01:09.695]             `[[` <- base::`[[`
[17:01:09.695]             `+` <- base::`+`
[17:01:09.695]             `<<-` <- base::`<<-`
[17:01:09.695]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.695]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.695]                   3L)]
[17:01:09.695]             }
[17:01:09.695]             function(cond) {
[17:01:09.695]                 is_error <- inherits(cond, "error")
[17:01:09.695]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.695]                   NULL)
[17:01:09.695]                 if (is_error) {
[17:01:09.695]                   sessionInformation <- function() {
[17:01:09.695]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.695]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.695]                       search = base::search(), system = base::Sys.info())
[17:01:09.695]                   }
[17:01:09.695]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.695]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.695]                     cond$call), session = sessionInformation(), 
[17:01:09.695]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.695]                   signalCondition(cond)
[17:01:09.695]                 }
[17:01:09.695]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.695]                 "immediateCondition"))) {
[17:01:09.695]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.695]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.695]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.695]                   if (TRUE && !signal) {
[17:01:09.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.695]                     {
[17:01:09.695]                       inherits <- base::inherits
[17:01:09.695]                       invokeRestart <- base::invokeRestart
[17:01:09.695]                       is.null <- base::is.null
[17:01:09.695]                       muffled <- FALSE
[17:01:09.695]                       if (inherits(cond, "message")) {
[17:01:09.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.695]                         if (muffled) 
[17:01:09.695]                           invokeRestart("muffleMessage")
[17:01:09.695]                       }
[17:01:09.695]                       else if (inherits(cond, "warning")) {
[17:01:09.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.695]                         if (muffled) 
[17:01:09.695]                           invokeRestart("muffleWarning")
[17:01:09.695]                       }
[17:01:09.695]                       else if (inherits(cond, "condition")) {
[17:01:09.695]                         if (!is.null(pattern)) {
[17:01:09.695]                           computeRestarts <- base::computeRestarts
[17:01:09.695]                           grepl <- base::grepl
[17:01:09.695]                           restarts <- computeRestarts(cond)
[17:01:09.695]                           for (restart in restarts) {
[17:01:09.695]                             name <- restart$name
[17:01:09.695]                             if (is.null(name)) 
[17:01:09.695]                               next
[17:01:09.695]                             if (!grepl(pattern, name)) 
[17:01:09.695]                               next
[17:01:09.695]                             invokeRestart(restart)
[17:01:09.695]                             muffled <- TRUE
[17:01:09.695]                             break
[17:01:09.695]                           }
[17:01:09.695]                         }
[17:01:09.695]                       }
[17:01:09.695]                       invisible(muffled)
[17:01:09.695]                     }
[17:01:09.695]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.695]                   }
[17:01:09.695]                 }
[17:01:09.695]                 else {
[17:01:09.695]                   if (TRUE) {
[17:01:09.695]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.695]                     {
[17:01:09.695]                       inherits <- base::inherits
[17:01:09.695]                       invokeRestart <- base::invokeRestart
[17:01:09.695]                       is.null <- base::is.null
[17:01:09.695]                       muffled <- FALSE
[17:01:09.695]                       if (inherits(cond, "message")) {
[17:01:09.695]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.695]                         if (muffled) 
[17:01:09.695]                           invokeRestart("muffleMessage")
[17:01:09.695]                       }
[17:01:09.695]                       else if (inherits(cond, "warning")) {
[17:01:09.695]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.695]                         if (muffled) 
[17:01:09.695]                           invokeRestart("muffleWarning")
[17:01:09.695]                       }
[17:01:09.695]                       else if (inherits(cond, "condition")) {
[17:01:09.695]                         if (!is.null(pattern)) {
[17:01:09.695]                           computeRestarts <- base::computeRestarts
[17:01:09.695]                           grepl <- base::grepl
[17:01:09.695]                           restarts <- computeRestarts(cond)
[17:01:09.695]                           for (restart in restarts) {
[17:01:09.695]                             name <- restart$name
[17:01:09.695]                             if (is.null(name)) 
[17:01:09.695]                               next
[17:01:09.695]                             if (!grepl(pattern, name)) 
[17:01:09.695]                               next
[17:01:09.695]                             invokeRestart(restart)
[17:01:09.695]                             muffled <- TRUE
[17:01:09.695]                             break
[17:01:09.695]                           }
[17:01:09.695]                         }
[17:01:09.695]                       }
[17:01:09.695]                       invisible(muffled)
[17:01:09.695]                     }
[17:01:09.695]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.695]                   }
[17:01:09.695]                 }
[17:01:09.695]             }
[17:01:09.695]         }))
[17:01:09.695]     }, error = function(ex) {
[17:01:09.695]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.695]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.695]                 ...future.rng), started = ...future.startTime, 
[17:01:09.695]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.695]             version = "1.8"), class = "FutureResult")
[17:01:09.695]     }, finally = {
[17:01:09.695]         if (!identical(...future.workdir, getwd())) 
[17:01:09.695]             setwd(...future.workdir)
[17:01:09.695]         {
[17:01:09.695]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.695]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.695]             }
[17:01:09.695]             base::options(...future.oldOptions)
[17:01:09.695]             if (.Platform$OS.type == "windows") {
[17:01:09.695]                 old_names <- names(...future.oldEnvVars)
[17:01:09.695]                 envs <- base::Sys.getenv()
[17:01:09.695]                 names <- names(envs)
[17:01:09.695]                 common <- intersect(names, old_names)
[17:01:09.695]                 added <- setdiff(names, old_names)
[17:01:09.695]                 removed <- setdiff(old_names, names)
[17:01:09.695]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.695]                   envs[common]]
[17:01:09.695]                 NAMES <- toupper(changed)
[17:01:09.695]                 args <- list()
[17:01:09.695]                 for (kk in seq_along(NAMES)) {
[17:01:09.695]                   name <- changed[[kk]]
[17:01:09.695]                   NAME <- NAMES[[kk]]
[17:01:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.695]                     next
[17:01:09.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.695]                 }
[17:01:09.695]                 NAMES <- toupper(added)
[17:01:09.695]                 for (kk in seq_along(NAMES)) {
[17:01:09.695]                   name <- added[[kk]]
[17:01:09.695]                   NAME <- NAMES[[kk]]
[17:01:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.695]                     next
[17:01:09.695]                   args[[name]] <- ""
[17:01:09.695]                 }
[17:01:09.695]                 NAMES <- toupper(removed)
[17:01:09.695]                 for (kk in seq_along(NAMES)) {
[17:01:09.695]                   name <- removed[[kk]]
[17:01:09.695]                   NAME <- NAMES[[kk]]
[17:01:09.695]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.695]                     next
[17:01:09.695]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.695]                 }
[17:01:09.695]                 if (length(args) > 0) 
[17:01:09.695]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.695]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.695]             }
[17:01:09.695]             else {
[17:01:09.695]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.695]             }
[17:01:09.695]             {
[17:01:09.695]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.695]                   0L) {
[17:01:09.695]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.695]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.695]                   base::options(opts)
[17:01:09.695]                 }
[17:01:09.695]                 {
[17:01:09.695]                   {
[17:01:09.695]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.695]                     NULL
[17:01:09.695]                   }
[17:01:09.695]                   options(future.plan = NULL)
[17:01:09.695]                   if (is.na(NA_character_)) 
[17:01:09.695]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.695]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.695]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.695]                     .init = FALSE)
[17:01:09.695]                 }
[17:01:09.695]             }
[17:01:09.695]         }
[17:01:09.695]     })
[17:01:09.695]     if (TRUE) {
[17:01:09.695]         base::sink(type = "output", split = FALSE)
[17:01:09.695]         if (TRUE) {
[17:01:09.695]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.695]         }
[17:01:09.695]         else {
[17:01:09.695]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.695]         }
[17:01:09.695]         base::close(...future.stdout)
[17:01:09.695]         ...future.stdout <- NULL
[17:01:09.695]     }
[17:01:09.695]     ...future.result$conditions <- ...future.conditions
[17:01:09.695]     ...future.result$finished <- base::Sys.time()
[17:01:09.695]     ...future.result
[17:01:09.695] }
[17:01:09.698] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[17:01:09.698] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:09.740] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:09.740] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:01:09.741] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.741] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:09.741] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:09.741] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:09.784] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:09.784] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:09.828] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:09.828] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:09.828] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.829] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[17:01:09.829] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[17:01:09.832] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:09.832] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.832] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[17:01:09.833] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[17:01:09.833] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:09.833] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.834] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:09.834] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:09.834] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[17:01:09.835] MultisessionFuture started
[17:01:09.835] - Launch lazy future ... done
[17:01:09.835] run() for ‘MultisessionFuture’ ... done
[17:01:09.835] Created future:
[17:01:09.835] MultisessionFuture:
[17:01:09.835] Label: ‘future_vapply-1’
[17:01:09.835] Expression:
[17:01:09.835] {
[17:01:09.835]     do.call(function(...) {
[17:01:09.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.835]             on.exit(options(oopts), add = TRUE)
[17:01:09.835]         }
[17:01:09.835]         {
[17:01:09.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.835]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.835]             })
[17:01:09.835]         }
[17:01:09.835]     }, args = future.call.arguments)
[17:01:09.835] }
[17:01:09.835] Lazy evaluation: FALSE
[17:01:09.835] Asynchronous evaluation: TRUE
[17:01:09.835] Local evaluation: TRUE
[17:01:09.835] Environment: R_GlobalEnv
[17:01:09.835] Capture standard output: TRUE
[17:01:09.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:09.835] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:09.835] Packages: 1 packages (‘future.apply’)
[17:01:09.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:09.835] Resolved: FALSE
[17:01:09.835] Value: <not collected>
[17:01:09.835] Conditions captured: <none>
[17:01:09.835] Early signaling: FALSE
[17:01:09.835] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:09.835] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.847] Chunk #1 of 2 ... DONE
[17:01:09.847] Chunk #2 of 2 ...
[17:01:09.847]  - Finding globals in 'X' for chunk #2 ...
[17:01:09.847] getGlobalsAndPackages() ...
[17:01:09.848] Searching for globals...
[17:01:09.848] 
[17:01:09.848] Searching for globals ... DONE
[17:01:09.848] - globals: [0] <none>
[17:01:09.848] getGlobalsAndPackages() ... DONE
[17:01:09.848]    + additional globals found: [n=0] 
[17:01:09.848]    + additional namespaces needed: [n=0] 
[17:01:09.848]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:09.849]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:09.849]  - seeds: <none>
[17:01:09.849]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.849] getGlobalsAndPackages() ...
[17:01:09.849] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.849] Resolving globals: FALSE
[17:01:09.849] Tweak future expression to call with '...' arguments ...
[17:01:09.849] {
[17:01:09.849]     do.call(function(...) {
[17:01:09.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:09.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.849]             on.exit(options(oopts), add = TRUE)
[17:01:09.849]         }
[17:01:09.849]         {
[17:01:09.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:09.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.849]                 ...future.FUN(...future.X_jj, ...)
[17:01:09.849]             })
[17:01:09.849]         }
[17:01:09.849]     }, args = future.call.arguments)
[17:01:09.849] }
[17:01:09.850] Tweak future expression to call with '...' arguments ... DONE
[17:01:09.850] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:09.850] - packages: [1] ‘future.apply’
[17:01:09.850] getGlobalsAndPackages() ... DONE
[17:01:09.851] run() for ‘Future’ ...
[17:01:09.851] - state: ‘created’
[17:01:09.851] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:09.865] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:09.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:09.865]   - Field: ‘node’
[17:01:09.865]   - Field: ‘label’
[17:01:09.865]   - Field: ‘local’
[17:01:09.865]   - Field: ‘owner’
[17:01:09.865]   - Field: ‘envir’
[17:01:09.866]   - Field: ‘workers’
[17:01:09.866]   - Field: ‘packages’
[17:01:09.866]   - Field: ‘gc’
[17:01:09.866]   - Field: ‘conditions’
[17:01:09.866]   - Field: ‘persistent’
[17:01:09.866]   - Field: ‘expr’
[17:01:09.866]   - Field: ‘uuid’
[17:01:09.866]   - Field: ‘seed’
[17:01:09.866]   - Field: ‘version’
[17:01:09.866]   - Field: ‘result’
[17:01:09.866]   - Field: ‘asynchronous’
[17:01:09.867]   - Field: ‘calls’
[17:01:09.867]   - Field: ‘globals’
[17:01:09.867]   - Field: ‘stdout’
[17:01:09.867]   - Field: ‘earlySignal’
[17:01:09.867]   - Field: ‘lazy’
[17:01:09.867]   - Field: ‘state’
[17:01:09.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:09.867] - Launch lazy future ...
[17:01:09.868] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:09.868] Packages needed by future strategies (n = 0): <none>
[17:01:09.868] {
[17:01:09.868]     {
[17:01:09.868]         {
[17:01:09.868]             ...future.startTime <- base::Sys.time()
[17:01:09.868]             {
[17:01:09.868]                 {
[17:01:09.868]                   {
[17:01:09.868]                     {
[17:01:09.868]                       {
[17:01:09.868]                         base::local({
[17:01:09.868]                           has_future <- base::requireNamespace("future", 
[17:01:09.868]                             quietly = TRUE)
[17:01:09.868]                           if (has_future) {
[17:01:09.868]                             ns <- base::getNamespace("future")
[17:01:09.868]                             version <- ns[[".package"]][["version"]]
[17:01:09.868]                             if (is.null(version)) 
[17:01:09.868]                               version <- utils::packageVersion("future")
[17:01:09.868]                           }
[17:01:09.868]                           else {
[17:01:09.868]                             version <- NULL
[17:01:09.868]                           }
[17:01:09.868]                           if (!has_future || version < "1.8.0") {
[17:01:09.868]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:09.868]                               "", base::R.version$version.string), 
[17:01:09.868]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:09.868]                                 base::R.version$platform, 8 * 
[17:01:09.868]                                   base::.Machine$sizeof.pointer), 
[17:01:09.868]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:09.868]                                 "release", "version")], collapse = " "), 
[17:01:09.868]                               hostname = base::Sys.info()[["nodename"]])
[17:01:09.868]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:09.868]                               info)
[17:01:09.868]                             info <- base::paste(info, collapse = "; ")
[17:01:09.868]                             if (!has_future) {
[17:01:09.868]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:09.868]                                 info)
[17:01:09.868]                             }
[17:01:09.868]                             else {
[17:01:09.868]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:09.868]                                 info, version)
[17:01:09.868]                             }
[17:01:09.868]                             base::stop(msg)
[17:01:09.868]                           }
[17:01:09.868]                         })
[17:01:09.868]                       }
[17:01:09.868]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:09.868]                       base::options(mc.cores = 1L)
[17:01:09.868]                     }
[17:01:09.868]                     base::local({
[17:01:09.868]                       for (pkg in "future.apply") {
[17:01:09.868]                         base::loadNamespace(pkg)
[17:01:09.868]                         base::library(pkg, character.only = TRUE)
[17:01:09.868]                       }
[17:01:09.868]                     })
[17:01:09.868]                   }
[17:01:09.868]                   ...future.strategy.old <- future::plan("list")
[17:01:09.868]                   options(future.plan = NULL)
[17:01:09.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:09.868]                 }
[17:01:09.868]                 ...future.workdir <- getwd()
[17:01:09.868]             }
[17:01:09.868]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:09.868]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:09.868]         }
[17:01:09.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:09.868]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:09.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:09.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:09.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:09.868]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:09.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:09.868]             base::names(...future.oldOptions))
[17:01:09.868]     }
[17:01:09.868]     if (FALSE) {
[17:01:09.868]     }
[17:01:09.868]     else {
[17:01:09.868]         if (TRUE) {
[17:01:09.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:09.868]                 open = "w")
[17:01:09.868]         }
[17:01:09.868]         else {
[17:01:09.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:09.868]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:09.868]         }
[17:01:09.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:09.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:09.868]             base::sink(type = "output", split = FALSE)
[17:01:09.868]             base::close(...future.stdout)
[17:01:09.868]         }, add = TRUE)
[17:01:09.868]     }
[17:01:09.868]     ...future.frame <- base::sys.nframe()
[17:01:09.868]     ...future.conditions <- base::list()
[17:01:09.868]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:09.868]     if (FALSE) {
[17:01:09.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:09.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:09.868]     }
[17:01:09.868]     ...future.result <- base::tryCatch({
[17:01:09.868]         base::withCallingHandlers({
[17:01:09.868]             ...future.value <- base::withVisible(base::local({
[17:01:09.868]                 ...future.makeSendCondition <- base::local({
[17:01:09.868]                   sendCondition <- NULL
[17:01:09.868]                   function(frame = 1L) {
[17:01:09.868]                     if (is.function(sendCondition)) 
[17:01:09.868]                       return(sendCondition)
[17:01:09.868]                     ns <- getNamespace("parallel")
[17:01:09.868]                     if (exists("sendData", mode = "function", 
[17:01:09.868]                       envir = ns)) {
[17:01:09.868]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:09.868]                         envir = ns)
[17:01:09.868]                       envir <- sys.frame(frame)
[17:01:09.868]                       master <- NULL
[17:01:09.868]                       while (!identical(envir, .GlobalEnv) && 
[17:01:09.868]                         !identical(envir, emptyenv())) {
[17:01:09.868]                         if (exists("master", mode = "list", envir = envir, 
[17:01:09.868]                           inherits = FALSE)) {
[17:01:09.868]                           master <- get("master", mode = "list", 
[17:01:09.868]                             envir = envir, inherits = FALSE)
[17:01:09.868]                           if (inherits(master, c("SOCKnode", 
[17:01:09.868]                             "SOCK0node"))) {
[17:01:09.868]                             sendCondition <<- function(cond) {
[17:01:09.868]                               data <- list(type = "VALUE", value = cond, 
[17:01:09.868]                                 success = TRUE)
[17:01:09.868]                               parallel_sendData(master, data)
[17:01:09.868]                             }
[17:01:09.868]                             return(sendCondition)
[17:01:09.868]                           }
[17:01:09.868]                         }
[17:01:09.868]                         frame <- frame + 1L
[17:01:09.868]                         envir <- sys.frame(frame)
[17:01:09.868]                       }
[17:01:09.868]                     }
[17:01:09.868]                     sendCondition <<- function(cond) NULL
[17:01:09.868]                   }
[17:01:09.868]                 })
[17:01:09.868]                 withCallingHandlers({
[17:01:09.868]                   {
[17:01:09.868]                     do.call(function(...) {
[17:01:09.868]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:09.868]                       if (!identical(...future.globals.maxSize.org, 
[17:01:09.868]                         ...future.globals.maxSize)) {
[17:01:09.868]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:09.868]                         on.exit(options(oopts), add = TRUE)
[17:01:09.868]                       }
[17:01:09.868]                       {
[17:01:09.868]                         lapply(seq_along(...future.elements_ii), 
[17:01:09.868]                           FUN = function(jj) {
[17:01:09.868]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:09.868]                             ...future.FUN(...future.X_jj, ...)
[17:01:09.868]                           })
[17:01:09.868]                       }
[17:01:09.868]                     }, args = future.call.arguments)
[17:01:09.868]                   }
[17:01:09.868]                 }, immediateCondition = function(cond) {
[17:01:09.868]                   sendCondition <- ...future.makeSendCondition()
[17:01:09.868]                   sendCondition(cond)
[17:01:09.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.868]                   {
[17:01:09.868]                     inherits <- base::inherits
[17:01:09.868]                     invokeRestart <- base::invokeRestart
[17:01:09.868]                     is.null <- base::is.null
[17:01:09.868]                     muffled <- FALSE
[17:01:09.868]                     if (inherits(cond, "message")) {
[17:01:09.868]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:09.868]                       if (muffled) 
[17:01:09.868]                         invokeRestart("muffleMessage")
[17:01:09.868]                     }
[17:01:09.868]                     else if (inherits(cond, "warning")) {
[17:01:09.868]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:09.868]                       if (muffled) 
[17:01:09.868]                         invokeRestart("muffleWarning")
[17:01:09.868]                     }
[17:01:09.868]                     else if (inherits(cond, "condition")) {
[17:01:09.868]                       if (!is.null(pattern)) {
[17:01:09.868]                         computeRestarts <- base::computeRestarts
[17:01:09.868]                         grepl <- base::grepl
[17:01:09.868]                         restarts <- computeRestarts(cond)
[17:01:09.868]                         for (restart in restarts) {
[17:01:09.868]                           name <- restart$name
[17:01:09.868]                           if (is.null(name)) 
[17:01:09.868]                             next
[17:01:09.868]                           if (!grepl(pattern, name)) 
[17:01:09.868]                             next
[17:01:09.868]                           invokeRestart(restart)
[17:01:09.868]                           muffled <- TRUE
[17:01:09.868]                           break
[17:01:09.868]                         }
[17:01:09.868]                       }
[17:01:09.868]                     }
[17:01:09.868]                     invisible(muffled)
[17:01:09.868]                   }
[17:01:09.868]                   muffleCondition(cond)
[17:01:09.868]                 })
[17:01:09.868]             }))
[17:01:09.868]             future::FutureResult(value = ...future.value$value, 
[17:01:09.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.868]                   ...future.rng), globalenv = if (FALSE) 
[17:01:09.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:09.868]                     ...future.globalenv.names))
[17:01:09.868]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:09.868]         }, condition = base::local({
[17:01:09.868]             c <- base::c
[17:01:09.868]             inherits <- base::inherits
[17:01:09.868]             invokeRestart <- base::invokeRestart
[17:01:09.868]             length <- base::length
[17:01:09.868]             list <- base::list
[17:01:09.868]             seq.int <- base::seq.int
[17:01:09.868]             signalCondition <- base::signalCondition
[17:01:09.868]             sys.calls <- base::sys.calls
[17:01:09.868]             `[[` <- base::`[[`
[17:01:09.868]             `+` <- base::`+`
[17:01:09.868]             `<<-` <- base::`<<-`
[17:01:09.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:09.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:09.868]                   3L)]
[17:01:09.868]             }
[17:01:09.868]             function(cond) {
[17:01:09.868]                 is_error <- inherits(cond, "error")
[17:01:09.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:09.868]                   NULL)
[17:01:09.868]                 if (is_error) {
[17:01:09.868]                   sessionInformation <- function() {
[17:01:09.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:09.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:09.868]                       search = base::search(), system = base::Sys.info())
[17:01:09.868]                   }
[17:01:09.868]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:09.868]                     cond$call), session = sessionInformation(), 
[17:01:09.868]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:09.868]                   signalCondition(cond)
[17:01:09.868]                 }
[17:01:09.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:09.868]                 "immediateCondition"))) {
[17:01:09.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:09.868]                   ...future.conditions[[length(...future.conditions) + 
[17:01:09.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:09.868]                   if (TRUE && !signal) {
[17:01:09.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.868]                     {
[17:01:09.868]                       inherits <- base::inherits
[17:01:09.868]                       invokeRestart <- base::invokeRestart
[17:01:09.868]                       is.null <- base::is.null
[17:01:09.868]                       muffled <- FALSE
[17:01:09.868]                       if (inherits(cond, "message")) {
[17:01:09.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.868]                         if (muffled) 
[17:01:09.868]                           invokeRestart("muffleMessage")
[17:01:09.868]                       }
[17:01:09.868]                       else if (inherits(cond, "warning")) {
[17:01:09.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.868]                         if (muffled) 
[17:01:09.868]                           invokeRestart("muffleWarning")
[17:01:09.868]                       }
[17:01:09.868]                       else if (inherits(cond, "condition")) {
[17:01:09.868]                         if (!is.null(pattern)) {
[17:01:09.868]                           computeRestarts <- base::computeRestarts
[17:01:09.868]                           grepl <- base::grepl
[17:01:09.868]                           restarts <- computeRestarts(cond)
[17:01:09.868]                           for (restart in restarts) {
[17:01:09.868]                             name <- restart$name
[17:01:09.868]                             if (is.null(name)) 
[17:01:09.868]                               next
[17:01:09.868]                             if (!grepl(pattern, name)) 
[17:01:09.868]                               next
[17:01:09.868]                             invokeRestart(restart)
[17:01:09.868]                             muffled <- TRUE
[17:01:09.868]                             break
[17:01:09.868]                           }
[17:01:09.868]                         }
[17:01:09.868]                       }
[17:01:09.868]                       invisible(muffled)
[17:01:09.868]                     }
[17:01:09.868]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.868]                   }
[17:01:09.868]                 }
[17:01:09.868]                 else {
[17:01:09.868]                   if (TRUE) {
[17:01:09.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:09.868]                     {
[17:01:09.868]                       inherits <- base::inherits
[17:01:09.868]                       invokeRestart <- base::invokeRestart
[17:01:09.868]                       is.null <- base::is.null
[17:01:09.868]                       muffled <- FALSE
[17:01:09.868]                       if (inherits(cond, "message")) {
[17:01:09.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:09.868]                         if (muffled) 
[17:01:09.868]                           invokeRestart("muffleMessage")
[17:01:09.868]                       }
[17:01:09.868]                       else if (inherits(cond, "warning")) {
[17:01:09.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:09.868]                         if (muffled) 
[17:01:09.868]                           invokeRestart("muffleWarning")
[17:01:09.868]                       }
[17:01:09.868]                       else if (inherits(cond, "condition")) {
[17:01:09.868]                         if (!is.null(pattern)) {
[17:01:09.868]                           computeRestarts <- base::computeRestarts
[17:01:09.868]                           grepl <- base::grepl
[17:01:09.868]                           restarts <- computeRestarts(cond)
[17:01:09.868]                           for (restart in restarts) {
[17:01:09.868]                             name <- restart$name
[17:01:09.868]                             if (is.null(name)) 
[17:01:09.868]                               next
[17:01:09.868]                             if (!grepl(pattern, name)) 
[17:01:09.868]                               next
[17:01:09.868]                             invokeRestart(restart)
[17:01:09.868]                             muffled <- TRUE
[17:01:09.868]                             break
[17:01:09.868]                           }
[17:01:09.868]                         }
[17:01:09.868]                       }
[17:01:09.868]                       invisible(muffled)
[17:01:09.868]                     }
[17:01:09.868]                     muffleCondition(cond, pattern = "^muffle")
[17:01:09.868]                   }
[17:01:09.868]                 }
[17:01:09.868]             }
[17:01:09.868]         }))
[17:01:09.868]     }, error = function(ex) {
[17:01:09.868]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:09.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:09.868]                 ...future.rng), started = ...future.startTime, 
[17:01:09.868]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:09.868]             version = "1.8"), class = "FutureResult")
[17:01:09.868]     }, finally = {
[17:01:09.868]         if (!identical(...future.workdir, getwd())) 
[17:01:09.868]             setwd(...future.workdir)
[17:01:09.868]         {
[17:01:09.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:09.868]                 ...future.oldOptions$nwarnings <- NULL
[17:01:09.868]             }
[17:01:09.868]             base::options(...future.oldOptions)
[17:01:09.868]             if (.Platform$OS.type == "windows") {
[17:01:09.868]                 old_names <- names(...future.oldEnvVars)
[17:01:09.868]                 envs <- base::Sys.getenv()
[17:01:09.868]                 names <- names(envs)
[17:01:09.868]                 common <- intersect(names, old_names)
[17:01:09.868]                 added <- setdiff(names, old_names)
[17:01:09.868]                 removed <- setdiff(old_names, names)
[17:01:09.868]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:09.868]                   envs[common]]
[17:01:09.868]                 NAMES <- toupper(changed)
[17:01:09.868]                 args <- list()
[17:01:09.868]                 for (kk in seq_along(NAMES)) {
[17:01:09.868]                   name <- changed[[kk]]
[17:01:09.868]                   NAME <- NAMES[[kk]]
[17:01:09.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.868]                     next
[17:01:09.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.868]                 }
[17:01:09.868]                 NAMES <- toupper(added)
[17:01:09.868]                 for (kk in seq_along(NAMES)) {
[17:01:09.868]                   name <- added[[kk]]
[17:01:09.868]                   NAME <- NAMES[[kk]]
[17:01:09.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.868]                     next
[17:01:09.868]                   args[[name]] <- ""
[17:01:09.868]                 }
[17:01:09.868]                 NAMES <- toupper(removed)
[17:01:09.868]                 for (kk in seq_along(NAMES)) {
[17:01:09.868]                   name <- removed[[kk]]
[17:01:09.868]                   NAME <- NAMES[[kk]]
[17:01:09.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:09.868]                     next
[17:01:09.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:09.868]                 }
[17:01:09.868]                 if (length(args) > 0) 
[17:01:09.868]                   base::do.call(base::Sys.setenv, args = args)
[17:01:09.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:09.868]             }
[17:01:09.868]             else {
[17:01:09.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:09.868]             }
[17:01:09.868]             {
[17:01:09.868]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:09.868]                   0L) {
[17:01:09.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:09.868]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:09.868]                   base::options(opts)
[17:01:09.868]                 }
[17:01:09.868]                 {
[17:01:09.868]                   {
[17:01:09.868]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:09.868]                     NULL
[17:01:09.868]                   }
[17:01:09.868]                   options(future.plan = NULL)
[17:01:09.868]                   if (is.na(NA_character_)) 
[17:01:09.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:09.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:09.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:09.868]                     .init = FALSE)
[17:01:09.868]                 }
[17:01:09.868]             }
[17:01:09.868]         }
[17:01:09.868]     })
[17:01:09.868]     if (TRUE) {
[17:01:09.868]         base::sink(type = "output", split = FALSE)
[17:01:09.868]         if (TRUE) {
[17:01:09.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:09.868]         }
[17:01:09.868]         else {
[17:01:09.868]             ...future.result["stdout"] <- base::list(NULL)
[17:01:09.868]         }
[17:01:09.868]         base::close(...future.stdout)
[17:01:09.868]         ...future.stdout <- NULL
[17:01:09.868]     }
[17:01:09.868]     ...future.result$conditions <- ...future.conditions
[17:01:09.868]     ...future.result$finished <- base::Sys.time()
[17:01:09.868]     ...future.result
[17:01:09.868] }
[17:01:09.871] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[17:01:09.871] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:09.916] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:09.916] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:01:09.917] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:01:09.917] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:09.917] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:09.917] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:09.960] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:09.960] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:10.004] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:10.004] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:10.005] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.005] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[17:01:10.005] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[17:01:10.005] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:10.006] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.006] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[17:01:10.006] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[17:01:10.006] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:10.007] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.007] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:10.007] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.007] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[17:01:10.008] MultisessionFuture started
[17:01:10.008] - Launch lazy future ... done
[17:01:10.008] run() for ‘MultisessionFuture’ ... done
[17:01:10.009] Created future:
[17:01:10.009] MultisessionFuture:
[17:01:10.009] Label: ‘future_vapply-2’
[17:01:10.009] Expression:
[17:01:10.009] {
[17:01:10.009]     do.call(function(...) {
[17:01:10.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.009]             on.exit(options(oopts), add = TRUE)
[17:01:10.009]         }
[17:01:10.009]         {
[17:01:10.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.009]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.009]             })
[17:01:10.009]         }
[17:01:10.009]     }, args = future.call.arguments)
[17:01:10.009] }
[17:01:10.009] Lazy evaluation: FALSE
[17:01:10.009] Asynchronous evaluation: TRUE
[17:01:10.009] Local evaluation: TRUE
[17:01:10.009] Environment: R_GlobalEnv
[17:01:10.009] Capture standard output: TRUE
[17:01:10.009] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:10.009] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:10.009] Packages: 1 packages (‘future.apply’)
[17:01:10.009] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:10.009] Resolved: FALSE
[17:01:10.009] Value: <not collected>
[17:01:10.009] Conditions captured: <none>
[17:01:10.009] Early signaling: FALSE
[17:01:10.009] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:10.009] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.021] Chunk #2 of 2 ... DONE
[17:01:10.021] Launching 2 futures (chunks) ... DONE
[17:01:10.021] Resolving 2 futures (chunks) ...
[17:01:10.021] resolve() on list ...
[17:01:10.021]  recursive: 0
[17:01:10.021]  length: 2
[17:01:10.021] 
[17:01:10.022] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.022] - Validating connection of MultisessionFuture
[17:01:10.022] - received message: FutureResult
[17:01:10.022] - Received FutureResult
[17:01:10.022] - Erased future from FutureRegistry
[17:01:10.022] result() for ClusterFuture ...
[17:01:10.022] - result already collected: FutureResult
[17:01:10.022] result() for ClusterFuture ... done
[17:01:10.023] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.023] Future #1
[17:01:10.023] result() for ClusterFuture ...
[17:01:10.023] - result already collected: FutureResult
[17:01:10.023] result() for ClusterFuture ... done
[17:01:10.023] result() for ClusterFuture ...
[17:01:10.023] - result already collected: FutureResult
[17:01:10.023] result() for ClusterFuture ... done
[17:01:10.023] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:10.023] - nx: 2
[17:01:10.024] - relay: TRUE
[17:01:10.024] - stdout: TRUE
[17:01:10.024] - signal: TRUE
[17:01:10.024] - resignal: FALSE
[17:01:10.024] - force: TRUE
[17:01:10.024] - relayed: [n=2] FALSE, FALSE
[17:01:10.024] - queued futures: [n=2] FALSE, FALSE
[17:01:10.024]  - until=1
[17:01:10.024]  - relaying element #1
[17:01:10.024] result() for ClusterFuture ...
[17:01:10.024] - result already collected: FutureResult
[17:01:10.024] result() for ClusterFuture ... done
[17:01:10.025] result() for ClusterFuture ...
[17:01:10.025] - result already collected: FutureResult
[17:01:10.025] result() for ClusterFuture ... done
[17:01:10.025] result() for ClusterFuture ...
[17:01:10.025] - result already collected: FutureResult
[17:01:10.025] result() for ClusterFuture ... done
[17:01:10.025] result() for ClusterFuture ...
[17:01:10.025] - result already collected: FutureResult
[17:01:10.025] result() for ClusterFuture ... done
[17:01:10.025] - relayed: [n=2] TRUE, FALSE
[17:01:10.025] - queued futures: [n=2] TRUE, FALSE
[17:01:10.025] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:10.026]  length: 1 (resolved future 1)
[17:01:10.053] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.053] - Validating connection of MultisessionFuture
[17:01:10.053] - received message: FutureResult
[17:01:10.054] - Received FutureResult
[17:01:10.054] - Erased future from FutureRegistry
[17:01:10.054] result() for ClusterFuture ...
[17:01:10.054] - result already collected: FutureResult
[17:01:10.054] result() for ClusterFuture ... done
[17:01:10.054] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.054] Future #2
[17:01:10.054] result() for ClusterFuture ...
[17:01:10.054] - result already collected: FutureResult
[17:01:10.054] result() for ClusterFuture ... done
[17:01:10.054] result() for ClusterFuture ...
[17:01:10.055] - result already collected: FutureResult
[17:01:10.055] result() for ClusterFuture ... done
[17:01:10.055] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:10.055] - nx: 2
[17:01:10.055] - relay: TRUE
[17:01:10.055] - stdout: TRUE
[17:01:10.055] - signal: TRUE
[17:01:10.055] - resignal: FALSE
[17:01:10.055] - force: TRUE
[17:01:10.055] - relayed: [n=2] TRUE, FALSE
[17:01:10.055] - queued futures: [n=2] TRUE, FALSE
[17:01:10.056]  - until=2
[17:01:10.056]  - relaying element #2
[17:01:10.056] result() for ClusterFuture ...
[17:01:10.056] - result already collected: FutureResult
[17:01:10.056] result() for ClusterFuture ... done
[17:01:10.056] result() for ClusterFuture ...
[17:01:10.056] - result already collected: FutureResult
[17:01:10.056] result() for ClusterFuture ... done
[17:01:10.056] result() for ClusterFuture ...
[17:01:10.056] - result already collected: FutureResult
[17:01:10.056] result() for ClusterFuture ... done
[17:01:10.057] result() for ClusterFuture ...
[17:01:10.057] - result already collected: FutureResult
[17:01:10.057] result() for ClusterFuture ... done
[17:01:10.057] - relayed: [n=2] TRUE, TRUE
[17:01:10.057] - queued futures: [n=2] TRUE, TRUE
[17:01:10.057] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:10.057]  length: 0 (resolved future 2)
[17:01:10.057] Relaying remaining futures
[17:01:10.057] signalConditionsASAP(NULL, pos=0) ...
[17:01:10.057] - nx: 2
[17:01:10.057] - relay: TRUE
[17:01:10.058] - stdout: TRUE
[17:01:10.058] - signal: TRUE
[17:01:10.058] - resignal: FALSE
[17:01:10.058] - force: TRUE
[17:01:10.058] - relayed: [n=2] TRUE, TRUE
[17:01:10.058] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:10.058] - relayed: [n=2] TRUE, TRUE
[17:01:10.058] - queued futures: [n=2] TRUE, TRUE
[17:01:10.058] signalConditionsASAP(NULL, pos=0) ... done
[17:01:10.058] resolve() on list ... DONE
[17:01:10.058] result() for ClusterFuture ...
[17:01:10.058] - result already collected: FutureResult
[17:01:10.059] result() for ClusterFuture ... done
[17:01:10.059] result() for ClusterFuture ...
[17:01:10.059] - result already collected: FutureResult
[17:01:10.059] result() for ClusterFuture ... done
[17:01:10.059] result() for ClusterFuture ...
[17:01:10.059] - result already collected: FutureResult
[17:01:10.059] result() for ClusterFuture ... done
[17:01:10.059] result() for ClusterFuture ...
[17:01:10.059] - result already collected: FutureResult
[17:01:10.059] result() for ClusterFuture ... done
[17:01:10.059]  - Number of value chunks collected: 2
[17:01:10.060] Resolving 2 futures (chunks) ... DONE
[17:01:10.060] Reducing values from 2 chunks ...
[17:01:10.060]  - Number of values collected after concatenation: 11
[17:01:10.060]  - Number of values expected: 11
[17:01:10.060] Reducing values from 2 chunks ... DONE
[17:01:10.060] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:01:10.061] future_lapply() ...
[17:01:10.066] Number of chunks: 2
[17:01:10.066] getGlobalsAndPackagesXApply() ...
[17:01:10.066]  - future.globals: TRUE
[17:01:10.067] getGlobalsAndPackages() ...
[17:01:10.067] Searching for globals...
[17:01:10.070] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:10.070] Searching for globals ... DONE
[17:01:10.070] Resolving globals: FALSE
[17:01:10.071] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:01:10.071] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:10.071] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:10.071] - packages: [1] ‘future.apply’
[17:01:10.071] getGlobalsAndPackages() ... DONE
[17:01:10.071]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:10.072]  - needed namespaces: [n=1] ‘future.apply’
[17:01:10.072] Finding globals ... DONE
[17:01:10.072]  - use_args: TRUE
[17:01:10.072]  - Getting '...' globals ...
[17:01:10.072] resolve() on list ...
[17:01:10.072]  recursive: 0
[17:01:10.072]  length: 1
[17:01:10.072]  elements: ‘...’
[17:01:10.073]  length: 0 (resolved future 1)
[17:01:10.073] resolve() on list ... DONE
[17:01:10.073]    - '...' content: [n=0] 
[17:01:10.073] List of 1
[17:01:10.073]  $ ...: list()
[17:01:10.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:10.073]  - attr(*, "where")=List of 1
[17:01:10.073]   ..$ ...:<environment: 0x55aadd42cf90> 
[17:01:10.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:10.073]  - attr(*, "resolved")= logi TRUE
[17:01:10.073]  - attr(*, "total_size")= num NA
[17:01:10.075]  - Getting '...' globals ... DONE
[17:01:10.075] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:10.076] List of 8
[17:01:10.076]  $ ...future.FUN:function (x, ...)  
[17:01:10.076]  $ x_FUN        :function (x)  
[17:01:10.076]  $ times        : int 1
[17:01:10.076]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:10.076]  $ stop_if_not  :function (...)  
[17:01:10.076]  $ dim          : NULL
[17:01:10.076]  $ valid_types  : chr [1:2] "logical" "integer"
[17:01:10.076]  $ ...          : list()
[17:01:10.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:10.076]  - attr(*, "where")=List of 8
[17:01:10.076]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:10.076]   ..$ ...          :<environment: 0x55aadd42cf90> 
[17:01:10.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:10.076]  - attr(*, "resolved")= logi FALSE
[17:01:10.076]  - attr(*, "total_size")= num 94264
[17:01:10.081] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:10.081] getGlobalsAndPackagesXApply() ... DONE
[17:01:10.081] Number of futures (= number of chunks): 2
[17:01:10.081] Launching 2 futures (chunks) ...
[17:01:10.081] Chunk #1 of 2 ...
[17:01:10.081]  - Finding globals in 'X' for chunk #1 ...
[17:01:10.081] getGlobalsAndPackages() ...
[17:01:10.081] Searching for globals...
[17:01:10.082] 
[17:01:10.082] Searching for globals ... DONE
[17:01:10.082] - globals: [0] <none>
[17:01:10.082] getGlobalsAndPackages() ... DONE
[17:01:10.082]    + additional globals found: [n=0] 
[17:01:10.082]    + additional namespaces needed: [n=0] 
[17:01:10.082]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:10.082]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:10.082]  - seeds: <none>
[17:01:10.082]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.083] getGlobalsAndPackages() ...
[17:01:10.083] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.083] Resolving globals: FALSE
[17:01:10.083] Tweak future expression to call with '...' arguments ...
[17:01:10.083] {
[17:01:10.083]     do.call(function(...) {
[17:01:10.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.083]             on.exit(options(oopts), add = TRUE)
[17:01:10.083]         }
[17:01:10.083]         {
[17:01:10.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.083]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.083]             })
[17:01:10.083]         }
[17:01:10.083]     }, args = future.call.arguments)
[17:01:10.083] }
[17:01:10.083] Tweak future expression to call with '...' arguments ... DONE
[17:01:10.084] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.084] - packages: [1] ‘future.apply’
[17:01:10.084] getGlobalsAndPackages() ... DONE
[17:01:10.084] run() for ‘Future’ ...
[17:01:10.084] - state: ‘created’
[17:01:10.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:10.098] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:10.099]   - Field: ‘node’
[17:01:10.099]   - Field: ‘label’
[17:01:10.099]   - Field: ‘local’
[17:01:10.099]   - Field: ‘owner’
[17:01:10.099]   - Field: ‘envir’
[17:01:10.099]   - Field: ‘workers’
[17:01:10.099]   - Field: ‘packages’
[17:01:10.099]   - Field: ‘gc’
[17:01:10.099]   - Field: ‘conditions’
[17:01:10.099]   - Field: ‘persistent’
[17:01:10.100]   - Field: ‘expr’
[17:01:10.100]   - Field: ‘uuid’
[17:01:10.100]   - Field: ‘seed’
[17:01:10.100]   - Field: ‘version’
[17:01:10.100]   - Field: ‘result’
[17:01:10.100]   - Field: ‘asynchronous’
[17:01:10.100]   - Field: ‘calls’
[17:01:10.100]   - Field: ‘globals’
[17:01:10.100]   - Field: ‘stdout’
[17:01:10.100]   - Field: ‘earlySignal’
[17:01:10.100]   - Field: ‘lazy’
[17:01:10.101]   - Field: ‘state’
[17:01:10.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:10.101] - Launch lazy future ...
[17:01:10.101] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:10.101] Packages needed by future strategies (n = 0): <none>
[17:01:10.102] {
[17:01:10.102]     {
[17:01:10.102]         {
[17:01:10.102]             ...future.startTime <- base::Sys.time()
[17:01:10.102]             {
[17:01:10.102]                 {
[17:01:10.102]                   {
[17:01:10.102]                     {
[17:01:10.102]                       {
[17:01:10.102]                         base::local({
[17:01:10.102]                           has_future <- base::requireNamespace("future", 
[17:01:10.102]                             quietly = TRUE)
[17:01:10.102]                           if (has_future) {
[17:01:10.102]                             ns <- base::getNamespace("future")
[17:01:10.102]                             version <- ns[[".package"]][["version"]]
[17:01:10.102]                             if (is.null(version)) 
[17:01:10.102]                               version <- utils::packageVersion("future")
[17:01:10.102]                           }
[17:01:10.102]                           else {
[17:01:10.102]                             version <- NULL
[17:01:10.102]                           }
[17:01:10.102]                           if (!has_future || version < "1.8.0") {
[17:01:10.102]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:10.102]                               "", base::R.version$version.string), 
[17:01:10.102]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:10.102]                                 base::R.version$platform, 8 * 
[17:01:10.102]                                   base::.Machine$sizeof.pointer), 
[17:01:10.102]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:10.102]                                 "release", "version")], collapse = " "), 
[17:01:10.102]                               hostname = base::Sys.info()[["nodename"]])
[17:01:10.102]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:10.102]                               info)
[17:01:10.102]                             info <- base::paste(info, collapse = "; ")
[17:01:10.102]                             if (!has_future) {
[17:01:10.102]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:10.102]                                 info)
[17:01:10.102]                             }
[17:01:10.102]                             else {
[17:01:10.102]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:10.102]                                 info, version)
[17:01:10.102]                             }
[17:01:10.102]                             base::stop(msg)
[17:01:10.102]                           }
[17:01:10.102]                         })
[17:01:10.102]                       }
[17:01:10.102]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:10.102]                       base::options(mc.cores = 1L)
[17:01:10.102]                     }
[17:01:10.102]                     base::local({
[17:01:10.102]                       for (pkg in "future.apply") {
[17:01:10.102]                         base::loadNamespace(pkg)
[17:01:10.102]                         base::library(pkg, character.only = TRUE)
[17:01:10.102]                       }
[17:01:10.102]                     })
[17:01:10.102]                   }
[17:01:10.102]                   ...future.strategy.old <- future::plan("list")
[17:01:10.102]                   options(future.plan = NULL)
[17:01:10.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:10.102]                 }
[17:01:10.102]                 ...future.workdir <- getwd()
[17:01:10.102]             }
[17:01:10.102]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:10.102]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:10.102]         }
[17:01:10.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:10.102]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:10.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:10.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:10.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:10.102]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:10.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:10.102]             base::names(...future.oldOptions))
[17:01:10.102]     }
[17:01:10.102]     if (FALSE) {
[17:01:10.102]     }
[17:01:10.102]     else {
[17:01:10.102]         if (TRUE) {
[17:01:10.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:10.102]                 open = "w")
[17:01:10.102]         }
[17:01:10.102]         else {
[17:01:10.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:10.102]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:10.102]         }
[17:01:10.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:10.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:10.102]             base::sink(type = "output", split = FALSE)
[17:01:10.102]             base::close(...future.stdout)
[17:01:10.102]         }, add = TRUE)
[17:01:10.102]     }
[17:01:10.102]     ...future.frame <- base::sys.nframe()
[17:01:10.102]     ...future.conditions <- base::list()
[17:01:10.102]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:10.102]     if (FALSE) {
[17:01:10.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:10.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:10.102]     }
[17:01:10.102]     ...future.result <- base::tryCatch({
[17:01:10.102]         base::withCallingHandlers({
[17:01:10.102]             ...future.value <- base::withVisible(base::local({
[17:01:10.102]                 ...future.makeSendCondition <- base::local({
[17:01:10.102]                   sendCondition <- NULL
[17:01:10.102]                   function(frame = 1L) {
[17:01:10.102]                     if (is.function(sendCondition)) 
[17:01:10.102]                       return(sendCondition)
[17:01:10.102]                     ns <- getNamespace("parallel")
[17:01:10.102]                     if (exists("sendData", mode = "function", 
[17:01:10.102]                       envir = ns)) {
[17:01:10.102]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:10.102]                         envir = ns)
[17:01:10.102]                       envir <- sys.frame(frame)
[17:01:10.102]                       master <- NULL
[17:01:10.102]                       while (!identical(envir, .GlobalEnv) && 
[17:01:10.102]                         !identical(envir, emptyenv())) {
[17:01:10.102]                         if (exists("master", mode = "list", envir = envir, 
[17:01:10.102]                           inherits = FALSE)) {
[17:01:10.102]                           master <- get("master", mode = "list", 
[17:01:10.102]                             envir = envir, inherits = FALSE)
[17:01:10.102]                           if (inherits(master, c("SOCKnode", 
[17:01:10.102]                             "SOCK0node"))) {
[17:01:10.102]                             sendCondition <<- function(cond) {
[17:01:10.102]                               data <- list(type = "VALUE", value = cond, 
[17:01:10.102]                                 success = TRUE)
[17:01:10.102]                               parallel_sendData(master, data)
[17:01:10.102]                             }
[17:01:10.102]                             return(sendCondition)
[17:01:10.102]                           }
[17:01:10.102]                         }
[17:01:10.102]                         frame <- frame + 1L
[17:01:10.102]                         envir <- sys.frame(frame)
[17:01:10.102]                       }
[17:01:10.102]                     }
[17:01:10.102]                     sendCondition <<- function(cond) NULL
[17:01:10.102]                   }
[17:01:10.102]                 })
[17:01:10.102]                 withCallingHandlers({
[17:01:10.102]                   {
[17:01:10.102]                     do.call(function(...) {
[17:01:10.102]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.102]                       if (!identical(...future.globals.maxSize.org, 
[17:01:10.102]                         ...future.globals.maxSize)) {
[17:01:10.102]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.102]                         on.exit(options(oopts), add = TRUE)
[17:01:10.102]                       }
[17:01:10.102]                       {
[17:01:10.102]                         lapply(seq_along(...future.elements_ii), 
[17:01:10.102]                           FUN = function(jj) {
[17:01:10.102]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.102]                             ...future.FUN(...future.X_jj, ...)
[17:01:10.102]                           })
[17:01:10.102]                       }
[17:01:10.102]                     }, args = future.call.arguments)
[17:01:10.102]                   }
[17:01:10.102]                 }, immediateCondition = function(cond) {
[17:01:10.102]                   sendCondition <- ...future.makeSendCondition()
[17:01:10.102]                   sendCondition(cond)
[17:01:10.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.102]                   {
[17:01:10.102]                     inherits <- base::inherits
[17:01:10.102]                     invokeRestart <- base::invokeRestart
[17:01:10.102]                     is.null <- base::is.null
[17:01:10.102]                     muffled <- FALSE
[17:01:10.102]                     if (inherits(cond, "message")) {
[17:01:10.102]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:10.102]                       if (muffled) 
[17:01:10.102]                         invokeRestart("muffleMessage")
[17:01:10.102]                     }
[17:01:10.102]                     else if (inherits(cond, "warning")) {
[17:01:10.102]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:10.102]                       if (muffled) 
[17:01:10.102]                         invokeRestart("muffleWarning")
[17:01:10.102]                     }
[17:01:10.102]                     else if (inherits(cond, "condition")) {
[17:01:10.102]                       if (!is.null(pattern)) {
[17:01:10.102]                         computeRestarts <- base::computeRestarts
[17:01:10.102]                         grepl <- base::grepl
[17:01:10.102]                         restarts <- computeRestarts(cond)
[17:01:10.102]                         for (restart in restarts) {
[17:01:10.102]                           name <- restart$name
[17:01:10.102]                           if (is.null(name)) 
[17:01:10.102]                             next
[17:01:10.102]                           if (!grepl(pattern, name)) 
[17:01:10.102]                             next
[17:01:10.102]                           invokeRestart(restart)
[17:01:10.102]                           muffled <- TRUE
[17:01:10.102]                           break
[17:01:10.102]                         }
[17:01:10.102]                       }
[17:01:10.102]                     }
[17:01:10.102]                     invisible(muffled)
[17:01:10.102]                   }
[17:01:10.102]                   muffleCondition(cond)
[17:01:10.102]                 })
[17:01:10.102]             }))
[17:01:10.102]             future::FutureResult(value = ...future.value$value, 
[17:01:10.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.102]                   ...future.rng), globalenv = if (FALSE) 
[17:01:10.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:10.102]                     ...future.globalenv.names))
[17:01:10.102]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:10.102]         }, condition = base::local({
[17:01:10.102]             c <- base::c
[17:01:10.102]             inherits <- base::inherits
[17:01:10.102]             invokeRestart <- base::invokeRestart
[17:01:10.102]             length <- base::length
[17:01:10.102]             list <- base::list
[17:01:10.102]             seq.int <- base::seq.int
[17:01:10.102]             signalCondition <- base::signalCondition
[17:01:10.102]             sys.calls <- base::sys.calls
[17:01:10.102]             `[[` <- base::`[[`
[17:01:10.102]             `+` <- base::`+`
[17:01:10.102]             `<<-` <- base::`<<-`
[17:01:10.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:10.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:10.102]                   3L)]
[17:01:10.102]             }
[17:01:10.102]             function(cond) {
[17:01:10.102]                 is_error <- inherits(cond, "error")
[17:01:10.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:10.102]                   NULL)
[17:01:10.102]                 if (is_error) {
[17:01:10.102]                   sessionInformation <- function() {
[17:01:10.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:10.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:10.102]                       search = base::search(), system = base::Sys.info())
[17:01:10.102]                   }
[17:01:10.102]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:10.102]                     cond$call), session = sessionInformation(), 
[17:01:10.102]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:10.102]                   signalCondition(cond)
[17:01:10.102]                 }
[17:01:10.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:10.102]                 "immediateCondition"))) {
[17:01:10.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:10.102]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:10.102]                   if (TRUE && !signal) {
[17:01:10.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.102]                     {
[17:01:10.102]                       inherits <- base::inherits
[17:01:10.102]                       invokeRestart <- base::invokeRestart
[17:01:10.102]                       is.null <- base::is.null
[17:01:10.102]                       muffled <- FALSE
[17:01:10.102]                       if (inherits(cond, "message")) {
[17:01:10.102]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.102]                         if (muffled) 
[17:01:10.102]                           invokeRestart("muffleMessage")
[17:01:10.102]                       }
[17:01:10.102]                       else if (inherits(cond, "warning")) {
[17:01:10.102]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.102]                         if (muffled) 
[17:01:10.102]                           invokeRestart("muffleWarning")
[17:01:10.102]                       }
[17:01:10.102]                       else if (inherits(cond, "condition")) {
[17:01:10.102]                         if (!is.null(pattern)) {
[17:01:10.102]                           computeRestarts <- base::computeRestarts
[17:01:10.102]                           grepl <- base::grepl
[17:01:10.102]                           restarts <- computeRestarts(cond)
[17:01:10.102]                           for (restart in restarts) {
[17:01:10.102]                             name <- restart$name
[17:01:10.102]                             if (is.null(name)) 
[17:01:10.102]                               next
[17:01:10.102]                             if (!grepl(pattern, name)) 
[17:01:10.102]                               next
[17:01:10.102]                             invokeRestart(restart)
[17:01:10.102]                             muffled <- TRUE
[17:01:10.102]                             break
[17:01:10.102]                           }
[17:01:10.102]                         }
[17:01:10.102]                       }
[17:01:10.102]                       invisible(muffled)
[17:01:10.102]                     }
[17:01:10.102]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.102]                   }
[17:01:10.102]                 }
[17:01:10.102]                 else {
[17:01:10.102]                   if (TRUE) {
[17:01:10.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.102]                     {
[17:01:10.102]                       inherits <- base::inherits
[17:01:10.102]                       invokeRestart <- base::invokeRestart
[17:01:10.102]                       is.null <- base::is.null
[17:01:10.102]                       muffled <- FALSE
[17:01:10.102]                       if (inherits(cond, "message")) {
[17:01:10.102]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.102]                         if (muffled) 
[17:01:10.102]                           invokeRestart("muffleMessage")
[17:01:10.102]                       }
[17:01:10.102]                       else if (inherits(cond, "warning")) {
[17:01:10.102]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.102]                         if (muffled) 
[17:01:10.102]                           invokeRestart("muffleWarning")
[17:01:10.102]                       }
[17:01:10.102]                       else if (inherits(cond, "condition")) {
[17:01:10.102]                         if (!is.null(pattern)) {
[17:01:10.102]                           computeRestarts <- base::computeRestarts
[17:01:10.102]                           grepl <- base::grepl
[17:01:10.102]                           restarts <- computeRestarts(cond)
[17:01:10.102]                           for (restart in restarts) {
[17:01:10.102]                             name <- restart$name
[17:01:10.102]                             if (is.null(name)) 
[17:01:10.102]                               next
[17:01:10.102]                             if (!grepl(pattern, name)) 
[17:01:10.102]                               next
[17:01:10.102]                             invokeRestart(restart)
[17:01:10.102]                             muffled <- TRUE
[17:01:10.102]                             break
[17:01:10.102]                           }
[17:01:10.102]                         }
[17:01:10.102]                       }
[17:01:10.102]                       invisible(muffled)
[17:01:10.102]                     }
[17:01:10.102]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.102]                   }
[17:01:10.102]                 }
[17:01:10.102]             }
[17:01:10.102]         }))
[17:01:10.102]     }, error = function(ex) {
[17:01:10.102]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:10.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.102]                 ...future.rng), started = ...future.startTime, 
[17:01:10.102]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:10.102]             version = "1.8"), class = "FutureResult")
[17:01:10.102]     }, finally = {
[17:01:10.102]         if (!identical(...future.workdir, getwd())) 
[17:01:10.102]             setwd(...future.workdir)
[17:01:10.102]         {
[17:01:10.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:10.102]                 ...future.oldOptions$nwarnings <- NULL
[17:01:10.102]             }
[17:01:10.102]             base::options(...future.oldOptions)
[17:01:10.102]             if (.Platform$OS.type == "windows") {
[17:01:10.102]                 old_names <- names(...future.oldEnvVars)
[17:01:10.102]                 envs <- base::Sys.getenv()
[17:01:10.102]                 names <- names(envs)
[17:01:10.102]                 common <- intersect(names, old_names)
[17:01:10.102]                 added <- setdiff(names, old_names)
[17:01:10.102]                 removed <- setdiff(old_names, names)
[17:01:10.102]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:10.102]                   envs[common]]
[17:01:10.102]                 NAMES <- toupper(changed)
[17:01:10.102]                 args <- list()
[17:01:10.102]                 for (kk in seq_along(NAMES)) {
[17:01:10.102]                   name <- changed[[kk]]
[17:01:10.102]                   NAME <- NAMES[[kk]]
[17:01:10.102]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.102]                     next
[17:01:10.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.102]                 }
[17:01:10.102]                 NAMES <- toupper(added)
[17:01:10.102]                 for (kk in seq_along(NAMES)) {
[17:01:10.102]                   name <- added[[kk]]
[17:01:10.102]                   NAME <- NAMES[[kk]]
[17:01:10.102]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.102]                     next
[17:01:10.102]                   args[[name]] <- ""
[17:01:10.102]                 }
[17:01:10.102]                 NAMES <- toupper(removed)
[17:01:10.102]                 for (kk in seq_along(NAMES)) {
[17:01:10.102]                   name <- removed[[kk]]
[17:01:10.102]                   NAME <- NAMES[[kk]]
[17:01:10.102]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.102]                     next
[17:01:10.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.102]                 }
[17:01:10.102]                 if (length(args) > 0) 
[17:01:10.102]                   base::do.call(base::Sys.setenv, args = args)
[17:01:10.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:10.102]             }
[17:01:10.102]             else {
[17:01:10.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:10.102]             }
[17:01:10.102]             {
[17:01:10.102]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:10.102]                   0L) {
[17:01:10.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:10.102]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:10.102]                   base::options(opts)
[17:01:10.102]                 }
[17:01:10.102]                 {
[17:01:10.102]                   {
[17:01:10.102]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:10.102]                     NULL
[17:01:10.102]                   }
[17:01:10.102]                   options(future.plan = NULL)
[17:01:10.102]                   if (is.na(NA_character_)) 
[17:01:10.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:10.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:10.102]                     .init = FALSE)
[17:01:10.102]                 }
[17:01:10.102]             }
[17:01:10.102]         }
[17:01:10.102]     })
[17:01:10.102]     if (TRUE) {
[17:01:10.102]         base::sink(type = "output", split = FALSE)
[17:01:10.102]         if (TRUE) {
[17:01:10.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:10.102]         }
[17:01:10.102]         else {
[17:01:10.102]             ...future.result["stdout"] <- base::list(NULL)
[17:01:10.102]         }
[17:01:10.102]         base::close(...future.stdout)
[17:01:10.102]         ...future.stdout <- NULL
[17:01:10.102]     }
[17:01:10.102]     ...future.result$conditions <- ...future.conditions
[17:01:10.102]     ...future.result$finished <- base::Sys.time()
[17:01:10.102]     ...future.result
[17:01:10.102] }
[17:01:10.104] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[17:01:10.105] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:10.148] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:10.148] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:01:10.148] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:01:10.148] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:10.149] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:10.149] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:10.192] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:10.192] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:10.236] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:10.236] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:10.236] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.237] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:01:10.237] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:01:10.237] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:10.237] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.238] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:01:10.238] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:01:10.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:10.238] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:10.239] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.239] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[17:01:10.240] MultisessionFuture started
[17:01:10.240] - Launch lazy future ... done
[17:01:10.240] run() for ‘MultisessionFuture’ ... done
[17:01:10.240] Created future:
[17:01:10.240] MultisessionFuture:
[17:01:10.240] Label: ‘future_vapply-1’
[17:01:10.240] Expression:
[17:01:10.240] {
[17:01:10.240]     do.call(function(...) {
[17:01:10.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.240]             on.exit(options(oopts), add = TRUE)
[17:01:10.240]         }
[17:01:10.240]         {
[17:01:10.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.240]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.240]             })
[17:01:10.240]         }
[17:01:10.240]     }, args = future.call.arguments)
[17:01:10.240] }
[17:01:10.240] Lazy evaluation: FALSE
[17:01:10.240] Asynchronous evaluation: TRUE
[17:01:10.240] Local evaluation: TRUE
[17:01:10.240] Environment: R_GlobalEnv
[17:01:10.240] Capture standard output: TRUE
[17:01:10.240] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:10.240] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:10.240] Packages: 1 packages (‘future.apply’)
[17:01:10.240] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:10.240] Resolved: FALSE
[17:01:10.240] Value: <not collected>
[17:01:10.240] Conditions captured: <none>
[17:01:10.240] Early signaling: FALSE
[17:01:10.240] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:10.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.252] Chunk #1 of 2 ... DONE
[17:01:10.252] Chunk #2 of 2 ...
[17:01:10.252]  - Finding globals in 'X' for chunk #2 ...
[17:01:10.252] getGlobalsAndPackages() ...
[17:01:10.252] Searching for globals...
[17:01:10.253] 
[17:01:10.253] Searching for globals ... DONE
[17:01:10.253] - globals: [0] <none>
[17:01:10.253] getGlobalsAndPackages() ... DONE
[17:01:10.253]    + additional globals found: [n=0] 
[17:01:10.253]    + additional namespaces needed: [n=0] 
[17:01:10.253]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:10.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:10.253]  - seeds: <none>
[17:01:10.253]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.253] getGlobalsAndPackages() ...
[17:01:10.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.254] Resolving globals: FALSE
[17:01:10.254] Tweak future expression to call with '...' arguments ...
[17:01:10.254] {
[17:01:10.254]     do.call(function(...) {
[17:01:10.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.254]             on.exit(options(oopts), add = TRUE)
[17:01:10.254]         }
[17:01:10.254]         {
[17:01:10.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.254]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.254]             })
[17:01:10.254]         }
[17:01:10.254]     }, args = future.call.arguments)
[17:01:10.254] }
[17:01:10.254] Tweak future expression to call with '...' arguments ... DONE
[17:01:10.255] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.255] - packages: [1] ‘future.apply’
[17:01:10.255] getGlobalsAndPackages() ... DONE
[17:01:10.255] run() for ‘Future’ ...
[17:01:10.255] - state: ‘created’
[17:01:10.255] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:10.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:10.270]   - Field: ‘node’
[17:01:10.270]   - Field: ‘label’
[17:01:10.270]   - Field: ‘local’
[17:01:10.270]   - Field: ‘owner’
[17:01:10.270]   - Field: ‘envir’
[17:01:10.270]   - Field: ‘workers’
[17:01:10.270]   - Field: ‘packages’
[17:01:10.271]   - Field: ‘gc’
[17:01:10.271]   - Field: ‘conditions’
[17:01:10.271]   - Field: ‘persistent’
[17:01:10.271]   - Field: ‘expr’
[17:01:10.271]   - Field: ‘uuid’
[17:01:10.271]   - Field: ‘seed’
[17:01:10.271]   - Field: ‘version’
[17:01:10.271]   - Field: ‘result’
[17:01:10.271]   - Field: ‘asynchronous’
[17:01:10.271]   - Field: ‘calls’
[17:01:10.271]   - Field: ‘globals’
[17:01:10.272]   - Field: ‘stdout’
[17:01:10.272]   - Field: ‘earlySignal’
[17:01:10.272]   - Field: ‘lazy’
[17:01:10.272]   - Field: ‘state’
[17:01:10.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:10.272] - Launch lazy future ...
[17:01:10.272] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:10.272] Packages needed by future strategies (n = 0): <none>
[17:01:10.273] {
[17:01:10.273]     {
[17:01:10.273]         {
[17:01:10.273]             ...future.startTime <- base::Sys.time()
[17:01:10.273]             {
[17:01:10.273]                 {
[17:01:10.273]                   {
[17:01:10.273]                     {
[17:01:10.273]                       {
[17:01:10.273]                         base::local({
[17:01:10.273]                           has_future <- base::requireNamespace("future", 
[17:01:10.273]                             quietly = TRUE)
[17:01:10.273]                           if (has_future) {
[17:01:10.273]                             ns <- base::getNamespace("future")
[17:01:10.273]                             version <- ns[[".package"]][["version"]]
[17:01:10.273]                             if (is.null(version)) 
[17:01:10.273]                               version <- utils::packageVersion("future")
[17:01:10.273]                           }
[17:01:10.273]                           else {
[17:01:10.273]                             version <- NULL
[17:01:10.273]                           }
[17:01:10.273]                           if (!has_future || version < "1.8.0") {
[17:01:10.273]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:10.273]                               "", base::R.version$version.string), 
[17:01:10.273]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:10.273]                                 base::R.version$platform, 8 * 
[17:01:10.273]                                   base::.Machine$sizeof.pointer), 
[17:01:10.273]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:10.273]                                 "release", "version")], collapse = " "), 
[17:01:10.273]                               hostname = base::Sys.info()[["nodename"]])
[17:01:10.273]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:10.273]                               info)
[17:01:10.273]                             info <- base::paste(info, collapse = "; ")
[17:01:10.273]                             if (!has_future) {
[17:01:10.273]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:10.273]                                 info)
[17:01:10.273]                             }
[17:01:10.273]                             else {
[17:01:10.273]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:10.273]                                 info, version)
[17:01:10.273]                             }
[17:01:10.273]                             base::stop(msg)
[17:01:10.273]                           }
[17:01:10.273]                         })
[17:01:10.273]                       }
[17:01:10.273]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:10.273]                       base::options(mc.cores = 1L)
[17:01:10.273]                     }
[17:01:10.273]                     base::local({
[17:01:10.273]                       for (pkg in "future.apply") {
[17:01:10.273]                         base::loadNamespace(pkg)
[17:01:10.273]                         base::library(pkg, character.only = TRUE)
[17:01:10.273]                       }
[17:01:10.273]                     })
[17:01:10.273]                   }
[17:01:10.273]                   ...future.strategy.old <- future::plan("list")
[17:01:10.273]                   options(future.plan = NULL)
[17:01:10.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:10.273]                 }
[17:01:10.273]                 ...future.workdir <- getwd()
[17:01:10.273]             }
[17:01:10.273]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:10.273]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:10.273]         }
[17:01:10.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:10.273]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:10.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:10.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:10.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:10.273]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:10.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:10.273]             base::names(...future.oldOptions))
[17:01:10.273]     }
[17:01:10.273]     if (FALSE) {
[17:01:10.273]     }
[17:01:10.273]     else {
[17:01:10.273]         if (TRUE) {
[17:01:10.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:10.273]                 open = "w")
[17:01:10.273]         }
[17:01:10.273]         else {
[17:01:10.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:10.273]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:10.273]         }
[17:01:10.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:10.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:10.273]             base::sink(type = "output", split = FALSE)
[17:01:10.273]             base::close(...future.stdout)
[17:01:10.273]         }, add = TRUE)
[17:01:10.273]     }
[17:01:10.273]     ...future.frame <- base::sys.nframe()
[17:01:10.273]     ...future.conditions <- base::list()
[17:01:10.273]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:10.273]     if (FALSE) {
[17:01:10.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:10.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:10.273]     }
[17:01:10.273]     ...future.result <- base::tryCatch({
[17:01:10.273]         base::withCallingHandlers({
[17:01:10.273]             ...future.value <- base::withVisible(base::local({
[17:01:10.273]                 ...future.makeSendCondition <- base::local({
[17:01:10.273]                   sendCondition <- NULL
[17:01:10.273]                   function(frame = 1L) {
[17:01:10.273]                     if (is.function(sendCondition)) 
[17:01:10.273]                       return(sendCondition)
[17:01:10.273]                     ns <- getNamespace("parallel")
[17:01:10.273]                     if (exists("sendData", mode = "function", 
[17:01:10.273]                       envir = ns)) {
[17:01:10.273]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:10.273]                         envir = ns)
[17:01:10.273]                       envir <- sys.frame(frame)
[17:01:10.273]                       master <- NULL
[17:01:10.273]                       while (!identical(envir, .GlobalEnv) && 
[17:01:10.273]                         !identical(envir, emptyenv())) {
[17:01:10.273]                         if (exists("master", mode = "list", envir = envir, 
[17:01:10.273]                           inherits = FALSE)) {
[17:01:10.273]                           master <- get("master", mode = "list", 
[17:01:10.273]                             envir = envir, inherits = FALSE)
[17:01:10.273]                           if (inherits(master, c("SOCKnode", 
[17:01:10.273]                             "SOCK0node"))) {
[17:01:10.273]                             sendCondition <<- function(cond) {
[17:01:10.273]                               data <- list(type = "VALUE", value = cond, 
[17:01:10.273]                                 success = TRUE)
[17:01:10.273]                               parallel_sendData(master, data)
[17:01:10.273]                             }
[17:01:10.273]                             return(sendCondition)
[17:01:10.273]                           }
[17:01:10.273]                         }
[17:01:10.273]                         frame <- frame + 1L
[17:01:10.273]                         envir <- sys.frame(frame)
[17:01:10.273]                       }
[17:01:10.273]                     }
[17:01:10.273]                     sendCondition <<- function(cond) NULL
[17:01:10.273]                   }
[17:01:10.273]                 })
[17:01:10.273]                 withCallingHandlers({
[17:01:10.273]                   {
[17:01:10.273]                     do.call(function(...) {
[17:01:10.273]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.273]                       if (!identical(...future.globals.maxSize.org, 
[17:01:10.273]                         ...future.globals.maxSize)) {
[17:01:10.273]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.273]                         on.exit(options(oopts), add = TRUE)
[17:01:10.273]                       }
[17:01:10.273]                       {
[17:01:10.273]                         lapply(seq_along(...future.elements_ii), 
[17:01:10.273]                           FUN = function(jj) {
[17:01:10.273]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.273]                             ...future.FUN(...future.X_jj, ...)
[17:01:10.273]                           })
[17:01:10.273]                       }
[17:01:10.273]                     }, args = future.call.arguments)
[17:01:10.273]                   }
[17:01:10.273]                 }, immediateCondition = function(cond) {
[17:01:10.273]                   sendCondition <- ...future.makeSendCondition()
[17:01:10.273]                   sendCondition(cond)
[17:01:10.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.273]                   {
[17:01:10.273]                     inherits <- base::inherits
[17:01:10.273]                     invokeRestart <- base::invokeRestart
[17:01:10.273]                     is.null <- base::is.null
[17:01:10.273]                     muffled <- FALSE
[17:01:10.273]                     if (inherits(cond, "message")) {
[17:01:10.273]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:10.273]                       if (muffled) 
[17:01:10.273]                         invokeRestart("muffleMessage")
[17:01:10.273]                     }
[17:01:10.273]                     else if (inherits(cond, "warning")) {
[17:01:10.273]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:10.273]                       if (muffled) 
[17:01:10.273]                         invokeRestart("muffleWarning")
[17:01:10.273]                     }
[17:01:10.273]                     else if (inherits(cond, "condition")) {
[17:01:10.273]                       if (!is.null(pattern)) {
[17:01:10.273]                         computeRestarts <- base::computeRestarts
[17:01:10.273]                         grepl <- base::grepl
[17:01:10.273]                         restarts <- computeRestarts(cond)
[17:01:10.273]                         for (restart in restarts) {
[17:01:10.273]                           name <- restart$name
[17:01:10.273]                           if (is.null(name)) 
[17:01:10.273]                             next
[17:01:10.273]                           if (!grepl(pattern, name)) 
[17:01:10.273]                             next
[17:01:10.273]                           invokeRestart(restart)
[17:01:10.273]                           muffled <- TRUE
[17:01:10.273]                           break
[17:01:10.273]                         }
[17:01:10.273]                       }
[17:01:10.273]                     }
[17:01:10.273]                     invisible(muffled)
[17:01:10.273]                   }
[17:01:10.273]                   muffleCondition(cond)
[17:01:10.273]                 })
[17:01:10.273]             }))
[17:01:10.273]             future::FutureResult(value = ...future.value$value, 
[17:01:10.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.273]                   ...future.rng), globalenv = if (FALSE) 
[17:01:10.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:10.273]                     ...future.globalenv.names))
[17:01:10.273]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:10.273]         }, condition = base::local({
[17:01:10.273]             c <- base::c
[17:01:10.273]             inherits <- base::inherits
[17:01:10.273]             invokeRestart <- base::invokeRestart
[17:01:10.273]             length <- base::length
[17:01:10.273]             list <- base::list
[17:01:10.273]             seq.int <- base::seq.int
[17:01:10.273]             signalCondition <- base::signalCondition
[17:01:10.273]             sys.calls <- base::sys.calls
[17:01:10.273]             `[[` <- base::`[[`
[17:01:10.273]             `+` <- base::`+`
[17:01:10.273]             `<<-` <- base::`<<-`
[17:01:10.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:10.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:10.273]                   3L)]
[17:01:10.273]             }
[17:01:10.273]             function(cond) {
[17:01:10.273]                 is_error <- inherits(cond, "error")
[17:01:10.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:10.273]                   NULL)
[17:01:10.273]                 if (is_error) {
[17:01:10.273]                   sessionInformation <- function() {
[17:01:10.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:10.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:10.273]                       search = base::search(), system = base::Sys.info())
[17:01:10.273]                   }
[17:01:10.273]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:10.273]                     cond$call), session = sessionInformation(), 
[17:01:10.273]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:10.273]                   signalCondition(cond)
[17:01:10.273]                 }
[17:01:10.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:10.273]                 "immediateCondition"))) {
[17:01:10.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:10.273]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:10.273]                   if (TRUE && !signal) {
[17:01:10.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.273]                     {
[17:01:10.273]                       inherits <- base::inherits
[17:01:10.273]                       invokeRestart <- base::invokeRestart
[17:01:10.273]                       is.null <- base::is.null
[17:01:10.273]                       muffled <- FALSE
[17:01:10.273]                       if (inherits(cond, "message")) {
[17:01:10.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.273]                         if (muffled) 
[17:01:10.273]                           invokeRestart("muffleMessage")
[17:01:10.273]                       }
[17:01:10.273]                       else if (inherits(cond, "warning")) {
[17:01:10.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.273]                         if (muffled) 
[17:01:10.273]                           invokeRestart("muffleWarning")
[17:01:10.273]                       }
[17:01:10.273]                       else if (inherits(cond, "condition")) {
[17:01:10.273]                         if (!is.null(pattern)) {
[17:01:10.273]                           computeRestarts <- base::computeRestarts
[17:01:10.273]                           grepl <- base::grepl
[17:01:10.273]                           restarts <- computeRestarts(cond)
[17:01:10.273]                           for (restart in restarts) {
[17:01:10.273]                             name <- restart$name
[17:01:10.273]                             if (is.null(name)) 
[17:01:10.273]                               next
[17:01:10.273]                             if (!grepl(pattern, name)) 
[17:01:10.273]                               next
[17:01:10.273]                             invokeRestart(restart)
[17:01:10.273]                             muffled <- TRUE
[17:01:10.273]                             break
[17:01:10.273]                           }
[17:01:10.273]                         }
[17:01:10.273]                       }
[17:01:10.273]                       invisible(muffled)
[17:01:10.273]                     }
[17:01:10.273]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.273]                   }
[17:01:10.273]                 }
[17:01:10.273]                 else {
[17:01:10.273]                   if (TRUE) {
[17:01:10.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.273]                     {
[17:01:10.273]                       inherits <- base::inherits
[17:01:10.273]                       invokeRestart <- base::invokeRestart
[17:01:10.273]                       is.null <- base::is.null
[17:01:10.273]                       muffled <- FALSE
[17:01:10.273]                       if (inherits(cond, "message")) {
[17:01:10.273]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.273]                         if (muffled) 
[17:01:10.273]                           invokeRestart("muffleMessage")
[17:01:10.273]                       }
[17:01:10.273]                       else if (inherits(cond, "warning")) {
[17:01:10.273]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.273]                         if (muffled) 
[17:01:10.273]                           invokeRestart("muffleWarning")
[17:01:10.273]                       }
[17:01:10.273]                       else if (inherits(cond, "condition")) {
[17:01:10.273]                         if (!is.null(pattern)) {
[17:01:10.273]                           computeRestarts <- base::computeRestarts
[17:01:10.273]                           grepl <- base::grepl
[17:01:10.273]                           restarts <- computeRestarts(cond)
[17:01:10.273]                           for (restart in restarts) {
[17:01:10.273]                             name <- restart$name
[17:01:10.273]                             if (is.null(name)) 
[17:01:10.273]                               next
[17:01:10.273]                             if (!grepl(pattern, name)) 
[17:01:10.273]                               next
[17:01:10.273]                             invokeRestart(restart)
[17:01:10.273]                             muffled <- TRUE
[17:01:10.273]                             break
[17:01:10.273]                           }
[17:01:10.273]                         }
[17:01:10.273]                       }
[17:01:10.273]                       invisible(muffled)
[17:01:10.273]                     }
[17:01:10.273]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.273]                   }
[17:01:10.273]                 }
[17:01:10.273]             }
[17:01:10.273]         }))
[17:01:10.273]     }, error = function(ex) {
[17:01:10.273]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:10.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.273]                 ...future.rng), started = ...future.startTime, 
[17:01:10.273]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:10.273]             version = "1.8"), class = "FutureResult")
[17:01:10.273]     }, finally = {
[17:01:10.273]         if (!identical(...future.workdir, getwd())) 
[17:01:10.273]             setwd(...future.workdir)
[17:01:10.273]         {
[17:01:10.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:10.273]                 ...future.oldOptions$nwarnings <- NULL
[17:01:10.273]             }
[17:01:10.273]             base::options(...future.oldOptions)
[17:01:10.273]             if (.Platform$OS.type == "windows") {
[17:01:10.273]                 old_names <- names(...future.oldEnvVars)
[17:01:10.273]                 envs <- base::Sys.getenv()
[17:01:10.273]                 names <- names(envs)
[17:01:10.273]                 common <- intersect(names, old_names)
[17:01:10.273]                 added <- setdiff(names, old_names)
[17:01:10.273]                 removed <- setdiff(old_names, names)
[17:01:10.273]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:10.273]                   envs[common]]
[17:01:10.273]                 NAMES <- toupper(changed)
[17:01:10.273]                 args <- list()
[17:01:10.273]                 for (kk in seq_along(NAMES)) {
[17:01:10.273]                   name <- changed[[kk]]
[17:01:10.273]                   NAME <- NAMES[[kk]]
[17:01:10.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.273]                     next
[17:01:10.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.273]                 }
[17:01:10.273]                 NAMES <- toupper(added)
[17:01:10.273]                 for (kk in seq_along(NAMES)) {
[17:01:10.273]                   name <- added[[kk]]
[17:01:10.273]                   NAME <- NAMES[[kk]]
[17:01:10.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.273]                     next
[17:01:10.273]                   args[[name]] <- ""
[17:01:10.273]                 }
[17:01:10.273]                 NAMES <- toupper(removed)
[17:01:10.273]                 for (kk in seq_along(NAMES)) {
[17:01:10.273]                   name <- removed[[kk]]
[17:01:10.273]                   NAME <- NAMES[[kk]]
[17:01:10.273]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.273]                     next
[17:01:10.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.273]                 }
[17:01:10.273]                 if (length(args) > 0) 
[17:01:10.273]                   base::do.call(base::Sys.setenv, args = args)
[17:01:10.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:10.273]             }
[17:01:10.273]             else {
[17:01:10.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:10.273]             }
[17:01:10.273]             {
[17:01:10.273]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:10.273]                   0L) {
[17:01:10.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:10.273]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:10.273]                   base::options(opts)
[17:01:10.273]                 }
[17:01:10.273]                 {
[17:01:10.273]                   {
[17:01:10.273]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:10.273]                     NULL
[17:01:10.273]                   }
[17:01:10.273]                   options(future.plan = NULL)
[17:01:10.273]                   if (is.na(NA_character_)) 
[17:01:10.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:10.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:10.273]                     .init = FALSE)
[17:01:10.273]                 }
[17:01:10.273]             }
[17:01:10.273]         }
[17:01:10.273]     })
[17:01:10.273]     if (TRUE) {
[17:01:10.273]         base::sink(type = "output", split = FALSE)
[17:01:10.273]         if (TRUE) {
[17:01:10.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:10.273]         }
[17:01:10.273]         else {
[17:01:10.273]             ...future.result["stdout"] <- base::list(NULL)
[17:01:10.273]         }
[17:01:10.273]         base::close(...future.stdout)
[17:01:10.273]         ...future.stdout <- NULL
[17:01:10.273]     }
[17:01:10.273]     ...future.result$conditions <- ...future.conditions
[17:01:10.273]     ...future.result$finished <- base::Sys.time()
[17:01:10.273]     ...future.result
[17:01:10.273] }
[17:01:10.276] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[17:01:10.276] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:10.320] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:10.320] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:01:10.320] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:01:10.321] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:10.321] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:10.321] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:10.364] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:10.364] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:10.408] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:10.408] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:10.408] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.409] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:01:10.409] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:01:10.409] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:10.410] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.410] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:10.410] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:10.410] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:10.411] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.411] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:10.411] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.411] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[17:01:10.412] MultisessionFuture started
[17:01:10.412] - Launch lazy future ... done
[17:01:10.412] run() for ‘MultisessionFuture’ ... done
[17:01:10.412] Created future:
[17:01:10.412] MultisessionFuture:
[17:01:10.412] Label: ‘future_vapply-2’
[17:01:10.412] Expression:
[17:01:10.412] {
[17:01:10.412]     do.call(function(...) {
[17:01:10.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.412]             on.exit(options(oopts), add = TRUE)
[17:01:10.412]         }
[17:01:10.412]         {
[17:01:10.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.412]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.412]             })
[17:01:10.412]         }
[17:01:10.412]     }, args = future.call.arguments)
[17:01:10.412] }
[17:01:10.412] Lazy evaluation: FALSE
[17:01:10.412] Asynchronous evaluation: TRUE
[17:01:10.412] Local evaluation: TRUE
[17:01:10.412] Environment: R_GlobalEnv
[17:01:10.412] Capture standard output: TRUE
[17:01:10.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:10.412] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:10.412] Packages: 1 packages (‘future.apply’)
[17:01:10.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:10.412] Resolved: FALSE
[17:01:10.412] Value: <not collected>
[17:01:10.412] Conditions captured: <none>
[17:01:10.412] Early signaling: FALSE
[17:01:10.412] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:10.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.427] Chunk #2 of 2 ... DONE
[17:01:10.427] Launching 2 futures (chunks) ... DONE
[17:01:10.427] Resolving 2 futures (chunks) ...
[17:01:10.427] resolve() on list ...
[17:01:10.427]  recursive: 0
[17:01:10.427]  length: 2
[17:01:10.428] 
[17:01:10.428] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.428] - Validating connection of MultisessionFuture
[17:01:10.428] - received message: FutureResult
[17:01:10.428] - Received FutureResult
[17:01:10.428] - Erased future from FutureRegistry
[17:01:10.429] result() for ClusterFuture ...
[17:01:10.429] - result already collected: FutureResult
[17:01:10.429] result() for ClusterFuture ... done
[17:01:10.429] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.429] Future #1
[17:01:10.429] result() for ClusterFuture ...
[17:01:10.429] - result already collected: FutureResult
[17:01:10.429] result() for ClusterFuture ... done
[17:01:10.429] result() for ClusterFuture ...
[17:01:10.429] - result already collected: FutureResult
[17:01:10.429] result() for ClusterFuture ... done
[17:01:10.430] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:10.430] - nx: 2
[17:01:10.430] - relay: TRUE
[17:01:10.430] - stdout: TRUE
[17:01:10.430] - signal: TRUE
[17:01:10.430] - resignal: FALSE
[17:01:10.430] - force: TRUE
[17:01:10.430] - relayed: [n=2] FALSE, FALSE
[17:01:10.430] - queued futures: [n=2] FALSE, FALSE
[17:01:10.430]  - until=1
[17:01:10.430]  - relaying element #1
[17:01:10.430] result() for ClusterFuture ...
[17:01:10.431] - result already collected: FutureResult
[17:01:10.431] result() for ClusterFuture ... done
[17:01:10.431] result() for ClusterFuture ...
[17:01:10.431] - result already collected: FutureResult
[17:01:10.431] result() for ClusterFuture ... done
[17:01:10.431] result() for ClusterFuture ...
[17:01:10.431] - result already collected: FutureResult
[17:01:10.431] result() for ClusterFuture ... done
[17:01:10.431] result() for ClusterFuture ...
[17:01:10.431] - result already collected: FutureResult
[17:01:10.431] result() for ClusterFuture ... done
[17:01:10.431] - relayed: [n=2] TRUE, FALSE
[17:01:10.432] - queued futures: [n=2] TRUE, FALSE
[17:01:10.432] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:10.432]  length: 1 (resolved future 1)
[17:01:10.457] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.457] - Validating connection of MultisessionFuture
[17:01:10.458] - received message: FutureResult
[17:01:10.458] - Received FutureResult
[17:01:10.458] - Erased future from FutureRegistry
[17:01:10.458] result() for ClusterFuture ...
[17:01:10.458] - result already collected: FutureResult
[17:01:10.458] result() for ClusterFuture ... done
[17:01:10.458] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.458] Future #2
[17:01:10.458] result() for ClusterFuture ...
[17:01:10.459] - result already collected: FutureResult
[17:01:10.459] result() for ClusterFuture ... done
[17:01:10.459] result() for ClusterFuture ...
[17:01:10.459] - result already collected: FutureResult
[17:01:10.459] result() for ClusterFuture ... done
[17:01:10.459] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:01:10.459] - nx: 2
[17:01:10.459] - relay: TRUE
[17:01:10.459] - stdout: TRUE
[17:01:10.459] - signal: TRUE
[17:01:10.459] - resignal: FALSE
[17:01:10.459] - force: TRUE
[17:01:10.460] - relayed: [n=2] TRUE, FALSE
[17:01:10.460] - queued futures: [n=2] TRUE, FALSE
[17:01:10.460]  - until=2
[17:01:10.460]  - relaying element #2
[17:01:10.460] result() for ClusterFuture ...
[17:01:10.460] - result already collected: FutureResult
[17:01:10.460] result() for ClusterFuture ... done
[17:01:10.460] result() for ClusterFuture ...
[17:01:10.460] - result already collected: FutureResult
[17:01:10.460] result() for ClusterFuture ... done
[17:01:10.460] result() for ClusterFuture ...
[17:01:10.461] - result already collected: FutureResult
[17:01:10.461] result() for ClusterFuture ... done
[17:01:10.461] result() for ClusterFuture ...
[17:01:10.461] - result already collected: FutureResult
[17:01:10.461] result() for ClusterFuture ... done
[17:01:10.461] - relayed: [n=2] TRUE, TRUE
[17:01:10.461] - queued futures: [n=2] TRUE, TRUE
[17:01:10.461] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:01:10.461]  length: 0 (resolved future 2)
[17:01:10.461] Relaying remaining futures
[17:01:10.461] signalConditionsASAP(NULL, pos=0) ...
[17:01:10.461] - nx: 2
[17:01:10.462] - relay: TRUE
[17:01:10.462] - stdout: TRUE
[17:01:10.462] - signal: TRUE
[17:01:10.462] - resignal: FALSE
[17:01:10.462] - force: TRUE
[17:01:10.462] - relayed: [n=2] TRUE, TRUE
[17:01:10.462] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:01:10.462] - relayed: [n=2] TRUE, TRUE
[17:01:10.462] - queued futures: [n=2] TRUE, TRUE
[17:01:10.462] signalConditionsASAP(NULL, pos=0) ... done
[17:01:10.462] resolve() on list ... DONE
[17:01:10.463] result() for ClusterFuture ...
[17:01:10.463] - result already collected: FutureResult
[17:01:10.463] result() for ClusterFuture ... done
[17:01:10.463] result() for ClusterFuture ...
[17:01:10.463] - result already collected: FutureResult
[17:01:10.463] result() for ClusterFuture ... done
[17:01:10.463] result() for ClusterFuture ...
[17:01:10.463] - result already collected: FutureResult
[17:01:10.463] result() for ClusterFuture ... done
[17:01:10.463] result() for ClusterFuture ...
[17:01:10.463] - result already collected: FutureResult
[17:01:10.463] result() for ClusterFuture ... done
[17:01:10.464]  - Number of value chunks collected: 2
[17:01:10.464] Resolving 2 futures (chunks) ... DONE
[17:01:10.464] Reducing values from 2 chunks ...
[17:01:10.464]  - Number of values collected after concatenation: 3
[17:01:10.464]  - Number of values expected: 3
[17:01:10.464] Reducing values from 2 chunks ... DONE
[17:01:10.464] future_lapply() ... DONE
- exceptions ...
[17:01:10.464] future_lapply() ...
[17:01:10.470] Number of chunks: 2
[17:01:10.470] getGlobalsAndPackagesXApply() ...
[17:01:10.470]  - future.globals: TRUE
[17:01:10.470] getGlobalsAndPackages() ...
[17:01:10.470] Searching for globals...
[17:01:10.474] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:01:10.474] Searching for globals ... DONE
[17:01:10.474] Resolving globals: FALSE
[17:01:10.475] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:01:10.475] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:01:10.476] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:10.476] - packages: [1] ‘future.apply’
[17:01:10.476] getGlobalsAndPackages() ... DONE
[17:01:10.476]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:01:10.476]  - needed namespaces: [n=1] ‘future.apply’
[17:01:10.476] Finding globals ... DONE
[17:01:10.476]  - use_args: TRUE
[17:01:10.476]  - Getting '...' globals ...
[17:01:10.477] resolve() on list ...
[17:01:10.477]  recursive: 0
[17:01:10.477]  length: 1
[17:01:10.477]  elements: ‘...’
[17:01:10.477]  length: 0 (resolved future 1)
[17:01:10.477] resolve() on list ... DONE
[17:01:10.477]    - '...' content: [n=0] 
[17:01:10.477] List of 1
[17:01:10.477]  $ ...: list()
[17:01:10.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:10.477]  - attr(*, "where")=List of 1
[17:01:10.477]   ..$ ...:<environment: 0x55aadb211bf8> 
[17:01:10.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:10.477]  - attr(*, "resolved")= logi TRUE
[17:01:10.477]  - attr(*, "total_size")= num NA
[17:01:10.480]  - Getting '...' globals ... DONE
[17:01:10.480] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:01:10.480] List of 8
[17:01:10.480]  $ ...future.FUN:function (x, ...)  
[17:01:10.480]  $ x_FUN        :function (x)  
[17:01:10.480]  $ times        : int 2
[17:01:10.480]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:01:10.480]  $ stop_if_not  :function (...)  
[17:01:10.480]  $ dim          : NULL
[17:01:10.480]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:01:10.480]  $ ...          : list()
[17:01:10.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:01:10.480]  - attr(*, "where")=List of 8
[17:01:10.480]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ times        :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ dim          :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:01:10.480]   ..$ ...          :<environment: 0x55aadb211bf8> 
[17:01:10.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:01:10.480]  - attr(*, "resolved")= logi FALSE
[17:01:10.480]  - attr(*, "total_size")= num 95128
[17:01:10.485] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:01:10.485] getGlobalsAndPackagesXApply() ... DONE
[17:01:10.486] Number of futures (= number of chunks): 2
[17:01:10.486] Launching 2 futures (chunks) ...
[17:01:10.486] Chunk #1 of 2 ...
[17:01:10.486]  - Finding globals in 'X' for chunk #1 ...
[17:01:10.486] getGlobalsAndPackages() ...
[17:01:10.486] Searching for globals...
[17:01:10.486] 
[17:01:10.486] Searching for globals ... DONE
[17:01:10.486] - globals: [0] <none>
[17:01:10.487] getGlobalsAndPackages() ... DONE
[17:01:10.487]    + additional globals found: [n=0] 
[17:01:10.487]    + additional namespaces needed: [n=0] 
[17:01:10.487]  - Finding globals in 'X' for chunk #1 ... DONE
[17:01:10.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:10.487]  - seeds: <none>
[17:01:10.487]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.487] getGlobalsAndPackages() ...
[17:01:10.487] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.487] Resolving globals: FALSE
[17:01:10.488] Tweak future expression to call with '...' arguments ...
[17:01:10.488] {
[17:01:10.488]     do.call(function(...) {
[17:01:10.488]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.488]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.488]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.488]             on.exit(options(oopts), add = TRUE)
[17:01:10.488]         }
[17:01:10.488]         {
[17:01:10.488]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.488]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.488]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.488]             })
[17:01:10.488]         }
[17:01:10.488]     }, args = future.call.arguments)
[17:01:10.488] }
[17:01:10.488] Tweak future expression to call with '...' arguments ... DONE
[17:01:10.488] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.489] - packages: [1] ‘future.apply’
[17:01:10.489] getGlobalsAndPackages() ... DONE
[17:01:10.489] run() for ‘Future’ ...
[17:01:10.489] - state: ‘created’
[17:01:10.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:10.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.504] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:10.504]   - Field: ‘node’
[17:01:10.504]   - Field: ‘label’
[17:01:10.504]   - Field: ‘local’
[17:01:10.504]   - Field: ‘owner’
[17:01:10.504]   - Field: ‘envir’
[17:01:10.504]   - Field: ‘workers’
[17:01:10.504]   - Field: ‘packages’
[17:01:10.504]   - Field: ‘gc’
[17:01:10.505]   - Field: ‘conditions’
[17:01:10.505]   - Field: ‘persistent’
[17:01:10.505]   - Field: ‘expr’
[17:01:10.505]   - Field: ‘uuid’
[17:01:10.505]   - Field: ‘seed’
[17:01:10.505]   - Field: ‘version’
[17:01:10.505]   - Field: ‘result’
[17:01:10.505]   - Field: ‘asynchronous’
[17:01:10.505]   - Field: ‘calls’
[17:01:10.505]   - Field: ‘globals’
[17:01:10.505]   - Field: ‘stdout’
[17:01:10.506]   - Field: ‘earlySignal’
[17:01:10.506]   - Field: ‘lazy’
[17:01:10.506]   - Field: ‘state’
[17:01:10.506] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:10.506] - Launch lazy future ...
[17:01:10.506] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:10.506] Packages needed by future strategies (n = 0): <none>
[17:01:10.507] {
[17:01:10.507]     {
[17:01:10.507]         {
[17:01:10.507]             ...future.startTime <- base::Sys.time()
[17:01:10.507]             {
[17:01:10.507]                 {
[17:01:10.507]                   {
[17:01:10.507]                     {
[17:01:10.507]                       {
[17:01:10.507]                         base::local({
[17:01:10.507]                           has_future <- base::requireNamespace("future", 
[17:01:10.507]                             quietly = TRUE)
[17:01:10.507]                           if (has_future) {
[17:01:10.507]                             ns <- base::getNamespace("future")
[17:01:10.507]                             version <- ns[[".package"]][["version"]]
[17:01:10.507]                             if (is.null(version)) 
[17:01:10.507]                               version <- utils::packageVersion("future")
[17:01:10.507]                           }
[17:01:10.507]                           else {
[17:01:10.507]                             version <- NULL
[17:01:10.507]                           }
[17:01:10.507]                           if (!has_future || version < "1.8.0") {
[17:01:10.507]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:10.507]                               "", base::R.version$version.string), 
[17:01:10.507]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:10.507]                                 base::R.version$platform, 8 * 
[17:01:10.507]                                   base::.Machine$sizeof.pointer), 
[17:01:10.507]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:10.507]                                 "release", "version")], collapse = " "), 
[17:01:10.507]                               hostname = base::Sys.info()[["nodename"]])
[17:01:10.507]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:10.507]                               info)
[17:01:10.507]                             info <- base::paste(info, collapse = "; ")
[17:01:10.507]                             if (!has_future) {
[17:01:10.507]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:10.507]                                 info)
[17:01:10.507]                             }
[17:01:10.507]                             else {
[17:01:10.507]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:10.507]                                 info, version)
[17:01:10.507]                             }
[17:01:10.507]                             base::stop(msg)
[17:01:10.507]                           }
[17:01:10.507]                         })
[17:01:10.507]                       }
[17:01:10.507]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:10.507]                       base::options(mc.cores = 1L)
[17:01:10.507]                     }
[17:01:10.507]                     base::local({
[17:01:10.507]                       for (pkg in "future.apply") {
[17:01:10.507]                         base::loadNamespace(pkg)
[17:01:10.507]                         base::library(pkg, character.only = TRUE)
[17:01:10.507]                       }
[17:01:10.507]                     })
[17:01:10.507]                   }
[17:01:10.507]                   ...future.strategy.old <- future::plan("list")
[17:01:10.507]                   options(future.plan = NULL)
[17:01:10.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:10.507]                 }
[17:01:10.507]                 ...future.workdir <- getwd()
[17:01:10.507]             }
[17:01:10.507]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:10.507]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:10.507]         }
[17:01:10.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:10.507]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:10.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:10.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:10.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:10.507]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:10.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:10.507]             base::names(...future.oldOptions))
[17:01:10.507]     }
[17:01:10.507]     if (FALSE) {
[17:01:10.507]     }
[17:01:10.507]     else {
[17:01:10.507]         if (TRUE) {
[17:01:10.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:10.507]                 open = "w")
[17:01:10.507]         }
[17:01:10.507]         else {
[17:01:10.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:10.507]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:10.507]         }
[17:01:10.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:10.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:10.507]             base::sink(type = "output", split = FALSE)
[17:01:10.507]             base::close(...future.stdout)
[17:01:10.507]         }, add = TRUE)
[17:01:10.507]     }
[17:01:10.507]     ...future.frame <- base::sys.nframe()
[17:01:10.507]     ...future.conditions <- base::list()
[17:01:10.507]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:10.507]     if (FALSE) {
[17:01:10.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:10.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:10.507]     }
[17:01:10.507]     ...future.result <- base::tryCatch({
[17:01:10.507]         base::withCallingHandlers({
[17:01:10.507]             ...future.value <- base::withVisible(base::local({
[17:01:10.507]                 ...future.makeSendCondition <- base::local({
[17:01:10.507]                   sendCondition <- NULL
[17:01:10.507]                   function(frame = 1L) {
[17:01:10.507]                     if (is.function(sendCondition)) 
[17:01:10.507]                       return(sendCondition)
[17:01:10.507]                     ns <- getNamespace("parallel")
[17:01:10.507]                     if (exists("sendData", mode = "function", 
[17:01:10.507]                       envir = ns)) {
[17:01:10.507]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:10.507]                         envir = ns)
[17:01:10.507]                       envir <- sys.frame(frame)
[17:01:10.507]                       master <- NULL
[17:01:10.507]                       while (!identical(envir, .GlobalEnv) && 
[17:01:10.507]                         !identical(envir, emptyenv())) {
[17:01:10.507]                         if (exists("master", mode = "list", envir = envir, 
[17:01:10.507]                           inherits = FALSE)) {
[17:01:10.507]                           master <- get("master", mode = "list", 
[17:01:10.507]                             envir = envir, inherits = FALSE)
[17:01:10.507]                           if (inherits(master, c("SOCKnode", 
[17:01:10.507]                             "SOCK0node"))) {
[17:01:10.507]                             sendCondition <<- function(cond) {
[17:01:10.507]                               data <- list(type = "VALUE", value = cond, 
[17:01:10.507]                                 success = TRUE)
[17:01:10.507]                               parallel_sendData(master, data)
[17:01:10.507]                             }
[17:01:10.507]                             return(sendCondition)
[17:01:10.507]                           }
[17:01:10.507]                         }
[17:01:10.507]                         frame <- frame + 1L
[17:01:10.507]                         envir <- sys.frame(frame)
[17:01:10.507]                       }
[17:01:10.507]                     }
[17:01:10.507]                     sendCondition <<- function(cond) NULL
[17:01:10.507]                   }
[17:01:10.507]                 })
[17:01:10.507]                 withCallingHandlers({
[17:01:10.507]                   {
[17:01:10.507]                     do.call(function(...) {
[17:01:10.507]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.507]                       if (!identical(...future.globals.maxSize.org, 
[17:01:10.507]                         ...future.globals.maxSize)) {
[17:01:10.507]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.507]                         on.exit(options(oopts), add = TRUE)
[17:01:10.507]                       }
[17:01:10.507]                       {
[17:01:10.507]                         lapply(seq_along(...future.elements_ii), 
[17:01:10.507]                           FUN = function(jj) {
[17:01:10.507]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.507]                             ...future.FUN(...future.X_jj, ...)
[17:01:10.507]                           })
[17:01:10.507]                       }
[17:01:10.507]                     }, args = future.call.arguments)
[17:01:10.507]                   }
[17:01:10.507]                 }, immediateCondition = function(cond) {
[17:01:10.507]                   sendCondition <- ...future.makeSendCondition()
[17:01:10.507]                   sendCondition(cond)
[17:01:10.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.507]                   {
[17:01:10.507]                     inherits <- base::inherits
[17:01:10.507]                     invokeRestart <- base::invokeRestart
[17:01:10.507]                     is.null <- base::is.null
[17:01:10.507]                     muffled <- FALSE
[17:01:10.507]                     if (inherits(cond, "message")) {
[17:01:10.507]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:10.507]                       if (muffled) 
[17:01:10.507]                         invokeRestart("muffleMessage")
[17:01:10.507]                     }
[17:01:10.507]                     else if (inherits(cond, "warning")) {
[17:01:10.507]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:10.507]                       if (muffled) 
[17:01:10.507]                         invokeRestart("muffleWarning")
[17:01:10.507]                     }
[17:01:10.507]                     else if (inherits(cond, "condition")) {
[17:01:10.507]                       if (!is.null(pattern)) {
[17:01:10.507]                         computeRestarts <- base::computeRestarts
[17:01:10.507]                         grepl <- base::grepl
[17:01:10.507]                         restarts <- computeRestarts(cond)
[17:01:10.507]                         for (restart in restarts) {
[17:01:10.507]                           name <- restart$name
[17:01:10.507]                           if (is.null(name)) 
[17:01:10.507]                             next
[17:01:10.507]                           if (!grepl(pattern, name)) 
[17:01:10.507]                             next
[17:01:10.507]                           invokeRestart(restart)
[17:01:10.507]                           muffled <- TRUE
[17:01:10.507]                           break
[17:01:10.507]                         }
[17:01:10.507]                       }
[17:01:10.507]                     }
[17:01:10.507]                     invisible(muffled)
[17:01:10.507]                   }
[17:01:10.507]                   muffleCondition(cond)
[17:01:10.507]                 })
[17:01:10.507]             }))
[17:01:10.507]             future::FutureResult(value = ...future.value$value, 
[17:01:10.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.507]                   ...future.rng), globalenv = if (FALSE) 
[17:01:10.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:10.507]                     ...future.globalenv.names))
[17:01:10.507]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:10.507]         }, condition = base::local({
[17:01:10.507]             c <- base::c
[17:01:10.507]             inherits <- base::inherits
[17:01:10.507]             invokeRestart <- base::invokeRestart
[17:01:10.507]             length <- base::length
[17:01:10.507]             list <- base::list
[17:01:10.507]             seq.int <- base::seq.int
[17:01:10.507]             signalCondition <- base::signalCondition
[17:01:10.507]             sys.calls <- base::sys.calls
[17:01:10.507]             `[[` <- base::`[[`
[17:01:10.507]             `+` <- base::`+`
[17:01:10.507]             `<<-` <- base::`<<-`
[17:01:10.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:10.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:10.507]                   3L)]
[17:01:10.507]             }
[17:01:10.507]             function(cond) {
[17:01:10.507]                 is_error <- inherits(cond, "error")
[17:01:10.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:10.507]                   NULL)
[17:01:10.507]                 if (is_error) {
[17:01:10.507]                   sessionInformation <- function() {
[17:01:10.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:10.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:10.507]                       search = base::search(), system = base::Sys.info())
[17:01:10.507]                   }
[17:01:10.507]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:10.507]                     cond$call), session = sessionInformation(), 
[17:01:10.507]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:10.507]                   signalCondition(cond)
[17:01:10.507]                 }
[17:01:10.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:10.507]                 "immediateCondition"))) {
[17:01:10.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:10.507]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:10.507]                   if (TRUE && !signal) {
[17:01:10.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.507]                     {
[17:01:10.507]                       inherits <- base::inherits
[17:01:10.507]                       invokeRestart <- base::invokeRestart
[17:01:10.507]                       is.null <- base::is.null
[17:01:10.507]                       muffled <- FALSE
[17:01:10.507]                       if (inherits(cond, "message")) {
[17:01:10.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.507]                         if (muffled) 
[17:01:10.507]                           invokeRestart("muffleMessage")
[17:01:10.507]                       }
[17:01:10.507]                       else if (inherits(cond, "warning")) {
[17:01:10.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.507]                         if (muffled) 
[17:01:10.507]                           invokeRestart("muffleWarning")
[17:01:10.507]                       }
[17:01:10.507]                       else if (inherits(cond, "condition")) {
[17:01:10.507]                         if (!is.null(pattern)) {
[17:01:10.507]                           computeRestarts <- base::computeRestarts
[17:01:10.507]                           grepl <- base::grepl
[17:01:10.507]                           restarts <- computeRestarts(cond)
[17:01:10.507]                           for (restart in restarts) {
[17:01:10.507]                             name <- restart$name
[17:01:10.507]                             if (is.null(name)) 
[17:01:10.507]                               next
[17:01:10.507]                             if (!grepl(pattern, name)) 
[17:01:10.507]                               next
[17:01:10.507]                             invokeRestart(restart)
[17:01:10.507]                             muffled <- TRUE
[17:01:10.507]                             break
[17:01:10.507]                           }
[17:01:10.507]                         }
[17:01:10.507]                       }
[17:01:10.507]                       invisible(muffled)
[17:01:10.507]                     }
[17:01:10.507]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.507]                   }
[17:01:10.507]                 }
[17:01:10.507]                 else {
[17:01:10.507]                   if (TRUE) {
[17:01:10.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.507]                     {
[17:01:10.507]                       inherits <- base::inherits
[17:01:10.507]                       invokeRestart <- base::invokeRestart
[17:01:10.507]                       is.null <- base::is.null
[17:01:10.507]                       muffled <- FALSE
[17:01:10.507]                       if (inherits(cond, "message")) {
[17:01:10.507]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.507]                         if (muffled) 
[17:01:10.507]                           invokeRestart("muffleMessage")
[17:01:10.507]                       }
[17:01:10.507]                       else if (inherits(cond, "warning")) {
[17:01:10.507]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.507]                         if (muffled) 
[17:01:10.507]                           invokeRestart("muffleWarning")
[17:01:10.507]                       }
[17:01:10.507]                       else if (inherits(cond, "condition")) {
[17:01:10.507]                         if (!is.null(pattern)) {
[17:01:10.507]                           computeRestarts <- base::computeRestarts
[17:01:10.507]                           grepl <- base::grepl
[17:01:10.507]                           restarts <- computeRestarts(cond)
[17:01:10.507]                           for (restart in restarts) {
[17:01:10.507]                             name <- restart$name
[17:01:10.507]                             if (is.null(name)) 
[17:01:10.507]                               next
[17:01:10.507]                             if (!grepl(pattern, name)) 
[17:01:10.507]                               next
[17:01:10.507]                             invokeRestart(restart)
[17:01:10.507]                             muffled <- TRUE
[17:01:10.507]                             break
[17:01:10.507]                           }
[17:01:10.507]                         }
[17:01:10.507]                       }
[17:01:10.507]                       invisible(muffled)
[17:01:10.507]                     }
[17:01:10.507]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.507]                   }
[17:01:10.507]                 }
[17:01:10.507]             }
[17:01:10.507]         }))
[17:01:10.507]     }, error = function(ex) {
[17:01:10.507]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:10.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.507]                 ...future.rng), started = ...future.startTime, 
[17:01:10.507]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:10.507]             version = "1.8"), class = "FutureResult")
[17:01:10.507]     }, finally = {
[17:01:10.507]         if (!identical(...future.workdir, getwd())) 
[17:01:10.507]             setwd(...future.workdir)
[17:01:10.507]         {
[17:01:10.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:10.507]                 ...future.oldOptions$nwarnings <- NULL
[17:01:10.507]             }
[17:01:10.507]             base::options(...future.oldOptions)
[17:01:10.507]             if (.Platform$OS.type == "windows") {
[17:01:10.507]                 old_names <- names(...future.oldEnvVars)
[17:01:10.507]                 envs <- base::Sys.getenv()
[17:01:10.507]                 names <- names(envs)
[17:01:10.507]                 common <- intersect(names, old_names)
[17:01:10.507]                 added <- setdiff(names, old_names)
[17:01:10.507]                 removed <- setdiff(old_names, names)
[17:01:10.507]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:10.507]                   envs[common]]
[17:01:10.507]                 NAMES <- toupper(changed)
[17:01:10.507]                 args <- list()
[17:01:10.507]                 for (kk in seq_along(NAMES)) {
[17:01:10.507]                   name <- changed[[kk]]
[17:01:10.507]                   NAME <- NAMES[[kk]]
[17:01:10.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.507]                     next
[17:01:10.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.507]                 }
[17:01:10.507]                 NAMES <- toupper(added)
[17:01:10.507]                 for (kk in seq_along(NAMES)) {
[17:01:10.507]                   name <- added[[kk]]
[17:01:10.507]                   NAME <- NAMES[[kk]]
[17:01:10.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.507]                     next
[17:01:10.507]                   args[[name]] <- ""
[17:01:10.507]                 }
[17:01:10.507]                 NAMES <- toupper(removed)
[17:01:10.507]                 for (kk in seq_along(NAMES)) {
[17:01:10.507]                   name <- removed[[kk]]
[17:01:10.507]                   NAME <- NAMES[[kk]]
[17:01:10.507]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.507]                     next
[17:01:10.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.507]                 }
[17:01:10.507]                 if (length(args) > 0) 
[17:01:10.507]                   base::do.call(base::Sys.setenv, args = args)
[17:01:10.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:10.507]             }
[17:01:10.507]             else {
[17:01:10.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:10.507]             }
[17:01:10.507]             {
[17:01:10.507]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:10.507]                   0L) {
[17:01:10.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:10.507]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:10.507]                   base::options(opts)
[17:01:10.507]                 }
[17:01:10.507]                 {
[17:01:10.507]                   {
[17:01:10.507]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:10.507]                     NULL
[17:01:10.507]                   }
[17:01:10.507]                   options(future.plan = NULL)
[17:01:10.507]                   if (is.na(NA_character_)) 
[17:01:10.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:10.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:10.507]                     .init = FALSE)
[17:01:10.507]                 }
[17:01:10.507]             }
[17:01:10.507]         }
[17:01:10.507]     })
[17:01:10.507]     if (TRUE) {
[17:01:10.507]         base::sink(type = "output", split = FALSE)
[17:01:10.507]         if (TRUE) {
[17:01:10.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:10.507]         }
[17:01:10.507]         else {
[17:01:10.507]             ...future.result["stdout"] <- base::list(NULL)
[17:01:10.507]         }
[17:01:10.507]         base::close(...future.stdout)
[17:01:10.507]         ...future.stdout <- NULL
[17:01:10.507]     }
[17:01:10.507]     ...future.result$conditions <- ...future.conditions
[17:01:10.507]     ...future.result$finished <- base::Sys.time()
[17:01:10.507]     ...future.result
[17:01:10.507] }
[17:01:10.510] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[17:01:10.510] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:01:10.556] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:01:10.556] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[17:01:10.556] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[17:01:10.557] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:01:10.557] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:01:10.557] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:01:10.600] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:01:10.600] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:01:10.644] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:01:10.644] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:01:10.644] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.645] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:01:10.645] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:01:10.645] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:01:10.645] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.646] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:01:10.646] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:01:10.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:01:10.646] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.646] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:01:10.647] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:01:10.647] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[17:01:10.647] MultisessionFuture started
[17:01:10.648] - Launch lazy future ... done
[17:01:10.648] run() for ‘MultisessionFuture’ ... done
[17:01:10.648] Created future:
[17:01:10.648] MultisessionFuture:
[17:01:10.648] Label: ‘future_vapply-1’
[17:01:10.648] Expression:
[17:01:10.648] {
[17:01:10.648]     do.call(function(...) {
[17:01:10.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.648]             on.exit(options(oopts), add = TRUE)
[17:01:10.648]         }
[17:01:10.648]         {
[17:01:10.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.648]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.648]             })
[17:01:10.648]         }
[17:01:10.648]     }, args = future.call.arguments)
[17:01:10.648] }
[17:01:10.648] Lazy evaluation: FALSE
[17:01:10.648] Asynchronous evaluation: TRUE
[17:01:10.648] Local evaluation: TRUE
[17:01:10.648] Environment: R_GlobalEnv
[17:01:10.648] Capture standard output: TRUE
[17:01:10.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:10.648] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:10.648] Packages: 1 packages (‘future.apply’)
[17:01:10.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:10.648] Resolved: FALSE
[17:01:10.648] Value: <not collected>
[17:01:10.648] Conditions captured: <none>
[17:01:10.648] Early signaling: FALSE
[17:01:10.648] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:10.648] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.660] Chunk #1 of 2 ... DONE
[17:01:10.660] Chunk #2 of 2 ...
[17:01:10.660]  - Finding globals in 'X' for chunk #2 ...
[17:01:10.660] getGlobalsAndPackages() ...
[17:01:10.660] Searching for globals...
[17:01:10.660] 
[17:01:10.661] Searching for globals ... DONE
[17:01:10.661] - globals: [0] <none>
[17:01:10.661] getGlobalsAndPackages() ... DONE
[17:01:10.661]    + additional globals found: [n=0] 
[17:01:10.661]    + additional namespaces needed: [n=0] 
[17:01:10.661]  - Finding globals in 'X' for chunk #2 ... DONE
[17:01:10.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:01:10.661]  - seeds: <none>
[17:01:10.661]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.662] getGlobalsAndPackages() ...
[17:01:10.662] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.662] Resolving globals: FALSE
[17:01:10.662] Tweak future expression to call with '...' arguments ...
[17:01:10.662] {
[17:01:10.662]     do.call(function(...) {
[17:01:10.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.662]             on.exit(options(oopts), add = TRUE)
[17:01:10.662]         }
[17:01:10.662]         {
[17:01:10.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.662]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.662]             })
[17:01:10.662]         }
[17:01:10.662]     }, args = future.call.arguments)
[17:01:10.662] }
[17:01:10.662] Tweak future expression to call with '...' arguments ... DONE
[17:01:10.663] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:01:10.663] - packages: [1] ‘future.apply’
[17:01:10.663] getGlobalsAndPackages() ... DONE
[17:01:10.663] run() for ‘Future’ ...
[17:01:10.663] - state: ‘created’
[17:01:10.664] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:01:10.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:01:10.678]   - Field: ‘node’
[17:01:10.678]   - Field: ‘label’
[17:01:10.678]   - Field: ‘local’
[17:01:10.678]   - Field: ‘owner’
[17:01:10.678]   - Field: ‘envir’
[17:01:10.678]   - Field: ‘workers’
[17:01:10.678]   - Field: ‘packages’
[17:01:10.679]   - Field: ‘gc’
[17:01:10.679]   - Field: ‘conditions’
[17:01:10.679]   - Field: ‘persistent’
[17:01:10.679]   - Field: ‘expr’
[17:01:10.679]   - Field: ‘uuid’
[17:01:10.679]   - Field: ‘seed’
[17:01:10.679]   - Field: ‘version’
[17:01:10.679]   - Field: ‘result’
[17:01:10.679]   - Field: ‘asynchronous’
[17:01:10.679]   - Field: ‘calls’
[17:01:10.680]   - Field: ‘globals’
[17:01:10.680]   - Field: ‘stdout’
[17:01:10.680]   - Field: ‘earlySignal’
[17:01:10.680]   - Field: ‘lazy’
[17:01:10.680]   - Field: ‘state’
[17:01:10.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:01:10.680] - Launch lazy future ...
[17:01:10.680] Packages needed by the future expression (n = 1): ‘future.apply’
[17:01:10.681] Packages needed by future strategies (n = 0): <none>
[17:01:10.681] {
[17:01:10.681]     {
[17:01:10.681]         {
[17:01:10.681]             ...future.startTime <- base::Sys.time()
[17:01:10.681]             {
[17:01:10.681]                 {
[17:01:10.681]                   {
[17:01:10.681]                     {
[17:01:10.681]                       {
[17:01:10.681]                         base::local({
[17:01:10.681]                           has_future <- base::requireNamespace("future", 
[17:01:10.681]                             quietly = TRUE)
[17:01:10.681]                           if (has_future) {
[17:01:10.681]                             ns <- base::getNamespace("future")
[17:01:10.681]                             version <- ns[[".package"]][["version"]]
[17:01:10.681]                             if (is.null(version)) 
[17:01:10.681]                               version <- utils::packageVersion("future")
[17:01:10.681]                           }
[17:01:10.681]                           else {
[17:01:10.681]                             version <- NULL
[17:01:10.681]                           }
[17:01:10.681]                           if (!has_future || version < "1.8.0") {
[17:01:10.681]                             info <- base::c(r_version = base::gsub("R version ", 
[17:01:10.681]                               "", base::R.version$version.string), 
[17:01:10.681]                               platform = base::sprintf("%s (%s-bit)", 
[17:01:10.681]                                 base::R.version$platform, 8 * 
[17:01:10.681]                                   base::.Machine$sizeof.pointer), 
[17:01:10.681]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:01:10.681]                                 "release", "version")], collapse = " "), 
[17:01:10.681]                               hostname = base::Sys.info()[["nodename"]])
[17:01:10.681]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:01:10.681]                               info)
[17:01:10.681]                             info <- base::paste(info, collapse = "; ")
[17:01:10.681]                             if (!has_future) {
[17:01:10.681]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:01:10.681]                                 info)
[17:01:10.681]                             }
[17:01:10.681]                             else {
[17:01:10.681]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:01:10.681]                                 info, version)
[17:01:10.681]                             }
[17:01:10.681]                             base::stop(msg)
[17:01:10.681]                           }
[17:01:10.681]                         })
[17:01:10.681]                       }
[17:01:10.681]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:01:10.681]                       base::options(mc.cores = 1L)
[17:01:10.681]                     }
[17:01:10.681]                     base::local({
[17:01:10.681]                       for (pkg in "future.apply") {
[17:01:10.681]                         base::loadNamespace(pkg)
[17:01:10.681]                         base::library(pkg, character.only = TRUE)
[17:01:10.681]                       }
[17:01:10.681]                     })
[17:01:10.681]                   }
[17:01:10.681]                   ...future.strategy.old <- future::plan("list")
[17:01:10.681]                   options(future.plan = NULL)
[17:01:10.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:01:10.681]                 }
[17:01:10.681]                 ...future.workdir <- getwd()
[17:01:10.681]             }
[17:01:10.681]             ...future.oldOptions <- base::as.list(base::.Options)
[17:01:10.681]             ...future.oldEnvVars <- base::Sys.getenv()
[17:01:10.681]         }
[17:01:10.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:01:10.681]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:01:10.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:01:10.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:01:10.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:01:10.681]             future.stdout.windows.reencode = NULL, width = 80L)
[17:01:10.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:01:10.681]             base::names(...future.oldOptions))
[17:01:10.681]     }
[17:01:10.681]     if (FALSE) {
[17:01:10.681]     }
[17:01:10.681]     else {
[17:01:10.681]         if (TRUE) {
[17:01:10.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:01:10.681]                 open = "w")
[17:01:10.681]         }
[17:01:10.681]         else {
[17:01:10.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:01:10.681]                 windows = "NUL", "/dev/null"), open = "w")
[17:01:10.681]         }
[17:01:10.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:01:10.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:01:10.681]             base::sink(type = "output", split = FALSE)
[17:01:10.681]             base::close(...future.stdout)
[17:01:10.681]         }, add = TRUE)
[17:01:10.681]     }
[17:01:10.681]     ...future.frame <- base::sys.nframe()
[17:01:10.681]     ...future.conditions <- base::list()
[17:01:10.681]     ...future.rng <- base::globalenv()$.Random.seed
[17:01:10.681]     if (FALSE) {
[17:01:10.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:01:10.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:01:10.681]     }
[17:01:10.681]     ...future.result <- base::tryCatch({
[17:01:10.681]         base::withCallingHandlers({
[17:01:10.681]             ...future.value <- base::withVisible(base::local({
[17:01:10.681]                 ...future.makeSendCondition <- base::local({
[17:01:10.681]                   sendCondition <- NULL
[17:01:10.681]                   function(frame = 1L) {
[17:01:10.681]                     if (is.function(sendCondition)) 
[17:01:10.681]                       return(sendCondition)
[17:01:10.681]                     ns <- getNamespace("parallel")
[17:01:10.681]                     if (exists("sendData", mode = "function", 
[17:01:10.681]                       envir = ns)) {
[17:01:10.681]                       parallel_sendData <- get("sendData", mode = "function", 
[17:01:10.681]                         envir = ns)
[17:01:10.681]                       envir <- sys.frame(frame)
[17:01:10.681]                       master <- NULL
[17:01:10.681]                       while (!identical(envir, .GlobalEnv) && 
[17:01:10.681]                         !identical(envir, emptyenv())) {
[17:01:10.681]                         if (exists("master", mode = "list", envir = envir, 
[17:01:10.681]                           inherits = FALSE)) {
[17:01:10.681]                           master <- get("master", mode = "list", 
[17:01:10.681]                             envir = envir, inherits = FALSE)
[17:01:10.681]                           if (inherits(master, c("SOCKnode", 
[17:01:10.681]                             "SOCK0node"))) {
[17:01:10.681]                             sendCondition <<- function(cond) {
[17:01:10.681]                               data <- list(type = "VALUE", value = cond, 
[17:01:10.681]                                 success = TRUE)
[17:01:10.681]                               parallel_sendData(master, data)
[17:01:10.681]                             }
[17:01:10.681]                             return(sendCondition)
[17:01:10.681]                           }
[17:01:10.681]                         }
[17:01:10.681]                         frame <- frame + 1L
[17:01:10.681]                         envir <- sys.frame(frame)
[17:01:10.681]                       }
[17:01:10.681]                     }
[17:01:10.681]                     sendCondition <<- function(cond) NULL
[17:01:10.681]                   }
[17:01:10.681]                 })
[17:01:10.681]                 withCallingHandlers({
[17:01:10.681]                   {
[17:01:10.681]                     do.call(function(...) {
[17:01:10.681]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.681]                       if (!identical(...future.globals.maxSize.org, 
[17:01:10.681]                         ...future.globals.maxSize)) {
[17:01:10.681]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.681]                         on.exit(options(oopts), add = TRUE)
[17:01:10.681]                       }
[17:01:10.681]                       {
[17:01:10.681]                         lapply(seq_along(...future.elements_ii), 
[17:01:10.681]                           FUN = function(jj) {
[17:01:10.681]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.681]                             ...future.FUN(...future.X_jj, ...)
[17:01:10.681]                           })
[17:01:10.681]                       }
[17:01:10.681]                     }, args = future.call.arguments)
[17:01:10.681]                   }
[17:01:10.681]                 }, immediateCondition = function(cond) {
[17:01:10.681]                   sendCondition <- ...future.makeSendCondition()
[17:01:10.681]                   sendCondition(cond)
[17:01:10.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.681]                   {
[17:01:10.681]                     inherits <- base::inherits
[17:01:10.681]                     invokeRestart <- base::invokeRestart
[17:01:10.681]                     is.null <- base::is.null
[17:01:10.681]                     muffled <- FALSE
[17:01:10.681]                     if (inherits(cond, "message")) {
[17:01:10.681]                       muffled <- grepl(pattern, "muffleMessage")
[17:01:10.681]                       if (muffled) 
[17:01:10.681]                         invokeRestart("muffleMessage")
[17:01:10.681]                     }
[17:01:10.681]                     else if (inherits(cond, "warning")) {
[17:01:10.681]                       muffled <- grepl(pattern, "muffleWarning")
[17:01:10.681]                       if (muffled) 
[17:01:10.681]                         invokeRestart("muffleWarning")
[17:01:10.681]                     }
[17:01:10.681]                     else if (inherits(cond, "condition")) {
[17:01:10.681]                       if (!is.null(pattern)) {
[17:01:10.681]                         computeRestarts <- base::computeRestarts
[17:01:10.681]                         grepl <- base::grepl
[17:01:10.681]                         restarts <- computeRestarts(cond)
[17:01:10.681]                         for (restart in restarts) {
[17:01:10.681]                           name <- restart$name
[17:01:10.681]                           if (is.null(name)) 
[17:01:10.681]                             next
[17:01:10.681]                           if (!grepl(pattern, name)) 
[17:01:10.681]                             next
[17:01:10.681]                           invokeRestart(restart)
[17:01:10.681]                           muffled <- TRUE
[17:01:10.681]                           break
[17:01:10.681]                         }
[17:01:10.681]                       }
[17:01:10.681]                     }
[17:01:10.681]                     invisible(muffled)
[17:01:10.681]                   }
[17:01:10.681]                   muffleCondition(cond)
[17:01:10.681]                 })
[17:01:10.681]             }))
[17:01:10.681]             future::FutureResult(value = ...future.value$value, 
[17:01:10.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.681]                   ...future.rng), globalenv = if (FALSE) 
[17:01:10.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:01:10.681]                     ...future.globalenv.names))
[17:01:10.681]                 else NULL, started = ...future.startTime, version = "1.8")
[17:01:10.681]         }, condition = base::local({
[17:01:10.681]             c <- base::c
[17:01:10.681]             inherits <- base::inherits
[17:01:10.681]             invokeRestart <- base::invokeRestart
[17:01:10.681]             length <- base::length
[17:01:10.681]             list <- base::list
[17:01:10.681]             seq.int <- base::seq.int
[17:01:10.681]             signalCondition <- base::signalCondition
[17:01:10.681]             sys.calls <- base::sys.calls
[17:01:10.681]             `[[` <- base::`[[`
[17:01:10.681]             `+` <- base::`+`
[17:01:10.681]             `<<-` <- base::`<<-`
[17:01:10.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:01:10.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:01:10.681]                   3L)]
[17:01:10.681]             }
[17:01:10.681]             function(cond) {
[17:01:10.681]                 is_error <- inherits(cond, "error")
[17:01:10.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:01:10.681]                   NULL)
[17:01:10.681]                 if (is_error) {
[17:01:10.681]                   sessionInformation <- function() {
[17:01:10.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:01:10.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:01:10.681]                       search = base::search(), system = base::Sys.info())
[17:01:10.681]                   }
[17:01:10.681]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:01:10.681]                     cond$call), session = sessionInformation(), 
[17:01:10.681]                     timestamp = base::Sys.time(), signaled = 0L)
[17:01:10.681]                   signalCondition(cond)
[17:01:10.681]                 }
[17:01:10.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:01:10.681]                 "immediateCondition"))) {
[17:01:10.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:01:10.681]                   ...future.conditions[[length(...future.conditions) + 
[17:01:10.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:01:10.681]                   if (TRUE && !signal) {
[17:01:10.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.681]                     {
[17:01:10.681]                       inherits <- base::inherits
[17:01:10.681]                       invokeRestart <- base::invokeRestart
[17:01:10.681]                       is.null <- base::is.null
[17:01:10.681]                       muffled <- FALSE
[17:01:10.681]                       if (inherits(cond, "message")) {
[17:01:10.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.681]                         if (muffled) 
[17:01:10.681]                           invokeRestart("muffleMessage")
[17:01:10.681]                       }
[17:01:10.681]                       else if (inherits(cond, "warning")) {
[17:01:10.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.681]                         if (muffled) 
[17:01:10.681]                           invokeRestart("muffleWarning")
[17:01:10.681]                       }
[17:01:10.681]                       else if (inherits(cond, "condition")) {
[17:01:10.681]                         if (!is.null(pattern)) {
[17:01:10.681]                           computeRestarts <- base::computeRestarts
[17:01:10.681]                           grepl <- base::grepl
[17:01:10.681]                           restarts <- computeRestarts(cond)
[17:01:10.681]                           for (restart in restarts) {
[17:01:10.681]                             name <- restart$name
[17:01:10.681]                             if (is.null(name)) 
[17:01:10.681]                               next
[17:01:10.681]                             if (!grepl(pattern, name)) 
[17:01:10.681]                               next
[17:01:10.681]                             invokeRestart(restart)
[17:01:10.681]                             muffled <- TRUE
[17:01:10.681]                             break
[17:01:10.681]                           }
[17:01:10.681]                         }
[17:01:10.681]                       }
[17:01:10.681]                       invisible(muffled)
[17:01:10.681]                     }
[17:01:10.681]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.681]                   }
[17:01:10.681]                 }
[17:01:10.681]                 else {
[17:01:10.681]                   if (TRUE) {
[17:01:10.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:01:10.681]                     {
[17:01:10.681]                       inherits <- base::inherits
[17:01:10.681]                       invokeRestart <- base::invokeRestart
[17:01:10.681]                       is.null <- base::is.null
[17:01:10.681]                       muffled <- FALSE
[17:01:10.681]                       if (inherits(cond, "message")) {
[17:01:10.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:01:10.681]                         if (muffled) 
[17:01:10.681]                           invokeRestart("muffleMessage")
[17:01:10.681]                       }
[17:01:10.681]                       else if (inherits(cond, "warning")) {
[17:01:10.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:01:10.681]                         if (muffled) 
[17:01:10.681]                           invokeRestart("muffleWarning")
[17:01:10.681]                       }
[17:01:10.681]                       else if (inherits(cond, "condition")) {
[17:01:10.681]                         if (!is.null(pattern)) {
[17:01:10.681]                           computeRestarts <- base::computeRestarts
[17:01:10.681]                           grepl <- base::grepl
[17:01:10.681]                           restarts <- computeRestarts(cond)
[17:01:10.681]                           for (restart in restarts) {
[17:01:10.681]                             name <- restart$name
[17:01:10.681]                             if (is.null(name)) 
[17:01:10.681]                               next
[17:01:10.681]                             if (!grepl(pattern, name)) 
[17:01:10.681]                               next
[17:01:10.681]                             invokeRestart(restart)
[17:01:10.681]                             muffled <- TRUE
[17:01:10.681]                             break
[17:01:10.681]                           }
[17:01:10.681]                         }
[17:01:10.681]                       }
[17:01:10.681]                       invisible(muffled)
[17:01:10.681]                     }
[17:01:10.681]                     muffleCondition(cond, pattern = "^muffle")
[17:01:10.681]                   }
[17:01:10.681]                 }
[17:01:10.681]             }
[17:01:10.681]         }))
[17:01:10.681]     }, error = function(ex) {
[17:01:10.681]         base::structure(base::list(value = NULL, visible = NULL, 
[17:01:10.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:01:10.681]                 ...future.rng), started = ...future.startTime, 
[17:01:10.681]             finished = Sys.time(), session_uuid = NA_character_, 
[17:01:10.681]             version = "1.8"), class = "FutureResult")
[17:01:10.681]     }, finally = {
[17:01:10.681]         if (!identical(...future.workdir, getwd())) 
[17:01:10.681]             setwd(...future.workdir)
[17:01:10.681]         {
[17:01:10.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:01:10.681]                 ...future.oldOptions$nwarnings <- NULL
[17:01:10.681]             }
[17:01:10.681]             base::options(...future.oldOptions)
[17:01:10.681]             if (.Platform$OS.type == "windows") {
[17:01:10.681]                 old_names <- names(...future.oldEnvVars)
[17:01:10.681]                 envs <- base::Sys.getenv()
[17:01:10.681]                 names <- names(envs)
[17:01:10.681]                 common <- intersect(names, old_names)
[17:01:10.681]                 added <- setdiff(names, old_names)
[17:01:10.681]                 removed <- setdiff(old_names, names)
[17:01:10.681]                 changed <- common[...future.oldEnvVars[common] != 
[17:01:10.681]                   envs[common]]
[17:01:10.681]                 NAMES <- toupper(changed)
[17:01:10.681]                 args <- list()
[17:01:10.681]                 for (kk in seq_along(NAMES)) {
[17:01:10.681]                   name <- changed[[kk]]
[17:01:10.681]                   NAME <- NAMES[[kk]]
[17:01:10.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.681]                     next
[17:01:10.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.681]                 }
[17:01:10.681]                 NAMES <- toupper(added)
[17:01:10.681]                 for (kk in seq_along(NAMES)) {
[17:01:10.681]                   name <- added[[kk]]
[17:01:10.681]                   NAME <- NAMES[[kk]]
[17:01:10.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.681]                     next
[17:01:10.681]                   args[[name]] <- ""
[17:01:10.681]                 }
[17:01:10.681]                 NAMES <- toupper(removed)
[17:01:10.681]                 for (kk in seq_along(NAMES)) {
[17:01:10.681]                   name <- removed[[kk]]
[17:01:10.681]                   NAME <- NAMES[[kk]]
[17:01:10.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:01:10.681]                     next
[17:01:10.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:01:10.681]                 }
[17:01:10.681]                 if (length(args) > 0) 
[17:01:10.681]                   base::do.call(base::Sys.setenv, args = args)
[17:01:10.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:01:10.681]             }
[17:01:10.681]             else {
[17:01:10.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:01:10.681]             }
[17:01:10.681]             {
[17:01:10.681]                 if (base::length(...future.futureOptionsAdded) > 
[17:01:10.681]                   0L) {
[17:01:10.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:01:10.681]                   base::names(opts) <- ...future.futureOptionsAdded
[17:01:10.681]                   base::options(opts)
[17:01:10.681]                 }
[17:01:10.681]                 {
[17:01:10.681]                   {
[17:01:10.681]                     base::options(mc.cores = ...future.mc.cores.old)
[17:01:10.681]                     NULL
[17:01:10.681]                   }
[17:01:10.681]                   options(future.plan = NULL)
[17:01:10.681]                   if (is.na(NA_character_)) 
[17:01:10.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:01:10.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:01:10.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:01:10.681]                     .init = FALSE)
[17:01:10.681]                 }
[17:01:10.681]             }
[17:01:10.681]         }
[17:01:10.681]     })
[17:01:10.681]     if (TRUE) {
[17:01:10.681]         base::sink(type = "output", split = FALSE)
[17:01:10.681]         if (TRUE) {
[17:01:10.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:01:10.681]         }
[17:01:10.681]         else {
[17:01:10.681]             ...future.result["stdout"] <- base::list(NULL)
[17:01:10.681]         }
[17:01:10.681]         base::close(...future.stdout)
[17:01:10.681]         ...future.stdout <- NULL
[17:01:10.681]     }
[17:01:10.681]     ...future.result$conditions <- ...future.conditions
[17:01:10.681]     ...future.result$finished <- base::Sys.time()
[17:01:10.681]     ...future.result
[17:01:10.681] }
[17:01:10.684] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[17:01:10.684] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:01:10.728] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:01:10.728] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[17:01:10.728] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[17:01:10.729] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:01:10.729] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:01:10.729] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:01:10.772] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:01:10.772] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:01:10.816] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:01:10.816] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:01:10.817] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.817] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:01:10.817] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:01:10.817] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:01:10.818] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.818] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:01:10.818] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:01:10.818] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:01:10.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:01:10.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:01:10.819] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[17:01:10.820] MultisessionFuture started
[17:01:10.820] - Launch lazy future ... done
[17:01:10.820] run() for ‘MultisessionFuture’ ... done
[17:01:10.820] Created future:
[17:01:10.822] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.822] - Validating connection of MultisessionFuture
[17:01:10.823] - received message: FutureResult
[17:01:10.823] - Received FutureResult
[17:01:10.823] - Erased future from FutureRegistry
[17:01:10.823] result() for ClusterFuture ...
[17:01:10.823] - result already collected: FutureResult
[17:01:10.823] result() for ClusterFuture ... done
[17:01:10.823] signalConditions() ...
[17:01:10.823]  - include = ‘immediateCondition’
[17:01:10.823]  - exclude = 
[17:01:10.823]  - resignal = FALSE
[17:01:10.824]  - Number of conditions: 1
[17:01:10.824] signalConditions() ... done
[17:01:10.824] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.820] MultisessionFuture:
[17:01:10.820] Label: ‘future_vapply-2’
[17:01:10.820] Expression:
[17:01:10.820] {
[17:01:10.820]     do.call(function(...) {
[17:01:10.820]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:01:10.820]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:01:10.820]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:01:10.820]             on.exit(options(oopts), add = TRUE)
[17:01:10.820]         }
[17:01:10.820]         {
[17:01:10.820]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:01:10.820]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:01:10.820]                 ...future.FUN(...future.X_jj, ...)
[17:01:10.820]             })
[17:01:10.820]         }
[17:01:10.820]     }, args = future.call.arguments)
[17:01:10.820] }
[17:01:10.820] Lazy evaluation: FALSE
[17:01:10.820] Asynchronous evaluation: TRUE
[17:01:10.820] Local evaluation: TRUE
[17:01:10.820] Environment: R_GlobalEnv
[17:01:10.820] Capture standard output: TRUE
[17:01:10.820] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:01:10.820] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:01:10.820] Packages: 1 packages (‘future.apply’)
[17:01:10.820] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:01:10.820] Resolved: TRUE
[17:01:10.820] Value: <not collected>
[17:01:10.820] Conditions captured: <none>
[17:01:10.820] Early signaling: FALSE
[17:01:10.820] Owner process: 0e872b5d-3cac-a675-7247-501ea8da4f6f
[17:01:10.820] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:01:10.824] Chunk #2 of 2 ... DONE
[17:01:10.824] Launching 2 futures (chunks) ... DONE
[17:01:10.824] Resolving 2 futures (chunks) ...
[17:01:10.824] resolve() on list ...
[17:01:10.824]  recursive: 0
[17:01:10.825]  length: 2
[17:01:10.825] 
[17:01:10.825] receiveMessageFromWorker() for ClusterFuture ...
[17:01:10.825] - Validating connection of MultisessionFuture
[17:01:10.826] - received message: FutureResult
[17:01:10.826] - Received FutureResult
[17:01:10.826] - Erased future from FutureRegistry
[17:01:10.826] result() for ClusterFuture ...
[17:01:10.826] - result already collected: FutureResult
[17:01:10.826] result() for ClusterFuture ... done
[17:01:10.826] signalConditions() ...
[17:01:10.826]  - include = ‘immediateCondition’
[17:01:10.826]  - exclude = 
[17:01:10.826]  - resignal = FALSE
[17:01:10.826]  - Number of conditions: 1
[17:01:10.826] signalConditions() ... done
[17:01:10.827] receiveMessageFromWorker() for ClusterFuture ... done
[17:01:10.827] Future #1
[17:01:10.827] result() for ClusterFuture ...
[17:01:10.827] - result already collected: FutureResult
[17:01:10.827] result() for ClusterFuture ... done
[17:01:10.827] result() for ClusterFuture ...
[17:01:10.827] - result already collected: FutureResult
[17:01:10.827] result() for ClusterFuture ... done
[17:01:10.827] signalConditions() ...
[17:01:10.827]  - include = ‘immediateCondition’
[17:01:10.827]  - exclude = 
[17:01:10.828]  - resignal = FALSE
[17:01:10.828]  - Number of conditions: 1
[17:01:10.828] signalConditions() ... done
[17:01:10.828] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:01:10.828] - nx: 2
[17:01:10.828] - relay: TRUE
[17:01:10.828] - stdout: TRUE
[17:01:10.828] - signal: TRUE
[17:01:10.828] - resignal: FALSE
[17:01:10.828] - force: TRUE
[17:01:10.828] - relayed: [n=2] FALSE, FALSE
[17:01:10.828] - queued futures: [n=2] FALSE, FALSE
[17:01:10.829]  - until=1
[17:01:10.829]  - relaying element #1
[17:01:10.829] result() for ClusterFuture ...
[17:01:10.829] - result already collected: FutureResult
[17:01:10.829] result() for ClusterFuture ... done
[17:01:10.829] result() for ClusterFuture ...
[17:01:10.829] - result already collected: FutureResult
[17:01:10.829] result() for ClusterFuture ... done
[17:01:10.829] signalConditions() ...
[17:01:10.829]  - include = ‘immediateCondition’
[17:01:10.829]  - exclude = 
[17:01:10.830]  - resignal = FALSE
[17:01:10.830]  - Number of conditions: 1
[17:01:10.830] signalConditions() ... done
[17:01:10.830] result() for ClusterFuture ...
[17:01:10.830] - result already collected: FutureResult
[17:01:10.830] result() for ClusterFuture ... done
[17:01:10.830] signalConditions() ...
[17:01:10.830]  - include = ‘immediateCondition’
[17:01:10.830]  - exclude = 
[17:01:10.830]  - resignal = FALSE
[17:01:10.830]  - Number of conditions: 1
[17:01:10.830] signalConditions() ... done
[17:01:10.831] result() for ClusterFuture ...
[17:01:10.831] - result already collected: FutureResult
[17:01:10.831] result() for ClusterFuture ... done
[17:01:10.831] signalConditions() ...
[17:01:10.831]  - include = ‘condition’
[17:01:10.831]  - exclude = ‘immediateCondition’
[17:01:10.831]  - resignal = TRUE
[17:01:10.831]  - Number of conditions: 1
[17:01:10.831]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:01:10.831] signalConditions() ... done
[17:01:10.831] - relayed: [n=2] FALSE, FALSE
[17:01:10.832] - queued futures: [n=2] TRUE, FALSE
[17:01:10.832] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:01:10.832] plan(): Setting new future strategy stack:
[17:01:10.832] List of future strategies:
[17:01:10.832] 1. sequential:
[17:01:10.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:10.832]    - tweaked: FALSE
[17:01:10.832]    - call: plan(sequential)
[17:01:10.833] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[17:01:10.834] plan(): Setting new future strategy stack:
[17:01:10.834] List of future strategies:
[17:01:10.834] 1. FutureStrategy:
[17:01:10.834]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:01:10.834]    - tweaked: FALSE
[17:01:10.834]    - call: future::plan(oplan)
[17:01:10.835] plan(): nbrOfWorkers() = 1
> 
