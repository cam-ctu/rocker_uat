
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:44:45.134] plan(): Setting new future strategy stack:
[17:44:45.134] List of future strategies:
[17:44:45.134] 1. sequential:
[17:44:45.134]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.134]    - tweaked: FALSE
[17:44:45.134]    - call: future::plan("sequential")
[17:44:45.149] plan(): nbrOfWorkers() = 1
> 
> message("*** future_mapply() ...")
*** future_mapply() ...
> 
> message("- Parallel RNG truth (for later)...")
- Parallel RNG truth (for later)...
> plan(sequential)
[17:44:45.157] plan(): Setting new future strategy stack:
[17:44:45.157] List of future strategies:
[17:44:45.157] 1. sequential:
[17:44:45.157]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.157]    - tweaked: FALSE
[17:44:45.157]    - call: plan(sequential)
[17:44:45.168] plan(): nbrOfWorkers() = 1
> y_rng_0 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                          MoreArgs = list(min = 1), future.seed = 0xBEEF)
[17:44:45.169] future_mapply() ...
[17:44:45.170] Generating random seeds ...
[17:44:45.170] Generating random seed streams for 4 elements ...
[17:44:45.170] Generating random seed streams for 4 elements ... DONE
[17:44:45.170] Generating random seeds ... DONE
[17:44:45.170] Will set RNG state on exit: 10407, 758682982, 2007525116, -28481907, 1098785749, 672537740, -484569582
[17:44:45.171] Number of chunks: 1
[17:44:45.171] getGlobalsAndPackagesXApply() ...
[17:44:45.171]  - future.globals: TRUE
[17:44:45.172] getGlobalsAndPackages() ...
[17:44:45.172] Searching for globals...
[17:44:45.177] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:44:45.177] Searching for globals ... DONE
[17:44:45.177] Resolving globals: FALSE
[17:44:45.178] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:44:45.178] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:44:45.179] - globals: [1] ‘FUN’
[17:44:45.179] - packages: [1] ‘stats’
[17:44:45.179] getGlobalsAndPackages() ... DONE
[17:44:45.179]  - globals found/used: [n=1] ‘FUN’
[17:44:45.179]  - needed namespaces: [n=1] ‘stats’
[17:44:45.179] Finding globals ... DONE
[17:44:45.179] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.180] List of 2
[17:44:45.180]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:44:45.180]  $ MoreArgs     :List of 1
[17:44:45.180]   ..$ min: num 1
[17:44:45.180]  - attr(*, "where")=List of 2
[17:44:45.180]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.180]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.180]  - attr(*, "resolved")= logi FALSE
[17:44:45.180]  - attr(*, "total_size")= num NA
[17:44:45.184] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:45.185] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.185] Number of futures (= number of chunks): 1
[17:44:45.185] Launching 1 futures (chunks) ...
[17:44:45.188] Chunk #1 of 1 ...
[17:44:45.188]  - Finding globals in '...' for chunk #1 ...
[17:44:45.188] getGlobalsAndPackages() ...
[17:44:45.188] Searching for globals...
[17:44:45.188] 
[17:44:45.188] Searching for globals ... DONE
[17:44:45.189] - globals: [0] <none>
[17:44:45.189] getGlobalsAndPackages() ... DONE
[17:44:45.189]    + additional globals found: [n=0] 
[17:44:45.189]    + additional namespaces needed: [n=0] 
[17:44:45.189]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.189]  - seeds: [4] <seeds>
[17:44:45.189]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.189] getGlobalsAndPackages() ...
[17:44:45.189] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.190] Resolving globals: FALSE
[17:44:45.190] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:44:45.191] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:44:45.191] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.191] - packages: [1] ‘stats’
[17:44:45.191] getGlobalsAndPackages() ... DONE
[17:44:45.192] run() for ‘Future’ ...
[17:44:45.192] - state: ‘created’
[17:44:45.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.192] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.193]   - Field: ‘label’
[17:44:45.193]   - Field: ‘local’
[17:44:45.193]   - Field: ‘owner’
[17:44:45.193]   - Field: ‘envir’
[17:44:45.193]   - Field: ‘packages’
[17:44:45.193]   - Field: ‘gc’
[17:44:45.193]   - Field: ‘conditions’
[17:44:45.193]   - Field: ‘expr’
[17:44:45.193]   - Field: ‘uuid’
[17:44:45.193]   - Field: ‘seed’
[17:44:45.193]   - Field: ‘version’
[17:44:45.194]   - Field: ‘result’
[17:44:45.194]   - Field: ‘asynchronous’
[17:44:45.194]   - Field: ‘calls’
[17:44:45.194]   - Field: ‘globals’
[17:44:45.194]   - Field: ‘stdout’
[17:44:45.194]   - Field: ‘earlySignal’
[17:44:45.194]   - Field: ‘lazy’
[17:44:45.194]   - Field: ‘state’
[17:44:45.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.194] - Launch lazy future ...
[17:44:45.195] Packages needed by the future expression (n = 1): ‘stats’
[17:44:45.195] Packages needed by future strategies (n = 0): <none>
[17:44:45.196] {
[17:44:45.196]     {
[17:44:45.196]         {
[17:44:45.196]             ...future.startTime <- base::Sys.time()
[17:44:45.196]             {
[17:44:45.196]                 {
[17:44:45.196]                   {
[17:44:45.196]                     {
[17:44:45.196]                       base::local({
[17:44:45.196]                         has_future <- base::requireNamespace("future", 
[17:44:45.196]                           quietly = TRUE)
[17:44:45.196]                         if (has_future) {
[17:44:45.196]                           ns <- base::getNamespace("future")
[17:44:45.196]                           version <- ns[[".package"]][["version"]]
[17:44:45.196]                           if (is.null(version)) 
[17:44:45.196]                             version <- utils::packageVersion("future")
[17:44:45.196]                         }
[17:44:45.196]                         else {
[17:44:45.196]                           version <- NULL
[17:44:45.196]                         }
[17:44:45.196]                         if (!has_future || version < "1.8.0") {
[17:44:45.196]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.196]                             "", base::R.version$version.string), 
[17:44:45.196]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:45.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.196]                               "release", "version")], collapse = " "), 
[17:44:45.196]                             hostname = base::Sys.info()[["nodename"]])
[17:44:45.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.196]                             info)
[17:44:45.196]                           info <- base::paste(info, collapse = "; ")
[17:44:45.196]                           if (!has_future) {
[17:44:45.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.196]                               info)
[17:44:45.196]                           }
[17:44:45.196]                           else {
[17:44:45.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.196]                               info, version)
[17:44:45.196]                           }
[17:44:45.196]                           base::stop(msg)
[17:44:45.196]                         }
[17:44:45.196]                       })
[17:44:45.196]                     }
[17:44:45.196]                     base::local({
[17:44:45.196]                       for (pkg in "stats") {
[17:44:45.196]                         base::loadNamespace(pkg)
[17:44:45.196]                         base::library(pkg, character.only = TRUE)
[17:44:45.196]                       }
[17:44:45.196]                     })
[17:44:45.196]                   }
[17:44:45.196]                   ...future.strategy.old <- future::plan("list")
[17:44:45.196]                   options(future.plan = NULL)
[17:44:45.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.196]                 }
[17:44:45.196]                 ...future.workdir <- getwd()
[17:44:45.196]             }
[17:44:45.196]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.196]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.196]         }
[17:44:45.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.196]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.196]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.196]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.196]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.196]             base::names(...future.oldOptions))
[17:44:45.196]     }
[17:44:45.196]     if (FALSE) {
[17:44:45.196]     }
[17:44:45.196]     else {
[17:44:45.196]         if (TRUE) {
[17:44:45.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.196]                 open = "w")
[17:44:45.196]         }
[17:44:45.196]         else {
[17:44:45.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.196]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.196]         }
[17:44:45.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.196]             base::sink(type = "output", split = FALSE)
[17:44:45.196]             base::close(...future.stdout)
[17:44:45.196]         }, add = TRUE)
[17:44:45.196]     }
[17:44:45.196]     ...future.frame <- base::sys.nframe()
[17:44:45.196]     ...future.conditions <- base::list()
[17:44:45.196]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.196]     if (FALSE) {
[17:44:45.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.196]     }
[17:44:45.196]     ...future.result <- base::tryCatch({
[17:44:45.196]         base::withCallingHandlers({
[17:44:45.196]             ...future.value <- base::withVisible(base::local({
[17:44:45.196]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.196]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.196]                   ...future.globals.maxSize)) {
[17:44:45.196]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.196]                   on.exit(options(oopts), add = TRUE)
[17:44:45.196]                 }
[17:44:45.196]                 {
[17:44:45.196]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:45.196]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:45.196]                       envir = globalenv(), inherits = FALSE)
[17:44:45.196]                     ...future.FUN(...)
[17:44:45.196]                   }
[17:44:45.196]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:45.196]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:45.196]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.196]                     USE.NAMES = FALSE)
[17:44:45.196]                   do.call(mapply, args = args)
[17:44:45.196]                 }
[17:44:45.196]             }))
[17:44:45.196]             future::FutureResult(value = ...future.value$value, 
[17:44:45.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.196]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.196]                     ...future.globalenv.names))
[17:44:45.196]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.196]         }, condition = base::local({
[17:44:45.196]             c <- base::c
[17:44:45.196]             inherits <- base::inherits
[17:44:45.196]             invokeRestart <- base::invokeRestart
[17:44:45.196]             length <- base::length
[17:44:45.196]             list <- base::list
[17:44:45.196]             seq.int <- base::seq.int
[17:44:45.196]             signalCondition <- base::signalCondition
[17:44:45.196]             sys.calls <- base::sys.calls
[17:44:45.196]             `[[` <- base::`[[`
[17:44:45.196]             `+` <- base::`+`
[17:44:45.196]             `<<-` <- base::`<<-`
[17:44:45.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.196]                   3L)]
[17:44:45.196]             }
[17:44:45.196]             function(cond) {
[17:44:45.196]                 is_error <- inherits(cond, "error")
[17:44:45.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.196]                   NULL)
[17:44:45.196]                 if (is_error) {
[17:44:45.196]                   sessionInformation <- function() {
[17:44:45.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.196]                       search = base::search(), system = base::Sys.info())
[17:44:45.196]                   }
[17:44:45.196]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.196]                     cond$call), session = sessionInformation(), 
[17:44:45.196]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.196]                   signalCondition(cond)
[17:44:45.196]                 }
[17:44:45.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.196]                 "immediateCondition"))) {
[17:44:45.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.196]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.196]                   if (TRUE && !signal) {
[17:44:45.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.196]                     {
[17:44:45.196]                       inherits <- base::inherits
[17:44:45.196]                       invokeRestart <- base::invokeRestart
[17:44:45.196]                       is.null <- base::is.null
[17:44:45.196]                       muffled <- FALSE
[17:44:45.196]                       if (inherits(cond, "message")) {
[17:44:45.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.196]                         if (muffled) 
[17:44:45.196]                           invokeRestart("muffleMessage")
[17:44:45.196]                       }
[17:44:45.196]                       else if (inherits(cond, "warning")) {
[17:44:45.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.196]                         if (muffled) 
[17:44:45.196]                           invokeRestart("muffleWarning")
[17:44:45.196]                       }
[17:44:45.196]                       else if (inherits(cond, "condition")) {
[17:44:45.196]                         if (!is.null(pattern)) {
[17:44:45.196]                           computeRestarts <- base::computeRestarts
[17:44:45.196]                           grepl <- base::grepl
[17:44:45.196]                           restarts <- computeRestarts(cond)
[17:44:45.196]                           for (restart in restarts) {
[17:44:45.196]                             name <- restart$name
[17:44:45.196]                             if (is.null(name)) 
[17:44:45.196]                               next
[17:44:45.196]                             if (!grepl(pattern, name)) 
[17:44:45.196]                               next
[17:44:45.196]                             invokeRestart(restart)
[17:44:45.196]                             muffled <- TRUE
[17:44:45.196]                             break
[17:44:45.196]                           }
[17:44:45.196]                         }
[17:44:45.196]                       }
[17:44:45.196]                       invisible(muffled)
[17:44:45.196]                     }
[17:44:45.196]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.196]                   }
[17:44:45.196]                 }
[17:44:45.196]                 else {
[17:44:45.196]                   if (TRUE) {
[17:44:45.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.196]                     {
[17:44:45.196]                       inherits <- base::inherits
[17:44:45.196]                       invokeRestart <- base::invokeRestart
[17:44:45.196]                       is.null <- base::is.null
[17:44:45.196]                       muffled <- FALSE
[17:44:45.196]                       if (inherits(cond, "message")) {
[17:44:45.196]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.196]                         if (muffled) 
[17:44:45.196]                           invokeRestart("muffleMessage")
[17:44:45.196]                       }
[17:44:45.196]                       else if (inherits(cond, "warning")) {
[17:44:45.196]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.196]                         if (muffled) 
[17:44:45.196]                           invokeRestart("muffleWarning")
[17:44:45.196]                       }
[17:44:45.196]                       else if (inherits(cond, "condition")) {
[17:44:45.196]                         if (!is.null(pattern)) {
[17:44:45.196]                           computeRestarts <- base::computeRestarts
[17:44:45.196]                           grepl <- base::grepl
[17:44:45.196]                           restarts <- computeRestarts(cond)
[17:44:45.196]                           for (restart in restarts) {
[17:44:45.196]                             name <- restart$name
[17:44:45.196]                             if (is.null(name)) 
[17:44:45.196]                               next
[17:44:45.196]                             if (!grepl(pattern, name)) 
[17:44:45.196]                               next
[17:44:45.196]                             invokeRestart(restart)
[17:44:45.196]                             muffled <- TRUE
[17:44:45.196]                             break
[17:44:45.196]                           }
[17:44:45.196]                         }
[17:44:45.196]                       }
[17:44:45.196]                       invisible(muffled)
[17:44:45.196]                     }
[17:44:45.196]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.196]                   }
[17:44:45.196]                 }
[17:44:45.196]             }
[17:44:45.196]         }))
[17:44:45.196]     }, error = function(ex) {
[17:44:45.196]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.196]                 ...future.rng), started = ...future.startTime, 
[17:44:45.196]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.196]             version = "1.8"), class = "FutureResult")
[17:44:45.196]     }, finally = {
[17:44:45.196]         if (!identical(...future.workdir, getwd())) 
[17:44:45.196]             setwd(...future.workdir)
[17:44:45.196]         {
[17:44:45.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.196]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.196]             }
[17:44:45.196]             base::options(...future.oldOptions)
[17:44:45.196]             if (.Platform$OS.type == "windows") {
[17:44:45.196]                 old_names <- names(...future.oldEnvVars)
[17:44:45.196]                 envs <- base::Sys.getenv()
[17:44:45.196]                 names <- names(envs)
[17:44:45.196]                 common <- intersect(names, old_names)
[17:44:45.196]                 added <- setdiff(names, old_names)
[17:44:45.196]                 removed <- setdiff(old_names, names)
[17:44:45.196]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.196]                   envs[common]]
[17:44:45.196]                 NAMES <- toupper(changed)
[17:44:45.196]                 args <- list()
[17:44:45.196]                 for (kk in seq_along(NAMES)) {
[17:44:45.196]                   name <- changed[[kk]]
[17:44:45.196]                   NAME <- NAMES[[kk]]
[17:44:45.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.196]                     next
[17:44:45.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.196]                 }
[17:44:45.196]                 NAMES <- toupper(added)
[17:44:45.196]                 for (kk in seq_along(NAMES)) {
[17:44:45.196]                   name <- added[[kk]]
[17:44:45.196]                   NAME <- NAMES[[kk]]
[17:44:45.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.196]                     next
[17:44:45.196]                   args[[name]] <- ""
[17:44:45.196]                 }
[17:44:45.196]                 NAMES <- toupper(removed)
[17:44:45.196]                 for (kk in seq_along(NAMES)) {
[17:44:45.196]                   name <- removed[[kk]]
[17:44:45.196]                   NAME <- NAMES[[kk]]
[17:44:45.196]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.196]                     next
[17:44:45.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.196]                 }
[17:44:45.196]                 if (length(args) > 0) 
[17:44:45.196]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.196]             }
[17:44:45.196]             else {
[17:44:45.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.196]             }
[17:44:45.196]             {
[17:44:45.196]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.196]                   0L) {
[17:44:45.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.196]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.196]                   base::options(opts)
[17:44:45.196]                 }
[17:44:45.196]                 {
[17:44:45.196]                   {
[17:44:45.196]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.196]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.196]                     -484569582L), envir = base::globalenv(), 
[17:44:45.196]                       inherits = FALSE)
[17:44:45.196]                     NULL
[17:44:45.196]                   }
[17:44:45.196]                   options(future.plan = NULL)
[17:44:45.196]                   if (is.na(NA_character_)) 
[17:44:45.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.196]                     .init = FALSE)
[17:44:45.196]                 }
[17:44:45.196]             }
[17:44:45.196]         }
[17:44:45.196]     })
[17:44:45.196]     if (TRUE) {
[17:44:45.196]         base::sink(type = "output", split = FALSE)
[17:44:45.196]         if (TRUE) {
[17:44:45.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.196]         }
[17:44:45.196]         else {
[17:44:45.196]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.196]         }
[17:44:45.196]         base::close(...future.stdout)
[17:44:45.196]         ...future.stdout <- NULL
[17:44:45.196]     }
[17:44:45.196]     ...future.result$conditions <- ...future.conditions
[17:44:45.196]     ...future.result$finished <- base::Sys.time()
[17:44:45.196]     ...future.result
[17:44:45.196] }
[17:44:45.198] assign_globals() ...
[17:44:45.198] List of 5
[17:44:45.198]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:44:45.198]  $ MoreArgs                 :List of 1
[17:44:45.198]   ..$ min: num 1
[17:44:45.198]  $ ...future.elements_ii    :List of 2
[17:44:45.198]   ..$ n  :List of 4
[17:44:45.198]   .. ..$ : int 1
[17:44:45.198]   .. ..$ : int 2
[17:44:45.198]   .. ..$ : int 3
[17:44:45.198]   .. ..$ : int 4
[17:44:45.198]   ..$ max:List of 4
[17:44:45.198]   .. ..$ : int 2
[17:44:45.198]   .. ..$ : int 3
[17:44:45.198]   .. ..$ : int 4
[17:44:45.198]   .. ..$ : int 5
[17:44:45.198]  $ ...future.seeds_ii       :List of 4
[17:44:45.198]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:44:45.198]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:44:45.198]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:44:45.198]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:44:45.198]  $ ...future.globals.maxSize: NULL
[17:44:45.198]  - attr(*, "where")=List of 5
[17:44:45.198]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.198]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.198]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.198]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.198]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.198]  - attr(*, "resolved")= logi FALSE
[17:44:45.198]  - attr(*, "total_size")= num 2912
[17:44:45.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.198]  - attr(*, "already-done")= logi TRUE
[17:44:45.206] - copied ‘...future.FUN’ to environment
[17:44:45.206] - copied ‘MoreArgs’ to environment
[17:44:45.206] - copied ‘...future.elements_ii’ to environment
[17:44:45.206] - copied ‘...future.seeds_ii’ to environment
[17:44:45.206] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.207] assign_globals() ... done
[17:44:45.207] plan(): Setting new future strategy stack:
[17:44:45.207] List of future strategies:
[17:44:45.207] 1. sequential:
[17:44:45.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.207]    - tweaked: FALSE
[17:44:45.207]    - call: NULL
[17:44:45.208] plan(): nbrOfWorkers() = 1
[17:44:45.209] plan(): Setting new future strategy stack:
[17:44:45.209] List of future strategies:
[17:44:45.209] 1. sequential:
[17:44:45.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.209]    - tweaked: FALSE
[17:44:45.209]    - call: plan(sequential)
[17:44:45.209] plan(): nbrOfWorkers() = 1
[17:44:45.210] SequentialFuture started (and completed)
[17:44:45.210] - Launch lazy future ... done
[17:44:45.210] run() for ‘SequentialFuture’ ... done
[17:44:45.210] Created future:
[17:44:45.210] SequentialFuture:
[17:44:45.210] Label: ‘future_mapply-1’
[17:44:45.210] Expression:
[17:44:45.210] {
[17:44:45.210]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.210]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.210]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.210]         on.exit(options(oopts), add = TRUE)
[17:44:45.210]     }
[17:44:45.210]     {
[17:44:45.210]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:45.210]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:45.210]                 inherits = FALSE)
[17:44:45.210]             ...future.FUN(...)
[17:44:45.210]         }
[17:44:45.210]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:45.210]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:45.210]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.210]         do.call(mapply, args = args)
[17:44:45.210]     }
[17:44:45.210] }
[17:44:45.210] Lazy evaluation: FALSE
[17:44:45.210] Asynchronous evaluation: FALSE
[17:44:45.210] Local evaluation: TRUE
[17:44:45.210] Environment: R_GlobalEnv
[17:44:45.210] Capture standard output: TRUE
[17:44:45.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.210] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.210] Packages: 1 packages (‘stats’)
[17:44:45.210] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:45.210] Resolved: TRUE
[17:44:45.210] Value: 280 bytes of class ‘list’
[17:44:45.210] Early signaling: FALSE
[17:44:45.210] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.210] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.212] Chunk #1 of 1 ... DONE
[17:44:45.212] Launching 1 futures (chunks) ... DONE
[17:44:45.212] Resolving 1 futures (chunks) ...
[17:44:45.212] resolve() on list ...
[17:44:45.212]  recursive: 0
[17:44:45.213]  length: 1
[17:44:45.213] 
[17:44:45.213] resolved() for ‘SequentialFuture’ ...
[17:44:45.213] - state: ‘finished’
[17:44:45.213] - run: TRUE
[17:44:45.213] - result: ‘FutureResult’
[17:44:45.213] resolved() for ‘SequentialFuture’ ... done
[17:44:45.213] Future #1
[17:44:45.214] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.214] - nx: 1
[17:44:45.214] - relay: TRUE
[17:44:45.214] - stdout: TRUE
[17:44:45.214] - signal: TRUE
[17:44:45.214] - resignal: FALSE
[17:44:45.214] - force: TRUE
[17:44:45.214] - relayed: [n=1] FALSE
[17:44:45.214] - queued futures: [n=1] FALSE
[17:44:45.215]  - until=1
[17:44:45.215]  - relaying element #1
[17:44:45.215] - relayed: [n=1] TRUE
[17:44:45.215] - queued futures: [n=1] TRUE
[17:44:45.215] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.215]  length: 0 (resolved future 1)
[17:44:45.215] Relaying remaining futures
[17:44:45.215] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.216] - nx: 1
[17:44:45.216] - relay: TRUE
[17:44:45.216] - stdout: TRUE
[17:44:45.216] - signal: TRUE
[17:44:45.216] - resignal: FALSE
[17:44:45.216] - force: TRUE
[17:44:45.216] - relayed: [n=1] TRUE
[17:44:45.216] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.216] - relayed: [n=1] TRUE
[17:44:45.216] - queued futures: [n=1] TRUE
[17:44:45.216] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.216] resolve() on list ... DONE
[17:44:45.217]  - Number of value chunks collected: 1
[17:44:45.217] Resolving 1 futures (chunks) ... DONE
[17:44:45.217] Reducing values from 1 chunks ...
[17:44:45.217]  - Number of values collected after concatenation: 4
[17:44:45.217]  - Number of values expected: 4
[17:44:45.217] Reducing values from 1 chunks ... DONE
[17:44:45.217] future_mapply() ... DONE
> print(y_rng_0)
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(mapply) ...")
+   y0 <- mapply(rep, 1:4, 4:1)
+   y1 <- future_mapply(rep, 1:4, 4:1)
+   stopifnot(identical(y1, y0))
+   y2 <- future_mapply("rep", 1:4, 4:1)
+   stopifnot(identical(y2, y0))
+   
+   y0 <- mapply(rep, times = 1:4, x = 4:1)
+   y1 <- future_mapply(rep, times = 1:4, x = 4:1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
+   stopifnot(identical(y1, y0))
+   
+   y0 <- mapply(function(x, y) seq_len(x) + y,
+                c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                       c(a =  1, b = 2, c = 3),  # names from first
+                       c(A = 10, B = 0, C = -10))
+   stopifnot(identical(y1, y0))
+ 
+   message("- future_.mapply()")
+   dots <- list(c(a =  1, b = 2, c = 3),  # names from first
+                c(A = 10, B = 0, C = -10))
+   y2 <- .mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   names(y0) <- NULL  ## .mapply() don't set names
+   stopifnot(all.equal(y2, y0))
+   y3 <- future_.mapply(function(x, y) seq_len(x) + y, dots = dots, MoreArgs = list())
+   stopifnot(all.equal(y3, y2))
+ 
+   word <- function(C, k) paste(rep.int(C, k), collapse = "")
+   for (chunk.size in list(1L, structure(2L, ordering = "random"), structure(3L, ordering = 5:1))) {
+     y0 <- mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE)
+     y1 <- future_mapply(word, LETTERS[1:5], 5:1, SIMPLIFY = FALSE, future.chunk.size = chunk.size)
+     stopifnot(identical(y1, y0))
+ 
+     dots <- list(LETTERS[1:5], 5:1)
+     MoreArgs <- list()
+     y2 <- .mapply(word, dots = dots, MoreArgs = list())
+     names(y0) <- NULL  ## .mapply() don't set names
+     stopifnot(all.equal(y2, y0))
+     y3 <- future_.mapply(word, dots = dots, MoreArgs = list())
+     stopifnot(all.equal(y3, y2))
+   }
+ 
+   message("- Subsetting (Issue #17) ...")
+   X <- as.Date("2018-06-01")
+   y0 <- mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   y1 <- future_mapply(FUN = identity, X, SIMPLIFY = FALSE)
+   stopifnot(identical(y1, y0))
+ 
+   dots <- list(X)
+   y2 <- .mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y2, y0))
+   y3 <- future_.mapply(FUN = identity, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y3, y2))
+ 
+   message("- Non-recycling of MoreArgs (Issue #51) ...")
+   y0 <- base::mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4)
+   )
+   y1 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = FALSE
+   )
+   stopifnot(identical(y1, y0))
+   y2 <- future.apply::future_mapply(
+     function(x, y) y,
+     x = 1:2, MoreArgs = list(y = 3:4),
+     future.seed = TRUE
+   )
+   stopifnot(identical(y2, y0))
+ 
+   dots <- list(x = 1:2)
+   MoreArgs <- list(y = 3:4)
+   y3 <- .mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   y4 <- future_.mapply(function(x, y) y, dots = dots, MoreArgs = MoreArgs)
+   stopifnot(identical(y4, y3))
+ 
+   message("- Recycle arguments to same length ...")
+   y0 <- mapply(rep, 1:4, 2:1)
+   y1 <- future_mapply(rep, 1:4, 2:1)
+   stopifnot(identical(y1, y0))
+ 
+   
+   message("- Parallel RNG ...")
+   y_rng_1 <- future_mapply(stats::runif, n = 1:4, max = 2:5,
+                            MoreArgs = list(min = 1), future.seed = 0xBEEF)
+   print(y_rng_1)
+   stopifnot(all.equal(y_rng_1, y_rng_0))
+ 
+   message("- future_Map() ...")
+   xs <- replicate(5, stats::runif(10), simplify = FALSE)
+   ws <- replicate(5, stats::rpois(10, 5) + 1, simplify = FALSE)
+   y0 <- Map(weighted.mean, xs, ws)
+   y1 <- future_Map(stats::weighted.mean, xs, ws)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_mapply() - 'max-or-0-if' recycling rule ...")
+   ## R (>= 4.2.0): mapply() & Map() follow usual "max-or-0-if" recycling rule
+   ## and keeps returning a named list in the "empty" case.
+   
+   truth <- list()
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(`+`, 1:3, NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(`+`, 1:3, NULL)
+   stopifnot(identical(y, truth))
+   
+   truth <- setNames(list(), character())
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character())
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), NULL)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), NULL)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters)
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, "A", character()) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, "A", character()) 
+   stopifnot(identical(y, truth))
+   
+   if (getRversion() >= "4.2.0") {
+     y0 <- mapply(paste, character(), letters) 
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, character(), letters) 
+   stopifnot(identical(y, truth))
+ 
+   ## Gives an error in R-devel (2021-11-26 r81252)
+   if (getRversion() >= "4.2.0" && FALSE) {
+     y0 <- mapply(paste, c(a = "A"), character())
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_mapply(paste, c(a = "A"), character())
+   stopifnot(identical(y, truth))
+ 
+   ## R (>= 4.2.0): Map() now recycles similar to basic Ops:
+   truth <- as.list(1 + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, 1, 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, 1, 1:3)
+   stopifnot(identical(y, truth))
+   
+   truth <- as.list(numeric() + 1:3)
+   if (getRversion() >= "4.2.0") {
+     y0 <- Map(`+`, numeric(), 1:3)
+     stopifnot(identical(y0, truth))
+   }
+   y <- future_Map(`+`, numeric(), 1:3)
+   stopifnot(identical(y, truth))
+ 
+   message("- future_mapply(x, ...) where x[[i]] subsets via S3 method ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   `[[.Foo` <- function(x, ...) 0
+   y0 <- mapply(x, FUN = identity)
+   stopifnot(identical(y0, c(a = 0, b = 0)))
+   y1 <- future_mapply(x, FUN = identity)
+   if (getOption("future.apply.chunkWith", "[[") == "[") {
+     stopifnot(identical(y1, unlist(x)))
+   } else {
+     stopifnot(identical(y1, y0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:44:45.375] plan(): Setting new future strategy stack:
[17:44:45.375] List of future strategies:
[17:44:45.375] 1. sequential:
[17:44:45.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.375]    - tweaked: FALSE
[17:44:45.375]    - call: plan(strategy)
[17:44:45.375] plan(): nbrOfWorkers() = 1
- From example(mapply) ...
[17:44:45.376] future_mapply() ...
[17:44:45.376] Number of chunks: 1
[17:44:45.376] getGlobalsAndPackagesXApply() ...
[17:44:45.376]  - future.globals: TRUE
[17:44:45.376] getGlobalsAndPackages() ...
[17:44:45.376] Searching for globals...
[17:44:45.377] - globals found: [1] ‘FUN’
[17:44:45.377] Searching for globals ... DONE
[17:44:45.377] Resolving globals: FALSE
[17:44:45.377] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:45.377] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:45.378] - globals: [1] ‘FUN’
[17:44:45.378] 
[17:44:45.378] getGlobalsAndPackages() ... DONE
[17:44:45.378]  - globals found/used: [n=1] ‘FUN’
[17:44:45.378]  - needed namespaces: [n=0] 
[17:44:45.378] Finding globals ... DONE
[17:44:45.378] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.378] List of 2
[17:44:45.378]  $ ...future.FUN:function (x, ...)  
[17:44:45.378]  $ MoreArgs     : NULL
[17:44:45.378]  - attr(*, "where")=List of 2
[17:44:45.378]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.378]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.378]  - attr(*, "resolved")= logi FALSE
[17:44:45.378]  - attr(*, "total_size")= num NA
[17:44:45.381] Packages to be attached in all futures: [n=0] 
[17:44:45.381] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.381] Number of futures (= number of chunks): 1
[17:44:45.382] Launching 1 futures (chunks) ...
[17:44:45.382] Chunk #1 of 1 ...
[17:44:45.382]  - Finding globals in '...' for chunk #1 ...
[17:44:45.382] getGlobalsAndPackages() ...
[17:44:45.382] Searching for globals...
[17:44:45.383] 
[17:44:45.383] Searching for globals ... DONE
[17:44:45.383] - globals: [0] <none>
[17:44:45.383] getGlobalsAndPackages() ... DONE
[17:44:45.383]    + additional globals found: [n=0] 
[17:44:45.383]    + additional namespaces needed: [n=0] 
[17:44:45.383]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.384]  - seeds: <none>
[17:44:45.384]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.384] getGlobalsAndPackages() ...
[17:44:45.384] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.384] Resolving globals: FALSE
[17:44:45.384] The total size of the 5 globals is 504 bytes (504 bytes)
[17:44:45.385] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.385] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.385] 
[17:44:45.385] getGlobalsAndPackages() ... DONE
[17:44:45.385] run() for ‘Future’ ...
[17:44:45.386] - state: ‘created’
[17:44:45.386] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.386] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.386]   - Field: ‘label’
[17:44:45.386]   - Field: ‘local’
[17:44:45.386]   - Field: ‘owner’
[17:44:45.386]   - Field: ‘envir’
[17:44:45.387]   - Field: ‘packages’
[17:44:45.387]   - Field: ‘gc’
[17:44:45.387]   - Field: ‘conditions’
[17:44:45.387]   - Field: ‘expr’
[17:44:45.387]   - Field: ‘uuid’
[17:44:45.387]   - Field: ‘seed’
[17:44:45.387]   - Field: ‘version’
[17:44:45.387]   - Field: ‘result’
[17:44:45.387]   - Field: ‘asynchronous’
[17:44:45.387]   - Field: ‘calls’
[17:44:45.387]   - Field: ‘globals’
[17:44:45.388]   - Field: ‘stdout’
[17:44:45.388]   - Field: ‘earlySignal’
[17:44:45.388]   - Field: ‘lazy’
[17:44:45.388]   - Field: ‘state’
[17:44:45.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.388] - Launch lazy future ...
[17:44:45.388] Packages needed by the future expression (n = 0): <none>
[17:44:45.388] Packages needed by future strategies (n = 0): <none>
[17:44:45.390] {
[17:44:45.390]     {
[17:44:45.390]         {
[17:44:45.390]             ...future.startTime <- base::Sys.time()
[17:44:45.390]             {
[17:44:45.390]                 {
[17:44:45.390]                   {
[17:44:45.390]                     base::local({
[17:44:45.390]                       has_future <- base::requireNamespace("future", 
[17:44:45.390]                         quietly = TRUE)
[17:44:45.390]                       if (has_future) {
[17:44:45.390]                         ns <- base::getNamespace("future")
[17:44:45.390]                         version <- ns[[".package"]][["version"]]
[17:44:45.390]                         if (is.null(version)) 
[17:44:45.390]                           version <- utils::packageVersion("future")
[17:44:45.390]                       }
[17:44:45.390]                       else {
[17:44:45.390]                         version <- NULL
[17:44:45.390]                       }
[17:44:45.390]                       if (!has_future || version < "1.8.0") {
[17:44:45.390]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.390]                           "", base::R.version$version.string), 
[17:44:45.390]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.390]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.390]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.390]                             "release", "version")], collapse = " "), 
[17:44:45.390]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.390]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.390]                           info)
[17:44:45.390]                         info <- base::paste(info, collapse = "; ")
[17:44:45.390]                         if (!has_future) {
[17:44:45.390]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.390]                             info)
[17:44:45.390]                         }
[17:44:45.390]                         else {
[17:44:45.390]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.390]                             info, version)
[17:44:45.390]                         }
[17:44:45.390]                         base::stop(msg)
[17:44:45.390]                       }
[17:44:45.390]                     })
[17:44:45.390]                   }
[17:44:45.390]                   ...future.strategy.old <- future::plan("list")
[17:44:45.390]                   options(future.plan = NULL)
[17:44:45.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.390]                 }
[17:44:45.390]                 ...future.workdir <- getwd()
[17:44:45.390]             }
[17:44:45.390]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.390]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.390]         }
[17:44:45.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.390]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.390]             base::names(...future.oldOptions))
[17:44:45.390]     }
[17:44:45.390]     if (FALSE) {
[17:44:45.390]     }
[17:44:45.390]     else {
[17:44:45.390]         if (TRUE) {
[17:44:45.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.390]                 open = "w")
[17:44:45.390]         }
[17:44:45.390]         else {
[17:44:45.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.390]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.390]         }
[17:44:45.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.390]             base::sink(type = "output", split = FALSE)
[17:44:45.390]             base::close(...future.stdout)
[17:44:45.390]         }, add = TRUE)
[17:44:45.390]     }
[17:44:45.390]     ...future.frame <- base::sys.nframe()
[17:44:45.390]     ...future.conditions <- base::list()
[17:44:45.390]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.390]     if (FALSE) {
[17:44:45.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.390]     }
[17:44:45.390]     ...future.result <- base::tryCatch({
[17:44:45.390]         base::withCallingHandlers({
[17:44:45.390]             ...future.value <- base::withVisible(base::local({
[17:44:45.390]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.390]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.390]                   ...future.globals.maxSize)) {
[17:44:45.390]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.390]                   on.exit(options(oopts), add = TRUE)
[17:44:45.390]                 }
[17:44:45.390]                 {
[17:44:45.390]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.390]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.390]                     USE.NAMES = FALSE)
[17:44:45.390]                   do.call(mapply, args = args)
[17:44:45.390]                 }
[17:44:45.390]             }))
[17:44:45.390]             future::FutureResult(value = ...future.value$value, 
[17:44:45.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.390]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.390]                     ...future.globalenv.names))
[17:44:45.390]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.390]         }, condition = base::local({
[17:44:45.390]             c <- base::c
[17:44:45.390]             inherits <- base::inherits
[17:44:45.390]             invokeRestart <- base::invokeRestart
[17:44:45.390]             length <- base::length
[17:44:45.390]             list <- base::list
[17:44:45.390]             seq.int <- base::seq.int
[17:44:45.390]             signalCondition <- base::signalCondition
[17:44:45.390]             sys.calls <- base::sys.calls
[17:44:45.390]             `[[` <- base::`[[`
[17:44:45.390]             `+` <- base::`+`
[17:44:45.390]             `<<-` <- base::`<<-`
[17:44:45.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.390]                   3L)]
[17:44:45.390]             }
[17:44:45.390]             function(cond) {
[17:44:45.390]                 is_error <- inherits(cond, "error")
[17:44:45.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.390]                   NULL)
[17:44:45.390]                 if (is_error) {
[17:44:45.390]                   sessionInformation <- function() {
[17:44:45.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.390]                       search = base::search(), system = base::Sys.info())
[17:44:45.390]                   }
[17:44:45.390]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.390]                     cond$call), session = sessionInformation(), 
[17:44:45.390]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.390]                   signalCondition(cond)
[17:44:45.390]                 }
[17:44:45.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.390]                 "immediateCondition"))) {
[17:44:45.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.390]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.390]                   if (TRUE && !signal) {
[17:44:45.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.390]                     {
[17:44:45.390]                       inherits <- base::inherits
[17:44:45.390]                       invokeRestart <- base::invokeRestart
[17:44:45.390]                       is.null <- base::is.null
[17:44:45.390]                       muffled <- FALSE
[17:44:45.390]                       if (inherits(cond, "message")) {
[17:44:45.390]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.390]                         if (muffled) 
[17:44:45.390]                           invokeRestart("muffleMessage")
[17:44:45.390]                       }
[17:44:45.390]                       else if (inherits(cond, "warning")) {
[17:44:45.390]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.390]                         if (muffled) 
[17:44:45.390]                           invokeRestart("muffleWarning")
[17:44:45.390]                       }
[17:44:45.390]                       else if (inherits(cond, "condition")) {
[17:44:45.390]                         if (!is.null(pattern)) {
[17:44:45.390]                           computeRestarts <- base::computeRestarts
[17:44:45.390]                           grepl <- base::grepl
[17:44:45.390]                           restarts <- computeRestarts(cond)
[17:44:45.390]                           for (restart in restarts) {
[17:44:45.390]                             name <- restart$name
[17:44:45.390]                             if (is.null(name)) 
[17:44:45.390]                               next
[17:44:45.390]                             if (!grepl(pattern, name)) 
[17:44:45.390]                               next
[17:44:45.390]                             invokeRestart(restart)
[17:44:45.390]                             muffled <- TRUE
[17:44:45.390]                             break
[17:44:45.390]                           }
[17:44:45.390]                         }
[17:44:45.390]                       }
[17:44:45.390]                       invisible(muffled)
[17:44:45.390]                     }
[17:44:45.390]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.390]                   }
[17:44:45.390]                 }
[17:44:45.390]                 else {
[17:44:45.390]                   if (TRUE) {
[17:44:45.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.390]                     {
[17:44:45.390]                       inherits <- base::inherits
[17:44:45.390]                       invokeRestart <- base::invokeRestart
[17:44:45.390]                       is.null <- base::is.null
[17:44:45.390]                       muffled <- FALSE
[17:44:45.390]                       if (inherits(cond, "message")) {
[17:44:45.390]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.390]                         if (muffled) 
[17:44:45.390]                           invokeRestart("muffleMessage")
[17:44:45.390]                       }
[17:44:45.390]                       else if (inherits(cond, "warning")) {
[17:44:45.390]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.390]                         if (muffled) 
[17:44:45.390]                           invokeRestart("muffleWarning")
[17:44:45.390]                       }
[17:44:45.390]                       else if (inherits(cond, "condition")) {
[17:44:45.390]                         if (!is.null(pattern)) {
[17:44:45.390]                           computeRestarts <- base::computeRestarts
[17:44:45.390]                           grepl <- base::grepl
[17:44:45.390]                           restarts <- computeRestarts(cond)
[17:44:45.390]                           for (restart in restarts) {
[17:44:45.390]                             name <- restart$name
[17:44:45.390]                             if (is.null(name)) 
[17:44:45.390]                               next
[17:44:45.390]                             if (!grepl(pattern, name)) 
[17:44:45.390]                               next
[17:44:45.390]                             invokeRestart(restart)
[17:44:45.390]                             muffled <- TRUE
[17:44:45.390]                             break
[17:44:45.390]                           }
[17:44:45.390]                         }
[17:44:45.390]                       }
[17:44:45.390]                       invisible(muffled)
[17:44:45.390]                     }
[17:44:45.390]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.390]                   }
[17:44:45.390]                 }
[17:44:45.390]             }
[17:44:45.390]         }))
[17:44:45.390]     }, error = function(ex) {
[17:44:45.390]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.390]                 ...future.rng), started = ...future.startTime, 
[17:44:45.390]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.390]             version = "1.8"), class = "FutureResult")
[17:44:45.390]     }, finally = {
[17:44:45.390]         if (!identical(...future.workdir, getwd())) 
[17:44:45.390]             setwd(...future.workdir)
[17:44:45.390]         {
[17:44:45.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.390]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.390]             }
[17:44:45.390]             base::options(...future.oldOptions)
[17:44:45.390]             if (.Platform$OS.type == "windows") {
[17:44:45.390]                 old_names <- names(...future.oldEnvVars)
[17:44:45.390]                 envs <- base::Sys.getenv()
[17:44:45.390]                 names <- names(envs)
[17:44:45.390]                 common <- intersect(names, old_names)
[17:44:45.390]                 added <- setdiff(names, old_names)
[17:44:45.390]                 removed <- setdiff(old_names, names)
[17:44:45.390]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.390]                   envs[common]]
[17:44:45.390]                 NAMES <- toupper(changed)
[17:44:45.390]                 args <- list()
[17:44:45.390]                 for (kk in seq_along(NAMES)) {
[17:44:45.390]                   name <- changed[[kk]]
[17:44:45.390]                   NAME <- NAMES[[kk]]
[17:44:45.390]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.390]                     next
[17:44:45.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.390]                 }
[17:44:45.390]                 NAMES <- toupper(added)
[17:44:45.390]                 for (kk in seq_along(NAMES)) {
[17:44:45.390]                   name <- added[[kk]]
[17:44:45.390]                   NAME <- NAMES[[kk]]
[17:44:45.390]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.390]                     next
[17:44:45.390]                   args[[name]] <- ""
[17:44:45.390]                 }
[17:44:45.390]                 NAMES <- toupper(removed)
[17:44:45.390]                 for (kk in seq_along(NAMES)) {
[17:44:45.390]                   name <- removed[[kk]]
[17:44:45.390]                   NAME <- NAMES[[kk]]
[17:44:45.390]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.390]                     next
[17:44:45.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.390]                 }
[17:44:45.390]                 if (length(args) > 0) 
[17:44:45.390]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.390]             }
[17:44:45.390]             else {
[17:44:45.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.390]             }
[17:44:45.390]             {
[17:44:45.390]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.390]                   0L) {
[17:44:45.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.390]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.390]                   base::options(opts)
[17:44:45.390]                 }
[17:44:45.390]                 {
[17:44:45.390]                   {
[17:44:45.390]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.390]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.390]                     -484569582L), envir = base::globalenv(), 
[17:44:45.390]                       inherits = FALSE)
[17:44:45.390]                     NULL
[17:44:45.390]                   }
[17:44:45.390]                   options(future.plan = NULL)
[17:44:45.390]                   if (is.na(NA_character_)) 
[17:44:45.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.390]                     .init = FALSE)
[17:44:45.390]                 }
[17:44:45.390]             }
[17:44:45.390]         }
[17:44:45.390]     })
[17:44:45.390]     if (TRUE) {
[17:44:45.390]         base::sink(type = "output", split = FALSE)
[17:44:45.390]         if (TRUE) {
[17:44:45.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.390]         }
[17:44:45.390]         else {
[17:44:45.390]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.390]         }
[17:44:45.390]         base::close(...future.stdout)
[17:44:45.390]         ...future.stdout <- NULL
[17:44:45.390]     }
[17:44:45.390]     ...future.result$conditions <- ...future.conditions
[17:44:45.390]     ...future.result$finished <- base::Sys.time()
[17:44:45.390]     ...future.result
[17:44:45.390] }
[17:44:45.392] assign_globals() ...
[17:44:45.392] List of 5
[17:44:45.392]  $ ...future.FUN            :function (x, ...)  
[17:44:45.392]  $ MoreArgs                 : NULL
[17:44:45.392]  $ ...future.elements_ii    :List of 2
[17:44:45.392]   ..$ :List of 4
[17:44:45.392]   .. ..$ : int 1
[17:44:45.392]   .. ..$ : int 2
[17:44:45.392]   .. ..$ : int 3
[17:44:45.392]   .. ..$ : int 4
[17:44:45.392]   ..$ :List of 4
[17:44:45.392]   .. ..$ : int 4
[17:44:45.392]   .. ..$ : int 3
[17:44:45.392]   .. ..$ : int 2
[17:44:45.392]   .. ..$ : int 1
[17:44:45.392]  $ ...future.seeds_ii       : NULL
[17:44:45.392]  $ ...future.globals.maxSize: NULL
[17:44:45.392]  - attr(*, "where")=List of 5
[17:44:45.392]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.392]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.392]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.392]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.392]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.392]  - attr(*, "resolved")= logi FALSE
[17:44:45.392]  - attr(*, "total_size")= num 504
[17:44:45.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.392]  - attr(*, "already-done")= logi TRUE
[17:44:45.399] - copied ‘...future.FUN’ to environment
[17:44:45.399] - copied ‘MoreArgs’ to environment
[17:44:45.399] - copied ‘...future.elements_ii’ to environment
[17:44:45.399] - copied ‘...future.seeds_ii’ to environment
[17:44:45.399] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.399] assign_globals() ... done
[17:44:45.399] plan(): Setting new future strategy stack:
[17:44:45.399] List of future strategies:
[17:44:45.399] 1. sequential:
[17:44:45.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.399]    - tweaked: FALSE
[17:44:45.399]    - call: NULL
[17:44:45.400] plan(): nbrOfWorkers() = 1
[17:44:45.401] plan(): Setting new future strategy stack:
[17:44:45.401] List of future strategies:
[17:44:45.401] 1. sequential:
[17:44:45.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.401]    - tweaked: FALSE
[17:44:45.401]    - call: plan(strategy)
[17:44:45.401] plan(): nbrOfWorkers() = 1
[17:44:45.401] SequentialFuture started (and completed)
[17:44:45.401] - Launch lazy future ... done
[17:44:45.401] run() for ‘SequentialFuture’ ... done
[17:44:45.402] Created future:
[17:44:45.402] SequentialFuture:
[17:44:45.402] Label: ‘future_mapply-1’
[17:44:45.402] Expression:
[17:44:45.402] {
[17:44:45.402]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.402]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.402]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.402]         on.exit(options(oopts), add = TRUE)
[17:44:45.402]     }
[17:44:45.402]     {
[17:44:45.402]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.402]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.402]         do.call(mapply, args = args)
[17:44:45.402]     }
[17:44:45.402] }
[17:44:45.402] Lazy evaluation: FALSE
[17:44:45.402] Asynchronous evaluation: FALSE
[17:44:45.402] Local evaluation: TRUE
[17:44:45.402] Environment: R_GlobalEnv
[17:44:45.402] Capture standard output: TRUE
[17:44:45.402] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.402] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.402] Packages: <none>
[17:44:45.402] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.402] Resolved: TRUE
[17:44:45.402] Value: 240 bytes of class ‘list’
[17:44:45.402] Early signaling: FALSE
[17:44:45.402] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.402] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.403] Chunk #1 of 1 ... DONE
[17:44:45.403] Launching 1 futures (chunks) ... DONE
[17:44:45.403] Resolving 1 futures (chunks) ...
[17:44:45.403] resolve() on list ...
[17:44:45.403]  recursive: 0
[17:44:45.403]  length: 1
[17:44:45.403] 
[17:44:45.403] resolved() for ‘SequentialFuture’ ...
[17:44:45.403] - state: ‘finished’
[17:44:45.403] - run: TRUE
[17:44:45.403] - result: ‘FutureResult’
[17:44:45.404] resolved() for ‘SequentialFuture’ ... done
[17:44:45.404] Future #1
[17:44:45.404] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.404] - nx: 1
[17:44:45.404] - relay: TRUE
[17:44:45.404] - stdout: TRUE
[17:44:45.404] - signal: TRUE
[17:44:45.404] - resignal: FALSE
[17:44:45.404] - force: TRUE
[17:44:45.404] - relayed: [n=1] FALSE
[17:44:45.404] - queued futures: [n=1] FALSE
[17:44:45.405]  - until=1
[17:44:45.405]  - relaying element #1
[17:44:45.405] - relayed: [n=1] TRUE
[17:44:45.405] - queued futures: [n=1] TRUE
[17:44:45.405] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.405]  length: 0 (resolved future 1)
[17:44:45.405] Relaying remaining futures
[17:44:45.405] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.405] - nx: 1
[17:44:45.405] - relay: TRUE
[17:44:45.406] - stdout: TRUE
[17:44:45.406] - signal: TRUE
[17:44:45.406] - resignal: FALSE
[17:44:45.406] - force: TRUE
[17:44:45.406] - relayed: [n=1] TRUE
[17:44:45.406] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.406] - relayed: [n=1] TRUE
[17:44:45.406] - queued futures: [n=1] TRUE
[17:44:45.406] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.406] resolve() on list ... DONE
[17:44:45.406]  - Number of value chunks collected: 1
[17:44:45.407] Resolving 1 futures (chunks) ... DONE
[17:44:45.407] Reducing values from 1 chunks ...
[17:44:45.407]  - Number of values collected after concatenation: 4
[17:44:45.407]  - Number of values expected: 4
[17:44:45.407] Reducing values from 1 chunks ... DONE
[17:44:45.407] future_mapply() ... DONE
[17:44:45.407] future_mapply() ...
[17:44:45.407] Number of chunks: 1
[17:44:45.407] getGlobalsAndPackagesXApply() ...
[17:44:45.407]  - future.globals: TRUE
[17:44:45.408] getGlobalsAndPackages() ...
[17:44:45.408] Searching for globals...
[17:44:45.408] - globals found: [1] ‘FUN’
[17:44:45.408] Searching for globals ... DONE
[17:44:45.408] Resolving globals: FALSE
[17:44:45.409] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:45.409] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:45.409] - globals: [1] ‘FUN’
[17:44:45.409] 
[17:44:45.409] getGlobalsAndPackages() ... DONE
[17:44:45.409]  - globals found/used: [n=1] ‘FUN’
[17:44:45.410]  - needed namespaces: [n=0] 
[17:44:45.410] Finding globals ... DONE
[17:44:45.410] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.410] List of 2
[17:44:45.410]  $ ...future.FUN:function (x, ...)  
[17:44:45.410]  $ MoreArgs     : NULL
[17:44:45.410]  - attr(*, "where")=List of 2
[17:44:45.410]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.410]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.410]  - attr(*, "resolved")= logi FALSE
[17:44:45.410]  - attr(*, "total_size")= num NA
[17:44:45.412] Packages to be attached in all futures: [n=0] 
[17:44:45.412] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.413] Number of futures (= number of chunks): 1
[17:44:45.413] Launching 1 futures (chunks) ...
[17:44:45.413] Chunk #1 of 1 ...
[17:44:45.413]  - Finding globals in '...' for chunk #1 ...
[17:44:45.413] getGlobalsAndPackages() ...
[17:44:45.413] Searching for globals...
[17:44:45.413] 
[17:44:45.414] Searching for globals ... DONE
[17:44:45.414] - globals: [0] <none>
[17:44:45.414] getGlobalsAndPackages() ... DONE
[17:44:45.414]    + additional globals found: [n=0] 
[17:44:45.414]    + additional namespaces needed: [n=0] 
[17:44:45.414]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.414]  - seeds: <none>
[17:44:45.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.414] getGlobalsAndPackages() ...
[17:44:45.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.414] Resolving globals: FALSE
[17:44:45.417] The total size of the 5 globals is 504 bytes (504 bytes)
[17:44:45.417] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.417] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.417] 
[17:44:45.417] getGlobalsAndPackages() ... DONE
[17:44:45.418] run() for ‘Future’ ...
[17:44:45.418] - state: ‘created’
[17:44:45.418] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.418] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.418]   - Field: ‘label’
[17:44:45.419]   - Field: ‘local’
[17:44:45.419]   - Field: ‘owner’
[17:44:45.419]   - Field: ‘envir’
[17:44:45.419]   - Field: ‘packages’
[17:44:45.419]   - Field: ‘gc’
[17:44:45.419]   - Field: ‘conditions’
[17:44:45.419]   - Field: ‘expr’
[17:44:45.419]   - Field: ‘uuid’
[17:44:45.419]   - Field: ‘seed’
[17:44:45.419]   - Field: ‘version’
[17:44:45.419]   - Field: ‘result’
[17:44:45.420]   - Field: ‘asynchronous’
[17:44:45.420]   - Field: ‘calls’
[17:44:45.420]   - Field: ‘globals’
[17:44:45.420]   - Field: ‘stdout’
[17:44:45.420]   - Field: ‘earlySignal’
[17:44:45.420]   - Field: ‘lazy’
[17:44:45.420]   - Field: ‘state’
[17:44:45.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.420] - Launch lazy future ...
[17:44:45.420] Packages needed by the future expression (n = 0): <none>
[17:44:45.421] Packages needed by future strategies (n = 0): <none>
[17:44:45.421] {
[17:44:45.421]     {
[17:44:45.421]         {
[17:44:45.421]             ...future.startTime <- base::Sys.time()
[17:44:45.421]             {
[17:44:45.421]                 {
[17:44:45.421]                   {
[17:44:45.421]                     base::local({
[17:44:45.421]                       has_future <- base::requireNamespace("future", 
[17:44:45.421]                         quietly = TRUE)
[17:44:45.421]                       if (has_future) {
[17:44:45.421]                         ns <- base::getNamespace("future")
[17:44:45.421]                         version <- ns[[".package"]][["version"]]
[17:44:45.421]                         if (is.null(version)) 
[17:44:45.421]                           version <- utils::packageVersion("future")
[17:44:45.421]                       }
[17:44:45.421]                       else {
[17:44:45.421]                         version <- NULL
[17:44:45.421]                       }
[17:44:45.421]                       if (!has_future || version < "1.8.0") {
[17:44:45.421]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.421]                           "", base::R.version$version.string), 
[17:44:45.421]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.421]                             "release", "version")], collapse = " "), 
[17:44:45.421]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.421]                           info)
[17:44:45.421]                         info <- base::paste(info, collapse = "; ")
[17:44:45.421]                         if (!has_future) {
[17:44:45.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.421]                             info)
[17:44:45.421]                         }
[17:44:45.421]                         else {
[17:44:45.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.421]                             info, version)
[17:44:45.421]                         }
[17:44:45.421]                         base::stop(msg)
[17:44:45.421]                       }
[17:44:45.421]                     })
[17:44:45.421]                   }
[17:44:45.421]                   ...future.strategy.old <- future::plan("list")
[17:44:45.421]                   options(future.plan = NULL)
[17:44:45.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.421]                 }
[17:44:45.421]                 ...future.workdir <- getwd()
[17:44:45.421]             }
[17:44:45.421]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.421]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.421]         }
[17:44:45.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.421]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.421]             base::names(...future.oldOptions))
[17:44:45.421]     }
[17:44:45.421]     if (FALSE) {
[17:44:45.421]     }
[17:44:45.421]     else {
[17:44:45.421]         if (TRUE) {
[17:44:45.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.421]                 open = "w")
[17:44:45.421]         }
[17:44:45.421]         else {
[17:44:45.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.421]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.421]         }
[17:44:45.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.421]             base::sink(type = "output", split = FALSE)
[17:44:45.421]             base::close(...future.stdout)
[17:44:45.421]         }, add = TRUE)
[17:44:45.421]     }
[17:44:45.421]     ...future.frame <- base::sys.nframe()
[17:44:45.421]     ...future.conditions <- base::list()
[17:44:45.421]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.421]     if (FALSE) {
[17:44:45.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.421]     }
[17:44:45.421]     ...future.result <- base::tryCatch({
[17:44:45.421]         base::withCallingHandlers({
[17:44:45.421]             ...future.value <- base::withVisible(base::local({
[17:44:45.421]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.421]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.421]                   ...future.globals.maxSize)) {
[17:44:45.421]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.421]                   on.exit(options(oopts), add = TRUE)
[17:44:45.421]                 }
[17:44:45.421]                 {
[17:44:45.421]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.421]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.421]                     USE.NAMES = FALSE)
[17:44:45.421]                   do.call(mapply, args = args)
[17:44:45.421]                 }
[17:44:45.421]             }))
[17:44:45.421]             future::FutureResult(value = ...future.value$value, 
[17:44:45.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.421]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.421]                     ...future.globalenv.names))
[17:44:45.421]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.421]         }, condition = base::local({
[17:44:45.421]             c <- base::c
[17:44:45.421]             inherits <- base::inherits
[17:44:45.421]             invokeRestart <- base::invokeRestart
[17:44:45.421]             length <- base::length
[17:44:45.421]             list <- base::list
[17:44:45.421]             seq.int <- base::seq.int
[17:44:45.421]             signalCondition <- base::signalCondition
[17:44:45.421]             sys.calls <- base::sys.calls
[17:44:45.421]             `[[` <- base::`[[`
[17:44:45.421]             `+` <- base::`+`
[17:44:45.421]             `<<-` <- base::`<<-`
[17:44:45.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.421]                   3L)]
[17:44:45.421]             }
[17:44:45.421]             function(cond) {
[17:44:45.421]                 is_error <- inherits(cond, "error")
[17:44:45.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.421]                   NULL)
[17:44:45.421]                 if (is_error) {
[17:44:45.421]                   sessionInformation <- function() {
[17:44:45.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.421]                       search = base::search(), system = base::Sys.info())
[17:44:45.421]                   }
[17:44:45.421]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.421]                     cond$call), session = sessionInformation(), 
[17:44:45.421]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.421]                   signalCondition(cond)
[17:44:45.421]                 }
[17:44:45.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.421]                 "immediateCondition"))) {
[17:44:45.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.421]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.421]                   if (TRUE && !signal) {
[17:44:45.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.421]                     {
[17:44:45.421]                       inherits <- base::inherits
[17:44:45.421]                       invokeRestart <- base::invokeRestart
[17:44:45.421]                       is.null <- base::is.null
[17:44:45.421]                       muffled <- FALSE
[17:44:45.421]                       if (inherits(cond, "message")) {
[17:44:45.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.421]                         if (muffled) 
[17:44:45.421]                           invokeRestart("muffleMessage")
[17:44:45.421]                       }
[17:44:45.421]                       else if (inherits(cond, "warning")) {
[17:44:45.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.421]                         if (muffled) 
[17:44:45.421]                           invokeRestart("muffleWarning")
[17:44:45.421]                       }
[17:44:45.421]                       else if (inherits(cond, "condition")) {
[17:44:45.421]                         if (!is.null(pattern)) {
[17:44:45.421]                           computeRestarts <- base::computeRestarts
[17:44:45.421]                           grepl <- base::grepl
[17:44:45.421]                           restarts <- computeRestarts(cond)
[17:44:45.421]                           for (restart in restarts) {
[17:44:45.421]                             name <- restart$name
[17:44:45.421]                             if (is.null(name)) 
[17:44:45.421]                               next
[17:44:45.421]                             if (!grepl(pattern, name)) 
[17:44:45.421]                               next
[17:44:45.421]                             invokeRestart(restart)
[17:44:45.421]                             muffled <- TRUE
[17:44:45.421]                             break
[17:44:45.421]                           }
[17:44:45.421]                         }
[17:44:45.421]                       }
[17:44:45.421]                       invisible(muffled)
[17:44:45.421]                     }
[17:44:45.421]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.421]                   }
[17:44:45.421]                 }
[17:44:45.421]                 else {
[17:44:45.421]                   if (TRUE) {
[17:44:45.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.421]                     {
[17:44:45.421]                       inherits <- base::inherits
[17:44:45.421]                       invokeRestart <- base::invokeRestart
[17:44:45.421]                       is.null <- base::is.null
[17:44:45.421]                       muffled <- FALSE
[17:44:45.421]                       if (inherits(cond, "message")) {
[17:44:45.421]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.421]                         if (muffled) 
[17:44:45.421]                           invokeRestart("muffleMessage")
[17:44:45.421]                       }
[17:44:45.421]                       else if (inherits(cond, "warning")) {
[17:44:45.421]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.421]                         if (muffled) 
[17:44:45.421]                           invokeRestart("muffleWarning")
[17:44:45.421]                       }
[17:44:45.421]                       else if (inherits(cond, "condition")) {
[17:44:45.421]                         if (!is.null(pattern)) {
[17:44:45.421]                           computeRestarts <- base::computeRestarts
[17:44:45.421]                           grepl <- base::grepl
[17:44:45.421]                           restarts <- computeRestarts(cond)
[17:44:45.421]                           for (restart in restarts) {
[17:44:45.421]                             name <- restart$name
[17:44:45.421]                             if (is.null(name)) 
[17:44:45.421]                               next
[17:44:45.421]                             if (!grepl(pattern, name)) 
[17:44:45.421]                               next
[17:44:45.421]                             invokeRestart(restart)
[17:44:45.421]                             muffled <- TRUE
[17:44:45.421]                             break
[17:44:45.421]                           }
[17:44:45.421]                         }
[17:44:45.421]                       }
[17:44:45.421]                       invisible(muffled)
[17:44:45.421]                     }
[17:44:45.421]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.421]                   }
[17:44:45.421]                 }
[17:44:45.421]             }
[17:44:45.421]         }))
[17:44:45.421]     }, error = function(ex) {
[17:44:45.421]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.421]                 ...future.rng), started = ...future.startTime, 
[17:44:45.421]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.421]             version = "1.8"), class = "FutureResult")
[17:44:45.421]     }, finally = {
[17:44:45.421]         if (!identical(...future.workdir, getwd())) 
[17:44:45.421]             setwd(...future.workdir)
[17:44:45.421]         {
[17:44:45.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.421]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.421]             }
[17:44:45.421]             base::options(...future.oldOptions)
[17:44:45.421]             if (.Platform$OS.type == "windows") {
[17:44:45.421]                 old_names <- names(...future.oldEnvVars)
[17:44:45.421]                 envs <- base::Sys.getenv()
[17:44:45.421]                 names <- names(envs)
[17:44:45.421]                 common <- intersect(names, old_names)
[17:44:45.421]                 added <- setdiff(names, old_names)
[17:44:45.421]                 removed <- setdiff(old_names, names)
[17:44:45.421]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.421]                   envs[common]]
[17:44:45.421]                 NAMES <- toupper(changed)
[17:44:45.421]                 args <- list()
[17:44:45.421]                 for (kk in seq_along(NAMES)) {
[17:44:45.421]                   name <- changed[[kk]]
[17:44:45.421]                   NAME <- NAMES[[kk]]
[17:44:45.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.421]                     next
[17:44:45.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.421]                 }
[17:44:45.421]                 NAMES <- toupper(added)
[17:44:45.421]                 for (kk in seq_along(NAMES)) {
[17:44:45.421]                   name <- added[[kk]]
[17:44:45.421]                   NAME <- NAMES[[kk]]
[17:44:45.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.421]                     next
[17:44:45.421]                   args[[name]] <- ""
[17:44:45.421]                 }
[17:44:45.421]                 NAMES <- toupper(removed)
[17:44:45.421]                 for (kk in seq_along(NAMES)) {
[17:44:45.421]                   name <- removed[[kk]]
[17:44:45.421]                   NAME <- NAMES[[kk]]
[17:44:45.421]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.421]                     next
[17:44:45.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.421]                 }
[17:44:45.421]                 if (length(args) > 0) 
[17:44:45.421]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.421]             }
[17:44:45.421]             else {
[17:44:45.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.421]             }
[17:44:45.421]             {
[17:44:45.421]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.421]                   0L) {
[17:44:45.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.421]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.421]                   base::options(opts)
[17:44:45.421]                 }
[17:44:45.421]                 {
[17:44:45.421]                   {
[17:44:45.421]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.421]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.421]                     -484569582L), envir = base::globalenv(), 
[17:44:45.421]                       inherits = FALSE)
[17:44:45.421]                     NULL
[17:44:45.421]                   }
[17:44:45.421]                   options(future.plan = NULL)
[17:44:45.421]                   if (is.na(NA_character_)) 
[17:44:45.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.421]                     .init = FALSE)
[17:44:45.421]                 }
[17:44:45.421]             }
[17:44:45.421]         }
[17:44:45.421]     })
[17:44:45.421]     if (TRUE) {
[17:44:45.421]         base::sink(type = "output", split = FALSE)
[17:44:45.421]         if (TRUE) {
[17:44:45.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.421]         }
[17:44:45.421]         else {
[17:44:45.421]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.421]         }
[17:44:45.421]         base::close(...future.stdout)
[17:44:45.421]         ...future.stdout <- NULL
[17:44:45.421]     }
[17:44:45.421]     ...future.result$conditions <- ...future.conditions
[17:44:45.421]     ...future.result$finished <- base::Sys.time()
[17:44:45.421]     ...future.result
[17:44:45.421] }
[17:44:45.423] assign_globals() ...
[17:44:45.423] List of 5
[17:44:45.423]  $ ...future.FUN            :function (x, ...)  
[17:44:45.423]  $ MoreArgs                 : NULL
[17:44:45.423]  $ ...future.elements_ii    :List of 2
[17:44:45.423]   ..$ :List of 4
[17:44:45.423]   .. ..$ : int 1
[17:44:45.423]   .. ..$ : int 2
[17:44:45.423]   .. ..$ : int 3
[17:44:45.423]   .. ..$ : int 4
[17:44:45.423]   ..$ :List of 4
[17:44:45.423]   .. ..$ : int 4
[17:44:45.423]   .. ..$ : int 3
[17:44:45.423]   .. ..$ : int 2
[17:44:45.423]   .. ..$ : int 1
[17:44:45.423]  $ ...future.seeds_ii       : NULL
[17:44:45.423]  $ ...future.globals.maxSize: NULL
[17:44:45.423]  - attr(*, "where")=List of 5
[17:44:45.423]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.423]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.423]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.423]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.423]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.423]  - attr(*, "resolved")= logi FALSE
[17:44:45.423]  - attr(*, "total_size")= num 504
[17:44:45.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.423]  - attr(*, "already-done")= logi TRUE
[17:44:45.429] - copied ‘...future.FUN’ to environment
[17:44:45.429] - copied ‘MoreArgs’ to environment
[17:44:45.430] - copied ‘...future.elements_ii’ to environment
[17:44:45.430] - copied ‘...future.seeds_ii’ to environment
[17:44:45.430] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.430] assign_globals() ... done
[17:44:45.430] plan(): Setting new future strategy stack:
[17:44:45.430] List of future strategies:
[17:44:45.430] 1. sequential:
[17:44:45.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.430]    - tweaked: FALSE
[17:44:45.430]    - call: NULL
[17:44:45.431] plan(): nbrOfWorkers() = 1
[17:44:45.431] plan(): Setting new future strategy stack:
[17:44:45.432] List of future strategies:
[17:44:45.432] 1. sequential:
[17:44:45.432]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.432]    - tweaked: FALSE
[17:44:45.432]    - call: plan(strategy)
[17:44:45.432] plan(): nbrOfWorkers() = 1
[17:44:45.432] SequentialFuture started (and completed)
[17:44:45.432] - Launch lazy future ... done
[17:44:45.432] run() for ‘SequentialFuture’ ... done
[17:44:45.433] Created future:
[17:44:45.433] SequentialFuture:
[17:44:45.433] Label: ‘future_mapply-1’
[17:44:45.433] Expression:
[17:44:45.433] {
[17:44:45.433]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.433]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.433]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.433]         on.exit(options(oopts), add = TRUE)
[17:44:45.433]     }
[17:44:45.433]     {
[17:44:45.433]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.433]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.433]         do.call(mapply, args = args)
[17:44:45.433]     }
[17:44:45.433] }
[17:44:45.433] Lazy evaluation: FALSE
[17:44:45.433] Asynchronous evaluation: FALSE
[17:44:45.433] Local evaluation: TRUE
[17:44:45.433] Environment: R_GlobalEnv
[17:44:45.433] Capture standard output: TRUE
[17:44:45.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.433] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.433] Packages: <none>
[17:44:45.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.433] Resolved: TRUE
[17:44:45.433] Value: 240 bytes of class ‘list’
[17:44:45.433] Early signaling: FALSE
[17:44:45.433] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.433] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.434] Chunk #1 of 1 ... DONE
[17:44:45.434] Launching 1 futures (chunks) ... DONE
[17:44:45.434] Resolving 1 futures (chunks) ...
[17:44:45.434] resolve() on list ...
[17:44:45.434]  recursive: 0
[17:44:45.434]  length: 1
[17:44:45.434] 
[17:44:45.434] resolved() for ‘SequentialFuture’ ...
[17:44:45.434] - state: ‘finished’
[17:44:45.434] - run: TRUE
[17:44:45.434] - result: ‘FutureResult’
[17:44:45.435] resolved() for ‘SequentialFuture’ ... done
[17:44:45.435] Future #1
[17:44:45.435] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.435] - nx: 1
[17:44:45.435] - relay: TRUE
[17:44:45.435] - stdout: TRUE
[17:44:45.435] - signal: TRUE
[17:44:45.435] - resignal: FALSE
[17:44:45.435] - force: TRUE
[17:44:45.435] - relayed: [n=1] FALSE
[17:44:45.436] - queued futures: [n=1] FALSE
[17:44:45.436]  - until=1
[17:44:45.436]  - relaying element #1
[17:44:45.436] - relayed: [n=1] TRUE
[17:44:45.436] - queued futures: [n=1] TRUE
[17:44:45.436] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.436]  length: 0 (resolved future 1)
[17:44:45.436] Relaying remaining futures
[17:44:45.436] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.436] - nx: 1
[17:44:45.437] - relay: TRUE
[17:44:45.437] - stdout: TRUE
[17:44:45.437] - signal: TRUE
[17:44:45.437] - resignal: FALSE
[17:44:45.437] - force: TRUE
[17:44:45.437] - relayed: [n=1] TRUE
[17:44:45.437] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.437] - relayed: [n=1] TRUE
[17:44:45.437] - queued futures: [n=1] TRUE
[17:44:45.437] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.437] resolve() on list ... DONE
[17:44:45.438]  - Number of value chunks collected: 1
[17:44:45.438] Resolving 1 futures (chunks) ... DONE
[17:44:45.438] Reducing values from 1 chunks ...
[17:44:45.438]  - Number of values collected after concatenation: 4
[17:44:45.438]  - Number of values expected: 4
[17:44:45.438] Reducing values from 1 chunks ... DONE
[17:44:45.438] future_mapply() ... DONE
[17:44:45.438] future_mapply() ...
[17:44:45.438] Number of chunks: 1
[17:44:45.439] getGlobalsAndPackagesXApply() ...
[17:44:45.439]  - future.globals: TRUE
[17:44:45.439] getGlobalsAndPackages() ...
[17:44:45.439] Searching for globals...
[17:44:45.439] - globals found: [1] ‘FUN’
[17:44:45.440] Searching for globals ... DONE
[17:44:45.440] Resolving globals: FALSE
[17:44:45.440] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:45.440] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:45.440] - globals: [1] ‘FUN’
[17:44:45.440] 
[17:44:45.441] getGlobalsAndPackages() ... DONE
[17:44:45.441]  - globals found/used: [n=1] ‘FUN’
[17:44:45.441]  - needed namespaces: [n=0] 
[17:44:45.441] Finding globals ... DONE
[17:44:45.441] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.441] List of 2
[17:44:45.441]  $ ...future.FUN:function (x, ...)  
[17:44:45.441]  $ MoreArgs     : NULL
[17:44:45.441]  - attr(*, "where")=List of 2
[17:44:45.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.441]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.441]  - attr(*, "resolved")= logi FALSE
[17:44:45.441]  - attr(*, "total_size")= num NA
[17:44:45.445] Packages to be attached in all futures: [n=0] 
[17:44:45.445] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.446] Number of futures (= number of chunks): 1
[17:44:45.446] Launching 1 futures (chunks) ...
[17:44:45.446] Chunk #1 of 1 ...
[17:44:45.446]  - Finding globals in '...' for chunk #1 ...
[17:44:45.446] getGlobalsAndPackages() ...
[17:44:45.446] Searching for globals...
[17:44:45.447] 
[17:44:45.447] Searching for globals ... DONE
[17:44:45.447] - globals: [0] <none>
[17:44:45.447] getGlobalsAndPackages() ... DONE
[17:44:45.447]    + additional globals found: [n=0] 
[17:44:45.447]    + additional namespaces needed: [n=0] 
[17:44:45.447]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.447]  - seeds: <none>
[17:44:45.447]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.447] getGlobalsAndPackages() ...
[17:44:45.447] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.448] Resolving globals: FALSE
[17:44:45.448] The total size of the 5 globals is 504 bytes (504 bytes)
[17:44:45.449] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.449] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.449] 
[17:44:45.449] getGlobalsAndPackages() ... DONE
[17:44:45.449] run() for ‘Future’ ...
[17:44:45.449] - state: ‘created’
[17:44:45.449] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.450]   - Field: ‘label’
[17:44:45.450]   - Field: ‘local’
[17:44:45.450]   - Field: ‘owner’
[17:44:45.450]   - Field: ‘envir’
[17:44:45.450]   - Field: ‘packages’
[17:44:45.450]   - Field: ‘gc’
[17:44:45.450]   - Field: ‘conditions’
[17:44:45.450]   - Field: ‘expr’
[17:44:45.451]   - Field: ‘uuid’
[17:44:45.451]   - Field: ‘seed’
[17:44:45.451]   - Field: ‘version’
[17:44:45.451]   - Field: ‘result’
[17:44:45.451]   - Field: ‘asynchronous’
[17:44:45.451]   - Field: ‘calls’
[17:44:45.451]   - Field: ‘globals’
[17:44:45.451]   - Field: ‘stdout’
[17:44:45.451]   - Field: ‘earlySignal’
[17:44:45.451]   - Field: ‘lazy’
[17:44:45.451]   - Field: ‘state’
[17:44:45.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.452] - Launch lazy future ...
[17:44:45.452] Packages needed by the future expression (n = 0): <none>
[17:44:45.452] Packages needed by future strategies (n = 0): <none>
[17:44:45.452] {
[17:44:45.452]     {
[17:44:45.452]         {
[17:44:45.452]             ...future.startTime <- base::Sys.time()
[17:44:45.452]             {
[17:44:45.452]                 {
[17:44:45.452]                   {
[17:44:45.452]                     base::local({
[17:44:45.452]                       has_future <- base::requireNamespace("future", 
[17:44:45.452]                         quietly = TRUE)
[17:44:45.452]                       if (has_future) {
[17:44:45.452]                         ns <- base::getNamespace("future")
[17:44:45.452]                         version <- ns[[".package"]][["version"]]
[17:44:45.452]                         if (is.null(version)) 
[17:44:45.452]                           version <- utils::packageVersion("future")
[17:44:45.452]                       }
[17:44:45.452]                       else {
[17:44:45.452]                         version <- NULL
[17:44:45.452]                       }
[17:44:45.452]                       if (!has_future || version < "1.8.0") {
[17:44:45.452]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.452]                           "", base::R.version$version.string), 
[17:44:45.452]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.452]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.452]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.452]                             "release", "version")], collapse = " "), 
[17:44:45.452]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.452]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.452]                           info)
[17:44:45.452]                         info <- base::paste(info, collapse = "; ")
[17:44:45.452]                         if (!has_future) {
[17:44:45.452]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.452]                             info)
[17:44:45.452]                         }
[17:44:45.452]                         else {
[17:44:45.452]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.452]                             info, version)
[17:44:45.452]                         }
[17:44:45.452]                         base::stop(msg)
[17:44:45.452]                       }
[17:44:45.452]                     })
[17:44:45.452]                   }
[17:44:45.452]                   ...future.strategy.old <- future::plan("list")
[17:44:45.452]                   options(future.plan = NULL)
[17:44:45.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.452]                 }
[17:44:45.452]                 ...future.workdir <- getwd()
[17:44:45.452]             }
[17:44:45.452]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.452]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.452]         }
[17:44:45.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.452]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.452]             base::names(...future.oldOptions))
[17:44:45.452]     }
[17:44:45.452]     if (FALSE) {
[17:44:45.452]     }
[17:44:45.452]     else {
[17:44:45.452]         if (TRUE) {
[17:44:45.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.452]                 open = "w")
[17:44:45.452]         }
[17:44:45.452]         else {
[17:44:45.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.452]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.452]         }
[17:44:45.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.452]             base::sink(type = "output", split = FALSE)
[17:44:45.452]             base::close(...future.stdout)
[17:44:45.452]         }, add = TRUE)
[17:44:45.452]     }
[17:44:45.452]     ...future.frame <- base::sys.nframe()
[17:44:45.452]     ...future.conditions <- base::list()
[17:44:45.452]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.452]     if (FALSE) {
[17:44:45.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.452]     }
[17:44:45.452]     ...future.result <- base::tryCatch({
[17:44:45.452]         base::withCallingHandlers({
[17:44:45.452]             ...future.value <- base::withVisible(base::local({
[17:44:45.452]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.452]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.452]                   ...future.globals.maxSize)) {
[17:44:45.452]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.452]                   on.exit(options(oopts), add = TRUE)
[17:44:45.452]                 }
[17:44:45.452]                 {
[17:44:45.452]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.452]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.452]                     USE.NAMES = FALSE)
[17:44:45.452]                   do.call(mapply, args = args)
[17:44:45.452]                 }
[17:44:45.452]             }))
[17:44:45.452]             future::FutureResult(value = ...future.value$value, 
[17:44:45.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.452]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.452]                     ...future.globalenv.names))
[17:44:45.452]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.452]         }, condition = base::local({
[17:44:45.452]             c <- base::c
[17:44:45.452]             inherits <- base::inherits
[17:44:45.452]             invokeRestart <- base::invokeRestart
[17:44:45.452]             length <- base::length
[17:44:45.452]             list <- base::list
[17:44:45.452]             seq.int <- base::seq.int
[17:44:45.452]             signalCondition <- base::signalCondition
[17:44:45.452]             sys.calls <- base::sys.calls
[17:44:45.452]             `[[` <- base::`[[`
[17:44:45.452]             `+` <- base::`+`
[17:44:45.452]             `<<-` <- base::`<<-`
[17:44:45.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.452]                   3L)]
[17:44:45.452]             }
[17:44:45.452]             function(cond) {
[17:44:45.452]                 is_error <- inherits(cond, "error")
[17:44:45.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.452]                   NULL)
[17:44:45.452]                 if (is_error) {
[17:44:45.452]                   sessionInformation <- function() {
[17:44:45.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.452]                       search = base::search(), system = base::Sys.info())
[17:44:45.452]                   }
[17:44:45.452]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.452]                     cond$call), session = sessionInformation(), 
[17:44:45.452]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.452]                   signalCondition(cond)
[17:44:45.452]                 }
[17:44:45.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.452]                 "immediateCondition"))) {
[17:44:45.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.452]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.452]                   if (TRUE && !signal) {
[17:44:45.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.452]                     {
[17:44:45.452]                       inherits <- base::inherits
[17:44:45.452]                       invokeRestart <- base::invokeRestart
[17:44:45.452]                       is.null <- base::is.null
[17:44:45.452]                       muffled <- FALSE
[17:44:45.452]                       if (inherits(cond, "message")) {
[17:44:45.452]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.452]                         if (muffled) 
[17:44:45.452]                           invokeRestart("muffleMessage")
[17:44:45.452]                       }
[17:44:45.452]                       else if (inherits(cond, "warning")) {
[17:44:45.452]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.452]                         if (muffled) 
[17:44:45.452]                           invokeRestart("muffleWarning")
[17:44:45.452]                       }
[17:44:45.452]                       else if (inherits(cond, "condition")) {
[17:44:45.452]                         if (!is.null(pattern)) {
[17:44:45.452]                           computeRestarts <- base::computeRestarts
[17:44:45.452]                           grepl <- base::grepl
[17:44:45.452]                           restarts <- computeRestarts(cond)
[17:44:45.452]                           for (restart in restarts) {
[17:44:45.452]                             name <- restart$name
[17:44:45.452]                             if (is.null(name)) 
[17:44:45.452]                               next
[17:44:45.452]                             if (!grepl(pattern, name)) 
[17:44:45.452]                               next
[17:44:45.452]                             invokeRestart(restart)
[17:44:45.452]                             muffled <- TRUE
[17:44:45.452]                             break
[17:44:45.452]                           }
[17:44:45.452]                         }
[17:44:45.452]                       }
[17:44:45.452]                       invisible(muffled)
[17:44:45.452]                     }
[17:44:45.452]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.452]                   }
[17:44:45.452]                 }
[17:44:45.452]                 else {
[17:44:45.452]                   if (TRUE) {
[17:44:45.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.452]                     {
[17:44:45.452]                       inherits <- base::inherits
[17:44:45.452]                       invokeRestart <- base::invokeRestart
[17:44:45.452]                       is.null <- base::is.null
[17:44:45.452]                       muffled <- FALSE
[17:44:45.452]                       if (inherits(cond, "message")) {
[17:44:45.452]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.452]                         if (muffled) 
[17:44:45.452]                           invokeRestart("muffleMessage")
[17:44:45.452]                       }
[17:44:45.452]                       else if (inherits(cond, "warning")) {
[17:44:45.452]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.452]                         if (muffled) 
[17:44:45.452]                           invokeRestart("muffleWarning")
[17:44:45.452]                       }
[17:44:45.452]                       else if (inherits(cond, "condition")) {
[17:44:45.452]                         if (!is.null(pattern)) {
[17:44:45.452]                           computeRestarts <- base::computeRestarts
[17:44:45.452]                           grepl <- base::grepl
[17:44:45.452]                           restarts <- computeRestarts(cond)
[17:44:45.452]                           for (restart in restarts) {
[17:44:45.452]                             name <- restart$name
[17:44:45.452]                             if (is.null(name)) 
[17:44:45.452]                               next
[17:44:45.452]                             if (!grepl(pattern, name)) 
[17:44:45.452]                               next
[17:44:45.452]                             invokeRestart(restart)
[17:44:45.452]                             muffled <- TRUE
[17:44:45.452]                             break
[17:44:45.452]                           }
[17:44:45.452]                         }
[17:44:45.452]                       }
[17:44:45.452]                       invisible(muffled)
[17:44:45.452]                     }
[17:44:45.452]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.452]                   }
[17:44:45.452]                 }
[17:44:45.452]             }
[17:44:45.452]         }))
[17:44:45.452]     }, error = function(ex) {
[17:44:45.452]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.452]                 ...future.rng), started = ...future.startTime, 
[17:44:45.452]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.452]             version = "1.8"), class = "FutureResult")
[17:44:45.452]     }, finally = {
[17:44:45.452]         if (!identical(...future.workdir, getwd())) 
[17:44:45.452]             setwd(...future.workdir)
[17:44:45.452]         {
[17:44:45.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.452]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.452]             }
[17:44:45.452]             base::options(...future.oldOptions)
[17:44:45.452]             if (.Platform$OS.type == "windows") {
[17:44:45.452]                 old_names <- names(...future.oldEnvVars)
[17:44:45.452]                 envs <- base::Sys.getenv()
[17:44:45.452]                 names <- names(envs)
[17:44:45.452]                 common <- intersect(names, old_names)
[17:44:45.452]                 added <- setdiff(names, old_names)
[17:44:45.452]                 removed <- setdiff(old_names, names)
[17:44:45.452]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.452]                   envs[common]]
[17:44:45.452]                 NAMES <- toupper(changed)
[17:44:45.452]                 args <- list()
[17:44:45.452]                 for (kk in seq_along(NAMES)) {
[17:44:45.452]                   name <- changed[[kk]]
[17:44:45.452]                   NAME <- NAMES[[kk]]
[17:44:45.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.452]                     next
[17:44:45.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.452]                 }
[17:44:45.452]                 NAMES <- toupper(added)
[17:44:45.452]                 for (kk in seq_along(NAMES)) {
[17:44:45.452]                   name <- added[[kk]]
[17:44:45.452]                   NAME <- NAMES[[kk]]
[17:44:45.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.452]                     next
[17:44:45.452]                   args[[name]] <- ""
[17:44:45.452]                 }
[17:44:45.452]                 NAMES <- toupper(removed)
[17:44:45.452]                 for (kk in seq_along(NAMES)) {
[17:44:45.452]                   name <- removed[[kk]]
[17:44:45.452]                   NAME <- NAMES[[kk]]
[17:44:45.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.452]                     next
[17:44:45.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.452]                 }
[17:44:45.452]                 if (length(args) > 0) 
[17:44:45.452]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.452]             }
[17:44:45.452]             else {
[17:44:45.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.452]             }
[17:44:45.452]             {
[17:44:45.452]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.452]                   0L) {
[17:44:45.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.452]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.452]                   base::options(opts)
[17:44:45.452]                 }
[17:44:45.452]                 {
[17:44:45.452]                   {
[17:44:45.452]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.452]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.452]                     -484569582L), envir = base::globalenv(), 
[17:44:45.452]                       inherits = FALSE)
[17:44:45.452]                     NULL
[17:44:45.452]                   }
[17:44:45.452]                   options(future.plan = NULL)
[17:44:45.452]                   if (is.na(NA_character_)) 
[17:44:45.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.452]                     .init = FALSE)
[17:44:45.452]                 }
[17:44:45.452]             }
[17:44:45.452]         }
[17:44:45.452]     })
[17:44:45.452]     if (TRUE) {
[17:44:45.452]         base::sink(type = "output", split = FALSE)
[17:44:45.452]         if (TRUE) {
[17:44:45.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.452]         }
[17:44:45.452]         else {
[17:44:45.452]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.452]         }
[17:44:45.452]         base::close(...future.stdout)
[17:44:45.452]         ...future.stdout <- NULL
[17:44:45.452]     }
[17:44:45.452]     ...future.result$conditions <- ...future.conditions
[17:44:45.452]     ...future.result$finished <- base::Sys.time()
[17:44:45.452]     ...future.result
[17:44:45.452] }
[17:44:45.454] assign_globals() ...
[17:44:45.454] List of 5
[17:44:45.454]  $ ...future.FUN            :function (x, ...)  
[17:44:45.454]  $ MoreArgs                 : NULL
[17:44:45.454]  $ ...future.elements_ii    :List of 2
[17:44:45.454]   ..$ times:List of 4
[17:44:45.454]   .. ..$ : int 1
[17:44:45.454]   .. ..$ : int 2
[17:44:45.454]   .. ..$ : int 3
[17:44:45.454]   .. ..$ : int 4
[17:44:45.454]   ..$ x    :List of 4
[17:44:45.454]   .. ..$ : int 4
[17:44:45.454]   .. ..$ : int 3
[17:44:45.454]   .. ..$ : int 2
[17:44:45.454]   .. ..$ : int 1
[17:44:45.454]  $ ...future.seeds_ii       : NULL
[17:44:45.454]  $ ...future.globals.maxSize: NULL
[17:44:45.454]  - attr(*, "where")=List of 5
[17:44:45.454]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.454]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.454]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.454]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.454]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.454]  - attr(*, "resolved")= logi FALSE
[17:44:45.454]  - attr(*, "total_size")= num 504
[17:44:45.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.454]  - attr(*, "already-done")= logi TRUE
[17:44:45.461] - copied ‘...future.FUN’ to environment
[17:44:45.461] - copied ‘MoreArgs’ to environment
[17:44:45.461] - copied ‘...future.elements_ii’ to environment
[17:44:45.461] - copied ‘...future.seeds_ii’ to environment
[17:44:45.461] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.461] assign_globals() ... done
[17:44:45.461] plan(): Setting new future strategy stack:
[17:44:45.461] List of future strategies:
[17:44:45.461] 1. sequential:
[17:44:45.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.461]    - tweaked: FALSE
[17:44:45.461]    - call: NULL
[17:44:45.462] plan(): nbrOfWorkers() = 1
[17:44:45.463] plan(): Setting new future strategy stack:
[17:44:45.463] List of future strategies:
[17:44:45.463] 1. sequential:
[17:44:45.463]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.463]    - tweaked: FALSE
[17:44:45.463]    - call: plan(strategy)
[17:44:45.463] plan(): nbrOfWorkers() = 1
[17:44:45.463] SequentialFuture started (and completed)
[17:44:45.464] - Launch lazy future ... done
[17:44:45.464] run() for ‘SequentialFuture’ ... done
[17:44:45.464] Created future:
[17:44:45.464] SequentialFuture:
[17:44:45.464] Label: ‘future_mapply-1’
[17:44:45.464] Expression:
[17:44:45.464] {
[17:44:45.464]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.464]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.464]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.464]         on.exit(options(oopts), add = TRUE)
[17:44:45.464]     }
[17:44:45.464]     {
[17:44:45.464]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.464]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.464]         do.call(mapply, args = args)
[17:44:45.464]     }
[17:44:45.464] }
[17:44:45.464] Lazy evaluation: FALSE
[17:44:45.464] Asynchronous evaluation: FALSE
[17:44:45.464] Local evaluation: TRUE
[17:44:45.464] Environment: R_GlobalEnv
[17:44:45.464] Capture standard output: TRUE
[17:44:45.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.464] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.464] Packages: <none>
[17:44:45.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.464] Resolved: TRUE
[17:44:45.464] Value: 240 bytes of class ‘list’
[17:44:45.464] Early signaling: FALSE
[17:44:45.464] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.464] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.465] Chunk #1 of 1 ... DONE
[17:44:45.465] Launching 1 futures (chunks) ... DONE
[17:44:45.465] Resolving 1 futures (chunks) ...
[17:44:45.465] resolve() on list ...
[17:44:45.465]  recursive: 0
[17:44:45.465]  length: 1
[17:44:45.465] 
[17:44:45.465] resolved() for ‘SequentialFuture’ ...
[17:44:45.466] - state: ‘finished’
[17:44:45.466] - run: TRUE
[17:44:45.466] - result: ‘FutureResult’
[17:44:45.466] resolved() for ‘SequentialFuture’ ... done
[17:44:45.466] Future #1
[17:44:45.466] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.466] - nx: 1
[17:44:45.466] - relay: TRUE
[17:44:45.466] - stdout: TRUE
[17:44:45.466] - signal: TRUE
[17:44:45.466] - resignal: FALSE
[17:44:45.467] - force: TRUE
[17:44:45.467] - relayed: [n=1] FALSE
[17:44:45.467] - queued futures: [n=1] FALSE
[17:44:45.467]  - until=1
[17:44:45.467]  - relaying element #1
[17:44:45.467] - relayed: [n=1] TRUE
[17:44:45.467] - queued futures: [n=1] TRUE
[17:44:45.467] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.467]  length: 0 (resolved future 1)
[17:44:45.467] Relaying remaining futures
[17:44:45.468] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.468] - nx: 1
[17:44:45.468] - relay: TRUE
[17:44:45.468] - stdout: TRUE
[17:44:45.468] - signal: TRUE
[17:44:45.468] - resignal: FALSE
[17:44:45.468] - force: TRUE
[17:44:45.468] - relayed: [n=1] TRUE
[17:44:45.468] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.468] - relayed: [n=1] TRUE
[17:44:45.468] - queued futures: [n=1] TRUE
[17:44:45.469] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.469] resolve() on list ... DONE
[17:44:45.470]  - Number of value chunks collected: 1
[17:44:45.471] Resolving 1 futures (chunks) ... DONE
[17:44:45.471] Reducing values from 1 chunks ...
[17:44:45.471]  - Number of values collected after concatenation: 4
[17:44:45.471]  - Number of values expected: 4
[17:44:45.471] Reducing values from 1 chunks ... DONE
[17:44:45.471] future_mapply() ... DONE
[17:44:45.471] future_mapply() ...
[17:44:45.471] Number of chunks: 1
[17:44:45.471] getGlobalsAndPackagesXApply() ...
[17:44:45.471]  - future.globals: TRUE
[17:44:45.472] getGlobalsAndPackages() ...
[17:44:45.472] Searching for globals...
[17:44:45.472] - globals found: [1] ‘FUN’
[17:44:45.472] Searching for globals ... DONE
[17:44:45.473] Resolving globals: FALSE
[17:44:45.473] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:45.473] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:45.473] - globals: [1] ‘FUN’
[17:44:45.473] 
[17:44:45.473] getGlobalsAndPackages() ... DONE
[17:44:45.474]  - globals found/used: [n=1] ‘FUN’
[17:44:45.474]  - needed namespaces: [n=0] 
[17:44:45.474] Finding globals ... DONE
[17:44:45.474] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.474] List of 2
[17:44:45.474]  $ ...future.FUN:function (x, ...)  
[17:44:45.474]  $ MoreArgs     :List of 1
[17:44:45.474]   ..$ x: num 42
[17:44:45.474]  - attr(*, "where")=List of 2
[17:44:45.474]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.474]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.474]  - attr(*, "resolved")= logi FALSE
[17:44:45.474]  - attr(*, "total_size")= num NA
[17:44:45.477] Packages to be attached in all futures: [n=0] 
[17:44:45.477] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.477] Number of futures (= number of chunks): 1
[17:44:45.477] Launching 1 futures (chunks) ...
[17:44:45.477] Chunk #1 of 1 ...
[17:44:45.477]  - Finding globals in '...' for chunk #1 ...
[17:44:45.478] getGlobalsAndPackages() ...
[17:44:45.478] Searching for globals...
[17:44:45.478] 
[17:44:45.478] Searching for globals ... DONE
[17:44:45.478] - globals: [0] <none>
[17:44:45.478] getGlobalsAndPackages() ... DONE
[17:44:45.478]    + additional globals found: [n=0] 
[17:44:45.478]    + additional namespaces needed: [n=0] 
[17:44:45.478]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.479]  - seeds: <none>
[17:44:45.479]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.479] getGlobalsAndPackages() ...
[17:44:45.479] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.479] Resolving globals: FALSE
[17:44:45.479] The total size of the 5 globals is 336 bytes (336 bytes)
[17:44:45.480] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 336 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:45.480] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.480] 
[17:44:45.480] getGlobalsAndPackages() ... DONE
[17:44:45.480] run() for ‘Future’ ...
[17:44:45.481] - state: ‘created’
[17:44:45.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.481]   - Field: ‘label’
[17:44:45.481]   - Field: ‘local’
[17:44:45.481]   - Field: ‘owner’
[17:44:45.482]   - Field: ‘envir’
[17:44:45.482]   - Field: ‘packages’
[17:44:45.482]   - Field: ‘gc’
[17:44:45.482]   - Field: ‘conditions’
[17:44:45.482]   - Field: ‘expr’
[17:44:45.482]   - Field: ‘uuid’
[17:44:45.482]   - Field: ‘seed’
[17:44:45.482]   - Field: ‘version’
[17:44:45.482]   - Field: ‘result’
[17:44:45.482]   - Field: ‘asynchronous’
[17:44:45.482]   - Field: ‘calls’
[17:44:45.483]   - Field: ‘globals’
[17:44:45.483]   - Field: ‘stdout’
[17:44:45.483]   - Field: ‘earlySignal’
[17:44:45.483]   - Field: ‘lazy’
[17:44:45.483]   - Field: ‘state’
[17:44:45.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.483] - Launch lazy future ...
[17:44:45.483] Packages needed by the future expression (n = 0): <none>
[17:44:45.483] Packages needed by future strategies (n = 0): <none>
[17:44:45.484] {
[17:44:45.484]     {
[17:44:45.484]         {
[17:44:45.484]             ...future.startTime <- base::Sys.time()
[17:44:45.484]             {
[17:44:45.484]                 {
[17:44:45.484]                   {
[17:44:45.484]                     base::local({
[17:44:45.484]                       has_future <- base::requireNamespace("future", 
[17:44:45.484]                         quietly = TRUE)
[17:44:45.484]                       if (has_future) {
[17:44:45.484]                         ns <- base::getNamespace("future")
[17:44:45.484]                         version <- ns[[".package"]][["version"]]
[17:44:45.484]                         if (is.null(version)) 
[17:44:45.484]                           version <- utils::packageVersion("future")
[17:44:45.484]                       }
[17:44:45.484]                       else {
[17:44:45.484]                         version <- NULL
[17:44:45.484]                       }
[17:44:45.484]                       if (!has_future || version < "1.8.0") {
[17:44:45.484]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.484]                           "", base::R.version$version.string), 
[17:44:45.484]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.484]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.484]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.484]                             "release", "version")], collapse = " "), 
[17:44:45.484]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.484]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.484]                           info)
[17:44:45.484]                         info <- base::paste(info, collapse = "; ")
[17:44:45.484]                         if (!has_future) {
[17:44:45.484]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.484]                             info)
[17:44:45.484]                         }
[17:44:45.484]                         else {
[17:44:45.484]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.484]                             info, version)
[17:44:45.484]                         }
[17:44:45.484]                         base::stop(msg)
[17:44:45.484]                       }
[17:44:45.484]                     })
[17:44:45.484]                   }
[17:44:45.484]                   ...future.strategy.old <- future::plan("list")
[17:44:45.484]                   options(future.plan = NULL)
[17:44:45.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.484]                 }
[17:44:45.484]                 ...future.workdir <- getwd()
[17:44:45.484]             }
[17:44:45.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.484]         }
[17:44:45.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.484]             base::names(...future.oldOptions))
[17:44:45.484]     }
[17:44:45.484]     if (FALSE) {
[17:44:45.484]     }
[17:44:45.484]     else {
[17:44:45.484]         if (TRUE) {
[17:44:45.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.484]                 open = "w")
[17:44:45.484]         }
[17:44:45.484]         else {
[17:44:45.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.484]         }
[17:44:45.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.484]             base::sink(type = "output", split = FALSE)
[17:44:45.484]             base::close(...future.stdout)
[17:44:45.484]         }, add = TRUE)
[17:44:45.484]     }
[17:44:45.484]     ...future.frame <- base::sys.nframe()
[17:44:45.484]     ...future.conditions <- base::list()
[17:44:45.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.484]     if (FALSE) {
[17:44:45.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.484]     }
[17:44:45.484]     ...future.result <- base::tryCatch({
[17:44:45.484]         base::withCallingHandlers({
[17:44:45.484]             ...future.value <- base::withVisible(base::local({
[17:44:45.484]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.484]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.484]                   ...future.globals.maxSize)) {
[17:44:45.484]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.484]                   on.exit(options(oopts), add = TRUE)
[17:44:45.484]                 }
[17:44:45.484]                 {
[17:44:45.484]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.484]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.484]                     USE.NAMES = FALSE)
[17:44:45.484]                   do.call(mapply, args = args)
[17:44:45.484]                 }
[17:44:45.484]             }))
[17:44:45.484]             future::FutureResult(value = ...future.value$value, 
[17:44:45.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.484]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.484]                     ...future.globalenv.names))
[17:44:45.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.484]         }, condition = base::local({
[17:44:45.484]             c <- base::c
[17:44:45.484]             inherits <- base::inherits
[17:44:45.484]             invokeRestart <- base::invokeRestart
[17:44:45.484]             length <- base::length
[17:44:45.484]             list <- base::list
[17:44:45.484]             seq.int <- base::seq.int
[17:44:45.484]             signalCondition <- base::signalCondition
[17:44:45.484]             sys.calls <- base::sys.calls
[17:44:45.484]             `[[` <- base::`[[`
[17:44:45.484]             `+` <- base::`+`
[17:44:45.484]             `<<-` <- base::`<<-`
[17:44:45.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.484]                   3L)]
[17:44:45.484]             }
[17:44:45.484]             function(cond) {
[17:44:45.484]                 is_error <- inherits(cond, "error")
[17:44:45.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.484]                   NULL)
[17:44:45.484]                 if (is_error) {
[17:44:45.484]                   sessionInformation <- function() {
[17:44:45.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.484]                       search = base::search(), system = base::Sys.info())
[17:44:45.484]                   }
[17:44:45.484]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.484]                     cond$call), session = sessionInformation(), 
[17:44:45.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.484]                   signalCondition(cond)
[17:44:45.484]                 }
[17:44:45.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.484]                 "immediateCondition"))) {
[17:44:45.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.484]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.484]                   if (TRUE && !signal) {
[17:44:45.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.484]                     {
[17:44:45.484]                       inherits <- base::inherits
[17:44:45.484]                       invokeRestart <- base::invokeRestart
[17:44:45.484]                       is.null <- base::is.null
[17:44:45.484]                       muffled <- FALSE
[17:44:45.484]                       if (inherits(cond, "message")) {
[17:44:45.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.484]                         if (muffled) 
[17:44:45.484]                           invokeRestart("muffleMessage")
[17:44:45.484]                       }
[17:44:45.484]                       else if (inherits(cond, "warning")) {
[17:44:45.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.484]                         if (muffled) 
[17:44:45.484]                           invokeRestart("muffleWarning")
[17:44:45.484]                       }
[17:44:45.484]                       else if (inherits(cond, "condition")) {
[17:44:45.484]                         if (!is.null(pattern)) {
[17:44:45.484]                           computeRestarts <- base::computeRestarts
[17:44:45.484]                           grepl <- base::grepl
[17:44:45.484]                           restarts <- computeRestarts(cond)
[17:44:45.484]                           for (restart in restarts) {
[17:44:45.484]                             name <- restart$name
[17:44:45.484]                             if (is.null(name)) 
[17:44:45.484]                               next
[17:44:45.484]                             if (!grepl(pattern, name)) 
[17:44:45.484]                               next
[17:44:45.484]                             invokeRestart(restart)
[17:44:45.484]                             muffled <- TRUE
[17:44:45.484]                             break
[17:44:45.484]                           }
[17:44:45.484]                         }
[17:44:45.484]                       }
[17:44:45.484]                       invisible(muffled)
[17:44:45.484]                     }
[17:44:45.484]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.484]                   }
[17:44:45.484]                 }
[17:44:45.484]                 else {
[17:44:45.484]                   if (TRUE) {
[17:44:45.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.484]                     {
[17:44:45.484]                       inherits <- base::inherits
[17:44:45.484]                       invokeRestart <- base::invokeRestart
[17:44:45.484]                       is.null <- base::is.null
[17:44:45.484]                       muffled <- FALSE
[17:44:45.484]                       if (inherits(cond, "message")) {
[17:44:45.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.484]                         if (muffled) 
[17:44:45.484]                           invokeRestart("muffleMessage")
[17:44:45.484]                       }
[17:44:45.484]                       else if (inherits(cond, "warning")) {
[17:44:45.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.484]                         if (muffled) 
[17:44:45.484]                           invokeRestart("muffleWarning")
[17:44:45.484]                       }
[17:44:45.484]                       else if (inherits(cond, "condition")) {
[17:44:45.484]                         if (!is.null(pattern)) {
[17:44:45.484]                           computeRestarts <- base::computeRestarts
[17:44:45.484]                           grepl <- base::grepl
[17:44:45.484]                           restarts <- computeRestarts(cond)
[17:44:45.484]                           for (restart in restarts) {
[17:44:45.484]                             name <- restart$name
[17:44:45.484]                             if (is.null(name)) 
[17:44:45.484]                               next
[17:44:45.484]                             if (!grepl(pattern, name)) 
[17:44:45.484]                               next
[17:44:45.484]                             invokeRestart(restart)
[17:44:45.484]                             muffled <- TRUE
[17:44:45.484]                             break
[17:44:45.484]                           }
[17:44:45.484]                         }
[17:44:45.484]                       }
[17:44:45.484]                       invisible(muffled)
[17:44:45.484]                     }
[17:44:45.484]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.484]                   }
[17:44:45.484]                 }
[17:44:45.484]             }
[17:44:45.484]         }))
[17:44:45.484]     }, error = function(ex) {
[17:44:45.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.484]                 ...future.rng), started = ...future.startTime, 
[17:44:45.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.484]             version = "1.8"), class = "FutureResult")
[17:44:45.484]     }, finally = {
[17:44:45.484]         if (!identical(...future.workdir, getwd())) 
[17:44:45.484]             setwd(...future.workdir)
[17:44:45.484]         {
[17:44:45.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.484]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.484]             }
[17:44:45.484]             base::options(...future.oldOptions)
[17:44:45.484]             if (.Platform$OS.type == "windows") {
[17:44:45.484]                 old_names <- names(...future.oldEnvVars)
[17:44:45.484]                 envs <- base::Sys.getenv()
[17:44:45.484]                 names <- names(envs)
[17:44:45.484]                 common <- intersect(names, old_names)
[17:44:45.484]                 added <- setdiff(names, old_names)
[17:44:45.484]                 removed <- setdiff(old_names, names)
[17:44:45.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.484]                   envs[common]]
[17:44:45.484]                 NAMES <- toupper(changed)
[17:44:45.484]                 args <- list()
[17:44:45.484]                 for (kk in seq_along(NAMES)) {
[17:44:45.484]                   name <- changed[[kk]]
[17:44:45.484]                   NAME <- NAMES[[kk]]
[17:44:45.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.484]                     next
[17:44:45.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.484]                 }
[17:44:45.484]                 NAMES <- toupper(added)
[17:44:45.484]                 for (kk in seq_along(NAMES)) {
[17:44:45.484]                   name <- added[[kk]]
[17:44:45.484]                   NAME <- NAMES[[kk]]
[17:44:45.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.484]                     next
[17:44:45.484]                   args[[name]] <- ""
[17:44:45.484]                 }
[17:44:45.484]                 NAMES <- toupper(removed)
[17:44:45.484]                 for (kk in seq_along(NAMES)) {
[17:44:45.484]                   name <- removed[[kk]]
[17:44:45.484]                   NAME <- NAMES[[kk]]
[17:44:45.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.484]                     next
[17:44:45.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.484]                 }
[17:44:45.484]                 if (length(args) > 0) 
[17:44:45.484]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.484]             }
[17:44:45.484]             else {
[17:44:45.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.484]             }
[17:44:45.484]             {
[17:44:45.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.484]                   0L) {
[17:44:45.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.484]                   base::options(opts)
[17:44:45.484]                 }
[17:44:45.484]                 {
[17:44:45.484]                   {
[17:44:45.484]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.484]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.484]                     -484569582L), envir = base::globalenv(), 
[17:44:45.484]                       inherits = FALSE)
[17:44:45.484]                     NULL
[17:44:45.484]                   }
[17:44:45.484]                   options(future.plan = NULL)
[17:44:45.484]                   if (is.na(NA_character_)) 
[17:44:45.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.484]                     .init = FALSE)
[17:44:45.484]                 }
[17:44:45.484]             }
[17:44:45.484]         }
[17:44:45.484]     })
[17:44:45.484]     if (TRUE) {
[17:44:45.484]         base::sink(type = "output", split = FALSE)
[17:44:45.484]         if (TRUE) {
[17:44:45.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.484]         }
[17:44:45.484]         else {
[17:44:45.484]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.484]         }
[17:44:45.484]         base::close(...future.stdout)
[17:44:45.484]         ...future.stdout <- NULL
[17:44:45.484]     }
[17:44:45.484]     ...future.result$conditions <- ...future.conditions
[17:44:45.484]     ...future.result$finished <- base::Sys.time()
[17:44:45.484]     ...future.result
[17:44:45.484] }
[17:44:45.485] assign_globals() ...
[17:44:45.486] List of 5
[17:44:45.486]  $ ...future.FUN            :function (x, ...)  
[17:44:45.486]  $ MoreArgs                 :List of 1
[17:44:45.486]   ..$ x: num 42
[17:44:45.486]  $ ...future.elements_ii    :List of 1
[17:44:45.486]   ..$ times:List of 4
[17:44:45.486]   .. ..$ : int 1
[17:44:45.486]   .. ..$ : int 2
[17:44:45.486]   .. ..$ : int 3
[17:44:45.486]   .. ..$ : int 4
[17:44:45.486]  $ ...future.seeds_ii       : NULL
[17:44:45.486]  $ ...future.globals.maxSize: NULL
[17:44:45.486]  - attr(*, "where")=List of 5
[17:44:45.486]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.486]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.486]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.486]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.486]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.486]  - attr(*, "resolved")= logi FALSE
[17:44:45.486]  - attr(*, "total_size")= num 336
[17:44:45.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.486]  - attr(*, "already-done")= logi TRUE
[17:44:45.491] - copied ‘...future.FUN’ to environment
[17:44:45.492] - copied ‘MoreArgs’ to environment
[17:44:45.492] - copied ‘...future.elements_ii’ to environment
[17:44:45.492] - copied ‘...future.seeds_ii’ to environment
[17:44:45.492] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.492] assign_globals() ... done
[17:44:45.492] plan(): Setting new future strategy stack:
[17:44:45.492] List of future strategies:
[17:44:45.492] 1. sequential:
[17:44:45.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.492]    - tweaked: FALSE
[17:44:45.492]    - call: NULL
[17:44:45.493] plan(): nbrOfWorkers() = 1
[17:44:45.493] plan(): Setting new future strategy stack:
[17:44:45.494] List of future strategies:
[17:44:45.494] 1. sequential:
[17:44:45.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.494]    - tweaked: FALSE
[17:44:45.494]    - call: plan(strategy)
[17:44:45.494] plan(): nbrOfWorkers() = 1
[17:44:45.494] SequentialFuture started (and completed)
[17:44:45.494] - Launch lazy future ... done
[17:44:45.494] run() for ‘SequentialFuture’ ... done
[17:44:45.495] Created future:
[17:44:45.495] SequentialFuture:
[17:44:45.495] Label: ‘future_mapply-1’
[17:44:45.495] Expression:
[17:44:45.495] {
[17:44:45.495]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.495]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.495]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.495]         on.exit(options(oopts), add = TRUE)
[17:44:45.495]     }
[17:44:45.495]     {
[17:44:45.495]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.495]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.495]         do.call(mapply, args = args)
[17:44:45.495]     }
[17:44:45.495] }
[17:44:45.495] Lazy evaluation: FALSE
[17:44:45.495] Asynchronous evaluation: FALSE
[17:44:45.495] Local evaluation: TRUE
[17:44:45.495] Environment: R_GlobalEnv
[17:44:45.495] Capture standard output: TRUE
[17:44:45.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.495] Globals: 5 objects totaling 336 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.495] Packages: <none>
[17:44:45.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.495] Resolved: TRUE
[17:44:45.495] Value: 280 bytes of class ‘list’
[17:44:45.495] Early signaling: FALSE
[17:44:45.495] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.495] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.496] Chunk #1 of 1 ... DONE
[17:44:45.496] Launching 1 futures (chunks) ... DONE
[17:44:45.496] Resolving 1 futures (chunks) ...
[17:44:45.496] resolve() on list ...
[17:44:45.496]  recursive: 0
[17:44:45.498]  length: 1
[17:44:45.498] 
[17:44:45.498] resolved() for ‘SequentialFuture’ ...
[17:44:45.498] - state: ‘finished’
[17:44:45.498] - run: TRUE
[17:44:45.498] - result: ‘FutureResult’
[17:44:45.498] resolved() for ‘SequentialFuture’ ... done
[17:44:45.499] Future #1
[17:44:45.499] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.499] - nx: 1
[17:44:45.499] - relay: TRUE
[17:44:45.499] - stdout: TRUE
[17:44:45.499] - signal: TRUE
[17:44:45.499] - resignal: FALSE
[17:44:45.499] - force: TRUE
[17:44:45.499] - relayed: [n=1] FALSE
[17:44:45.499] - queued futures: [n=1] FALSE
[17:44:45.499]  - until=1
[17:44:45.500]  - relaying element #1
[17:44:45.500] - relayed: [n=1] TRUE
[17:44:45.500] - queued futures: [n=1] TRUE
[17:44:45.500] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.500]  length: 0 (resolved future 1)
[17:44:45.500] Relaying remaining futures
[17:44:45.500] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.500] - nx: 1
[17:44:45.500] - relay: TRUE
[17:44:45.501] - stdout: TRUE
[17:44:45.501] - signal: TRUE
[17:44:45.501] - resignal: FALSE
[17:44:45.501] - force: TRUE
[17:44:45.501] - relayed: [n=1] TRUE
[17:44:45.501] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.501] - relayed: [n=1] TRUE
[17:44:45.501] - queued futures: [n=1] TRUE
[17:44:45.501] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.501] resolve() on list ... DONE
[17:44:45.502]  - Number of value chunks collected: 1
[17:44:45.502] Resolving 1 futures (chunks) ... DONE
[17:44:45.502] Reducing values from 1 chunks ...
[17:44:45.502]  - Number of values collected after concatenation: 4
[17:44:45.502]  - Number of values expected: 4
[17:44:45.502] Reducing values from 1 chunks ... DONE
[17:44:45.502] future_mapply() ... DONE
[17:44:45.502] future_mapply() ...
[17:44:45.502] Number of chunks: 1
[17:44:45.502] getGlobalsAndPackagesXApply() ...
[17:44:45.503]  - future.globals: TRUE
[17:44:45.503] getGlobalsAndPackages() ...
[17:44:45.503] Searching for globals...
[17:44:45.504] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:45.504] Searching for globals ... DONE
[17:44:45.504] Resolving globals: FALSE
[17:44:45.505] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:45.505] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:45.505] - globals: [1] ‘FUN’
[17:44:45.505] 
[17:44:45.505] getGlobalsAndPackages() ... DONE
[17:44:45.505]  - globals found/used: [n=1] ‘FUN’
[17:44:45.505]  - needed namespaces: [n=0] 
[17:44:45.506] Finding globals ... DONE
[17:44:45.506] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.506] List of 2
[17:44:45.506]  $ ...future.FUN:function (x, y)  
[17:44:45.506]  $ MoreArgs     : NULL
[17:44:45.506]  - attr(*, "where")=List of 2
[17:44:45.506]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.506]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.506]  - attr(*, "resolved")= logi FALSE
[17:44:45.506]  - attr(*, "total_size")= num NA
[17:44:45.508] Packages to be attached in all futures: [n=0] 
[17:44:45.508] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.509] Number of futures (= number of chunks): 1
[17:44:45.509] Launching 1 futures (chunks) ...
[17:44:45.509] Chunk #1 of 1 ...
[17:44:45.509]  - Finding globals in '...' for chunk #1 ...
[17:44:45.509] getGlobalsAndPackages() ...
[17:44:45.509] Searching for globals...
[17:44:45.509] 
[17:44:45.509] Searching for globals ... DONE
[17:44:45.510] - globals: [0] <none>
[17:44:45.510] getGlobalsAndPackages() ... DONE
[17:44:45.510]    + additional globals found: [n=0] 
[17:44:45.510]    + additional namespaces needed: [n=0] 
[17:44:45.510]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.510]  - seeds: <none>
[17:44:45.510]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.510] getGlobalsAndPackages() ...
[17:44:45.510] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.510] Resolving globals: FALSE
[17:44:45.511] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:44:45.511] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.511] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.512] 
[17:44:45.512] getGlobalsAndPackages() ... DONE
[17:44:45.512] run() for ‘Future’ ...
[17:44:45.512] - state: ‘created’
[17:44:45.512] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.512] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.513]   - Field: ‘label’
[17:44:45.513]   - Field: ‘local’
[17:44:45.513]   - Field: ‘owner’
[17:44:45.513]   - Field: ‘envir’
[17:44:45.513]   - Field: ‘packages’
[17:44:45.513]   - Field: ‘gc’
[17:44:45.513]   - Field: ‘conditions’
[17:44:45.513]   - Field: ‘expr’
[17:44:45.513]   - Field: ‘uuid’
[17:44:45.514]   - Field: ‘seed’
[17:44:45.514]   - Field: ‘version’
[17:44:45.514]   - Field: ‘result’
[17:44:45.514]   - Field: ‘asynchronous’
[17:44:45.514]   - Field: ‘calls’
[17:44:45.514]   - Field: ‘globals’
[17:44:45.514]   - Field: ‘stdout’
[17:44:45.514]   - Field: ‘earlySignal’
[17:44:45.514]   - Field: ‘lazy’
[17:44:45.514]   - Field: ‘state’
[17:44:45.514] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.515] - Launch lazy future ...
[17:44:45.515] Packages needed by the future expression (n = 0): <none>
[17:44:45.515] Packages needed by future strategies (n = 0): <none>
[17:44:45.515] {
[17:44:45.515]     {
[17:44:45.515]         {
[17:44:45.515]             ...future.startTime <- base::Sys.time()
[17:44:45.515]             {
[17:44:45.515]                 {
[17:44:45.515]                   {
[17:44:45.515]                     base::local({
[17:44:45.515]                       has_future <- base::requireNamespace("future", 
[17:44:45.515]                         quietly = TRUE)
[17:44:45.515]                       if (has_future) {
[17:44:45.515]                         ns <- base::getNamespace("future")
[17:44:45.515]                         version <- ns[[".package"]][["version"]]
[17:44:45.515]                         if (is.null(version)) 
[17:44:45.515]                           version <- utils::packageVersion("future")
[17:44:45.515]                       }
[17:44:45.515]                       else {
[17:44:45.515]                         version <- NULL
[17:44:45.515]                       }
[17:44:45.515]                       if (!has_future || version < "1.8.0") {
[17:44:45.515]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.515]                           "", base::R.version$version.string), 
[17:44:45.515]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.515]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.515]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.515]                             "release", "version")], collapse = " "), 
[17:44:45.515]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.515]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.515]                           info)
[17:44:45.515]                         info <- base::paste(info, collapse = "; ")
[17:44:45.515]                         if (!has_future) {
[17:44:45.515]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.515]                             info)
[17:44:45.515]                         }
[17:44:45.515]                         else {
[17:44:45.515]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.515]                             info, version)
[17:44:45.515]                         }
[17:44:45.515]                         base::stop(msg)
[17:44:45.515]                       }
[17:44:45.515]                     })
[17:44:45.515]                   }
[17:44:45.515]                   ...future.strategy.old <- future::plan("list")
[17:44:45.515]                   options(future.plan = NULL)
[17:44:45.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.515]                 }
[17:44:45.515]                 ...future.workdir <- getwd()
[17:44:45.515]             }
[17:44:45.515]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.515]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.515]         }
[17:44:45.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.515]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.515]             base::names(...future.oldOptions))
[17:44:45.515]     }
[17:44:45.515]     if (FALSE) {
[17:44:45.515]     }
[17:44:45.515]     else {
[17:44:45.515]         if (TRUE) {
[17:44:45.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.515]                 open = "w")
[17:44:45.515]         }
[17:44:45.515]         else {
[17:44:45.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.515]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.515]         }
[17:44:45.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.515]             base::sink(type = "output", split = FALSE)
[17:44:45.515]             base::close(...future.stdout)
[17:44:45.515]         }, add = TRUE)
[17:44:45.515]     }
[17:44:45.515]     ...future.frame <- base::sys.nframe()
[17:44:45.515]     ...future.conditions <- base::list()
[17:44:45.515]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.515]     if (FALSE) {
[17:44:45.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.515]     }
[17:44:45.515]     ...future.result <- base::tryCatch({
[17:44:45.515]         base::withCallingHandlers({
[17:44:45.515]             ...future.value <- base::withVisible(base::local({
[17:44:45.515]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.515]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.515]                   ...future.globals.maxSize)) {
[17:44:45.515]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.515]                   on.exit(options(oopts), add = TRUE)
[17:44:45.515]                 }
[17:44:45.515]                 {
[17:44:45.515]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.515]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.515]                     USE.NAMES = FALSE)
[17:44:45.515]                   do.call(mapply, args = args)
[17:44:45.515]                 }
[17:44:45.515]             }))
[17:44:45.515]             future::FutureResult(value = ...future.value$value, 
[17:44:45.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.515]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.515]                     ...future.globalenv.names))
[17:44:45.515]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.515]         }, condition = base::local({
[17:44:45.515]             c <- base::c
[17:44:45.515]             inherits <- base::inherits
[17:44:45.515]             invokeRestart <- base::invokeRestart
[17:44:45.515]             length <- base::length
[17:44:45.515]             list <- base::list
[17:44:45.515]             seq.int <- base::seq.int
[17:44:45.515]             signalCondition <- base::signalCondition
[17:44:45.515]             sys.calls <- base::sys.calls
[17:44:45.515]             `[[` <- base::`[[`
[17:44:45.515]             `+` <- base::`+`
[17:44:45.515]             `<<-` <- base::`<<-`
[17:44:45.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.515]                   3L)]
[17:44:45.515]             }
[17:44:45.515]             function(cond) {
[17:44:45.515]                 is_error <- inherits(cond, "error")
[17:44:45.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.515]                   NULL)
[17:44:45.515]                 if (is_error) {
[17:44:45.515]                   sessionInformation <- function() {
[17:44:45.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.515]                       search = base::search(), system = base::Sys.info())
[17:44:45.515]                   }
[17:44:45.515]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.515]                     cond$call), session = sessionInformation(), 
[17:44:45.515]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.515]                   signalCondition(cond)
[17:44:45.515]                 }
[17:44:45.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.515]                 "immediateCondition"))) {
[17:44:45.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.515]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.515]                   if (TRUE && !signal) {
[17:44:45.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.515]                     {
[17:44:45.515]                       inherits <- base::inherits
[17:44:45.515]                       invokeRestart <- base::invokeRestart
[17:44:45.515]                       is.null <- base::is.null
[17:44:45.515]                       muffled <- FALSE
[17:44:45.515]                       if (inherits(cond, "message")) {
[17:44:45.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.515]                         if (muffled) 
[17:44:45.515]                           invokeRestart("muffleMessage")
[17:44:45.515]                       }
[17:44:45.515]                       else if (inherits(cond, "warning")) {
[17:44:45.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.515]                         if (muffled) 
[17:44:45.515]                           invokeRestart("muffleWarning")
[17:44:45.515]                       }
[17:44:45.515]                       else if (inherits(cond, "condition")) {
[17:44:45.515]                         if (!is.null(pattern)) {
[17:44:45.515]                           computeRestarts <- base::computeRestarts
[17:44:45.515]                           grepl <- base::grepl
[17:44:45.515]                           restarts <- computeRestarts(cond)
[17:44:45.515]                           for (restart in restarts) {
[17:44:45.515]                             name <- restart$name
[17:44:45.515]                             if (is.null(name)) 
[17:44:45.515]                               next
[17:44:45.515]                             if (!grepl(pattern, name)) 
[17:44:45.515]                               next
[17:44:45.515]                             invokeRestart(restart)
[17:44:45.515]                             muffled <- TRUE
[17:44:45.515]                             break
[17:44:45.515]                           }
[17:44:45.515]                         }
[17:44:45.515]                       }
[17:44:45.515]                       invisible(muffled)
[17:44:45.515]                     }
[17:44:45.515]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.515]                   }
[17:44:45.515]                 }
[17:44:45.515]                 else {
[17:44:45.515]                   if (TRUE) {
[17:44:45.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.515]                     {
[17:44:45.515]                       inherits <- base::inherits
[17:44:45.515]                       invokeRestart <- base::invokeRestart
[17:44:45.515]                       is.null <- base::is.null
[17:44:45.515]                       muffled <- FALSE
[17:44:45.515]                       if (inherits(cond, "message")) {
[17:44:45.515]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.515]                         if (muffled) 
[17:44:45.515]                           invokeRestart("muffleMessage")
[17:44:45.515]                       }
[17:44:45.515]                       else if (inherits(cond, "warning")) {
[17:44:45.515]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.515]                         if (muffled) 
[17:44:45.515]                           invokeRestart("muffleWarning")
[17:44:45.515]                       }
[17:44:45.515]                       else if (inherits(cond, "condition")) {
[17:44:45.515]                         if (!is.null(pattern)) {
[17:44:45.515]                           computeRestarts <- base::computeRestarts
[17:44:45.515]                           grepl <- base::grepl
[17:44:45.515]                           restarts <- computeRestarts(cond)
[17:44:45.515]                           for (restart in restarts) {
[17:44:45.515]                             name <- restart$name
[17:44:45.515]                             if (is.null(name)) 
[17:44:45.515]                               next
[17:44:45.515]                             if (!grepl(pattern, name)) 
[17:44:45.515]                               next
[17:44:45.515]                             invokeRestart(restart)
[17:44:45.515]                             muffled <- TRUE
[17:44:45.515]                             break
[17:44:45.515]                           }
[17:44:45.515]                         }
[17:44:45.515]                       }
[17:44:45.515]                       invisible(muffled)
[17:44:45.515]                     }
[17:44:45.515]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.515]                   }
[17:44:45.515]                 }
[17:44:45.515]             }
[17:44:45.515]         }))
[17:44:45.515]     }, error = function(ex) {
[17:44:45.515]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.515]                 ...future.rng), started = ...future.startTime, 
[17:44:45.515]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.515]             version = "1.8"), class = "FutureResult")
[17:44:45.515]     }, finally = {
[17:44:45.515]         if (!identical(...future.workdir, getwd())) 
[17:44:45.515]             setwd(...future.workdir)
[17:44:45.515]         {
[17:44:45.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.515]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.515]             }
[17:44:45.515]             base::options(...future.oldOptions)
[17:44:45.515]             if (.Platform$OS.type == "windows") {
[17:44:45.515]                 old_names <- names(...future.oldEnvVars)
[17:44:45.515]                 envs <- base::Sys.getenv()
[17:44:45.515]                 names <- names(envs)
[17:44:45.515]                 common <- intersect(names, old_names)
[17:44:45.515]                 added <- setdiff(names, old_names)
[17:44:45.515]                 removed <- setdiff(old_names, names)
[17:44:45.515]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.515]                   envs[common]]
[17:44:45.515]                 NAMES <- toupper(changed)
[17:44:45.515]                 args <- list()
[17:44:45.515]                 for (kk in seq_along(NAMES)) {
[17:44:45.515]                   name <- changed[[kk]]
[17:44:45.515]                   NAME <- NAMES[[kk]]
[17:44:45.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.515]                     next
[17:44:45.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.515]                 }
[17:44:45.515]                 NAMES <- toupper(added)
[17:44:45.515]                 for (kk in seq_along(NAMES)) {
[17:44:45.515]                   name <- added[[kk]]
[17:44:45.515]                   NAME <- NAMES[[kk]]
[17:44:45.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.515]                     next
[17:44:45.515]                   args[[name]] <- ""
[17:44:45.515]                 }
[17:44:45.515]                 NAMES <- toupper(removed)
[17:44:45.515]                 for (kk in seq_along(NAMES)) {
[17:44:45.515]                   name <- removed[[kk]]
[17:44:45.515]                   NAME <- NAMES[[kk]]
[17:44:45.515]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.515]                     next
[17:44:45.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.515]                 }
[17:44:45.515]                 if (length(args) > 0) 
[17:44:45.515]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.515]             }
[17:44:45.515]             else {
[17:44:45.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.515]             }
[17:44:45.515]             {
[17:44:45.515]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.515]                   0L) {
[17:44:45.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.515]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.515]                   base::options(opts)
[17:44:45.515]                 }
[17:44:45.515]                 {
[17:44:45.515]                   {
[17:44:45.515]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.515]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.515]                     -484569582L), envir = base::globalenv(), 
[17:44:45.515]                       inherits = FALSE)
[17:44:45.515]                     NULL
[17:44:45.515]                   }
[17:44:45.515]                   options(future.plan = NULL)
[17:44:45.515]                   if (is.na(NA_character_)) 
[17:44:45.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.515]                     .init = FALSE)
[17:44:45.515]                 }
[17:44:45.515]             }
[17:44:45.515]         }
[17:44:45.515]     })
[17:44:45.515]     if (TRUE) {
[17:44:45.515]         base::sink(type = "output", split = FALSE)
[17:44:45.515]         if (TRUE) {
[17:44:45.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.515]         }
[17:44:45.515]         else {
[17:44:45.515]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.515]         }
[17:44:45.515]         base::close(...future.stdout)
[17:44:45.515]         ...future.stdout <- NULL
[17:44:45.515]     }
[17:44:45.515]     ...future.result$conditions <- ...future.conditions
[17:44:45.515]     ...future.result$finished <- base::Sys.time()
[17:44:45.515]     ...future.result
[17:44:45.515] }
[17:44:45.517] assign_globals() ...
[17:44:45.517] List of 5
[17:44:45.517]  $ ...future.FUN            :function (x, y)  
[17:44:45.517]  $ MoreArgs                 : NULL
[17:44:45.517]  $ ...future.elements_ii    :List of 2
[17:44:45.517]   ..$ :List of 3
[17:44:45.517]   .. ..$ a: num 1
[17:44:45.517]   .. ..$ b: num 2
[17:44:45.517]   .. ..$ c: num 3
[17:44:45.517]   ..$ :List of 3
[17:44:45.517]   .. ..$ A: num 10
[17:44:45.517]   .. ..$ B: num 0
[17:44:45.517]   .. ..$ C: num -10
[17:44:45.517]  $ ...future.seeds_ii       : NULL
[17:44:45.517]  $ ...future.globals.maxSize: NULL
[17:44:45.517]  - attr(*, "where")=List of 5
[17:44:45.517]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.517]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.517]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.517]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.517]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.517]  - attr(*, "resolved")= logi FALSE
[17:44:45.517]  - attr(*, "total_size")= num 2312
[17:44:45.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.517]  - attr(*, "already-done")= logi TRUE
[17:44:45.525] - reassign environment for ‘...future.FUN’
[17:44:45.525] - copied ‘...future.FUN’ to environment
[17:44:45.525] - copied ‘MoreArgs’ to environment
[17:44:45.525] - copied ‘...future.elements_ii’ to environment
[17:44:45.525] - copied ‘...future.seeds_ii’ to environment
[17:44:45.525] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.525] assign_globals() ... done
[17:44:45.526] plan(): Setting new future strategy stack:
[17:44:45.526] List of future strategies:
[17:44:45.526] 1. sequential:
[17:44:45.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.526]    - tweaked: FALSE
[17:44:45.526]    - call: NULL
[17:44:45.526] plan(): nbrOfWorkers() = 1
[17:44:45.527] plan(): Setting new future strategy stack:
[17:44:45.527] List of future strategies:
[17:44:45.527] 1. sequential:
[17:44:45.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.527]    - tweaked: FALSE
[17:44:45.527]    - call: plan(strategy)
[17:44:45.528] plan(): nbrOfWorkers() = 1
[17:44:45.528] SequentialFuture started (and completed)
[17:44:45.528] - Launch lazy future ... done
[17:44:45.528] run() for ‘SequentialFuture’ ... done
[17:44:45.528] Created future:
[17:44:45.528] SequentialFuture:
[17:44:45.528] Label: ‘future_mapply-1’
[17:44:45.528] Expression:
[17:44:45.528] {
[17:44:45.528]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.528]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.528]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.528]         on.exit(options(oopts), add = TRUE)
[17:44:45.528]     }
[17:44:45.528]     {
[17:44:45.528]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.528]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.528]         do.call(mapply, args = args)
[17:44:45.528]     }
[17:44:45.528] }
[17:44:45.528] Lazy evaluation: FALSE
[17:44:45.528] Asynchronous evaluation: FALSE
[17:44:45.528] Local evaluation: TRUE
[17:44:45.528] Environment: R_GlobalEnv
[17:44:45.528] Capture standard output: TRUE
[17:44:45.528] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.528] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.528] Packages: <none>
[17:44:45.528] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.528] Resolved: TRUE
[17:44:45.528] Value: 200 bytes of class ‘list’
[17:44:45.528] Early signaling: FALSE
[17:44:45.528] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.528] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.529] Chunk #1 of 1 ... DONE
[17:44:45.529] Launching 1 futures (chunks) ... DONE
[17:44:45.529] Resolving 1 futures (chunks) ...
[17:44:45.529] resolve() on list ...
[17:44:45.529]  recursive: 0
[17:44:45.529]  length: 1
[17:44:45.530] 
[17:44:45.530] resolved() for ‘SequentialFuture’ ...
[17:44:45.530] - state: ‘finished’
[17:44:45.530] - run: TRUE
[17:44:45.530] - result: ‘FutureResult’
[17:44:45.530] resolved() for ‘SequentialFuture’ ... done
[17:44:45.530] Future #1
[17:44:45.530] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.530] - nx: 1
[17:44:45.530] - relay: TRUE
[17:44:45.531] - stdout: TRUE
[17:44:45.531] - signal: TRUE
[17:44:45.531] - resignal: FALSE
[17:44:45.531] - force: TRUE
[17:44:45.531] - relayed: [n=1] FALSE
[17:44:45.531] - queued futures: [n=1] FALSE
[17:44:45.531]  - until=1
[17:44:45.531]  - relaying element #1
[17:44:45.531] - relayed: [n=1] TRUE
[17:44:45.531] - queued futures: [n=1] TRUE
[17:44:45.531] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.532]  length: 0 (resolved future 1)
[17:44:45.532] Relaying remaining futures
[17:44:45.532] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.532] - nx: 1
[17:44:45.532] - relay: TRUE
[17:44:45.532] - stdout: TRUE
[17:44:45.532] - signal: TRUE
[17:44:45.532] - resignal: FALSE
[17:44:45.532] - force: TRUE
[17:44:45.532] - relayed: [n=1] TRUE
[17:44:45.532] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.533] - relayed: [n=1] TRUE
[17:44:45.533] - queued futures: [n=1] TRUE
[17:44:45.533] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.533] resolve() on list ... DONE
[17:44:45.533]  - Number of value chunks collected: 1
[17:44:45.533] Resolving 1 futures (chunks) ... DONE
[17:44:45.533] Reducing values from 1 chunks ...
[17:44:45.533]  - Number of values collected after concatenation: 3
[17:44:45.533]  - Number of values expected: 3
[17:44:45.533] Reducing values from 1 chunks ... DONE
[17:44:45.533] future_mapply() ... DONE
- future_.mapply()
[17:44:45.534] future_mapply() ...
[17:44:45.534] Number of chunks: 1
[17:44:45.534] getGlobalsAndPackagesXApply() ...
[17:44:45.535]  - future.globals: TRUE
[17:44:45.535] getGlobalsAndPackages() ...
[17:44:45.535] Searching for globals...
[17:44:45.536] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:45.536] Searching for globals ... DONE
[17:44:45.536] Resolving globals: FALSE
[17:44:45.537] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:45.537] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:45.537] - globals: [1] ‘FUN’
[17:44:45.537] 
[17:44:45.537] getGlobalsAndPackages() ... DONE
[17:44:45.537]  - globals found/used: [n=1] ‘FUN’
[17:44:45.537]  - needed namespaces: [n=0] 
[17:44:45.537] Finding globals ... DONE
[17:44:45.538] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.538] List of 2
[17:44:45.538]  $ ...future.FUN:function (x, y)  
[17:44:45.538]  $ MoreArgs     : list()
[17:44:45.538]  - attr(*, "where")=List of 2
[17:44:45.538]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.538]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.538]  - attr(*, "resolved")= logi FALSE
[17:44:45.538]  - attr(*, "total_size")= num NA
[17:44:45.540] Packages to be attached in all futures: [n=0] 
[17:44:45.540] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.540] Number of futures (= number of chunks): 1
[17:44:45.541] Launching 1 futures (chunks) ...
[17:44:45.541] Chunk #1 of 1 ...
[17:44:45.541]  - Finding globals in '...' for chunk #1 ...
[17:44:45.541] getGlobalsAndPackages() ...
[17:44:45.541] Searching for globals...
[17:44:45.541] 
[17:44:45.541] Searching for globals ... DONE
[17:44:45.541] - globals: [0] <none>
[17:44:45.542] getGlobalsAndPackages() ... DONE
[17:44:45.542]    + additional globals found: [n=0] 
[17:44:45.542]    + additional namespaces needed: [n=0] 
[17:44:45.542]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.542]  - seeds: <none>
[17:44:45.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.542] getGlobalsAndPackages() ...
[17:44:45.542] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.542] Resolving globals: FALSE
[17:44:45.543] The total size of the 5 globals is 2.26 KiB (2312 bytes)
[17:44:45.543] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:45.543] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.543] 
[17:44:45.543] getGlobalsAndPackages() ... DONE
[17:44:45.544] run() for ‘Future’ ...
[17:44:45.544] - state: ‘created’
[17:44:45.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.544]   - Field: ‘label’
[17:44:45.545]   - Field: ‘local’
[17:44:45.545]   - Field: ‘owner’
[17:44:45.545]   - Field: ‘envir’
[17:44:45.545]   - Field: ‘packages’
[17:44:45.545]   - Field: ‘gc’
[17:44:45.545]   - Field: ‘conditions’
[17:44:45.545]   - Field: ‘expr’
[17:44:45.545]   - Field: ‘uuid’
[17:44:45.545]   - Field: ‘seed’
[17:44:45.545]   - Field: ‘version’
[17:44:45.545]   - Field: ‘result’
[17:44:45.546]   - Field: ‘asynchronous’
[17:44:45.546]   - Field: ‘calls’
[17:44:45.546]   - Field: ‘globals’
[17:44:45.546]   - Field: ‘stdout’
[17:44:45.546]   - Field: ‘earlySignal’
[17:44:45.546]   - Field: ‘lazy’
[17:44:45.546]   - Field: ‘state’
[17:44:45.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.546] - Launch lazy future ...
[17:44:45.546] Packages needed by the future expression (n = 0): <none>
[17:44:45.547] Packages needed by future strategies (n = 0): <none>
[17:44:45.547] {
[17:44:45.547]     {
[17:44:45.547]         {
[17:44:45.547]             ...future.startTime <- base::Sys.time()
[17:44:45.547]             {
[17:44:45.547]                 {
[17:44:45.547]                   {
[17:44:45.547]                     base::local({
[17:44:45.547]                       has_future <- base::requireNamespace("future", 
[17:44:45.547]                         quietly = TRUE)
[17:44:45.547]                       if (has_future) {
[17:44:45.547]                         ns <- base::getNamespace("future")
[17:44:45.547]                         version <- ns[[".package"]][["version"]]
[17:44:45.547]                         if (is.null(version)) 
[17:44:45.547]                           version <- utils::packageVersion("future")
[17:44:45.547]                       }
[17:44:45.547]                       else {
[17:44:45.547]                         version <- NULL
[17:44:45.547]                       }
[17:44:45.547]                       if (!has_future || version < "1.8.0") {
[17:44:45.547]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.547]                           "", base::R.version$version.string), 
[17:44:45.547]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.547]                             "release", "version")], collapse = " "), 
[17:44:45.547]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.547]                           info)
[17:44:45.547]                         info <- base::paste(info, collapse = "; ")
[17:44:45.547]                         if (!has_future) {
[17:44:45.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.547]                             info)
[17:44:45.547]                         }
[17:44:45.547]                         else {
[17:44:45.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.547]                             info, version)
[17:44:45.547]                         }
[17:44:45.547]                         base::stop(msg)
[17:44:45.547]                       }
[17:44:45.547]                     })
[17:44:45.547]                   }
[17:44:45.547]                   ...future.strategy.old <- future::plan("list")
[17:44:45.547]                   options(future.plan = NULL)
[17:44:45.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.547]                 }
[17:44:45.547]                 ...future.workdir <- getwd()
[17:44:45.547]             }
[17:44:45.547]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.547]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.547]         }
[17:44:45.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.547]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.547]             base::names(...future.oldOptions))
[17:44:45.547]     }
[17:44:45.547]     if (FALSE) {
[17:44:45.547]     }
[17:44:45.547]     else {
[17:44:45.547]         if (TRUE) {
[17:44:45.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.547]                 open = "w")
[17:44:45.547]         }
[17:44:45.547]         else {
[17:44:45.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.547]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.547]         }
[17:44:45.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.547]             base::sink(type = "output", split = FALSE)
[17:44:45.547]             base::close(...future.stdout)
[17:44:45.547]         }, add = TRUE)
[17:44:45.547]     }
[17:44:45.547]     ...future.frame <- base::sys.nframe()
[17:44:45.547]     ...future.conditions <- base::list()
[17:44:45.547]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.547]     if (FALSE) {
[17:44:45.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.547]     }
[17:44:45.547]     ...future.result <- base::tryCatch({
[17:44:45.547]         base::withCallingHandlers({
[17:44:45.547]             ...future.value <- base::withVisible(base::local({
[17:44:45.547]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.547]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.547]                   ...future.globals.maxSize)) {
[17:44:45.547]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.547]                   on.exit(options(oopts), add = TRUE)
[17:44:45.547]                 }
[17:44:45.547]                 {
[17:44:45.547]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.547]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.547]                     USE.NAMES = FALSE)
[17:44:45.547]                   do.call(mapply, args = args)
[17:44:45.547]                 }
[17:44:45.547]             }))
[17:44:45.547]             future::FutureResult(value = ...future.value$value, 
[17:44:45.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.547]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.547]                     ...future.globalenv.names))
[17:44:45.547]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.547]         }, condition = base::local({
[17:44:45.547]             c <- base::c
[17:44:45.547]             inherits <- base::inherits
[17:44:45.547]             invokeRestart <- base::invokeRestart
[17:44:45.547]             length <- base::length
[17:44:45.547]             list <- base::list
[17:44:45.547]             seq.int <- base::seq.int
[17:44:45.547]             signalCondition <- base::signalCondition
[17:44:45.547]             sys.calls <- base::sys.calls
[17:44:45.547]             `[[` <- base::`[[`
[17:44:45.547]             `+` <- base::`+`
[17:44:45.547]             `<<-` <- base::`<<-`
[17:44:45.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.547]                   3L)]
[17:44:45.547]             }
[17:44:45.547]             function(cond) {
[17:44:45.547]                 is_error <- inherits(cond, "error")
[17:44:45.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.547]                   NULL)
[17:44:45.547]                 if (is_error) {
[17:44:45.547]                   sessionInformation <- function() {
[17:44:45.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.547]                       search = base::search(), system = base::Sys.info())
[17:44:45.547]                   }
[17:44:45.547]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.547]                     cond$call), session = sessionInformation(), 
[17:44:45.547]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.547]                   signalCondition(cond)
[17:44:45.547]                 }
[17:44:45.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.547]                 "immediateCondition"))) {
[17:44:45.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.547]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.547]                   if (TRUE && !signal) {
[17:44:45.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.547]                     {
[17:44:45.547]                       inherits <- base::inherits
[17:44:45.547]                       invokeRestart <- base::invokeRestart
[17:44:45.547]                       is.null <- base::is.null
[17:44:45.547]                       muffled <- FALSE
[17:44:45.547]                       if (inherits(cond, "message")) {
[17:44:45.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.547]                         if (muffled) 
[17:44:45.547]                           invokeRestart("muffleMessage")
[17:44:45.547]                       }
[17:44:45.547]                       else if (inherits(cond, "warning")) {
[17:44:45.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.547]                         if (muffled) 
[17:44:45.547]                           invokeRestart("muffleWarning")
[17:44:45.547]                       }
[17:44:45.547]                       else if (inherits(cond, "condition")) {
[17:44:45.547]                         if (!is.null(pattern)) {
[17:44:45.547]                           computeRestarts <- base::computeRestarts
[17:44:45.547]                           grepl <- base::grepl
[17:44:45.547]                           restarts <- computeRestarts(cond)
[17:44:45.547]                           for (restart in restarts) {
[17:44:45.547]                             name <- restart$name
[17:44:45.547]                             if (is.null(name)) 
[17:44:45.547]                               next
[17:44:45.547]                             if (!grepl(pattern, name)) 
[17:44:45.547]                               next
[17:44:45.547]                             invokeRestart(restart)
[17:44:45.547]                             muffled <- TRUE
[17:44:45.547]                             break
[17:44:45.547]                           }
[17:44:45.547]                         }
[17:44:45.547]                       }
[17:44:45.547]                       invisible(muffled)
[17:44:45.547]                     }
[17:44:45.547]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.547]                   }
[17:44:45.547]                 }
[17:44:45.547]                 else {
[17:44:45.547]                   if (TRUE) {
[17:44:45.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.547]                     {
[17:44:45.547]                       inherits <- base::inherits
[17:44:45.547]                       invokeRestart <- base::invokeRestart
[17:44:45.547]                       is.null <- base::is.null
[17:44:45.547]                       muffled <- FALSE
[17:44:45.547]                       if (inherits(cond, "message")) {
[17:44:45.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.547]                         if (muffled) 
[17:44:45.547]                           invokeRestart("muffleMessage")
[17:44:45.547]                       }
[17:44:45.547]                       else if (inherits(cond, "warning")) {
[17:44:45.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.547]                         if (muffled) 
[17:44:45.547]                           invokeRestart("muffleWarning")
[17:44:45.547]                       }
[17:44:45.547]                       else if (inherits(cond, "condition")) {
[17:44:45.547]                         if (!is.null(pattern)) {
[17:44:45.547]                           computeRestarts <- base::computeRestarts
[17:44:45.547]                           grepl <- base::grepl
[17:44:45.547]                           restarts <- computeRestarts(cond)
[17:44:45.547]                           for (restart in restarts) {
[17:44:45.547]                             name <- restart$name
[17:44:45.547]                             if (is.null(name)) 
[17:44:45.547]                               next
[17:44:45.547]                             if (!grepl(pattern, name)) 
[17:44:45.547]                               next
[17:44:45.547]                             invokeRestart(restart)
[17:44:45.547]                             muffled <- TRUE
[17:44:45.547]                             break
[17:44:45.547]                           }
[17:44:45.547]                         }
[17:44:45.547]                       }
[17:44:45.547]                       invisible(muffled)
[17:44:45.547]                     }
[17:44:45.547]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.547]                   }
[17:44:45.547]                 }
[17:44:45.547]             }
[17:44:45.547]         }))
[17:44:45.547]     }, error = function(ex) {
[17:44:45.547]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.547]                 ...future.rng), started = ...future.startTime, 
[17:44:45.547]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.547]             version = "1.8"), class = "FutureResult")
[17:44:45.547]     }, finally = {
[17:44:45.547]         if (!identical(...future.workdir, getwd())) 
[17:44:45.547]             setwd(...future.workdir)
[17:44:45.547]         {
[17:44:45.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.547]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.547]             }
[17:44:45.547]             base::options(...future.oldOptions)
[17:44:45.547]             if (.Platform$OS.type == "windows") {
[17:44:45.547]                 old_names <- names(...future.oldEnvVars)
[17:44:45.547]                 envs <- base::Sys.getenv()
[17:44:45.547]                 names <- names(envs)
[17:44:45.547]                 common <- intersect(names, old_names)
[17:44:45.547]                 added <- setdiff(names, old_names)
[17:44:45.547]                 removed <- setdiff(old_names, names)
[17:44:45.547]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.547]                   envs[common]]
[17:44:45.547]                 NAMES <- toupper(changed)
[17:44:45.547]                 args <- list()
[17:44:45.547]                 for (kk in seq_along(NAMES)) {
[17:44:45.547]                   name <- changed[[kk]]
[17:44:45.547]                   NAME <- NAMES[[kk]]
[17:44:45.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.547]                     next
[17:44:45.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.547]                 }
[17:44:45.547]                 NAMES <- toupper(added)
[17:44:45.547]                 for (kk in seq_along(NAMES)) {
[17:44:45.547]                   name <- added[[kk]]
[17:44:45.547]                   NAME <- NAMES[[kk]]
[17:44:45.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.547]                     next
[17:44:45.547]                   args[[name]] <- ""
[17:44:45.547]                 }
[17:44:45.547]                 NAMES <- toupper(removed)
[17:44:45.547]                 for (kk in seq_along(NAMES)) {
[17:44:45.547]                   name <- removed[[kk]]
[17:44:45.547]                   NAME <- NAMES[[kk]]
[17:44:45.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.547]                     next
[17:44:45.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.547]                 }
[17:44:45.547]                 if (length(args) > 0) 
[17:44:45.547]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.547]             }
[17:44:45.547]             else {
[17:44:45.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.547]             }
[17:44:45.547]             {
[17:44:45.547]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.547]                   0L) {
[17:44:45.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.547]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.547]                   base::options(opts)
[17:44:45.547]                 }
[17:44:45.547]                 {
[17:44:45.547]                   {
[17:44:45.547]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.547]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.547]                     -484569582L), envir = base::globalenv(), 
[17:44:45.547]                       inherits = FALSE)
[17:44:45.547]                     NULL
[17:44:45.547]                   }
[17:44:45.547]                   options(future.plan = NULL)
[17:44:45.547]                   if (is.na(NA_character_)) 
[17:44:45.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.547]                     .init = FALSE)
[17:44:45.547]                 }
[17:44:45.547]             }
[17:44:45.547]         }
[17:44:45.547]     })
[17:44:45.547]     if (TRUE) {
[17:44:45.547]         base::sink(type = "output", split = FALSE)
[17:44:45.547]         if (TRUE) {
[17:44:45.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.547]         }
[17:44:45.547]         else {
[17:44:45.547]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.547]         }
[17:44:45.547]         base::close(...future.stdout)
[17:44:45.547]         ...future.stdout <- NULL
[17:44:45.547]     }
[17:44:45.547]     ...future.result$conditions <- ...future.conditions
[17:44:45.547]     ...future.result$finished <- base::Sys.time()
[17:44:45.547]     ...future.result
[17:44:45.547] }
[17:44:45.549] assign_globals() ...
[17:44:45.549] List of 5
[17:44:45.549]  $ ...future.FUN            :function (x, y)  
[17:44:45.549]  $ MoreArgs                 : list()
[17:44:45.549]  $ ...future.elements_ii    :List of 2
[17:44:45.549]   ..$ :List of 3
[17:44:45.549]   .. ..$ a: num 1
[17:44:45.549]   .. ..$ b: num 2
[17:44:45.549]   .. ..$ c: num 3
[17:44:45.549]   ..$ :List of 3
[17:44:45.549]   .. ..$ A: num 10
[17:44:45.549]   .. ..$ B: num 0
[17:44:45.549]   .. ..$ C: num -10
[17:44:45.549]  $ ...future.seeds_ii       : NULL
[17:44:45.549]  $ ...future.globals.maxSize: NULL
[17:44:45.549]  - attr(*, "where")=List of 5
[17:44:45.549]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.549]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.549]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.549]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.549]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.549]  - attr(*, "resolved")= logi FALSE
[17:44:45.549]  - attr(*, "total_size")= num 2312
[17:44:45.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.549]  - attr(*, "already-done")= logi TRUE
[17:44:45.557] - reassign environment for ‘...future.FUN’
[17:44:45.557] - copied ‘...future.FUN’ to environment
[17:44:45.557] - copied ‘MoreArgs’ to environment
[17:44:45.557] - copied ‘...future.elements_ii’ to environment
[17:44:45.557] - copied ‘...future.seeds_ii’ to environment
[17:44:45.558] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.558] assign_globals() ... done
[17:44:45.558] plan(): Setting new future strategy stack:
[17:44:45.558] List of future strategies:
[17:44:45.558] 1. sequential:
[17:44:45.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.558]    - tweaked: FALSE
[17:44:45.558]    - call: NULL
[17:44:45.558] plan(): nbrOfWorkers() = 1
[17:44:45.559] plan(): Setting new future strategy stack:
[17:44:45.559] List of future strategies:
[17:44:45.559] 1. sequential:
[17:44:45.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.559]    - tweaked: FALSE
[17:44:45.559]    - call: plan(strategy)
[17:44:45.560] plan(): nbrOfWorkers() = 1
[17:44:45.560] SequentialFuture started (and completed)
[17:44:45.560] - Launch lazy future ... done
[17:44:45.560] run() for ‘SequentialFuture’ ... done
[17:44:45.560] Created future:
[17:44:45.560] SequentialFuture:
[17:44:45.560] Label: ‘future_.mapply-1’
[17:44:45.560] Expression:
[17:44:45.560] {
[17:44:45.560]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.560]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.560]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.560]         on.exit(options(oopts), add = TRUE)
[17:44:45.560]     }
[17:44:45.560]     {
[17:44:45.560]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.560]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.560]         do.call(mapply, args = args)
[17:44:45.560]     }
[17:44:45.560] }
[17:44:45.560] Lazy evaluation: FALSE
[17:44:45.560] Asynchronous evaluation: FALSE
[17:44:45.560] Local evaluation: TRUE
[17:44:45.560] Environment: R_GlobalEnv
[17:44:45.560] Capture standard output: TRUE
[17:44:45.560] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.560] Globals: 5 objects totaling 2.26 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.560] Packages: <none>
[17:44:45.560] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.560] Resolved: TRUE
[17:44:45.560] Value: 200 bytes of class ‘list’
[17:44:45.560] Early signaling: FALSE
[17:44:45.560] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.560] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.561] Chunk #1 of 1 ... DONE
[17:44:45.561] Launching 1 futures (chunks) ... DONE
[17:44:45.561] Resolving 1 futures (chunks) ...
[17:44:45.561] resolve() on list ...
[17:44:45.562]  recursive: 0
[17:44:45.562]  length: 1
[17:44:45.562] 
[17:44:45.562] resolved() for ‘SequentialFuture’ ...
[17:44:45.562] - state: ‘finished’
[17:44:45.562] - run: TRUE
[17:44:45.562] - result: ‘FutureResult’
[17:44:45.562] resolved() for ‘SequentialFuture’ ... done
[17:44:45.562] Future #1
[17:44:45.562] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.563] - nx: 1
[17:44:45.563] - relay: TRUE
[17:44:45.563] - stdout: TRUE
[17:44:45.563] - signal: TRUE
[17:44:45.563] - resignal: FALSE
[17:44:45.563] - force: TRUE
[17:44:45.563] - relayed: [n=1] FALSE
[17:44:45.563] - queued futures: [n=1] FALSE
[17:44:45.563]  - until=1
[17:44:45.563]  - relaying element #1
[17:44:45.564] - relayed: [n=1] TRUE
[17:44:45.564] - queued futures: [n=1] TRUE
[17:44:45.564] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.564]  length: 0 (resolved future 1)
[17:44:45.564] Relaying remaining futures
[17:44:45.564] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.565] - nx: 1
[17:44:45.565] - relay: TRUE
[17:44:45.565] - stdout: TRUE
[17:44:45.565] - signal: TRUE
[17:44:45.565] - resignal: FALSE
[17:44:45.565] - force: TRUE
[17:44:45.565] - relayed: [n=1] TRUE
[17:44:45.565] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.565] - relayed: [n=1] TRUE
[17:44:45.565] - queued futures: [n=1] TRUE
[17:44:45.565] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.566] resolve() on list ... DONE
[17:44:45.566]  - Number of value chunks collected: 1
[17:44:45.566] Resolving 1 futures (chunks) ... DONE
[17:44:45.566] Reducing values from 1 chunks ...
[17:44:45.566]  - Number of values collected after concatenation: 3
[17:44:45.566]  - Number of values expected: 3
[17:44:45.566] Reducing values from 1 chunks ... DONE
[17:44:45.566] future_mapply() ... DONE
[17:44:45.566] future_mapply() ...
[17:44:45.568] Number of chunks: 5
[17:44:45.568] getGlobalsAndPackagesXApply() ...
[17:44:45.568]  - future.globals: TRUE
[17:44:45.569] getGlobalsAndPackages() ...
[17:44:45.569] Searching for globals...
[17:44:45.570] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.570] Searching for globals ... DONE
[17:44:45.570] Resolving globals: FALSE
[17:44:45.570] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.571] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.571] - globals: [1] ‘FUN’
[17:44:45.571] 
[17:44:45.571] getGlobalsAndPackages() ... DONE
[17:44:45.571]  - globals found/used: [n=1] ‘FUN’
[17:44:45.571]  - needed namespaces: [n=0] 
[17:44:45.571] Finding globals ... DONE
[17:44:45.572] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.572] List of 2
[17:44:45.572]  $ ...future.FUN:function (C, k)  
[17:44:45.572]  $ MoreArgs     : NULL
[17:44:45.572]  - attr(*, "where")=List of 2
[17:44:45.572]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.572]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.572]  - attr(*, "resolved")= logi FALSE
[17:44:45.572]  - attr(*, "total_size")= num NA
[17:44:45.574] Packages to be attached in all futures: [n=0] 
[17:44:45.574] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.574] Number of futures (= number of chunks): 5
[17:44:45.575] Launching 5 futures (chunks) ...
[17:44:45.575] Chunk #1 of 5 ...
[17:44:45.575]  - Finding globals in '...' for chunk #1 ...
[17:44:45.575] getGlobalsAndPackages() ...
[17:44:45.575] Searching for globals...
[17:44:45.577] 
[17:44:45.577] Searching for globals ... DONE
[17:44:45.577] - globals: [0] <none>
[17:44:45.577] getGlobalsAndPackages() ... DONE
[17:44:45.577]    + additional globals found: [n=0] 
[17:44:45.577]    + additional namespaces needed: [n=0] 
[17:44:45.578]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.578]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:45.578]  - seeds: <none>
[17:44:45.578]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.578] getGlobalsAndPackages() ...
[17:44:45.578] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.578] Resolving globals: FALSE
[17:44:45.579] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.579] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.579] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.579] 
[17:44:45.579] getGlobalsAndPackages() ... DONE
[17:44:45.580] run() for ‘Future’ ...
[17:44:45.580] - state: ‘created’
[17:44:45.580] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.580] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.580]   - Field: ‘label’
[17:44:45.581]   - Field: ‘local’
[17:44:45.581]   - Field: ‘owner’
[17:44:45.581]   - Field: ‘envir’
[17:44:45.581]   - Field: ‘packages’
[17:44:45.581]   - Field: ‘gc’
[17:44:45.581]   - Field: ‘conditions’
[17:44:45.581]   - Field: ‘expr’
[17:44:45.581]   - Field: ‘uuid’
[17:44:45.581]   - Field: ‘seed’
[17:44:45.581]   - Field: ‘version’
[17:44:45.581]   - Field: ‘result’
[17:44:45.582]   - Field: ‘asynchronous’
[17:44:45.582]   - Field: ‘calls’
[17:44:45.582]   - Field: ‘globals’
[17:44:45.582]   - Field: ‘stdout’
[17:44:45.582]   - Field: ‘earlySignal’
[17:44:45.582]   - Field: ‘lazy’
[17:44:45.582]   - Field: ‘state’
[17:44:45.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.582] - Launch lazy future ...
[17:44:45.582] Packages needed by the future expression (n = 0): <none>
[17:44:45.583] Packages needed by future strategies (n = 0): <none>
[17:44:45.583] {
[17:44:45.583]     {
[17:44:45.583]         {
[17:44:45.583]             ...future.startTime <- base::Sys.time()
[17:44:45.583]             {
[17:44:45.583]                 {
[17:44:45.583]                   {
[17:44:45.583]                     base::local({
[17:44:45.583]                       has_future <- base::requireNamespace("future", 
[17:44:45.583]                         quietly = TRUE)
[17:44:45.583]                       if (has_future) {
[17:44:45.583]                         ns <- base::getNamespace("future")
[17:44:45.583]                         version <- ns[[".package"]][["version"]]
[17:44:45.583]                         if (is.null(version)) 
[17:44:45.583]                           version <- utils::packageVersion("future")
[17:44:45.583]                       }
[17:44:45.583]                       else {
[17:44:45.583]                         version <- NULL
[17:44:45.583]                       }
[17:44:45.583]                       if (!has_future || version < "1.8.0") {
[17:44:45.583]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.583]                           "", base::R.version$version.string), 
[17:44:45.583]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.583]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.583]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.583]                             "release", "version")], collapse = " "), 
[17:44:45.583]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.583]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.583]                           info)
[17:44:45.583]                         info <- base::paste(info, collapse = "; ")
[17:44:45.583]                         if (!has_future) {
[17:44:45.583]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.583]                             info)
[17:44:45.583]                         }
[17:44:45.583]                         else {
[17:44:45.583]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.583]                             info, version)
[17:44:45.583]                         }
[17:44:45.583]                         base::stop(msg)
[17:44:45.583]                       }
[17:44:45.583]                     })
[17:44:45.583]                   }
[17:44:45.583]                   ...future.strategy.old <- future::plan("list")
[17:44:45.583]                   options(future.plan = NULL)
[17:44:45.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.583]                 }
[17:44:45.583]                 ...future.workdir <- getwd()
[17:44:45.583]             }
[17:44:45.583]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.583]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.583]         }
[17:44:45.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.583]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:45.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.583]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.583]             base::names(...future.oldOptions))
[17:44:45.583]     }
[17:44:45.583]     if (FALSE) {
[17:44:45.583]     }
[17:44:45.583]     else {
[17:44:45.583]         if (TRUE) {
[17:44:45.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.583]                 open = "w")
[17:44:45.583]         }
[17:44:45.583]         else {
[17:44:45.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.583]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.583]         }
[17:44:45.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.583]             base::sink(type = "output", split = FALSE)
[17:44:45.583]             base::close(...future.stdout)
[17:44:45.583]         }, add = TRUE)
[17:44:45.583]     }
[17:44:45.583]     ...future.frame <- base::sys.nframe()
[17:44:45.583]     ...future.conditions <- base::list()
[17:44:45.583]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.583]     if (FALSE) {
[17:44:45.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.583]     }
[17:44:45.583]     ...future.result <- base::tryCatch({
[17:44:45.583]         base::withCallingHandlers({
[17:44:45.583]             ...future.value <- base::withVisible(base::local({
[17:44:45.583]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.583]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.583]                   ...future.globals.maxSize)) {
[17:44:45.583]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.583]                   on.exit(options(oopts), add = TRUE)
[17:44:45.583]                 }
[17:44:45.583]                 {
[17:44:45.583]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.583]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.583]                     USE.NAMES = FALSE)
[17:44:45.583]                   do.call(mapply, args = args)
[17:44:45.583]                 }
[17:44:45.583]             }))
[17:44:45.583]             future::FutureResult(value = ...future.value$value, 
[17:44:45.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.583]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.583]                     ...future.globalenv.names))
[17:44:45.583]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.583]         }, condition = base::local({
[17:44:45.583]             c <- base::c
[17:44:45.583]             inherits <- base::inherits
[17:44:45.583]             invokeRestart <- base::invokeRestart
[17:44:45.583]             length <- base::length
[17:44:45.583]             list <- base::list
[17:44:45.583]             seq.int <- base::seq.int
[17:44:45.583]             signalCondition <- base::signalCondition
[17:44:45.583]             sys.calls <- base::sys.calls
[17:44:45.583]             `[[` <- base::`[[`
[17:44:45.583]             `+` <- base::`+`
[17:44:45.583]             `<<-` <- base::`<<-`
[17:44:45.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.583]                   3L)]
[17:44:45.583]             }
[17:44:45.583]             function(cond) {
[17:44:45.583]                 is_error <- inherits(cond, "error")
[17:44:45.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.583]                   NULL)
[17:44:45.583]                 if (is_error) {
[17:44:45.583]                   sessionInformation <- function() {
[17:44:45.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.583]                       search = base::search(), system = base::Sys.info())
[17:44:45.583]                   }
[17:44:45.583]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.583]                     cond$call), session = sessionInformation(), 
[17:44:45.583]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.583]                   signalCondition(cond)
[17:44:45.583]                 }
[17:44:45.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.583]                 "immediateCondition"))) {
[17:44:45.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.583]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.583]                   if (TRUE && !signal) {
[17:44:45.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.583]                     {
[17:44:45.583]                       inherits <- base::inherits
[17:44:45.583]                       invokeRestart <- base::invokeRestart
[17:44:45.583]                       is.null <- base::is.null
[17:44:45.583]                       muffled <- FALSE
[17:44:45.583]                       if (inherits(cond, "message")) {
[17:44:45.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.583]                         if (muffled) 
[17:44:45.583]                           invokeRestart("muffleMessage")
[17:44:45.583]                       }
[17:44:45.583]                       else if (inherits(cond, "warning")) {
[17:44:45.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.583]                         if (muffled) 
[17:44:45.583]                           invokeRestart("muffleWarning")
[17:44:45.583]                       }
[17:44:45.583]                       else if (inherits(cond, "condition")) {
[17:44:45.583]                         if (!is.null(pattern)) {
[17:44:45.583]                           computeRestarts <- base::computeRestarts
[17:44:45.583]                           grepl <- base::grepl
[17:44:45.583]                           restarts <- computeRestarts(cond)
[17:44:45.583]                           for (restart in restarts) {
[17:44:45.583]                             name <- restart$name
[17:44:45.583]                             if (is.null(name)) 
[17:44:45.583]                               next
[17:44:45.583]                             if (!grepl(pattern, name)) 
[17:44:45.583]                               next
[17:44:45.583]                             invokeRestart(restart)
[17:44:45.583]                             muffled <- TRUE
[17:44:45.583]                             break
[17:44:45.583]                           }
[17:44:45.583]                         }
[17:44:45.583]                       }
[17:44:45.583]                       invisible(muffled)
[17:44:45.583]                     }
[17:44:45.583]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.583]                   }
[17:44:45.583]                 }
[17:44:45.583]                 else {
[17:44:45.583]                   if (TRUE) {
[17:44:45.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.583]                     {
[17:44:45.583]                       inherits <- base::inherits
[17:44:45.583]                       invokeRestart <- base::invokeRestart
[17:44:45.583]                       is.null <- base::is.null
[17:44:45.583]                       muffled <- FALSE
[17:44:45.583]                       if (inherits(cond, "message")) {
[17:44:45.583]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.583]                         if (muffled) 
[17:44:45.583]                           invokeRestart("muffleMessage")
[17:44:45.583]                       }
[17:44:45.583]                       else if (inherits(cond, "warning")) {
[17:44:45.583]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.583]                         if (muffled) 
[17:44:45.583]                           invokeRestart("muffleWarning")
[17:44:45.583]                       }
[17:44:45.583]                       else if (inherits(cond, "condition")) {
[17:44:45.583]                         if (!is.null(pattern)) {
[17:44:45.583]                           computeRestarts <- base::computeRestarts
[17:44:45.583]                           grepl <- base::grepl
[17:44:45.583]                           restarts <- computeRestarts(cond)
[17:44:45.583]                           for (restart in restarts) {
[17:44:45.583]                             name <- restart$name
[17:44:45.583]                             if (is.null(name)) 
[17:44:45.583]                               next
[17:44:45.583]                             if (!grepl(pattern, name)) 
[17:44:45.583]                               next
[17:44:45.583]                             invokeRestart(restart)
[17:44:45.583]                             muffled <- TRUE
[17:44:45.583]                             break
[17:44:45.583]                           }
[17:44:45.583]                         }
[17:44:45.583]                       }
[17:44:45.583]                       invisible(muffled)
[17:44:45.583]                     }
[17:44:45.583]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.583]                   }
[17:44:45.583]                 }
[17:44:45.583]             }
[17:44:45.583]         }))
[17:44:45.583]     }, error = function(ex) {
[17:44:45.583]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.583]                 ...future.rng), started = ...future.startTime, 
[17:44:45.583]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.583]             version = "1.8"), class = "FutureResult")
[17:44:45.583]     }, finally = {
[17:44:45.583]         if (!identical(...future.workdir, getwd())) 
[17:44:45.583]             setwd(...future.workdir)
[17:44:45.583]         {
[17:44:45.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.583]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.583]             }
[17:44:45.583]             base::options(...future.oldOptions)
[17:44:45.583]             if (.Platform$OS.type == "windows") {
[17:44:45.583]                 old_names <- names(...future.oldEnvVars)
[17:44:45.583]                 envs <- base::Sys.getenv()
[17:44:45.583]                 names <- names(envs)
[17:44:45.583]                 common <- intersect(names, old_names)
[17:44:45.583]                 added <- setdiff(names, old_names)
[17:44:45.583]                 removed <- setdiff(old_names, names)
[17:44:45.583]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.583]                   envs[common]]
[17:44:45.583]                 NAMES <- toupper(changed)
[17:44:45.583]                 args <- list()
[17:44:45.583]                 for (kk in seq_along(NAMES)) {
[17:44:45.583]                   name <- changed[[kk]]
[17:44:45.583]                   NAME <- NAMES[[kk]]
[17:44:45.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.583]                     next
[17:44:45.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.583]                 }
[17:44:45.583]                 NAMES <- toupper(added)
[17:44:45.583]                 for (kk in seq_along(NAMES)) {
[17:44:45.583]                   name <- added[[kk]]
[17:44:45.583]                   NAME <- NAMES[[kk]]
[17:44:45.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.583]                     next
[17:44:45.583]                   args[[name]] <- ""
[17:44:45.583]                 }
[17:44:45.583]                 NAMES <- toupper(removed)
[17:44:45.583]                 for (kk in seq_along(NAMES)) {
[17:44:45.583]                   name <- removed[[kk]]
[17:44:45.583]                   NAME <- NAMES[[kk]]
[17:44:45.583]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.583]                     next
[17:44:45.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.583]                 }
[17:44:45.583]                 if (length(args) > 0) 
[17:44:45.583]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.583]             }
[17:44:45.583]             else {
[17:44:45.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.583]             }
[17:44:45.583]             {
[17:44:45.583]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.583]                   0L) {
[17:44:45.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.583]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.583]                   base::options(opts)
[17:44:45.583]                 }
[17:44:45.583]                 {
[17:44:45.583]                   {
[17:44:45.583]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.583]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.583]                     -484569582L), envir = base::globalenv(), 
[17:44:45.583]                       inherits = FALSE)
[17:44:45.583]                     NULL
[17:44:45.583]                   }
[17:44:45.583]                   options(future.plan = NULL)
[17:44:45.583]                   if (is.na(NA_character_)) 
[17:44:45.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.583]                     .init = FALSE)
[17:44:45.583]                 }
[17:44:45.583]             }
[17:44:45.583]         }
[17:44:45.583]     })
[17:44:45.583]     if (TRUE) {
[17:44:45.583]         base::sink(type = "output", split = FALSE)
[17:44:45.583]         if (TRUE) {
[17:44:45.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.583]         }
[17:44:45.583]         else {
[17:44:45.583]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.583]         }
[17:44:45.583]         base::close(...future.stdout)
[17:44:45.583]         ...future.stdout <- NULL
[17:44:45.583]     }
[17:44:45.583]     ...future.result$conditions <- ...future.conditions
[17:44:45.583]     ...future.result$finished <- base::Sys.time()
[17:44:45.583]     ...future.result
[17:44:45.583] }
[17:44:45.585] assign_globals() ...
[17:44:45.585] List of 5
[17:44:45.585]  $ ...future.FUN            :function (C, k)  
[17:44:45.585]  $ MoreArgs                 : NULL
[17:44:45.585]  $ ...future.elements_ii    :List of 2
[17:44:45.585]   ..$ :List of 1
[17:44:45.585]   .. ..$ : chr "A"
[17:44:45.585]   ..$ :List of 1
[17:44:45.585]   .. ..$ : int 5
[17:44:45.585]  $ ...future.seeds_ii       : NULL
[17:44:45.585]  $ ...future.globals.maxSize: NULL
[17:44:45.585]  - attr(*, "where")=List of 5
[17:44:45.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.585]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.585]  - attr(*, "resolved")= logi FALSE
[17:44:45.585]  - attr(*, "total_size")= num 3488
[17:44:45.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.585]  - attr(*, "already-done")= logi TRUE
[17:44:45.589] - reassign environment for ‘...future.FUN’
[17:44:45.590] - copied ‘...future.FUN’ to environment
[17:44:45.590] - copied ‘MoreArgs’ to environment
[17:44:45.590] - copied ‘...future.elements_ii’ to environment
[17:44:45.590] - copied ‘...future.seeds_ii’ to environment
[17:44:45.590] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.590] assign_globals() ... done
[17:44:45.590] plan(): Setting new future strategy stack:
[17:44:45.590] List of future strategies:
[17:44:45.590] 1. sequential:
[17:44:45.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.590]    - tweaked: FALSE
[17:44:45.590]    - call: NULL
[17:44:45.591] plan(): nbrOfWorkers() = 1
[17:44:45.591] plan(): Setting new future strategy stack:
[17:44:45.592] List of future strategies:
[17:44:45.592] 1. sequential:
[17:44:45.592]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.592]    - tweaked: FALSE
[17:44:45.592]    - call: plan(strategy)
[17:44:45.592] plan(): nbrOfWorkers() = 1
[17:44:45.592] SequentialFuture started (and completed)
[17:44:45.592] - Launch lazy future ... done
[17:44:45.592] run() for ‘SequentialFuture’ ... done
[17:44:45.593] Created future:
[17:44:45.593] SequentialFuture:
[17:44:45.593] Label: ‘future_mapply-1’
[17:44:45.593] Expression:
[17:44:45.593] {
[17:44:45.593]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.593]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.593]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.593]         on.exit(options(oopts), add = TRUE)
[17:44:45.593]     }
[17:44:45.593]     {
[17:44:45.593]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.593]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.593]         do.call(mapply, args = args)
[17:44:45.593]     }
[17:44:45.593] }
[17:44:45.593] Lazy evaluation: FALSE
[17:44:45.593] Asynchronous evaluation: FALSE
[17:44:45.593] Local evaluation: TRUE
[17:44:45.593] Environment: R_GlobalEnv
[17:44:45.593] Capture standard output: TRUE
[17:44:45.593] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.593] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.593] Packages: <none>
[17:44:45.593] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.593] Resolved: TRUE
[17:44:45.593] Value: 112 bytes of class ‘list’
[17:44:45.593] Early signaling: FALSE
[17:44:45.593] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.593] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.593] Chunk #1 of 5 ... DONE
[17:44:45.594] Chunk #2 of 5 ...
[17:44:45.594]  - Finding globals in '...' for chunk #2 ...
[17:44:45.594] getGlobalsAndPackages() ...
[17:44:45.594] Searching for globals...
[17:44:45.594] 
[17:44:45.594] Searching for globals ... DONE
[17:44:45.594] - globals: [0] <none>
[17:44:45.594] getGlobalsAndPackages() ... DONE
[17:44:45.595]    + additional globals found: [n=0] 
[17:44:45.595]    + additional namespaces needed: [n=0] 
[17:44:45.595]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:45.595]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:45.595]  - seeds: <none>
[17:44:45.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.595] getGlobalsAndPackages() ...
[17:44:45.595] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.595] Resolving globals: FALSE
[17:44:45.596] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.596] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.596] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.596] 
[17:44:45.597] getGlobalsAndPackages() ... DONE
[17:44:45.597] run() for ‘Future’ ...
[17:44:45.597] - state: ‘created’
[17:44:45.597] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.597] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.597]   - Field: ‘label’
[17:44:45.598]   - Field: ‘local’
[17:44:45.598]   - Field: ‘owner’
[17:44:45.598]   - Field: ‘envir’
[17:44:45.598]   - Field: ‘packages’
[17:44:45.598]   - Field: ‘gc’
[17:44:45.598]   - Field: ‘conditions’
[17:44:45.598]   - Field: ‘expr’
[17:44:45.598]   - Field: ‘uuid’
[17:44:45.598]   - Field: ‘seed’
[17:44:45.598]   - Field: ‘version’
[17:44:45.598]   - Field: ‘result’
[17:44:45.599]   - Field: ‘asynchronous’
[17:44:45.599]   - Field: ‘calls’
[17:44:45.599]   - Field: ‘globals’
[17:44:45.599]   - Field: ‘stdout’
[17:44:45.599]   - Field: ‘earlySignal’
[17:44:45.599]   - Field: ‘lazy’
[17:44:45.599]   - Field: ‘state’
[17:44:45.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.599] - Launch lazy future ...
[17:44:45.599] Packages needed by the future expression (n = 0): <none>
[17:44:45.600] Packages needed by future strategies (n = 0): <none>
[17:44:45.600] {
[17:44:45.600]     {
[17:44:45.600]         {
[17:44:45.600]             ...future.startTime <- base::Sys.time()
[17:44:45.600]             {
[17:44:45.600]                 {
[17:44:45.600]                   {
[17:44:45.600]                     base::local({
[17:44:45.600]                       has_future <- base::requireNamespace("future", 
[17:44:45.600]                         quietly = TRUE)
[17:44:45.600]                       if (has_future) {
[17:44:45.600]                         ns <- base::getNamespace("future")
[17:44:45.600]                         version <- ns[[".package"]][["version"]]
[17:44:45.600]                         if (is.null(version)) 
[17:44:45.600]                           version <- utils::packageVersion("future")
[17:44:45.600]                       }
[17:44:45.600]                       else {
[17:44:45.600]                         version <- NULL
[17:44:45.600]                       }
[17:44:45.600]                       if (!has_future || version < "1.8.0") {
[17:44:45.600]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.600]                           "", base::R.version$version.string), 
[17:44:45.600]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.600]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.600]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.600]                             "release", "version")], collapse = " "), 
[17:44:45.600]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.600]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.600]                           info)
[17:44:45.600]                         info <- base::paste(info, collapse = "; ")
[17:44:45.600]                         if (!has_future) {
[17:44:45.600]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.600]                             info)
[17:44:45.600]                         }
[17:44:45.600]                         else {
[17:44:45.600]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.600]                             info, version)
[17:44:45.600]                         }
[17:44:45.600]                         base::stop(msg)
[17:44:45.600]                       }
[17:44:45.600]                     })
[17:44:45.600]                   }
[17:44:45.600]                   ...future.strategy.old <- future::plan("list")
[17:44:45.600]                   options(future.plan = NULL)
[17:44:45.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.600]                 }
[17:44:45.600]                 ...future.workdir <- getwd()
[17:44:45.600]             }
[17:44:45.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.600]         }
[17:44:45.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.600]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:45.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.600]             base::names(...future.oldOptions))
[17:44:45.600]     }
[17:44:45.600]     if (FALSE) {
[17:44:45.600]     }
[17:44:45.600]     else {
[17:44:45.600]         if (TRUE) {
[17:44:45.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.600]                 open = "w")
[17:44:45.600]         }
[17:44:45.600]         else {
[17:44:45.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.600]         }
[17:44:45.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.600]             base::sink(type = "output", split = FALSE)
[17:44:45.600]             base::close(...future.stdout)
[17:44:45.600]         }, add = TRUE)
[17:44:45.600]     }
[17:44:45.600]     ...future.frame <- base::sys.nframe()
[17:44:45.600]     ...future.conditions <- base::list()
[17:44:45.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.600]     if (FALSE) {
[17:44:45.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.600]     }
[17:44:45.600]     ...future.result <- base::tryCatch({
[17:44:45.600]         base::withCallingHandlers({
[17:44:45.600]             ...future.value <- base::withVisible(base::local({
[17:44:45.600]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.600]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.600]                   ...future.globals.maxSize)) {
[17:44:45.600]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.600]                   on.exit(options(oopts), add = TRUE)
[17:44:45.600]                 }
[17:44:45.600]                 {
[17:44:45.600]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.600]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.600]                     USE.NAMES = FALSE)
[17:44:45.600]                   do.call(mapply, args = args)
[17:44:45.600]                 }
[17:44:45.600]             }))
[17:44:45.600]             future::FutureResult(value = ...future.value$value, 
[17:44:45.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.600]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.600]                     ...future.globalenv.names))
[17:44:45.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.600]         }, condition = base::local({
[17:44:45.600]             c <- base::c
[17:44:45.600]             inherits <- base::inherits
[17:44:45.600]             invokeRestart <- base::invokeRestart
[17:44:45.600]             length <- base::length
[17:44:45.600]             list <- base::list
[17:44:45.600]             seq.int <- base::seq.int
[17:44:45.600]             signalCondition <- base::signalCondition
[17:44:45.600]             sys.calls <- base::sys.calls
[17:44:45.600]             `[[` <- base::`[[`
[17:44:45.600]             `+` <- base::`+`
[17:44:45.600]             `<<-` <- base::`<<-`
[17:44:45.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.600]                   3L)]
[17:44:45.600]             }
[17:44:45.600]             function(cond) {
[17:44:45.600]                 is_error <- inherits(cond, "error")
[17:44:45.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.600]                   NULL)
[17:44:45.600]                 if (is_error) {
[17:44:45.600]                   sessionInformation <- function() {
[17:44:45.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.600]                       search = base::search(), system = base::Sys.info())
[17:44:45.600]                   }
[17:44:45.600]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.600]                     cond$call), session = sessionInformation(), 
[17:44:45.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.600]                   signalCondition(cond)
[17:44:45.600]                 }
[17:44:45.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.600]                 "immediateCondition"))) {
[17:44:45.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.600]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.600]                   if (TRUE && !signal) {
[17:44:45.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.600]                     {
[17:44:45.600]                       inherits <- base::inherits
[17:44:45.600]                       invokeRestart <- base::invokeRestart
[17:44:45.600]                       is.null <- base::is.null
[17:44:45.600]                       muffled <- FALSE
[17:44:45.600]                       if (inherits(cond, "message")) {
[17:44:45.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.600]                         if (muffled) 
[17:44:45.600]                           invokeRestart("muffleMessage")
[17:44:45.600]                       }
[17:44:45.600]                       else if (inherits(cond, "warning")) {
[17:44:45.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.600]                         if (muffled) 
[17:44:45.600]                           invokeRestart("muffleWarning")
[17:44:45.600]                       }
[17:44:45.600]                       else if (inherits(cond, "condition")) {
[17:44:45.600]                         if (!is.null(pattern)) {
[17:44:45.600]                           computeRestarts <- base::computeRestarts
[17:44:45.600]                           grepl <- base::grepl
[17:44:45.600]                           restarts <- computeRestarts(cond)
[17:44:45.600]                           for (restart in restarts) {
[17:44:45.600]                             name <- restart$name
[17:44:45.600]                             if (is.null(name)) 
[17:44:45.600]                               next
[17:44:45.600]                             if (!grepl(pattern, name)) 
[17:44:45.600]                               next
[17:44:45.600]                             invokeRestart(restart)
[17:44:45.600]                             muffled <- TRUE
[17:44:45.600]                             break
[17:44:45.600]                           }
[17:44:45.600]                         }
[17:44:45.600]                       }
[17:44:45.600]                       invisible(muffled)
[17:44:45.600]                     }
[17:44:45.600]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.600]                   }
[17:44:45.600]                 }
[17:44:45.600]                 else {
[17:44:45.600]                   if (TRUE) {
[17:44:45.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.600]                     {
[17:44:45.600]                       inherits <- base::inherits
[17:44:45.600]                       invokeRestart <- base::invokeRestart
[17:44:45.600]                       is.null <- base::is.null
[17:44:45.600]                       muffled <- FALSE
[17:44:45.600]                       if (inherits(cond, "message")) {
[17:44:45.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.600]                         if (muffled) 
[17:44:45.600]                           invokeRestart("muffleMessage")
[17:44:45.600]                       }
[17:44:45.600]                       else if (inherits(cond, "warning")) {
[17:44:45.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.600]                         if (muffled) 
[17:44:45.600]                           invokeRestart("muffleWarning")
[17:44:45.600]                       }
[17:44:45.600]                       else if (inherits(cond, "condition")) {
[17:44:45.600]                         if (!is.null(pattern)) {
[17:44:45.600]                           computeRestarts <- base::computeRestarts
[17:44:45.600]                           grepl <- base::grepl
[17:44:45.600]                           restarts <- computeRestarts(cond)
[17:44:45.600]                           for (restart in restarts) {
[17:44:45.600]                             name <- restart$name
[17:44:45.600]                             if (is.null(name)) 
[17:44:45.600]                               next
[17:44:45.600]                             if (!grepl(pattern, name)) 
[17:44:45.600]                               next
[17:44:45.600]                             invokeRestart(restart)
[17:44:45.600]                             muffled <- TRUE
[17:44:45.600]                             break
[17:44:45.600]                           }
[17:44:45.600]                         }
[17:44:45.600]                       }
[17:44:45.600]                       invisible(muffled)
[17:44:45.600]                     }
[17:44:45.600]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.600]                   }
[17:44:45.600]                 }
[17:44:45.600]             }
[17:44:45.600]         }))
[17:44:45.600]     }, error = function(ex) {
[17:44:45.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.600]                 ...future.rng), started = ...future.startTime, 
[17:44:45.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.600]             version = "1.8"), class = "FutureResult")
[17:44:45.600]     }, finally = {
[17:44:45.600]         if (!identical(...future.workdir, getwd())) 
[17:44:45.600]             setwd(...future.workdir)
[17:44:45.600]         {
[17:44:45.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.600]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.600]             }
[17:44:45.600]             base::options(...future.oldOptions)
[17:44:45.600]             if (.Platform$OS.type == "windows") {
[17:44:45.600]                 old_names <- names(...future.oldEnvVars)
[17:44:45.600]                 envs <- base::Sys.getenv()
[17:44:45.600]                 names <- names(envs)
[17:44:45.600]                 common <- intersect(names, old_names)
[17:44:45.600]                 added <- setdiff(names, old_names)
[17:44:45.600]                 removed <- setdiff(old_names, names)
[17:44:45.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.600]                   envs[common]]
[17:44:45.600]                 NAMES <- toupper(changed)
[17:44:45.600]                 args <- list()
[17:44:45.600]                 for (kk in seq_along(NAMES)) {
[17:44:45.600]                   name <- changed[[kk]]
[17:44:45.600]                   NAME <- NAMES[[kk]]
[17:44:45.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.600]                     next
[17:44:45.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.600]                 }
[17:44:45.600]                 NAMES <- toupper(added)
[17:44:45.600]                 for (kk in seq_along(NAMES)) {
[17:44:45.600]                   name <- added[[kk]]
[17:44:45.600]                   NAME <- NAMES[[kk]]
[17:44:45.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.600]                     next
[17:44:45.600]                   args[[name]] <- ""
[17:44:45.600]                 }
[17:44:45.600]                 NAMES <- toupper(removed)
[17:44:45.600]                 for (kk in seq_along(NAMES)) {
[17:44:45.600]                   name <- removed[[kk]]
[17:44:45.600]                   NAME <- NAMES[[kk]]
[17:44:45.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.600]                     next
[17:44:45.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.600]                 }
[17:44:45.600]                 if (length(args) > 0) 
[17:44:45.600]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.600]             }
[17:44:45.600]             else {
[17:44:45.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.600]             }
[17:44:45.600]             {
[17:44:45.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.600]                   0L) {
[17:44:45.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.600]                   base::options(opts)
[17:44:45.600]                 }
[17:44:45.600]                 {
[17:44:45.600]                   {
[17:44:45.600]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.600]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.600]                     -484569582L), envir = base::globalenv(), 
[17:44:45.600]                       inherits = FALSE)
[17:44:45.600]                     NULL
[17:44:45.600]                   }
[17:44:45.600]                   options(future.plan = NULL)
[17:44:45.600]                   if (is.na(NA_character_)) 
[17:44:45.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.600]                     .init = FALSE)
[17:44:45.600]                 }
[17:44:45.600]             }
[17:44:45.600]         }
[17:44:45.600]     })
[17:44:45.600]     if (TRUE) {
[17:44:45.600]         base::sink(type = "output", split = FALSE)
[17:44:45.600]         if (TRUE) {
[17:44:45.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.600]         }
[17:44:45.600]         else {
[17:44:45.600]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.600]         }
[17:44:45.600]         base::close(...future.stdout)
[17:44:45.600]         ...future.stdout <- NULL
[17:44:45.600]     }
[17:44:45.600]     ...future.result$conditions <- ...future.conditions
[17:44:45.600]     ...future.result$finished <- base::Sys.time()
[17:44:45.600]     ...future.result
[17:44:45.600] }
[17:44:45.603] assign_globals() ...
[17:44:45.603] List of 5
[17:44:45.603]  $ ...future.FUN            :function (C, k)  
[17:44:45.603]  $ MoreArgs                 : NULL
[17:44:45.603]  $ ...future.elements_ii    :List of 2
[17:44:45.603]   ..$ :List of 1
[17:44:45.603]   .. ..$ : chr "B"
[17:44:45.603]   ..$ :List of 1
[17:44:45.603]   .. ..$ : int 4
[17:44:45.603]  $ ...future.seeds_ii       : NULL
[17:44:45.603]  $ ...future.globals.maxSize: NULL
[17:44:45.603]  - attr(*, "where")=List of 5
[17:44:45.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.603]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.603]  - attr(*, "resolved")= logi FALSE
[17:44:45.603]  - attr(*, "total_size")= num 3488
[17:44:45.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.603]  - attr(*, "already-done")= logi TRUE
[17:44:45.608] - reassign environment for ‘...future.FUN’
[17:44:45.608] - copied ‘...future.FUN’ to environment
[17:44:45.608] - copied ‘MoreArgs’ to environment
[17:44:45.608] - copied ‘...future.elements_ii’ to environment
[17:44:45.608] - copied ‘...future.seeds_ii’ to environment
[17:44:45.609] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.609] assign_globals() ... done
[17:44:45.609] plan(): Setting new future strategy stack:
[17:44:45.609] List of future strategies:
[17:44:45.609] 1. sequential:
[17:44:45.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.609]    - tweaked: FALSE
[17:44:45.609]    - call: NULL
[17:44:45.609] plan(): nbrOfWorkers() = 1
[17:44:45.610] plan(): Setting new future strategy stack:
[17:44:45.610] List of future strategies:
[17:44:45.610] 1. sequential:
[17:44:45.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.610]    - tweaked: FALSE
[17:44:45.610]    - call: plan(strategy)
[17:44:45.611] plan(): nbrOfWorkers() = 1
[17:44:45.611] SequentialFuture started (and completed)
[17:44:45.611] - Launch lazy future ... done
[17:44:45.611] run() for ‘SequentialFuture’ ... done
[17:44:45.611] Created future:
[17:44:45.611] SequentialFuture:
[17:44:45.611] Label: ‘future_mapply-2’
[17:44:45.611] Expression:
[17:44:45.611] {
[17:44:45.611]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.611]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.611]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.611]         on.exit(options(oopts), add = TRUE)
[17:44:45.611]     }
[17:44:45.611]     {
[17:44:45.611]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.611]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.611]         do.call(mapply, args = args)
[17:44:45.611]     }
[17:44:45.611] }
[17:44:45.611] Lazy evaluation: FALSE
[17:44:45.611] Asynchronous evaluation: FALSE
[17:44:45.611] Local evaluation: TRUE
[17:44:45.611] Environment: R_GlobalEnv
[17:44:45.611] Capture standard output: TRUE
[17:44:45.611] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.611] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.611] Packages: <none>
[17:44:45.611] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.611] Resolved: TRUE
[17:44:45.611] Value: 112 bytes of class ‘list’
[17:44:45.611] Early signaling: FALSE
[17:44:45.611] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.611] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.612] Chunk #2 of 5 ... DONE
[17:44:45.612] Chunk #3 of 5 ...
[17:44:45.612]  - Finding globals in '...' for chunk #3 ...
[17:44:45.612] getGlobalsAndPackages() ...
[17:44:45.612] Searching for globals...
[17:44:45.613] 
[17:44:45.613] Searching for globals ... DONE
[17:44:45.613] - globals: [0] <none>
[17:44:45.613] getGlobalsAndPackages() ... DONE
[17:44:45.613]    + additional globals found: [n=0] 
[17:44:45.613]    + additional namespaces needed: [n=0] 
[17:44:45.613]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:45.613]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:45.613]  - seeds: <none>
[17:44:45.614]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.614] getGlobalsAndPackages() ...
[17:44:45.614] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.614] Resolving globals: FALSE
[17:44:45.614] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.615] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.615] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.615] 
[17:44:45.615] getGlobalsAndPackages() ... DONE
[17:44:45.615] run() for ‘Future’ ...
[17:44:45.615] - state: ‘created’
[17:44:45.615] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.616] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.616]   - Field: ‘label’
[17:44:45.616]   - Field: ‘local’
[17:44:45.616]   - Field: ‘owner’
[17:44:45.616]   - Field: ‘envir’
[17:44:45.616]   - Field: ‘packages’
[17:44:45.616]   - Field: ‘gc’
[17:44:45.616]   - Field: ‘conditions’
[17:44:45.617]   - Field: ‘expr’
[17:44:45.617]   - Field: ‘uuid’
[17:44:45.617]   - Field: ‘seed’
[17:44:45.617]   - Field: ‘version’
[17:44:45.617]   - Field: ‘result’
[17:44:45.617]   - Field: ‘asynchronous’
[17:44:45.617]   - Field: ‘calls’
[17:44:45.617]   - Field: ‘globals’
[17:44:45.617]   - Field: ‘stdout’
[17:44:45.617]   - Field: ‘earlySignal’
[17:44:45.617]   - Field: ‘lazy’
[17:44:45.618]   - Field: ‘state’
[17:44:45.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.618] - Launch lazy future ...
[17:44:45.618] Packages needed by the future expression (n = 0): <none>
[17:44:45.618] Packages needed by future strategies (n = 0): <none>
[17:44:45.618] {
[17:44:45.618]     {
[17:44:45.618]         {
[17:44:45.618]             ...future.startTime <- base::Sys.time()
[17:44:45.618]             {
[17:44:45.618]                 {
[17:44:45.618]                   {
[17:44:45.618]                     base::local({
[17:44:45.618]                       has_future <- base::requireNamespace("future", 
[17:44:45.618]                         quietly = TRUE)
[17:44:45.618]                       if (has_future) {
[17:44:45.618]                         ns <- base::getNamespace("future")
[17:44:45.618]                         version <- ns[[".package"]][["version"]]
[17:44:45.618]                         if (is.null(version)) 
[17:44:45.618]                           version <- utils::packageVersion("future")
[17:44:45.618]                       }
[17:44:45.618]                       else {
[17:44:45.618]                         version <- NULL
[17:44:45.618]                       }
[17:44:45.618]                       if (!has_future || version < "1.8.0") {
[17:44:45.618]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.618]                           "", base::R.version$version.string), 
[17:44:45.618]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.618]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.618]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.618]                             "release", "version")], collapse = " "), 
[17:44:45.618]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.618]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.618]                           info)
[17:44:45.618]                         info <- base::paste(info, collapse = "; ")
[17:44:45.618]                         if (!has_future) {
[17:44:45.618]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.618]                             info)
[17:44:45.618]                         }
[17:44:45.618]                         else {
[17:44:45.618]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.618]                             info, version)
[17:44:45.618]                         }
[17:44:45.618]                         base::stop(msg)
[17:44:45.618]                       }
[17:44:45.618]                     })
[17:44:45.618]                   }
[17:44:45.618]                   ...future.strategy.old <- future::plan("list")
[17:44:45.618]                   options(future.plan = NULL)
[17:44:45.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.618]                 }
[17:44:45.618]                 ...future.workdir <- getwd()
[17:44:45.618]             }
[17:44:45.618]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.618]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.618]         }
[17:44:45.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.618]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:45.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.618]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.618]             base::names(...future.oldOptions))
[17:44:45.618]     }
[17:44:45.618]     if (FALSE) {
[17:44:45.618]     }
[17:44:45.618]     else {
[17:44:45.618]         if (TRUE) {
[17:44:45.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.618]                 open = "w")
[17:44:45.618]         }
[17:44:45.618]         else {
[17:44:45.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.618]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.618]         }
[17:44:45.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.618]             base::sink(type = "output", split = FALSE)
[17:44:45.618]             base::close(...future.stdout)
[17:44:45.618]         }, add = TRUE)
[17:44:45.618]     }
[17:44:45.618]     ...future.frame <- base::sys.nframe()
[17:44:45.618]     ...future.conditions <- base::list()
[17:44:45.618]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.618]     if (FALSE) {
[17:44:45.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.618]     }
[17:44:45.618]     ...future.result <- base::tryCatch({
[17:44:45.618]         base::withCallingHandlers({
[17:44:45.618]             ...future.value <- base::withVisible(base::local({
[17:44:45.618]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.618]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.618]                   ...future.globals.maxSize)) {
[17:44:45.618]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.618]                   on.exit(options(oopts), add = TRUE)
[17:44:45.618]                 }
[17:44:45.618]                 {
[17:44:45.618]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.618]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.618]                     USE.NAMES = FALSE)
[17:44:45.618]                   do.call(mapply, args = args)
[17:44:45.618]                 }
[17:44:45.618]             }))
[17:44:45.618]             future::FutureResult(value = ...future.value$value, 
[17:44:45.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.618]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.618]                     ...future.globalenv.names))
[17:44:45.618]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.618]         }, condition = base::local({
[17:44:45.618]             c <- base::c
[17:44:45.618]             inherits <- base::inherits
[17:44:45.618]             invokeRestart <- base::invokeRestart
[17:44:45.618]             length <- base::length
[17:44:45.618]             list <- base::list
[17:44:45.618]             seq.int <- base::seq.int
[17:44:45.618]             signalCondition <- base::signalCondition
[17:44:45.618]             sys.calls <- base::sys.calls
[17:44:45.618]             `[[` <- base::`[[`
[17:44:45.618]             `+` <- base::`+`
[17:44:45.618]             `<<-` <- base::`<<-`
[17:44:45.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.618]                   3L)]
[17:44:45.618]             }
[17:44:45.618]             function(cond) {
[17:44:45.618]                 is_error <- inherits(cond, "error")
[17:44:45.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.618]                   NULL)
[17:44:45.618]                 if (is_error) {
[17:44:45.618]                   sessionInformation <- function() {
[17:44:45.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.618]                       search = base::search(), system = base::Sys.info())
[17:44:45.618]                   }
[17:44:45.618]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.618]                     cond$call), session = sessionInformation(), 
[17:44:45.618]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.618]                   signalCondition(cond)
[17:44:45.618]                 }
[17:44:45.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.618]                 "immediateCondition"))) {
[17:44:45.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.618]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.618]                   if (TRUE && !signal) {
[17:44:45.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.618]                     {
[17:44:45.618]                       inherits <- base::inherits
[17:44:45.618]                       invokeRestart <- base::invokeRestart
[17:44:45.618]                       is.null <- base::is.null
[17:44:45.618]                       muffled <- FALSE
[17:44:45.618]                       if (inherits(cond, "message")) {
[17:44:45.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.618]                         if (muffled) 
[17:44:45.618]                           invokeRestart("muffleMessage")
[17:44:45.618]                       }
[17:44:45.618]                       else if (inherits(cond, "warning")) {
[17:44:45.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.618]                         if (muffled) 
[17:44:45.618]                           invokeRestart("muffleWarning")
[17:44:45.618]                       }
[17:44:45.618]                       else if (inherits(cond, "condition")) {
[17:44:45.618]                         if (!is.null(pattern)) {
[17:44:45.618]                           computeRestarts <- base::computeRestarts
[17:44:45.618]                           grepl <- base::grepl
[17:44:45.618]                           restarts <- computeRestarts(cond)
[17:44:45.618]                           for (restart in restarts) {
[17:44:45.618]                             name <- restart$name
[17:44:45.618]                             if (is.null(name)) 
[17:44:45.618]                               next
[17:44:45.618]                             if (!grepl(pattern, name)) 
[17:44:45.618]                               next
[17:44:45.618]                             invokeRestart(restart)
[17:44:45.618]                             muffled <- TRUE
[17:44:45.618]                             break
[17:44:45.618]                           }
[17:44:45.618]                         }
[17:44:45.618]                       }
[17:44:45.618]                       invisible(muffled)
[17:44:45.618]                     }
[17:44:45.618]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.618]                   }
[17:44:45.618]                 }
[17:44:45.618]                 else {
[17:44:45.618]                   if (TRUE) {
[17:44:45.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.618]                     {
[17:44:45.618]                       inherits <- base::inherits
[17:44:45.618]                       invokeRestart <- base::invokeRestart
[17:44:45.618]                       is.null <- base::is.null
[17:44:45.618]                       muffled <- FALSE
[17:44:45.618]                       if (inherits(cond, "message")) {
[17:44:45.618]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.618]                         if (muffled) 
[17:44:45.618]                           invokeRestart("muffleMessage")
[17:44:45.618]                       }
[17:44:45.618]                       else if (inherits(cond, "warning")) {
[17:44:45.618]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.618]                         if (muffled) 
[17:44:45.618]                           invokeRestart("muffleWarning")
[17:44:45.618]                       }
[17:44:45.618]                       else if (inherits(cond, "condition")) {
[17:44:45.618]                         if (!is.null(pattern)) {
[17:44:45.618]                           computeRestarts <- base::computeRestarts
[17:44:45.618]                           grepl <- base::grepl
[17:44:45.618]                           restarts <- computeRestarts(cond)
[17:44:45.618]                           for (restart in restarts) {
[17:44:45.618]                             name <- restart$name
[17:44:45.618]                             if (is.null(name)) 
[17:44:45.618]                               next
[17:44:45.618]                             if (!grepl(pattern, name)) 
[17:44:45.618]                               next
[17:44:45.618]                             invokeRestart(restart)
[17:44:45.618]                             muffled <- TRUE
[17:44:45.618]                             break
[17:44:45.618]                           }
[17:44:45.618]                         }
[17:44:45.618]                       }
[17:44:45.618]                       invisible(muffled)
[17:44:45.618]                     }
[17:44:45.618]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.618]                   }
[17:44:45.618]                 }
[17:44:45.618]             }
[17:44:45.618]         }))
[17:44:45.618]     }, error = function(ex) {
[17:44:45.618]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.618]                 ...future.rng), started = ...future.startTime, 
[17:44:45.618]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.618]             version = "1.8"), class = "FutureResult")
[17:44:45.618]     }, finally = {
[17:44:45.618]         if (!identical(...future.workdir, getwd())) 
[17:44:45.618]             setwd(...future.workdir)
[17:44:45.618]         {
[17:44:45.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.618]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.618]             }
[17:44:45.618]             base::options(...future.oldOptions)
[17:44:45.618]             if (.Platform$OS.type == "windows") {
[17:44:45.618]                 old_names <- names(...future.oldEnvVars)
[17:44:45.618]                 envs <- base::Sys.getenv()
[17:44:45.618]                 names <- names(envs)
[17:44:45.618]                 common <- intersect(names, old_names)
[17:44:45.618]                 added <- setdiff(names, old_names)
[17:44:45.618]                 removed <- setdiff(old_names, names)
[17:44:45.618]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.618]                   envs[common]]
[17:44:45.618]                 NAMES <- toupper(changed)
[17:44:45.618]                 args <- list()
[17:44:45.618]                 for (kk in seq_along(NAMES)) {
[17:44:45.618]                   name <- changed[[kk]]
[17:44:45.618]                   NAME <- NAMES[[kk]]
[17:44:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.618]                     next
[17:44:45.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.618]                 }
[17:44:45.618]                 NAMES <- toupper(added)
[17:44:45.618]                 for (kk in seq_along(NAMES)) {
[17:44:45.618]                   name <- added[[kk]]
[17:44:45.618]                   NAME <- NAMES[[kk]]
[17:44:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.618]                     next
[17:44:45.618]                   args[[name]] <- ""
[17:44:45.618]                 }
[17:44:45.618]                 NAMES <- toupper(removed)
[17:44:45.618]                 for (kk in seq_along(NAMES)) {
[17:44:45.618]                   name <- removed[[kk]]
[17:44:45.618]                   NAME <- NAMES[[kk]]
[17:44:45.618]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.618]                     next
[17:44:45.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.618]                 }
[17:44:45.618]                 if (length(args) > 0) 
[17:44:45.618]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.618]             }
[17:44:45.618]             else {
[17:44:45.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.618]             }
[17:44:45.618]             {
[17:44:45.618]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.618]                   0L) {
[17:44:45.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.618]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.618]                   base::options(opts)
[17:44:45.618]                 }
[17:44:45.618]                 {
[17:44:45.618]                   {
[17:44:45.618]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.618]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.618]                     -484569582L), envir = base::globalenv(), 
[17:44:45.618]                       inherits = FALSE)
[17:44:45.618]                     NULL
[17:44:45.618]                   }
[17:44:45.618]                   options(future.plan = NULL)
[17:44:45.618]                   if (is.na(NA_character_)) 
[17:44:45.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.618]                     .init = FALSE)
[17:44:45.618]                 }
[17:44:45.618]             }
[17:44:45.618]         }
[17:44:45.618]     })
[17:44:45.618]     if (TRUE) {
[17:44:45.618]         base::sink(type = "output", split = FALSE)
[17:44:45.618]         if (TRUE) {
[17:44:45.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.618]         }
[17:44:45.618]         else {
[17:44:45.618]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.618]         }
[17:44:45.618]         base::close(...future.stdout)
[17:44:45.618]         ...future.stdout <- NULL
[17:44:45.618]     }
[17:44:45.618]     ...future.result$conditions <- ...future.conditions
[17:44:45.618]     ...future.result$finished <- base::Sys.time()
[17:44:45.618]     ...future.result
[17:44:45.618] }
[17:44:45.620] assign_globals() ...
[17:44:45.620] List of 5
[17:44:45.620]  $ ...future.FUN            :function (C, k)  
[17:44:45.620]  $ MoreArgs                 : NULL
[17:44:45.620]  $ ...future.elements_ii    :List of 2
[17:44:45.620]   ..$ :List of 1
[17:44:45.620]   .. ..$ : chr "C"
[17:44:45.620]   ..$ :List of 1
[17:44:45.620]   .. ..$ : int 3
[17:44:45.620]  $ ...future.seeds_ii       : NULL
[17:44:45.620]  $ ...future.globals.maxSize: NULL
[17:44:45.620]  - attr(*, "where")=List of 5
[17:44:45.620]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.620]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.620]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.620]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.620]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.620]  - attr(*, "resolved")= logi FALSE
[17:44:45.620]  - attr(*, "total_size")= num 3488
[17:44:45.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.620]  - attr(*, "already-done")= logi TRUE
[17:44:45.625] - reassign environment for ‘...future.FUN’
[17:44:45.625] - copied ‘...future.FUN’ to environment
[17:44:45.625] - copied ‘MoreArgs’ to environment
[17:44:45.625] - copied ‘...future.elements_ii’ to environment
[17:44:45.625] - copied ‘...future.seeds_ii’ to environment
[17:44:45.627] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.627] assign_globals() ... done
[17:44:45.627] plan(): Setting new future strategy stack:
[17:44:45.627] List of future strategies:
[17:44:45.627] 1. sequential:
[17:44:45.627]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.627]    - tweaked: FALSE
[17:44:45.627]    - call: NULL
[17:44:45.628] plan(): nbrOfWorkers() = 1
[17:44:45.628] plan(): Setting new future strategy stack:
[17:44:45.628] List of future strategies:
[17:44:45.628] 1. sequential:
[17:44:45.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.628]    - tweaked: FALSE
[17:44:45.628]    - call: plan(strategy)
[17:44:45.629] plan(): nbrOfWorkers() = 1
[17:44:45.629] SequentialFuture started (and completed)
[17:44:45.629] - Launch lazy future ... done
[17:44:45.629] run() for ‘SequentialFuture’ ... done
[17:44:45.629] Created future:
[17:44:45.629] SequentialFuture:
[17:44:45.629] Label: ‘future_mapply-3’
[17:44:45.629] Expression:
[17:44:45.629] {
[17:44:45.629]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.629]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.629]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.629]         on.exit(options(oopts), add = TRUE)
[17:44:45.629]     }
[17:44:45.629]     {
[17:44:45.629]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.629]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.629]         do.call(mapply, args = args)
[17:44:45.629]     }
[17:44:45.629] }
[17:44:45.629] Lazy evaluation: FALSE
[17:44:45.629] Asynchronous evaluation: FALSE
[17:44:45.629] Local evaluation: TRUE
[17:44:45.629] Environment: R_GlobalEnv
[17:44:45.629] Capture standard output: TRUE
[17:44:45.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.629] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.629] Packages: <none>
[17:44:45.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.629] Resolved: TRUE
[17:44:45.629] Value: 112 bytes of class ‘list’
[17:44:45.629] Early signaling: FALSE
[17:44:45.629] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.629] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.630] Chunk #3 of 5 ... DONE
[17:44:45.630] Chunk #4 of 5 ...
[17:44:45.630]  - Finding globals in '...' for chunk #4 ...
[17:44:45.630] getGlobalsAndPackages() ...
[17:44:45.631] Searching for globals...
[17:44:45.631] 
[17:44:45.631] Searching for globals ... DONE
[17:44:45.631] - globals: [0] <none>
[17:44:45.631] getGlobalsAndPackages() ... DONE
[17:44:45.631]    + additional globals found: [n=0] 
[17:44:45.631]    + additional namespaces needed: [n=0] 
[17:44:45.631]  - Finding globals in '...' for chunk #4 ... DONE
[17:44:45.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:45.632]  - seeds: <none>
[17:44:45.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.632] getGlobalsAndPackages() ...
[17:44:45.632] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.632] Resolving globals: FALSE
[17:44:45.632] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.633] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.633] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.633] 
[17:44:45.633] getGlobalsAndPackages() ... DONE
[17:44:45.633] run() for ‘Future’ ...
[17:44:45.633] - state: ‘created’
[17:44:45.634] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.634] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.634]   - Field: ‘label’
[17:44:45.634]   - Field: ‘local’
[17:44:45.634]   - Field: ‘owner’
[17:44:45.634]   - Field: ‘envir’
[17:44:45.634]   - Field: ‘packages’
[17:44:45.634]   - Field: ‘gc’
[17:44:45.635]   - Field: ‘conditions’
[17:44:45.635]   - Field: ‘expr’
[17:44:45.635]   - Field: ‘uuid’
[17:44:45.635]   - Field: ‘seed’
[17:44:45.635]   - Field: ‘version’
[17:44:45.635]   - Field: ‘result’
[17:44:45.635]   - Field: ‘asynchronous’
[17:44:45.635]   - Field: ‘calls’
[17:44:45.635]   - Field: ‘globals’
[17:44:45.635]   - Field: ‘stdout’
[17:44:45.636]   - Field: ‘earlySignal’
[17:44:45.636]   - Field: ‘lazy’
[17:44:45.636]   - Field: ‘state’
[17:44:45.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.636] - Launch lazy future ...
[17:44:45.636] Packages needed by the future expression (n = 0): <none>
[17:44:45.636] Packages needed by future strategies (n = 0): <none>
[17:44:45.637] {
[17:44:45.637]     {
[17:44:45.637]         {
[17:44:45.637]             ...future.startTime <- base::Sys.time()
[17:44:45.637]             {
[17:44:45.637]                 {
[17:44:45.637]                   {
[17:44:45.637]                     base::local({
[17:44:45.637]                       has_future <- base::requireNamespace("future", 
[17:44:45.637]                         quietly = TRUE)
[17:44:45.637]                       if (has_future) {
[17:44:45.637]                         ns <- base::getNamespace("future")
[17:44:45.637]                         version <- ns[[".package"]][["version"]]
[17:44:45.637]                         if (is.null(version)) 
[17:44:45.637]                           version <- utils::packageVersion("future")
[17:44:45.637]                       }
[17:44:45.637]                       else {
[17:44:45.637]                         version <- NULL
[17:44:45.637]                       }
[17:44:45.637]                       if (!has_future || version < "1.8.0") {
[17:44:45.637]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.637]                           "", base::R.version$version.string), 
[17:44:45.637]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.637]                             "release", "version")], collapse = " "), 
[17:44:45.637]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.637]                           info)
[17:44:45.637]                         info <- base::paste(info, collapse = "; ")
[17:44:45.637]                         if (!has_future) {
[17:44:45.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.637]                             info)
[17:44:45.637]                         }
[17:44:45.637]                         else {
[17:44:45.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.637]                             info, version)
[17:44:45.637]                         }
[17:44:45.637]                         base::stop(msg)
[17:44:45.637]                       }
[17:44:45.637]                     })
[17:44:45.637]                   }
[17:44:45.637]                   ...future.strategy.old <- future::plan("list")
[17:44:45.637]                   options(future.plan = NULL)
[17:44:45.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.637]                 }
[17:44:45.637]                 ...future.workdir <- getwd()
[17:44:45.637]             }
[17:44:45.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.637]         }
[17:44:45.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.637]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:45.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.637]             base::names(...future.oldOptions))
[17:44:45.637]     }
[17:44:45.637]     if (FALSE) {
[17:44:45.637]     }
[17:44:45.637]     else {
[17:44:45.637]         if (TRUE) {
[17:44:45.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.637]                 open = "w")
[17:44:45.637]         }
[17:44:45.637]         else {
[17:44:45.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.637]         }
[17:44:45.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.637]             base::sink(type = "output", split = FALSE)
[17:44:45.637]             base::close(...future.stdout)
[17:44:45.637]         }, add = TRUE)
[17:44:45.637]     }
[17:44:45.637]     ...future.frame <- base::sys.nframe()
[17:44:45.637]     ...future.conditions <- base::list()
[17:44:45.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.637]     if (FALSE) {
[17:44:45.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.637]     }
[17:44:45.637]     ...future.result <- base::tryCatch({
[17:44:45.637]         base::withCallingHandlers({
[17:44:45.637]             ...future.value <- base::withVisible(base::local({
[17:44:45.637]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.637]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.637]                   ...future.globals.maxSize)) {
[17:44:45.637]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.637]                   on.exit(options(oopts), add = TRUE)
[17:44:45.637]                 }
[17:44:45.637]                 {
[17:44:45.637]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.637]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.637]                     USE.NAMES = FALSE)
[17:44:45.637]                   do.call(mapply, args = args)
[17:44:45.637]                 }
[17:44:45.637]             }))
[17:44:45.637]             future::FutureResult(value = ...future.value$value, 
[17:44:45.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.637]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.637]                     ...future.globalenv.names))
[17:44:45.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.637]         }, condition = base::local({
[17:44:45.637]             c <- base::c
[17:44:45.637]             inherits <- base::inherits
[17:44:45.637]             invokeRestart <- base::invokeRestart
[17:44:45.637]             length <- base::length
[17:44:45.637]             list <- base::list
[17:44:45.637]             seq.int <- base::seq.int
[17:44:45.637]             signalCondition <- base::signalCondition
[17:44:45.637]             sys.calls <- base::sys.calls
[17:44:45.637]             `[[` <- base::`[[`
[17:44:45.637]             `+` <- base::`+`
[17:44:45.637]             `<<-` <- base::`<<-`
[17:44:45.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.637]                   3L)]
[17:44:45.637]             }
[17:44:45.637]             function(cond) {
[17:44:45.637]                 is_error <- inherits(cond, "error")
[17:44:45.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.637]                   NULL)
[17:44:45.637]                 if (is_error) {
[17:44:45.637]                   sessionInformation <- function() {
[17:44:45.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.637]                       search = base::search(), system = base::Sys.info())
[17:44:45.637]                   }
[17:44:45.637]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.637]                     cond$call), session = sessionInformation(), 
[17:44:45.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.637]                   signalCondition(cond)
[17:44:45.637]                 }
[17:44:45.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.637]                 "immediateCondition"))) {
[17:44:45.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.637]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.637]                   if (TRUE && !signal) {
[17:44:45.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.637]                     {
[17:44:45.637]                       inherits <- base::inherits
[17:44:45.637]                       invokeRestart <- base::invokeRestart
[17:44:45.637]                       is.null <- base::is.null
[17:44:45.637]                       muffled <- FALSE
[17:44:45.637]                       if (inherits(cond, "message")) {
[17:44:45.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.637]                         if (muffled) 
[17:44:45.637]                           invokeRestart("muffleMessage")
[17:44:45.637]                       }
[17:44:45.637]                       else if (inherits(cond, "warning")) {
[17:44:45.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.637]                         if (muffled) 
[17:44:45.637]                           invokeRestart("muffleWarning")
[17:44:45.637]                       }
[17:44:45.637]                       else if (inherits(cond, "condition")) {
[17:44:45.637]                         if (!is.null(pattern)) {
[17:44:45.637]                           computeRestarts <- base::computeRestarts
[17:44:45.637]                           grepl <- base::grepl
[17:44:45.637]                           restarts <- computeRestarts(cond)
[17:44:45.637]                           for (restart in restarts) {
[17:44:45.637]                             name <- restart$name
[17:44:45.637]                             if (is.null(name)) 
[17:44:45.637]                               next
[17:44:45.637]                             if (!grepl(pattern, name)) 
[17:44:45.637]                               next
[17:44:45.637]                             invokeRestart(restart)
[17:44:45.637]                             muffled <- TRUE
[17:44:45.637]                             break
[17:44:45.637]                           }
[17:44:45.637]                         }
[17:44:45.637]                       }
[17:44:45.637]                       invisible(muffled)
[17:44:45.637]                     }
[17:44:45.637]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.637]                   }
[17:44:45.637]                 }
[17:44:45.637]                 else {
[17:44:45.637]                   if (TRUE) {
[17:44:45.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.637]                     {
[17:44:45.637]                       inherits <- base::inherits
[17:44:45.637]                       invokeRestart <- base::invokeRestart
[17:44:45.637]                       is.null <- base::is.null
[17:44:45.637]                       muffled <- FALSE
[17:44:45.637]                       if (inherits(cond, "message")) {
[17:44:45.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.637]                         if (muffled) 
[17:44:45.637]                           invokeRestart("muffleMessage")
[17:44:45.637]                       }
[17:44:45.637]                       else if (inherits(cond, "warning")) {
[17:44:45.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.637]                         if (muffled) 
[17:44:45.637]                           invokeRestart("muffleWarning")
[17:44:45.637]                       }
[17:44:45.637]                       else if (inherits(cond, "condition")) {
[17:44:45.637]                         if (!is.null(pattern)) {
[17:44:45.637]                           computeRestarts <- base::computeRestarts
[17:44:45.637]                           grepl <- base::grepl
[17:44:45.637]                           restarts <- computeRestarts(cond)
[17:44:45.637]                           for (restart in restarts) {
[17:44:45.637]                             name <- restart$name
[17:44:45.637]                             if (is.null(name)) 
[17:44:45.637]                               next
[17:44:45.637]                             if (!grepl(pattern, name)) 
[17:44:45.637]                               next
[17:44:45.637]                             invokeRestart(restart)
[17:44:45.637]                             muffled <- TRUE
[17:44:45.637]                             break
[17:44:45.637]                           }
[17:44:45.637]                         }
[17:44:45.637]                       }
[17:44:45.637]                       invisible(muffled)
[17:44:45.637]                     }
[17:44:45.637]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.637]                   }
[17:44:45.637]                 }
[17:44:45.637]             }
[17:44:45.637]         }))
[17:44:45.637]     }, error = function(ex) {
[17:44:45.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.637]                 ...future.rng), started = ...future.startTime, 
[17:44:45.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.637]             version = "1.8"), class = "FutureResult")
[17:44:45.637]     }, finally = {
[17:44:45.637]         if (!identical(...future.workdir, getwd())) 
[17:44:45.637]             setwd(...future.workdir)
[17:44:45.637]         {
[17:44:45.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.637]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.637]             }
[17:44:45.637]             base::options(...future.oldOptions)
[17:44:45.637]             if (.Platform$OS.type == "windows") {
[17:44:45.637]                 old_names <- names(...future.oldEnvVars)
[17:44:45.637]                 envs <- base::Sys.getenv()
[17:44:45.637]                 names <- names(envs)
[17:44:45.637]                 common <- intersect(names, old_names)
[17:44:45.637]                 added <- setdiff(names, old_names)
[17:44:45.637]                 removed <- setdiff(old_names, names)
[17:44:45.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.637]                   envs[common]]
[17:44:45.637]                 NAMES <- toupper(changed)
[17:44:45.637]                 args <- list()
[17:44:45.637]                 for (kk in seq_along(NAMES)) {
[17:44:45.637]                   name <- changed[[kk]]
[17:44:45.637]                   NAME <- NAMES[[kk]]
[17:44:45.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.637]                     next
[17:44:45.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.637]                 }
[17:44:45.637]                 NAMES <- toupper(added)
[17:44:45.637]                 for (kk in seq_along(NAMES)) {
[17:44:45.637]                   name <- added[[kk]]
[17:44:45.637]                   NAME <- NAMES[[kk]]
[17:44:45.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.637]                     next
[17:44:45.637]                   args[[name]] <- ""
[17:44:45.637]                 }
[17:44:45.637]                 NAMES <- toupper(removed)
[17:44:45.637]                 for (kk in seq_along(NAMES)) {
[17:44:45.637]                   name <- removed[[kk]]
[17:44:45.637]                   NAME <- NAMES[[kk]]
[17:44:45.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.637]                     next
[17:44:45.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.637]                 }
[17:44:45.637]                 if (length(args) > 0) 
[17:44:45.637]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.637]             }
[17:44:45.637]             else {
[17:44:45.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.637]             }
[17:44:45.637]             {
[17:44:45.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.637]                   0L) {
[17:44:45.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.637]                   base::options(opts)
[17:44:45.637]                 }
[17:44:45.637]                 {
[17:44:45.637]                   {
[17:44:45.637]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.637]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.637]                     -484569582L), envir = base::globalenv(), 
[17:44:45.637]                       inherits = FALSE)
[17:44:45.637]                     NULL
[17:44:45.637]                   }
[17:44:45.637]                   options(future.plan = NULL)
[17:44:45.637]                   if (is.na(NA_character_)) 
[17:44:45.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.637]                     .init = FALSE)
[17:44:45.637]                 }
[17:44:45.637]             }
[17:44:45.637]         }
[17:44:45.637]     })
[17:44:45.637]     if (TRUE) {
[17:44:45.637]         base::sink(type = "output", split = FALSE)
[17:44:45.637]         if (TRUE) {
[17:44:45.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.637]         }
[17:44:45.637]         else {
[17:44:45.637]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.637]         }
[17:44:45.637]         base::close(...future.stdout)
[17:44:45.637]         ...future.stdout <- NULL
[17:44:45.637]     }
[17:44:45.637]     ...future.result$conditions <- ...future.conditions
[17:44:45.637]     ...future.result$finished <- base::Sys.time()
[17:44:45.637]     ...future.result
[17:44:45.637] }
[17:44:45.638] assign_globals() ...
[17:44:45.638] List of 5
[17:44:45.638]  $ ...future.FUN            :function (C, k)  
[17:44:45.638]  $ MoreArgs                 : NULL
[17:44:45.638]  $ ...future.elements_ii    :List of 2
[17:44:45.638]   ..$ :List of 1
[17:44:45.638]   .. ..$ : chr "D"
[17:44:45.638]   ..$ :List of 1
[17:44:45.638]   .. ..$ : int 2
[17:44:45.638]  $ ...future.seeds_ii       : NULL
[17:44:45.638]  $ ...future.globals.maxSize: NULL
[17:44:45.638]  - attr(*, "where")=List of 5
[17:44:45.638]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.638]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.638]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.638]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.638]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.638]  - attr(*, "resolved")= logi FALSE
[17:44:45.638]  - attr(*, "total_size")= num 3488
[17:44:45.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.638]  - attr(*, "already-done")= logi TRUE
[17:44:45.643] - reassign environment for ‘...future.FUN’
[17:44:45.643] - copied ‘...future.FUN’ to environment
[17:44:45.643] - copied ‘MoreArgs’ to environment
[17:44:45.643] - copied ‘...future.elements_ii’ to environment
[17:44:45.643] - copied ‘...future.seeds_ii’ to environment
[17:44:45.643] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.643] assign_globals() ... done
[17:44:45.644] plan(): Setting new future strategy stack:
[17:44:45.644] List of future strategies:
[17:44:45.644] 1. sequential:
[17:44:45.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.644]    - tweaked: FALSE
[17:44:45.644]    - call: NULL
[17:44:45.644] plan(): nbrOfWorkers() = 1
[17:44:45.645] plan(): Setting new future strategy stack:
[17:44:45.645] List of future strategies:
[17:44:45.645] 1. sequential:
[17:44:45.645]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.645]    - tweaked: FALSE
[17:44:45.645]    - call: plan(strategy)
[17:44:45.645] plan(): nbrOfWorkers() = 1
[17:44:45.646] SequentialFuture started (and completed)
[17:44:45.646] - Launch lazy future ... done
[17:44:45.646] run() for ‘SequentialFuture’ ... done
[17:44:45.646] Created future:
[17:44:45.646] SequentialFuture:
[17:44:45.646] Label: ‘future_mapply-4’
[17:44:45.646] Expression:
[17:44:45.646] {
[17:44:45.646]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.646]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.646]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.646]         on.exit(options(oopts), add = TRUE)
[17:44:45.646]     }
[17:44:45.646]     {
[17:44:45.646]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.646]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.646]         do.call(mapply, args = args)
[17:44:45.646]     }
[17:44:45.646] }
[17:44:45.646] Lazy evaluation: FALSE
[17:44:45.646] Asynchronous evaluation: FALSE
[17:44:45.646] Local evaluation: TRUE
[17:44:45.646] Environment: R_GlobalEnv
[17:44:45.646] Capture standard output: TRUE
[17:44:45.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.646] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.646] Packages: <none>
[17:44:45.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.646] Resolved: TRUE
[17:44:45.646] Value: 112 bytes of class ‘list’
[17:44:45.646] Early signaling: FALSE
[17:44:45.646] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.646] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.647] Chunk #4 of 5 ... DONE
[17:44:45.647] Chunk #5 of 5 ...
[17:44:45.647]  - Finding globals in '...' for chunk #5 ...
[17:44:45.647] getGlobalsAndPackages() ...
[17:44:45.647] Searching for globals...
[17:44:45.647] 
[17:44:45.648] Searching for globals ... DONE
[17:44:45.648] - globals: [0] <none>
[17:44:45.648] getGlobalsAndPackages() ... DONE
[17:44:45.648]    + additional globals found: [n=0] 
[17:44:45.648]    + additional namespaces needed: [n=0] 
[17:44:45.648]  - Finding globals in '...' for chunk #5 ... DONE
[17:44:45.648]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:45.648]  - seeds: <none>
[17:44:45.648]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.648] getGlobalsAndPackages() ...
[17:44:45.648] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.649] Resolving globals: FALSE
[17:44:45.649] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.649] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.674] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.674] 
[17:44:45.674] getGlobalsAndPackages() ... DONE
[17:44:45.675] run() for ‘Future’ ...
[17:44:45.675] - state: ‘created’
[17:44:45.675] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.675] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.676]   - Field: ‘label’
[17:44:45.676]   - Field: ‘local’
[17:44:45.676]   - Field: ‘owner’
[17:44:45.676]   - Field: ‘envir’
[17:44:45.676]   - Field: ‘packages’
[17:44:45.676]   - Field: ‘gc’
[17:44:45.676]   - Field: ‘conditions’
[17:44:45.676]   - Field: ‘expr’
[17:44:45.676]   - Field: ‘uuid’
[17:44:45.676]   - Field: ‘seed’
[17:44:45.677]   - Field: ‘version’
[17:44:45.677]   - Field: ‘result’
[17:44:45.677]   - Field: ‘asynchronous’
[17:44:45.677]   - Field: ‘calls’
[17:44:45.677]   - Field: ‘globals’
[17:44:45.677]   - Field: ‘stdout’
[17:44:45.677]   - Field: ‘earlySignal’
[17:44:45.677]   - Field: ‘lazy’
[17:44:45.677]   - Field: ‘state’
[17:44:45.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.677] - Launch lazy future ...
[17:44:45.678] Packages needed by the future expression (n = 0): <none>
[17:44:45.678] Packages needed by future strategies (n = 0): <none>
[17:44:45.678] {
[17:44:45.678]     {
[17:44:45.678]         {
[17:44:45.678]             ...future.startTime <- base::Sys.time()
[17:44:45.678]             {
[17:44:45.678]                 {
[17:44:45.678]                   {
[17:44:45.678]                     base::local({
[17:44:45.678]                       has_future <- base::requireNamespace("future", 
[17:44:45.678]                         quietly = TRUE)
[17:44:45.678]                       if (has_future) {
[17:44:45.678]                         ns <- base::getNamespace("future")
[17:44:45.678]                         version <- ns[[".package"]][["version"]]
[17:44:45.678]                         if (is.null(version)) 
[17:44:45.678]                           version <- utils::packageVersion("future")
[17:44:45.678]                       }
[17:44:45.678]                       else {
[17:44:45.678]                         version <- NULL
[17:44:45.678]                       }
[17:44:45.678]                       if (!has_future || version < "1.8.0") {
[17:44:45.678]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.678]                           "", base::R.version$version.string), 
[17:44:45.678]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.678]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.678]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.678]                             "release", "version")], collapse = " "), 
[17:44:45.678]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.678]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.678]                           info)
[17:44:45.678]                         info <- base::paste(info, collapse = "; ")
[17:44:45.678]                         if (!has_future) {
[17:44:45.678]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.678]                             info)
[17:44:45.678]                         }
[17:44:45.678]                         else {
[17:44:45.678]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.678]                             info, version)
[17:44:45.678]                         }
[17:44:45.678]                         base::stop(msg)
[17:44:45.678]                       }
[17:44:45.678]                     })
[17:44:45.678]                   }
[17:44:45.678]                   ...future.strategy.old <- future::plan("list")
[17:44:45.678]                   options(future.plan = NULL)
[17:44:45.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.678]                 }
[17:44:45.678]                 ...future.workdir <- getwd()
[17:44:45.678]             }
[17:44:45.678]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.678]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.678]         }
[17:44:45.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.678]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:45.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.678]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.678]             base::names(...future.oldOptions))
[17:44:45.678]     }
[17:44:45.678]     if (FALSE) {
[17:44:45.678]     }
[17:44:45.678]     else {
[17:44:45.678]         if (TRUE) {
[17:44:45.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.678]                 open = "w")
[17:44:45.678]         }
[17:44:45.678]         else {
[17:44:45.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.678]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.678]         }
[17:44:45.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.678]             base::sink(type = "output", split = FALSE)
[17:44:45.678]             base::close(...future.stdout)
[17:44:45.678]         }, add = TRUE)
[17:44:45.678]     }
[17:44:45.678]     ...future.frame <- base::sys.nframe()
[17:44:45.678]     ...future.conditions <- base::list()
[17:44:45.678]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.678]     if (FALSE) {
[17:44:45.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.678]     }
[17:44:45.678]     ...future.result <- base::tryCatch({
[17:44:45.678]         base::withCallingHandlers({
[17:44:45.678]             ...future.value <- base::withVisible(base::local({
[17:44:45.678]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.678]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.678]                   ...future.globals.maxSize)) {
[17:44:45.678]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.678]                   on.exit(options(oopts), add = TRUE)
[17:44:45.678]                 }
[17:44:45.678]                 {
[17:44:45.678]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.678]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.678]                     USE.NAMES = FALSE)
[17:44:45.678]                   do.call(mapply, args = args)
[17:44:45.678]                 }
[17:44:45.678]             }))
[17:44:45.678]             future::FutureResult(value = ...future.value$value, 
[17:44:45.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.678]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.678]                     ...future.globalenv.names))
[17:44:45.678]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.678]         }, condition = base::local({
[17:44:45.678]             c <- base::c
[17:44:45.678]             inherits <- base::inherits
[17:44:45.678]             invokeRestart <- base::invokeRestart
[17:44:45.678]             length <- base::length
[17:44:45.678]             list <- base::list
[17:44:45.678]             seq.int <- base::seq.int
[17:44:45.678]             signalCondition <- base::signalCondition
[17:44:45.678]             sys.calls <- base::sys.calls
[17:44:45.678]             `[[` <- base::`[[`
[17:44:45.678]             `+` <- base::`+`
[17:44:45.678]             `<<-` <- base::`<<-`
[17:44:45.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.678]                   3L)]
[17:44:45.678]             }
[17:44:45.678]             function(cond) {
[17:44:45.678]                 is_error <- inherits(cond, "error")
[17:44:45.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.678]                   NULL)
[17:44:45.678]                 if (is_error) {
[17:44:45.678]                   sessionInformation <- function() {
[17:44:45.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.678]                       search = base::search(), system = base::Sys.info())
[17:44:45.678]                   }
[17:44:45.678]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.678]                     cond$call), session = sessionInformation(), 
[17:44:45.678]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.678]                   signalCondition(cond)
[17:44:45.678]                 }
[17:44:45.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.678]                 "immediateCondition"))) {
[17:44:45.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.678]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.678]                   if (TRUE && !signal) {
[17:44:45.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.678]                     {
[17:44:45.678]                       inherits <- base::inherits
[17:44:45.678]                       invokeRestart <- base::invokeRestart
[17:44:45.678]                       is.null <- base::is.null
[17:44:45.678]                       muffled <- FALSE
[17:44:45.678]                       if (inherits(cond, "message")) {
[17:44:45.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.678]                         if (muffled) 
[17:44:45.678]                           invokeRestart("muffleMessage")
[17:44:45.678]                       }
[17:44:45.678]                       else if (inherits(cond, "warning")) {
[17:44:45.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.678]                         if (muffled) 
[17:44:45.678]                           invokeRestart("muffleWarning")
[17:44:45.678]                       }
[17:44:45.678]                       else if (inherits(cond, "condition")) {
[17:44:45.678]                         if (!is.null(pattern)) {
[17:44:45.678]                           computeRestarts <- base::computeRestarts
[17:44:45.678]                           grepl <- base::grepl
[17:44:45.678]                           restarts <- computeRestarts(cond)
[17:44:45.678]                           for (restart in restarts) {
[17:44:45.678]                             name <- restart$name
[17:44:45.678]                             if (is.null(name)) 
[17:44:45.678]                               next
[17:44:45.678]                             if (!grepl(pattern, name)) 
[17:44:45.678]                               next
[17:44:45.678]                             invokeRestart(restart)
[17:44:45.678]                             muffled <- TRUE
[17:44:45.678]                             break
[17:44:45.678]                           }
[17:44:45.678]                         }
[17:44:45.678]                       }
[17:44:45.678]                       invisible(muffled)
[17:44:45.678]                     }
[17:44:45.678]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.678]                   }
[17:44:45.678]                 }
[17:44:45.678]                 else {
[17:44:45.678]                   if (TRUE) {
[17:44:45.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.678]                     {
[17:44:45.678]                       inherits <- base::inherits
[17:44:45.678]                       invokeRestart <- base::invokeRestart
[17:44:45.678]                       is.null <- base::is.null
[17:44:45.678]                       muffled <- FALSE
[17:44:45.678]                       if (inherits(cond, "message")) {
[17:44:45.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.678]                         if (muffled) 
[17:44:45.678]                           invokeRestart("muffleMessage")
[17:44:45.678]                       }
[17:44:45.678]                       else if (inherits(cond, "warning")) {
[17:44:45.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.678]                         if (muffled) 
[17:44:45.678]                           invokeRestart("muffleWarning")
[17:44:45.678]                       }
[17:44:45.678]                       else if (inherits(cond, "condition")) {
[17:44:45.678]                         if (!is.null(pattern)) {
[17:44:45.678]                           computeRestarts <- base::computeRestarts
[17:44:45.678]                           grepl <- base::grepl
[17:44:45.678]                           restarts <- computeRestarts(cond)
[17:44:45.678]                           for (restart in restarts) {
[17:44:45.678]                             name <- restart$name
[17:44:45.678]                             if (is.null(name)) 
[17:44:45.678]                               next
[17:44:45.678]                             if (!grepl(pattern, name)) 
[17:44:45.678]                               next
[17:44:45.678]                             invokeRestart(restart)
[17:44:45.678]                             muffled <- TRUE
[17:44:45.678]                             break
[17:44:45.678]                           }
[17:44:45.678]                         }
[17:44:45.678]                       }
[17:44:45.678]                       invisible(muffled)
[17:44:45.678]                     }
[17:44:45.678]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.678]                   }
[17:44:45.678]                 }
[17:44:45.678]             }
[17:44:45.678]         }))
[17:44:45.678]     }, error = function(ex) {
[17:44:45.678]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.678]                 ...future.rng), started = ...future.startTime, 
[17:44:45.678]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.678]             version = "1.8"), class = "FutureResult")
[17:44:45.678]     }, finally = {
[17:44:45.678]         if (!identical(...future.workdir, getwd())) 
[17:44:45.678]             setwd(...future.workdir)
[17:44:45.678]         {
[17:44:45.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.678]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.678]             }
[17:44:45.678]             base::options(...future.oldOptions)
[17:44:45.678]             if (.Platform$OS.type == "windows") {
[17:44:45.678]                 old_names <- names(...future.oldEnvVars)
[17:44:45.678]                 envs <- base::Sys.getenv()
[17:44:45.678]                 names <- names(envs)
[17:44:45.678]                 common <- intersect(names, old_names)
[17:44:45.678]                 added <- setdiff(names, old_names)
[17:44:45.678]                 removed <- setdiff(old_names, names)
[17:44:45.678]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.678]                   envs[common]]
[17:44:45.678]                 NAMES <- toupper(changed)
[17:44:45.678]                 args <- list()
[17:44:45.678]                 for (kk in seq_along(NAMES)) {
[17:44:45.678]                   name <- changed[[kk]]
[17:44:45.678]                   NAME <- NAMES[[kk]]
[17:44:45.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.678]                     next
[17:44:45.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.678]                 }
[17:44:45.678]                 NAMES <- toupper(added)
[17:44:45.678]                 for (kk in seq_along(NAMES)) {
[17:44:45.678]                   name <- added[[kk]]
[17:44:45.678]                   NAME <- NAMES[[kk]]
[17:44:45.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.678]                     next
[17:44:45.678]                   args[[name]] <- ""
[17:44:45.678]                 }
[17:44:45.678]                 NAMES <- toupper(removed)
[17:44:45.678]                 for (kk in seq_along(NAMES)) {
[17:44:45.678]                   name <- removed[[kk]]
[17:44:45.678]                   NAME <- NAMES[[kk]]
[17:44:45.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.678]                     next
[17:44:45.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.678]                 }
[17:44:45.678]                 if (length(args) > 0) 
[17:44:45.678]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.678]             }
[17:44:45.678]             else {
[17:44:45.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.678]             }
[17:44:45.678]             {
[17:44:45.678]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.678]                   0L) {
[17:44:45.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.678]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.678]                   base::options(opts)
[17:44:45.678]                 }
[17:44:45.678]                 {
[17:44:45.678]                   {
[17:44:45.678]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.678]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.678]                     -484569582L), envir = base::globalenv(), 
[17:44:45.678]                       inherits = FALSE)
[17:44:45.678]                     NULL
[17:44:45.678]                   }
[17:44:45.678]                   options(future.plan = NULL)
[17:44:45.678]                   if (is.na(NA_character_)) 
[17:44:45.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.678]                     .init = FALSE)
[17:44:45.678]                 }
[17:44:45.678]             }
[17:44:45.678]         }
[17:44:45.678]     })
[17:44:45.678]     if (TRUE) {
[17:44:45.678]         base::sink(type = "output", split = FALSE)
[17:44:45.678]         if (TRUE) {
[17:44:45.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.678]         }
[17:44:45.678]         else {
[17:44:45.678]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.678]         }
[17:44:45.678]         base::close(...future.stdout)
[17:44:45.678]         ...future.stdout <- NULL
[17:44:45.678]     }
[17:44:45.678]     ...future.result$conditions <- ...future.conditions
[17:44:45.678]     ...future.result$finished <- base::Sys.time()
[17:44:45.678]     ...future.result
[17:44:45.678] }
[17:44:45.680] assign_globals() ...
[17:44:45.680] List of 5
[17:44:45.680]  $ ...future.FUN            :function (C, k)  
[17:44:45.680]  $ MoreArgs                 : NULL
[17:44:45.680]  $ ...future.elements_ii    :List of 2
[17:44:45.680]   ..$ :List of 1
[17:44:45.680]   .. ..$ : chr "E"
[17:44:45.680]   ..$ :List of 1
[17:44:45.680]   .. ..$ : int 1
[17:44:45.680]  $ ...future.seeds_ii       : NULL
[17:44:45.680]  $ ...future.globals.maxSize: NULL
[17:44:45.680]  - attr(*, "where")=List of 5
[17:44:45.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.680]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.680]  - attr(*, "resolved")= logi FALSE
[17:44:45.680]  - attr(*, "total_size")= num 3488
[17:44:45.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.680]  - attr(*, "already-done")= logi TRUE
[17:44:45.685] - reassign environment for ‘...future.FUN’
[17:44:45.685] - copied ‘...future.FUN’ to environment
[17:44:45.685] - copied ‘MoreArgs’ to environment
[17:44:45.685] - copied ‘...future.elements_ii’ to environment
[17:44:45.685] - copied ‘...future.seeds_ii’ to environment
[17:44:45.685] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.685] assign_globals() ... done
[17:44:45.685] plan(): Setting new future strategy stack:
[17:44:45.686] List of future strategies:
[17:44:45.686] 1. sequential:
[17:44:45.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.686]    - tweaked: FALSE
[17:44:45.686]    - call: NULL
[17:44:45.686] plan(): nbrOfWorkers() = 1
[17:44:45.687] plan(): Setting new future strategy stack:
[17:44:45.687] List of future strategies:
[17:44:45.687] 1. sequential:
[17:44:45.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.687]    - tweaked: FALSE
[17:44:45.687]    - call: plan(strategy)
[17:44:45.687] plan(): nbrOfWorkers() = 1
[17:44:45.687] SequentialFuture started (and completed)
[17:44:45.688] - Launch lazy future ... done
[17:44:45.688] run() for ‘SequentialFuture’ ... done
[17:44:45.688] Created future:
[17:44:45.688] SequentialFuture:
[17:44:45.688] Label: ‘future_mapply-5’
[17:44:45.688] Expression:
[17:44:45.688] {
[17:44:45.688]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.688]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.688]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.688]         on.exit(options(oopts), add = TRUE)
[17:44:45.688]     }
[17:44:45.688]     {
[17:44:45.688]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.688]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.688]         do.call(mapply, args = args)
[17:44:45.688]     }
[17:44:45.688] }
[17:44:45.688] Lazy evaluation: FALSE
[17:44:45.688] Asynchronous evaluation: FALSE
[17:44:45.688] Local evaluation: TRUE
[17:44:45.688] Environment: R_GlobalEnv
[17:44:45.688] Capture standard output: TRUE
[17:44:45.688] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.688] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.688] Packages: <none>
[17:44:45.688] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.688] Resolved: TRUE
[17:44:45.688] Value: 112 bytes of class ‘list’
[17:44:45.688] Early signaling: FALSE
[17:44:45.688] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.688] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.689] Chunk #5 of 5 ... DONE
[17:44:45.689] Launching 5 futures (chunks) ... DONE
[17:44:45.689] Resolving 5 futures (chunks) ...
[17:44:45.689] resolve() on list ...
[17:44:45.689]  recursive: 0
[17:44:45.689]  length: 5
[17:44:45.689] 
[17:44:45.689] resolved() for ‘SequentialFuture’ ...
[17:44:45.689] - state: ‘finished’
[17:44:45.689] - run: TRUE
[17:44:45.690] - result: ‘FutureResult’
[17:44:45.690] resolved() for ‘SequentialFuture’ ... done
[17:44:45.690] Future #1
[17:44:45.690] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.690] - nx: 5
[17:44:45.690] - relay: TRUE
[17:44:45.690] - stdout: TRUE
[17:44:45.690] - signal: TRUE
[17:44:45.690] - resignal: FALSE
[17:44:45.690] - force: TRUE
[17:44:45.690] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:45.691] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:45.691]  - until=1
[17:44:45.691]  - relaying element #1
[17:44:45.691] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:45.691] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:45.691] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.691]  length: 4 (resolved future 1)
[17:44:45.691] resolved() for ‘SequentialFuture’ ...
[17:44:45.691] - state: ‘finished’
[17:44:45.692] - run: TRUE
[17:44:45.692] - result: ‘FutureResult’
[17:44:45.692] resolved() for ‘SequentialFuture’ ... done
[17:44:45.692] Future #2
[17:44:45.692] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:44:45.692] - nx: 5
[17:44:45.692] - relay: TRUE
[17:44:45.692] - stdout: TRUE
[17:44:45.692] - signal: TRUE
[17:44:45.692] - resignal: FALSE
[17:44:45.692] - force: TRUE
[17:44:45.693] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:45.693] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:45.693]  - until=2
[17:44:45.693]  - relaying element #2
[17:44:45.693] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:45.693] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:45.693] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:44:45.693]  length: 3 (resolved future 2)
[17:44:45.693] resolved() for ‘SequentialFuture’ ...
[17:44:45.693] - state: ‘finished’
[17:44:45.694] - run: TRUE
[17:44:45.694] - result: ‘FutureResult’
[17:44:45.694] resolved() for ‘SequentialFuture’ ... done
[17:44:45.694] Future #3
[17:44:45.694] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:44:45.694] - nx: 5
[17:44:45.694] - relay: TRUE
[17:44:45.694] - stdout: TRUE
[17:44:45.694] - signal: TRUE
[17:44:45.694] - resignal: FALSE
[17:44:45.694] - force: TRUE
[17:44:45.695] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:45.695] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:45.695]  - until=3
[17:44:45.695]  - relaying element #3
[17:44:45.695] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:45.695] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:45.695] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:44:45.695]  length: 2 (resolved future 3)
[17:44:45.695] resolved() for ‘SequentialFuture’ ...
[17:44:45.696] - state: ‘finished’
[17:44:45.696] - run: TRUE
[17:44:45.696] - result: ‘FutureResult’
[17:44:45.696] resolved() for ‘SequentialFuture’ ... done
[17:44:45.696] Future #4
[17:44:45.696] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:44:45.696] - nx: 5
[17:44:45.696] - relay: TRUE
[17:44:45.696] - stdout: TRUE
[17:44:45.696] - signal: TRUE
[17:44:45.696] - resignal: FALSE
[17:44:45.697] - force: TRUE
[17:44:45.697] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:45.697] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:45.697]  - until=4
[17:44:45.697]  - relaying element #4
[17:44:45.697] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:45.697] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:45.697] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:44:45.697]  length: 1 (resolved future 4)
[17:44:45.697] resolved() for ‘SequentialFuture’ ...
[17:44:45.698] - state: ‘finished’
[17:44:45.698] - run: TRUE
[17:44:45.698] - result: ‘FutureResult’
[17:44:45.698] resolved() for ‘SequentialFuture’ ... done
[17:44:45.698] Future #5
[17:44:45.698] signalConditionsASAP(SequentialFuture, pos=5) ...
[17:44:45.698] - nx: 5
[17:44:45.698] - relay: TRUE
[17:44:45.698] - stdout: TRUE
[17:44:45.698] - signal: TRUE
[17:44:45.698] - resignal: FALSE
[17:44:45.699] - force: TRUE
[17:44:45.699] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:45.699] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:45.699]  - until=5
[17:44:45.699]  - relaying element #5
[17:44:45.699] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:45.699] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:45.700] signalConditionsASAP(SequentialFuture, pos=5) ... done
[17:44:45.700]  length: 0 (resolved future 5)
[17:44:45.701] Relaying remaining futures
[17:44:45.701] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.701] - nx: 5
[17:44:45.701] - relay: TRUE
[17:44:45.701] - stdout: TRUE
[17:44:45.701] - signal: TRUE
[17:44:45.701] - resignal: FALSE
[17:44:45.701] - force: TRUE
[17:44:45.701] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:45.701] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:44:45.701] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:45.702] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:45.702] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.702] resolve() on list ... DONE
[17:44:45.702]  - Number of value chunks collected: 5
[17:44:45.702] Resolving 5 futures (chunks) ... DONE
[17:44:45.702] Reducing values from 5 chunks ...
[17:44:45.702]  - Number of values collected after concatenation: 5
[17:44:45.702]  - Number of values expected: 5
[17:44:45.702] Reducing values from 5 chunks ... DONE
[17:44:45.703] future_mapply() ... DONE
[17:44:45.703] future_mapply() ...
[17:44:45.703] Number of chunks: 1
[17:44:45.703] getGlobalsAndPackagesXApply() ...
[17:44:45.703]  - future.globals: TRUE
[17:44:45.703] getGlobalsAndPackages() ...
[17:44:45.704] Searching for globals...
[17:44:45.705] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.705] Searching for globals ... DONE
[17:44:45.705] Resolving globals: FALSE
[17:44:45.705] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.706] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.706] - globals: [1] ‘FUN’
[17:44:45.706] 
[17:44:45.706] getGlobalsAndPackages() ... DONE
[17:44:45.706]  - globals found/used: [n=1] ‘FUN’
[17:44:45.706]  - needed namespaces: [n=0] 
[17:44:45.706] Finding globals ... DONE
[17:44:45.706] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.706] List of 2
[17:44:45.706]  $ ...future.FUN:function (C, k)  
[17:44:45.706]  $ MoreArgs     : list()
[17:44:45.706]  - attr(*, "where")=List of 2
[17:44:45.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.706]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.706]  - attr(*, "resolved")= logi FALSE
[17:44:45.706]  - attr(*, "total_size")= num NA
[17:44:45.709] Packages to be attached in all futures: [n=0] 
[17:44:45.709] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.709] Number of futures (= number of chunks): 1
[17:44:45.709] Launching 1 futures (chunks) ...
[17:44:45.709] Chunk #1 of 1 ...
[17:44:45.709]  - Finding globals in '...' for chunk #1 ...
[17:44:45.709] getGlobalsAndPackages() ...
[17:44:45.710] Searching for globals...
[17:44:45.710] 
[17:44:45.710] Searching for globals ... DONE
[17:44:45.710] - globals: [0] <none>
[17:44:45.710] getGlobalsAndPackages() ... DONE
[17:44:45.710]    + additional globals found: [n=0] 
[17:44:45.710]    + additional namespaces needed: [n=0] 
[17:44:45.710]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.710]  - seeds: <none>
[17:44:45.711]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.711] getGlobalsAndPackages() ...
[17:44:45.711] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.711] Resolving globals: FALSE
[17:44:45.711] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:44:45.712] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:45.712] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.712] 
[17:44:45.712] getGlobalsAndPackages() ... DONE
[17:44:45.712] run() for ‘Future’ ...
[17:44:45.712] - state: ‘created’
[17:44:45.713] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.713]   - Field: ‘label’
[17:44:45.713]   - Field: ‘local’
[17:44:45.713]   - Field: ‘owner’
[17:44:45.713]   - Field: ‘envir’
[17:44:45.714]   - Field: ‘packages’
[17:44:45.714]   - Field: ‘gc’
[17:44:45.714]   - Field: ‘conditions’
[17:44:45.714]   - Field: ‘expr’
[17:44:45.714]   - Field: ‘uuid’
[17:44:45.714]   - Field: ‘seed’
[17:44:45.714]   - Field: ‘version’
[17:44:45.714]   - Field: ‘result’
[17:44:45.714]   - Field: ‘asynchronous’
[17:44:45.714]   - Field: ‘calls’
[17:44:45.714]   - Field: ‘globals’
[17:44:45.715]   - Field: ‘stdout’
[17:44:45.715]   - Field: ‘earlySignal’
[17:44:45.715]   - Field: ‘lazy’
[17:44:45.715]   - Field: ‘state’
[17:44:45.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.715] - Launch lazy future ...
[17:44:45.715] Packages needed by the future expression (n = 0): <none>
[17:44:45.715] Packages needed by future strategies (n = 0): <none>
[17:44:45.716] {
[17:44:45.716]     {
[17:44:45.716]         {
[17:44:45.716]             ...future.startTime <- base::Sys.time()
[17:44:45.716]             {
[17:44:45.716]                 {
[17:44:45.716]                   {
[17:44:45.716]                     base::local({
[17:44:45.716]                       has_future <- base::requireNamespace("future", 
[17:44:45.716]                         quietly = TRUE)
[17:44:45.716]                       if (has_future) {
[17:44:45.716]                         ns <- base::getNamespace("future")
[17:44:45.716]                         version <- ns[[".package"]][["version"]]
[17:44:45.716]                         if (is.null(version)) 
[17:44:45.716]                           version <- utils::packageVersion("future")
[17:44:45.716]                       }
[17:44:45.716]                       else {
[17:44:45.716]                         version <- NULL
[17:44:45.716]                       }
[17:44:45.716]                       if (!has_future || version < "1.8.0") {
[17:44:45.716]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.716]                           "", base::R.version$version.string), 
[17:44:45.716]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.716]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.716]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.716]                             "release", "version")], collapse = " "), 
[17:44:45.716]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.716]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.716]                           info)
[17:44:45.716]                         info <- base::paste(info, collapse = "; ")
[17:44:45.716]                         if (!has_future) {
[17:44:45.716]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.716]                             info)
[17:44:45.716]                         }
[17:44:45.716]                         else {
[17:44:45.716]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.716]                             info, version)
[17:44:45.716]                         }
[17:44:45.716]                         base::stop(msg)
[17:44:45.716]                       }
[17:44:45.716]                     })
[17:44:45.716]                   }
[17:44:45.716]                   ...future.strategy.old <- future::plan("list")
[17:44:45.716]                   options(future.plan = NULL)
[17:44:45.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.716]                 }
[17:44:45.716]                 ...future.workdir <- getwd()
[17:44:45.716]             }
[17:44:45.716]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.716]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.716]         }
[17:44:45.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.716]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.716]             base::names(...future.oldOptions))
[17:44:45.716]     }
[17:44:45.716]     if (FALSE) {
[17:44:45.716]     }
[17:44:45.716]     else {
[17:44:45.716]         if (TRUE) {
[17:44:45.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.716]                 open = "w")
[17:44:45.716]         }
[17:44:45.716]         else {
[17:44:45.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.716]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.716]         }
[17:44:45.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.716]             base::sink(type = "output", split = FALSE)
[17:44:45.716]             base::close(...future.stdout)
[17:44:45.716]         }, add = TRUE)
[17:44:45.716]     }
[17:44:45.716]     ...future.frame <- base::sys.nframe()
[17:44:45.716]     ...future.conditions <- base::list()
[17:44:45.716]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.716]     if (FALSE) {
[17:44:45.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.716]     }
[17:44:45.716]     ...future.result <- base::tryCatch({
[17:44:45.716]         base::withCallingHandlers({
[17:44:45.716]             ...future.value <- base::withVisible(base::local({
[17:44:45.716]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.716]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.716]                   ...future.globals.maxSize)) {
[17:44:45.716]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.716]                   on.exit(options(oopts), add = TRUE)
[17:44:45.716]                 }
[17:44:45.716]                 {
[17:44:45.716]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.716]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.716]                     USE.NAMES = FALSE)
[17:44:45.716]                   do.call(mapply, args = args)
[17:44:45.716]                 }
[17:44:45.716]             }))
[17:44:45.716]             future::FutureResult(value = ...future.value$value, 
[17:44:45.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.716]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.716]                     ...future.globalenv.names))
[17:44:45.716]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.716]         }, condition = base::local({
[17:44:45.716]             c <- base::c
[17:44:45.716]             inherits <- base::inherits
[17:44:45.716]             invokeRestart <- base::invokeRestart
[17:44:45.716]             length <- base::length
[17:44:45.716]             list <- base::list
[17:44:45.716]             seq.int <- base::seq.int
[17:44:45.716]             signalCondition <- base::signalCondition
[17:44:45.716]             sys.calls <- base::sys.calls
[17:44:45.716]             `[[` <- base::`[[`
[17:44:45.716]             `+` <- base::`+`
[17:44:45.716]             `<<-` <- base::`<<-`
[17:44:45.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.716]                   3L)]
[17:44:45.716]             }
[17:44:45.716]             function(cond) {
[17:44:45.716]                 is_error <- inherits(cond, "error")
[17:44:45.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.716]                   NULL)
[17:44:45.716]                 if (is_error) {
[17:44:45.716]                   sessionInformation <- function() {
[17:44:45.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.716]                       search = base::search(), system = base::Sys.info())
[17:44:45.716]                   }
[17:44:45.716]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.716]                     cond$call), session = sessionInformation(), 
[17:44:45.716]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.716]                   signalCondition(cond)
[17:44:45.716]                 }
[17:44:45.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.716]                 "immediateCondition"))) {
[17:44:45.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.716]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.716]                   if (TRUE && !signal) {
[17:44:45.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.716]                     {
[17:44:45.716]                       inherits <- base::inherits
[17:44:45.716]                       invokeRestart <- base::invokeRestart
[17:44:45.716]                       is.null <- base::is.null
[17:44:45.716]                       muffled <- FALSE
[17:44:45.716]                       if (inherits(cond, "message")) {
[17:44:45.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.716]                         if (muffled) 
[17:44:45.716]                           invokeRestart("muffleMessage")
[17:44:45.716]                       }
[17:44:45.716]                       else if (inherits(cond, "warning")) {
[17:44:45.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.716]                         if (muffled) 
[17:44:45.716]                           invokeRestart("muffleWarning")
[17:44:45.716]                       }
[17:44:45.716]                       else if (inherits(cond, "condition")) {
[17:44:45.716]                         if (!is.null(pattern)) {
[17:44:45.716]                           computeRestarts <- base::computeRestarts
[17:44:45.716]                           grepl <- base::grepl
[17:44:45.716]                           restarts <- computeRestarts(cond)
[17:44:45.716]                           for (restart in restarts) {
[17:44:45.716]                             name <- restart$name
[17:44:45.716]                             if (is.null(name)) 
[17:44:45.716]                               next
[17:44:45.716]                             if (!grepl(pattern, name)) 
[17:44:45.716]                               next
[17:44:45.716]                             invokeRestart(restart)
[17:44:45.716]                             muffled <- TRUE
[17:44:45.716]                             break
[17:44:45.716]                           }
[17:44:45.716]                         }
[17:44:45.716]                       }
[17:44:45.716]                       invisible(muffled)
[17:44:45.716]                     }
[17:44:45.716]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.716]                   }
[17:44:45.716]                 }
[17:44:45.716]                 else {
[17:44:45.716]                   if (TRUE) {
[17:44:45.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.716]                     {
[17:44:45.716]                       inherits <- base::inherits
[17:44:45.716]                       invokeRestart <- base::invokeRestart
[17:44:45.716]                       is.null <- base::is.null
[17:44:45.716]                       muffled <- FALSE
[17:44:45.716]                       if (inherits(cond, "message")) {
[17:44:45.716]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.716]                         if (muffled) 
[17:44:45.716]                           invokeRestart("muffleMessage")
[17:44:45.716]                       }
[17:44:45.716]                       else if (inherits(cond, "warning")) {
[17:44:45.716]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.716]                         if (muffled) 
[17:44:45.716]                           invokeRestart("muffleWarning")
[17:44:45.716]                       }
[17:44:45.716]                       else if (inherits(cond, "condition")) {
[17:44:45.716]                         if (!is.null(pattern)) {
[17:44:45.716]                           computeRestarts <- base::computeRestarts
[17:44:45.716]                           grepl <- base::grepl
[17:44:45.716]                           restarts <- computeRestarts(cond)
[17:44:45.716]                           for (restart in restarts) {
[17:44:45.716]                             name <- restart$name
[17:44:45.716]                             if (is.null(name)) 
[17:44:45.716]                               next
[17:44:45.716]                             if (!grepl(pattern, name)) 
[17:44:45.716]                               next
[17:44:45.716]                             invokeRestart(restart)
[17:44:45.716]                             muffled <- TRUE
[17:44:45.716]                             break
[17:44:45.716]                           }
[17:44:45.716]                         }
[17:44:45.716]                       }
[17:44:45.716]                       invisible(muffled)
[17:44:45.716]                     }
[17:44:45.716]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.716]                   }
[17:44:45.716]                 }
[17:44:45.716]             }
[17:44:45.716]         }))
[17:44:45.716]     }, error = function(ex) {
[17:44:45.716]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.716]                 ...future.rng), started = ...future.startTime, 
[17:44:45.716]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.716]             version = "1.8"), class = "FutureResult")
[17:44:45.716]     }, finally = {
[17:44:45.716]         if (!identical(...future.workdir, getwd())) 
[17:44:45.716]             setwd(...future.workdir)
[17:44:45.716]         {
[17:44:45.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.716]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.716]             }
[17:44:45.716]             base::options(...future.oldOptions)
[17:44:45.716]             if (.Platform$OS.type == "windows") {
[17:44:45.716]                 old_names <- names(...future.oldEnvVars)
[17:44:45.716]                 envs <- base::Sys.getenv()
[17:44:45.716]                 names <- names(envs)
[17:44:45.716]                 common <- intersect(names, old_names)
[17:44:45.716]                 added <- setdiff(names, old_names)
[17:44:45.716]                 removed <- setdiff(old_names, names)
[17:44:45.716]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.716]                   envs[common]]
[17:44:45.716]                 NAMES <- toupper(changed)
[17:44:45.716]                 args <- list()
[17:44:45.716]                 for (kk in seq_along(NAMES)) {
[17:44:45.716]                   name <- changed[[kk]]
[17:44:45.716]                   NAME <- NAMES[[kk]]
[17:44:45.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.716]                     next
[17:44:45.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.716]                 }
[17:44:45.716]                 NAMES <- toupper(added)
[17:44:45.716]                 for (kk in seq_along(NAMES)) {
[17:44:45.716]                   name <- added[[kk]]
[17:44:45.716]                   NAME <- NAMES[[kk]]
[17:44:45.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.716]                     next
[17:44:45.716]                   args[[name]] <- ""
[17:44:45.716]                 }
[17:44:45.716]                 NAMES <- toupper(removed)
[17:44:45.716]                 for (kk in seq_along(NAMES)) {
[17:44:45.716]                   name <- removed[[kk]]
[17:44:45.716]                   NAME <- NAMES[[kk]]
[17:44:45.716]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.716]                     next
[17:44:45.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.716]                 }
[17:44:45.716]                 if (length(args) > 0) 
[17:44:45.716]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.716]             }
[17:44:45.716]             else {
[17:44:45.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.716]             }
[17:44:45.716]             {
[17:44:45.716]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.716]                   0L) {
[17:44:45.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.716]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.716]                   base::options(opts)
[17:44:45.716]                 }
[17:44:45.716]                 {
[17:44:45.716]                   {
[17:44:45.716]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.716]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.716]                     -484569582L), envir = base::globalenv(), 
[17:44:45.716]                       inherits = FALSE)
[17:44:45.716]                     NULL
[17:44:45.716]                   }
[17:44:45.716]                   options(future.plan = NULL)
[17:44:45.716]                   if (is.na(NA_character_)) 
[17:44:45.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.716]                     .init = FALSE)
[17:44:45.716]                 }
[17:44:45.716]             }
[17:44:45.716]         }
[17:44:45.716]     })
[17:44:45.716]     if (TRUE) {
[17:44:45.716]         base::sink(type = "output", split = FALSE)
[17:44:45.716]         if (TRUE) {
[17:44:45.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.716]         }
[17:44:45.716]         else {
[17:44:45.716]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.716]         }
[17:44:45.716]         base::close(...future.stdout)
[17:44:45.716]         ...future.stdout <- NULL
[17:44:45.716]     }
[17:44:45.716]     ...future.result$conditions <- ...future.conditions
[17:44:45.716]     ...future.result$finished <- base::Sys.time()
[17:44:45.716]     ...future.result
[17:44:45.716] }
[17:44:45.717] assign_globals() ...
[17:44:45.717] List of 5
[17:44:45.717]  $ ...future.FUN            :function (C, k)  
[17:44:45.717]  $ MoreArgs                 : list()
[17:44:45.717]  $ ...future.elements_ii    :List of 2
[17:44:45.717]   ..$ :List of 5
[17:44:45.717]   .. ..$ : chr "A"
[17:44:45.717]   .. ..$ : chr "B"
[17:44:45.717]   .. ..$ : chr "C"
[17:44:45.717]   .. ..$ : chr "D"
[17:44:45.717]   .. ..$ : chr "E"
[17:44:45.717]   ..$ :List of 5
[17:44:45.717]   .. ..$ : int 5
[17:44:45.717]   .. ..$ : int 4
[17:44:45.717]   .. ..$ : int 3
[17:44:45.717]   .. ..$ : int 2
[17:44:45.717]   .. ..$ : int 1
[17:44:45.717]  $ ...future.seeds_ii       : NULL
[17:44:45.717]  $ ...future.globals.maxSize: NULL
[17:44:45.717]  - attr(*, "where")=List of 5
[17:44:45.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.717]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.717]  - attr(*, "resolved")= logi FALSE
[17:44:45.717]  - attr(*, "total_size")= num 4160
[17:44:45.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.717]  - attr(*, "already-done")= logi TRUE
[17:44:45.724] - reassign environment for ‘...future.FUN’
[17:44:45.724] - copied ‘...future.FUN’ to environment
[17:44:45.724] - copied ‘MoreArgs’ to environment
[17:44:45.725] - copied ‘...future.elements_ii’ to environment
[17:44:45.726] - copied ‘...future.seeds_ii’ to environment
[17:44:45.726] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.726] assign_globals() ... done
[17:44:45.727] plan(): Setting new future strategy stack:
[17:44:45.727] List of future strategies:
[17:44:45.727] 1. sequential:
[17:44:45.727]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.727]    - tweaked: FALSE
[17:44:45.727]    - call: NULL
[17:44:45.727] plan(): nbrOfWorkers() = 1
[17:44:45.728] plan(): Setting new future strategy stack:
[17:44:45.728] List of future strategies:
[17:44:45.728] 1. sequential:
[17:44:45.728]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.728]    - tweaked: FALSE
[17:44:45.728]    - call: plan(strategy)
[17:44:45.729] plan(): nbrOfWorkers() = 1
[17:44:45.729] SequentialFuture started (and completed)
[17:44:45.729] - Launch lazy future ... done
[17:44:45.729] run() for ‘SequentialFuture’ ... done
[17:44:45.729] Created future:
[17:44:45.729] SequentialFuture:
[17:44:45.729] Label: ‘future_.mapply-1’
[17:44:45.729] Expression:
[17:44:45.729] {
[17:44:45.729]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.729]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.729]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.729]         on.exit(options(oopts), add = TRUE)
[17:44:45.729]     }
[17:44:45.729]     {
[17:44:45.729]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.729]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.729]         do.call(mapply, args = args)
[17:44:45.729]     }
[17:44:45.729] }
[17:44:45.729] Lazy evaluation: FALSE
[17:44:45.729] Asynchronous evaluation: FALSE
[17:44:45.729] Local evaluation: TRUE
[17:44:45.729] Environment: R_GlobalEnv
[17:44:45.729] Capture standard output: TRUE
[17:44:45.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.729] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.729] Packages: <none>
[17:44:45.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.729] Resolved: TRUE
[17:44:45.729] Value: 560 bytes of class ‘list’
[17:44:45.729] Early signaling: FALSE
[17:44:45.729] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.729] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.730] Chunk #1 of 1 ... DONE
[17:44:45.730] Launching 1 futures (chunks) ... DONE
[17:44:45.730] Resolving 1 futures (chunks) ...
[17:44:45.730] resolve() on list ...
[17:44:45.730]  recursive: 0
[17:44:45.731]  length: 1
[17:44:45.731] 
[17:44:45.731] resolved() for ‘SequentialFuture’ ...
[17:44:45.731] - state: ‘finished’
[17:44:45.731] - run: TRUE
[17:44:45.731] - result: ‘FutureResult’
[17:44:45.731] resolved() for ‘SequentialFuture’ ... done
[17:44:45.731] Future #1
[17:44:45.731] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.732] - nx: 1
[17:44:45.732] - relay: TRUE
[17:44:45.732] - stdout: TRUE
[17:44:45.732] - signal: TRUE
[17:44:45.732] - resignal: FALSE
[17:44:45.732] - force: TRUE
[17:44:45.732] - relayed: [n=1] FALSE
[17:44:45.732] - queued futures: [n=1] FALSE
[17:44:45.732]  - until=1
[17:44:45.732]  - relaying element #1
[17:44:45.732] - relayed: [n=1] TRUE
[17:44:45.733] - queued futures: [n=1] TRUE
[17:44:45.733] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.733]  length: 0 (resolved future 1)
[17:44:45.733] Relaying remaining futures
[17:44:45.733] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.733] - nx: 1
[17:44:45.733] - relay: TRUE
[17:44:45.733] - stdout: TRUE
[17:44:45.733] - signal: TRUE
[17:44:45.733] - resignal: FALSE
[17:44:45.733] - force: TRUE
[17:44:45.733] - relayed: [n=1] TRUE
[17:44:45.734] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.734] - relayed: [n=1] TRUE
[17:44:45.734] - queued futures: [n=1] TRUE
[17:44:45.734] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.734] resolve() on list ... DONE
[17:44:45.734]  - Number of value chunks collected: 1
[17:44:45.734] Resolving 1 futures (chunks) ... DONE
[17:44:45.734] Reducing values from 1 chunks ...
[17:44:45.734]  - Number of values collected after concatenation: 5
[17:44:45.734]  - Number of values expected: 5
[17:44:45.735] Reducing values from 1 chunks ... DONE
[17:44:45.735] future_mapply() ... DONE
[17:44:45.735] future_mapply() ...
[17:44:45.735] Number of chunks: 3
[17:44:45.735] Index remapping (attribute 'ordering'): [n = 5] 2, 5, 4, 3, 1
[17:44:45.736] getGlobalsAndPackagesXApply() ...
[17:44:45.736]  - future.globals: TRUE
[17:44:45.736] getGlobalsAndPackages() ...
[17:44:45.736] Searching for globals...
[17:44:45.737] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.737] Searching for globals ... DONE
[17:44:45.737] Resolving globals: FALSE
[17:44:45.738] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.738] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.738] - globals: [1] ‘FUN’
[17:44:45.738] 
[17:44:45.738] getGlobalsAndPackages() ... DONE
[17:44:45.738]  - globals found/used: [n=1] ‘FUN’
[17:44:45.738]  - needed namespaces: [n=0] 
[17:44:45.739] Finding globals ... DONE
[17:44:45.739] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.739] List of 2
[17:44:45.739]  $ ...future.FUN:function (C, k)  
[17:44:45.739]  $ MoreArgs     : NULL
[17:44:45.739]  - attr(*, "where")=List of 2
[17:44:45.739]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.739]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.739]  - attr(*, "resolved")= logi FALSE
[17:44:45.739]  - attr(*, "total_size")= num NA
[17:44:45.741] Packages to be attached in all futures: [n=0] 
[17:44:45.741] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.742] Number of futures (= number of chunks): 3
[17:44:45.742] Launching 3 futures (chunks) ...
[17:44:45.742] Chunk #1 of 3 ...
[17:44:45.742]  - Finding globals in '...' for chunk #1 ...
[17:44:45.742] getGlobalsAndPackages() ...
[17:44:45.742] Searching for globals...
[17:44:45.742] 
[17:44:45.743] Searching for globals ... DONE
[17:44:45.743] - globals: [0] <none>
[17:44:45.743] getGlobalsAndPackages() ... DONE
[17:44:45.743]    + additional globals found: [n=0] 
[17:44:45.743]    + additional namespaces needed: [n=0] 
[17:44:45.743]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.743]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:45.743]  - seeds: <none>
[17:44:45.743]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.743] getGlobalsAndPackages() ...
[17:44:45.744] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.744] Resolving globals: FALSE
[17:44:45.744] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:45.745] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.745] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.745] 
[17:44:45.745] getGlobalsAndPackages() ... DONE
[17:44:45.745] run() for ‘Future’ ...
[17:44:45.745] - state: ‘created’
[17:44:45.745] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.746]   - Field: ‘label’
[17:44:45.746]   - Field: ‘local’
[17:44:45.746]   - Field: ‘owner’
[17:44:45.746]   - Field: ‘envir’
[17:44:45.746]   - Field: ‘packages’
[17:44:45.746]   - Field: ‘gc’
[17:44:45.747]   - Field: ‘conditions’
[17:44:45.747]   - Field: ‘expr’
[17:44:45.747]   - Field: ‘uuid’
[17:44:45.747]   - Field: ‘seed’
[17:44:45.747]   - Field: ‘version’
[17:44:45.747]   - Field: ‘result’
[17:44:45.747]   - Field: ‘asynchronous’
[17:44:45.747]   - Field: ‘calls’
[17:44:45.747]   - Field: ‘globals’
[17:44:45.747]   - Field: ‘stdout’
[17:44:45.748]   - Field: ‘earlySignal’
[17:44:45.748]   - Field: ‘lazy’
[17:44:45.748]   - Field: ‘state’
[17:44:45.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.748] - Launch lazy future ...
[17:44:45.748] Packages needed by the future expression (n = 0): <none>
[17:44:45.748] Packages needed by future strategies (n = 0): <none>
[17:44:45.749] {
[17:44:45.749]     {
[17:44:45.749]         {
[17:44:45.749]             ...future.startTime <- base::Sys.time()
[17:44:45.749]             {
[17:44:45.749]                 {
[17:44:45.749]                   {
[17:44:45.749]                     base::local({
[17:44:45.749]                       has_future <- base::requireNamespace("future", 
[17:44:45.749]                         quietly = TRUE)
[17:44:45.749]                       if (has_future) {
[17:44:45.749]                         ns <- base::getNamespace("future")
[17:44:45.749]                         version <- ns[[".package"]][["version"]]
[17:44:45.749]                         if (is.null(version)) 
[17:44:45.749]                           version <- utils::packageVersion("future")
[17:44:45.749]                       }
[17:44:45.749]                       else {
[17:44:45.749]                         version <- NULL
[17:44:45.749]                       }
[17:44:45.749]                       if (!has_future || version < "1.8.0") {
[17:44:45.749]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.749]                           "", base::R.version$version.string), 
[17:44:45.749]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.749]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.749]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.749]                             "release", "version")], collapse = " "), 
[17:44:45.749]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.749]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.749]                           info)
[17:44:45.749]                         info <- base::paste(info, collapse = "; ")
[17:44:45.749]                         if (!has_future) {
[17:44:45.749]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.749]                             info)
[17:44:45.749]                         }
[17:44:45.749]                         else {
[17:44:45.749]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.749]                             info, version)
[17:44:45.749]                         }
[17:44:45.749]                         base::stop(msg)
[17:44:45.749]                       }
[17:44:45.749]                     })
[17:44:45.749]                   }
[17:44:45.749]                   ...future.strategy.old <- future::plan("list")
[17:44:45.749]                   options(future.plan = NULL)
[17:44:45.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.749]                 }
[17:44:45.749]                 ...future.workdir <- getwd()
[17:44:45.749]             }
[17:44:45.749]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.749]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.749]         }
[17:44:45.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.749]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:45.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.749]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.749]             base::names(...future.oldOptions))
[17:44:45.749]     }
[17:44:45.749]     if (FALSE) {
[17:44:45.749]     }
[17:44:45.749]     else {
[17:44:45.749]         if (TRUE) {
[17:44:45.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.749]                 open = "w")
[17:44:45.749]         }
[17:44:45.749]         else {
[17:44:45.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.749]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.749]         }
[17:44:45.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.749]             base::sink(type = "output", split = FALSE)
[17:44:45.749]             base::close(...future.stdout)
[17:44:45.749]         }, add = TRUE)
[17:44:45.749]     }
[17:44:45.749]     ...future.frame <- base::sys.nframe()
[17:44:45.749]     ...future.conditions <- base::list()
[17:44:45.749]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.749]     if (FALSE) {
[17:44:45.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.749]     }
[17:44:45.749]     ...future.result <- base::tryCatch({
[17:44:45.749]         base::withCallingHandlers({
[17:44:45.749]             ...future.value <- base::withVisible(base::local({
[17:44:45.749]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.749]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.749]                   ...future.globals.maxSize)) {
[17:44:45.749]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.749]                   on.exit(options(oopts), add = TRUE)
[17:44:45.749]                 }
[17:44:45.749]                 {
[17:44:45.749]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.749]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.749]                     USE.NAMES = FALSE)
[17:44:45.749]                   do.call(mapply, args = args)
[17:44:45.749]                 }
[17:44:45.749]             }))
[17:44:45.749]             future::FutureResult(value = ...future.value$value, 
[17:44:45.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.749]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.749]                     ...future.globalenv.names))
[17:44:45.749]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.749]         }, condition = base::local({
[17:44:45.749]             c <- base::c
[17:44:45.749]             inherits <- base::inherits
[17:44:45.749]             invokeRestart <- base::invokeRestart
[17:44:45.749]             length <- base::length
[17:44:45.749]             list <- base::list
[17:44:45.749]             seq.int <- base::seq.int
[17:44:45.749]             signalCondition <- base::signalCondition
[17:44:45.749]             sys.calls <- base::sys.calls
[17:44:45.749]             `[[` <- base::`[[`
[17:44:45.749]             `+` <- base::`+`
[17:44:45.749]             `<<-` <- base::`<<-`
[17:44:45.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.749]                   3L)]
[17:44:45.749]             }
[17:44:45.749]             function(cond) {
[17:44:45.749]                 is_error <- inherits(cond, "error")
[17:44:45.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.749]                   NULL)
[17:44:45.749]                 if (is_error) {
[17:44:45.749]                   sessionInformation <- function() {
[17:44:45.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.749]                       search = base::search(), system = base::Sys.info())
[17:44:45.749]                   }
[17:44:45.749]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.749]                     cond$call), session = sessionInformation(), 
[17:44:45.749]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.749]                   signalCondition(cond)
[17:44:45.749]                 }
[17:44:45.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.749]                 "immediateCondition"))) {
[17:44:45.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.749]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.749]                   if (TRUE && !signal) {
[17:44:45.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.749]                     {
[17:44:45.749]                       inherits <- base::inherits
[17:44:45.749]                       invokeRestart <- base::invokeRestart
[17:44:45.749]                       is.null <- base::is.null
[17:44:45.749]                       muffled <- FALSE
[17:44:45.749]                       if (inherits(cond, "message")) {
[17:44:45.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.749]                         if (muffled) 
[17:44:45.749]                           invokeRestart("muffleMessage")
[17:44:45.749]                       }
[17:44:45.749]                       else if (inherits(cond, "warning")) {
[17:44:45.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.749]                         if (muffled) 
[17:44:45.749]                           invokeRestart("muffleWarning")
[17:44:45.749]                       }
[17:44:45.749]                       else if (inherits(cond, "condition")) {
[17:44:45.749]                         if (!is.null(pattern)) {
[17:44:45.749]                           computeRestarts <- base::computeRestarts
[17:44:45.749]                           grepl <- base::grepl
[17:44:45.749]                           restarts <- computeRestarts(cond)
[17:44:45.749]                           for (restart in restarts) {
[17:44:45.749]                             name <- restart$name
[17:44:45.749]                             if (is.null(name)) 
[17:44:45.749]                               next
[17:44:45.749]                             if (!grepl(pattern, name)) 
[17:44:45.749]                               next
[17:44:45.749]                             invokeRestart(restart)
[17:44:45.749]                             muffled <- TRUE
[17:44:45.749]                             break
[17:44:45.749]                           }
[17:44:45.749]                         }
[17:44:45.749]                       }
[17:44:45.749]                       invisible(muffled)
[17:44:45.749]                     }
[17:44:45.749]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.749]                   }
[17:44:45.749]                 }
[17:44:45.749]                 else {
[17:44:45.749]                   if (TRUE) {
[17:44:45.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.749]                     {
[17:44:45.749]                       inherits <- base::inherits
[17:44:45.749]                       invokeRestart <- base::invokeRestart
[17:44:45.749]                       is.null <- base::is.null
[17:44:45.749]                       muffled <- FALSE
[17:44:45.749]                       if (inherits(cond, "message")) {
[17:44:45.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.749]                         if (muffled) 
[17:44:45.749]                           invokeRestart("muffleMessage")
[17:44:45.749]                       }
[17:44:45.749]                       else if (inherits(cond, "warning")) {
[17:44:45.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.749]                         if (muffled) 
[17:44:45.749]                           invokeRestart("muffleWarning")
[17:44:45.749]                       }
[17:44:45.749]                       else if (inherits(cond, "condition")) {
[17:44:45.749]                         if (!is.null(pattern)) {
[17:44:45.749]                           computeRestarts <- base::computeRestarts
[17:44:45.749]                           grepl <- base::grepl
[17:44:45.749]                           restarts <- computeRestarts(cond)
[17:44:45.749]                           for (restart in restarts) {
[17:44:45.749]                             name <- restart$name
[17:44:45.749]                             if (is.null(name)) 
[17:44:45.749]                               next
[17:44:45.749]                             if (!grepl(pattern, name)) 
[17:44:45.749]                               next
[17:44:45.749]                             invokeRestart(restart)
[17:44:45.749]                             muffled <- TRUE
[17:44:45.749]                             break
[17:44:45.749]                           }
[17:44:45.749]                         }
[17:44:45.749]                       }
[17:44:45.749]                       invisible(muffled)
[17:44:45.749]                     }
[17:44:45.749]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.749]                   }
[17:44:45.749]                 }
[17:44:45.749]             }
[17:44:45.749]         }))
[17:44:45.749]     }, error = function(ex) {
[17:44:45.749]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.749]                 ...future.rng), started = ...future.startTime, 
[17:44:45.749]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.749]             version = "1.8"), class = "FutureResult")
[17:44:45.749]     }, finally = {
[17:44:45.749]         if (!identical(...future.workdir, getwd())) 
[17:44:45.749]             setwd(...future.workdir)
[17:44:45.749]         {
[17:44:45.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.749]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.749]             }
[17:44:45.749]             base::options(...future.oldOptions)
[17:44:45.749]             if (.Platform$OS.type == "windows") {
[17:44:45.749]                 old_names <- names(...future.oldEnvVars)
[17:44:45.749]                 envs <- base::Sys.getenv()
[17:44:45.749]                 names <- names(envs)
[17:44:45.749]                 common <- intersect(names, old_names)
[17:44:45.749]                 added <- setdiff(names, old_names)
[17:44:45.749]                 removed <- setdiff(old_names, names)
[17:44:45.749]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.749]                   envs[common]]
[17:44:45.749]                 NAMES <- toupper(changed)
[17:44:45.749]                 args <- list()
[17:44:45.749]                 for (kk in seq_along(NAMES)) {
[17:44:45.749]                   name <- changed[[kk]]
[17:44:45.749]                   NAME <- NAMES[[kk]]
[17:44:45.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.749]                     next
[17:44:45.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.749]                 }
[17:44:45.749]                 NAMES <- toupper(added)
[17:44:45.749]                 for (kk in seq_along(NAMES)) {
[17:44:45.749]                   name <- added[[kk]]
[17:44:45.749]                   NAME <- NAMES[[kk]]
[17:44:45.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.749]                     next
[17:44:45.749]                   args[[name]] <- ""
[17:44:45.749]                 }
[17:44:45.749]                 NAMES <- toupper(removed)
[17:44:45.749]                 for (kk in seq_along(NAMES)) {
[17:44:45.749]                   name <- removed[[kk]]
[17:44:45.749]                   NAME <- NAMES[[kk]]
[17:44:45.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.749]                     next
[17:44:45.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.749]                 }
[17:44:45.749]                 if (length(args) > 0) 
[17:44:45.749]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.749]             }
[17:44:45.749]             else {
[17:44:45.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.749]             }
[17:44:45.749]             {
[17:44:45.749]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.749]                   0L) {
[17:44:45.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.749]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.749]                   base::options(opts)
[17:44:45.749]                 }
[17:44:45.749]                 {
[17:44:45.749]                   {
[17:44:45.749]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.749]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.749]                     -484569582L), envir = base::globalenv(), 
[17:44:45.749]                       inherits = FALSE)
[17:44:45.749]                     NULL
[17:44:45.749]                   }
[17:44:45.749]                   options(future.plan = NULL)
[17:44:45.749]                   if (is.na(NA_character_)) 
[17:44:45.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.749]                     .init = FALSE)
[17:44:45.749]                 }
[17:44:45.749]             }
[17:44:45.749]         }
[17:44:45.749]     })
[17:44:45.749]     if (TRUE) {
[17:44:45.749]         base::sink(type = "output", split = FALSE)
[17:44:45.749]         if (TRUE) {
[17:44:45.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.749]         }
[17:44:45.749]         else {
[17:44:45.749]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.749]         }
[17:44:45.749]         base::close(...future.stdout)
[17:44:45.749]         ...future.stdout <- NULL
[17:44:45.749]     }
[17:44:45.749]     ...future.result$conditions <- ...future.conditions
[17:44:45.749]     ...future.result$finished <- base::Sys.time()
[17:44:45.749]     ...future.result
[17:44:45.749] }
[17:44:45.750] assign_globals() ...
[17:44:45.750] List of 5
[17:44:45.750]  $ ...future.FUN            :function (C, k)  
[17:44:45.750]  $ MoreArgs                 : NULL
[17:44:45.750]  $ ...future.elements_ii    :List of 2
[17:44:45.750]   ..$ :List of 2
[17:44:45.750]   .. ..$ : chr "B"
[17:44:45.750]   .. ..$ : chr "E"
[17:44:45.750]   ..$ :List of 2
[17:44:45.750]   .. ..$ : int 4
[17:44:45.750]   .. ..$ : int 1
[17:44:45.750]  $ ...future.seeds_ii       : NULL
[17:44:45.750]  $ ...future.globals.maxSize: NULL
[17:44:45.750]  - attr(*, "where")=List of 5
[17:44:45.750]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.750]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.750]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.750]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.750]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.750]  - attr(*, "resolved")= logi FALSE
[17:44:45.750]  - attr(*, "total_size")= num 3656
[17:44:45.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.750]  - attr(*, "already-done")= logi TRUE
[17:44:45.758] - reassign environment for ‘...future.FUN’
[17:44:45.759] - copied ‘...future.FUN’ to environment
[17:44:45.759] - copied ‘MoreArgs’ to environment
[17:44:45.759] - copied ‘...future.elements_ii’ to environment
[17:44:45.759] - copied ‘...future.seeds_ii’ to environment
[17:44:45.759] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.759] assign_globals() ... done
[17:44:45.759] plan(): Setting new future strategy stack:
[17:44:45.759] List of future strategies:
[17:44:45.759] 1. sequential:
[17:44:45.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.759]    - tweaked: FALSE
[17:44:45.759]    - call: NULL
[17:44:45.760] plan(): nbrOfWorkers() = 1
[17:44:45.761] plan(): Setting new future strategy stack:
[17:44:45.761] List of future strategies:
[17:44:45.761] 1. sequential:
[17:44:45.761]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.761]    - tweaked: FALSE
[17:44:45.761]    - call: plan(strategy)
[17:44:45.761] plan(): nbrOfWorkers() = 1
[17:44:45.761] SequentialFuture started (and completed)
[17:44:45.762] - Launch lazy future ... done
[17:44:45.762] run() for ‘SequentialFuture’ ... done
[17:44:45.762] Created future:
[17:44:45.762] SequentialFuture:
[17:44:45.762] Label: ‘future_mapply-1’
[17:44:45.762] Expression:
[17:44:45.762] {
[17:44:45.762]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.762]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.762]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.762]         on.exit(options(oopts), add = TRUE)
[17:44:45.762]     }
[17:44:45.762]     {
[17:44:45.762]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.762]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.762]         do.call(mapply, args = args)
[17:44:45.762]     }
[17:44:45.762] }
[17:44:45.762] Lazy evaluation: FALSE
[17:44:45.762] Asynchronous evaluation: FALSE
[17:44:45.762] Local evaluation: TRUE
[17:44:45.762] Environment: R_GlobalEnv
[17:44:45.762] Capture standard output: TRUE
[17:44:45.762] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.762] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.762] Packages: <none>
[17:44:45.762] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.762] Resolved: TRUE
[17:44:45.762] Value: 224 bytes of class ‘list’
[17:44:45.762] Early signaling: FALSE
[17:44:45.762] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.762] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.763] Chunk #1 of 3 ... DONE
[17:44:45.763] Chunk #2 of 3 ...
[17:44:45.763]  - Finding globals in '...' for chunk #2 ...
[17:44:45.763] getGlobalsAndPackages() ...
[17:44:45.763] Searching for globals...
[17:44:45.764] 
[17:44:45.764] Searching for globals ... DONE
[17:44:45.764] - globals: [0] <none>
[17:44:45.764] getGlobalsAndPackages() ... DONE
[17:44:45.764]    + additional globals found: [n=0] 
[17:44:45.764]    + additional namespaces needed: [n=0] 
[17:44:45.764]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:45.764]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:45.765]  - seeds: <none>
[17:44:45.765]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.765] getGlobalsAndPackages() ...
[17:44:45.765] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.765] Resolving globals: FALSE
[17:44:45.765] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:45.766] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.766] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.766] 
[17:44:45.766] getGlobalsAndPackages() ... DONE
[17:44:45.767] run() for ‘Future’ ...
[17:44:45.767] - state: ‘created’
[17:44:45.767] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.767] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.767]   - Field: ‘label’
[17:44:45.767]   - Field: ‘local’
[17:44:45.768]   - Field: ‘owner’
[17:44:45.768]   - Field: ‘envir’
[17:44:45.768]   - Field: ‘packages’
[17:44:45.768]   - Field: ‘gc’
[17:44:45.768]   - Field: ‘conditions’
[17:44:45.768]   - Field: ‘expr’
[17:44:45.768]   - Field: ‘uuid’
[17:44:45.768]   - Field: ‘seed’
[17:44:45.768]   - Field: ‘version’
[17:44:45.769]   - Field: ‘result’
[17:44:45.769]   - Field: ‘asynchronous’
[17:44:45.769]   - Field: ‘calls’
[17:44:45.769]   - Field: ‘globals’
[17:44:45.769]   - Field: ‘stdout’
[17:44:45.769]   - Field: ‘earlySignal’
[17:44:45.769]   - Field: ‘lazy’
[17:44:45.769]   - Field: ‘state’
[17:44:45.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.769] - Launch lazy future ...
[17:44:45.770] Packages needed by the future expression (n = 0): <none>
[17:44:45.770] Packages needed by future strategies (n = 0): <none>
[17:44:45.770] {
[17:44:45.770]     {
[17:44:45.770]         {
[17:44:45.770]             ...future.startTime <- base::Sys.time()
[17:44:45.770]             {
[17:44:45.770]                 {
[17:44:45.770]                   {
[17:44:45.770]                     base::local({
[17:44:45.770]                       has_future <- base::requireNamespace("future", 
[17:44:45.770]                         quietly = TRUE)
[17:44:45.770]                       if (has_future) {
[17:44:45.770]                         ns <- base::getNamespace("future")
[17:44:45.770]                         version <- ns[[".package"]][["version"]]
[17:44:45.770]                         if (is.null(version)) 
[17:44:45.770]                           version <- utils::packageVersion("future")
[17:44:45.770]                       }
[17:44:45.770]                       else {
[17:44:45.770]                         version <- NULL
[17:44:45.770]                       }
[17:44:45.770]                       if (!has_future || version < "1.8.0") {
[17:44:45.770]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.770]                           "", base::R.version$version.string), 
[17:44:45.770]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.770]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.770]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.770]                             "release", "version")], collapse = " "), 
[17:44:45.770]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.770]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.770]                           info)
[17:44:45.770]                         info <- base::paste(info, collapse = "; ")
[17:44:45.770]                         if (!has_future) {
[17:44:45.770]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.770]                             info)
[17:44:45.770]                         }
[17:44:45.770]                         else {
[17:44:45.770]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.770]                             info, version)
[17:44:45.770]                         }
[17:44:45.770]                         base::stop(msg)
[17:44:45.770]                       }
[17:44:45.770]                     })
[17:44:45.770]                   }
[17:44:45.770]                   ...future.strategy.old <- future::plan("list")
[17:44:45.770]                   options(future.plan = NULL)
[17:44:45.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.770]                 }
[17:44:45.770]                 ...future.workdir <- getwd()
[17:44:45.770]             }
[17:44:45.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.770]         }
[17:44:45.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.770]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:45.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.770]             base::names(...future.oldOptions))
[17:44:45.770]     }
[17:44:45.770]     if (FALSE) {
[17:44:45.770]     }
[17:44:45.770]     else {
[17:44:45.770]         if (TRUE) {
[17:44:45.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.770]                 open = "w")
[17:44:45.770]         }
[17:44:45.770]         else {
[17:44:45.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.770]         }
[17:44:45.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.770]             base::sink(type = "output", split = FALSE)
[17:44:45.770]             base::close(...future.stdout)
[17:44:45.770]         }, add = TRUE)
[17:44:45.770]     }
[17:44:45.770]     ...future.frame <- base::sys.nframe()
[17:44:45.770]     ...future.conditions <- base::list()
[17:44:45.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.770]     if (FALSE) {
[17:44:45.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.770]     }
[17:44:45.770]     ...future.result <- base::tryCatch({
[17:44:45.770]         base::withCallingHandlers({
[17:44:45.770]             ...future.value <- base::withVisible(base::local({
[17:44:45.770]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.770]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.770]                   ...future.globals.maxSize)) {
[17:44:45.770]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.770]                   on.exit(options(oopts), add = TRUE)
[17:44:45.770]                 }
[17:44:45.770]                 {
[17:44:45.770]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.770]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.770]                     USE.NAMES = FALSE)
[17:44:45.770]                   do.call(mapply, args = args)
[17:44:45.770]                 }
[17:44:45.770]             }))
[17:44:45.770]             future::FutureResult(value = ...future.value$value, 
[17:44:45.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.770]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.770]                     ...future.globalenv.names))
[17:44:45.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.770]         }, condition = base::local({
[17:44:45.770]             c <- base::c
[17:44:45.770]             inherits <- base::inherits
[17:44:45.770]             invokeRestart <- base::invokeRestart
[17:44:45.770]             length <- base::length
[17:44:45.770]             list <- base::list
[17:44:45.770]             seq.int <- base::seq.int
[17:44:45.770]             signalCondition <- base::signalCondition
[17:44:45.770]             sys.calls <- base::sys.calls
[17:44:45.770]             `[[` <- base::`[[`
[17:44:45.770]             `+` <- base::`+`
[17:44:45.770]             `<<-` <- base::`<<-`
[17:44:45.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.770]                   3L)]
[17:44:45.770]             }
[17:44:45.770]             function(cond) {
[17:44:45.770]                 is_error <- inherits(cond, "error")
[17:44:45.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.770]                   NULL)
[17:44:45.770]                 if (is_error) {
[17:44:45.770]                   sessionInformation <- function() {
[17:44:45.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.770]                       search = base::search(), system = base::Sys.info())
[17:44:45.770]                   }
[17:44:45.770]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.770]                     cond$call), session = sessionInformation(), 
[17:44:45.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.770]                   signalCondition(cond)
[17:44:45.770]                 }
[17:44:45.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.770]                 "immediateCondition"))) {
[17:44:45.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.770]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.770]                   if (TRUE && !signal) {
[17:44:45.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.770]                     {
[17:44:45.770]                       inherits <- base::inherits
[17:44:45.770]                       invokeRestart <- base::invokeRestart
[17:44:45.770]                       is.null <- base::is.null
[17:44:45.770]                       muffled <- FALSE
[17:44:45.770]                       if (inherits(cond, "message")) {
[17:44:45.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.770]                         if (muffled) 
[17:44:45.770]                           invokeRestart("muffleMessage")
[17:44:45.770]                       }
[17:44:45.770]                       else if (inherits(cond, "warning")) {
[17:44:45.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.770]                         if (muffled) 
[17:44:45.770]                           invokeRestart("muffleWarning")
[17:44:45.770]                       }
[17:44:45.770]                       else if (inherits(cond, "condition")) {
[17:44:45.770]                         if (!is.null(pattern)) {
[17:44:45.770]                           computeRestarts <- base::computeRestarts
[17:44:45.770]                           grepl <- base::grepl
[17:44:45.770]                           restarts <- computeRestarts(cond)
[17:44:45.770]                           for (restart in restarts) {
[17:44:45.770]                             name <- restart$name
[17:44:45.770]                             if (is.null(name)) 
[17:44:45.770]                               next
[17:44:45.770]                             if (!grepl(pattern, name)) 
[17:44:45.770]                               next
[17:44:45.770]                             invokeRestart(restart)
[17:44:45.770]                             muffled <- TRUE
[17:44:45.770]                             break
[17:44:45.770]                           }
[17:44:45.770]                         }
[17:44:45.770]                       }
[17:44:45.770]                       invisible(muffled)
[17:44:45.770]                     }
[17:44:45.770]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.770]                   }
[17:44:45.770]                 }
[17:44:45.770]                 else {
[17:44:45.770]                   if (TRUE) {
[17:44:45.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.770]                     {
[17:44:45.770]                       inherits <- base::inherits
[17:44:45.770]                       invokeRestart <- base::invokeRestart
[17:44:45.770]                       is.null <- base::is.null
[17:44:45.770]                       muffled <- FALSE
[17:44:45.770]                       if (inherits(cond, "message")) {
[17:44:45.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.770]                         if (muffled) 
[17:44:45.770]                           invokeRestart("muffleMessage")
[17:44:45.770]                       }
[17:44:45.770]                       else if (inherits(cond, "warning")) {
[17:44:45.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.770]                         if (muffled) 
[17:44:45.770]                           invokeRestart("muffleWarning")
[17:44:45.770]                       }
[17:44:45.770]                       else if (inherits(cond, "condition")) {
[17:44:45.770]                         if (!is.null(pattern)) {
[17:44:45.770]                           computeRestarts <- base::computeRestarts
[17:44:45.770]                           grepl <- base::grepl
[17:44:45.770]                           restarts <- computeRestarts(cond)
[17:44:45.770]                           for (restart in restarts) {
[17:44:45.770]                             name <- restart$name
[17:44:45.770]                             if (is.null(name)) 
[17:44:45.770]                               next
[17:44:45.770]                             if (!grepl(pattern, name)) 
[17:44:45.770]                               next
[17:44:45.770]                             invokeRestart(restart)
[17:44:45.770]                             muffled <- TRUE
[17:44:45.770]                             break
[17:44:45.770]                           }
[17:44:45.770]                         }
[17:44:45.770]                       }
[17:44:45.770]                       invisible(muffled)
[17:44:45.770]                     }
[17:44:45.770]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.770]                   }
[17:44:45.770]                 }
[17:44:45.770]             }
[17:44:45.770]         }))
[17:44:45.770]     }, error = function(ex) {
[17:44:45.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.770]                 ...future.rng), started = ...future.startTime, 
[17:44:45.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.770]             version = "1.8"), class = "FutureResult")
[17:44:45.770]     }, finally = {
[17:44:45.770]         if (!identical(...future.workdir, getwd())) 
[17:44:45.770]             setwd(...future.workdir)
[17:44:45.770]         {
[17:44:45.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.770]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.770]             }
[17:44:45.770]             base::options(...future.oldOptions)
[17:44:45.770]             if (.Platform$OS.type == "windows") {
[17:44:45.770]                 old_names <- names(...future.oldEnvVars)
[17:44:45.770]                 envs <- base::Sys.getenv()
[17:44:45.770]                 names <- names(envs)
[17:44:45.770]                 common <- intersect(names, old_names)
[17:44:45.770]                 added <- setdiff(names, old_names)
[17:44:45.770]                 removed <- setdiff(old_names, names)
[17:44:45.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.770]                   envs[common]]
[17:44:45.770]                 NAMES <- toupper(changed)
[17:44:45.770]                 args <- list()
[17:44:45.770]                 for (kk in seq_along(NAMES)) {
[17:44:45.770]                   name <- changed[[kk]]
[17:44:45.770]                   NAME <- NAMES[[kk]]
[17:44:45.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.770]                     next
[17:44:45.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.770]                 }
[17:44:45.770]                 NAMES <- toupper(added)
[17:44:45.770]                 for (kk in seq_along(NAMES)) {
[17:44:45.770]                   name <- added[[kk]]
[17:44:45.770]                   NAME <- NAMES[[kk]]
[17:44:45.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.770]                     next
[17:44:45.770]                   args[[name]] <- ""
[17:44:45.770]                 }
[17:44:45.770]                 NAMES <- toupper(removed)
[17:44:45.770]                 for (kk in seq_along(NAMES)) {
[17:44:45.770]                   name <- removed[[kk]]
[17:44:45.770]                   NAME <- NAMES[[kk]]
[17:44:45.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.770]                     next
[17:44:45.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.770]                 }
[17:44:45.770]                 if (length(args) > 0) 
[17:44:45.770]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.770]             }
[17:44:45.770]             else {
[17:44:45.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.770]             }
[17:44:45.770]             {
[17:44:45.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.770]                   0L) {
[17:44:45.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.770]                   base::options(opts)
[17:44:45.770]                 }
[17:44:45.770]                 {
[17:44:45.770]                   {
[17:44:45.770]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.770]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.770]                     -484569582L), envir = base::globalenv(), 
[17:44:45.770]                       inherits = FALSE)
[17:44:45.770]                     NULL
[17:44:45.770]                   }
[17:44:45.770]                   options(future.plan = NULL)
[17:44:45.770]                   if (is.na(NA_character_)) 
[17:44:45.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.770]                     .init = FALSE)
[17:44:45.770]                 }
[17:44:45.770]             }
[17:44:45.770]         }
[17:44:45.770]     })
[17:44:45.770]     if (TRUE) {
[17:44:45.770]         base::sink(type = "output", split = FALSE)
[17:44:45.770]         if (TRUE) {
[17:44:45.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.770]         }
[17:44:45.770]         else {
[17:44:45.770]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.770]         }
[17:44:45.770]         base::close(...future.stdout)
[17:44:45.770]         ...future.stdout <- NULL
[17:44:45.770]     }
[17:44:45.770]     ...future.result$conditions <- ...future.conditions
[17:44:45.770]     ...future.result$finished <- base::Sys.time()
[17:44:45.770]     ...future.result
[17:44:45.770] }
[17:44:45.772] assign_globals() ...
[17:44:45.772] List of 5
[17:44:45.772]  $ ...future.FUN            :function (C, k)  
[17:44:45.772]  $ MoreArgs                 : NULL
[17:44:45.772]  $ ...future.elements_ii    :List of 2
[17:44:45.772]   ..$ :List of 1
[17:44:45.772]   .. ..$ : chr "D"
[17:44:45.772]   ..$ :List of 1
[17:44:45.772]   .. ..$ : int 2
[17:44:45.772]  $ ...future.seeds_ii       : NULL
[17:44:45.772]  $ ...future.globals.maxSize: NULL
[17:44:45.772]  - attr(*, "where")=List of 5
[17:44:45.772]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.772]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.772]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.772]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.772]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.772]  - attr(*, "resolved")= logi FALSE
[17:44:45.772]  - attr(*, "total_size")= num 3488
[17:44:45.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.772]  - attr(*, "already-done")= logi TRUE
[17:44:45.777] - reassign environment for ‘...future.FUN’
[17:44:45.777] - copied ‘...future.FUN’ to environment
[17:44:45.777] - copied ‘MoreArgs’ to environment
[17:44:45.777] - copied ‘...future.elements_ii’ to environment
[17:44:45.778] - copied ‘...future.seeds_ii’ to environment
[17:44:45.778] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.778] assign_globals() ... done
[17:44:45.778] plan(): Setting new future strategy stack:
[17:44:45.778] List of future strategies:
[17:44:45.778] 1. sequential:
[17:44:45.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.778]    - tweaked: FALSE
[17:44:45.778]    - call: NULL
[17:44:45.779] plan(): nbrOfWorkers() = 1
[17:44:45.779] plan(): Setting new future strategy stack:
[17:44:45.780] List of future strategies:
[17:44:45.780] 1. sequential:
[17:44:45.780]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.780]    - tweaked: FALSE
[17:44:45.780]    - call: plan(strategy)
[17:44:45.780] plan(): nbrOfWorkers() = 1
[17:44:45.780] SequentialFuture started (and completed)
[17:44:45.780] - Launch lazy future ... done
[17:44:45.780] run() for ‘SequentialFuture’ ... done
[17:44:45.781] Created future:
[17:44:45.781] SequentialFuture:
[17:44:45.781] Label: ‘future_mapply-2’
[17:44:45.781] Expression:
[17:44:45.781] {
[17:44:45.781]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.781]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.781]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.781]         on.exit(options(oopts), add = TRUE)
[17:44:45.781]     }
[17:44:45.781]     {
[17:44:45.781]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.781]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.781]         do.call(mapply, args = args)
[17:44:45.781]     }
[17:44:45.781] }
[17:44:45.781] Lazy evaluation: FALSE
[17:44:45.781] Asynchronous evaluation: FALSE
[17:44:45.781] Local evaluation: TRUE
[17:44:45.781] Environment: R_GlobalEnv
[17:44:45.781] Capture standard output: TRUE
[17:44:45.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.781] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.781] Packages: <none>
[17:44:45.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.781] Resolved: TRUE
[17:44:45.781] Value: 112 bytes of class ‘list’
[17:44:45.781] Early signaling: FALSE
[17:44:45.781] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.781] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.782] Chunk #2 of 3 ... DONE
[17:44:45.782] Chunk #3 of 3 ...
[17:44:45.784]  - Finding globals in '...' for chunk #3 ...
[17:44:45.784] getGlobalsAndPackages() ...
[17:44:45.784] Searching for globals...
[17:44:45.784] 
[17:44:45.784] Searching for globals ... DONE
[17:44:45.785] - globals: [0] <none>
[17:44:45.785] getGlobalsAndPackages() ... DONE
[17:44:45.785]    + additional globals found: [n=0] 
[17:44:45.785]    + additional namespaces needed: [n=0] 
[17:44:45.785]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:45.785]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:45.785]  - seeds: <none>
[17:44:45.785]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.786] getGlobalsAndPackages() ...
[17:44:45.786] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.786] Resolving globals: FALSE
[17:44:45.786] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:45.787] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.787] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.787] 
[17:44:45.787] getGlobalsAndPackages() ... DONE
[17:44:45.788] run() for ‘Future’ ...
[17:44:45.788] - state: ‘created’
[17:44:45.788] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.788] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.788]   - Field: ‘label’
[17:44:45.788]   - Field: ‘local’
[17:44:45.788]   - Field: ‘owner’
[17:44:45.789]   - Field: ‘envir’
[17:44:45.789]   - Field: ‘packages’
[17:44:45.789]   - Field: ‘gc’
[17:44:45.789]   - Field: ‘conditions’
[17:44:45.789]   - Field: ‘expr’
[17:44:45.789]   - Field: ‘uuid’
[17:44:45.789]   - Field: ‘seed’
[17:44:45.789]   - Field: ‘version’
[17:44:45.789]   - Field: ‘result’
[17:44:45.789]   - Field: ‘asynchronous’
[17:44:45.789]   - Field: ‘calls’
[17:44:45.790]   - Field: ‘globals’
[17:44:45.790]   - Field: ‘stdout’
[17:44:45.790]   - Field: ‘earlySignal’
[17:44:45.790]   - Field: ‘lazy’
[17:44:45.790]   - Field: ‘state’
[17:44:45.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.790] - Launch lazy future ...
[17:44:45.790] Packages needed by the future expression (n = 0): <none>
[17:44:45.790] Packages needed by future strategies (n = 0): <none>
[17:44:45.791] {
[17:44:45.791]     {
[17:44:45.791]         {
[17:44:45.791]             ...future.startTime <- base::Sys.time()
[17:44:45.791]             {
[17:44:45.791]                 {
[17:44:45.791]                   {
[17:44:45.791]                     base::local({
[17:44:45.791]                       has_future <- base::requireNamespace("future", 
[17:44:45.791]                         quietly = TRUE)
[17:44:45.791]                       if (has_future) {
[17:44:45.791]                         ns <- base::getNamespace("future")
[17:44:45.791]                         version <- ns[[".package"]][["version"]]
[17:44:45.791]                         if (is.null(version)) 
[17:44:45.791]                           version <- utils::packageVersion("future")
[17:44:45.791]                       }
[17:44:45.791]                       else {
[17:44:45.791]                         version <- NULL
[17:44:45.791]                       }
[17:44:45.791]                       if (!has_future || version < "1.8.0") {
[17:44:45.791]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.791]                           "", base::R.version$version.string), 
[17:44:45.791]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.791]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.791]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.791]                             "release", "version")], collapse = " "), 
[17:44:45.791]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.791]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.791]                           info)
[17:44:45.791]                         info <- base::paste(info, collapse = "; ")
[17:44:45.791]                         if (!has_future) {
[17:44:45.791]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.791]                             info)
[17:44:45.791]                         }
[17:44:45.791]                         else {
[17:44:45.791]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.791]                             info, version)
[17:44:45.791]                         }
[17:44:45.791]                         base::stop(msg)
[17:44:45.791]                       }
[17:44:45.791]                     })
[17:44:45.791]                   }
[17:44:45.791]                   ...future.strategy.old <- future::plan("list")
[17:44:45.791]                   options(future.plan = NULL)
[17:44:45.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.791]                 }
[17:44:45.791]                 ...future.workdir <- getwd()
[17:44:45.791]             }
[17:44:45.791]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.791]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.791]         }
[17:44:45.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.791]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:45.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.791]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.791]             base::names(...future.oldOptions))
[17:44:45.791]     }
[17:44:45.791]     if (FALSE) {
[17:44:45.791]     }
[17:44:45.791]     else {
[17:44:45.791]         if (TRUE) {
[17:44:45.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.791]                 open = "w")
[17:44:45.791]         }
[17:44:45.791]         else {
[17:44:45.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.791]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.791]         }
[17:44:45.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.791]             base::sink(type = "output", split = FALSE)
[17:44:45.791]             base::close(...future.stdout)
[17:44:45.791]         }, add = TRUE)
[17:44:45.791]     }
[17:44:45.791]     ...future.frame <- base::sys.nframe()
[17:44:45.791]     ...future.conditions <- base::list()
[17:44:45.791]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.791]     if (FALSE) {
[17:44:45.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.791]     }
[17:44:45.791]     ...future.result <- base::tryCatch({
[17:44:45.791]         base::withCallingHandlers({
[17:44:45.791]             ...future.value <- base::withVisible(base::local({
[17:44:45.791]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.791]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.791]                   ...future.globals.maxSize)) {
[17:44:45.791]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.791]                   on.exit(options(oopts), add = TRUE)
[17:44:45.791]                 }
[17:44:45.791]                 {
[17:44:45.791]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.791]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.791]                     USE.NAMES = FALSE)
[17:44:45.791]                   do.call(mapply, args = args)
[17:44:45.791]                 }
[17:44:45.791]             }))
[17:44:45.791]             future::FutureResult(value = ...future.value$value, 
[17:44:45.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.791]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.791]                     ...future.globalenv.names))
[17:44:45.791]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.791]         }, condition = base::local({
[17:44:45.791]             c <- base::c
[17:44:45.791]             inherits <- base::inherits
[17:44:45.791]             invokeRestart <- base::invokeRestart
[17:44:45.791]             length <- base::length
[17:44:45.791]             list <- base::list
[17:44:45.791]             seq.int <- base::seq.int
[17:44:45.791]             signalCondition <- base::signalCondition
[17:44:45.791]             sys.calls <- base::sys.calls
[17:44:45.791]             `[[` <- base::`[[`
[17:44:45.791]             `+` <- base::`+`
[17:44:45.791]             `<<-` <- base::`<<-`
[17:44:45.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.791]                   3L)]
[17:44:45.791]             }
[17:44:45.791]             function(cond) {
[17:44:45.791]                 is_error <- inherits(cond, "error")
[17:44:45.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.791]                   NULL)
[17:44:45.791]                 if (is_error) {
[17:44:45.791]                   sessionInformation <- function() {
[17:44:45.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.791]                       search = base::search(), system = base::Sys.info())
[17:44:45.791]                   }
[17:44:45.791]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.791]                     cond$call), session = sessionInformation(), 
[17:44:45.791]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.791]                   signalCondition(cond)
[17:44:45.791]                 }
[17:44:45.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.791]                 "immediateCondition"))) {
[17:44:45.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.791]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.791]                   if (TRUE && !signal) {
[17:44:45.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.791]                     {
[17:44:45.791]                       inherits <- base::inherits
[17:44:45.791]                       invokeRestart <- base::invokeRestart
[17:44:45.791]                       is.null <- base::is.null
[17:44:45.791]                       muffled <- FALSE
[17:44:45.791]                       if (inherits(cond, "message")) {
[17:44:45.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.791]                         if (muffled) 
[17:44:45.791]                           invokeRestart("muffleMessage")
[17:44:45.791]                       }
[17:44:45.791]                       else if (inherits(cond, "warning")) {
[17:44:45.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.791]                         if (muffled) 
[17:44:45.791]                           invokeRestart("muffleWarning")
[17:44:45.791]                       }
[17:44:45.791]                       else if (inherits(cond, "condition")) {
[17:44:45.791]                         if (!is.null(pattern)) {
[17:44:45.791]                           computeRestarts <- base::computeRestarts
[17:44:45.791]                           grepl <- base::grepl
[17:44:45.791]                           restarts <- computeRestarts(cond)
[17:44:45.791]                           for (restart in restarts) {
[17:44:45.791]                             name <- restart$name
[17:44:45.791]                             if (is.null(name)) 
[17:44:45.791]                               next
[17:44:45.791]                             if (!grepl(pattern, name)) 
[17:44:45.791]                               next
[17:44:45.791]                             invokeRestart(restart)
[17:44:45.791]                             muffled <- TRUE
[17:44:45.791]                             break
[17:44:45.791]                           }
[17:44:45.791]                         }
[17:44:45.791]                       }
[17:44:45.791]                       invisible(muffled)
[17:44:45.791]                     }
[17:44:45.791]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.791]                   }
[17:44:45.791]                 }
[17:44:45.791]                 else {
[17:44:45.791]                   if (TRUE) {
[17:44:45.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.791]                     {
[17:44:45.791]                       inherits <- base::inherits
[17:44:45.791]                       invokeRestart <- base::invokeRestart
[17:44:45.791]                       is.null <- base::is.null
[17:44:45.791]                       muffled <- FALSE
[17:44:45.791]                       if (inherits(cond, "message")) {
[17:44:45.791]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.791]                         if (muffled) 
[17:44:45.791]                           invokeRestart("muffleMessage")
[17:44:45.791]                       }
[17:44:45.791]                       else if (inherits(cond, "warning")) {
[17:44:45.791]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.791]                         if (muffled) 
[17:44:45.791]                           invokeRestart("muffleWarning")
[17:44:45.791]                       }
[17:44:45.791]                       else if (inherits(cond, "condition")) {
[17:44:45.791]                         if (!is.null(pattern)) {
[17:44:45.791]                           computeRestarts <- base::computeRestarts
[17:44:45.791]                           grepl <- base::grepl
[17:44:45.791]                           restarts <- computeRestarts(cond)
[17:44:45.791]                           for (restart in restarts) {
[17:44:45.791]                             name <- restart$name
[17:44:45.791]                             if (is.null(name)) 
[17:44:45.791]                               next
[17:44:45.791]                             if (!grepl(pattern, name)) 
[17:44:45.791]                               next
[17:44:45.791]                             invokeRestart(restart)
[17:44:45.791]                             muffled <- TRUE
[17:44:45.791]                             break
[17:44:45.791]                           }
[17:44:45.791]                         }
[17:44:45.791]                       }
[17:44:45.791]                       invisible(muffled)
[17:44:45.791]                     }
[17:44:45.791]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.791]                   }
[17:44:45.791]                 }
[17:44:45.791]             }
[17:44:45.791]         }))
[17:44:45.791]     }, error = function(ex) {
[17:44:45.791]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.791]                 ...future.rng), started = ...future.startTime, 
[17:44:45.791]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.791]             version = "1.8"), class = "FutureResult")
[17:44:45.791]     }, finally = {
[17:44:45.791]         if (!identical(...future.workdir, getwd())) 
[17:44:45.791]             setwd(...future.workdir)
[17:44:45.791]         {
[17:44:45.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.791]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.791]             }
[17:44:45.791]             base::options(...future.oldOptions)
[17:44:45.791]             if (.Platform$OS.type == "windows") {
[17:44:45.791]                 old_names <- names(...future.oldEnvVars)
[17:44:45.791]                 envs <- base::Sys.getenv()
[17:44:45.791]                 names <- names(envs)
[17:44:45.791]                 common <- intersect(names, old_names)
[17:44:45.791]                 added <- setdiff(names, old_names)
[17:44:45.791]                 removed <- setdiff(old_names, names)
[17:44:45.791]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.791]                   envs[common]]
[17:44:45.791]                 NAMES <- toupper(changed)
[17:44:45.791]                 args <- list()
[17:44:45.791]                 for (kk in seq_along(NAMES)) {
[17:44:45.791]                   name <- changed[[kk]]
[17:44:45.791]                   NAME <- NAMES[[kk]]
[17:44:45.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.791]                     next
[17:44:45.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.791]                 }
[17:44:45.791]                 NAMES <- toupper(added)
[17:44:45.791]                 for (kk in seq_along(NAMES)) {
[17:44:45.791]                   name <- added[[kk]]
[17:44:45.791]                   NAME <- NAMES[[kk]]
[17:44:45.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.791]                     next
[17:44:45.791]                   args[[name]] <- ""
[17:44:45.791]                 }
[17:44:45.791]                 NAMES <- toupper(removed)
[17:44:45.791]                 for (kk in seq_along(NAMES)) {
[17:44:45.791]                   name <- removed[[kk]]
[17:44:45.791]                   NAME <- NAMES[[kk]]
[17:44:45.791]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.791]                     next
[17:44:45.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.791]                 }
[17:44:45.791]                 if (length(args) > 0) 
[17:44:45.791]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.791]             }
[17:44:45.791]             else {
[17:44:45.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.791]             }
[17:44:45.791]             {
[17:44:45.791]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.791]                   0L) {
[17:44:45.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.791]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.791]                   base::options(opts)
[17:44:45.791]                 }
[17:44:45.791]                 {
[17:44:45.791]                   {
[17:44:45.791]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.791]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.791]                     -484569582L), envir = base::globalenv(), 
[17:44:45.791]                       inherits = FALSE)
[17:44:45.791]                     NULL
[17:44:45.791]                   }
[17:44:45.791]                   options(future.plan = NULL)
[17:44:45.791]                   if (is.na(NA_character_)) 
[17:44:45.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.791]                     .init = FALSE)
[17:44:45.791]                 }
[17:44:45.791]             }
[17:44:45.791]         }
[17:44:45.791]     })
[17:44:45.791]     if (TRUE) {
[17:44:45.791]         base::sink(type = "output", split = FALSE)
[17:44:45.791]         if (TRUE) {
[17:44:45.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.791]         }
[17:44:45.791]         else {
[17:44:45.791]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.791]         }
[17:44:45.791]         base::close(...future.stdout)
[17:44:45.791]         ...future.stdout <- NULL
[17:44:45.791]     }
[17:44:45.791]     ...future.result$conditions <- ...future.conditions
[17:44:45.791]     ...future.result$finished <- base::Sys.time()
[17:44:45.791]     ...future.result
[17:44:45.791] }
[17:44:45.793] assign_globals() ...
[17:44:45.793] List of 5
[17:44:45.793]  $ ...future.FUN            :function (C, k)  
[17:44:45.793]  $ MoreArgs                 : NULL
[17:44:45.793]  $ ...future.elements_ii    :List of 2
[17:44:45.793]   ..$ :List of 2
[17:44:45.793]   .. ..$ : chr "C"
[17:44:45.793]   .. ..$ : chr "A"
[17:44:45.793]   ..$ :List of 2
[17:44:45.793]   .. ..$ : int 3
[17:44:45.793]   .. ..$ : int 5
[17:44:45.793]  $ ...future.seeds_ii       : NULL
[17:44:45.793]  $ ...future.globals.maxSize: NULL
[17:44:45.793]  - attr(*, "where")=List of 5
[17:44:45.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.793]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.793]  - attr(*, "resolved")= logi FALSE
[17:44:45.793]  - attr(*, "total_size")= num 3656
[17:44:45.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.793]  - attr(*, "already-done")= logi TRUE
[17:44:45.798] - reassign environment for ‘...future.FUN’
[17:44:45.798] - copied ‘...future.FUN’ to environment
[17:44:45.798] - copied ‘MoreArgs’ to environment
[17:44:45.798] - copied ‘...future.elements_ii’ to environment
[17:44:45.799] - copied ‘...future.seeds_ii’ to environment
[17:44:45.799] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.799] assign_globals() ... done
[17:44:45.799] plan(): Setting new future strategy stack:
[17:44:45.799] List of future strategies:
[17:44:45.799] 1. sequential:
[17:44:45.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.799]    - tweaked: FALSE
[17:44:45.799]    - call: NULL
[17:44:45.800] plan(): nbrOfWorkers() = 1
[17:44:45.800] plan(): Setting new future strategy stack:
[17:44:45.800] List of future strategies:
[17:44:45.800] 1. sequential:
[17:44:45.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.800]    - tweaked: FALSE
[17:44:45.800]    - call: plan(strategy)
[17:44:45.801] plan(): nbrOfWorkers() = 1
[17:44:45.801] SequentialFuture started (and completed)
[17:44:45.801] - Launch lazy future ... done
[17:44:45.801] run() for ‘SequentialFuture’ ... done
[17:44:45.801] Created future:
[17:44:45.801] SequentialFuture:
[17:44:45.801] Label: ‘future_mapply-3’
[17:44:45.801] Expression:
[17:44:45.801] {
[17:44:45.801]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.801]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.801]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.801]         on.exit(options(oopts), add = TRUE)
[17:44:45.801]     }
[17:44:45.801]     {
[17:44:45.801]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.801]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.801]         do.call(mapply, args = args)
[17:44:45.801]     }
[17:44:45.801] }
[17:44:45.801] Lazy evaluation: FALSE
[17:44:45.801] Asynchronous evaluation: FALSE
[17:44:45.801] Local evaluation: TRUE
[17:44:45.801] Environment: R_GlobalEnv
[17:44:45.801] Capture standard output: TRUE
[17:44:45.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.801] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.801] Packages: <none>
[17:44:45.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.801] Resolved: TRUE
[17:44:45.801] Value: 224 bytes of class ‘list’
[17:44:45.801] Early signaling: FALSE
[17:44:45.801] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.801] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.802] Chunk #3 of 3 ... DONE
[17:44:45.802] Launching 3 futures (chunks) ... DONE
[17:44:45.803] Resolving 3 futures (chunks) ...
[17:44:45.803] resolve() on list ...
[17:44:45.803]  recursive: 0
[17:44:45.803]  length: 3
[17:44:45.803] 
[17:44:45.803] resolved() for ‘SequentialFuture’ ...
[17:44:45.803] - state: ‘finished’
[17:44:45.803] - run: TRUE
[17:44:45.803] - result: ‘FutureResult’
[17:44:45.803] resolved() for ‘SequentialFuture’ ... done
[17:44:45.804] Future #1
[17:44:45.804] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.804] - nx: 3
[17:44:45.804] - relay: TRUE
[17:44:45.804] - stdout: TRUE
[17:44:45.804] - signal: TRUE
[17:44:45.804] - resignal: FALSE
[17:44:45.804] - force: TRUE
[17:44:45.804] - relayed: [n=3] FALSE, FALSE, FALSE
[17:44:45.804] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:44:45.804]  - until=1
[17:44:45.805]  - relaying element #1
[17:44:45.805] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:45.805] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:45.805] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.805]  length: 2 (resolved future 1)
[17:44:45.805] resolved() for ‘SequentialFuture’ ...
[17:44:45.805] - state: ‘finished’
[17:44:45.805] - run: TRUE
[17:44:45.805] - result: ‘FutureResult’
[17:44:45.806] resolved() for ‘SequentialFuture’ ... done
[17:44:45.806] Future #2
[17:44:45.806] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:44:45.806] - nx: 3
[17:44:45.806] - relay: TRUE
[17:44:45.806] - stdout: TRUE
[17:44:45.806] - signal: TRUE
[17:44:45.806] - resignal: FALSE
[17:44:45.806] - force: TRUE
[17:44:45.806] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:45.806] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:45.807]  - until=2
[17:44:45.807]  - relaying element #2
[17:44:45.807] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:45.807] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:45.807] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:44:45.807]  length: 1 (resolved future 2)
[17:44:45.807] resolved() for ‘SequentialFuture’ ...
[17:44:45.807] - state: ‘finished’
[17:44:45.807] - run: TRUE
[17:44:45.808] - result: ‘FutureResult’
[17:44:45.808] resolved() for ‘SequentialFuture’ ... done
[17:44:45.808] Future #3
[17:44:45.808] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:44:45.808] - nx: 3
[17:44:45.808] - relay: TRUE
[17:44:45.808] - stdout: TRUE
[17:44:45.808] - signal: TRUE
[17:44:45.808] - resignal: FALSE
[17:44:45.808] - force: TRUE
[17:44:45.808] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:45.809] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:45.809]  - until=3
[17:44:45.809]  - relaying element #3
[17:44:45.809] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:45.809] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:45.809] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:44:45.809]  length: 0 (resolved future 3)
[17:44:45.809] Relaying remaining futures
[17:44:45.811] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.811] - nx: 3
[17:44:45.811] - relay: TRUE
[17:44:45.811] - stdout: TRUE
[17:44:45.811] - signal: TRUE
[17:44:45.811] - resignal: FALSE
[17:44:45.812] - force: TRUE
[17:44:45.812] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:45.812] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:44:45.812] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:45.812] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:45.812] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.812] resolve() on list ... DONE
[17:44:45.813]  - Number of value chunks collected: 3
[17:44:45.813] Resolving 3 futures (chunks) ... DONE
[17:44:45.813] Reducing values from 3 chunks ...
[17:44:45.813]  - Number of values collected after concatenation: 5
[17:44:45.813]  - Number of values expected: 5
[17:44:45.813] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 1, 4, 3, 2
[17:44:45.813] Reducing values from 3 chunks ... DONE
[17:44:45.813] future_mapply() ... DONE
[17:44:45.813] future_mapply() ...
[17:44:45.814] Number of chunks: 1
[17:44:45.814] getGlobalsAndPackagesXApply() ...
[17:44:45.814]  - future.globals: TRUE
[17:44:45.814] getGlobalsAndPackages() ...
[17:44:45.814] Searching for globals...
[17:44:45.815] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.815] Searching for globals ... DONE
[17:44:45.816] Resolving globals: FALSE
[17:44:45.816] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.816] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.816] - globals: [1] ‘FUN’
[17:44:45.816] 
[17:44:45.817] getGlobalsAndPackages() ... DONE
[17:44:45.817]  - globals found/used: [n=1] ‘FUN’
[17:44:45.817]  - needed namespaces: [n=0] 
[17:44:45.817] Finding globals ... DONE
[17:44:45.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.817] List of 2
[17:44:45.817]  $ ...future.FUN:function (C, k)  
[17:44:45.817]  $ MoreArgs     : list()
[17:44:45.817]  - attr(*, "where")=List of 2
[17:44:45.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.817]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.817]  - attr(*, "resolved")= logi FALSE
[17:44:45.817]  - attr(*, "total_size")= num NA
[17:44:45.819] Packages to be attached in all futures: [n=0] 
[17:44:45.820] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.820] Number of futures (= number of chunks): 1
[17:44:45.820] Launching 1 futures (chunks) ...
[17:44:45.820] Chunk #1 of 1 ...
[17:44:45.820]  - Finding globals in '...' for chunk #1 ...
[17:44:45.820] getGlobalsAndPackages() ...
[17:44:45.820] Searching for globals...
[17:44:45.821] 
[17:44:45.821] Searching for globals ... DONE
[17:44:45.821] - globals: [0] <none>
[17:44:45.821] getGlobalsAndPackages() ... DONE
[17:44:45.821]    + additional globals found: [n=0] 
[17:44:45.821]    + additional namespaces needed: [n=0] 
[17:44:45.821]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.821]  - seeds: <none>
[17:44:45.821]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.821] getGlobalsAndPackages() ...
[17:44:45.821] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.822] Resolving globals: FALSE
[17:44:45.822] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:44:45.822] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:45.823] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.823] 
[17:44:45.823] getGlobalsAndPackages() ... DONE
[17:44:45.823] run() for ‘Future’ ...
[17:44:45.823] - state: ‘created’
[17:44:45.823] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.824] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.824]   - Field: ‘label’
[17:44:45.824]   - Field: ‘local’
[17:44:45.824]   - Field: ‘owner’
[17:44:45.824]   - Field: ‘envir’
[17:44:45.824]   - Field: ‘packages’
[17:44:45.824]   - Field: ‘gc’
[17:44:45.824]   - Field: ‘conditions’
[17:44:45.824]   - Field: ‘expr’
[17:44:45.824]   - Field: ‘uuid’
[17:44:45.825]   - Field: ‘seed’
[17:44:45.825]   - Field: ‘version’
[17:44:45.825]   - Field: ‘result’
[17:44:45.825]   - Field: ‘asynchronous’
[17:44:45.825]   - Field: ‘calls’
[17:44:45.825]   - Field: ‘globals’
[17:44:45.825]   - Field: ‘stdout’
[17:44:45.825]   - Field: ‘earlySignal’
[17:44:45.825]   - Field: ‘lazy’
[17:44:45.825]   - Field: ‘state’
[17:44:45.825] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.826] - Launch lazy future ...
[17:44:45.826] Packages needed by the future expression (n = 0): <none>
[17:44:45.826] Packages needed by future strategies (n = 0): <none>
[17:44:45.826] {
[17:44:45.826]     {
[17:44:45.826]         {
[17:44:45.826]             ...future.startTime <- base::Sys.time()
[17:44:45.826]             {
[17:44:45.826]                 {
[17:44:45.826]                   {
[17:44:45.826]                     base::local({
[17:44:45.826]                       has_future <- base::requireNamespace("future", 
[17:44:45.826]                         quietly = TRUE)
[17:44:45.826]                       if (has_future) {
[17:44:45.826]                         ns <- base::getNamespace("future")
[17:44:45.826]                         version <- ns[[".package"]][["version"]]
[17:44:45.826]                         if (is.null(version)) 
[17:44:45.826]                           version <- utils::packageVersion("future")
[17:44:45.826]                       }
[17:44:45.826]                       else {
[17:44:45.826]                         version <- NULL
[17:44:45.826]                       }
[17:44:45.826]                       if (!has_future || version < "1.8.0") {
[17:44:45.826]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.826]                           "", base::R.version$version.string), 
[17:44:45.826]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.826]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.826]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.826]                             "release", "version")], collapse = " "), 
[17:44:45.826]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.826]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.826]                           info)
[17:44:45.826]                         info <- base::paste(info, collapse = "; ")
[17:44:45.826]                         if (!has_future) {
[17:44:45.826]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.826]                             info)
[17:44:45.826]                         }
[17:44:45.826]                         else {
[17:44:45.826]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.826]                             info, version)
[17:44:45.826]                         }
[17:44:45.826]                         base::stop(msg)
[17:44:45.826]                       }
[17:44:45.826]                     })
[17:44:45.826]                   }
[17:44:45.826]                   ...future.strategy.old <- future::plan("list")
[17:44:45.826]                   options(future.plan = NULL)
[17:44:45.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.826]                 }
[17:44:45.826]                 ...future.workdir <- getwd()
[17:44:45.826]             }
[17:44:45.826]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.826]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.826]         }
[17:44:45.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.826]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.826]             base::names(...future.oldOptions))
[17:44:45.826]     }
[17:44:45.826]     if (FALSE) {
[17:44:45.826]     }
[17:44:45.826]     else {
[17:44:45.826]         if (TRUE) {
[17:44:45.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.826]                 open = "w")
[17:44:45.826]         }
[17:44:45.826]         else {
[17:44:45.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.826]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.826]         }
[17:44:45.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.826]             base::sink(type = "output", split = FALSE)
[17:44:45.826]             base::close(...future.stdout)
[17:44:45.826]         }, add = TRUE)
[17:44:45.826]     }
[17:44:45.826]     ...future.frame <- base::sys.nframe()
[17:44:45.826]     ...future.conditions <- base::list()
[17:44:45.826]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.826]     if (FALSE) {
[17:44:45.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.826]     }
[17:44:45.826]     ...future.result <- base::tryCatch({
[17:44:45.826]         base::withCallingHandlers({
[17:44:45.826]             ...future.value <- base::withVisible(base::local({
[17:44:45.826]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.826]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.826]                   ...future.globals.maxSize)) {
[17:44:45.826]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.826]                   on.exit(options(oopts), add = TRUE)
[17:44:45.826]                 }
[17:44:45.826]                 {
[17:44:45.826]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.826]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.826]                     USE.NAMES = FALSE)
[17:44:45.826]                   do.call(mapply, args = args)
[17:44:45.826]                 }
[17:44:45.826]             }))
[17:44:45.826]             future::FutureResult(value = ...future.value$value, 
[17:44:45.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.826]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.826]                     ...future.globalenv.names))
[17:44:45.826]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.826]         }, condition = base::local({
[17:44:45.826]             c <- base::c
[17:44:45.826]             inherits <- base::inherits
[17:44:45.826]             invokeRestart <- base::invokeRestart
[17:44:45.826]             length <- base::length
[17:44:45.826]             list <- base::list
[17:44:45.826]             seq.int <- base::seq.int
[17:44:45.826]             signalCondition <- base::signalCondition
[17:44:45.826]             sys.calls <- base::sys.calls
[17:44:45.826]             `[[` <- base::`[[`
[17:44:45.826]             `+` <- base::`+`
[17:44:45.826]             `<<-` <- base::`<<-`
[17:44:45.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.826]                   3L)]
[17:44:45.826]             }
[17:44:45.826]             function(cond) {
[17:44:45.826]                 is_error <- inherits(cond, "error")
[17:44:45.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.826]                   NULL)
[17:44:45.826]                 if (is_error) {
[17:44:45.826]                   sessionInformation <- function() {
[17:44:45.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.826]                       search = base::search(), system = base::Sys.info())
[17:44:45.826]                   }
[17:44:45.826]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.826]                     cond$call), session = sessionInformation(), 
[17:44:45.826]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.826]                   signalCondition(cond)
[17:44:45.826]                 }
[17:44:45.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.826]                 "immediateCondition"))) {
[17:44:45.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.826]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.826]                   if (TRUE && !signal) {
[17:44:45.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.826]                     {
[17:44:45.826]                       inherits <- base::inherits
[17:44:45.826]                       invokeRestart <- base::invokeRestart
[17:44:45.826]                       is.null <- base::is.null
[17:44:45.826]                       muffled <- FALSE
[17:44:45.826]                       if (inherits(cond, "message")) {
[17:44:45.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.826]                         if (muffled) 
[17:44:45.826]                           invokeRestart("muffleMessage")
[17:44:45.826]                       }
[17:44:45.826]                       else if (inherits(cond, "warning")) {
[17:44:45.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.826]                         if (muffled) 
[17:44:45.826]                           invokeRestart("muffleWarning")
[17:44:45.826]                       }
[17:44:45.826]                       else if (inherits(cond, "condition")) {
[17:44:45.826]                         if (!is.null(pattern)) {
[17:44:45.826]                           computeRestarts <- base::computeRestarts
[17:44:45.826]                           grepl <- base::grepl
[17:44:45.826]                           restarts <- computeRestarts(cond)
[17:44:45.826]                           for (restart in restarts) {
[17:44:45.826]                             name <- restart$name
[17:44:45.826]                             if (is.null(name)) 
[17:44:45.826]                               next
[17:44:45.826]                             if (!grepl(pattern, name)) 
[17:44:45.826]                               next
[17:44:45.826]                             invokeRestart(restart)
[17:44:45.826]                             muffled <- TRUE
[17:44:45.826]                             break
[17:44:45.826]                           }
[17:44:45.826]                         }
[17:44:45.826]                       }
[17:44:45.826]                       invisible(muffled)
[17:44:45.826]                     }
[17:44:45.826]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.826]                   }
[17:44:45.826]                 }
[17:44:45.826]                 else {
[17:44:45.826]                   if (TRUE) {
[17:44:45.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.826]                     {
[17:44:45.826]                       inherits <- base::inherits
[17:44:45.826]                       invokeRestart <- base::invokeRestart
[17:44:45.826]                       is.null <- base::is.null
[17:44:45.826]                       muffled <- FALSE
[17:44:45.826]                       if (inherits(cond, "message")) {
[17:44:45.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.826]                         if (muffled) 
[17:44:45.826]                           invokeRestart("muffleMessage")
[17:44:45.826]                       }
[17:44:45.826]                       else if (inherits(cond, "warning")) {
[17:44:45.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.826]                         if (muffled) 
[17:44:45.826]                           invokeRestart("muffleWarning")
[17:44:45.826]                       }
[17:44:45.826]                       else if (inherits(cond, "condition")) {
[17:44:45.826]                         if (!is.null(pattern)) {
[17:44:45.826]                           computeRestarts <- base::computeRestarts
[17:44:45.826]                           grepl <- base::grepl
[17:44:45.826]                           restarts <- computeRestarts(cond)
[17:44:45.826]                           for (restart in restarts) {
[17:44:45.826]                             name <- restart$name
[17:44:45.826]                             if (is.null(name)) 
[17:44:45.826]                               next
[17:44:45.826]                             if (!grepl(pattern, name)) 
[17:44:45.826]                               next
[17:44:45.826]                             invokeRestart(restart)
[17:44:45.826]                             muffled <- TRUE
[17:44:45.826]                             break
[17:44:45.826]                           }
[17:44:45.826]                         }
[17:44:45.826]                       }
[17:44:45.826]                       invisible(muffled)
[17:44:45.826]                     }
[17:44:45.826]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.826]                   }
[17:44:45.826]                 }
[17:44:45.826]             }
[17:44:45.826]         }))
[17:44:45.826]     }, error = function(ex) {
[17:44:45.826]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.826]                 ...future.rng), started = ...future.startTime, 
[17:44:45.826]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.826]             version = "1.8"), class = "FutureResult")
[17:44:45.826]     }, finally = {
[17:44:45.826]         if (!identical(...future.workdir, getwd())) 
[17:44:45.826]             setwd(...future.workdir)
[17:44:45.826]         {
[17:44:45.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.826]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.826]             }
[17:44:45.826]             base::options(...future.oldOptions)
[17:44:45.826]             if (.Platform$OS.type == "windows") {
[17:44:45.826]                 old_names <- names(...future.oldEnvVars)
[17:44:45.826]                 envs <- base::Sys.getenv()
[17:44:45.826]                 names <- names(envs)
[17:44:45.826]                 common <- intersect(names, old_names)
[17:44:45.826]                 added <- setdiff(names, old_names)
[17:44:45.826]                 removed <- setdiff(old_names, names)
[17:44:45.826]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.826]                   envs[common]]
[17:44:45.826]                 NAMES <- toupper(changed)
[17:44:45.826]                 args <- list()
[17:44:45.826]                 for (kk in seq_along(NAMES)) {
[17:44:45.826]                   name <- changed[[kk]]
[17:44:45.826]                   NAME <- NAMES[[kk]]
[17:44:45.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.826]                     next
[17:44:45.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.826]                 }
[17:44:45.826]                 NAMES <- toupper(added)
[17:44:45.826]                 for (kk in seq_along(NAMES)) {
[17:44:45.826]                   name <- added[[kk]]
[17:44:45.826]                   NAME <- NAMES[[kk]]
[17:44:45.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.826]                     next
[17:44:45.826]                   args[[name]] <- ""
[17:44:45.826]                 }
[17:44:45.826]                 NAMES <- toupper(removed)
[17:44:45.826]                 for (kk in seq_along(NAMES)) {
[17:44:45.826]                   name <- removed[[kk]]
[17:44:45.826]                   NAME <- NAMES[[kk]]
[17:44:45.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.826]                     next
[17:44:45.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.826]                 }
[17:44:45.826]                 if (length(args) > 0) 
[17:44:45.826]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.826]             }
[17:44:45.826]             else {
[17:44:45.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.826]             }
[17:44:45.826]             {
[17:44:45.826]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.826]                   0L) {
[17:44:45.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.826]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.826]                   base::options(opts)
[17:44:45.826]                 }
[17:44:45.826]                 {
[17:44:45.826]                   {
[17:44:45.826]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.826]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.826]                     -484569582L), envir = base::globalenv(), 
[17:44:45.826]                       inherits = FALSE)
[17:44:45.826]                     NULL
[17:44:45.826]                   }
[17:44:45.826]                   options(future.plan = NULL)
[17:44:45.826]                   if (is.na(NA_character_)) 
[17:44:45.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.826]                     .init = FALSE)
[17:44:45.826]                 }
[17:44:45.826]             }
[17:44:45.826]         }
[17:44:45.826]     })
[17:44:45.826]     if (TRUE) {
[17:44:45.826]         base::sink(type = "output", split = FALSE)
[17:44:45.826]         if (TRUE) {
[17:44:45.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.826]         }
[17:44:45.826]         else {
[17:44:45.826]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.826]         }
[17:44:45.826]         base::close(...future.stdout)
[17:44:45.826]         ...future.stdout <- NULL
[17:44:45.826]     }
[17:44:45.826]     ...future.result$conditions <- ...future.conditions
[17:44:45.826]     ...future.result$finished <- base::Sys.time()
[17:44:45.826]     ...future.result
[17:44:45.826] }
[17:44:45.828] assign_globals() ...
[17:44:45.828] List of 5
[17:44:45.828]  $ ...future.FUN            :function (C, k)  
[17:44:45.828]  $ MoreArgs                 : list()
[17:44:45.828]  $ ...future.elements_ii    :List of 2
[17:44:45.828]   ..$ :List of 5
[17:44:45.828]   .. ..$ : chr "A"
[17:44:45.828]   .. ..$ : chr "B"
[17:44:45.828]   .. ..$ : chr "C"
[17:44:45.828]   .. ..$ : chr "D"
[17:44:45.828]   .. ..$ : chr "E"
[17:44:45.828]   ..$ :List of 5
[17:44:45.828]   .. ..$ : int 5
[17:44:45.828]   .. ..$ : int 4
[17:44:45.828]   .. ..$ : int 3
[17:44:45.828]   .. ..$ : int 2
[17:44:45.828]   .. ..$ : int 1
[17:44:45.828]  $ ...future.seeds_ii       : NULL
[17:44:45.828]  $ ...future.globals.maxSize: NULL
[17:44:45.828]  - attr(*, "where")=List of 5
[17:44:45.828]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.828]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.828]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.828]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.828]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.828]  - attr(*, "resolved")= logi FALSE
[17:44:45.828]  - attr(*, "total_size")= num 4160
[17:44:45.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.828]  - attr(*, "already-done")= logi TRUE
[17:44:45.836] - reassign environment for ‘...future.FUN’
[17:44:45.836] - copied ‘...future.FUN’ to environment
[17:44:45.836] - copied ‘MoreArgs’ to environment
[17:44:45.836] - copied ‘...future.elements_ii’ to environment
[17:44:45.837] - copied ‘...future.seeds_ii’ to environment
[17:44:45.837] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.837] assign_globals() ... done
[17:44:45.837] plan(): Setting new future strategy stack:
[17:44:45.837] List of future strategies:
[17:44:45.837] 1. sequential:
[17:44:45.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.837]    - tweaked: FALSE
[17:44:45.837]    - call: NULL
[17:44:45.838] plan(): nbrOfWorkers() = 1
[17:44:45.838] plan(): Setting new future strategy stack:
[17:44:45.838] List of future strategies:
[17:44:45.838] 1. sequential:
[17:44:45.838]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.838]    - tweaked: FALSE
[17:44:45.838]    - call: plan(strategy)
[17:44:45.839] plan(): nbrOfWorkers() = 1
[17:44:45.839] SequentialFuture started (and completed)
[17:44:45.839] - Launch lazy future ... done
[17:44:45.839] run() for ‘SequentialFuture’ ... done
[17:44:45.839] Created future:
[17:44:45.840] SequentialFuture:
[17:44:45.840] Label: ‘future_.mapply-1’
[17:44:45.840] Expression:
[17:44:45.840] {
[17:44:45.840]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.840]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.840]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.840]         on.exit(options(oopts), add = TRUE)
[17:44:45.840]     }
[17:44:45.840]     {
[17:44:45.840]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.840]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.840]         do.call(mapply, args = args)
[17:44:45.840]     }
[17:44:45.840] }
[17:44:45.840] Lazy evaluation: FALSE
[17:44:45.840] Asynchronous evaluation: FALSE
[17:44:45.840] Local evaluation: TRUE
[17:44:45.840] Environment: R_GlobalEnv
[17:44:45.840] Capture standard output: TRUE
[17:44:45.840] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.840] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.840] Packages: <none>
[17:44:45.840] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.840] Resolved: TRUE
[17:44:45.840] Value: 560 bytes of class ‘list’
[17:44:45.840] Early signaling: FALSE
[17:44:45.840] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.840] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.840] Chunk #1 of 1 ... DONE
[17:44:45.840] Launching 1 futures (chunks) ... DONE
[17:44:45.841] Resolving 1 futures (chunks) ...
[17:44:45.841] resolve() on list ...
[17:44:45.841]  recursive: 0
[17:44:45.841]  length: 1
[17:44:45.841] 
[17:44:45.841] resolved() for ‘SequentialFuture’ ...
[17:44:45.841] - state: ‘finished’
[17:44:45.841] - run: TRUE
[17:44:45.841] - result: ‘FutureResult’
[17:44:45.841] resolved() for ‘SequentialFuture’ ... done
[17:44:45.842] Future #1
[17:44:45.842] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.842] - nx: 1
[17:44:45.842] - relay: TRUE
[17:44:45.842] - stdout: TRUE
[17:44:45.842] - signal: TRUE
[17:44:45.842] - resignal: FALSE
[17:44:45.842] - force: TRUE
[17:44:45.842] - relayed: [n=1] FALSE
[17:44:45.842] - queued futures: [n=1] FALSE
[17:44:45.842]  - until=1
[17:44:45.843]  - relaying element #1
[17:44:45.843] - relayed: [n=1] TRUE
[17:44:45.843] - queued futures: [n=1] TRUE
[17:44:45.843] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.843]  length: 0 (resolved future 1)
[17:44:45.843] Relaying remaining futures
[17:44:45.843] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.843] - nx: 1
[17:44:45.843] - relay: TRUE
[17:44:45.843] - stdout: TRUE
[17:44:45.843] - signal: TRUE
[17:44:45.844] - resignal: FALSE
[17:44:45.844] - force: TRUE
[17:44:45.844] - relayed: [n=1] TRUE
[17:44:45.844] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.844] - relayed: [n=1] TRUE
[17:44:45.844] - queued futures: [n=1] TRUE
[17:44:45.844] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.844] resolve() on list ... DONE
[17:44:45.844]  - Number of value chunks collected: 1
[17:44:45.844] Resolving 1 futures (chunks) ... DONE
[17:44:45.845] Reducing values from 1 chunks ...
[17:44:45.845]  - Number of values collected after concatenation: 5
[17:44:45.845]  - Number of values expected: 5
[17:44:45.845] Reducing values from 1 chunks ... DONE
[17:44:45.845] future_mapply() ... DONE
[17:44:45.845] future_mapply() ...
[17:44:45.845] Number of chunks: 2
[17:44:45.846] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:45.846] getGlobalsAndPackagesXApply() ...
[17:44:45.846]  - future.globals: TRUE
[17:44:45.846] getGlobalsAndPackages() ...
[17:44:45.846] Searching for globals...
[17:44:45.847] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.847] Searching for globals ... DONE
[17:44:45.847] Resolving globals: FALSE
[17:44:45.848] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.848] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.848] - globals: [1] ‘FUN’
[17:44:45.848] 
[17:44:45.848] getGlobalsAndPackages() ... DONE
[17:44:45.848]  - globals found/used: [n=1] ‘FUN’
[17:44:45.848]  - needed namespaces: [n=0] 
[17:44:45.849] Finding globals ... DONE
[17:44:45.849] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.849] List of 2
[17:44:45.849]  $ ...future.FUN:function (C, k)  
[17:44:45.849]  $ MoreArgs     : NULL
[17:44:45.849]  - attr(*, "where")=List of 2
[17:44:45.849]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.849]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.849]  - attr(*, "resolved")= logi FALSE
[17:44:45.849]  - attr(*, "total_size")= num NA
[17:44:45.851] Packages to be attached in all futures: [n=0] 
[17:44:45.851] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.851] Number of futures (= number of chunks): 2
[17:44:45.852] Launching 2 futures (chunks) ...
[17:44:45.852] Chunk #1 of 2 ...
[17:44:45.852]  - Finding globals in '...' for chunk #1 ...
[17:44:45.852] getGlobalsAndPackages() ...
[17:44:45.852] Searching for globals...
[17:44:45.852] 
[17:44:45.852] Searching for globals ... DONE
[17:44:45.852] - globals: [0] <none>
[17:44:45.853] getGlobalsAndPackages() ... DONE
[17:44:45.853]    + additional globals found: [n=0] 
[17:44:45.853]    + additional namespaces needed: [n=0] 
[17:44:45.853]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.853]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:45.853]  - seeds: <none>
[17:44:45.853]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.853] getGlobalsAndPackages() ...
[17:44:45.853] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.853] Resolving globals: FALSE
[17:44:45.854] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:45.854] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.854] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.854] 
[17:44:45.855] getGlobalsAndPackages() ... DONE
[17:44:45.855] run() for ‘Future’ ...
[17:44:45.855] - state: ‘created’
[17:44:45.855] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.855] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.856]   - Field: ‘label’
[17:44:45.856]   - Field: ‘local’
[17:44:45.856]   - Field: ‘owner’
[17:44:45.856]   - Field: ‘envir’
[17:44:45.856]   - Field: ‘packages’
[17:44:45.856]   - Field: ‘gc’
[17:44:45.856]   - Field: ‘conditions’
[17:44:45.856]   - Field: ‘expr’
[17:44:45.856]   - Field: ‘uuid’
[17:44:45.856]   - Field: ‘seed’
[17:44:45.856]   - Field: ‘version’
[17:44:45.857]   - Field: ‘result’
[17:44:45.857]   - Field: ‘asynchronous’
[17:44:45.857]   - Field: ‘calls’
[17:44:45.857]   - Field: ‘globals’
[17:44:45.857]   - Field: ‘stdout’
[17:44:45.857]   - Field: ‘earlySignal’
[17:44:45.857]   - Field: ‘lazy’
[17:44:45.857]   - Field: ‘state’
[17:44:45.857] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.857] - Launch lazy future ...
[17:44:45.858] Packages needed by the future expression (n = 0): <none>
[17:44:45.858] Packages needed by future strategies (n = 0): <none>
[17:44:45.858] {
[17:44:45.858]     {
[17:44:45.858]         {
[17:44:45.858]             ...future.startTime <- base::Sys.time()
[17:44:45.858]             {
[17:44:45.858]                 {
[17:44:45.858]                   {
[17:44:45.858]                     base::local({
[17:44:45.858]                       has_future <- base::requireNamespace("future", 
[17:44:45.858]                         quietly = TRUE)
[17:44:45.858]                       if (has_future) {
[17:44:45.858]                         ns <- base::getNamespace("future")
[17:44:45.858]                         version <- ns[[".package"]][["version"]]
[17:44:45.858]                         if (is.null(version)) 
[17:44:45.858]                           version <- utils::packageVersion("future")
[17:44:45.858]                       }
[17:44:45.858]                       else {
[17:44:45.858]                         version <- NULL
[17:44:45.858]                       }
[17:44:45.858]                       if (!has_future || version < "1.8.0") {
[17:44:45.858]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.858]                           "", base::R.version$version.string), 
[17:44:45.858]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.858]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.858]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.858]                             "release", "version")], collapse = " "), 
[17:44:45.858]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.858]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.858]                           info)
[17:44:45.858]                         info <- base::paste(info, collapse = "; ")
[17:44:45.858]                         if (!has_future) {
[17:44:45.858]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.858]                             info)
[17:44:45.858]                         }
[17:44:45.858]                         else {
[17:44:45.858]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.858]                             info, version)
[17:44:45.858]                         }
[17:44:45.858]                         base::stop(msg)
[17:44:45.858]                       }
[17:44:45.858]                     })
[17:44:45.858]                   }
[17:44:45.858]                   ...future.strategy.old <- future::plan("list")
[17:44:45.858]                   options(future.plan = NULL)
[17:44:45.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.858]                 }
[17:44:45.858]                 ...future.workdir <- getwd()
[17:44:45.858]             }
[17:44:45.858]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.858]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.858]         }
[17:44:45.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.858]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:45.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.858]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.858]             base::names(...future.oldOptions))
[17:44:45.858]     }
[17:44:45.858]     if (FALSE) {
[17:44:45.858]     }
[17:44:45.858]     else {
[17:44:45.858]         if (TRUE) {
[17:44:45.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.858]                 open = "w")
[17:44:45.858]         }
[17:44:45.858]         else {
[17:44:45.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.858]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.858]         }
[17:44:45.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.858]             base::sink(type = "output", split = FALSE)
[17:44:45.858]             base::close(...future.stdout)
[17:44:45.858]         }, add = TRUE)
[17:44:45.858]     }
[17:44:45.858]     ...future.frame <- base::sys.nframe()
[17:44:45.858]     ...future.conditions <- base::list()
[17:44:45.858]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.858]     if (FALSE) {
[17:44:45.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.858]     }
[17:44:45.858]     ...future.result <- base::tryCatch({
[17:44:45.858]         base::withCallingHandlers({
[17:44:45.858]             ...future.value <- base::withVisible(base::local({
[17:44:45.858]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.858]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.858]                   ...future.globals.maxSize)) {
[17:44:45.858]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.858]                   on.exit(options(oopts), add = TRUE)
[17:44:45.858]                 }
[17:44:45.858]                 {
[17:44:45.858]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.858]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.858]                     USE.NAMES = FALSE)
[17:44:45.858]                   do.call(mapply, args = args)
[17:44:45.858]                 }
[17:44:45.858]             }))
[17:44:45.858]             future::FutureResult(value = ...future.value$value, 
[17:44:45.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.858]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.858]                     ...future.globalenv.names))
[17:44:45.858]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.858]         }, condition = base::local({
[17:44:45.858]             c <- base::c
[17:44:45.858]             inherits <- base::inherits
[17:44:45.858]             invokeRestart <- base::invokeRestart
[17:44:45.858]             length <- base::length
[17:44:45.858]             list <- base::list
[17:44:45.858]             seq.int <- base::seq.int
[17:44:45.858]             signalCondition <- base::signalCondition
[17:44:45.858]             sys.calls <- base::sys.calls
[17:44:45.858]             `[[` <- base::`[[`
[17:44:45.858]             `+` <- base::`+`
[17:44:45.858]             `<<-` <- base::`<<-`
[17:44:45.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.858]                   3L)]
[17:44:45.858]             }
[17:44:45.858]             function(cond) {
[17:44:45.858]                 is_error <- inherits(cond, "error")
[17:44:45.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.858]                   NULL)
[17:44:45.858]                 if (is_error) {
[17:44:45.858]                   sessionInformation <- function() {
[17:44:45.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.858]                       search = base::search(), system = base::Sys.info())
[17:44:45.858]                   }
[17:44:45.858]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.858]                     cond$call), session = sessionInformation(), 
[17:44:45.858]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.858]                   signalCondition(cond)
[17:44:45.858]                 }
[17:44:45.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.858]                 "immediateCondition"))) {
[17:44:45.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.858]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.858]                   if (TRUE && !signal) {
[17:44:45.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.858]                     {
[17:44:45.858]                       inherits <- base::inherits
[17:44:45.858]                       invokeRestart <- base::invokeRestart
[17:44:45.858]                       is.null <- base::is.null
[17:44:45.858]                       muffled <- FALSE
[17:44:45.858]                       if (inherits(cond, "message")) {
[17:44:45.858]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.858]                         if (muffled) 
[17:44:45.858]                           invokeRestart("muffleMessage")
[17:44:45.858]                       }
[17:44:45.858]                       else if (inherits(cond, "warning")) {
[17:44:45.858]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.858]                         if (muffled) 
[17:44:45.858]                           invokeRestart("muffleWarning")
[17:44:45.858]                       }
[17:44:45.858]                       else if (inherits(cond, "condition")) {
[17:44:45.858]                         if (!is.null(pattern)) {
[17:44:45.858]                           computeRestarts <- base::computeRestarts
[17:44:45.858]                           grepl <- base::grepl
[17:44:45.858]                           restarts <- computeRestarts(cond)
[17:44:45.858]                           for (restart in restarts) {
[17:44:45.858]                             name <- restart$name
[17:44:45.858]                             if (is.null(name)) 
[17:44:45.858]                               next
[17:44:45.858]                             if (!grepl(pattern, name)) 
[17:44:45.858]                               next
[17:44:45.858]                             invokeRestart(restart)
[17:44:45.858]                             muffled <- TRUE
[17:44:45.858]                             break
[17:44:45.858]                           }
[17:44:45.858]                         }
[17:44:45.858]                       }
[17:44:45.858]                       invisible(muffled)
[17:44:45.858]                     }
[17:44:45.858]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.858]                   }
[17:44:45.858]                 }
[17:44:45.858]                 else {
[17:44:45.858]                   if (TRUE) {
[17:44:45.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.858]                     {
[17:44:45.858]                       inherits <- base::inherits
[17:44:45.858]                       invokeRestart <- base::invokeRestart
[17:44:45.858]                       is.null <- base::is.null
[17:44:45.858]                       muffled <- FALSE
[17:44:45.858]                       if (inherits(cond, "message")) {
[17:44:45.858]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.858]                         if (muffled) 
[17:44:45.858]                           invokeRestart("muffleMessage")
[17:44:45.858]                       }
[17:44:45.858]                       else if (inherits(cond, "warning")) {
[17:44:45.858]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.858]                         if (muffled) 
[17:44:45.858]                           invokeRestart("muffleWarning")
[17:44:45.858]                       }
[17:44:45.858]                       else if (inherits(cond, "condition")) {
[17:44:45.858]                         if (!is.null(pattern)) {
[17:44:45.858]                           computeRestarts <- base::computeRestarts
[17:44:45.858]                           grepl <- base::grepl
[17:44:45.858]                           restarts <- computeRestarts(cond)
[17:44:45.858]                           for (restart in restarts) {
[17:44:45.858]                             name <- restart$name
[17:44:45.858]                             if (is.null(name)) 
[17:44:45.858]                               next
[17:44:45.858]                             if (!grepl(pattern, name)) 
[17:44:45.858]                               next
[17:44:45.858]                             invokeRestart(restart)
[17:44:45.858]                             muffled <- TRUE
[17:44:45.858]                             break
[17:44:45.858]                           }
[17:44:45.858]                         }
[17:44:45.858]                       }
[17:44:45.858]                       invisible(muffled)
[17:44:45.858]                     }
[17:44:45.858]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.858]                   }
[17:44:45.858]                 }
[17:44:45.858]             }
[17:44:45.858]         }))
[17:44:45.858]     }, error = function(ex) {
[17:44:45.858]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.858]                 ...future.rng), started = ...future.startTime, 
[17:44:45.858]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.858]             version = "1.8"), class = "FutureResult")
[17:44:45.858]     }, finally = {
[17:44:45.858]         if (!identical(...future.workdir, getwd())) 
[17:44:45.858]             setwd(...future.workdir)
[17:44:45.858]         {
[17:44:45.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.858]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.858]             }
[17:44:45.858]             base::options(...future.oldOptions)
[17:44:45.858]             if (.Platform$OS.type == "windows") {
[17:44:45.858]                 old_names <- names(...future.oldEnvVars)
[17:44:45.858]                 envs <- base::Sys.getenv()
[17:44:45.858]                 names <- names(envs)
[17:44:45.858]                 common <- intersect(names, old_names)
[17:44:45.858]                 added <- setdiff(names, old_names)
[17:44:45.858]                 removed <- setdiff(old_names, names)
[17:44:45.858]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.858]                   envs[common]]
[17:44:45.858]                 NAMES <- toupper(changed)
[17:44:45.858]                 args <- list()
[17:44:45.858]                 for (kk in seq_along(NAMES)) {
[17:44:45.858]                   name <- changed[[kk]]
[17:44:45.858]                   NAME <- NAMES[[kk]]
[17:44:45.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.858]                     next
[17:44:45.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.858]                 }
[17:44:45.858]                 NAMES <- toupper(added)
[17:44:45.858]                 for (kk in seq_along(NAMES)) {
[17:44:45.858]                   name <- added[[kk]]
[17:44:45.858]                   NAME <- NAMES[[kk]]
[17:44:45.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.858]                     next
[17:44:45.858]                   args[[name]] <- ""
[17:44:45.858]                 }
[17:44:45.858]                 NAMES <- toupper(removed)
[17:44:45.858]                 for (kk in seq_along(NAMES)) {
[17:44:45.858]                   name <- removed[[kk]]
[17:44:45.858]                   NAME <- NAMES[[kk]]
[17:44:45.858]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.858]                     next
[17:44:45.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.858]                 }
[17:44:45.858]                 if (length(args) > 0) 
[17:44:45.858]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.858]             }
[17:44:45.858]             else {
[17:44:45.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.858]             }
[17:44:45.858]             {
[17:44:45.858]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.858]                   0L) {
[17:44:45.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.858]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.858]                   base::options(opts)
[17:44:45.858]                 }
[17:44:45.858]                 {
[17:44:45.858]                   {
[17:44:45.858]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.858]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.858]                     -484569582L), envir = base::globalenv(), 
[17:44:45.858]                       inherits = FALSE)
[17:44:45.858]                     NULL
[17:44:45.858]                   }
[17:44:45.858]                   options(future.plan = NULL)
[17:44:45.858]                   if (is.na(NA_character_)) 
[17:44:45.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.858]                     .init = FALSE)
[17:44:45.858]                 }
[17:44:45.858]             }
[17:44:45.858]         }
[17:44:45.858]     })
[17:44:45.858]     if (TRUE) {
[17:44:45.858]         base::sink(type = "output", split = FALSE)
[17:44:45.858]         if (TRUE) {
[17:44:45.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.858]         }
[17:44:45.858]         else {
[17:44:45.858]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.858]         }
[17:44:45.858]         base::close(...future.stdout)
[17:44:45.858]         ...future.stdout <- NULL
[17:44:45.858]     }
[17:44:45.858]     ...future.result$conditions <- ...future.conditions
[17:44:45.858]     ...future.result$finished <- base::Sys.time()
[17:44:45.858]     ...future.result
[17:44:45.858] }
[17:44:45.860] assign_globals() ...
[17:44:45.860] List of 5
[17:44:45.860]  $ ...future.FUN            :function (C, k)  
[17:44:45.860]  $ MoreArgs                 : NULL
[17:44:45.860]  $ ...future.elements_ii    :List of 2
[17:44:45.860]   ..$ :List of 2
[17:44:45.860]   .. ..$ : chr "E"
[17:44:45.860]   .. ..$ : chr "D"
[17:44:45.860]   ..$ :List of 2
[17:44:45.860]   .. ..$ : int 1
[17:44:45.860]   .. ..$ : int 2
[17:44:45.860]  $ ...future.seeds_ii       : NULL
[17:44:45.860]  $ ...future.globals.maxSize: NULL
[17:44:45.860]  - attr(*, "where")=List of 5
[17:44:45.860]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.860]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.860]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.860]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.860]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.860]  - attr(*, "resolved")= logi FALSE
[17:44:45.860]  - attr(*, "total_size")= num 3656
[17:44:45.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.860]  - attr(*, "already-done")= logi TRUE
[17:44:45.867] - reassign environment for ‘...future.FUN’
[17:44:45.867] - copied ‘...future.FUN’ to environment
[17:44:45.867] - copied ‘MoreArgs’ to environment
[17:44:45.867] - copied ‘...future.elements_ii’ to environment
[17:44:45.867] - copied ‘...future.seeds_ii’ to environment
[17:44:45.867] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.867] assign_globals() ... done
[17:44:45.867] plan(): Setting new future strategy stack:
[17:44:45.868] List of future strategies:
[17:44:45.868] 1. sequential:
[17:44:45.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.868]    - tweaked: FALSE
[17:44:45.868]    - call: NULL
[17:44:45.868] plan(): nbrOfWorkers() = 1
[17:44:45.869] plan(): Setting new future strategy stack:
[17:44:45.869] List of future strategies:
[17:44:45.869] 1. sequential:
[17:44:45.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.869]    - tweaked: FALSE
[17:44:45.869]    - call: plan(strategy)
[17:44:45.869] plan(): nbrOfWorkers() = 1
[17:44:45.869] SequentialFuture started (and completed)
[17:44:45.869] - Launch lazy future ... done
[17:44:45.870] run() for ‘SequentialFuture’ ... done
[17:44:45.870] Created future:
[17:44:45.870] SequentialFuture:
[17:44:45.870] Label: ‘future_mapply-1’
[17:44:45.870] Expression:
[17:44:45.870] {
[17:44:45.870]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.870]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.870]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.870]         on.exit(options(oopts), add = TRUE)
[17:44:45.870]     }
[17:44:45.870]     {
[17:44:45.870]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.870]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.870]         do.call(mapply, args = args)
[17:44:45.870]     }
[17:44:45.870] }
[17:44:45.870] Lazy evaluation: FALSE
[17:44:45.870] Asynchronous evaluation: FALSE
[17:44:45.870] Local evaluation: TRUE
[17:44:45.870] Environment: R_GlobalEnv
[17:44:45.870] Capture standard output: TRUE
[17:44:45.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.870] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.870] Packages: <none>
[17:44:45.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.870] Resolved: TRUE
[17:44:45.870] Value: 224 bytes of class ‘list’
[17:44:45.870] Early signaling: FALSE
[17:44:45.870] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.870] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.871] Chunk #1 of 2 ... DONE
[17:44:45.871] Chunk #2 of 2 ...
[17:44:45.871]  - Finding globals in '...' for chunk #2 ...
[17:44:45.871] getGlobalsAndPackages() ...
[17:44:45.871] Searching for globals...
[17:44:45.871] 
[17:44:45.871] Searching for globals ... DONE
[17:44:45.872] - globals: [0] <none>
[17:44:45.872] getGlobalsAndPackages() ... DONE
[17:44:45.872]    + additional globals found: [n=0] 
[17:44:45.872]    + additional namespaces needed: [n=0] 
[17:44:45.872]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:45.872]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:45.872]  - seeds: <none>
[17:44:45.872]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.872] getGlobalsAndPackages() ...
[17:44:45.872] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.872] Resolving globals: FALSE
[17:44:45.873] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:45.873] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.873] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.874] 
[17:44:45.874] getGlobalsAndPackages() ... DONE
[17:44:45.874] run() for ‘Future’ ...
[17:44:45.874] - state: ‘created’
[17:44:45.874] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.874] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.875]   - Field: ‘label’
[17:44:45.875]   - Field: ‘local’
[17:44:45.875]   - Field: ‘owner’
[17:44:45.875]   - Field: ‘envir’
[17:44:45.875]   - Field: ‘packages’
[17:44:45.875]   - Field: ‘gc’
[17:44:45.875]   - Field: ‘conditions’
[17:44:45.875]   - Field: ‘expr’
[17:44:45.875]   - Field: ‘uuid’
[17:44:45.875]   - Field: ‘seed’
[17:44:45.876]   - Field: ‘version’
[17:44:45.876]   - Field: ‘result’
[17:44:45.876]   - Field: ‘asynchronous’
[17:44:45.876]   - Field: ‘calls’
[17:44:45.876]   - Field: ‘globals’
[17:44:45.876]   - Field: ‘stdout’
[17:44:45.876]   - Field: ‘earlySignal’
[17:44:45.876]   - Field: ‘lazy’
[17:44:45.876]   - Field: ‘state’
[17:44:45.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.876] - Launch lazy future ...
[17:44:45.877] Packages needed by the future expression (n = 0): <none>
[17:44:45.877] Packages needed by future strategies (n = 0): <none>
[17:44:45.877] {
[17:44:45.877]     {
[17:44:45.877]         {
[17:44:45.877]             ...future.startTime <- base::Sys.time()
[17:44:45.877]             {
[17:44:45.877]                 {
[17:44:45.877]                   {
[17:44:45.877]                     base::local({
[17:44:45.877]                       has_future <- base::requireNamespace("future", 
[17:44:45.877]                         quietly = TRUE)
[17:44:45.877]                       if (has_future) {
[17:44:45.877]                         ns <- base::getNamespace("future")
[17:44:45.877]                         version <- ns[[".package"]][["version"]]
[17:44:45.877]                         if (is.null(version)) 
[17:44:45.877]                           version <- utils::packageVersion("future")
[17:44:45.877]                       }
[17:44:45.877]                       else {
[17:44:45.877]                         version <- NULL
[17:44:45.877]                       }
[17:44:45.877]                       if (!has_future || version < "1.8.0") {
[17:44:45.877]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.877]                           "", base::R.version$version.string), 
[17:44:45.877]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.877]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.877]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.877]                             "release", "version")], collapse = " "), 
[17:44:45.877]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.877]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.877]                           info)
[17:44:45.877]                         info <- base::paste(info, collapse = "; ")
[17:44:45.877]                         if (!has_future) {
[17:44:45.877]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.877]                             info)
[17:44:45.877]                         }
[17:44:45.877]                         else {
[17:44:45.877]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.877]                             info, version)
[17:44:45.877]                         }
[17:44:45.877]                         base::stop(msg)
[17:44:45.877]                       }
[17:44:45.877]                     })
[17:44:45.877]                   }
[17:44:45.877]                   ...future.strategy.old <- future::plan("list")
[17:44:45.877]                   options(future.plan = NULL)
[17:44:45.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.877]                 }
[17:44:45.877]                 ...future.workdir <- getwd()
[17:44:45.877]             }
[17:44:45.877]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.877]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.877]         }
[17:44:45.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.877]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:45.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.877]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.877]             base::names(...future.oldOptions))
[17:44:45.877]     }
[17:44:45.877]     if (FALSE) {
[17:44:45.877]     }
[17:44:45.877]     else {
[17:44:45.877]         if (TRUE) {
[17:44:45.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.877]                 open = "w")
[17:44:45.877]         }
[17:44:45.877]         else {
[17:44:45.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.877]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.877]         }
[17:44:45.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.877]             base::sink(type = "output", split = FALSE)
[17:44:45.877]             base::close(...future.stdout)
[17:44:45.877]         }, add = TRUE)
[17:44:45.877]     }
[17:44:45.877]     ...future.frame <- base::sys.nframe()
[17:44:45.877]     ...future.conditions <- base::list()
[17:44:45.877]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.877]     if (FALSE) {
[17:44:45.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.877]     }
[17:44:45.877]     ...future.result <- base::tryCatch({
[17:44:45.877]         base::withCallingHandlers({
[17:44:45.877]             ...future.value <- base::withVisible(base::local({
[17:44:45.877]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.877]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.877]                   ...future.globals.maxSize)) {
[17:44:45.877]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.877]                   on.exit(options(oopts), add = TRUE)
[17:44:45.877]                 }
[17:44:45.877]                 {
[17:44:45.877]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.877]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.877]                     USE.NAMES = FALSE)
[17:44:45.877]                   do.call(mapply, args = args)
[17:44:45.877]                 }
[17:44:45.877]             }))
[17:44:45.877]             future::FutureResult(value = ...future.value$value, 
[17:44:45.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.877]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.877]                     ...future.globalenv.names))
[17:44:45.877]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.877]         }, condition = base::local({
[17:44:45.877]             c <- base::c
[17:44:45.877]             inherits <- base::inherits
[17:44:45.877]             invokeRestart <- base::invokeRestart
[17:44:45.877]             length <- base::length
[17:44:45.877]             list <- base::list
[17:44:45.877]             seq.int <- base::seq.int
[17:44:45.877]             signalCondition <- base::signalCondition
[17:44:45.877]             sys.calls <- base::sys.calls
[17:44:45.877]             `[[` <- base::`[[`
[17:44:45.877]             `+` <- base::`+`
[17:44:45.877]             `<<-` <- base::`<<-`
[17:44:45.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.877]                   3L)]
[17:44:45.877]             }
[17:44:45.877]             function(cond) {
[17:44:45.877]                 is_error <- inherits(cond, "error")
[17:44:45.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.877]                   NULL)
[17:44:45.877]                 if (is_error) {
[17:44:45.877]                   sessionInformation <- function() {
[17:44:45.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.877]                       search = base::search(), system = base::Sys.info())
[17:44:45.877]                   }
[17:44:45.877]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.877]                     cond$call), session = sessionInformation(), 
[17:44:45.877]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.877]                   signalCondition(cond)
[17:44:45.877]                 }
[17:44:45.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.877]                 "immediateCondition"))) {
[17:44:45.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.877]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.877]                   if (TRUE && !signal) {
[17:44:45.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.877]                     {
[17:44:45.877]                       inherits <- base::inherits
[17:44:45.877]                       invokeRestart <- base::invokeRestart
[17:44:45.877]                       is.null <- base::is.null
[17:44:45.877]                       muffled <- FALSE
[17:44:45.877]                       if (inherits(cond, "message")) {
[17:44:45.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.877]                         if (muffled) 
[17:44:45.877]                           invokeRestart("muffleMessage")
[17:44:45.877]                       }
[17:44:45.877]                       else if (inherits(cond, "warning")) {
[17:44:45.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.877]                         if (muffled) 
[17:44:45.877]                           invokeRestart("muffleWarning")
[17:44:45.877]                       }
[17:44:45.877]                       else if (inherits(cond, "condition")) {
[17:44:45.877]                         if (!is.null(pattern)) {
[17:44:45.877]                           computeRestarts <- base::computeRestarts
[17:44:45.877]                           grepl <- base::grepl
[17:44:45.877]                           restarts <- computeRestarts(cond)
[17:44:45.877]                           for (restart in restarts) {
[17:44:45.877]                             name <- restart$name
[17:44:45.877]                             if (is.null(name)) 
[17:44:45.877]                               next
[17:44:45.877]                             if (!grepl(pattern, name)) 
[17:44:45.877]                               next
[17:44:45.877]                             invokeRestart(restart)
[17:44:45.877]                             muffled <- TRUE
[17:44:45.877]                             break
[17:44:45.877]                           }
[17:44:45.877]                         }
[17:44:45.877]                       }
[17:44:45.877]                       invisible(muffled)
[17:44:45.877]                     }
[17:44:45.877]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.877]                   }
[17:44:45.877]                 }
[17:44:45.877]                 else {
[17:44:45.877]                   if (TRUE) {
[17:44:45.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.877]                     {
[17:44:45.877]                       inherits <- base::inherits
[17:44:45.877]                       invokeRestart <- base::invokeRestart
[17:44:45.877]                       is.null <- base::is.null
[17:44:45.877]                       muffled <- FALSE
[17:44:45.877]                       if (inherits(cond, "message")) {
[17:44:45.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.877]                         if (muffled) 
[17:44:45.877]                           invokeRestart("muffleMessage")
[17:44:45.877]                       }
[17:44:45.877]                       else if (inherits(cond, "warning")) {
[17:44:45.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.877]                         if (muffled) 
[17:44:45.877]                           invokeRestart("muffleWarning")
[17:44:45.877]                       }
[17:44:45.877]                       else if (inherits(cond, "condition")) {
[17:44:45.877]                         if (!is.null(pattern)) {
[17:44:45.877]                           computeRestarts <- base::computeRestarts
[17:44:45.877]                           grepl <- base::grepl
[17:44:45.877]                           restarts <- computeRestarts(cond)
[17:44:45.877]                           for (restart in restarts) {
[17:44:45.877]                             name <- restart$name
[17:44:45.877]                             if (is.null(name)) 
[17:44:45.877]                               next
[17:44:45.877]                             if (!grepl(pattern, name)) 
[17:44:45.877]                               next
[17:44:45.877]                             invokeRestart(restart)
[17:44:45.877]                             muffled <- TRUE
[17:44:45.877]                             break
[17:44:45.877]                           }
[17:44:45.877]                         }
[17:44:45.877]                       }
[17:44:45.877]                       invisible(muffled)
[17:44:45.877]                     }
[17:44:45.877]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.877]                   }
[17:44:45.877]                 }
[17:44:45.877]             }
[17:44:45.877]         }))
[17:44:45.877]     }, error = function(ex) {
[17:44:45.877]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.877]                 ...future.rng), started = ...future.startTime, 
[17:44:45.877]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.877]             version = "1.8"), class = "FutureResult")
[17:44:45.877]     }, finally = {
[17:44:45.877]         if (!identical(...future.workdir, getwd())) 
[17:44:45.877]             setwd(...future.workdir)
[17:44:45.877]         {
[17:44:45.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.877]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.877]             }
[17:44:45.877]             base::options(...future.oldOptions)
[17:44:45.877]             if (.Platform$OS.type == "windows") {
[17:44:45.877]                 old_names <- names(...future.oldEnvVars)
[17:44:45.877]                 envs <- base::Sys.getenv()
[17:44:45.877]                 names <- names(envs)
[17:44:45.877]                 common <- intersect(names, old_names)
[17:44:45.877]                 added <- setdiff(names, old_names)
[17:44:45.877]                 removed <- setdiff(old_names, names)
[17:44:45.877]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.877]                   envs[common]]
[17:44:45.877]                 NAMES <- toupper(changed)
[17:44:45.877]                 args <- list()
[17:44:45.877]                 for (kk in seq_along(NAMES)) {
[17:44:45.877]                   name <- changed[[kk]]
[17:44:45.877]                   NAME <- NAMES[[kk]]
[17:44:45.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.877]                     next
[17:44:45.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.877]                 }
[17:44:45.877]                 NAMES <- toupper(added)
[17:44:45.877]                 for (kk in seq_along(NAMES)) {
[17:44:45.877]                   name <- added[[kk]]
[17:44:45.877]                   NAME <- NAMES[[kk]]
[17:44:45.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.877]                     next
[17:44:45.877]                   args[[name]] <- ""
[17:44:45.877]                 }
[17:44:45.877]                 NAMES <- toupper(removed)
[17:44:45.877]                 for (kk in seq_along(NAMES)) {
[17:44:45.877]                   name <- removed[[kk]]
[17:44:45.877]                   NAME <- NAMES[[kk]]
[17:44:45.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.877]                     next
[17:44:45.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.877]                 }
[17:44:45.877]                 if (length(args) > 0) 
[17:44:45.877]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.877]             }
[17:44:45.877]             else {
[17:44:45.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.877]             }
[17:44:45.877]             {
[17:44:45.877]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.877]                   0L) {
[17:44:45.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.877]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.877]                   base::options(opts)
[17:44:45.877]                 }
[17:44:45.877]                 {
[17:44:45.877]                   {
[17:44:45.877]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.877]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.877]                     -484569582L), envir = base::globalenv(), 
[17:44:45.877]                       inherits = FALSE)
[17:44:45.877]                     NULL
[17:44:45.877]                   }
[17:44:45.877]                   options(future.plan = NULL)
[17:44:45.877]                   if (is.na(NA_character_)) 
[17:44:45.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.877]                     .init = FALSE)
[17:44:45.877]                 }
[17:44:45.877]             }
[17:44:45.877]         }
[17:44:45.877]     })
[17:44:45.877]     if (TRUE) {
[17:44:45.877]         base::sink(type = "output", split = FALSE)
[17:44:45.877]         if (TRUE) {
[17:44:45.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.877]         }
[17:44:45.877]         else {
[17:44:45.877]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.877]         }
[17:44:45.877]         base::close(...future.stdout)
[17:44:45.877]         ...future.stdout <- NULL
[17:44:45.877]     }
[17:44:45.877]     ...future.result$conditions <- ...future.conditions
[17:44:45.877]     ...future.result$finished <- base::Sys.time()
[17:44:45.877]     ...future.result
[17:44:45.877] }
[17:44:45.879] assign_globals() ...
[17:44:45.879] List of 5
[17:44:45.879]  $ ...future.FUN            :function (C, k)  
[17:44:45.879]  $ MoreArgs                 : NULL
[17:44:45.879]  $ ...future.elements_ii    :List of 2
[17:44:45.879]   ..$ :List of 3
[17:44:45.879]   .. ..$ : chr "C"
[17:44:45.879]   .. ..$ : chr "B"
[17:44:45.879]   .. ..$ : chr "A"
[17:44:45.879]   ..$ :List of 3
[17:44:45.879]   .. ..$ : int 3
[17:44:45.879]   .. ..$ : int 4
[17:44:45.879]   .. ..$ : int 5
[17:44:45.879]  $ ...future.seeds_ii       : NULL
[17:44:45.879]  $ ...future.globals.maxSize: NULL
[17:44:45.879]  - attr(*, "where")=List of 5
[17:44:45.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.879]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.879]  - attr(*, "resolved")= logi FALSE
[17:44:45.879]  - attr(*, "total_size")= num 3824
[17:44:45.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.879]  - attr(*, "already-done")= logi TRUE
[17:44:45.885] - reassign environment for ‘...future.FUN’
[17:44:45.885] - copied ‘...future.FUN’ to environment
[17:44:45.885] - copied ‘MoreArgs’ to environment
[17:44:45.885] - copied ‘...future.elements_ii’ to environment
[17:44:45.885] - copied ‘...future.seeds_ii’ to environment
[17:44:45.885] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.885] assign_globals() ... done
[17:44:45.887] plan(): Setting new future strategy stack:
[17:44:45.887] List of future strategies:
[17:44:45.887] 1. sequential:
[17:44:45.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.887]    - tweaked: FALSE
[17:44:45.887]    - call: NULL
[17:44:45.887] plan(): nbrOfWorkers() = 1
[17:44:45.888] plan(): Setting new future strategy stack:
[17:44:45.888] List of future strategies:
[17:44:45.888] 1. sequential:
[17:44:45.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.888]    - tweaked: FALSE
[17:44:45.888]    - call: plan(strategy)
[17:44:45.889] plan(): nbrOfWorkers() = 1
[17:44:45.889] SequentialFuture started (and completed)
[17:44:45.889] - Launch lazy future ... done
[17:44:45.889] run() for ‘SequentialFuture’ ... done
[17:44:45.889] Created future:
[17:44:45.889] SequentialFuture:
[17:44:45.889] Label: ‘future_mapply-2’
[17:44:45.889] Expression:
[17:44:45.889] {
[17:44:45.889]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.889]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.889]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.889]         on.exit(options(oopts), add = TRUE)
[17:44:45.889]     }
[17:44:45.889]     {
[17:44:45.889]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.889]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.889]         do.call(mapply, args = args)
[17:44:45.889]     }
[17:44:45.889] }
[17:44:45.889] Lazy evaluation: FALSE
[17:44:45.889] Asynchronous evaluation: FALSE
[17:44:45.889] Local evaluation: TRUE
[17:44:45.889] Environment: R_GlobalEnv
[17:44:45.889] Capture standard output: TRUE
[17:44:45.889] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.889] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.889] Packages: <none>
[17:44:45.889] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.889] Resolved: TRUE
[17:44:45.889] Value: 336 bytes of class ‘list’
[17:44:45.889] Early signaling: FALSE
[17:44:45.889] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.889] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.890] Chunk #2 of 2 ... DONE
[17:44:45.890] Launching 2 futures (chunks) ... DONE
[17:44:45.891] Resolving 2 futures (chunks) ...
[17:44:45.891] resolve() on list ...
[17:44:45.891]  recursive: 0
[17:44:45.891]  length: 2
[17:44:45.891] 
[17:44:45.891] resolved() for ‘SequentialFuture’ ...
[17:44:45.891] - state: ‘finished’
[17:44:45.891] - run: TRUE
[17:44:45.891] - result: ‘FutureResult’
[17:44:45.891] resolved() for ‘SequentialFuture’ ... done
[17:44:45.892] Future #1
[17:44:45.892] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.892] - nx: 2
[17:44:45.892] - relay: TRUE
[17:44:45.892] - stdout: TRUE
[17:44:45.892] - signal: TRUE
[17:44:45.892] - resignal: FALSE
[17:44:45.892] - force: TRUE
[17:44:45.892] - relayed: [n=2] FALSE, FALSE
[17:44:45.892] - queued futures: [n=2] FALSE, FALSE
[17:44:45.892]  - until=1
[17:44:45.893]  - relaying element #1
[17:44:45.893] - relayed: [n=2] TRUE, FALSE
[17:44:45.893] - queued futures: [n=2] TRUE, FALSE
[17:44:45.893] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.893]  length: 1 (resolved future 1)
[17:44:45.893] resolved() for ‘SequentialFuture’ ...
[17:44:45.893] - state: ‘finished’
[17:44:45.893] - run: TRUE
[17:44:45.893] - result: ‘FutureResult’
[17:44:45.893] resolved() for ‘SequentialFuture’ ... done
[17:44:45.894] Future #2
[17:44:45.894] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:44:45.894] - nx: 2
[17:44:45.894] - relay: TRUE
[17:44:45.894] - stdout: TRUE
[17:44:45.894] - signal: TRUE
[17:44:45.894] - resignal: FALSE
[17:44:45.894] - force: TRUE
[17:44:45.894] - relayed: [n=2] TRUE, FALSE
[17:44:45.894] - queued futures: [n=2] TRUE, FALSE
[17:44:45.894]  - until=2
[17:44:45.895]  - relaying element #2
[17:44:45.895] - relayed: [n=2] TRUE, TRUE
[17:44:45.895] - queued futures: [n=2] TRUE, TRUE
[17:44:45.895] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:44:45.895]  length: 0 (resolved future 2)
[17:44:45.895] Relaying remaining futures
[17:44:45.895] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.895] - nx: 2
[17:44:45.895] - relay: TRUE
[17:44:45.895] - stdout: TRUE
[17:44:45.896] - signal: TRUE
[17:44:45.896] - resignal: FALSE
[17:44:45.896] - force: TRUE
[17:44:45.896] - relayed: [n=2] TRUE, TRUE
[17:44:45.896] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:45.896] - relayed: [n=2] TRUE, TRUE
[17:44:45.896] - queued futures: [n=2] TRUE, TRUE
[17:44:45.896] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.896] resolve() on list ... DONE
[17:44:45.896]  - Number of value chunks collected: 2
[17:44:45.897] Resolving 2 futures (chunks) ... DONE
[17:44:45.897] Reducing values from 2 chunks ...
[17:44:45.897]  - Number of values collected after concatenation: 5
[17:44:45.897]  - Number of values expected: 5
[17:44:45.897] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:45.897] Reducing values from 2 chunks ... DONE
[17:44:45.897] future_mapply() ... DONE
[17:44:45.897] future_mapply() ...
[17:44:45.898] Number of chunks: 1
[17:44:45.898] getGlobalsAndPackagesXApply() ...
[17:44:45.898]  - future.globals: TRUE
[17:44:45.898] getGlobalsAndPackages() ...
[17:44:45.898] Searching for globals...
[17:44:45.899] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:45.899] Searching for globals ... DONE
[17:44:45.899] Resolving globals: FALSE
[17:44:45.900] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:45.900] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:45.900] - globals: [1] ‘FUN’
[17:44:45.900] 
[17:44:45.900] getGlobalsAndPackages() ... DONE
[17:44:45.900]  - globals found/used: [n=1] ‘FUN’
[17:44:45.900]  - needed namespaces: [n=0] 
[17:44:45.901] Finding globals ... DONE
[17:44:45.901] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.901] List of 2
[17:44:45.901]  $ ...future.FUN:function (C, k)  
[17:44:45.901]  $ MoreArgs     : list()
[17:44:45.901]  - attr(*, "where")=List of 2
[17:44:45.901]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.901]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.901]  - attr(*, "resolved")= logi FALSE
[17:44:45.901]  - attr(*, "total_size")= num NA
[17:44:45.903] Packages to be attached in all futures: [n=0] 
[17:44:45.903] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.904] Number of futures (= number of chunks): 1
[17:44:45.904] Launching 1 futures (chunks) ...
[17:44:45.904] Chunk #1 of 1 ...
[17:44:45.904]  - Finding globals in '...' for chunk #1 ...
[17:44:45.904] getGlobalsAndPackages() ...
[17:44:45.904] Searching for globals...
[17:44:45.904] 
[17:44:45.904] Searching for globals ... DONE
[17:44:45.905] - globals: [0] <none>
[17:44:45.905] getGlobalsAndPackages() ... DONE
[17:44:45.905]    + additional globals found: [n=0] 
[17:44:45.905]    + additional namespaces needed: [n=0] 
[17:44:45.905]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.905]  - seeds: <none>
[17:44:45.905]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.905] getGlobalsAndPackages() ...
[17:44:45.905] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.905] Resolving globals: FALSE
[17:44:45.906] The total size of the 5 globals is 4.06 KiB (4160 bytes)
[17:44:45.906] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 4.06 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (840 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:45.906] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.906] 
[17:44:45.907] getGlobalsAndPackages() ... DONE
[17:44:45.907] run() for ‘Future’ ...
[17:44:45.907] - state: ‘created’
[17:44:45.907] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.907] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.908]   - Field: ‘label’
[17:44:45.908]   - Field: ‘local’
[17:44:45.908]   - Field: ‘owner’
[17:44:45.908]   - Field: ‘envir’
[17:44:45.908]   - Field: ‘packages’
[17:44:45.908]   - Field: ‘gc’
[17:44:45.908]   - Field: ‘conditions’
[17:44:45.908]   - Field: ‘expr’
[17:44:45.908]   - Field: ‘uuid’
[17:44:45.908]   - Field: ‘seed’
[17:44:45.908]   - Field: ‘version’
[17:44:45.909]   - Field: ‘result’
[17:44:45.909]   - Field: ‘asynchronous’
[17:44:45.909]   - Field: ‘calls’
[17:44:45.909]   - Field: ‘globals’
[17:44:45.909]   - Field: ‘stdout’
[17:44:45.909]   - Field: ‘earlySignal’
[17:44:45.909]   - Field: ‘lazy’
[17:44:45.909]   - Field: ‘state’
[17:44:45.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.909] - Launch lazy future ...
[17:44:45.910] Packages needed by the future expression (n = 0): <none>
[17:44:45.910] Packages needed by future strategies (n = 0): <none>
[17:44:45.912] {
[17:44:45.912]     {
[17:44:45.912]         {
[17:44:45.912]             ...future.startTime <- base::Sys.time()
[17:44:45.912]             {
[17:44:45.912]                 {
[17:44:45.912]                   {
[17:44:45.912]                     base::local({
[17:44:45.912]                       has_future <- base::requireNamespace("future", 
[17:44:45.912]                         quietly = TRUE)
[17:44:45.912]                       if (has_future) {
[17:44:45.912]                         ns <- base::getNamespace("future")
[17:44:45.912]                         version <- ns[[".package"]][["version"]]
[17:44:45.912]                         if (is.null(version)) 
[17:44:45.912]                           version <- utils::packageVersion("future")
[17:44:45.912]                       }
[17:44:45.912]                       else {
[17:44:45.912]                         version <- NULL
[17:44:45.912]                       }
[17:44:45.912]                       if (!has_future || version < "1.8.0") {
[17:44:45.912]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.912]                           "", base::R.version$version.string), 
[17:44:45.912]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.912]                             "release", "version")], collapse = " "), 
[17:44:45.912]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.912]                           info)
[17:44:45.912]                         info <- base::paste(info, collapse = "; ")
[17:44:45.912]                         if (!has_future) {
[17:44:45.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.912]                             info)
[17:44:45.912]                         }
[17:44:45.912]                         else {
[17:44:45.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.912]                             info, version)
[17:44:45.912]                         }
[17:44:45.912]                         base::stop(msg)
[17:44:45.912]                       }
[17:44:45.912]                     })
[17:44:45.912]                   }
[17:44:45.912]                   ...future.strategy.old <- future::plan("list")
[17:44:45.912]                   options(future.plan = NULL)
[17:44:45.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.912]                 }
[17:44:45.912]                 ...future.workdir <- getwd()
[17:44:45.912]             }
[17:44:45.912]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.912]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.912]         }
[17:44:45.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.912]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.912]             base::names(...future.oldOptions))
[17:44:45.912]     }
[17:44:45.912]     if (FALSE) {
[17:44:45.912]     }
[17:44:45.912]     else {
[17:44:45.912]         if (TRUE) {
[17:44:45.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.912]                 open = "w")
[17:44:45.912]         }
[17:44:45.912]         else {
[17:44:45.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.912]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.912]         }
[17:44:45.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.912]             base::sink(type = "output", split = FALSE)
[17:44:45.912]             base::close(...future.stdout)
[17:44:45.912]         }, add = TRUE)
[17:44:45.912]     }
[17:44:45.912]     ...future.frame <- base::sys.nframe()
[17:44:45.912]     ...future.conditions <- base::list()
[17:44:45.912]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.912]     if (FALSE) {
[17:44:45.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.912]     }
[17:44:45.912]     ...future.result <- base::tryCatch({
[17:44:45.912]         base::withCallingHandlers({
[17:44:45.912]             ...future.value <- base::withVisible(base::local({
[17:44:45.912]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.912]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.912]                   ...future.globals.maxSize)) {
[17:44:45.912]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.912]                   on.exit(options(oopts), add = TRUE)
[17:44:45.912]                 }
[17:44:45.912]                 {
[17:44:45.912]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.912]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.912]                     USE.NAMES = FALSE)
[17:44:45.912]                   do.call(mapply, args = args)
[17:44:45.912]                 }
[17:44:45.912]             }))
[17:44:45.912]             future::FutureResult(value = ...future.value$value, 
[17:44:45.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.912]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.912]                     ...future.globalenv.names))
[17:44:45.912]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.912]         }, condition = base::local({
[17:44:45.912]             c <- base::c
[17:44:45.912]             inherits <- base::inherits
[17:44:45.912]             invokeRestart <- base::invokeRestart
[17:44:45.912]             length <- base::length
[17:44:45.912]             list <- base::list
[17:44:45.912]             seq.int <- base::seq.int
[17:44:45.912]             signalCondition <- base::signalCondition
[17:44:45.912]             sys.calls <- base::sys.calls
[17:44:45.912]             `[[` <- base::`[[`
[17:44:45.912]             `+` <- base::`+`
[17:44:45.912]             `<<-` <- base::`<<-`
[17:44:45.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.912]                   3L)]
[17:44:45.912]             }
[17:44:45.912]             function(cond) {
[17:44:45.912]                 is_error <- inherits(cond, "error")
[17:44:45.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.912]                   NULL)
[17:44:45.912]                 if (is_error) {
[17:44:45.912]                   sessionInformation <- function() {
[17:44:45.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.912]                       search = base::search(), system = base::Sys.info())
[17:44:45.912]                   }
[17:44:45.912]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.912]                     cond$call), session = sessionInformation(), 
[17:44:45.912]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.912]                   signalCondition(cond)
[17:44:45.912]                 }
[17:44:45.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.912]                 "immediateCondition"))) {
[17:44:45.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.912]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.912]                   if (TRUE && !signal) {
[17:44:45.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.912]                     {
[17:44:45.912]                       inherits <- base::inherits
[17:44:45.912]                       invokeRestart <- base::invokeRestart
[17:44:45.912]                       is.null <- base::is.null
[17:44:45.912]                       muffled <- FALSE
[17:44:45.912]                       if (inherits(cond, "message")) {
[17:44:45.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.912]                         if (muffled) 
[17:44:45.912]                           invokeRestart("muffleMessage")
[17:44:45.912]                       }
[17:44:45.912]                       else if (inherits(cond, "warning")) {
[17:44:45.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.912]                         if (muffled) 
[17:44:45.912]                           invokeRestart("muffleWarning")
[17:44:45.912]                       }
[17:44:45.912]                       else if (inherits(cond, "condition")) {
[17:44:45.912]                         if (!is.null(pattern)) {
[17:44:45.912]                           computeRestarts <- base::computeRestarts
[17:44:45.912]                           grepl <- base::grepl
[17:44:45.912]                           restarts <- computeRestarts(cond)
[17:44:45.912]                           for (restart in restarts) {
[17:44:45.912]                             name <- restart$name
[17:44:45.912]                             if (is.null(name)) 
[17:44:45.912]                               next
[17:44:45.912]                             if (!grepl(pattern, name)) 
[17:44:45.912]                               next
[17:44:45.912]                             invokeRestart(restart)
[17:44:45.912]                             muffled <- TRUE
[17:44:45.912]                             break
[17:44:45.912]                           }
[17:44:45.912]                         }
[17:44:45.912]                       }
[17:44:45.912]                       invisible(muffled)
[17:44:45.912]                     }
[17:44:45.912]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.912]                   }
[17:44:45.912]                 }
[17:44:45.912]                 else {
[17:44:45.912]                   if (TRUE) {
[17:44:45.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.912]                     {
[17:44:45.912]                       inherits <- base::inherits
[17:44:45.912]                       invokeRestart <- base::invokeRestart
[17:44:45.912]                       is.null <- base::is.null
[17:44:45.912]                       muffled <- FALSE
[17:44:45.912]                       if (inherits(cond, "message")) {
[17:44:45.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.912]                         if (muffled) 
[17:44:45.912]                           invokeRestart("muffleMessage")
[17:44:45.912]                       }
[17:44:45.912]                       else if (inherits(cond, "warning")) {
[17:44:45.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.912]                         if (muffled) 
[17:44:45.912]                           invokeRestart("muffleWarning")
[17:44:45.912]                       }
[17:44:45.912]                       else if (inherits(cond, "condition")) {
[17:44:45.912]                         if (!is.null(pattern)) {
[17:44:45.912]                           computeRestarts <- base::computeRestarts
[17:44:45.912]                           grepl <- base::grepl
[17:44:45.912]                           restarts <- computeRestarts(cond)
[17:44:45.912]                           for (restart in restarts) {
[17:44:45.912]                             name <- restart$name
[17:44:45.912]                             if (is.null(name)) 
[17:44:45.912]                               next
[17:44:45.912]                             if (!grepl(pattern, name)) 
[17:44:45.912]                               next
[17:44:45.912]                             invokeRestart(restart)
[17:44:45.912]                             muffled <- TRUE
[17:44:45.912]                             break
[17:44:45.912]                           }
[17:44:45.912]                         }
[17:44:45.912]                       }
[17:44:45.912]                       invisible(muffled)
[17:44:45.912]                     }
[17:44:45.912]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.912]                   }
[17:44:45.912]                 }
[17:44:45.912]             }
[17:44:45.912]         }))
[17:44:45.912]     }, error = function(ex) {
[17:44:45.912]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.912]                 ...future.rng), started = ...future.startTime, 
[17:44:45.912]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.912]             version = "1.8"), class = "FutureResult")
[17:44:45.912]     }, finally = {
[17:44:45.912]         if (!identical(...future.workdir, getwd())) 
[17:44:45.912]             setwd(...future.workdir)
[17:44:45.912]         {
[17:44:45.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.912]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.912]             }
[17:44:45.912]             base::options(...future.oldOptions)
[17:44:45.912]             if (.Platform$OS.type == "windows") {
[17:44:45.912]                 old_names <- names(...future.oldEnvVars)
[17:44:45.912]                 envs <- base::Sys.getenv()
[17:44:45.912]                 names <- names(envs)
[17:44:45.912]                 common <- intersect(names, old_names)
[17:44:45.912]                 added <- setdiff(names, old_names)
[17:44:45.912]                 removed <- setdiff(old_names, names)
[17:44:45.912]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.912]                   envs[common]]
[17:44:45.912]                 NAMES <- toupper(changed)
[17:44:45.912]                 args <- list()
[17:44:45.912]                 for (kk in seq_along(NAMES)) {
[17:44:45.912]                   name <- changed[[kk]]
[17:44:45.912]                   NAME <- NAMES[[kk]]
[17:44:45.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.912]                     next
[17:44:45.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.912]                 }
[17:44:45.912]                 NAMES <- toupper(added)
[17:44:45.912]                 for (kk in seq_along(NAMES)) {
[17:44:45.912]                   name <- added[[kk]]
[17:44:45.912]                   NAME <- NAMES[[kk]]
[17:44:45.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.912]                     next
[17:44:45.912]                   args[[name]] <- ""
[17:44:45.912]                 }
[17:44:45.912]                 NAMES <- toupper(removed)
[17:44:45.912]                 for (kk in seq_along(NAMES)) {
[17:44:45.912]                   name <- removed[[kk]]
[17:44:45.912]                   NAME <- NAMES[[kk]]
[17:44:45.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.912]                     next
[17:44:45.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.912]                 }
[17:44:45.912]                 if (length(args) > 0) 
[17:44:45.912]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.912]             }
[17:44:45.912]             else {
[17:44:45.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.912]             }
[17:44:45.912]             {
[17:44:45.912]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.912]                   0L) {
[17:44:45.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.912]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.912]                   base::options(opts)
[17:44:45.912]                 }
[17:44:45.912]                 {
[17:44:45.912]                   {
[17:44:45.912]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.912]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.912]                     -484569582L), envir = base::globalenv(), 
[17:44:45.912]                       inherits = FALSE)
[17:44:45.912]                     NULL
[17:44:45.912]                   }
[17:44:45.912]                   options(future.plan = NULL)
[17:44:45.912]                   if (is.na(NA_character_)) 
[17:44:45.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.912]                     .init = FALSE)
[17:44:45.912]                 }
[17:44:45.912]             }
[17:44:45.912]         }
[17:44:45.912]     })
[17:44:45.912]     if (TRUE) {
[17:44:45.912]         base::sink(type = "output", split = FALSE)
[17:44:45.912]         if (TRUE) {
[17:44:45.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.912]         }
[17:44:45.912]         else {
[17:44:45.912]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.912]         }
[17:44:45.912]         base::close(...future.stdout)
[17:44:45.912]         ...future.stdout <- NULL
[17:44:45.912]     }
[17:44:45.912]     ...future.result$conditions <- ...future.conditions
[17:44:45.912]     ...future.result$finished <- base::Sys.time()
[17:44:45.912]     ...future.result
[17:44:45.912] }
[17:44:45.913] assign_globals() ...
[17:44:45.913] List of 5
[17:44:45.913]  $ ...future.FUN            :function (C, k)  
[17:44:45.913]  $ MoreArgs                 : list()
[17:44:45.913]  $ ...future.elements_ii    :List of 2
[17:44:45.913]   ..$ :List of 5
[17:44:45.913]   .. ..$ : chr "A"
[17:44:45.913]   .. ..$ : chr "B"
[17:44:45.913]   .. ..$ : chr "C"
[17:44:45.913]   .. ..$ : chr "D"
[17:44:45.913]   .. ..$ : chr "E"
[17:44:45.913]   ..$ :List of 5
[17:44:45.913]   .. ..$ : int 5
[17:44:45.913]   .. ..$ : int 4
[17:44:45.913]   .. ..$ : int 3
[17:44:45.913]   .. ..$ : int 2
[17:44:45.913]   .. ..$ : int 1
[17:44:45.913]  $ ...future.seeds_ii       : NULL
[17:44:45.913]  $ ...future.globals.maxSize: NULL
[17:44:45.913]  - attr(*, "where")=List of 5
[17:44:45.913]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.913]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.913]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.913]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.913]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.913]  - attr(*, "resolved")= logi FALSE
[17:44:45.913]  - attr(*, "total_size")= num 4160
[17:44:45.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.913]  - attr(*, "already-done")= logi TRUE
[17:44:45.920] - reassign environment for ‘...future.FUN’
[17:44:45.920] - copied ‘...future.FUN’ to environment
[17:44:45.920] - copied ‘MoreArgs’ to environment
[17:44:45.921] - copied ‘...future.elements_ii’ to environment
[17:44:45.921] - copied ‘...future.seeds_ii’ to environment
[17:44:45.921] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.921] assign_globals() ... done
[17:44:45.921] plan(): Setting new future strategy stack:
[17:44:45.921] List of future strategies:
[17:44:45.921] 1. sequential:
[17:44:45.921]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.921]    - tweaked: FALSE
[17:44:45.921]    - call: NULL
[17:44:45.922] plan(): nbrOfWorkers() = 1
[17:44:45.922] plan(): Setting new future strategy stack:
[17:44:45.922] List of future strategies:
[17:44:45.922] 1. sequential:
[17:44:45.922]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.922]    - tweaked: FALSE
[17:44:45.922]    - call: plan(strategy)
[17:44:45.923] plan(): nbrOfWorkers() = 1
[17:44:45.923] SequentialFuture started (and completed)
[17:44:45.923] - Launch lazy future ... done
[17:44:45.923] run() for ‘SequentialFuture’ ... done
[17:44:45.923] Created future:
[17:44:45.923] SequentialFuture:
[17:44:45.923] Label: ‘future_.mapply-1’
[17:44:45.923] Expression:
[17:44:45.923] {
[17:44:45.923]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.923]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.923]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.923]         on.exit(options(oopts), add = TRUE)
[17:44:45.923]     }
[17:44:45.923]     {
[17:44:45.923]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.923]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.923]         do.call(mapply, args = args)
[17:44:45.923]     }
[17:44:45.923] }
[17:44:45.923] Lazy evaluation: FALSE
[17:44:45.923] Asynchronous evaluation: FALSE
[17:44:45.923] Local evaluation: TRUE
[17:44:45.923] Environment: R_GlobalEnv
[17:44:45.923] Capture standard output: TRUE
[17:44:45.923] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.923] Globals: 5 objects totaling 4.06 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 840 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.923] Packages: <none>
[17:44:45.923] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.923] Resolved: TRUE
[17:44:45.923] Value: 560 bytes of class ‘list’
[17:44:45.923] Early signaling: FALSE
[17:44:45.923] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.923] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.924] Chunk #1 of 1 ... DONE
[17:44:45.924] Launching 1 futures (chunks) ... DONE
[17:44:45.925] Resolving 1 futures (chunks) ...
[17:44:45.925] resolve() on list ...
[17:44:45.925]  recursive: 0
[17:44:45.925]  length: 1
[17:44:45.925] 
[17:44:45.925] resolved() for ‘SequentialFuture’ ...
[17:44:45.925] - state: ‘finished’
[17:44:45.925] - run: TRUE
[17:44:45.925] - result: ‘FutureResult’
[17:44:45.925] resolved() for ‘SequentialFuture’ ... done
[17:44:45.925] Future #1
[17:44:45.926] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.926] - nx: 1
[17:44:45.926] - relay: TRUE
[17:44:45.926] - stdout: TRUE
[17:44:45.926] - signal: TRUE
[17:44:45.926] - resignal: FALSE
[17:44:45.926] - force: TRUE
[17:44:45.926] - relayed: [n=1] FALSE
[17:44:45.926] - queued futures: [n=1] FALSE
[17:44:45.926]  - until=1
[17:44:45.926]  - relaying element #1
[17:44:45.927] - relayed: [n=1] TRUE
[17:44:45.927] - queued futures: [n=1] TRUE
[17:44:45.927] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.927]  length: 0 (resolved future 1)
[17:44:45.927] Relaying remaining futures
[17:44:45.927] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.927] - nx: 1
[17:44:45.927] - relay: TRUE
[17:44:45.927] - stdout: TRUE
[17:44:45.927] - signal: TRUE
[17:44:45.928] - resignal: FALSE
[17:44:45.928] - force: TRUE
[17:44:45.928] - relayed: [n=1] TRUE
[17:44:45.928] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.928] - relayed: [n=1] TRUE
[17:44:45.928] - queued futures: [n=1] TRUE
[17:44:45.928] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.928] resolve() on list ... DONE
[17:44:45.928]  - Number of value chunks collected: 1
[17:44:45.928] Resolving 1 futures (chunks) ... DONE
[17:44:45.928] Reducing values from 1 chunks ...
[17:44:45.929]  - Number of values collected after concatenation: 5
[17:44:45.929]  - Number of values expected: 5
[17:44:45.929] Reducing values from 1 chunks ... DONE
[17:44:45.929] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:44:45.929] future_mapply() ...
[17:44:45.930] Number of chunks: 1
[17:44:45.930] getGlobalsAndPackagesXApply() ...
[17:44:45.930]  - future.globals: TRUE
[17:44:45.930] getGlobalsAndPackages() ...
[17:44:45.930] Searching for globals...
[17:44:45.931] - globals found: [1] ‘FUN’
[17:44:45.931] Searching for globals ... DONE
[17:44:45.931] Resolving globals: FALSE
[17:44:45.931] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:45.932] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:45.932] - globals: [1] ‘FUN’
[17:44:45.932] 
[17:44:45.932] getGlobalsAndPackages() ... DONE
[17:44:45.932]  - globals found/used: [n=1] ‘FUN’
[17:44:45.932]  - needed namespaces: [n=0] 
[17:44:45.932] Finding globals ... DONE
[17:44:45.932] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.933] List of 2
[17:44:45.933]  $ ...future.FUN:function (x)  
[17:44:45.933]  $ MoreArgs     : NULL
[17:44:45.933]  - attr(*, "where")=List of 2
[17:44:45.933]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.933]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.933]  - attr(*, "resolved")= logi FALSE
[17:44:45.933]  - attr(*, "total_size")= num NA
[17:44:45.937] Packages to be attached in all futures: [n=0] 
[17:44:45.937] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.937] Number of futures (= number of chunks): 1
[17:44:45.937] Launching 1 futures (chunks) ...
[17:44:45.937] Chunk #1 of 1 ...
[17:44:45.937]  - Finding globals in '...' for chunk #1 ...
[17:44:45.937] getGlobalsAndPackages() ...
[17:44:45.938] Searching for globals...
[17:44:45.938] 
[17:44:45.938] Searching for globals ... DONE
[17:44:45.938] - globals: [0] <none>
[17:44:45.938] getGlobalsAndPackages() ... DONE
[17:44:45.938]    + additional globals found: [n=0] 
[17:44:45.938]    + additional namespaces needed: [n=0] 
[17:44:45.938]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.939]  - seeds: <none>
[17:44:45.939]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.939] getGlobalsAndPackages() ...
[17:44:45.939] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.939] Resolving globals: FALSE
[17:44:45.939] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:45.940] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:45.940] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.940] 
[17:44:45.940] getGlobalsAndPackages() ... DONE
[17:44:45.940] run() for ‘Future’ ...
[17:44:45.941] - state: ‘created’
[17:44:45.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.941]   - Field: ‘label’
[17:44:45.941]   - Field: ‘local’
[17:44:45.941]   - Field: ‘owner’
[17:44:45.941]   - Field: ‘envir’
[17:44:45.942]   - Field: ‘packages’
[17:44:45.942]   - Field: ‘gc’
[17:44:45.942]   - Field: ‘conditions’
[17:44:45.942]   - Field: ‘expr’
[17:44:45.942]   - Field: ‘uuid’
[17:44:45.942]   - Field: ‘seed’
[17:44:45.942]   - Field: ‘version’
[17:44:45.942]   - Field: ‘result’
[17:44:45.942]   - Field: ‘asynchronous’
[17:44:45.942]   - Field: ‘calls’
[17:44:45.942]   - Field: ‘globals’
[17:44:45.943]   - Field: ‘stdout’
[17:44:45.943]   - Field: ‘earlySignal’
[17:44:45.943]   - Field: ‘lazy’
[17:44:45.943]   - Field: ‘state’
[17:44:45.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.943] - Launch lazy future ...
[17:44:45.943] Packages needed by the future expression (n = 0): <none>
[17:44:45.943] Packages needed by future strategies (n = 0): <none>
[17:44:45.944] {
[17:44:45.944]     {
[17:44:45.944]         {
[17:44:45.944]             ...future.startTime <- base::Sys.time()
[17:44:45.944]             {
[17:44:45.944]                 {
[17:44:45.944]                   {
[17:44:45.944]                     base::local({
[17:44:45.944]                       has_future <- base::requireNamespace("future", 
[17:44:45.944]                         quietly = TRUE)
[17:44:45.944]                       if (has_future) {
[17:44:45.944]                         ns <- base::getNamespace("future")
[17:44:45.944]                         version <- ns[[".package"]][["version"]]
[17:44:45.944]                         if (is.null(version)) 
[17:44:45.944]                           version <- utils::packageVersion("future")
[17:44:45.944]                       }
[17:44:45.944]                       else {
[17:44:45.944]                         version <- NULL
[17:44:45.944]                       }
[17:44:45.944]                       if (!has_future || version < "1.8.0") {
[17:44:45.944]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.944]                           "", base::R.version$version.string), 
[17:44:45.944]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.944]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.944]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.944]                             "release", "version")], collapse = " "), 
[17:44:45.944]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.944]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.944]                           info)
[17:44:45.944]                         info <- base::paste(info, collapse = "; ")
[17:44:45.944]                         if (!has_future) {
[17:44:45.944]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.944]                             info)
[17:44:45.944]                         }
[17:44:45.944]                         else {
[17:44:45.944]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.944]                             info, version)
[17:44:45.944]                         }
[17:44:45.944]                         base::stop(msg)
[17:44:45.944]                       }
[17:44:45.944]                     })
[17:44:45.944]                   }
[17:44:45.944]                   ...future.strategy.old <- future::plan("list")
[17:44:45.944]                   options(future.plan = NULL)
[17:44:45.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.944]                 }
[17:44:45.944]                 ...future.workdir <- getwd()
[17:44:45.944]             }
[17:44:45.944]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.944]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.944]         }
[17:44:45.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.944]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.944]             base::names(...future.oldOptions))
[17:44:45.944]     }
[17:44:45.944]     if (FALSE) {
[17:44:45.944]     }
[17:44:45.944]     else {
[17:44:45.944]         if (TRUE) {
[17:44:45.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.944]                 open = "w")
[17:44:45.944]         }
[17:44:45.944]         else {
[17:44:45.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.944]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.944]         }
[17:44:45.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.944]             base::sink(type = "output", split = FALSE)
[17:44:45.944]             base::close(...future.stdout)
[17:44:45.944]         }, add = TRUE)
[17:44:45.944]     }
[17:44:45.944]     ...future.frame <- base::sys.nframe()
[17:44:45.944]     ...future.conditions <- base::list()
[17:44:45.944]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.944]     if (FALSE) {
[17:44:45.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.944]     }
[17:44:45.944]     ...future.result <- base::tryCatch({
[17:44:45.944]         base::withCallingHandlers({
[17:44:45.944]             ...future.value <- base::withVisible(base::local({
[17:44:45.944]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.944]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.944]                   ...future.globals.maxSize)) {
[17:44:45.944]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.944]                   on.exit(options(oopts), add = TRUE)
[17:44:45.944]                 }
[17:44:45.944]                 {
[17:44:45.944]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.944]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.944]                     USE.NAMES = FALSE)
[17:44:45.944]                   do.call(mapply, args = args)
[17:44:45.944]                 }
[17:44:45.944]             }))
[17:44:45.944]             future::FutureResult(value = ...future.value$value, 
[17:44:45.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.944]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.944]                     ...future.globalenv.names))
[17:44:45.944]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.944]         }, condition = base::local({
[17:44:45.944]             c <- base::c
[17:44:45.944]             inherits <- base::inherits
[17:44:45.944]             invokeRestart <- base::invokeRestart
[17:44:45.944]             length <- base::length
[17:44:45.944]             list <- base::list
[17:44:45.944]             seq.int <- base::seq.int
[17:44:45.944]             signalCondition <- base::signalCondition
[17:44:45.944]             sys.calls <- base::sys.calls
[17:44:45.944]             `[[` <- base::`[[`
[17:44:45.944]             `+` <- base::`+`
[17:44:45.944]             `<<-` <- base::`<<-`
[17:44:45.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.944]                   3L)]
[17:44:45.944]             }
[17:44:45.944]             function(cond) {
[17:44:45.944]                 is_error <- inherits(cond, "error")
[17:44:45.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.944]                   NULL)
[17:44:45.944]                 if (is_error) {
[17:44:45.944]                   sessionInformation <- function() {
[17:44:45.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.944]                       search = base::search(), system = base::Sys.info())
[17:44:45.944]                   }
[17:44:45.944]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.944]                     cond$call), session = sessionInformation(), 
[17:44:45.944]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.944]                   signalCondition(cond)
[17:44:45.944]                 }
[17:44:45.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.944]                 "immediateCondition"))) {
[17:44:45.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.944]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.944]                   if (TRUE && !signal) {
[17:44:45.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.944]                     {
[17:44:45.944]                       inherits <- base::inherits
[17:44:45.944]                       invokeRestart <- base::invokeRestart
[17:44:45.944]                       is.null <- base::is.null
[17:44:45.944]                       muffled <- FALSE
[17:44:45.944]                       if (inherits(cond, "message")) {
[17:44:45.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.944]                         if (muffled) 
[17:44:45.944]                           invokeRestart("muffleMessage")
[17:44:45.944]                       }
[17:44:45.944]                       else if (inherits(cond, "warning")) {
[17:44:45.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.944]                         if (muffled) 
[17:44:45.944]                           invokeRestart("muffleWarning")
[17:44:45.944]                       }
[17:44:45.944]                       else if (inherits(cond, "condition")) {
[17:44:45.944]                         if (!is.null(pattern)) {
[17:44:45.944]                           computeRestarts <- base::computeRestarts
[17:44:45.944]                           grepl <- base::grepl
[17:44:45.944]                           restarts <- computeRestarts(cond)
[17:44:45.944]                           for (restart in restarts) {
[17:44:45.944]                             name <- restart$name
[17:44:45.944]                             if (is.null(name)) 
[17:44:45.944]                               next
[17:44:45.944]                             if (!grepl(pattern, name)) 
[17:44:45.944]                               next
[17:44:45.944]                             invokeRestart(restart)
[17:44:45.944]                             muffled <- TRUE
[17:44:45.944]                             break
[17:44:45.944]                           }
[17:44:45.944]                         }
[17:44:45.944]                       }
[17:44:45.944]                       invisible(muffled)
[17:44:45.944]                     }
[17:44:45.944]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.944]                   }
[17:44:45.944]                 }
[17:44:45.944]                 else {
[17:44:45.944]                   if (TRUE) {
[17:44:45.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.944]                     {
[17:44:45.944]                       inherits <- base::inherits
[17:44:45.944]                       invokeRestart <- base::invokeRestart
[17:44:45.944]                       is.null <- base::is.null
[17:44:45.944]                       muffled <- FALSE
[17:44:45.944]                       if (inherits(cond, "message")) {
[17:44:45.944]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.944]                         if (muffled) 
[17:44:45.944]                           invokeRestart("muffleMessage")
[17:44:45.944]                       }
[17:44:45.944]                       else if (inherits(cond, "warning")) {
[17:44:45.944]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.944]                         if (muffled) 
[17:44:45.944]                           invokeRestart("muffleWarning")
[17:44:45.944]                       }
[17:44:45.944]                       else if (inherits(cond, "condition")) {
[17:44:45.944]                         if (!is.null(pattern)) {
[17:44:45.944]                           computeRestarts <- base::computeRestarts
[17:44:45.944]                           grepl <- base::grepl
[17:44:45.944]                           restarts <- computeRestarts(cond)
[17:44:45.944]                           for (restart in restarts) {
[17:44:45.944]                             name <- restart$name
[17:44:45.944]                             if (is.null(name)) 
[17:44:45.944]                               next
[17:44:45.944]                             if (!grepl(pattern, name)) 
[17:44:45.944]                               next
[17:44:45.944]                             invokeRestart(restart)
[17:44:45.944]                             muffled <- TRUE
[17:44:45.944]                             break
[17:44:45.944]                           }
[17:44:45.944]                         }
[17:44:45.944]                       }
[17:44:45.944]                       invisible(muffled)
[17:44:45.944]                     }
[17:44:45.944]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.944]                   }
[17:44:45.944]                 }
[17:44:45.944]             }
[17:44:45.944]         }))
[17:44:45.944]     }, error = function(ex) {
[17:44:45.944]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.944]                 ...future.rng), started = ...future.startTime, 
[17:44:45.944]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.944]             version = "1.8"), class = "FutureResult")
[17:44:45.944]     }, finally = {
[17:44:45.944]         if (!identical(...future.workdir, getwd())) 
[17:44:45.944]             setwd(...future.workdir)
[17:44:45.944]         {
[17:44:45.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.944]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.944]             }
[17:44:45.944]             base::options(...future.oldOptions)
[17:44:45.944]             if (.Platform$OS.type == "windows") {
[17:44:45.944]                 old_names <- names(...future.oldEnvVars)
[17:44:45.944]                 envs <- base::Sys.getenv()
[17:44:45.944]                 names <- names(envs)
[17:44:45.944]                 common <- intersect(names, old_names)
[17:44:45.944]                 added <- setdiff(names, old_names)
[17:44:45.944]                 removed <- setdiff(old_names, names)
[17:44:45.944]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.944]                   envs[common]]
[17:44:45.944]                 NAMES <- toupper(changed)
[17:44:45.944]                 args <- list()
[17:44:45.944]                 for (kk in seq_along(NAMES)) {
[17:44:45.944]                   name <- changed[[kk]]
[17:44:45.944]                   NAME <- NAMES[[kk]]
[17:44:45.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.944]                     next
[17:44:45.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.944]                 }
[17:44:45.944]                 NAMES <- toupper(added)
[17:44:45.944]                 for (kk in seq_along(NAMES)) {
[17:44:45.944]                   name <- added[[kk]]
[17:44:45.944]                   NAME <- NAMES[[kk]]
[17:44:45.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.944]                     next
[17:44:45.944]                   args[[name]] <- ""
[17:44:45.944]                 }
[17:44:45.944]                 NAMES <- toupper(removed)
[17:44:45.944]                 for (kk in seq_along(NAMES)) {
[17:44:45.944]                   name <- removed[[kk]]
[17:44:45.944]                   NAME <- NAMES[[kk]]
[17:44:45.944]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.944]                     next
[17:44:45.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.944]                 }
[17:44:45.944]                 if (length(args) > 0) 
[17:44:45.944]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.944]             }
[17:44:45.944]             else {
[17:44:45.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.944]             }
[17:44:45.944]             {
[17:44:45.944]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.944]                   0L) {
[17:44:45.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.944]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.944]                   base::options(opts)
[17:44:45.944]                 }
[17:44:45.944]                 {
[17:44:45.944]                   {
[17:44:45.944]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.944]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.944]                     -484569582L), envir = base::globalenv(), 
[17:44:45.944]                       inherits = FALSE)
[17:44:45.944]                     NULL
[17:44:45.944]                   }
[17:44:45.944]                   options(future.plan = NULL)
[17:44:45.944]                   if (is.na(NA_character_)) 
[17:44:45.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.944]                     .init = FALSE)
[17:44:45.944]                 }
[17:44:45.944]             }
[17:44:45.944]         }
[17:44:45.944]     })
[17:44:45.944]     if (TRUE) {
[17:44:45.944]         base::sink(type = "output", split = FALSE)
[17:44:45.944]         if (TRUE) {
[17:44:45.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.944]         }
[17:44:45.944]         else {
[17:44:45.944]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.944]         }
[17:44:45.944]         base::close(...future.stdout)
[17:44:45.944]         ...future.stdout <- NULL
[17:44:45.944]     }
[17:44:45.944]     ...future.result$conditions <- ...future.conditions
[17:44:45.944]     ...future.result$finished <- base::Sys.time()
[17:44:45.944]     ...future.result
[17:44:45.944] }
[17:44:45.945] assign_globals() ...
[17:44:45.945] List of 5
[17:44:45.945]  $ ...future.FUN            :function (x)  
[17:44:45.945]  $ MoreArgs                 : NULL
[17:44:45.945]  $ ...future.elements_ii    :List of 1
[17:44:45.945]   ..$ :List of 1
[17:44:45.945]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:44:45.945]  $ ...future.seeds_ii       : NULL
[17:44:45.945]  $ ...future.globals.maxSize: NULL
[17:44:45.945]  - attr(*, "where")=List of 5
[17:44:45.945]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.945]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.945]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.945]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.945]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.945]  - attr(*, "resolved")= logi FALSE
[17:44:45.945]  - attr(*, "total_size")= num 1128
[17:44:45.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.945]  - attr(*, "already-done")= logi TRUE
[17:44:45.950] - copied ‘...future.FUN’ to environment
[17:44:45.950] - copied ‘MoreArgs’ to environment
[17:44:45.950] - copied ‘...future.elements_ii’ to environment
[17:44:45.950] - copied ‘...future.seeds_ii’ to environment
[17:44:45.951] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.951] assign_globals() ... done
[17:44:45.951] plan(): Setting new future strategy stack:
[17:44:45.951] List of future strategies:
[17:44:45.951] 1. sequential:
[17:44:45.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.951]    - tweaked: FALSE
[17:44:45.951]    - call: NULL
[17:44:45.951] plan(): nbrOfWorkers() = 1
[17:44:45.952] plan(): Setting new future strategy stack:
[17:44:45.952] List of future strategies:
[17:44:45.952] 1. sequential:
[17:44:45.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.952]    - tweaked: FALSE
[17:44:45.952]    - call: plan(strategy)
[17:44:45.953] plan(): nbrOfWorkers() = 1
[17:44:45.953] SequentialFuture started (and completed)
[17:44:45.953] - Launch lazy future ... done
[17:44:45.953] run() for ‘SequentialFuture’ ... done
[17:44:45.953] Created future:
[17:44:45.953] SequentialFuture:
[17:44:45.953] Label: ‘future_mapply-1’
[17:44:45.953] Expression:
[17:44:45.953] {
[17:44:45.953]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.953]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.953]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.953]         on.exit(options(oopts), add = TRUE)
[17:44:45.953]     }
[17:44:45.953]     {
[17:44:45.953]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.953]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.953]         do.call(mapply, args = args)
[17:44:45.953]     }
[17:44:45.953] }
[17:44:45.953] Lazy evaluation: FALSE
[17:44:45.953] Asynchronous evaluation: FALSE
[17:44:45.953] Local evaluation: TRUE
[17:44:45.953] Environment: R_GlobalEnv
[17:44:45.953] Capture standard output: TRUE
[17:44:45.953] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.953] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.953] Packages: <none>
[17:44:45.953] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.953] Resolved: TRUE
[17:44:45.953] Value: 280 bytes of class ‘list’
[17:44:45.953] Early signaling: FALSE
[17:44:45.953] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.953] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.954] Chunk #1 of 1 ... DONE
[17:44:45.954] Launching 1 futures (chunks) ... DONE
[17:44:45.954] Resolving 1 futures (chunks) ...
[17:44:45.954] resolve() on list ...
[17:44:45.954]  recursive: 0
[17:44:45.955]  length: 1
[17:44:45.955] 
[17:44:45.955] resolved() for ‘SequentialFuture’ ...
[17:44:45.955] - state: ‘finished’
[17:44:45.955] - run: TRUE
[17:44:45.955] - result: ‘FutureResult’
[17:44:45.955] resolved() for ‘SequentialFuture’ ... done
[17:44:45.955] Future #1
[17:44:45.955] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.955] - nx: 1
[17:44:45.956] - relay: TRUE
[17:44:45.956] - stdout: TRUE
[17:44:45.956] - signal: TRUE
[17:44:45.956] - resignal: FALSE
[17:44:45.956] - force: TRUE
[17:44:45.956] - relayed: [n=1] FALSE
[17:44:45.956] - queued futures: [n=1] FALSE
[17:44:45.956]  - until=1
[17:44:45.956]  - relaying element #1
[17:44:45.956] - relayed: [n=1] TRUE
[17:44:45.957] - queued futures: [n=1] TRUE
[17:44:45.957] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.957]  length: 0 (resolved future 1)
[17:44:45.957] Relaying remaining futures
[17:44:45.957] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.957] - nx: 1
[17:44:45.957] - relay: TRUE
[17:44:45.957] - stdout: TRUE
[17:44:45.957] - signal: TRUE
[17:44:45.957] - resignal: FALSE
[17:44:45.957] - force: TRUE
[17:44:45.958] - relayed: [n=1] TRUE
[17:44:45.958] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.958] - relayed: [n=1] TRUE
[17:44:45.958] - queued futures: [n=1] TRUE
[17:44:45.958] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.958] resolve() on list ... DONE
[17:44:45.958]  - Number of value chunks collected: 1
[17:44:45.958] Resolving 1 futures (chunks) ... DONE
[17:44:45.958] Reducing values from 1 chunks ...
[17:44:45.958]  - Number of values collected after concatenation: 1
[17:44:45.959]  - Number of values expected: 1
[17:44:45.959] Reducing values from 1 chunks ... DONE
[17:44:45.959] future_mapply() ... DONE
[17:44:45.959] future_mapply() ...
[17:44:45.959] Number of chunks: 1
[17:44:45.959] getGlobalsAndPackagesXApply() ...
[17:44:45.959]  - future.globals: TRUE
[17:44:45.959] getGlobalsAndPackages() ...
[17:44:45.959] Searching for globals...
[17:44:45.960] - globals found: [1] ‘FUN’
[17:44:45.960] Searching for globals ... DONE
[17:44:45.961] Resolving globals: FALSE
[17:44:45.962] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:45.963] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:45.963] - globals: [1] ‘FUN’
[17:44:45.963] 
[17:44:45.963] getGlobalsAndPackages() ... DONE
[17:44:45.963]  - globals found/used: [n=1] ‘FUN’
[17:44:45.963]  - needed namespaces: [n=0] 
[17:44:45.963] Finding globals ... DONE
[17:44:45.964] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.964] List of 2
[17:44:45.964]  $ ...future.FUN:function (x)  
[17:44:45.964]  $ MoreArgs     : list()
[17:44:45.964]  - attr(*, "where")=List of 2
[17:44:45.964]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.964]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.964]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.964]  - attr(*, "resolved")= logi FALSE
[17:44:45.964]  - attr(*, "total_size")= num NA
[17:44:45.966] Packages to be attached in all futures: [n=0] 
[17:44:45.966] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.966] Number of futures (= number of chunks): 1
[17:44:45.967] Launching 1 futures (chunks) ...
[17:44:45.967] Chunk #1 of 1 ...
[17:44:45.967]  - Finding globals in '...' for chunk #1 ...
[17:44:45.967] getGlobalsAndPackages() ...
[17:44:45.967] Searching for globals...
[17:44:45.967] 
[17:44:45.967] Searching for globals ... DONE
[17:44:45.967] - globals: [0] <none>
[17:44:45.968] getGlobalsAndPackages() ... DONE
[17:44:45.968]    + additional globals found: [n=0] 
[17:44:45.968]    + additional namespaces needed: [n=0] 
[17:44:45.968]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.968]  - seeds: <none>
[17:44:45.968]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.968] getGlobalsAndPackages() ...
[17:44:45.968] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.968] Resolving globals: FALSE
[17:44:45.969] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:45.969] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:45.969] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.969] 
[17:44:45.969] getGlobalsAndPackages() ... DONE
[17:44:45.970] run() for ‘Future’ ...
[17:44:45.970] - state: ‘created’
[17:44:45.970] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.970] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:45.970]   - Field: ‘label’
[17:44:45.971]   - Field: ‘local’
[17:44:45.971]   - Field: ‘owner’
[17:44:45.971]   - Field: ‘envir’
[17:44:45.971]   - Field: ‘packages’
[17:44:45.971]   - Field: ‘gc’
[17:44:45.971]   - Field: ‘conditions’
[17:44:45.971]   - Field: ‘expr’
[17:44:45.971]   - Field: ‘uuid’
[17:44:45.971]   - Field: ‘seed’
[17:44:45.971]   - Field: ‘version’
[17:44:45.971]   - Field: ‘result’
[17:44:45.972]   - Field: ‘asynchronous’
[17:44:45.972]   - Field: ‘calls’
[17:44:45.972]   - Field: ‘globals’
[17:44:45.972]   - Field: ‘stdout’
[17:44:45.972]   - Field: ‘earlySignal’
[17:44:45.972]   - Field: ‘lazy’
[17:44:45.972]   - Field: ‘state’
[17:44:45.972] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:45.972] - Launch lazy future ...
[17:44:45.972] Packages needed by the future expression (n = 0): <none>
[17:44:45.973] Packages needed by future strategies (n = 0): <none>
[17:44:45.973] {
[17:44:45.973]     {
[17:44:45.973]         {
[17:44:45.973]             ...future.startTime <- base::Sys.time()
[17:44:45.973]             {
[17:44:45.973]                 {
[17:44:45.973]                   {
[17:44:45.973]                     base::local({
[17:44:45.973]                       has_future <- base::requireNamespace("future", 
[17:44:45.973]                         quietly = TRUE)
[17:44:45.973]                       if (has_future) {
[17:44:45.973]                         ns <- base::getNamespace("future")
[17:44:45.973]                         version <- ns[[".package"]][["version"]]
[17:44:45.973]                         if (is.null(version)) 
[17:44:45.973]                           version <- utils::packageVersion("future")
[17:44:45.973]                       }
[17:44:45.973]                       else {
[17:44:45.973]                         version <- NULL
[17:44:45.973]                       }
[17:44:45.973]                       if (!has_future || version < "1.8.0") {
[17:44:45.973]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:45.973]                           "", base::R.version$version.string), 
[17:44:45.973]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:45.973]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:45.973]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:45.973]                             "release", "version")], collapse = " "), 
[17:44:45.973]                           hostname = base::Sys.info()[["nodename"]])
[17:44:45.973]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:45.973]                           info)
[17:44:45.973]                         info <- base::paste(info, collapse = "; ")
[17:44:45.973]                         if (!has_future) {
[17:44:45.973]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:45.973]                             info)
[17:44:45.973]                         }
[17:44:45.973]                         else {
[17:44:45.973]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:45.973]                             info, version)
[17:44:45.973]                         }
[17:44:45.973]                         base::stop(msg)
[17:44:45.973]                       }
[17:44:45.973]                     })
[17:44:45.973]                   }
[17:44:45.973]                   ...future.strategy.old <- future::plan("list")
[17:44:45.973]                   options(future.plan = NULL)
[17:44:45.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:45.973]                 }
[17:44:45.973]                 ...future.workdir <- getwd()
[17:44:45.973]             }
[17:44:45.973]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:45.973]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:45.973]         }
[17:44:45.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:45.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:45.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:45.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:45.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:45.973]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:45.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:45.973]             base::names(...future.oldOptions))
[17:44:45.973]     }
[17:44:45.973]     if (FALSE) {
[17:44:45.973]     }
[17:44:45.973]     else {
[17:44:45.973]         if (TRUE) {
[17:44:45.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:45.973]                 open = "w")
[17:44:45.973]         }
[17:44:45.973]         else {
[17:44:45.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:45.973]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:45.973]         }
[17:44:45.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:45.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:45.973]             base::sink(type = "output", split = FALSE)
[17:44:45.973]             base::close(...future.stdout)
[17:44:45.973]         }, add = TRUE)
[17:44:45.973]     }
[17:44:45.973]     ...future.frame <- base::sys.nframe()
[17:44:45.973]     ...future.conditions <- base::list()
[17:44:45.973]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:45.973]     if (FALSE) {
[17:44:45.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:45.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:45.973]     }
[17:44:45.973]     ...future.result <- base::tryCatch({
[17:44:45.973]         base::withCallingHandlers({
[17:44:45.973]             ...future.value <- base::withVisible(base::local({
[17:44:45.973]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.973]                 if (!identical(...future.globals.maxSize.org, 
[17:44:45.973]                   ...future.globals.maxSize)) {
[17:44:45.973]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.973]                   on.exit(options(oopts), add = TRUE)
[17:44:45.973]                 }
[17:44:45.973]                 {
[17:44:45.973]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.973]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:45.973]                     USE.NAMES = FALSE)
[17:44:45.973]                   do.call(mapply, args = args)
[17:44:45.973]                 }
[17:44:45.973]             }))
[17:44:45.973]             future::FutureResult(value = ...future.value$value, 
[17:44:45.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.973]                   ...future.rng), globalenv = if (FALSE) 
[17:44:45.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:45.973]                     ...future.globalenv.names))
[17:44:45.973]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:45.973]         }, condition = base::local({
[17:44:45.973]             c <- base::c
[17:44:45.973]             inherits <- base::inherits
[17:44:45.973]             invokeRestart <- base::invokeRestart
[17:44:45.973]             length <- base::length
[17:44:45.973]             list <- base::list
[17:44:45.973]             seq.int <- base::seq.int
[17:44:45.973]             signalCondition <- base::signalCondition
[17:44:45.973]             sys.calls <- base::sys.calls
[17:44:45.973]             `[[` <- base::`[[`
[17:44:45.973]             `+` <- base::`+`
[17:44:45.973]             `<<-` <- base::`<<-`
[17:44:45.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:45.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:45.973]                   3L)]
[17:44:45.973]             }
[17:44:45.973]             function(cond) {
[17:44:45.973]                 is_error <- inherits(cond, "error")
[17:44:45.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:45.973]                   NULL)
[17:44:45.973]                 if (is_error) {
[17:44:45.973]                   sessionInformation <- function() {
[17:44:45.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:45.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:45.973]                       search = base::search(), system = base::Sys.info())
[17:44:45.973]                   }
[17:44:45.973]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:45.973]                     cond$call), session = sessionInformation(), 
[17:44:45.973]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:45.973]                   signalCondition(cond)
[17:44:45.973]                 }
[17:44:45.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:45.973]                 "immediateCondition"))) {
[17:44:45.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:45.973]                   ...future.conditions[[length(...future.conditions) + 
[17:44:45.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:45.973]                   if (TRUE && !signal) {
[17:44:45.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.973]                     {
[17:44:45.973]                       inherits <- base::inherits
[17:44:45.973]                       invokeRestart <- base::invokeRestart
[17:44:45.973]                       is.null <- base::is.null
[17:44:45.973]                       muffled <- FALSE
[17:44:45.973]                       if (inherits(cond, "message")) {
[17:44:45.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.973]                         if (muffled) 
[17:44:45.973]                           invokeRestart("muffleMessage")
[17:44:45.973]                       }
[17:44:45.973]                       else if (inherits(cond, "warning")) {
[17:44:45.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.973]                         if (muffled) 
[17:44:45.973]                           invokeRestart("muffleWarning")
[17:44:45.973]                       }
[17:44:45.973]                       else if (inherits(cond, "condition")) {
[17:44:45.973]                         if (!is.null(pattern)) {
[17:44:45.973]                           computeRestarts <- base::computeRestarts
[17:44:45.973]                           grepl <- base::grepl
[17:44:45.973]                           restarts <- computeRestarts(cond)
[17:44:45.973]                           for (restart in restarts) {
[17:44:45.973]                             name <- restart$name
[17:44:45.973]                             if (is.null(name)) 
[17:44:45.973]                               next
[17:44:45.973]                             if (!grepl(pattern, name)) 
[17:44:45.973]                               next
[17:44:45.973]                             invokeRestart(restart)
[17:44:45.973]                             muffled <- TRUE
[17:44:45.973]                             break
[17:44:45.973]                           }
[17:44:45.973]                         }
[17:44:45.973]                       }
[17:44:45.973]                       invisible(muffled)
[17:44:45.973]                     }
[17:44:45.973]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.973]                   }
[17:44:45.973]                 }
[17:44:45.973]                 else {
[17:44:45.973]                   if (TRUE) {
[17:44:45.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:45.973]                     {
[17:44:45.973]                       inherits <- base::inherits
[17:44:45.973]                       invokeRestart <- base::invokeRestart
[17:44:45.973]                       is.null <- base::is.null
[17:44:45.973]                       muffled <- FALSE
[17:44:45.973]                       if (inherits(cond, "message")) {
[17:44:45.973]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:45.973]                         if (muffled) 
[17:44:45.973]                           invokeRestart("muffleMessage")
[17:44:45.973]                       }
[17:44:45.973]                       else if (inherits(cond, "warning")) {
[17:44:45.973]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:45.973]                         if (muffled) 
[17:44:45.973]                           invokeRestart("muffleWarning")
[17:44:45.973]                       }
[17:44:45.973]                       else if (inherits(cond, "condition")) {
[17:44:45.973]                         if (!is.null(pattern)) {
[17:44:45.973]                           computeRestarts <- base::computeRestarts
[17:44:45.973]                           grepl <- base::grepl
[17:44:45.973]                           restarts <- computeRestarts(cond)
[17:44:45.973]                           for (restart in restarts) {
[17:44:45.973]                             name <- restart$name
[17:44:45.973]                             if (is.null(name)) 
[17:44:45.973]                               next
[17:44:45.973]                             if (!grepl(pattern, name)) 
[17:44:45.973]                               next
[17:44:45.973]                             invokeRestart(restart)
[17:44:45.973]                             muffled <- TRUE
[17:44:45.973]                             break
[17:44:45.973]                           }
[17:44:45.973]                         }
[17:44:45.973]                       }
[17:44:45.973]                       invisible(muffled)
[17:44:45.973]                     }
[17:44:45.973]                     muffleCondition(cond, pattern = "^muffle")
[17:44:45.973]                   }
[17:44:45.973]                 }
[17:44:45.973]             }
[17:44:45.973]         }))
[17:44:45.973]     }, error = function(ex) {
[17:44:45.973]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:45.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:45.973]                 ...future.rng), started = ...future.startTime, 
[17:44:45.973]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:45.973]             version = "1.8"), class = "FutureResult")
[17:44:45.973]     }, finally = {
[17:44:45.973]         if (!identical(...future.workdir, getwd())) 
[17:44:45.973]             setwd(...future.workdir)
[17:44:45.973]         {
[17:44:45.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:45.973]                 ...future.oldOptions$nwarnings <- NULL
[17:44:45.973]             }
[17:44:45.973]             base::options(...future.oldOptions)
[17:44:45.973]             if (.Platform$OS.type == "windows") {
[17:44:45.973]                 old_names <- names(...future.oldEnvVars)
[17:44:45.973]                 envs <- base::Sys.getenv()
[17:44:45.973]                 names <- names(envs)
[17:44:45.973]                 common <- intersect(names, old_names)
[17:44:45.973]                 added <- setdiff(names, old_names)
[17:44:45.973]                 removed <- setdiff(old_names, names)
[17:44:45.973]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:45.973]                   envs[common]]
[17:44:45.973]                 NAMES <- toupper(changed)
[17:44:45.973]                 args <- list()
[17:44:45.973]                 for (kk in seq_along(NAMES)) {
[17:44:45.973]                   name <- changed[[kk]]
[17:44:45.973]                   NAME <- NAMES[[kk]]
[17:44:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.973]                     next
[17:44:45.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.973]                 }
[17:44:45.973]                 NAMES <- toupper(added)
[17:44:45.973]                 for (kk in seq_along(NAMES)) {
[17:44:45.973]                   name <- added[[kk]]
[17:44:45.973]                   NAME <- NAMES[[kk]]
[17:44:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.973]                     next
[17:44:45.973]                   args[[name]] <- ""
[17:44:45.973]                 }
[17:44:45.973]                 NAMES <- toupper(removed)
[17:44:45.973]                 for (kk in seq_along(NAMES)) {
[17:44:45.973]                   name <- removed[[kk]]
[17:44:45.973]                   NAME <- NAMES[[kk]]
[17:44:45.973]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:45.973]                     next
[17:44:45.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:45.973]                 }
[17:44:45.973]                 if (length(args) > 0) 
[17:44:45.973]                   base::do.call(base::Sys.setenv, args = args)
[17:44:45.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:45.973]             }
[17:44:45.973]             else {
[17:44:45.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:45.973]             }
[17:44:45.973]             {
[17:44:45.973]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:45.973]                   0L) {
[17:44:45.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:45.973]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:45.973]                   base::options(opts)
[17:44:45.973]                 }
[17:44:45.973]                 {
[17:44:45.973]                   {
[17:44:45.973]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:45.973]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:45.973]                     -484569582L), envir = base::globalenv(), 
[17:44:45.973]                       inherits = FALSE)
[17:44:45.973]                     NULL
[17:44:45.973]                   }
[17:44:45.973]                   options(future.plan = NULL)
[17:44:45.973]                   if (is.na(NA_character_)) 
[17:44:45.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:45.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:45.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:45.973]                     .init = FALSE)
[17:44:45.973]                 }
[17:44:45.973]             }
[17:44:45.973]         }
[17:44:45.973]     })
[17:44:45.973]     if (TRUE) {
[17:44:45.973]         base::sink(type = "output", split = FALSE)
[17:44:45.973]         if (TRUE) {
[17:44:45.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:45.973]         }
[17:44:45.973]         else {
[17:44:45.973]             ...future.result["stdout"] <- base::list(NULL)
[17:44:45.973]         }
[17:44:45.973]         base::close(...future.stdout)
[17:44:45.973]         ...future.stdout <- NULL
[17:44:45.973]     }
[17:44:45.973]     ...future.result$conditions <- ...future.conditions
[17:44:45.973]     ...future.result$finished <- base::Sys.time()
[17:44:45.973]     ...future.result
[17:44:45.973] }
[17:44:45.975] assign_globals() ...
[17:44:45.975] List of 5
[17:44:45.975]  $ ...future.FUN            :function (x)  
[17:44:45.975]  $ MoreArgs                 : list()
[17:44:45.975]  $ ...future.elements_ii    :List of 1
[17:44:45.975]   ..$ :List of 1
[17:44:45.975]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:44:45.975]  $ ...future.seeds_ii       : NULL
[17:44:45.975]  $ ...future.globals.maxSize: NULL
[17:44:45.975]  - attr(*, "where")=List of 5
[17:44:45.975]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:45.975]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:45.975]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:45.975]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:45.975]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:45.975]  - attr(*, "resolved")= logi FALSE
[17:44:45.975]  - attr(*, "total_size")= num 1128
[17:44:45.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.975]  - attr(*, "already-done")= logi TRUE
[17:44:45.979] - copied ‘...future.FUN’ to environment
[17:44:45.979] - copied ‘MoreArgs’ to environment
[17:44:45.979] - copied ‘...future.elements_ii’ to environment
[17:44:45.979] - copied ‘...future.seeds_ii’ to environment
[17:44:45.980] - copied ‘...future.globals.maxSize’ to environment
[17:44:45.980] assign_globals() ... done
[17:44:45.980] plan(): Setting new future strategy stack:
[17:44:45.980] List of future strategies:
[17:44:45.980] 1. sequential:
[17:44:45.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.980]    - tweaked: FALSE
[17:44:45.980]    - call: NULL
[17:44:45.980] plan(): nbrOfWorkers() = 1
[17:44:45.981] plan(): Setting new future strategy stack:
[17:44:45.981] List of future strategies:
[17:44:45.981] 1. sequential:
[17:44:45.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:45.981]    - tweaked: FALSE
[17:44:45.981]    - call: plan(strategy)
[17:44:45.982] plan(): nbrOfWorkers() = 1
[17:44:45.982] SequentialFuture started (and completed)
[17:44:45.982] - Launch lazy future ... done
[17:44:45.982] run() for ‘SequentialFuture’ ... done
[17:44:45.982] Created future:
[17:44:45.982] SequentialFuture:
[17:44:45.982] Label: ‘future_.mapply-1’
[17:44:45.982] Expression:
[17:44:45.982] {
[17:44:45.982]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:45.982]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:45.982]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:45.982]         on.exit(options(oopts), add = TRUE)
[17:44:45.982]     }
[17:44:45.982]     {
[17:44:45.982]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:45.982]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:45.982]         do.call(mapply, args = args)
[17:44:45.982]     }
[17:44:45.982] }
[17:44:45.982] Lazy evaluation: FALSE
[17:44:45.982] Asynchronous evaluation: FALSE
[17:44:45.982] Local evaluation: TRUE
[17:44:45.982] Environment: R_GlobalEnv
[17:44:45.982] Capture standard output: TRUE
[17:44:45.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:45.982] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:45.982] Packages: <none>
[17:44:45.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:45.982] Resolved: TRUE
[17:44:45.982] Value: 280 bytes of class ‘list’
[17:44:45.982] Early signaling: FALSE
[17:44:45.982] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:45.982] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.983] Chunk #1 of 1 ... DONE
[17:44:45.983] Launching 1 futures (chunks) ... DONE
[17:44:45.983] Resolving 1 futures (chunks) ...
[17:44:45.983] resolve() on list ...
[17:44:45.984]  recursive: 0
[17:44:45.984]  length: 1
[17:44:45.984] 
[17:44:45.984] resolved() for ‘SequentialFuture’ ...
[17:44:45.984] - state: ‘finished’
[17:44:45.984] - run: TRUE
[17:44:45.984] - result: ‘FutureResult’
[17:44:45.984] resolved() for ‘SequentialFuture’ ... done
[17:44:45.984] Future #1
[17:44:45.984] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:45.984] - nx: 1
[17:44:45.985] - relay: TRUE
[17:44:45.985] - stdout: TRUE
[17:44:45.985] - signal: TRUE
[17:44:45.985] - resignal: FALSE
[17:44:45.985] - force: TRUE
[17:44:45.985] - relayed: [n=1] FALSE
[17:44:45.985] - queued futures: [n=1] FALSE
[17:44:45.985]  - until=1
[17:44:45.985]  - relaying element #1
[17:44:45.985] - relayed: [n=1] TRUE
[17:44:45.986] - queued futures: [n=1] TRUE
[17:44:45.986] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:45.986]  length: 0 (resolved future 1)
[17:44:45.986] Relaying remaining futures
[17:44:45.987] signalConditionsASAP(NULL, pos=0) ...
[17:44:45.987] - nx: 1
[17:44:45.988] - relay: TRUE
[17:44:45.988] - stdout: TRUE
[17:44:45.988] - signal: TRUE
[17:44:45.988] - resignal: FALSE
[17:44:45.988] - force: TRUE
[17:44:45.988] - relayed: [n=1] TRUE
[17:44:45.988] - queued futures: [n=1] TRUE
 - flush all
[17:44:45.988] - relayed: [n=1] TRUE
[17:44:45.988] - queued futures: [n=1] TRUE
[17:44:45.988] signalConditionsASAP(NULL, pos=0) ... done
[17:44:45.989] resolve() on list ... DONE
[17:44:45.989]  - Number of value chunks collected: 1
[17:44:45.989] Resolving 1 futures (chunks) ... DONE
[17:44:45.989] Reducing values from 1 chunks ...
[17:44:45.989]  - Number of values collected after concatenation: 1
[17:44:45.989]  - Number of values expected: 1
[17:44:45.989] Reducing values from 1 chunks ... DONE
[17:44:45.989] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:44:45.990] future_mapply() ...
[17:44:45.990] Number of chunks: 1
[17:44:45.990] getGlobalsAndPackagesXApply() ...
[17:44:45.990]  - future.globals: TRUE
[17:44:45.990] getGlobalsAndPackages() ...
[17:44:45.990] Searching for globals...
[17:44:45.991] - globals found: [1] ‘FUN’
[17:44:45.991] Searching for globals ... DONE
[17:44:45.991] Resolving globals: FALSE
[17:44:45.992] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:45.992] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:45.992] - globals: [1] ‘FUN’
[17:44:45.992] 
[17:44:45.992] getGlobalsAndPackages() ... DONE
[17:44:45.992]  - globals found/used: [n=1] ‘FUN’
[17:44:45.992]  - needed namespaces: [n=0] 
[17:44:45.992] Finding globals ... DONE
[17:44:45.993] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:45.993] List of 2
[17:44:45.993]  $ ...future.FUN:function (x, y)  
[17:44:45.993]  $ MoreArgs     :List of 1
[17:44:45.993]   ..$ y: int [1:2] 3 4
[17:44:45.993]  - attr(*, "where")=List of 2
[17:44:45.993]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:45.993]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:45.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:45.993]  - attr(*, "resolved")= logi FALSE
[17:44:45.993]  - attr(*, "total_size")= num NA
[17:44:45.995] Packages to be attached in all futures: [n=0] 
[17:44:45.995] getGlobalsAndPackagesXApply() ... DONE
[17:44:45.996] Number of futures (= number of chunks): 1
[17:44:45.996] Launching 1 futures (chunks) ...
[17:44:45.996] Chunk #1 of 1 ...
[17:44:45.996]  - Finding globals in '...' for chunk #1 ...
[17:44:45.996] getGlobalsAndPackages() ...
[17:44:45.996] Searching for globals...
[17:44:45.996] 
[17:44:45.997] Searching for globals ... DONE
[17:44:45.997] - globals: [0] <none>
[17:44:45.997] getGlobalsAndPackages() ... DONE
[17:44:45.997]    + additional globals found: [n=0] 
[17:44:45.997]    + additional namespaces needed: [n=0] 
[17:44:45.997]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:45.997]  - seeds: <none>
[17:44:45.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.997] getGlobalsAndPackages() ...
[17:44:45.997] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.997] Resolving globals: FALSE
[17:44:45.998] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:44:45.998] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:45.998] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:45.999] 
[17:44:45.999] getGlobalsAndPackages() ... DONE
[17:44:45.999] run() for ‘Future’ ...
[17:44:45.999] - state: ‘created’
[17:44:45.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:45.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:45.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.000]   - Field: ‘label’
[17:44:46.000]   - Field: ‘local’
[17:44:46.000]   - Field: ‘owner’
[17:44:46.000]   - Field: ‘envir’
[17:44:46.000]   - Field: ‘packages’
[17:44:46.000]   - Field: ‘gc’
[17:44:46.000]   - Field: ‘conditions’
[17:44:46.000]   - Field: ‘expr’
[17:44:46.000]   - Field: ‘uuid’
[17:44:46.000]   - Field: ‘seed’
[17:44:46.000]   - Field: ‘version’
[17:44:46.001]   - Field: ‘result’
[17:44:46.001]   - Field: ‘asynchronous’
[17:44:46.001]   - Field: ‘calls’
[17:44:46.001]   - Field: ‘globals’
[17:44:46.001]   - Field: ‘stdout’
[17:44:46.001]   - Field: ‘earlySignal’
[17:44:46.001]   - Field: ‘lazy’
[17:44:46.001]   - Field: ‘state’
[17:44:46.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.001] - Launch lazy future ...
[17:44:46.002] Packages needed by the future expression (n = 0): <none>
[17:44:46.002] Packages needed by future strategies (n = 0): <none>
[17:44:46.002] {
[17:44:46.002]     {
[17:44:46.002]         {
[17:44:46.002]             ...future.startTime <- base::Sys.time()
[17:44:46.002]             {
[17:44:46.002]                 {
[17:44:46.002]                   {
[17:44:46.002]                     base::local({
[17:44:46.002]                       has_future <- base::requireNamespace("future", 
[17:44:46.002]                         quietly = TRUE)
[17:44:46.002]                       if (has_future) {
[17:44:46.002]                         ns <- base::getNamespace("future")
[17:44:46.002]                         version <- ns[[".package"]][["version"]]
[17:44:46.002]                         if (is.null(version)) 
[17:44:46.002]                           version <- utils::packageVersion("future")
[17:44:46.002]                       }
[17:44:46.002]                       else {
[17:44:46.002]                         version <- NULL
[17:44:46.002]                       }
[17:44:46.002]                       if (!has_future || version < "1.8.0") {
[17:44:46.002]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.002]                           "", base::R.version$version.string), 
[17:44:46.002]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.002]                             "release", "version")], collapse = " "), 
[17:44:46.002]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.002]                           info)
[17:44:46.002]                         info <- base::paste(info, collapse = "; ")
[17:44:46.002]                         if (!has_future) {
[17:44:46.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.002]                             info)
[17:44:46.002]                         }
[17:44:46.002]                         else {
[17:44:46.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.002]                             info, version)
[17:44:46.002]                         }
[17:44:46.002]                         base::stop(msg)
[17:44:46.002]                       }
[17:44:46.002]                     })
[17:44:46.002]                   }
[17:44:46.002]                   ...future.strategy.old <- future::plan("list")
[17:44:46.002]                   options(future.plan = NULL)
[17:44:46.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.002]                 }
[17:44:46.002]                 ...future.workdir <- getwd()
[17:44:46.002]             }
[17:44:46.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.002]         }
[17:44:46.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.002]             base::names(...future.oldOptions))
[17:44:46.002]     }
[17:44:46.002]     if (FALSE) {
[17:44:46.002]     }
[17:44:46.002]     else {
[17:44:46.002]         if (TRUE) {
[17:44:46.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.002]                 open = "w")
[17:44:46.002]         }
[17:44:46.002]         else {
[17:44:46.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.002]         }
[17:44:46.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.002]             base::sink(type = "output", split = FALSE)
[17:44:46.002]             base::close(...future.stdout)
[17:44:46.002]         }, add = TRUE)
[17:44:46.002]     }
[17:44:46.002]     ...future.frame <- base::sys.nframe()
[17:44:46.002]     ...future.conditions <- base::list()
[17:44:46.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.002]     if (FALSE) {
[17:44:46.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.002]     }
[17:44:46.002]     ...future.result <- base::tryCatch({
[17:44:46.002]         base::withCallingHandlers({
[17:44:46.002]             ...future.value <- base::withVisible(base::local({
[17:44:46.002]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.002]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.002]                   ...future.globals.maxSize)) {
[17:44:46.002]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.002]                   on.exit(options(oopts), add = TRUE)
[17:44:46.002]                 }
[17:44:46.002]                 {
[17:44:46.002]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.002]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.002]                     USE.NAMES = FALSE)
[17:44:46.002]                   do.call(mapply, args = args)
[17:44:46.002]                 }
[17:44:46.002]             }))
[17:44:46.002]             future::FutureResult(value = ...future.value$value, 
[17:44:46.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.002]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.002]                     ...future.globalenv.names))
[17:44:46.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.002]         }, condition = base::local({
[17:44:46.002]             c <- base::c
[17:44:46.002]             inherits <- base::inherits
[17:44:46.002]             invokeRestart <- base::invokeRestart
[17:44:46.002]             length <- base::length
[17:44:46.002]             list <- base::list
[17:44:46.002]             seq.int <- base::seq.int
[17:44:46.002]             signalCondition <- base::signalCondition
[17:44:46.002]             sys.calls <- base::sys.calls
[17:44:46.002]             `[[` <- base::`[[`
[17:44:46.002]             `+` <- base::`+`
[17:44:46.002]             `<<-` <- base::`<<-`
[17:44:46.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.002]                   3L)]
[17:44:46.002]             }
[17:44:46.002]             function(cond) {
[17:44:46.002]                 is_error <- inherits(cond, "error")
[17:44:46.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.002]                   NULL)
[17:44:46.002]                 if (is_error) {
[17:44:46.002]                   sessionInformation <- function() {
[17:44:46.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.002]                       search = base::search(), system = base::Sys.info())
[17:44:46.002]                   }
[17:44:46.002]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.002]                     cond$call), session = sessionInformation(), 
[17:44:46.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.002]                   signalCondition(cond)
[17:44:46.002]                 }
[17:44:46.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.002]                 "immediateCondition"))) {
[17:44:46.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.002]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.002]                   if (TRUE && !signal) {
[17:44:46.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.002]                     {
[17:44:46.002]                       inherits <- base::inherits
[17:44:46.002]                       invokeRestart <- base::invokeRestart
[17:44:46.002]                       is.null <- base::is.null
[17:44:46.002]                       muffled <- FALSE
[17:44:46.002]                       if (inherits(cond, "message")) {
[17:44:46.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.002]                         if (muffled) 
[17:44:46.002]                           invokeRestart("muffleMessage")
[17:44:46.002]                       }
[17:44:46.002]                       else if (inherits(cond, "warning")) {
[17:44:46.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.002]                         if (muffled) 
[17:44:46.002]                           invokeRestart("muffleWarning")
[17:44:46.002]                       }
[17:44:46.002]                       else if (inherits(cond, "condition")) {
[17:44:46.002]                         if (!is.null(pattern)) {
[17:44:46.002]                           computeRestarts <- base::computeRestarts
[17:44:46.002]                           grepl <- base::grepl
[17:44:46.002]                           restarts <- computeRestarts(cond)
[17:44:46.002]                           for (restart in restarts) {
[17:44:46.002]                             name <- restart$name
[17:44:46.002]                             if (is.null(name)) 
[17:44:46.002]                               next
[17:44:46.002]                             if (!grepl(pattern, name)) 
[17:44:46.002]                               next
[17:44:46.002]                             invokeRestart(restart)
[17:44:46.002]                             muffled <- TRUE
[17:44:46.002]                             break
[17:44:46.002]                           }
[17:44:46.002]                         }
[17:44:46.002]                       }
[17:44:46.002]                       invisible(muffled)
[17:44:46.002]                     }
[17:44:46.002]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.002]                   }
[17:44:46.002]                 }
[17:44:46.002]                 else {
[17:44:46.002]                   if (TRUE) {
[17:44:46.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.002]                     {
[17:44:46.002]                       inherits <- base::inherits
[17:44:46.002]                       invokeRestart <- base::invokeRestart
[17:44:46.002]                       is.null <- base::is.null
[17:44:46.002]                       muffled <- FALSE
[17:44:46.002]                       if (inherits(cond, "message")) {
[17:44:46.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.002]                         if (muffled) 
[17:44:46.002]                           invokeRestart("muffleMessage")
[17:44:46.002]                       }
[17:44:46.002]                       else if (inherits(cond, "warning")) {
[17:44:46.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.002]                         if (muffled) 
[17:44:46.002]                           invokeRestart("muffleWarning")
[17:44:46.002]                       }
[17:44:46.002]                       else if (inherits(cond, "condition")) {
[17:44:46.002]                         if (!is.null(pattern)) {
[17:44:46.002]                           computeRestarts <- base::computeRestarts
[17:44:46.002]                           grepl <- base::grepl
[17:44:46.002]                           restarts <- computeRestarts(cond)
[17:44:46.002]                           for (restart in restarts) {
[17:44:46.002]                             name <- restart$name
[17:44:46.002]                             if (is.null(name)) 
[17:44:46.002]                               next
[17:44:46.002]                             if (!grepl(pattern, name)) 
[17:44:46.002]                               next
[17:44:46.002]                             invokeRestart(restart)
[17:44:46.002]                             muffled <- TRUE
[17:44:46.002]                             break
[17:44:46.002]                           }
[17:44:46.002]                         }
[17:44:46.002]                       }
[17:44:46.002]                       invisible(muffled)
[17:44:46.002]                     }
[17:44:46.002]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.002]                   }
[17:44:46.002]                 }
[17:44:46.002]             }
[17:44:46.002]         }))
[17:44:46.002]     }, error = function(ex) {
[17:44:46.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.002]                 ...future.rng), started = ...future.startTime, 
[17:44:46.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.002]             version = "1.8"), class = "FutureResult")
[17:44:46.002]     }, finally = {
[17:44:46.002]         if (!identical(...future.workdir, getwd())) 
[17:44:46.002]             setwd(...future.workdir)
[17:44:46.002]         {
[17:44:46.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.002]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.002]             }
[17:44:46.002]             base::options(...future.oldOptions)
[17:44:46.002]             if (.Platform$OS.type == "windows") {
[17:44:46.002]                 old_names <- names(...future.oldEnvVars)
[17:44:46.002]                 envs <- base::Sys.getenv()
[17:44:46.002]                 names <- names(envs)
[17:44:46.002]                 common <- intersect(names, old_names)
[17:44:46.002]                 added <- setdiff(names, old_names)
[17:44:46.002]                 removed <- setdiff(old_names, names)
[17:44:46.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.002]                   envs[common]]
[17:44:46.002]                 NAMES <- toupper(changed)
[17:44:46.002]                 args <- list()
[17:44:46.002]                 for (kk in seq_along(NAMES)) {
[17:44:46.002]                   name <- changed[[kk]]
[17:44:46.002]                   NAME <- NAMES[[kk]]
[17:44:46.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.002]                     next
[17:44:46.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.002]                 }
[17:44:46.002]                 NAMES <- toupper(added)
[17:44:46.002]                 for (kk in seq_along(NAMES)) {
[17:44:46.002]                   name <- added[[kk]]
[17:44:46.002]                   NAME <- NAMES[[kk]]
[17:44:46.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.002]                     next
[17:44:46.002]                   args[[name]] <- ""
[17:44:46.002]                 }
[17:44:46.002]                 NAMES <- toupper(removed)
[17:44:46.002]                 for (kk in seq_along(NAMES)) {
[17:44:46.002]                   name <- removed[[kk]]
[17:44:46.002]                   NAME <- NAMES[[kk]]
[17:44:46.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.002]                     next
[17:44:46.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.002]                 }
[17:44:46.002]                 if (length(args) > 0) 
[17:44:46.002]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.002]             }
[17:44:46.002]             else {
[17:44:46.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.002]             }
[17:44:46.002]             {
[17:44:46.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.002]                   0L) {
[17:44:46.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.002]                   base::options(opts)
[17:44:46.002]                 }
[17:44:46.002]                 {
[17:44:46.002]                   {
[17:44:46.002]                     base::assign(".Random.seed", c(10407L, 758682982L, 
[17:44:46.002]                     2007525116L, -28481907L, 1098785749L, 672537740L, 
[17:44:46.002]                     -484569582L), envir = base::globalenv(), 
[17:44:46.002]                       inherits = FALSE)
[17:44:46.002]                     NULL
[17:44:46.002]                   }
[17:44:46.002]                   options(future.plan = NULL)
[17:44:46.002]                   if (is.na(NA_character_)) 
[17:44:46.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.002]                     .init = FALSE)
[17:44:46.002]                 }
[17:44:46.002]             }
[17:44:46.002]         }
[17:44:46.002]     })
[17:44:46.002]     if (TRUE) {
[17:44:46.002]         base::sink(type = "output", split = FALSE)
[17:44:46.002]         if (TRUE) {
[17:44:46.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.002]         }
[17:44:46.002]         else {
[17:44:46.002]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.002]         }
[17:44:46.002]         base::close(...future.stdout)
[17:44:46.002]         ...future.stdout <- NULL
[17:44:46.002]     }
[17:44:46.002]     ...future.result$conditions <- ...future.conditions
[17:44:46.002]     ...future.result$finished <- base::Sys.time()
[17:44:46.002]     ...future.result
[17:44:46.002] }
[17:44:46.004] assign_globals() ...
[17:44:46.004] List of 5
[17:44:46.004]  $ ...future.FUN            :function (x, y)  
[17:44:46.004]  $ MoreArgs                 :List of 1
[17:44:46.004]   ..$ y: int [1:2] 3 4
[17:44:46.004]  $ ...future.elements_ii    :List of 1
[17:44:46.004]   ..$ x:List of 2
[17:44:46.004]   .. ..$ : int 1
[17:44:46.004]   .. ..$ : int 2
[17:44:46.004]  $ ...future.seeds_ii       : NULL
[17:44:46.004]  $ ...future.globals.maxSize: NULL
[17:44:46.004]  - attr(*, "where")=List of 5
[17:44:46.004]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.004]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.004]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.004]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.004]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.004]  - attr(*, "resolved")= logi FALSE
[17:44:46.004]  - attr(*, "total_size")= num 1872
[17:44:46.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.004]  - attr(*, "already-done")= logi TRUE
[17:44:46.009] - reassign environment for ‘...future.FUN’
[17:44:46.009] - copied ‘...future.FUN’ to environment
[17:44:46.009] - copied ‘MoreArgs’ to environment
[17:44:46.009] - copied ‘...future.elements_ii’ to environment
[17:44:46.009] - copied ‘...future.seeds_ii’ to environment
[17:44:46.009] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.009] assign_globals() ... done
[17:44:46.009] plan(): Setting new future strategy stack:
[17:44:46.010] List of future strategies:
[17:44:46.010] 1. sequential:
[17:44:46.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.010]    - tweaked: FALSE
[17:44:46.010]    - call: NULL
[17:44:46.012] plan(): nbrOfWorkers() = 1
[17:44:46.012] plan(): Setting new future strategy stack:
[17:44:46.012] List of future strategies:
[17:44:46.012] 1. sequential:
[17:44:46.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.012]    - tweaked: FALSE
[17:44:46.012]    - call: plan(strategy)
[17:44:46.013] plan(): nbrOfWorkers() = 1
[17:44:46.013] SequentialFuture started (and completed)
[17:44:46.013] - Launch lazy future ... done
[17:44:46.013] run() for ‘SequentialFuture’ ... done
[17:44:46.014] Created future:
[17:44:46.014] SequentialFuture:
[17:44:46.014] Label: ‘future_mapply-1’
[17:44:46.014] Expression:
[17:44:46.014] {
[17:44:46.014]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.014]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.014]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.014]         on.exit(options(oopts), add = TRUE)
[17:44:46.014]     }
[17:44:46.014]     {
[17:44:46.014]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.014]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.014]         do.call(mapply, args = args)
[17:44:46.014]     }
[17:44:46.014] }
[17:44:46.014] Lazy evaluation: FALSE
[17:44:46.014] Asynchronous evaluation: FALSE
[17:44:46.014] Local evaluation: TRUE
[17:44:46.014] Environment: R_GlobalEnv
[17:44:46.014] Capture standard output: TRUE
[17:44:46.014] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.014] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.014] Packages: <none>
[17:44:46.014] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.014] Resolved: TRUE
[17:44:46.014] Value: 112 bytes of class ‘list’
[17:44:46.014] Early signaling: FALSE
[17:44:46.014] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.014] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.014] Chunk #1 of 1 ... DONE
[17:44:46.015] Launching 1 futures (chunks) ... DONE
[17:44:46.015] Resolving 1 futures (chunks) ...
[17:44:46.015] resolve() on list ...
[17:44:46.015]  recursive: 0
[17:44:46.015]  length: 1
[17:44:46.015] 
[17:44:46.015] resolved() for ‘SequentialFuture’ ...
[17:44:46.015] - state: ‘finished’
[17:44:46.015] - run: TRUE
[17:44:46.015] - result: ‘FutureResult’
[17:44:46.016] resolved() for ‘SequentialFuture’ ... done
[17:44:46.016] Future #1
[17:44:46.016] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.016] - nx: 1
[17:44:46.016] - relay: TRUE
[17:44:46.016] - stdout: TRUE
[17:44:46.016] - signal: TRUE
[17:44:46.016] - resignal: FALSE
[17:44:46.016] - force: TRUE
[17:44:46.016] - relayed: [n=1] FALSE
[17:44:46.016] - queued futures: [n=1] FALSE
[17:44:46.017]  - until=1
[17:44:46.017]  - relaying element #1
[17:44:46.017] - relayed: [n=1] TRUE
[17:44:46.017] - queued futures: [n=1] TRUE
[17:44:46.017] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.017]  length: 0 (resolved future 1)
[17:44:46.017] Relaying remaining futures
[17:44:46.017] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.017] - nx: 1
[17:44:46.017] - relay: TRUE
[17:44:46.018] - stdout: TRUE
[17:44:46.018] - signal: TRUE
[17:44:46.018] - resignal: FALSE
[17:44:46.018] - force: TRUE
[17:44:46.018] - relayed: [n=1] TRUE
[17:44:46.018] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.018] - relayed: [n=1] TRUE
[17:44:46.018] - queued futures: [n=1] TRUE
[17:44:46.018] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.018] resolve() on list ... DONE
[17:44:46.018]  - Number of value chunks collected: 1
[17:44:46.019] Resolving 1 futures (chunks) ... DONE
[17:44:46.019] Reducing values from 1 chunks ...
[17:44:46.019]  - Number of values collected after concatenation: 2
[17:44:46.019]  - Number of values expected: 2
[17:44:46.019] Reducing values from 1 chunks ... DONE
[17:44:46.019] future_mapply() ... DONE
[17:44:46.019] future_mapply() ...
[17:44:46.019] Generating random seeds ...
[17:44:46.019] Generating random seed streams for 2 elements ...
[17:44:46.020] Generating random seed streams for 2 elements ... DONE
[17:44:46.020] Generating random seeds ... DONE
[17:44:46.020] Will set RNG state on exit: 10407, -28481907, 1349820217, 692505723, -484569582, -442277067, 964225693
[17:44:46.020] Number of chunks: 1
[17:44:46.020] getGlobalsAndPackagesXApply() ...
[17:44:46.020]  - future.globals: TRUE
[17:44:46.020] getGlobalsAndPackages() ...
[17:44:46.020] Searching for globals...
[17:44:46.021] - globals found: [1] ‘FUN’
[17:44:46.021] Searching for globals ... DONE
[17:44:46.021] Resolving globals: FALSE
[17:44:46.022] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:46.022] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:46.022] - globals: [1] ‘FUN’
[17:44:46.022] 
[17:44:46.022] getGlobalsAndPackages() ... DONE
[17:44:46.022]  - globals found/used: [n=1] ‘FUN’
[17:44:46.022]  - needed namespaces: [n=0] 
[17:44:46.023] Finding globals ... DONE
[17:44:46.023] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.023] List of 2
[17:44:46.023]  $ ...future.FUN:function (x, y)  
[17:44:46.023]  $ MoreArgs     :List of 1
[17:44:46.023]   ..$ y: int [1:2] 3 4
[17:44:46.023]  - attr(*, "where")=List of 2
[17:44:46.023]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.023]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.023]  - attr(*, "resolved")= logi FALSE
[17:44:46.023]  - attr(*, "total_size")= num NA
[17:44:46.026] Packages to be attached in all futures: [n=0] 
[17:44:46.026] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.026] Number of futures (= number of chunks): 1
[17:44:46.026] Launching 1 futures (chunks) ...
[17:44:46.026] Chunk #1 of 1 ...
[17:44:46.026]  - Finding globals in '...' for chunk #1 ...
[17:44:46.026] getGlobalsAndPackages() ...
[17:44:46.026] Searching for globals...
[17:44:46.027] 
[17:44:46.027] Searching for globals ... DONE
[17:44:46.027] - globals: [0] <none>
[17:44:46.027] getGlobalsAndPackages() ... DONE
[17:44:46.027]    + additional globals found: [n=0] 
[17:44:46.027]    + additional namespaces needed: [n=0] 
[17:44:46.027]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.027]  - seeds: [2] <seeds>
[17:44:46.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.027] getGlobalsAndPackages() ...
[17:44:46.028] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.028] Resolving globals: FALSE
[17:44:46.028] The total size of the 5 globals is 1.98 KiB (2032 bytes)
[17:44:46.029] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.98 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (160 bytes of class ‘list’) and ‘...future.elements_ii’ (112 bytes of class ‘list’)
[17:44:46.029] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.029] 
[17:44:46.029] getGlobalsAndPackages() ... DONE
[17:44:46.029] run() for ‘Future’ ...
[17:44:46.029] - state: ‘created’
[17:44:46.029] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.030] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.030]   - Field: ‘label’
[17:44:46.030]   - Field: ‘local’
[17:44:46.030]   - Field: ‘owner’
[17:44:46.030]   - Field: ‘envir’
[17:44:46.030]   - Field: ‘packages’
[17:44:46.030]   - Field: ‘gc’
[17:44:46.030]   - Field: ‘conditions’
[17:44:46.030]   - Field: ‘expr’
[17:44:46.031]   - Field: ‘uuid’
[17:44:46.031]   - Field: ‘seed’
[17:44:46.031]   - Field: ‘version’
[17:44:46.031]   - Field: ‘result’
[17:44:46.031]   - Field: ‘asynchronous’
[17:44:46.031]   - Field: ‘calls’
[17:44:46.031]   - Field: ‘globals’
[17:44:46.031]   - Field: ‘stdout’
[17:44:46.031]   - Field: ‘earlySignal’
[17:44:46.031]   - Field: ‘lazy’
[17:44:46.032]   - Field: ‘state’
[17:44:46.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.032] - Launch lazy future ...
[17:44:46.032] Packages needed by the future expression (n = 0): <none>
[17:44:46.032] Packages needed by future strategies (n = 0): <none>
[17:44:46.032] {
[17:44:46.032]     {
[17:44:46.032]         {
[17:44:46.032]             ...future.startTime <- base::Sys.time()
[17:44:46.032]             {
[17:44:46.032]                 {
[17:44:46.032]                   {
[17:44:46.032]                     base::local({
[17:44:46.032]                       has_future <- base::requireNamespace("future", 
[17:44:46.032]                         quietly = TRUE)
[17:44:46.032]                       if (has_future) {
[17:44:46.032]                         ns <- base::getNamespace("future")
[17:44:46.032]                         version <- ns[[".package"]][["version"]]
[17:44:46.032]                         if (is.null(version)) 
[17:44:46.032]                           version <- utils::packageVersion("future")
[17:44:46.032]                       }
[17:44:46.032]                       else {
[17:44:46.032]                         version <- NULL
[17:44:46.032]                       }
[17:44:46.032]                       if (!has_future || version < "1.8.0") {
[17:44:46.032]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.032]                           "", base::R.version$version.string), 
[17:44:46.032]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.032]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.032]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.032]                             "release", "version")], collapse = " "), 
[17:44:46.032]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.032]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.032]                           info)
[17:44:46.032]                         info <- base::paste(info, collapse = "; ")
[17:44:46.032]                         if (!has_future) {
[17:44:46.032]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.032]                             info)
[17:44:46.032]                         }
[17:44:46.032]                         else {
[17:44:46.032]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.032]                             info, version)
[17:44:46.032]                         }
[17:44:46.032]                         base::stop(msg)
[17:44:46.032]                       }
[17:44:46.032]                     })
[17:44:46.032]                   }
[17:44:46.032]                   ...future.strategy.old <- future::plan("list")
[17:44:46.032]                   options(future.plan = NULL)
[17:44:46.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.032]                 }
[17:44:46.032]                 ...future.workdir <- getwd()
[17:44:46.032]             }
[17:44:46.032]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.032]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.032]         }
[17:44:46.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.032]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.032]             base::names(...future.oldOptions))
[17:44:46.032]     }
[17:44:46.032]     if (FALSE) {
[17:44:46.032]     }
[17:44:46.032]     else {
[17:44:46.032]         if (TRUE) {
[17:44:46.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.032]                 open = "w")
[17:44:46.032]         }
[17:44:46.032]         else {
[17:44:46.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.032]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.032]         }
[17:44:46.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.032]             base::sink(type = "output", split = FALSE)
[17:44:46.032]             base::close(...future.stdout)
[17:44:46.032]         }, add = TRUE)
[17:44:46.032]     }
[17:44:46.032]     ...future.frame <- base::sys.nframe()
[17:44:46.032]     ...future.conditions <- base::list()
[17:44:46.032]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.032]     if (FALSE) {
[17:44:46.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.032]     }
[17:44:46.032]     ...future.result <- base::tryCatch({
[17:44:46.032]         base::withCallingHandlers({
[17:44:46.032]             ...future.value <- base::withVisible(base::local({
[17:44:46.032]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.032]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.032]                   ...future.globals.maxSize)) {
[17:44:46.032]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.032]                   on.exit(options(oopts), add = TRUE)
[17:44:46.032]                 }
[17:44:46.032]                 {
[17:44:46.032]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:46.032]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:46.032]                       envir = globalenv(), inherits = FALSE)
[17:44:46.032]                     ...future.FUN(...)
[17:44:46.032]                   }
[17:44:46.032]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:46.032]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:46.032]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.032]                     USE.NAMES = FALSE)
[17:44:46.032]                   do.call(mapply, args = args)
[17:44:46.032]                 }
[17:44:46.032]             }))
[17:44:46.032]             future::FutureResult(value = ...future.value$value, 
[17:44:46.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.032]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.032]                     ...future.globalenv.names))
[17:44:46.032]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.032]         }, condition = base::local({
[17:44:46.032]             c <- base::c
[17:44:46.032]             inherits <- base::inherits
[17:44:46.032]             invokeRestart <- base::invokeRestart
[17:44:46.032]             length <- base::length
[17:44:46.032]             list <- base::list
[17:44:46.032]             seq.int <- base::seq.int
[17:44:46.032]             signalCondition <- base::signalCondition
[17:44:46.032]             sys.calls <- base::sys.calls
[17:44:46.032]             `[[` <- base::`[[`
[17:44:46.032]             `+` <- base::`+`
[17:44:46.032]             `<<-` <- base::`<<-`
[17:44:46.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.032]                   3L)]
[17:44:46.032]             }
[17:44:46.032]             function(cond) {
[17:44:46.032]                 is_error <- inherits(cond, "error")
[17:44:46.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.032]                   NULL)
[17:44:46.032]                 if (is_error) {
[17:44:46.032]                   sessionInformation <- function() {
[17:44:46.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.032]                       search = base::search(), system = base::Sys.info())
[17:44:46.032]                   }
[17:44:46.032]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.032]                     cond$call), session = sessionInformation(), 
[17:44:46.032]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.032]                   signalCondition(cond)
[17:44:46.032]                 }
[17:44:46.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.032]                 "immediateCondition"))) {
[17:44:46.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.032]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.032]                   if (TRUE && !signal) {
[17:44:46.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.032]                     {
[17:44:46.032]                       inherits <- base::inherits
[17:44:46.032]                       invokeRestart <- base::invokeRestart
[17:44:46.032]                       is.null <- base::is.null
[17:44:46.032]                       muffled <- FALSE
[17:44:46.032]                       if (inherits(cond, "message")) {
[17:44:46.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.032]                         if (muffled) 
[17:44:46.032]                           invokeRestart("muffleMessage")
[17:44:46.032]                       }
[17:44:46.032]                       else if (inherits(cond, "warning")) {
[17:44:46.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.032]                         if (muffled) 
[17:44:46.032]                           invokeRestart("muffleWarning")
[17:44:46.032]                       }
[17:44:46.032]                       else if (inherits(cond, "condition")) {
[17:44:46.032]                         if (!is.null(pattern)) {
[17:44:46.032]                           computeRestarts <- base::computeRestarts
[17:44:46.032]                           grepl <- base::grepl
[17:44:46.032]                           restarts <- computeRestarts(cond)
[17:44:46.032]                           for (restart in restarts) {
[17:44:46.032]                             name <- restart$name
[17:44:46.032]                             if (is.null(name)) 
[17:44:46.032]                               next
[17:44:46.032]                             if (!grepl(pattern, name)) 
[17:44:46.032]                               next
[17:44:46.032]                             invokeRestart(restart)
[17:44:46.032]                             muffled <- TRUE
[17:44:46.032]                             break
[17:44:46.032]                           }
[17:44:46.032]                         }
[17:44:46.032]                       }
[17:44:46.032]                       invisible(muffled)
[17:44:46.032]                     }
[17:44:46.032]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.032]                   }
[17:44:46.032]                 }
[17:44:46.032]                 else {
[17:44:46.032]                   if (TRUE) {
[17:44:46.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.032]                     {
[17:44:46.032]                       inherits <- base::inherits
[17:44:46.032]                       invokeRestart <- base::invokeRestart
[17:44:46.032]                       is.null <- base::is.null
[17:44:46.032]                       muffled <- FALSE
[17:44:46.032]                       if (inherits(cond, "message")) {
[17:44:46.032]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.032]                         if (muffled) 
[17:44:46.032]                           invokeRestart("muffleMessage")
[17:44:46.032]                       }
[17:44:46.032]                       else if (inherits(cond, "warning")) {
[17:44:46.032]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.032]                         if (muffled) 
[17:44:46.032]                           invokeRestart("muffleWarning")
[17:44:46.032]                       }
[17:44:46.032]                       else if (inherits(cond, "condition")) {
[17:44:46.032]                         if (!is.null(pattern)) {
[17:44:46.032]                           computeRestarts <- base::computeRestarts
[17:44:46.032]                           grepl <- base::grepl
[17:44:46.032]                           restarts <- computeRestarts(cond)
[17:44:46.032]                           for (restart in restarts) {
[17:44:46.032]                             name <- restart$name
[17:44:46.032]                             if (is.null(name)) 
[17:44:46.032]                               next
[17:44:46.032]                             if (!grepl(pattern, name)) 
[17:44:46.032]                               next
[17:44:46.032]                             invokeRestart(restart)
[17:44:46.032]                             muffled <- TRUE
[17:44:46.032]                             break
[17:44:46.032]                           }
[17:44:46.032]                         }
[17:44:46.032]                       }
[17:44:46.032]                       invisible(muffled)
[17:44:46.032]                     }
[17:44:46.032]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.032]                   }
[17:44:46.032]                 }
[17:44:46.032]             }
[17:44:46.032]         }))
[17:44:46.032]     }, error = function(ex) {
[17:44:46.032]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.032]                 ...future.rng), started = ...future.startTime, 
[17:44:46.032]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.032]             version = "1.8"), class = "FutureResult")
[17:44:46.032]     }, finally = {
[17:44:46.032]         if (!identical(...future.workdir, getwd())) 
[17:44:46.032]             setwd(...future.workdir)
[17:44:46.032]         {
[17:44:46.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.032]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.032]             }
[17:44:46.032]             base::options(...future.oldOptions)
[17:44:46.032]             if (.Platform$OS.type == "windows") {
[17:44:46.032]                 old_names <- names(...future.oldEnvVars)
[17:44:46.032]                 envs <- base::Sys.getenv()
[17:44:46.032]                 names <- names(envs)
[17:44:46.032]                 common <- intersect(names, old_names)
[17:44:46.032]                 added <- setdiff(names, old_names)
[17:44:46.032]                 removed <- setdiff(old_names, names)
[17:44:46.032]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.032]                   envs[common]]
[17:44:46.032]                 NAMES <- toupper(changed)
[17:44:46.032]                 args <- list()
[17:44:46.032]                 for (kk in seq_along(NAMES)) {
[17:44:46.032]                   name <- changed[[kk]]
[17:44:46.032]                   NAME <- NAMES[[kk]]
[17:44:46.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.032]                     next
[17:44:46.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.032]                 }
[17:44:46.032]                 NAMES <- toupper(added)
[17:44:46.032]                 for (kk in seq_along(NAMES)) {
[17:44:46.032]                   name <- added[[kk]]
[17:44:46.032]                   NAME <- NAMES[[kk]]
[17:44:46.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.032]                     next
[17:44:46.032]                   args[[name]] <- ""
[17:44:46.032]                 }
[17:44:46.032]                 NAMES <- toupper(removed)
[17:44:46.032]                 for (kk in seq_along(NAMES)) {
[17:44:46.032]                   name <- removed[[kk]]
[17:44:46.032]                   NAME <- NAMES[[kk]]
[17:44:46.032]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.032]                     next
[17:44:46.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.032]                 }
[17:44:46.032]                 if (length(args) > 0) 
[17:44:46.032]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.032]             }
[17:44:46.032]             else {
[17:44:46.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.032]             }
[17:44:46.032]             {
[17:44:46.032]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.032]                   0L) {
[17:44:46.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.032]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.032]                   base::options(opts)
[17:44:46.032]                 }
[17:44:46.032]                 {
[17:44:46.032]                   {
[17:44:46.032]                     base::assign(".Random.seed", c(10407L, -28481907L, 
[17:44:46.032]                     1349820217L, 692505723L, -484569582L, -442277067L, 
[17:44:46.032]                     964225693L), envir = base::globalenv(), inherits = FALSE)
[17:44:46.032]                     NULL
[17:44:46.032]                   }
[17:44:46.032]                   options(future.plan = NULL)
[17:44:46.032]                   if (is.na(NA_character_)) 
[17:44:46.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.032]                     .init = FALSE)
[17:44:46.032]                 }
[17:44:46.032]             }
[17:44:46.032]         }
[17:44:46.032]     })
[17:44:46.032]     if (TRUE) {
[17:44:46.032]         base::sink(type = "output", split = FALSE)
[17:44:46.032]         if (TRUE) {
[17:44:46.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.032]         }
[17:44:46.032]         else {
[17:44:46.032]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.032]         }
[17:44:46.032]         base::close(...future.stdout)
[17:44:46.032]         ...future.stdout <- NULL
[17:44:46.032]     }
[17:44:46.032]     ...future.result$conditions <- ...future.conditions
[17:44:46.032]     ...future.result$finished <- base::Sys.time()
[17:44:46.032]     ...future.result
[17:44:46.032] }
[17:44:46.034] assign_globals() ...
[17:44:46.034] List of 5
[17:44:46.034]  $ ...future.FUN            :function (x, y)  
[17:44:46.034]  $ MoreArgs                 :List of 1
[17:44:46.034]   ..$ y: int [1:2] 3 4
[17:44:46.034]  $ ...future.elements_ii    :List of 1
[17:44:46.034]   ..$ x:List of 2
[17:44:46.034]   .. ..$ : int 1
[17:44:46.034]   .. ..$ : int 2
[17:44:46.034]  $ ...future.seeds_ii       :List of 2
[17:44:46.034]   ..$ : int [1:7] 10407 1611491924 -1294971101 1506452124 1148887124 663633636 -1035138577
[17:44:46.034]   ..$ : int [1:7] 10407 -947859376 19270589 672171964 -649803083 1651961057 383439639
[17:44:46.034]  $ ...future.globals.maxSize: NULL
[17:44:46.034]  - attr(*, "where")=List of 5
[17:44:46.034]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.034]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.034]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.034]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.034]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.034]  - attr(*, "resolved")= logi FALSE
[17:44:46.034]  - attr(*, "total_size")= num 2032
[17:44:46.034]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.034]  - attr(*, "already-done")= logi TRUE
[17:44:46.041] - reassign environment for ‘...future.FUN’
[17:44:46.041] - copied ‘...future.FUN’ to environment
[17:44:46.042] - copied ‘MoreArgs’ to environment
[17:44:46.042] - copied ‘...future.elements_ii’ to environment
[17:44:46.042] - copied ‘...future.seeds_ii’ to environment
[17:44:46.042] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.042] assign_globals() ... done
[17:44:46.042] plan(): Setting new future strategy stack:
[17:44:46.042] List of future strategies:
[17:44:46.042] 1. sequential:
[17:44:46.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.042]    - tweaked: FALSE
[17:44:46.042]    - call: NULL
[17:44:46.043] plan(): nbrOfWorkers() = 1
[17:44:46.043] plan(): Setting new future strategy stack:
[17:44:46.044] List of future strategies:
[17:44:46.044] 1. sequential:
[17:44:46.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.044]    - tweaked: FALSE
[17:44:46.044]    - call: plan(strategy)
[17:44:46.044] plan(): nbrOfWorkers() = 1
[17:44:46.044] SequentialFuture started (and completed)
[17:44:46.044] - Launch lazy future ... done
[17:44:46.044] run() for ‘SequentialFuture’ ... done
[17:44:46.044] Created future:
[17:44:46.045] SequentialFuture:
[17:44:46.045] Label: ‘future_mapply-1’
[17:44:46.045] Expression:
[17:44:46.045] {
[17:44:46.045]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.045]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.045]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.045]         on.exit(options(oopts), add = TRUE)
[17:44:46.045]     }
[17:44:46.045]     {
[17:44:46.045]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:46.045]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:46.045]                 inherits = FALSE)
[17:44:46.045]             ...future.FUN(...)
[17:44:46.045]         }
[17:44:46.045]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:46.045]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:46.045]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.045]         do.call(mapply, args = args)
[17:44:46.045]     }
[17:44:46.045] }
[17:44:46.045] Lazy evaluation: FALSE
[17:44:46.045] Asynchronous evaluation: FALSE
[17:44:46.045] Local evaluation: TRUE
[17:44:46.045] Environment: R_GlobalEnv
[17:44:46.045] Capture standard output: TRUE
[17:44:46.045] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.045] Globals: 5 objects totaling 1.98 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.045] Packages: <none>
[17:44:46.045] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:46.045] Resolved: TRUE
[17:44:46.045] Value: 112 bytes of class ‘list’
[17:44:46.045] Early signaling: FALSE
[17:44:46.045] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.045] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.045] Chunk #1 of 1 ... DONE
[17:44:46.046] Launching 1 futures (chunks) ... DONE
[17:44:46.046] Resolving 1 futures (chunks) ...
[17:44:46.046] resolve() on list ...
[17:44:46.046]  recursive: 0
[17:44:46.046]  length: 1
[17:44:46.046] 
[17:44:46.046] resolved() for ‘SequentialFuture’ ...
[17:44:46.046] - state: ‘finished’
[17:44:46.046] - run: TRUE
[17:44:46.046] - result: ‘FutureResult’
[17:44:46.046] resolved() for ‘SequentialFuture’ ... done
[17:44:46.047] Future #1
[17:44:46.047] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.047] - nx: 1
[17:44:46.047] - relay: TRUE
[17:44:46.047] - stdout: TRUE
[17:44:46.047] - signal: TRUE
[17:44:46.047] - resignal: FALSE
[17:44:46.047] - force: TRUE
[17:44:46.047] - relayed: [n=1] FALSE
[17:44:46.047] - queued futures: [n=1] FALSE
[17:44:46.047]  - until=1
[17:44:46.048]  - relaying element #1
[17:44:46.048] - relayed: [n=1] TRUE
[17:44:46.048] - queued futures: [n=1] TRUE
[17:44:46.048] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.048]  length: 0 (resolved future 1)
[17:44:46.048] Relaying remaining futures
[17:44:46.048] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.048] - nx: 1
[17:44:46.048] - relay: TRUE
[17:44:46.048] - stdout: TRUE
[17:44:46.049] - signal: TRUE
[17:44:46.049] - resignal: FALSE
[17:44:46.049] - force: TRUE
[17:44:46.049] - relayed: [n=1] TRUE
[17:44:46.049] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.049] - relayed: [n=1] TRUE
[17:44:46.049] - queued futures: [n=1] TRUE
[17:44:46.049] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.049] resolve() on list ... DONE
[17:44:46.049]  - Number of value chunks collected: 1
[17:44:46.049] Resolving 1 futures (chunks) ... DONE
[17:44:46.050] Reducing values from 1 chunks ...
[17:44:46.050]  - Number of values collected after concatenation: 2
[17:44:46.050]  - Number of values expected: 2
[17:44:46.050] Reducing values from 1 chunks ... DONE
[17:44:46.050] future_mapply() ... DONE
[17:44:46.050] future_mapply() ...
[17:44:46.050] Number of chunks: 1
[17:44:46.050] getGlobalsAndPackagesXApply() ...
[17:44:46.050]  - future.globals: TRUE
[17:44:46.050] getGlobalsAndPackages() ...
[17:44:46.051] Searching for globals...
[17:44:46.052] - globals found: [1] ‘FUN’
[17:44:46.052] Searching for globals ... DONE
[17:44:46.052] Resolving globals: FALSE
[17:44:46.052] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:46.052] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:46.052] - globals: [1] ‘FUN’
[17:44:46.053] 
[17:44:46.053] getGlobalsAndPackages() ... DONE
[17:44:46.053]  - globals found/used: [n=1] ‘FUN’
[17:44:46.053]  - needed namespaces: [n=0] 
[17:44:46.053] Finding globals ... DONE
[17:44:46.053] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.053] List of 2
[17:44:46.053]  $ ...future.FUN:function (x, y)  
[17:44:46.053]  $ MoreArgs     :List of 1
[17:44:46.053]   ..$ y: int [1:2] 3 4
[17:44:46.053]  - attr(*, "where")=List of 2
[17:44:46.053]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.053]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.053]  - attr(*, "resolved")= logi FALSE
[17:44:46.053]  - attr(*, "total_size")= num NA
[17:44:46.056] Packages to be attached in all futures: [n=0] 
[17:44:46.056] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.056] Number of futures (= number of chunks): 1
[17:44:46.056] Launching 1 futures (chunks) ...
[17:44:46.056] Chunk #1 of 1 ...
[17:44:46.057]  - Finding globals in '...' for chunk #1 ...
[17:44:46.057] getGlobalsAndPackages() ...
[17:44:46.057] Searching for globals...
[17:44:46.057] 
[17:44:46.057] Searching for globals ... DONE
[17:44:46.057] - globals: [0] <none>
[17:44:46.057] getGlobalsAndPackages() ... DONE
[17:44:46.057]    + additional globals found: [n=0] 
[17:44:46.057]    + additional namespaces needed: [n=0] 
[17:44:46.058]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.058]  - seeds: <none>
[17:44:46.059]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.059] getGlobalsAndPackages() ...
[17:44:46.059] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.060] Resolving globals: FALSE
[17:44:46.060] The total size of the 5 globals is 1.83 KiB (1872 bytes)
[17:44:46.061] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:46.061] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.061] 
[17:44:46.061] getGlobalsAndPackages() ... DONE
[17:44:46.061] run() for ‘Future’ ...
[17:44:46.061] - state: ‘created’
[17:44:46.061] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.062] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.062]   - Field: ‘label’
[17:44:46.062]   - Field: ‘local’
[17:44:46.062]   - Field: ‘owner’
[17:44:46.062]   - Field: ‘envir’
[17:44:46.062]   - Field: ‘packages’
[17:44:46.062]   - Field: ‘gc’
[17:44:46.063]   - Field: ‘conditions’
[17:44:46.063]   - Field: ‘expr’
[17:44:46.063]   - Field: ‘uuid’
[17:44:46.063]   - Field: ‘seed’
[17:44:46.063]   - Field: ‘version’
[17:44:46.063]   - Field: ‘result’
[17:44:46.063]   - Field: ‘asynchronous’
[17:44:46.063]   - Field: ‘calls’
[17:44:46.063]   - Field: ‘globals’
[17:44:46.063]   - Field: ‘stdout’
[17:44:46.063]   - Field: ‘earlySignal’
[17:44:46.064]   - Field: ‘lazy’
[17:44:46.064]   - Field: ‘state’
[17:44:46.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.064] - Launch lazy future ...
[17:44:46.064] Packages needed by the future expression (n = 0): <none>
[17:44:46.064] Packages needed by future strategies (n = 0): <none>
[17:44:46.065] {
[17:44:46.065]     {
[17:44:46.065]         {
[17:44:46.065]             ...future.startTime <- base::Sys.time()
[17:44:46.065]             {
[17:44:46.065]                 {
[17:44:46.065]                   {
[17:44:46.065]                     base::local({
[17:44:46.065]                       has_future <- base::requireNamespace("future", 
[17:44:46.065]                         quietly = TRUE)
[17:44:46.065]                       if (has_future) {
[17:44:46.065]                         ns <- base::getNamespace("future")
[17:44:46.065]                         version <- ns[[".package"]][["version"]]
[17:44:46.065]                         if (is.null(version)) 
[17:44:46.065]                           version <- utils::packageVersion("future")
[17:44:46.065]                       }
[17:44:46.065]                       else {
[17:44:46.065]                         version <- NULL
[17:44:46.065]                       }
[17:44:46.065]                       if (!has_future || version < "1.8.0") {
[17:44:46.065]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.065]                           "", base::R.version$version.string), 
[17:44:46.065]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.065]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.065]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.065]                             "release", "version")], collapse = " "), 
[17:44:46.065]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.065]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.065]                           info)
[17:44:46.065]                         info <- base::paste(info, collapse = "; ")
[17:44:46.065]                         if (!has_future) {
[17:44:46.065]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.065]                             info)
[17:44:46.065]                         }
[17:44:46.065]                         else {
[17:44:46.065]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.065]                             info, version)
[17:44:46.065]                         }
[17:44:46.065]                         base::stop(msg)
[17:44:46.065]                       }
[17:44:46.065]                     })
[17:44:46.065]                   }
[17:44:46.065]                   ...future.strategy.old <- future::plan("list")
[17:44:46.065]                   options(future.plan = NULL)
[17:44:46.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.065]                 }
[17:44:46.065]                 ...future.workdir <- getwd()
[17:44:46.065]             }
[17:44:46.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.065]         }
[17:44:46.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.065]             base::names(...future.oldOptions))
[17:44:46.065]     }
[17:44:46.065]     if (FALSE) {
[17:44:46.065]     }
[17:44:46.065]     else {
[17:44:46.065]         if (TRUE) {
[17:44:46.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.065]                 open = "w")
[17:44:46.065]         }
[17:44:46.065]         else {
[17:44:46.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.065]         }
[17:44:46.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.065]             base::sink(type = "output", split = FALSE)
[17:44:46.065]             base::close(...future.stdout)
[17:44:46.065]         }, add = TRUE)
[17:44:46.065]     }
[17:44:46.065]     ...future.frame <- base::sys.nframe()
[17:44:46.065]     ...future.conditions <- base::list()
[17:44:46.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.065]     if (FALSE) {
[17:44:46.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.065]     }
[17:44:46.065]     ...future.result <- base::tryCatch({
[17:44:46.065]         base::withCallingHandlers({
[17:44:46.065]             ...future.value <- base::withVisible(base::local({
[17:44:46.065]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.065]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.065]                   ...future.globals.maxSize)) {
[17:44:46.065]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.065]                   on.exit(options(oopts), add = TRUE)
[17:44:46.065]                 }
[17:44:46.065]                 {
[17:44:46.065]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.065]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.065]                     USE.NAMES = FALSE)
[17:44:46.065]                   do.call(mapply, args = args)
[17:44:46.065]                 }
[17:44:46.065]             }))
[17:44:46.065]             future::FutureResult(value = ...future.value$value, 
[17:44:46.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.065]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.065]                     ...future.globalenv.names))
[17:44:46.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.065]         }, condition = base::local({
[17:44:46.065]             c <- base::c
[17:44:46.065]             inherits <- base::inherits
[17:44:46.065]             invokeRestart <- base::invokeRestart
[17:44:46.065]             length <- base::length
[17:44:46.065]             list <- base::list
[17:44:46.065]             seq.int <- base::seq.int
[17:44:46.065]             signalCondition <- base::signalCondition
[17:44:46.065]             sys.calls <- base::sys.calls
[17:44:46.065]             `[[` <- base::`[[`
[17:44:46.065]             `+` <- base::`+`
[17:44:46.065]             `<<-` <- base::`<<-`
[17:44:46.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.065]                   3L)]
[17:44:46.065]             }
[17:44:46.065]             function(cond) {
[17:44:46.065]                 is_error <- inherits(cond, "error")
[17:44:46.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.065]                   NULL)
[17:44:46.065]                 if (is_error) {
[17:44:46.065]                   sessionInformation <- function() {
[17:44:46.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.065]                       search = base::search(), system = base::Sys.info())
[17:44:46.065]                   }
[17:44:46.065]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.065]                     cond$call), session = sessionInformation(), 
[17:44:46.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.065]                   signalCondition(cond)
[17:44:46.065]                 }
[17:44:46.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.065]                 "immediateCondition"))) {
[17:44:46.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.065]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.065]                   if (TRUE && !signal) {
[17:44:46.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.065]                     {
[17:44:46.065]                       inherits <- base::inherits
[17:44:46.065]                       invokeRestart <- base::invokeRestart
[17:44:46.065]                       is.null <- base::is.null
[17:44:46.065]                       muffled <- FALSE
[17:44:46.065]                       if (inherits(cond, "message")) {
[17:44:46.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.065]                         if (muffled) 
[17:44:46.065]                           invokeRestart("muffleMessage")
[17:44:46.065]                       }
[17:44:46.065]                       else if (inherits(cond, "warning")) {
[17:44:46.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.065]                         if (muffled) 
[17:44:46.065]                           invokeRestart("muffleWarning")
[17:44:46.065]                       }
[17:44:46.065]                       else if (inherits(cond, "condition")) {
[17:44:46.065]                         if (!is.null(pattern)) {
[17:44:46.065]                           computeRestarts <- base::computeRestarts
[17:44:46.065]                           grepl <- base::grepl
[17:44:46.065]                           restarts <- computeRestarts(cond)
[17:44:46.065]                           for (restart in restarts) {
[17:44:46.065]                             name <- restart$name
[17:44:46.065]                             if (is.null(name)) 
[17:44:46.065]                               next
[17:44:46.065]                             if (!grepl(pattern, name)) 
[17:44:46.065]                               next
[17:44:46.065]                             invokeRestart(restart)
[17:44:46.065]                             muffled <- TRUE
[17:44:46.065]                             break
[17:44:46.065]                           }
[17:44:46.065]                         }
[17:44:46.065]                       }
[17:44:46.065]                       invisible(muffled)
[17:44:46.065]                     }
[17:44:46.065]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.065]                   }
[17:44:46.065]                 }
[17:44:46.065]                 else {
[17:44:46.065]                   if (TRUE) {
[17:44:46.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.065]                     {
[17:44:46.065]                       inherits <- base::inherits
[17:44:46.065]                       invokeRestart <- base::invokeRestart
[17:44:46.065]                       is.null <- base::is.null
[17:44:46.065]                       muffled <- FALSE
[17:44:46.065]                       if (inherits(cond, "message")) {
[17:44:46.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.065]                         if (muffled) 
[17:44:46.065]                           invokeRestart("muffleMessage")
[17:44:46.065]                       }
[17:44:46.065]                       else if (inherits(cond, "warning")) {
[17:44:46.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.065]                         if (muffled) 
[17:44:46.065]                           invokeRestart("muffleWarning")
[17:44:46.065]                       }
[17:44:46.065]                       else if (inherits(cond, "condition")) {
[17:44:46.065]                         if (!is.null(pattern)) {
[17:44:46.065]                           computeRestarts <- base::computeRestarts
[17:44:46.065]                           grepl <- base::grepl
[17:44:46.065]                           restarts <- computeRestarts(cond)
[17:44:46.065]                           for (restart in restarts) {
[17:44:46.065]                             name <- restart$name
[17:44:46.065]                             if (is.null(name)) 
[17:44:46.065]                               next
[17:44:46.065]                             if (!grepl(pattern, name)) 
[17:44:46.065]                               next
[17:44:46.065]                             invokeRestart(restart)
[17:44:46.065]                             muffled <- TRUE
[17:44:46.065]                             break
[17:44:46.065]                           }
[17:44:46.065]                         }
[17:44:46.065]                       }
[17:44:46.065]                       invisible(muffled)
[17:44:46.065]                     }
[17:44:46.065]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.065]                   }
[17:44:46.065]                 }
[17:44:46.065]             }
[17:44:46.065]         }))
[17:44:46.065]     }, error = function(ex) {
[17:44:46.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.065]                 ...future.rng), started = ...future.startTime, 
[17:44:46.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.065]             version = "1.8"), class = "FutureResult")
[17:44:46.065]     }, finally = {
[17:44:46.065]         if (!identical(...future.workdir, getwd())) 
[17:44:46.065]             setwd(...future.workdir)
[17:44:46.065]         {
[17:44:46.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.065]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.065]             }
[17:44:46.065]             base::options(...future.oldOptions)
[17:44:46.065]             if (.Platform$OS.type == "windows") {
[17:44:46.065]                 old_names <- names(...future.oldEnvVars)
[17:44:46.065]                 envs <- base::Sys.getenv()
[17:44:46.065]                 names <- names(envs)
[17:44:46.065]                 common <- intersect(names, old_names)
[17:44:46.065]                 added <- setdiff(names, old_names)
[17:44:46.065]                 removed <- setdiff(old_names, names)
[17:44:46.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.065]                   envs[common]]
[17:44:46.065]                 NAMES <- toupper(changed)
[17:44:46.065]                 args <- list()
[17:44:46.065]                 for (kk in seq_along(NAMES)) {
[17:44:46.065]                   name <- changed[[kk]]
[17:44:46.065]                   NAME <- NAMES[[kk]]
[17:44:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.065]                     next
[17:44:46.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.065]                 }
[17:44:46.065]                 NAMES <- toupper(added)
[17:44:46.065]                 for (kk in seq_along(NAMES)) {
[17:44:46.065]                   name <- added[[kk]]
[17:44:46.065]                   NAME <- NAMES[[kk]]
[17:44:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.065]                     next
[17:44:46.065]                   args[[name]] <- ""
[17:44:46.065]                 }
[17:44:46.065]                 NAMES <- toupper(removed)
[17:44:46.065]                 for (kk in seq_along(NAMES)) {
[17:44:46.065]                   name <- removed[[kk]]
[17:44:46.065]                   NAME <- NAMES[[kk]]
[17:44:46.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.065]                     next
[17:44:46.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.065]                 }
[17:44:46.065]                 if (length(args) > 0) 
[17:44:46.065]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.065]             }
[17:44:46.065]             else {
[17:44:46.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.065]             }
[17:44:46.065]             {
[17:44:46.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.065]                   0L) {
[17:44:46.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.065]                   base::options(opts)
[17:44:46.065]                 }
[17:44:46.065]                 {
[17:44:46.065]                   {
[17:44:46.065]                     base::assign(".Random.seed", c(10407L, -28481907L, 
[17:44:46.065]                     1349820217L, 692505723L, -484569582L, -442277067L, 
[17:44:46.065]                     964225693L), envir = base::globalenv(), inherits = FALSE)
[17:44:46.065]                     NULL
[17:44:46.065]                   }
[17:44:46.065]                   options(future.plan = NULL)
[17:44:46.065]                   if (is.na(NA_character_)) 
[17:44:46.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.065]                     .init = FALSE)
[17:44:46.065]                 }
[17:44:46.065]             }
[17:44:46.065]         }
[17:44:46.065]     })
[17:44:46.065]     if (TRUE) {
[17:44:46.065]         base::sink(type = "output", split = FALSE)
[17:44:46.065]         if (TRUE) {
[17:44:46.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.065]         }
[17:44:46.065]         else {
[17:44:46.065]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.065]         }
[17:44:46.065]         base::close(...future.stdout)
[17:44:46.065]         ...future.stdout <- NULL
[17:44:46.065]     }
[17:44:46.065]     ...future.result$conditions <- ...future.conditions
[17:44:46.065]     ...future.result$finished <- base::Sys.time()
[17:44:46.065]     ...future.result
[17:44:46.065] }
[17:44:46.066] assign_globals() ...
[17:44:46.066] List of 5
[17:44:46.066]  $ ...future.FUN            :function (x, y)  
[17:44:46.066]  $ MoreArgs                 :List of 1
[17:44:46.066]   ..$ y: int [1:2] 3 4
[17:44:46.066]  $ ...future.elements_ii    :List of 1
[17:44:46.066]   ..$ x:List of 2
[17:44:46.066]   .. ..$ : int 1
[17:44:46.066]   .. ..$ : int 2
[17:44:46.066]  $ ...future.seeds_ii       : NULL
[17:44:46.066]  $ ...future.globals.maxSize: NULL
[17:44:46.066]  - attr(*, "where")=List of 5
[17:44:46.066]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.066]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.066]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.066]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.066]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.066]  - attr(*, "resolved")= logi FALSE
[17:44:46.066]  - attr(*, "total_size")= num 1872
[17:44:46.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.066]  - attr(*, "already-done")= logi TRUE
[17:44:46.071] - reassign environment for ‘...future.FUN’
[17:44:46.072] - copied ‘...future.FUN’ to environment
[17:44:46.072] - copied ‘MoreArgs’ to environment
[17:44:46.072] - copied ‘...future.elements_ii’ to environment
[17:44:46.072] - copied ‘...future.seeds_ii’ to environment
[17:44:46.072] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.072] assign_globals() ... done
[17:44:46.072] plan(): Setting new future strategy stack:
[17:44:46.072] List of future strategies:
[17:44:46.072] 1. sequential:
[17:44:46.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.072]    - tweaked: FALSE
[17:44:46.072]    - call: NULL
[17:44:46.073] plan(): nbrOfWorkers() = 1
[17:44:46.073] plan(): Setting new future strategy stack:
[17:44:46.074] List of future strategies:
[17:44:46.074] 1. sequential:
[17:44:46.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.074]    - tweaked: FALSE
[17:44:46.074]    - call: plan(strategy)
[17:44:46.074] plan(): nbrOfWorkers() = 1
[17:44:46.074] SequentialFuture started (and completed)
[17:44:46.074] - Launch lazy future ... done
[17:44:46.074] run() for ‘SequentialFuture’ ... done
[17:44:46.075] Created future:
[17:44:46.075] SequentialFuture:
[17:44:46.075] Label: ‘future_.mapply-1’
[17:44:46.075] Expression:
[17:44:46.075] {
[17:44:46.075]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.075]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.075]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.075]         on.exit(options(oopts), add = TRUE)
[17:44:46.075]     }
[17:44:46.075]     {
[17:44:46.075]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.075]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.075]         do.call(mapply, args = args)
[17:44:46.075]     }
[17:44:46.075] }
[17:44:46.075] Lazy evaluation: FALSE
[17:44:46.075] Asynchronous evaluation: FALSE
[17:44:46.075] Local evaluation: TRUE
[17:44:46.075] Environment: R_GlobalEnv
[17:44:46.075] Capture standard output: TRUE
[17:44:46.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.075] Globals: 5 objects totaling 1.83 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.075] Packages: <none>
[17:44:46.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.075] Resolved: TRUE
[17:44:46.075] Value: 112 bytes of class ‘list’
[17:44:46.075] Early signaling: FALSE
[17:44:46.075] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.075] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.076] Chunk #1 of 1 ... DONE
[17:44:46.076] Launching 1 futures (chunks) ... DONE
[17:44:46.076] Resolving 1 futures (chunks) ...
[17:44:46.076] resolve() on list ...
[17:44:46.076]  recursive: 0
[17:44:46.076]  length: 1
[17:44:46.076] 
[17:44:46.076] resolved() for ‘SequentialFuture’ ...
[17:44:46.076] - state: ‘finished’
[17:44:46.076] - run: TRUE
[17:44:46.077] - result: ‘FutureResult’
[17:44:46.077] resolved() for ‘SequentialFuture’ ... done
[17:44:46.077] Future #1
[17:44:46.077] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.077] - nx: 1
[17:44:46.077] - relay: TRUE
[17:44:46.077] - stdout: TRUE
[17:44:46.077] - signal: TRUE
[17:44:46.077] - resignal: FALSE
[17:44:46.077] - force: TRUE
[17:44:46.077] - relayed: [n=1] FALSE
[17:44:46.078] - queued futures: [n=1] FALSE
[17:44:46.078]  - until=1
[17:44:46.078]  - relaying element #1
[17:44:46.078] - relayed: [n=1] TRUE
[17:44:46.078] - queued futures: [n=1] TRUE
[17:44:46.078] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.078]  length: 0 (resolved future 1)
[17:44:46.078] Relaying remaining futures
[17:44:46.078] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.079] - nx: 1
[17:44:46.079] - relay: TRUE
[17:44:46.079] - stdout: TRUE
[17:44:46.079] - signal: TRUE
[17:44:46.079] - resignal: FALSE
[17:44:46.079] - force: TRUE
[17:44:46.079] - relayed: [n=1] TRUE
[17:44:46.079] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.079] - relayed: [n=1] TRUE
[17:44:46.079] - queued futures: [n=1] TRUE
[17:44:46.079] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.080] resolve() on list ... DONE
[17:44:46.080]  - Number of value chunks collected: 1
[17:44:46.080] Resolving 1 futures (chunks) ... DONE
[17:44:46.080] Reducing values from 1 chunks ...
[17:44:46.080]  - Number of values collected after concatenation: 2
[17:44:46.080]  - Number of values expected: 2
[17:44:46.080] Reducing values from 1 chunks ... DONE
[17:44:46.080] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:44:46.080] future_mapply() ...
[17:44:46.081] Number of chunks: 1
[17:44:46.081] getGlobalsAndPackagesXApply() ...
[17:44:46.081]  - future.globals: TRUE
[17:44:46.081] getGlobalsAndPackages() ...
[17:44:46.081] Searching for globals...
[17:44:46.082] - globals found: [1] ‘FUN’
[17:44:46.082] Searching for globals ... DONE
[17:44:46.082] Resolving globals: FALSE
[17:44:46.082] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.082] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.082] - globals: [1] ‘FUN’
[17:44:46.083] 
[17:44:46.085] getGlobalsAndPackages() ... DONE
[17:44:46.085]  - globals found/used: [n=1] ‘FUN’
[17:44:46.085]  - needed namespaces: [n=0] 
[17:44:46.085] Finding globals ... DONE
[17:44:46.085] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.085] List of 2
[17:44:46.085]  $ ...future.FUN:function (x, ...)  
[17:44:46.085]  $ MoreArgs     : NULL
[17:44:46.085]  - attr(*, "where")=List of 2
[17:44:46.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.085]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.085]  - attr(*, "resolved")= logi FALSE
[17:44:46.085]  - attr(*, "total_size")= num NA
[17:44:46.088] Packages to be attached in all futures: [n=0] 
[17:44:46.088] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.088] Number of futures (= number of chunks): 1
[17:44:46.088] Launching 1 futures (chunks) ...
[17:44:46.089] Chunk #1 of 1 ...
[17:44:46.089]  - Finding globals in '...' for chunk #1 ...
[17:44:46.089] getGlobalsAndPackages() ...
[17:44:46.089] Searching for globals...
[17:44:46.089] 
[17:44:46.089] Searching for globals ... DONE
[17:44:46.089] - globals: [0] <none>
[17:44:46.089] getGlobalsAndPackages() ... DONE
[17:44:46.090]    + additional globals found: [n=0] 
[17:44:46.090]    + additional namespaces needed: [n=0] 
[17:44:46.090]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.090]  - seeds: <none>
[17:44:46.090]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.090] getGlobalsAndPackages() ...
[17:44:46.090] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.090] Resolving globals: FALSE
[17:44:46.091] The total size of the 5 globals is 504 bytes (504 bytes)
[17:44:46.091] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 504 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (448 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.091] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.091] 
[17:44:46.092] getGlobalsAndPackages() ... DONE
[17:44:46.092] run() for ‘Future’ ...
[17:44:46.092] - state: ‘created’
[17:44:46.092] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.092] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.093]   - Field: ‘label’
[17:44:46.093]   - Field: ‘local’
[17:44:46.093]   - Field: ‘owner’
[17:44:46.093]   - Field: ‘envir’
[17:44:46.093]   - Field: ‘packages’
[17:44:46.093]   - Field: ‘gc’
[17:44:46.093]   - Field: ‘conditions’
[17:44:46.093]   - Field: ‘expr’
[17:44:46.093]   - Field: ‘uuid’
[17:44:46.093]   - Field: ‘seed’
[17:44:46.093]   - Field: ‘version’
[17:44:46.094]   - Field: ‘result’
[17:44:46.094]   - Field: ‘asynchronous’
[17:44:46.094]   - Field: ‘calls’
[17:44:46.094]   - Field: ‘globals’
[17:44:46.094]   - Field: ‘stdout’
[17:44:46.094]   - Field: ‘earlySignal’
[17:44:46.094]   - Field: ‘lazy’
[17:44:46.094]   - Field: ‘state’
[17:44:46.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.094] - Launch lazy future ...
[17:44:46.095] Packages needed by the future expression (n = 0): <none>
[17:44:46.095] Packages needed by future strategies (n = 0): <none>
[17:44:46.095] {
[17:44:46.095]     {
[17:44:46.095]         {
[17:44:46.095]             ...future.startTime <- base::Sys.time()
[17:44:46.095]             {
[17:44:46.095]                 {
[17:44:46.095]                   {
[17:44:46.095]                     base::local({
[17:44:46.095]                       has_future <- base::requireNamespace("future", 
[17:44:46.095]                         quietly = TRUE)
[17:44:46.095]                       if (has_future) {
[17:44:46.095]                         ns <- base::getNamespace("future")
[17:44:46.095]                         version <- ns[[".package"]][["version"]]
[17:44:46.095]                         if (is.null(version)) 
[17:44:46.095]                           version <- utils::packageVersion("future")
[17:44:46.095]                       }
[17:44:46.095]                       else {
[17:44:46.095]                         version <- NULL
[17:44:46.095]                       }
[17:44:46.095]                       if (!has_future || version < "1.8.0") {
[17:44:46.095]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.095]                           "", base::R.version$version.string), 
[17:44:46.095]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.095]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.095]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.095]                             "release", "version")], collapse = " "), 
[17:44:46.095]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.095]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.095]                           info)
[17:44:46.095]                         info <- base::paste(info, collapse = "; ")
[17:44:46.095]                         if (!has_future) {
[17:44:46.095]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.095]                             info)
[17:44:46.095]                         }
[17:44:46.095]                         else {
[17:44:46.095]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.095]                             info, version)
[17:44:46.095]                         }
[17:44:46.095]                         base::stop(msg)
[17:44:46.095]                       }
[17:44:46.095]                     })
[17:44:46.095]                   }
[17:44:46.095]                   ...future.strategy.old <- future::plan("list")
[17:44:46.095]                   options(future.plan = NULL)
[17:44:46.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.095]                 }
[17:44:46.095]                 ...future.workdir <- getwd()
[17:44:46.095]             }
[17:44:46.095]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.095]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.095]         }
[17:44:46.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.095]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.095]             base::names(...future.oldOptions))
[17:44:46.095]     }
[17:44:46.095]     if (FALSE) {
[17:44:46.095]     }
[17:44:46.095]     else {
[17:44:46.095]         if (TRUE) {
[17:44:46.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.095]                 open = "w")
[17:44:46.095]         }
[17:44:46.095]         else {
[17:44:46.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.095]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.095]         }
[17:44:46.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.095]             base::sink(type = "output", split = FALSE)
[17:44:46.095]             base::close(...future.stdout)
[17:44:46.095]         }, add = TRUE)
[17:44:46.095]     }
[17:44:46.095]     ...future.frame <- base::sys.nframe()
[17:44:46.095]     ...future.conditions <- base::list()
[17:44:46.095]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.095]     if (FALSE) {
[17:44:46.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.095]     }
[17:44:46.095]     ...future.result <- base::tryCatch({
[17:44:46.095]         base::withCallingHandlers({
[17:44:46.095]             ...future.value <- base::withVisible(base::local({
[17:44:46.095]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.095]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.095]                   ...future.globals.maxSize)) {
[17:44:46.095]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.095]                   on.exit(options(oopts), add = TRUE)
[17:44:46.095]                 }
[17:44:46.095]                 {
[17:44:46.095]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.095]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.095]                     USE.NAMES = FALSE)
[17:44:46.095]                   do.call(mapply, args = args)
[17:44:46.095]                 }
[17:44:46.095]             }))
[17:44:46.095]             future::FutureResult(value = ...future.value$value, 
[17:44:46.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.095]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.095]                     ...future.globalenv.names))
[17:44:46.095]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.095]         }, condition = base::local({
[17:44:46.095]             c <- base::c
[17:44:46.095]             inherits <- base::inherits
[17:44:46.095]             invokeRestart <- base::invokeRestart
[17:44:46.095]             length <- base::length
[17:44:46.095]             list <- base::list
[17:44:46.095]             seq.int <- base::seq.int
[17:44:46.095]             signalCondition <- base::signalCondition
[17:44:46.095]             sys.calls <- base::sys.calls
[17:44:46.095]             `[[` <- base::`[[`
[17:44:46.095]             `+` <- base::`+`
[17:44:46.095]             `<<-` <- base::`<<-`
[17:44:46.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.095]                   3L)]
[17:44:46.095]             }
[17:44:46.095]             function(cond) {
[17:44:46.095]                 is_error <- inherits(cond, "error")
[17:44:46.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.095]                   NULL)
[17:44:46.095]                 if (is_error) {
[17:44:46.095]                   sessionInformation <- function() {
[17:44:46.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.095]                       search = base::search(), system = base::Sys.info())
[17:44:46.095]                   }
[17:44:46.095]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.095]                     cond$call), session = sessionInformation(), 
[17:44:46.095]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.095]                   signalCondition(cond)
[17:44:46.095]                 }
[17:44:46.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.095]                 "immediateCondition"))) {
[17:44:46.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.095]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.095]                   if (TRUE && !signal) {
[17:44:46.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.095]                     {
[17:44:46.095]                       inherits <- base::inherits
[17:44:46.095]                       invokeRestart <- base::invokeRestart
[17:44:46.095]                       is.null <- base::is.null
[17:44:46.095]                       muffled <- FALSE
[17:44:46.095]                       if (inherits(cond, "message")) {
[17:44:46.095]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.095]                         if (muffled) 
[17:44:46.095]                           invokeRestart("muffleMessage")
[17:44:46.095]                       }
[17:44:46.095]                       else if (inherits(cond, "warning")) {
[17:44:46.095]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.095]                         if (muffled) 
[17:44:46.095]                           invokeRestart("muffleWarning")
[17:44:46.095]                       }
[17:44:46.095]                       else if (inherits(cond, "condition")) {
[17:44:46.095]                         if (!is.null(pattern)) {
[17:44:46.095]                           computeRestarts <- base::computeRestarts
[17:44:46.095]                           grepl <- base::grepl
[17:44:46.095]                           restarts <- computeRestarts(cond)
[17:44:46.095]                           for (restart in restarts) {
[17:44:46.095]                             name <- restart$name
[17:44:46.095]                             if (is.null(name)) 
[17:44:46.095]                               next
[17:44:46.095]                             if (!grepl(pattern, name)) 
[17:44:46.095]                               next
[17:44:46.095]                             invokeRestart(restart)
[17:44:46.095]                             muffled <- TRUE
[17:44:46.095]                             break
[17:44:46.095]                           }
[17:44:46.095]                         }
[17:44:46.095]                       }
[17:44:46.095]                       invisible(muffled)
[17:44:46.095]                     }
[17:44:46.095]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.095]                   }
[17:44:46.095]                 }
[17:44:46.095]                 else {
[17:44:46.095]                   if (TRUE) {
[17:44:46.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.095]                     {
[17:44:46.095]                       inherits <- base::inherits
[17:44:46.095]                       invokeRestart <- base::invokeRestart
[17:44:46.095]                       is.null <- base::is.null
[17:44:46.095]                       muffled <- FALSE
[17:44:46.095]                       if (inherits(cond, "message")) {
[17:44:46.095]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.095]                         if (muffled) 
[17:44:46.095]                           invokeRestart("muffleMessage")
[17:44:46.095]                       }
[17:44:46.095]                       else if (inherits(cond, "warning")) {
[17:44:46.095]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.095]                         if (muffled) 
[17:44:46.095]                           invokeRestart("muffleWarning")
[17:44:46.095]                       }
[17:44:46.095]                       else if (inherits(cond, "condition")) {
[17:44:46.095]                         if (!is.null(pattern)) {
[17:44:46.095]                           computeRestarts <- base::computeRestarts
[17:44:46.095]                           grepl <- base::grepl
[17:44:46.095]                           restarts <- computeRestarts(cond)
[17:44:46.095]                           for (restart in restarts) {
[17:44:46.095]                             name <- restart$name
[17:44:46.095]                             if (is.null(name)) 
[17:44:46.095]                               next
[17:44:46.095]                             if (!grepl(pattern, name)) 
[17:44:46.095]                               next
[17:44:46.095]                             invokeRestart(restart)
[17:44:46.095]                             muffled <- TRUE
[17:44:46.095]                             break
[17:44:46.095]                           }
[17:44:46.095]                         }
[17:44:46.095]                       }
[17:44:46.095]                       invisible(muffled)
[17:44:46.095]                     }
[17:44:46.095]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.095]                   }
[17:44:46.095]                 }
[17:44:46.095]             }
[17:44:46.095]         }))
[17:44:46.095]     }, error = function(ex) {
[17:44:46.095]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.095]                 ...future.rng), started = ...future.startTime, 
[17:44:46.095]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.095]             version = "1.8"), class = "FutureResult")
[17:44:46.095]     }, finally = {
[17:44:46.095]         if (!identical(...future.workdir, getwd())) 
[17:44:46.095]             setwd(...future.workdir)
[17:44:46.095]         {
[17:44:46.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.095]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.095]             }
[17:44:46.095]             base::options(...future.oldOptions)
[17:44:46.095]             if (.Platform$OS.type == "windows") {
[17:44:46.095]                 old_names <- names(...future.oldEnvVars)
[17:44:46.095]                 envs <- base::Sys.getenv()
[17:44:46.095]                 names <- names(envs)
[17:44:46.095]                 common <- intersect(names, old_names)
[17:44:46.095]                 added <- setdiff(names, old_names)
[17:44:46.095]                 removed <- setdiff(old_names, names)
[17:44:46.095]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.095]                   envs[common]]
[17:44:46.095]                 NAMES <- toupper(changed)
[17:44:46.095]                 args <- list()
[17:44:46.095]                 for (kk in seq_along(NAMES)) {
[17:44:46.095]                   name <- changed[[kk]]
[17:44:46.095]                   NAME <- NAMES[[kk]]
[17:44:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.095]                     next
[17:44:46.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.095]                 }
[17:44:46.095]                 NAMES <- toupper(added)
[17:44:46.095]                 for (kk in seq_along(NAMES)) {
[17:44:46.095]                   name <- added[[kk]]
[17:44:46.095]                   NAME <- NAMES[[kk]]
[17:44:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.095]                     next
[17:44:46.095]                   args[[name]] <- ""
[17:44:46.095]                 }
[17:44:46.095]                 NAMES <- toupper(removed)
[17:44:46.095]                 for (kk in seq_along(NAMES)) {
[17:44:46.095]                   name <- removed[[kk]]
[17:44:46.095]                   NAME <- NAMES[[kk]]
[17:44:46.095]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.095]                     next
[17:44:46.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.095]                 }
[17:44:46.095]                 if (length(args) > 0) 
[17:44:46.095]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.095]             }
[17:44:46.095]             else {
[17:44:46.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.095]             }
[17:44:46.095]             {
[17:44:46.095]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.095]                   0L) {
[17:44:46.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.095]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.095]                   base::options(opts)
[17:44:46.095]                 }
[17:44:46.095]                 {
[17:44:46.095]                   {
[17:44:46.095]                     base::assign(".Random.seed", c(10407L, -28481907L, 
[17:44:46.095]                     1349820217L, 692505723L, -484569582L, -442277067L, 
[17:44:46.095]                     964225693L), envir = base::globalenv(), inherits = FALSE)
[17:44:46.095]                     NULL
[17:44:46.095]                   }
[17:44:46.095]                   options(future.plan = NULL)
[17:44:46.095]                   if (is.na(NA_character_)) 
[17:44:46.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.095]                     .init = FALSE)
[17:44:46.095]                 }
[17:44:46.095]             }
[17:44:46.095]         }
[17:44:46.095]     })
[17:44:46.095]     if (TRUE) {
[17:44:46.095]         base::sink(type = "output", split = FALSE)
[17:44:46.095]         if (TRUE) {
[17:44:46.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.095]         }
[17:44:46.095]         else {
[17:44:46.095]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.095]         }
[17:44:46.095]         base::close(...future.stdout)
[17:44:46.095]         ...future.stdout <- NULL
[17:44:46.095]     }
[17:44:46.095]     ...future.result$conditions <- ...future.conditions
[17:44:46.095]     ...future.result$finished <- base::Sys.time()
[17:44:46.095]     ...future.result
[17:44:46.095] }
[17:44:46.097] assign_globals() ...
[17:44:46.097] List of 5
[17:44:46.097]  $ ...future.FUN            :function (x, ...)  
[17:44:46.097]  $ MoreArgs                 : NULL
[17:44:46.097]  $ ...future.elements_ii    :List of 2
[17:44:46.097]   ..$ :List of 4
[17:44:46.097]   .. ..$ : int 1
[17:44:46.097]   .. ..$ : int 2
[17:44:46.097]   .. ..$ : int 3
[17:44:46.097]   .. ..$ : int 4
[17:44:46.097]   ..$ :List of 4
[17:44:46.097]   .. ..$ : int 2
[17:44:46.097]   .. ..$ : int 1
[17:44:46.097]   .. ..$ : int 2
[17:44:46.097]   .. ..$ : int 1
[17:44:46.097]  $ ...future.seeds_ii       : NULL
[17:44:46.097]  $ ...future.globals.maxSize: NULL
[17:44:46.097]  - attr(*, "where")=List of 5
[17:44:46.097]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.097]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.097]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.097]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.097]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.097]  - attr(*, "resolved")= logi FALSE
[17:44:46.097]  - attr(*, "total_size")= num 504
[17:44:46.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.097]  - attr(*, "already-done")= logi TRUE
[17:44:46.104] - copied ‘...future.FUN’ to environment
[17:44:46.104] - copied ‘MoreArgs’ to environment
[17:44:46.104] - copied ‘...future.elements_ii’ to environment
[17:44:46.104] - copied ‘...future.seeds_ii’ to environment
[17:44:46.104] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.104] assign_globals() ... done
[17:44:46.104] plan(): Setting new future strategy stack:
[17:44:46.104] List of future strategies:
[17:44:46.104] 1. sequential:
[17:44:46.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.104]    - tweaked: FALSE
[17:44:46.104]    - call: NULL
[17:44:46.105] plan(): nbrOfWorkers() = 1
[17:44:46.106] plan(): Setting new future strategy stack:
[17:44:46.106] List of future strategies:
[17:44:46.106] 1. sequential:
[17:44:46.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.106]    - tweaked: FALSE
[17:44:46.106]    - call: plan(strategy)
[17:44:46.106] plan(): nbrOfWorkers() = 1
[17:44:46.106] SequentialFuture started (and completed)
[17:44:46.106] - Launch lazy future ... done
[17:44:46.107] run() for ‘SequentialFuture’ ... done
[17:44:46.107] Created future:
[17:44:46.107] SequentialFuture:
[17:44:46.107] Label: ‘future_mapply-1’
[17:44:46.107] Expression:
[17:44:46.107] {
[17:44:46.107]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.107]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.107]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.107]         on.exit(options(oopts), add = TRUE)
[17:44:46.107]     }
[17:44:46.107]     {
[17:44:46.107]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.107]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.107]         do.call(mapply, args = args)
[17:44:46.107]     }
[17:44:46.107] }
[17:44:46.107] Lazy evaluation: FALSE
[17:44:46.107] Asynchronous evaluation: FALSE
[17:44:46.107] Local evaluation: TRUE
[17:44:46.107] Environment: R_GlobalEnv
[17:44:46.107] Capture standard output: TRUE
[17:44:46.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.107] Globals: 5 objects totaling 504 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 448 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.107] Packages: <none>
[17:44:46.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.107] Resolved: TRUE
[17:44:46.107] Value: 224 bytes of class ‘list’
[17:44:46.107] Early signaling: FALSE
[17:44:46.107] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.107] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.110] Chunk #1 of 1 ... DONE
[17:44:46.110] Launching 1 futures (chunks) ... DONE
[17:44:46.110] Resolving 1 futures (chunks) ...
[17:44:46.110] resolve() on list ...
[17:44:46.110]  recursive: 0
[17:44:46.110]  length: 1
[17:44:46.110] 
[17:44:46.110] resolved() for ‘SequentialFuture’ ...
[17:44:46.110] - state: ‘finished’
[17:44:46.111] - run: TRUE
[17:44:46.111] - result: ‘FutureResult’
[17:44:46.111] resolved() for ‘SequentialFuture’ ... done
[17:44:46.111] Future #1
[17:44:46.111] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.111] - nx: 1
[17:44:46.111] - relay: TRUE
[17:44:46.111] - stdout: TRUE
[17:44:46.112] - signal: TRUE
[17:44:46.112] - resignal: FALSE
[17:44:46.112] - force: TRUE
[17:44:46.112] - relayed: [n=1] FALSE
[17:44:46.112] - queued futures: [n=1] FALSE
[17:44:46.112]  - until=1
[17:44:46.112]  - relaying element #1
[17:44:46.112] - relayed: [n=1] TRUE
[17:44:46.112] - queued futures: [n=1] TRUE
[17:44:46.112] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.113]  length: 0 (resolved future 1)
[17:44:46.113] Relaying remaining futures
[17:44:46.113] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.113] - nx: 1
[17:44:46.113] - relay: TRUE
[17:44:46.113] - stdout: TRUE
[17:44:46.113] - signal: TRUE
[17:44:46.113] - resignal: FALSE
[17:44:46.113] - force: TRUE
[17:44:46.113] - relayed: [n=1] TRUE
[17:44:46.113] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.114] - relayed: [n=1] TRUE
[17:44:46.114] - queued futures: [n=1] TRUE
[17:44:46.114] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.114] resolve() on list ... DONE
[17:44:46.114]  - Number of value chunks collected: 1
[17:44:46.114] Resolving 1 futures (chunks) ... DONE
[17:44:46.114] Reducing values from 1 chunks ...
[17:44:46.114]  - Number of values collected after concatenation: 4
[17:44:46.114]  - Number of values expected: 4
[17:44:46.114] Reducing values from 1 chunks ... DONE
[17:44:46.115] future_mapply() ... DONE
- Parallel RNG ...
[17:44:46.115] future_mapply() ...
[17:44:46.115] Generating random seeds ...
[17:44:46.115] Generating random seed streams for 4 elements ...
[17:44:46.115] Generating random seed streams for 4 elements ... DONE
[17:44:46.115] Generating random seeds ... DONE
[17:44:46.115] Will set RNG state on exit: 10407, 692505723, -1169343096, 865207733, 964225693, 919427386, -1211317129
[17:44:46.115] Number of chunks: 1
[17:44:46.115] getGlobalsAndPackagesXApply() ...
[17:44:46.116]  - future.globals: TRUE
[17:44:46.116] getGlobalsAndPackages() ...
[17:44:46.116] Searching for globals...
[17:44:46.117] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:44:46.117] Searching for globals ... DONE
[17:44:46.117] Resolving globals: FALSE
[17:44:46.118] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:44:46.118] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:44:46.118] - globals: [1] ‘FUN’
[17:44:46.118] - packages: [1] ‘stats’
[17:44:46.118] getGlobalsAndPackages() ... DONE
[17:44:46.118]  - globals found/used: [n=1] ‘FUN’
[17:44:46.119]  - needed namespaces: [n=1] ‘stats’
[17:44:46.119] Finding globals ... DONE
[17:44:46.119] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.119] List of 2
[17:44:46.119]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:44:46.119]  $ MoreArgs     :List of 1
[17:44:46.119]   ..$ min: num 1
[17:44:46.119]  - attr(*, "where")=List of 2
[17:44:46.119]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.119]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.119]  - attr(*, "resolved")= logi FALSE
[17:44:46.119]  - attr(*, "total_size")= num NA
[17:44:46.122] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:46.122] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.122] Number of futures (= number of chunks): 1
[17:44:46.122] Launching 1 futures (chunks) ...
[17:44:46.122] Chunk #1 of 1 ...
[17:44:46.122]  - Finding globals in '...' for chunk #1 ...
[17:44:46.122] getGlobalsAndPackages() ...
[17:44:46.123] Searching for globals...
[17:44:46.123] 
[17:44:46.123] Searching for globals ... DONE
[17:44:46.123] - globals: [0] <none>
[17:44:46.123] getGlobalsAndPackages() ... DONE
[17:44:46.123]    + additional globals found: [n=0] 
[17:44:46.123]    + additional namespaces needed: [n=0] 
[17:44:46.123]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.123]  - seeds: [4] <seeds>
[17:44:46.124]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.124] getGlobalsAndPackages() ...
[17:44:46.124] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.124] Resolving globals: FALSE
[17:44:46.124] The total size of the 5 globals is 2.84 KiB (2912 bytes)
[17:44:46.125] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (448 bytes of class ‘list’) and ‘...future.seeds_ii’ (320 bytes of class ‘list’)
[17:44:46.125] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.125] - packages: [1] ‘stats’
[17:44:46.125] getGlobalsAndPackages() ... DONE
[17:44:46.125] run() for ‘Future’ ...
[17:44:46.126] - state: ‘created’
[17:44:46.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.126]   - Field: ‘label’
[17:44:46.126]   - Field: ‘local’
[17:44:46.126]   - Field: ‘owner’
[17:44:46.127]   - Field: ‘envir’
[17:44:46.127]   - Field: ‘packages’
[17:44:46.127]   - Field: ‘gc’
[17:44:46.127]   - Field: ‘conditions’
[17:44:46.127]   - Field: ‘expr’
[17:44:46.127]   - Field: ‘uuid’
[17:44:46.127]   - Field: ‘seed’
[17:44:46.127]   - Field: ‘version’
[17:44:46.127]   - Field: ‘result’
[17:44:46.127]   - Field: ‘asynchronous’
[17:44:46.127]   - Field: ‘calls’
[17:44:46.128]   - Field: ‘globals’
[17:44:46.128]   - Field: ‘stdout’
[17:44:46.128]   - Field: ‘earlySignal’
[17:44:46.128]   - Field: ‘lazy’
[17:44:46.128]   - Field: ‘state’
[17:44:46.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.128] - Launch lazy future ...
[17:44:46.128] Packages needed by the future expression (n = 1): ‘stats’
[17:44:46.128] Packages needed by future strategies (n = 0): <none>
[17:44:46.129] {
[17:44:46.129]     {
[17:44:46.129]         {
[17:44:46.129]             ...future.startTime <- base::Sys.time()
[17:44:46.129]             {
[17:44:46.129]                 {
[17:44:46.129]                   {
[17:44:46.129]                     {
[17:44:46.129]                       base::local({
[17:44:46.129]                         has_future <- base::requireNamespace("future", 
[17:44:46.129]                           quietly = TRUE)
[17:44:46.129]                         if (has_future) {
[17:44:46.129]                           ns <- base::getNamespace("future")
[17:44:46.129]                           version <- ns[[".package"]][["version"]]
[17:44:46.129]                           if (is.null(version)) 
[17:44:46.129]                             version <- utils::packageVersion("future")
[17:44:46.129]                         }
[17:44:46.129]                         else {
[17:44:46.129]                           version <- NULL
[17:44:46.129]                         }
[17:44:46.129]                         if (!has_future || version < "1.8.0") {
[17:44:46.129]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.129]                             "", base::R.version$version.string), 
[17:44:46.129]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.129]                               "release", "version")], collapse = " "), 
[17:44:46.129]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.129]                             info)
[17:44:46.129]                           info <- base::paste(info, collapse = "; ")
[17:44:46.129]                           if (!has_future) {
[17:44:46.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.129]                               info)
[17:44:46.129]                           }
[17:44:46.129]                           else {
[17:44:46.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.129]                               info, version)
[17:44:46.129]                           }
[17:44:46.129]                           base::stop(msg)
[17:44:46.129]                         }
[17:44:46.129]                       })
[17:44:46.129]                     }
[17:44:46.129]                     base::local({
[17:44:46.129]                       for (pkg in "stats") {
[17:44:46.129]                         base::loadNamespace(pkg)
[17:44:46.129]                         base::library(pkg, character.only = TRUE)
[17:44:46.129]                       }
[17:44:46.129]                     })
[17:44:46.129]                   }
[17:44:46.129]                   ...future.strategy.old <- future::plan("list")
[17:44:46.129]                   options(future.plan = NULL)
[17:44:46.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.129]                 }
[17:44:46.129]                 ...future.workdir <- getwd()
[17:44:46.129]             }
[17:44:46.129]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.129]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.129]         }
[17:44:46.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.129]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.129]             base::names(...future.oldOptions))
[17:44:46.129]     }
[17:44:46.129]     if (FALSE) {
[17:44:46.129]     }
[17:44:46.129]     else {
[17:44:46.129]         if (TRUE) {
[17:44:46.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.129]                 open = "w")
[17:44:46.129]         }
[17:44:46.129]         else {
[17:44:46.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.129]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.129]         }
[17:44:46.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.129]             base::sink(type = "output", split = FALSE)
[17:44:46.129]             base::close(...future.stdout)
[17:44:46.129]         }, add = TRUE)
[17:44:46.129]     }
[17:44:46.129]     ...future.frame <- base::sys.nframe()
[17:44:46.129]     ...future.conditions <- base::list()
[17:44:46.129]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.129]     if (FALSE) {
[17:44:46.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.129]     }
[17:44:46.129]     ...future.result <- base::tryCatch({
[17:44:46.129]         base::withCallingHandlers({
[17:44:46.129]             ...future.value <- base::withVisible(base::local({
[17:44:46.129]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.129]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.129]                   ...future.globals.maxSize)) {
[17:44:46.129]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.129]                   on.exit(options(oopts), add = TRUE)
[17:44:46.129]                 }
[17:44:46.129]                 {
[17:44:46.129]                   ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:46.129]                     assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:46.129]                       envir = globalenv(), inherits = FALSE)
[17:44:46.129]                     ...future.FUN(...)
[17:44:46.129]                   }
[17:44:46.129]                   args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:46.129]                     list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:46.129]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.129]                     USE.NAMES = FALSE)
[17:44:46.129]                   do.call(mapply, args = args)
[17:44:46.129]                 }
[17:44:46.129]             }))
[17:44:46.129]             future::FutureResult(value = ...future.value$value, 
[17:44:46.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.129]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.129]                     ...future.globalenv.names))
[17:44:46.129]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.129]         }, condition = base::local({
[17:44:46.129]             c <- base::c
[17:44:46.129]             inherits <- base::inherits
[17:44:46.129]             invokeRestart <- base::invokeRestart
[17:44:46.129]             length <- base::length
[17:44:46.129]             list <- base::list
[17:44:46.129]             seq.int <- base::seq.int
[17:44:46.129]             signalCondition <- base::signalCondition
[17:44:46.129]             sys.calls <- base::sys.calls
[17:44:46.129]             `[[` <- base::`[[`
[17:44:46.129]             `+` <- base::`+`
[17:44:46.129]             `<<-` <- base::`<<-`
[17:44:46.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.129]                   3L)]
[17:44:46.129]             }
[17:44:46.129]             function(cond) {
[17:44:46.129]                 is_error <- inherits(cond, "error")
[17:44:46.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.129]                   NULL)
[17:44:46.129]                 if (is_error) {
[17:44:46.129]                   sessionInformation <- function() {
[17:44:46.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.129]                       search = base::search(), system = base::Sys.info())
[17:44:46.129]                   }
[17:44:46.129]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.129]                     cond$call), session = sessionInformation(), 
[17:44:46.129]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.129]                   signalCondition(cond)
[17:44:46.129]                 }
[17:44:46.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.129]                 "immediateCondition"))) {
[17:44:46.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.129]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.129]                   if (TRUE && !signal) {
[17:44:46.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.129]                     {
[17:44:46.129]                       inherits <- base::inherits
[17:44:46.129]                       invokeRestart <- base::invokeRestart
[17:44:46.129]                       is.null <- base::is.null
[17:44:46.129]                       muffled <- FALSE
[17:44:46.129]                       if (inherits(cond, "message")) {
[17:44:46.129]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.129]                         if (muffled) 
[17:44:46.129]                           invokeRestart("muffleMessage")
[17:44:46.129]                       }
[17:44:46.129]                       else if (inherits(cond, "warning")) {
[17:44:46.129]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.129]                         if (muffled) 
[17:44:46.129]                           invokeRestart("muffleWarning")
[17:44:46.129]                       }
[17:44:46.129]                       else if (inherits(cond, "condition")) {
[17:44:46.129]                         if (!is.null(pattern)) {
[17:44:46.129]                           computeRestarts <- base::computeRestarts
[17:44:46.129]                           grepl <- base::grepl
[17:44:46.129]                           restarts <- computeRestarts(cond)
[17:44:46.129]                           for (restart in restarts) {
[17:44:46.129]                             name <- restart$name
[17:44:46.129]                             if (is.null(name)) 
[17:44:46.129]                               next
[17:44:46.129]                             if (!grepl(pattern, name)) 
[17:44:46.129]                               next
[17:44:46.129]                             invokeRestart(restart)
[17:44:46.129]                             muffled <- TRUE
[17:44:46.129]                             break
[17:44:46.129]                           }
[17:44:46.129]                         }
[17:44:46.129]                       }
[17:44:46.129]                       invisible(muffled)
[17:44:46.129]                     }
[17:44:46.129]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.129]                   }
[17:44:46.129]                 }
[17:44:46.129]                 else {
[17:44:46.129]                   if (TRUE) {
[17:44:46.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.129]                     {
[17:44:46.129]                       inherits <- base::inherits
[17:44:46.129]                       invokeRestart <- base::invokeRestart
[17:44:46.129]                       is.null <- base::is.null
[17:44:46.129]                       muffled <- FALSE
[17:44:46.129]                       if (inherits(cond, "message")) {
[17:44:46.129]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.129]                         if (muffled) 
[17:44:46.129]                           invokeRestart("muffleMessage")
[17:44:46.129]                       }
[17:44:46.129]                       else if (inherits(cond, "warning")) {
[17:44:46.129]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.129]                         if (muffled) 
[17:44:46.129]                           invokeRestart("muffleWarning")
[17:44:46.129]                       }
[17:44:46.129]                       else if (inherits(cond, "condition")) {
[17:44:46.129]                         if (!is.null(pattern)) {
[17:44:46.129]                           computeRestarts <- base::computeRestarts
[17:44:46.129]                           grepl <- base::grepl
[17:44:46.129]                           restarts <- computeRestarts(cond)
[17:44:46.129]                           for (restart in restarts) {
[17:44:46.129]                             name <- restart$name
[17:44:46.129]                             if (is.null(name)) 
[17:44:46.129]                               next
[17:44:46.129]                             if (!grepl(pattern, name)) 
[17:44:46.129]                               next
[17:44:46.129]                             invokeRestart(restart)
[17:44:46.129]                             muffled <- TRUE
[17:44:46.129]                             break
[17:44:46.129]                           }
[17:44:46.129]                         }
[17:44:46.129]                       }
[17:44:46.129]                       invisible(muffled)
[17:44:46.129]                     }
[17:44:46.129]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.129]                   }
[17:44:46.129]                 }
[17:44:46.129]             }
[17:44:46.129]         }))
[17:44:46.129]     }, error = function(ex) {
[17:44:46.129]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.129]                 ...future.rng), started = ...future.startTime, 
[17:44:46.129]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.129]             version = "1.8"), class = "FutureResult")
[17:44:46.129]     }, finally = {
[17:44:46.129]         if (!identical(...future.workdir, getwd())) 
[17:44:46.129]             setwd(...future.workdir)
[17:44:46.129]         {
[17:44:46.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.129]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.129]             }
[17:44:46.129]             base::options(...future.oldOptions)
[17:44:46.129]             if (.Platform$OS.type == "windows") {
[17:44:46.129]                 old_names <- names(...future.oldEnvVars)
[17:44:46.129]                 envs <- base::Sys.getenv()
[17:44:46.129]                 names <- names(envs)
[17:44:46.129]                 common <- intersect(names, old_names)
[17:44:46.129]                 added <- setdiff(names, old_names)
[17:44:46.129]                 removed <- setdiff(old_names, names)
[17:44:46.129]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.129]                   envs[common]]
[17:44:46.129]                 NAMES <- toupper(changed)
[17:44:46.129]                 args <- list()
[17:44:46.129]                 for (kk in seq_along(NAMES)) {
[17:44:46.129]                   name <- changed[[kk]]
[17:44:46.129]                   NAME <- NAMES[[kk]]
[17:44:46.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.129]                     next
[17:44:46.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.129]                 }
[17:44:46.129]                 NAMES <- toupper(added)
[17:44:46.129]                 for (kk in seq_along(NAMES)) {
[17:44:46.129]                   name <- added[[kk]]
[17:44:46.129]                   NAME <- NAMES[[kk]]
[17:44:46.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.129]                     next
[17:44:46.129]                   args[[name]] <- ""
[17:44:46.129]                 }
[17:44:46.129]                 NAMES <- toupper(removed)
[17:44:46.129]                 for (kk in seq_along(NAMES)) {
[17:44:46.129]                   name <- removed[[kk]]
[17:44:46.129]                   NAME <- NAMES[[kk]]
[17:44:46.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.129]                     next
[17:44:46.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.129]                 }
[17:44:46.129]                 if (length(args) > 0) 
[17:44:46.129]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.129]             }
[17:44:46.129]             else {
[17:44:46.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.129]             }
[17:44:46.129]             {
[17:44:46.129]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.129]                   0L) {
[17:44:46.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.129]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.129]                   base::options(opts)
[17:44:46.129]                 }
[17:44:46.129]                 {
[17:44:46.129]                   {
[17:44:46.129]                     base::assign(".Random.seed", c(10407L, 692505723L, 
[17:44:46.129]                     -1169343096L, 865207733L, 964225693L, 919427386L, 
[17:44:46.129]                     -1211317129L), envir = base::globalenv(), 
[17:44:46.129]                       inherits = FALSE)
[17:44:46.129]                     NULL
[17:44:46.129]                   }
[17:44:46.129]                   options(future.plan = NULL)
[17:44:46.129]                   if (is.na(NA_character_)) 
[17:44:46.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.129]                     .init = FALSE)
[17:44:46.129]                 }
[17:44:46.129]             }
[17:44:46.129]         }
[17:44:46.129]     })
[17:44:46.129]     if (TRUE) {
[17:44:46.129]         base::sink(type = "output", split = FALSE)
[17:44:46.129]         if (TRUE) {
[17:44:46.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.129]         }
[17:44:46.129]         else {
[17:44:46.129]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.129]         }
[17:44:46.129]         base::close(...future.stdout)
[17:44:46.129]         ...future.stdout <- NULL
[17:44:46.129]     }
[17:44:46.129]     ...future.result$conditions <- ...future.conditions
[17:44:46.129]     ...future.result$finished <- base::Sys.time()
[17:44:46.129]     ...future.result
[17:44:46.129] }
[17:44:46.131] assign_globals() ...
[17:44:46.131] List of 5
[17:44:46.131]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:44:46.131]  $ MoreArgs                 :List of 1
[17:44:46.131]   ..$ min: num 1
[17:44:46.131]  $ ...future.elements_ii    :List of 2
[17:44:46.131]   ..$ n  :List of 4
[17:44:46.131]   .. ..$ : int 1
[17:44:46.131]   .. ..$ : int 2
[17:44:46.131]   .. ..$ : int 3
[17:44:46.131]   .. ..$ : int 4
[17:44:46.131]   ..$ max:List of 4
[17:44:46.131]   .. ..$ : int 2
[17:44:46.131]   .. ..$ : int 3
[17:44:46.131]   .. ..$ : int 4
[17:44:46.131]   .. ..$ : int 5
[17:44:46.131]  $ ...future.seeds_ii       :List of 4
[17:44:46.131]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:44:46.131]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:44:46.131]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:44:46.131]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:44:46.131]  $ ...future.globals.maxSize: NULL
[17:44:46.131]  - attr(*, "where")=List of 5
[17:44:46.131]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.131]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.131]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.131]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.131]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.131]  - attr(*, "resolved")= logi FALSE
[17:44:46.131]  - attr(*, "total_size")= num 2912
[17:44:46.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.131]  - attr(*, "already-done")= logi TRUE
[17:44:46.141] - copied ‘...future.FUN’ to environment
[17:44:46.141] - copied ‘MoreArgs’ to environment
[17:44:46.141] - copied ‘...future.elements_ii’ to environment
[17:44:46.141] - copied ‘...future.seeds_ii’ to environment
[17:44:46.141] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.142] assign_globals() ... done
[17:44:46.142] plan(): Setting new future strategy stack:
[17:44:46.142] List of future strategies:
[17:44:46.142] 1. sequential:
[17:44:46.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.142]    - tweaked: FALSE
[17:44:46.142]    - call: NULL
[17:44:46.142] plan(): nbrOfWorkers() = 1
[17:44:46.143] plan(): Setting new future strategy stack:
[17:44:46.143] List of future strategies:
[17:44:46.143] 1. sequential:
[17:44:46.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.143]    - tweaked: FALSE
[17:44:46.143]    - call: plan(strategy)
[17:44:46.144] plan(): nbrOfWorkers() = 1
[17:44:46.144] SequentialFuture started (and completed)
[17:44:46.144] - Launch lazy future ... done
[17:44:46.144] run() for ‘SequentialFuture’ ... done
[17:44:46.144] Created future:
[17:44:46.144] SequentialFuture:
[17:44:46.144] Label: ‘future_mapply-1’
[17:44:46.144] Expression:
[17:44:46.144] {
[17:44:46.144]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.144]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.144]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.144]         on.exit(options(oopts), add = TRUE)
[17:44:46.144]     }
[17:44:46.144]     {
[17:44:46.144]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:46.144]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:46.144]                 inherits = FALSE)
[17:44:46.144]             ...future.FUN(...)
[17:44:46.144]         }
[17:44:46.144]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:46.144]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:46.144]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.144]         do.call(mapply, args = args)
[17:44:46.144]     }
[17:44:46.144] }
[17:44:46.144] Lazy evaluation: FALSE
[17:44:46.144] Asynchronous evaluation: FALSE
[17:44:46.144] Local evaluation: TRUE
[17:44:46.144] Environment: R_GlobalEnv
[17:44:46.144] Capture standard output: TRUE
[17:44:46.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.144] Globals: 5 objects totaling 2.84 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 448 bytes, list ‘...future.seeds_ii’ of 320 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.144] Packages: 1 packages (‘stats’)
[17:44:46.144] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:46.144] Resolved: TRUE
[17:44:46.144] Value: 280 bytes of class ‘list’
[17:44:46.144] Early signaling: FALSE
[17:44:46.144] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.144] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.145] Chunk #1 of 1 ... DONE
[17:44:46.145] Launching 1 futures (chunks) ... DONE
[17:44:46.145] Resolving 1 futures (chunks) ...
[17:44:46.146] resolve() on list ...
[17:44:46.146]  recursive: 0
[17:44:46.146]  length: 1
[17:44:46.146] 
[17:44:46.146] resolved() for ‘SequentialFuture’ ...
[17:44:46.146] - state: ‘finished’
[17:44:46.146] - run: TRUE
[17:44:46.146] - result: ‘FutureResult’
[17:44:46.146] resolved() for ‘SequentialFuture’ ... done
[17:44:46.146] Future #1
[17:44:46.146] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.147] - nx: 1
[17:44:46.147] - relay: TRUE
[17:44:46.147] - stdout: TRUE
[17:44:46.147] - signal: TRUE
[17:44:46.147] - resignal: FALSE
[17:44:46.147] - force: TRUE
[17:44:46.147] - relayed: [n=1] FALSE
[17:44:46.147] - queued futures: [n=1] FALSE
[17:44:46.147]  - until=1
[17:44:46.147]  - relaying element #1
[17:44:46.148] - relayed: [n=1] TRUE
[17:44:46.148] - queued futures: [n=1] TRUE
[17:44:46.148] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.148]  length: 0 (resolved future 1)
[17:44:46.148] Relaying remaining futures
[17:44:46.148] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.148] - nx: 1
[17:44:46.148] - relay: TRUE
[17:44:46.148] - stdout: TRUE
[17:44:46.148] - signal: TRUE
[17:44:46.148] - resignal: FALSE
[17:44:46.148] - force: TRUE
[17:44:46.149] - relayed: [n=1] TRUE
[17:44:46.149] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.149] - relayed: [n=1] TRUE
[17:44:46.149] - queued futures: [n=1] TRUE
[17:44:46.149] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.149] resolve() on list ... DONE
[17:44:46.149]  - Number of value chunks collected: 1
[17:44:46.149] Resolving 1 futures (chunks) ... DONE
[17:44:46.149] Reducing values from 1 chunks ...
[17:44:46.149]  - Number of values collected after concatenation: 4
[17:44:46.149]  - Number of values expected: 4
[17:44:46.150] Reducing values from 1 chunks ... DONE
[17:44:46.150] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:44:46.152] future_mapply() ...
[17:44:46.152] Number of chunks: 1
[17:44:46.152] getGlobalsAndPackagesXApply() ...
[17:44:46.152]  - future.globals: TRUE
[17:44:46.152] getGlobalsAndPackages() ...
[17:44:46.152] Searching for globals...
[17:44:46.154] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:44:46.154] Searching for globals ... DONE
[17:44:46.154] Resolving globals: FALSE
[17:44:46.154] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:44:46.154] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:44:46.155] - globals: [1] ‘FUN’
[17:44:46.155] - packages: [1] ‘stats’
[17:44:46.155] getGlobalsAndPackages() ... DONE
[17:44:46.157]  - globals found/used: [n=1] ‘FUN’
[17:44:46.157]  - needed namespaces: [n=1] ‘stats’
[17:44:46.157] Finding globals ... DONE
[17:44:46.157] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.157] List of 2
[17:44:46.157]  $ ...future.FUN:function (x, w, ...)  
[17:44:46.157]  $ MoreArgs     : NULL
[17:44:46.157]  - attr(*, "where")=List of 2
[17:44:46.157]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.157]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.157]  - attr(*, "resolved")= logi FALSE
[17:44:46.157]  - attr(*, "total_size")= num NA
[17:44:46.160] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:46.160] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.160] Number of futures (= number of chunks): 1
[17:44:46.160] Launching 1 futures (chunks) ...
[17:44:46.160] Chunk #1 of 1 ...
[17:44:46.160]  - Finding globals in '...' for chunk #1 ...
[17:44:46.160] getGlobalsAndPackages() ...
[17:44:46.161] Searching for globals...
[17:44:46.161] 
[17:44:46.161] Searching for globals ... DONE
[17:44:46.161] - globals: [0] <none>
[17:44:46.161] getGlobalsAndPackages() ... DONE
[17:44:46.161]    + additional globals found: [n=0] 
[17:44:46.161]    + additional namespaces needed: [n=0] 
[17:44:46.161]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.161]  - seeds: <none>
[17:44:46.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.162] getGlobalsAndPackages() ...
[17:44:46.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.162] Resolving globals: FALSE
[17:44:46.162] The total size of the 5 globals is 3.10 KiB (3176 bytes)
[17:44:46.163] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (1.72 KiB of class ‘list’), ‘...future.FUN’ (1.38 KiB of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.163] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.163] - packages: [1] ‘stats’
[17:44:46.163] getGlobalsAndPackages() ... DONE
[17:44:46.164] run() for ‘Future’ ...
[17:44:46.164] - state: ‘created’
[17:44:46.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.164] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.164] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.164]   - Field: ‘label’
[17:44:46.164]   - Field: ‘local’
[17:44:46.164]   - Field: ‘owner’
[17:44:46.165]   - Field: ‘envir’
[17:44:46.165]   - Field: ‘packages’
[17:44:46.165]   - Field: ‘gc’
[17:44:46.165]   - Field: ‘conditions’
[17:44:46.165]   - Field: ‘expr’
[17:44:46.165]   - Field: ‘uuid’
[17:44:46.165]   - Field: ‘seed’
[17:44:46.165]   - Field: ‘version’
[17:44:46.165]   - Field: ‘result’
[17:44:46.165]   - Field: ‘asynchronous’
[17:44:46.165]   - Field: ‘calls’
[17:44:46.166]   - Field: ‘globals’
[17:44:46.166]   - Field: ‘stdout’
[17:44:46.166]   - Field: ‘earlySignal’
[17:44:46.166]   - Field: ‘lazy’
[17:44:46.166]   - Field: ‘state’
[17:44:46.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.166] - Launch lazy future ...
[17:44:46.166] Packages needed by the future expression (n = 1): ‘stats’
[17:44:46.166] Packages needed by future strategies (n = 0): <none>
[17:44:46.167] {
[17:44:46.167]     {
[17:44:46.167]         {
[17:44:46.167]             ...future.startTime <- base::Sys.time()
[17:44:46.167]             {
[17:44:46.167]                 {
[17:44:46.167]                   {
[17:44:46.167]                     {
[17:44:46.167]                       base::local({
[17:44:46.167]                         has_future <- base::requireNamespace("future", 
[17:44:46.167]                           quietly = TRUE)
[17:44:46.167]                         if (has_future) {
[17:44:46.167]                           ns <- base::getNamespace("future")
[17:44:46.167]                           version <- ns[[".package"]][["version"]]
[17:44:46.167]                           if (is.null(version)) 
[17:44:46.167]                             version <- utils::packageVersion("future")
[17:44:46.167]                         }
[17:44:46.167]                         else {
[17:44:46.167]                           version <- NULL
[17:44:46.167]                         }
[17:44:46.167]                         if (!has_future || version < "1.8.0") {
[17:44:46.167]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.167]                             "", base::R.version$version.string), 
[17:44:46.167]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.167]                               "release", "version")], collapse = " "), 
[17:44:46.167]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.167]                             info)
[17:44:46.167]                           info <- base::paste(info, collapse = "; ")
[17:44:46.167]                           if (!has_future) {
[17:44:46.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.167]                               info)
[17:44:46.167]                           }
[17:44:46.167]                           else {
[17:44:46.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.167]                               info, version)
[17:44:46.167]                           }
[17:44:46.167]                           base::stop(msg)
[17:44:46.167]                         }
[17:44:46.167]                       })
[17:44:46.167]                     }
[17:44:46.167]                     base::local({
[17:44:46.167]                       for (pkg in "stats") {
[17:44:46.167]                         base::loadNamespace(pkg)
[17:44:46.167]                         base::library(pkg, character.only = TRUE)
[17:44:46.167]                       }
[17:44:46.167]                     })
[17:44:46.167]                   }
[17:44:46.167]                   ...future.strategy.old <- future::plan("list")
[17:44:46.167]                   options(future.plan = NULL)
[17:44:46.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.167]                 }
[17:44:46.167]                 ...future.workdir <- getwd()
[17:44:46.167]             }
[17:44:46.167]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.167]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.167]         }
[17:44:46.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.167]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.167]             base::names(...future.oldOptions))
[17:44:46.167]     }
[17:44:46.167]     if (FALSE) {
[17:44:46.167]     }
[17:44:46.167]     else {
[17:44:46.167]         if (TRUE) {
[17:44:46.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.167]                 open = "w")
[17:44:46.167]         }
[17:44:46.167]         else {
[17:44:46.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.167]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.167]         }
[17:44:46.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.167]             base::sink(type = "output", split = FALSE)
[17:44:46.167]             base::close(...future.stdout)
[17:44:46.167]         }, add = TRUE)
[17:44:46.167]     }
[17:44:46.167]     ...future.frame <- base::sys.nframe()
[17:44:46.167]     ...future.conditions <- base::list()
[17:44:46.167]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.167]     if (FALSE) {
[17:44:46.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.167]     }
[17:44:46.167]     ...future.result <- base::tryCatch({
[17:44:46.167]         base::withCallingHandlers({
[17:44:46.167]             ...future.value <- base::withVisible(base::local({
[17:44:46.167]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.167]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.167]                   ...future.globals.maxSize)) {
[17:44:46.167]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.167]                   on.exit(options(oopts), add = TRUE)
[17:44:46.167]                 }
[17:44:46.167]                 {
[17:44:46.167]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.167]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.167]                     USE.NAMES = FALSE)
[17:44:46.167]                   do.call(mapply, args = args)
[17:44:46.167]                 }
[17:44:46.167]             }))
[17:44:46.167]             future::FutureResult(value = ...future.value$value, 
[17:44:46.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.167]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.167]                     ...future.globalenv.names))
[17:44:46.167]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.167]         }, condition = base::local({
[17:44:46.167]             c <- base::c
[17:44:46.167]             inherits <- base::inherits
[17:44:46.167]             invokeRestart <- base::invokeRestart
[17:44:46.167]             length <- base::length
[17:44:46.167]             list <- base::list
[17:44:46.167]             seq.int <- base::seq.int
[17:44:46.167]             signalCondition <- base::signalCondition
[17:44:46.167]             sys.calls <- base::sys.calls
[17:44:46.167]             `[[` <- base::`[[`
[17:44:46.167]             `+` <- base::`+`
[17:44:46.167]             `<<-` <- base::`<<-`
[17:44:46.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.167]                   3L)]
[17:44:46.167]             }
[17:44:46.167]             function(cond) {
[17:44:46.167]                 is_error <- inherits(cond, "error")
[17:44:46.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.167]                   NULL)
[17:44:46.167]                 if (is_error) {
[17:44:46.167]                   sessionInformation <- function() {
[17:44:46.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.167]                       search = base::search(), system = base::Sys.info())
[17:44:46.167]                   }
[17:44:46.167]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.167]                     cond$call), session = sessionInformation(), 
[17:44:46.167]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.167]                   signalCondition(cond)
[17:44:46.167]                 }
[17:44:46.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.167]                 "immediateCondition"))) {
[17:44:46.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.167]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.167]                   if (TRUE && !signal) {
[17:44:46.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.167]                     {
[17:44:46.167]                       inherits <- base::inherits
[17:44:46.167]                       invokeRestart <- base::invokeRestart
[17:44:46.167]                       is.null <- base::is.null
[17:44:46.167]                       muffled <- FALSE
[17:44:46.167]                       if (inherits(cond, "message")) {
[17:44:46.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.167]                         if (muffled) 
[17:44:46.167]                           invokeRestart("muffleMessage")
[17:44:46.167]                       }
[17:44:46.167]                       else if (inherits(cond, "warning")) {
[17:44:46.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.167]                         if (muffled) 
[17:44:46.167]                           invokeRestart("muffleWarning")
[17:44:46.167]                       }
[17:44:46.167]                       else if (inherits(cond, "condition")) {
[17:44:46.167]                         if (!is.null(pattern)) {
[17:44:46.167]                           computeRestarts <- base::computeRestarts
[17:44:46.167]                           grepl <- base::grepl
[17:44:46.167]                           restarts <- computeRestarts(cond)
[17:44:46.167]                           for (restart in restarts) {
[17:44:46.167]                             name <- restart$name
[17:44:46.167]                             if (is.null(name)) 
[17:44:46.167]                               next
[17:44:46.167]                             if (!grepl(pattern, name)) 
[17:44:46.167]                               next
[17:44:46.167]                             invokeRestart(restart)
[17:44:46.167]                             muffled <- TRUE
[17:44:46.167]                             break
[17:44:46.167]                           }
[17:44:46.167]                         }
[17:44:46.167]                       }
[17:44:46.167]                       invisible(muffled)
[17:44:46.167]                     }
[17:44:46.167]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.167]                   }
[17:44:46.167]                 }
[17:44:46.167]                 else {
[17:44:46.167]                   if (TRUE) {
[17:44:46.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.167]                     {
[17:44:46.167]                       inherits <- base::inherits
[17:44:46.167]                       invokeRestart <- base::invokeRestart
[17:44:46.167]                       is.null <- base::is.null
[17:44:46.167]                       muffled <- FALSE
[17:44:46.167]                       if (inherits(cond, "message")) {
[17:44:46.167]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.167]                         if (muffled) 
[17:44:46.167]                           invokeRestart("muffleMessage")
[17:44:46.167]                       }
[17:44:46.167]                       else if (inherits(cond, "warning")) {
[17:44:46.167]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.167]                         if (muffled) 
[17:44:46.167]                           invokeRestart("muffleWarning")
[17:44:46.167]                       }
[17:44:46.167]                       else if (inherits(cond, "condition")) {
[17:44:46.167]                         if (!is.null(pattern)) {
[17:44:46.167]                           computeRestarts <- base::computeRestarts
[17:44:46.167]                           grepl <- base::grepl
[17:44:46.167]                           restarts <- computeRestarts(cond)
[17:44:46.167]                           for (restart in restarts) {
[17:44:46.167]                             name <- restart$name
[17:44:46.167]                             if (is.null(name)) 
[17:44:46.167]                               next
[17:44:46.167]                             if (!grepl(pattern, name)) 
[17:44:46.167]                               next
[17:44:46.167]                             invokeRestart(restart)
[17:44:46.167]                             muffled <- TRUE
[17:44:46.167]                             break
[17:44:46.167]                           }
[17:44:46.167]                         }
[17:44:46.167]                       }
[17:44:46.167]                       invisible(muffled)
[17:44:46.167]                     }
[17:44:46.167]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.167]                   }
[17:44:46.167]                 }
[17:44:46.167]             }
[17:44:46.167]         }))
[17:44:46.167]     }, error = function(ex) {
[17:44:46.167]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.167]                 ...future.rng), started = ...future.startTime, 
[17:44:46.167]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.167]             version = "1.8"), class = "FutureResult")
[17:44:46.167]     }, finally = {
[17:44:46.167]         if (!identical(...future.workdir, getwd())) 
[17:44:46.167]             setwd(...future.workdir)
[17:44:46.167]         {
[17:44:46.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.167]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.167]             }
[17:44:46.167]             base::options(...future.oldOptions)
[17:44:46.167]             if (.Platform$OS.type == "windows") {
[17:44:46.167]                 old_names <- names(...future.oldEnvVars)
[17:44:46.167]                 envs <- base::Sys.getenv()
[17:44:46.167]                 names <- names(envs)
[17:44:46.167]                 common <- intersect(names, old_names)
[17:44:46.167]                 added <- setdiff(names, old_names)
[17:44:46.167]                 removed <- setdiff(old_names, names)
[17:44:46.167]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.167]                   envs[common]]
[17:44:46.167]                 NAMES <- toupper(changed)
[17:44:46.167]                 args <- list()
[17:44:46.167]                 for (kk in seq_along(NAMES)) {
[17:44:46.167]                   name <- changed[[kk]]
[17:44:46.167]                   NAME <- NAMES[[kk]]
[17:44:46.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.167]                     next
[17:44:46.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.167]                 }
[17:44:46.167]                 NAMES <- toupper(added)
[17:44:46.167]                 for (kk in seq_along(NAMES)) {
[17:44:46.167]                   name <- added[[kk]]
[17:44:46.167]                   NAME <- NAMES[[kk]]
[17:44:46.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.167]                     next
[17:44:46.167]                   args[[name]] <- ""
[17:44:46.167]                 }
[17:44:46.167]                 NAMES <- toupper(removed)
[17:44:46.167]                 for (kk in seq_along(NAMES)) {
[17:44:46.167]                   name <- removed[[kk]]
[17:44:46.167]                   NAME <- NAMES[[kk]]
[17:44:46.167]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.167]                     next
[17:44:46.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.167]                 }
[17:44:46.167]                 if (length(args) > 0) 
[17:44:46.167]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.167]             }
[17:44:46.167]             else {
[17:44:46.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.167]             }
[17:44:46.167]             {
[17:44:46.167]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.167]                   0L) {
[17:44:46.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.167]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.167]                   base::options(opts)
[17:44:46.167]                 }
[17:44:46.167]                 {
[17:44:46.167]                   {
[17:44:46.167]                     base::assign(".Random.seed", c(10407L, -1891762399L, 
[17:44:46.167]                     -1855272286L, 1739498560L, -1880592766L, 
[17:44:46.167]                     1367182738L, -1109387676L), envir = base::globalenv(), 
[17:44:46.167]                       inherits = FALSE)
[17:44:46.167]                     NULL
[17:44:46.167]                   }
[17:44:46.167]                   options(future.plan = NULL)
[17:44:46.167]                   if (is.na(NA_character_)) 
[17:44:46.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.167]                     .init = FALSE)
[17:44:46.167]                 }
[17:44:46.167]             }
[17:44:46.167]         }
[17:44:46.167]     })
[17:44:46.167]     if (TRUE) {
[17:44:46.167]         base::sink(type = "output", split = FALSE)
[17:44:46.167]         if (TRUE) {
[17:44:46.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.167]         }
[17:44:46.167]         else {
[17:44:46.167]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.167]         }
[17:44:46.167]         base::close(...future.stdout)
[17:44:46.167]         ...future.stdout <- NULL
[17:44:46.167]     }
[17:44:46.167]     ...future.result$conditions <- ...future.conditions
[17:44:46.167]     ...future.result$finished <- base::Sys.time()
[17:44:46.167]     ...future.result
[17:44:46.167] }
[17:44:46.169] assign_globals() ...
[17:44:46.169] List of 5
[17:44:46.169]  $ ...future.FUN            :function (x, w, ...)  
[17:44:46.169]  $ MoreArgs                 : NULL
[17:44:46.169]  $ ...future.elements_ii    :List of 2
[17:44:46.169]   ..$ :List of 5
[17:44:46.169]   .. ..$ : num [1:10] 0.8526 0.2885 0.4924 0.2134 0.0336 ...
[17:44:46.169]   .. ..$ : num [1:10] 0.25 0.45 0.685 0.4 0.216 ...
[17:44:46.169]   .. ..$ : num [1:10] 0.692 0.794 0.664 0.214 0.919 ...
[17:44:46.169]   .. ..$ : num [1:10] 0.66 0.816 0.764 0.325 0.251 ...
[17:44:46.169]   .. ..$ : num [1:10] 0.5 0.931 0.715 0.916 0.604 ...
[17:44:46.169]   ..$ :List of 5
[17:44:46.169]   .. ..$ : num [1:10] 7 6 6 6 7 7 6 6 8 7
[17:44:46.169]   .. ..$ : num [1:10] 9 10 3 7 3 3 6 8 4 7
[17:44:46.169]   .. ..$ : num [1:10] 6 9 5 6 10 3 5 3 5 4
[17:44:46.169]   .. ..$ : num [1:10] 6 5 8 5 5 8 6 4 10 8
[17:44:46.169]   .. ..$ : num [1:10] 7 9 3 3 8 6 6 13 4 7
[17:44:46.169]  $ ...future.seeds_ii       : NULL
[17:44:46.169]  $ ...future.globals.maxSize: NULL
[17:44:46.169]  - attr(*, "where")=List of 5
[17:44:46.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.169]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.169]  - attr(*, "resolved")= logi FALSE
[17:44:46.169]  - attr(*, "total_size")= num 3176
[17:44:46.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.169]  - attr(*, "already-done")= logi TRUE
[17:44:46.176] - copied ‘...future.FUN’ to environment
[17:44:46.176] - copied ‘MoreArgs’ to environment
[17:44:46.176] - copied ‘...future.elements_ii’ to environment
[17:44:46.176] - copied ‘...future.seeds_ii’ to environment
[17:44:46.177] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.177] assign_globals() ... done
[17:44:46.177] plan(): Setting new future strategy stack:
[17:44:46.177] List of future strategies:
[17:44:46.177] 1. sequential:
[17:44:46.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.177]    - tweaked: FALSE
[17:44:46.177]    - call: NULL
[17:44:46.178] plan(): nbrOfWorkers() = 1
[17:44:46.178] plan(): Setting new future strategy stack:
[17:44:46.178] List of future strategies:
[17:44:46.178] 1. sequential:
[17:44:46.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.178]    - tweaked: FALSE
[17:44:46.178]    - call: plan(strategy)
[17:44:46.181] plan(): nbrOfWorkers() = 1
[17:44:46.181] SequentialFuture started (and completed)
[17:44:46.181] - Launch lazy future ... done
[17:44:46.181] run() for ‘SequentialFuture’ ... done
[17:44:46.181] Created future:
[17:44:46.181] SequentialFuture:
[17:44:46.181] Label: ‘future_Map-1’
[17:44:46.181] Expression:
[17:44:46.181] {
[17:44:46.181]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.181]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.181]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.181]         on.exit(options(oopts), add = TRUE)
[17:44:46.181]     }
[17:44:46.181]     {
[17:44:46.181]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.181]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.181]         do.call(mapply, args = args)
[17:44:46.181]     }
[17:44:46.181] }
[17:44:46.181] Lazy evaluation: FALSE
[17:44:46.181] Asynchronous evaluation: FALSE
[17:44:46.181] Local evaluation: TRUE
[17:44:46.181] Environment: R_GlobalEnv
[17:44:46.181] Capture standard output: TRUE
[17:44:46.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.181] Globals: 5 objects totaling 3.10 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.181] Packages: 1 packages (‘stats’)
[17:44:46.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.181] Resolved: TRUE
[17:44:46.181] Value: 280 bytes of class ‘list’
[17:44:46.181] Early signaling: FALSE
[17:44:46.181] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.181] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.182] Chunk #1 of 1 ... DONE
[17:44:46.182] Launching 1 futures (chunks) ... DONE
[17:44:46.183] Resolving 1 futures (chunks) ...
[17:44:46.183] resolve() on list ...
[17:44:46.183]  recursive: 0
[17:44:46.183]  length: 1
[17:44:46.183] 
[17:44:46.183] resolved() for ‘SequentialFuture’ ...
[17:44:46.183] - state: ‘finished’
[17:44:46.183] - run: TRUE
[17:44:46.183] - result: ‘FutureResult’
[17:44:46.184] resolved() for ‘SequentialFuture’ ... done
[17:44:46.184] Future #1
[17:44:46.184] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.184] - nx: 1
[17:44:46.184] - relay: TRUE
[17:44:46.184] - stdout: TRUE
[17:44:46.184] - signal: TRUE
[17:44:46.184] - resignal: FALSE
[17:44:46.184] - force: TRUE
[17:44:46.184] - relayed: [n=1] FALSE
[17:44:46.184] - queued futures: [n=1] FALSE
[17:44:46.185]  - until=1
[17:44:46.185]  - relaying element #1
[17:44:46.185] - relayed: [n=1] TRUE
[17:44:46.185] - queued futures: [n=1] TRUE
[17:44:46.185] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.185]  length: 0 (resolved future 1)
[17:44:46.185] Relaying remaining futures
[17:44:46.185] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.185] - nx: 1
[17:44:46.185] - relay: TRUE
[17:44:46.186] - stdout: TRUE
[17:44:46.186] - signal: TRUE
[17:44:46.186] - resignal: FALSE
[17:44:46.186] - force: TRUE
[17:44:46.186] - relayed: [n=1] TRUE
[17:44:46.186] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.186] - relayed: [n=1] TRUE
[17:44:46.186] - queued futures: [n=1] TRUE
[17:44:46.186] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.186] resolve() on list ... DONE
[17:44:46.186]  - Number of value chunks collected: 1
[17:44:46.187] Resolving 1 futures (chunks) ... DONE
[17:44:46.187] Reducing values from 1 chunks ...
[17:44:46.187]  - Number of values collected after concatenation: 5
[17:44:46.187]  - Number of values expected: 5
[17:44:46.187] Reducing values from 1 chunks ... DONE
[17:44:46.187] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:44:46.189] future_mapply() ...
[17:44:46.189] Number of chunks: 1
[17:44:46.189] getGlobalsAndPackagesXApply() ...
[17:44:46.189]  - future.globals: TRUE
[17:44:46.189] getGlobalsAndPackages() ...
[17:44:46.189] Searching for globals...
[17:44:46.190] - globals found: [1] ‘FUN’
[17:44:46.190] Searching for globals ... DONE
[17:44:46.190] Resolving globals: FALSE
[17:44:46.190] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.191] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.191] - globals: [1] ‘FUN’
[17:44:46.191] 
[17:44:46.191] getGlobalsAndPackages() ... DONE
[17:44:46.191]  - globals found/used: [n=1] ‘FUN’
[17:44:46.191]  - needed namespaces: [n=0] 
[17:44:46.191] Finding globals ... DONE
[17:44:46.191] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.191] List of 2
[17:44:46.191]  $ ...future.FUN:function (e1, e2)  
[17:44:46.191]  $ MoreArgs     : NULL
[17:44:46.191]  - attr(*, "where")=List of 2
[17:44:46.191]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.191]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.191]  - attr(*, "resolved")= logi FALSE
[17:44:46.191]  - attr(*, "total_size")= num NA
[17:44:46.194] Packages to be attached in all futures: [n=0] 
[17:44:46.194] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.194] Number of futures (= number of chunks): 1
[17:44:46.194] Launching 1 futures (chunks) ...
[17:44:46.194] Chunk #1 of 1 ...
[17:44:46.194]  - Finding globals in '...' for chunk #1 ...
[17:44:46.195] getGlobalsAndPackages() ...
[17:44:46.195] Searching for globals...
[17:44:46.195] 
[17:44:46.195] Searching for globals ... DONE
[17:44:46.195] - globals: [0] <none>
[17:44:46.195] getGlobalsAndPackages() ... DONE
[17:44:46.195]    + additional globals found: [n=0] 
[17:44:46.195]    + additional namespaces needed: [n=0] 
[17:44:46.196]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.196]  - seeds: <none>
[17:44:46.196]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.196] getGlobalsAndPackages() ...
[17:44:46.196] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.196] Resolving globals: FALSE
[17:44:46.196] The total size of the 5 globals is 392 bytes (392 bytes)
[17:44:46.197] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 392 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (336 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.197] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.197] 
[17:44:46.197] getGlobalsAndPackages() ... DONE
[17:44:46.197] run() for ‘Future’ ...
[17:44:46.198] - state: ‘created’
[17:44:46.198] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.198] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.198]   - Field: ‘label’
[17:44:46.198]   - Field: ‘local’
[17:44:46.198]   - Field: ‘owner’
[17:44:46.198]   - Field: ‘envir’
[17:44:46.199]   - Field: ‘packages’
[17:44:46.199]   - Field: ‘gc’
[17:44:46.199]   - Field: ‘conditions’
[17:44:46.199]   - Field: ‘expr’
[17:44:46.199]   - Field: ‘uuid’
[17:44:46.199]   - Field: ‘seed’
[17:44:46.199]   - Field: ‘version’
[17:44:46.199]   - Field: ‘result’
[17:44:46.199]   - Field: ‘asynchronous’
[17:44:46.199]   - Field: ‘calls’
[17:44:46.200]   - Field: ‘globals’
[17:44:46.200]   - Field: ‘stdout’
[17:44:46.200]   - Field: ‘earlySignal’
[17:44:46.200]   - Field: ‘lazy’
[17:44:46.200]   - Field: ‘state’
[17:44:46.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.200] - Launch lazy future ...
[17:44:46.200] Packages needed by the future expression (n = 0): <none>
[17:44:46.200] Packages needed by future strategies (n = 0): <none>
[17:44:46.201] {
[17:44:46.201]     {
[17:44:46.201]         {
[17:44:46.201]             ...future.startTime <- base::Sys.time()
[17:44:46.201]             {
[17:44:46.201]                 {
[17:44:46.201]                   {
[17:44:46.201]                     base::local({
[17:44:46.201]                       has_future <- base::requireNamespace("future", 
[17:44:46.201]                         quietly = TRUE)
[17:44:46.201]                       if (has_future) {
[17:44:46.201]                         ns <- base::getNamespace("future")
[17:44:46.201]                         version <- ns[[".package"]][["version"]]
[17:44:46.201]                         if (is.null(version)) 
[17:44:46.201]                           version <- utils::packageVersion("future")
[17:44:46.201]                       }
[17:44:46.201]                       else {
[17:44:46.201]                         version <- NULL
[17:44:46.201]                       }
[17:44:46.201]                       if (!has_future || version < "1.8.0") {
[17:44:46.201]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.201]                           "", base::R.version$version.string), 
[17:44:46.201]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.201]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.201]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.201]                             "release", "version")], collapse = " "), 
[17:44:46.201]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.201]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.201]                           info)
[17:44:46.201]                         info <- base::paste(info, collapse = "; ")
[17:44:46.201]                         if (!has_future) {
[17:44:46.201]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.201]                             info)
[17:44:46.201]                         }
[17:44:46.201]                         else {
[17:44:46.201]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.201]                             info, version)
[17:44:46.201]                         }
[17:44:46.201]                         base::stop(msg)
[17:44:46.201]                       }
[17:44:46.201]                     })
[17:44:46.201]                   }
[17:44:46.201]                   ...future.strategy.old <- future::plan("list")
[17:44:46.201]                   options(future.plan = NULL)
[17:44:46.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.201]                 }
[17:44:46.201]                 ...future.workdir <- getwd()
[17:44:46.201]             }
[17:44:46.201]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.201]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.201]         }
[17:44:46.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.201]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.201]             base::names(...future.oldOptions))
[17:44:46.201]     }
[17:44:46.201]     if (FALSE) {
[17:44:46.201]     }
[17:44:46.201]     else {
[17:44:46.201]         if (TRUE) {
[17:44:46.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.201]                 open = "w")
[17:44:46.201]         }
[17:44:46.201]         else {
[17:44:46.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.201]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.201]         }
[17:44:46.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.201]             base::sink(type = "output", split = FALSE)
[17:44:46.201]             base::close(...future.stdout)
[17:44:46.201]         }, add = TRUE)
[17:44:46.201]     }
[17:44:46.201]     ...future.frame <- base::sys.nframe()
[17:44:46.201]     ...future.conditions <- base::list()
[17:44:46.201]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.201]     if (FALSE) {
[17:44:46.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.201]     }
[17:44:46.201]     ...future.result <- base::tryCatch({
[17:44:46.201]         base::withCallingHandlers({
[17:44:46.201]             ...future.value <- base::withVisible(base::local({
[17:44:46.201]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.201]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.201]                   ...future.globals.maxSize)) {
[17:44:46.201]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.201]                   on.exit(options(oopts), add = TRUE)
[17:44:46.201]                 }
[17:44:46.201]                 {
[17:44:46.201]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.201]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.201]                     USE.NAMES = FALSE)
[17:44:46.201]                   do.call(mapply, args = args)
[17:44:46.201]                 }
[17:44:46.201]             }))
[17:44:46.201]             future::FutureResult(value = ...future.value$value, 
[17:44:46.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.201]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.201]                     ...future.globalenv.names))
[17:44:46.201]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.201]         }, condition = base::local({
[17:44:46.201]             c <- base::c
[17:44:46.201]             inherits <- base::inherits
[17:44:46.201]             invokeRestart <- base::invokeRestart
[17:44:46.201]             length <- base::length
[17:44:46.201]             list <- base::list
[17:44:46.201]             seq.int <- base::seq.int
[17:44:46.201]             signalCondition <- base::signalCondition
[17:44:46.201]             sys.calls <- base::sys.calls
[17:44:46.201]             `[[` <- base::`[[`
[17:44:46.201]             `+` <- base::`+`
[17:44:46.201]             `<<-` <- base::`<<-`
[17:44:46.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.201]                   3L)]
[17:44:46.201]             }
[17:44:46.201]             function(cond) {
[17:44:46.201]                 is_error <- inherits(cond, "error")
[17:44:46.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.201]                   NULL)
[17:44:46.201]                 if (is_error) {
[17:44:46.201]                   sessionInformation <- function() {
[17:44:46.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.201]                       search = base::search(), system = base::Sys.info())
[17:44:46.201]                   }
[17:44:46.201]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.201]                     cond$call), session = sessionInformation(), 
[17:44:46.201]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.201]                   signalCondition(cond)
[17:44:46.201]                 }
[17:44:46.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.201]                 "immediateCondition"))) {
[17:44:46.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.201]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.201]                   if (TRUE && !signal) {
[17:44:46.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.201]                     {
[17:44:46.201]                       inherits <- base::inherits
[17:44:46.201]                       invokeRestart <- base::invokeRestart
[17:44:46.201]                       is.null <- base::is.null
[17:44:46.201]                       muffled <- FALSE
[17:44:46.201]                       if (inherits(cond, "message")) {
[17:44:46.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.201]                         if (muffled) 
[17:44:46.201]                           invokeRestart("muffleMessage")
[17:44:46.201]                       }
[17:44:46.201]                       else if (inherits(cond, "warning")) {
[17:44:46.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.201]                         if (muffled) 
[17:44:46.201]                           invokeRestart("muffleWarning")
[17:44:46.201]                       }
[17:44:46.201]                       else if (inherits(cond, "condition")) {
[17:44:46.201]                         if (!is.null(pattern)) {
[17:44:46.201]                           computeRestarts <- base::computeRestarts
[17:44:46.201]                           grepl <- base::grepl
[17:44:46.201]                           restarts <- computeRestarts(cond)
[17:44:46.201]                           for (restart in restarts) {
[17:44:46.201]                             name <- restart$name
[17:44:46.201]                             if (is.null(name)) 
[17:44:46.201]                               next
[17:44:46.201]                             if (!grepl(pattern, name)) 
[17:44:46.201]                               next
[17:44:46.201]                             invokeRestart(restart)
[17:44:46.201]                             muffled <- TRUE
[17:44:46.201]                             break
[17:44:46.201]                           }
[17:44:46.201]                         }
[17:44:46.201]                       }
[17:44:46.201]                       invisible(muffled)
[17:44:46.201]                     }
[17:44:46.201]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.201]                   }
[17:44:46.201]                 }
[17:44:46.201]                 else {
[17:44:46.201]                   if (TRUE) {
[17:44:46.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.201]                     {
[17:44:46.201]                       inherits <- base::inherits
[17:44:46.201]                       invokeRestart <- base::invokeRestart
[17:44:46.201]                       is.null <- base::is.null
[17:44:46.201]                       muffled <- FALSE
[17:44:46.201]                       if (inherits(cond, "message")) {
[17:44:46.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.201]                         if (muffled) 
[17:44:46.201]                           invokeRestart("muffleMessage")
[17:44:46.201]                       }
[17:44:46.201]                       else if (inherits(cond, "warning")) {
[17:44:46.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.201]                         if (muffled) 
[17:44:46.201]                           invokeRestart("muffleWarning")
[17:44:46.201]                       }
[17:44:46.201]                       else if (inherits(cond, "condition")) {
[17:44:46.201]                         if (!is.null(pattern)) {
[17:44:46.201]                           computeRestarts <- base::computeRestarts
[17:44:46.201]                           grepl <- base::grepl
[17:44:46.201]                           restarts <- computeRestarts(cond)
[17:44:46.201]                           for (restart in restarts) {
[17:44:46.201]                             name <- restart$name
[17:44:46.201]                             if (is.null(name)) 
[17:44:46.201]                               next
[17:44:46.201]                             if (!grepl(pattern, name)) 
[17:44:46.201]                               next
[17:44:46.201]                             invokeRestart(restart)
[17:44:46.201]                             muffled <- TRUE
[17:44:46.201]                             break
[17:44:46.201]                           }
[17:44:46.201]                         }
[17:44:46.201]                       }
[17:44:46.201]                       invisible(muffled)
[17:44:46.201]                     }
[17:44:46.201]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.201]                   }
[17:44:46.201]                 }
[17:44:46.201]             }
[17:44:46.201]         }))
[17:44:46.201]     }, error = function(ex) {
[17:44:46.201]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.201]                 ...future.rng), started = ...future.startTime, 
[17:44:46.201]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.201]             version = "1.8"), class = "FutureResult")
[17:44:46.201]     }, finally = {
[17:44:46.201]         if (!identical(...future.workdir, getwd())) 
[17:44:46.201]             setwd(...future.workdir)
[17:44:46.201]         {
[17:44:46.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.201]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.201]             }
[17:44:46.201]             base::options(...future.oldOptions)
[17:44:46.201]             if (.Platform$OS.type == "windows") {
[17:44:46.201]                 old_names <- names(...future.oldEnvVars)
[17:44:46.201]                 envs <- base::Sys.getenv()
[17:44:46.201]                 names <- names(envs)
[17:44:46.201]                 common <- intersect(names, old_names)
[17:44:46.201]                 added <- setdiff(names, old_names)
[17:44:46.201]                 removed <- setdiff(old_names, names)
[17:44:46.201]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.201]                   envs[common]]
[17:44:46.201]                 NAMES <- toupper(changed)
[17:44:46.201]                 args <- list()
[17:44:46.201]                 for (kk in seq_along(NAMES)) {
[17:44:46.201]                   name <- changed[[kk]]
[17:44:46.201]                   NAME <- NAMES[[kk]]
[17:44:46.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.201]                     next
[17:44:46.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.201]                 }
[17:44:46.201]                 NAMES <- toupper(added)
[17:44:46.201]                 for (kk in seq_along(NAMES)) {
[17:44:46.201]                   name <- added[[kk]]
[17:44:46.201]                   NAME <- NAMES[[kk]]
[17:44:46.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.201]                     next
[17:44:46.201]                   args[[name]] <- ""
[17:44:46.201]                 }
[17:44:46.201]                 NAMES <- toupper(removed)
[17:44:46.201]                 for (kk in seq_along(NAMES)) {
[17:44:46.201]                   name <- removed[[kk]]
[17:44:46.201]                   NAME <- NAMES[[kk]]
[17:44:46.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.201]                     next
[17:44:46.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.201]                 }
[17:44:46.201]                 if (length(args) > 0) 
[17:44:46.201]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.201]             }
[17:44:46.201]             else {
[17:44:46.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.201]             }
[17:44:46.201]             {
[17:44:46.201]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.201]                   0L) {
[17:44:46.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.201]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.201]                   base::options(opts)
[17:44:46.201]                 }
[17:44:46.201]                 {
[17:44:46.201]                   {
[17:44:46.201]                     base::assign(".Random.seed", c(10407L, -1891762399L, 
[17:44:46.201]                     -1855272286L, 1739498560L, -1880592766L, 
[17:44:46.201]                     1367182738L, -1109387676L), envir = base::globalenv(), 
[17:44:46.201]                       inherits = FALSE)
[17:44:46.201]                     NULL
[17:44:46.201]                   }
[17:44:46.201]                   options(future.plan = NULL)
[17:44:46.201]                   if (is.na(NA_character_)) 
[17:44:46.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.201]                     .init = FALSE)
[17:44:46.201]                 }
[17:44:46.201]             }
[17:44:46.201]         }
[17:44:46.201]     })
[17:44:46.201]     if (TRUE) {
[17:44:46.201]         base::sink(type = "output", split = FALSE)
[17:44:46.201]         if (TRUE) {
[17:44:46.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.201]         }
[17:44:46.201]         else {
[17:44:46.201]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.201]         }
[17:44:46.201]         base::close(...future.stdout)
[17:44:46.201]         ...future.stdout <- NULL
[17:44:46.201]     }
[17:44:46.201]     ...future.result$conditions <- ...future.conditions
[17:44:46.201]     ...future.result$finished <- base::Sys.time()
[17:44:46.201]     ...future.result
[17:44:46.201] }
[17:44:46.202] assign_globals() ...
[17:44:46.203] List of 5
[17:44:46.203]  $ ...future.FUN            :function (e1, e2)  
[17:44:46.203]  $ MoreArgs                 : NULL
[17:44:46.203]  $ ...future.elements_ii    :List of 2
[17:44:46.203]   ..$ :List of 3
[17:44:46.203]   .. ..$ : num 1
[17:44:46.203]   .. ..$ : num 1
[17:44:46.203]   .. ..$ : num 1
[17:44:46.203]   ..$ :List of 3
[17:44:46.203]   .. ..$ : int 1
[17:44:46.203]   .. ..$ : int 2
[17:44:46.203]   .. ..$ : int 3
[17:44:46.203]  $ ...future.seeds_ii       : NULL
[17:44:46.203]  $ ...future.globals.maxSize: NULL
[17:44:46.203]  - attr(*, "where")=List of 5
[17:44:46.203]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.203]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.203]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.203]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.203]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.203]  - attr(*, "resolved")= logi FALSE
[17:44:46.203]  - attr(*, "total_size")= num 392
[17:44:46.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.203]  - attr(*, "already-done")= logi TRUE
[17:44:46.213] - copied ‘...future.FUN’ to environment
[17:44:46.213] - copied ‘MoreArgs’ to environment
[17:44:46.213] - copied ‘...future.elements_ii’ to environment
[17:44:46.213] - copied ‘...future.seeds_ii’ to environment
[17:44:46.213] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.213] assign_globals() ... done
[17:44:46.213] plan(): Setting new future strategy stack:
[17:44:46.213] List of future strategies:
[17:44:46.213] 1. sequential:
[17:44:46.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.213]    - tweaked: FALSE
[17:44:46.213]    - call: NULL
[17:44:46.214] plan(): nbrOfWorkers() = 1
[17:44:46.215] plan(): Setting new future strategy stack:
[17:44:46.215] List of future strategies:
[17:44:46.215] 1. sequential:
[17:44:46.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.215]    - tweaked: FALSE
[17:44:46.215]    - call: plan(strategy)
[17:44:46.215] plan(): nbrOfWorkers() = 1
[17:44:46.215] SequentialFuture started (and completed)
[17:44:46.216] - Launch lazy future ... done
[17:44:46.216] run() for ‘SequentialFuture’ ... done
[17:44:46.216] Created future:
[17:44:46.216] SequentialFuture:
[17:44:46.216] Label: ‘future_Map-1’
[17:44:46.216] Expression:
[17:44:46.216] {
[17:44:46.216]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.216]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.216]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.216]         on.exit(options(oopts), add = TRUE)
[17:44:46.216]     }
[17:44:46.216]     {
[17:44:46.216]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.216]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.216]         do.call(mapply, args = args)
[17:44:46.216]     }
[17:44:46.216] }
[17:44:46.216] Lazy evaluation: FALSE
[17:44:46.216] Asynchronous evaluation: FALSE
[17:44:46.216] Local evaluation: TRUE
[17:44:46.216] Environment: R_GlobalEnv
[17:44:46.216] Capture standard output: TRUE
[17:44:46.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.216] Globals: 5 objects totaling 392 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.216] Packages: <none>
[17:44:46.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.216] Resolved: TRUE
[17:44:46.216] Value: 168 bytes of class ‘list’
[17:44:46.216] Early signaling: FALSE
[17:44:46.216] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.216] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.217] Chunk #1 of 1 ... DONE
[17:44:46.217] Launching 1 futures (chunks) ... DONE
[17:44:46.217] Resolving 1 futures (chunks) ...
[17:44:46.217] resolve() on list ...
[17:44:46.217]  recursive: 0
[17:44:46.217]  length: 1
[17:44:46.217] 
[17:44:46.217] resolved() for ‘SequentialFuture’ ...
[17:44:46.217] - state: ‘finished’
[17:44:46.218] - run: TRUE
[17:44:46.218] - result: ‘FutureResult’
[17:44:46.218] resolved() for ‘SequentialFuture’ ... done
[17:44:46.218] Future #1
[17:44:46.218] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.218] - nx: 1
[17:44:46.218] - relay: TRUE
[17:44:46.218] - stdout: TRUE
[17:44:46.218] - signal: TRUE
[17:44:46.218] - resignal: FALSE
[17:44:46.218] - force: TRUE
[17:44:46.219] - relayed: [n=1] FALSE
[17:44:46.219] - queued futures: [n=1] FALSE
[17:44:46.219]  - until=1
[17:44:46.219]  - relaying element #1
[17:44:46.219] - relayed: [n=1] TRUE
[17:44:46.219] - queued futures: [n=1] TRUE
[17:44:46.219] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.219]  length: 0 (resolved future 1)
[17:44:46.219] Relaying remaining futures
[17:44:46.220] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.220] - nx: 1
[17:44:46.220] - relay: TRUE
[17:44:46.220] - stdout: TRUE
[17:44:46.220] - signal: TRUE
[17:44:46.220] - resignal: FALSE
[17:44:46.220] - force: TRUE
[17:44:46.220] - relayed: [n=1] TRUE
[17:44:46.220] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.220] - relayed: [n=1] TRUE
[17:44:46.220] - queued futures: [n=1] TRUE
[17:44:46.220] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.221] resolve() on list ... DONE
[17:44:46.221]  - Number of value chunks collected: 1
[17:44:46.221] Resolving 1 futures (chunks) ... DONE
[17:44:46.221] Reducing values from 1 chunks ...
[17:44:46.221]  - Number of values collected after concatenation: 3
[17:44:46.221]  - Number of values expected: 3
[17:44:46.221] Reducing values from 1 chunks ... DONE
[17:44:46.221] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:44:46.222] future_mapply() ...
[17:44:46.222] Number of chunks: 1
[17:44:46.222] getGlobalsAndPackagesXApply() ...
[17:44:46.222]  - future.globals: TRUE
[17:44:46.222] getGlobalsAndPackages() ...
[17:44:46.222] Searching for globals...
[17:44:46.223] - globals found: [1] ‘FUN’
[17:44:46.223] Searching for globals ... DONE
[17:44:46.223] Resolving globals: FALSE
[17:44:46.224] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:46.224] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:46.224] - globals: [1] ‘FUN’
[17:44:46.224] 
[17:44:46.224] getGlobalsAndPackages() ... DONE
[17:44:46.224]  - globals found/used: [n=1] ‘FUN’
[17:44:46.224]  - needed namespaces: [n=0] 
[17:44:46.225] Finding globals ... DONE
[17:44:46.225] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.225] List of 2
[17:44:46.225]  $ ...future.FUN:function (x)  
[17:44:46.225]  $ MoreArgs     : NULL
[17:44:46.225]  - attr(*, "where")=List of 2
[17:44:46.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.225]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.225]  - attr(*, "resolved")= logi FALSE
[17:44:46.225]  - attr(*, "total_size")= num NA
[17:44:46.227] Packages to be attached in all futures: [n=0] 
[17:44:46.227] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.228] Number of futures (= number of chunks): 1
[17:44:46.228] Launching 1 futures (chunks) ...
[17:44:46.228] Chunk #1 of 1 ...
[17:44:46.228]  - Finding globals in '...' for chunk #1 ...
[17:44:46.228] getGlobalsAndPackages() ...
[17:44:46.228] Searching for globals...
[17:44:46.228] 
[17:44:46.228] Searching for globals ... DONE
[17:44:46.229] - globals: [0] <none>
[17:44:46.229] getGlobalsAndPackages() ... DONE
[17:44:46.229]    + additional globals found: [n=0] 
[17:44:46.229]    + additional namespaces needed: [n=0] 
[17:44:46.229]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.229]  - seeds: <none>
[17:44:46.229]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.229] getGlobalsAndPackages() ...
[17:44:46.229] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.231] Resolving globals: FALSE
[17:44:46.231] The total size of the 5 globals is 960 bytes (960 bytes)
[17:44:46.232] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 960 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.232] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.232] 
[17:44:46.232] getGlobalsAndPackages() ... DONE
[17:44:46.233] run() for ‘Future’ ...
[17:44:46.233] - state: ‘created’
[17:44:46.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:44:46.233] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.233] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:44:46.233]   - Field: ‘label’
[17:44:46.233]   - Field: ‘local’
[17:44:46.234]   - Field: ‘owner’
[17:44:46.234]   - Field: ‘envir’
[17:44:46.234]   - Field: ‘packages’
[17:44:46.234]   - Field: ‘gc’
[17:44:46.234]   - Field: ‘conditions’
[17:44:46.234]   - Field: ‘expr’
[17:44:46.234]   - Field: ‘uuid’
[17:44:46.234]   - Field: ‘seed’
[17:44:46.234]   - Field: ‘version’
[17:44:46.234]   - Field: ‘result’
[17:44:46.235]   - Field: ‘asynchronous’
[17:44:46.235]   - Field: ‘calls’
[17:44:46.235]   - Field: ‘globals’
[17:44:46.235]   - Field: ‘stdout’
[17:44:46.235]   - Field: ‘earlySignal’
[17:44:46.235]   - Field: ‘lazy’
[17:44:46.235]   - Field: ‘state’
[17:44:46.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:44:46.235] - Launch lazy future ...
[17:44:46.235] Packages needed by the future expression (n = 0): <none>
[17:44:46.236] Packages needed by future strategies (n = 0): <none>
[17:44:46.236] {
[17:44:46.236]     {
[17:44:46.236]         {
[17:44:46.236]             ...future.startTime <- base::Sys.time()
[17:44:46.236]             {
[17:44:46.236]                 {
[17:44:46.236]                   {
[17:44:46.236]                     base::local({
[17:44:46.236]                       has_future <- base::requireNamespace("future", 
[17:44:46.236]                         quietly = TRUE)
[17:44:46.236]                       if (has_future) {
[17:44:46.236]                         ns <- base::getNamespace("future")
[17:44:46.236]                         version <- ns[[".package"]][["version"]]
[17:44:46.236]                         if (is.null(version)) 
[17:44:46.236]                           version <- utils::packageVersion("future")
[17:44:46.236]                       }
[17:44:46.236]                       else {
[17:44:46.236]                         version <- NULL
[17:44:46.236]                       }
[17:44:46.236]                       if (!has_future || version < "1.8.0") {
[17:44:46.236]                         info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.236]                           "", base::R.version$version.string), 
[17:44:46.236]                           platform = base::sprintf("%s (%s-bit)", 
[17:44:46.236]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.236]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.236]                             "release", "version")], collapse = " "), 
[17:44:46.236]                           hostname = base::Sys.info()[["nodename"]])
[17:44:46.236]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.236]                           info)
[17:44:46.236]                         info <- base::paste(info, collapse = "; ")
[17:44:46.236]                         if (!has_future) {
[17:44:46.236]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.236]                             info)
[17:44:46.236]                         }
[17:44:46.236]                         else {
[17:44:46.236]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.236]                             info, version)
[17:44:46.236]                         }
[17:44:46.236]                         base::stop(msg)
[17:44:46.236]                       }
[17:44:46.236]                     })
[17:44:46.236]                   }
[17:44:46.236]                   ...future.strategy.old <- future::plan("list")
[17:44:46.236]                   options(future.plan = NULL)
[17:44:46.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.236]                 }
[17:44:46.236]                 ...future.workdir <- getwd()
[17:44:46.236]             }
[17:44:46.236]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.236]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.236]         }
[17:44:46.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:46.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.236]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.236]             base::names(...future.oldOptions))
[17:44:46.236]     }
[17:44:46.236]     if (FALSE) {
[17:44:46.236]     }
[17:44:46.236]     else {
[17:44:46.236]         if (TRUE) {
[17:44:46.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.236]                 open = "w")
[17:44:46.236]         }
[17:44:46.236]         else {
[17:44:46.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.236]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.236]         }
[17:44:46.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.236]             base::sink(type = "output", split = FALSE)
[17:44:46.236]             base::close(...future.stdout)
[17:44:46.236]         }, add = TRUE)
[17:44:46.236]     }
[17:44:46.236]     ...future.frame <- base::sys.nframe()
[17:44:46.236]     ...future.conditions <- base::list()
[17:44:46.236]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.236]     if (FALSE) {
[17:44:46.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.236]     }
[17:44:46.236]     ...future.result <- base::tryCatch({
[17:44:46.236]         base::withCallingHandlers({
[17:44:46.236]             ...future.value <- base::withVisible(base::local({
[17:44:46.236]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.236]                 if (!identical(...future.globals.maxSize.org, 
[17:44:46.236]                   ...future.globals.maxSize)) {
[17:44:46.236]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.236]                   on.exit(options(oopts), add = TRUE)
[17:44:46.236]                 }
[17:44:46.236]                 {
[17:44:46.236]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.236]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.236]                     USE.NAMES = FALSE)
[17:44:46.236]                   do.call(mapply, args = args)
[17:44:46.236]                 }
[17:44:46.236]             }))
[17:44:46.236]             future::FutureResult(value = ...future.value$value, 
[17:44:46.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.236]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.236]                     ...future.globalenv.names))
[17:44:46.236]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.236]         }, condition = base::local({
[17:44:46.236]             c <- base::c
[17:44:46.236]             inherits <- base::inherits
[17:44:46.236]             invokeRestart <- base::invokeRestart
[17:44:46.236]             length <- base::length
[17:44:46.236]             list <- base::list
[17:44:46.236]             seq.int <- base::seq.int
[17:44:46.236]             signalCondition <- base::signalCondition
[17:44:46.236]             sys.calls <- base::sys.calls
[17:44:46.236]             `[[` <- base::`[[`
[17:44:46.236]             `+` <- base::`+`
[17:44:46.236]             `<<-` <- base::`<<-`
[17:44:46.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.236]                   3L)]
[17:44:46.236]             }
[17:44:46.236]             function(cond) {
[17:44:46.236]                 is_error <- inherits(cond, "error")
[17:44:46.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.236]                   NULL)
[17:44:46.236]                 if (is_error) {
[17:44:46.236]                   sessionInformation <- function() {
[17:44:46.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.236]                       search = base::search(), system = base::Sys.info())
[17:44:46.236]                   }
[17:44:46.236]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.236]                     cond$call), session = sessionInformation(), 
[17:44:46.236]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.236]                   signalCondition(cond)
[17:44:46.236]                 }
[17:44:46.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.236]                 "immediateCondition"))) {
[17:44:46.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.236]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.236]                   if (TRUE && !signal) {
[17:44:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.236]                     {
[17:44:46.236]                       inherits <- base::inherits
[17:44:46.236]                       invokeRestart <- base::invokeRestart
[17:44:46.236]                       is.null <- base::is.null
[17:44:46.236]                       muffled <- FALSE
[17:44:46.236]                       if (inherits(cond, "message")) {
[17:44:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.236]                         if (muffled) 
[17:44:46.236]                           invokeRestart("muffleMessage")
[17:44:46.236]                       }
[17:44:46.236]                       else if (inherits(cond, "warning")) {
[17:44:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.236]                         if (muffled) 
[17:44:46.236]                           invokeRestart("muffleWarning")
[17:44:46.236]                       }
[17:44:46.236]                       else if (inherits(cond, "condition")) {
[17:44:46.236]                         if (!is.null(pattern)) {
[17:44:46.236]                           computeRestarts <- base::computeRestarts
[17:44:46.236]                           grepl <- base::grepl
[17:44:46.236]                           restarts <- computeRestarts(cond)
[17:44:46.236]                           for (restart in restarts) {
[17:44:46.236]                             name <- restart$name
[17:44:46.236]                             if (is.null(name)) 
[17:44:46.236]                               next
[17:44:46.236]                             if (!grepl(pattern, name)) 
[17:44:46.236]                               next
[17:44:46.236]                             invokeRestart(restart)
[17:44:46.236]                             muffled <- TRUE
[17:44:46.236]                             break
[17:44:46.236]                           }
[17:44:46.236]                         }
[17:44:46.236]                       }
[17:44:46.236]                       invisible(muffled)
[17:44:46.236]                     }
[17:44:46.236]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.236]                   }
[17:44:46.236]                 }
[17:44:46.236]                 else {
[17:44:46.236]                   if (TRUE) {
[17:44:46.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.236]                     {
[17:44:46.236]                       inherits <- base::inherits
[17:44:46.236]                       invokeRestart <- base::invokeRestart
[17:44:46.236]                       is.null <- base::is.null
[17:44:46.236]                       muffled <- FALSE
[17:44:46.236]                       if (inherits(cond, "message")) {
[17:44:46.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.236]                         if (muffled) 
[17:44:46.236]                           invokeRestart("muffleMessage")
[17:44:46.236]                       }
[17:44:46.236]                       else if (inherits(cond, "warning")) {
[17:44:46.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.236]                         if (muffled) 
[17:44:46.236]                           invokeRestart("muffleWarning")
[17:44:46.236]                       }
[17:44:46.236]                       else if (inherits(cond, "condition")) {
[17:44:46.236]                         if (!is.null(pattern)) {
[17:44:46.236]                           computeRestarts <- base::computeRestarts
[17:44:46.236]                           grepl <- base::grepl
[17:44:46.236]                           restarts <- computeRestarts(cond)
[17:44:46.236]                           for (restart in restarts) {
[17:44:46.236]                             name <- restart$name
[17:44:46.236]                             if (is.null(name)) 
[17:44:46.236]                               next
[17:44:46.236]                             if (!grepl(pattern, name)) 
[17:44:46.236]                               next
[17:44:46.236]                             invokeRestart(restart)
[17:44:46.236]                             muffled <- TRUE
[17:44:46.236]                             break
[17:44:46.236]                           }
[17:44:46.236]                         }
[17:44:46.236]                       }
[17:44:46.236]                       invisible(muffled)
[17:44:46.236]                     }
[17:44:46.236]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.236]                   }
[17:44:46.236]                 }
[17:44:46.236]             }
[17:44:46.236]         }))
[17:44:46.236]     }, error = function(ex) {
[17:44:46.236]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.236]                 ...future.rng), started = ...future.startTime, 
[17:44:46.236]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.236]             version = "1.8"), class = "FutureResult")
[17:44:46.236]     }, finally = {
[17:44:46.236]         if (!identical(...future.workdir, getwd())) 
[17:44:46.236]             setwd(...future.workdir)
[17:44:46.236]         {
[17:44:46.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.236]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.236]             }
[17:44:46.236]             base::options(...future.oldOptions)
[17:44:46.236]             if (.Platform$OS.type == "windows") {
[17:44:46.236]                 old_names <- names(...future.oldEnvVars)
[17:44:46.236]                 envs <- base::Sys.getenv()
[17:44:46.236]                 names <- names(envs)
[17:44:46.236]                 common <- intersect(names, old_names)
[17:44:46.236]                 added <- setdiff(names, old_names)
[17:44:46.236]                 removed <- setdiff(old_names, names)
[17:44:46.236]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.236]                   envs[common]]
[17:44:46.236]                 NAMES <- toupper(changed)
[17:44:46.236]                 args <- list()
[17:44:46.236]                 for (kk in seq_along(NAMES)) {
[17:44:46.236]                   name <- changed[[kk]]
[17:44:46.236]                   NAME <- NAMES[[kk]]
[17:44:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.236]                     next
[17:44:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.236]                 }
[17:44:46.236]                 NAMES <- toupper(added)
[17:44:46.236]                 for (kk in seq_along(NAMES)) {
[17:44:46.236]                   name <- added[[kk]]
[17:44:46.236]                   NAME <- NAMES[[kk]]
[17:44:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.236]                     next
[17:44:46.236]                   args[[name]] <- ""
[17:44:46.236]                 }
[17:44:46.236]                 NAMES <- toupper(removed)
[17:44:46.236]                 for (kk in seq_along(NAMES)) {
[17:44:46.236]                   name <- removed[[kk]]
[17:44:46.236]                   NAME <- NAMES[[kk]]
[17:44:46.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.236]                     next
[17:44:46.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.236]                 }
[17:44:46.236]                 if (length(args) > 0) 
[17:44:46.236]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.236]             }
[17:44:46.236]             else {
[17:44:46.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.236]             }
[17:44:46.236]             {
[17:44:46.236]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.236]                   0L) {
[17:44:46.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.236]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.236]                   base::options(opts)
[17:44:46.236]                 }
[17:44:46.236]                 {
[17:44:46.236]                   {
[17:44:46.236]                     base::assign(".Random.seed", c(10407L, -1891762399L, 
[17:44:46.236]                     -1855272286L, 1739498560L, -1880592766L, 
[17:44:46.236]                     1367182738L, -1109387676L), envir = base::globalenv(), 
[17:44:46.236]                       inherits = FALSE)
[17:44:46.236]                     NULL
[17:44:46.236]                   }
[17:44:46.236]                   options(future.plan = NULL)
[17:44:46.236]                   if (is.na(NA_character_)) 
[17:44:46.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.236]                     .init = FALSE)
[17:44:46.236]                 }
[17:44:46.236]             }
[17:44:46.236]         }
[17:44:46.236]     })
[17:44:46.236]     if (TRUE) {
[17:44:46.236]         base::sink(type = "output", split = FALSE)
[17:44:46.236]         if (TRUE) {
[17:44:46.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.236]         }
[17:44:46.236]         else {
[17:44:46.236]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.236]         }
[17:44:46.236]         base::close(...future.stdout)
[17:44:46.236]         ...future.stdout <- NULL
[17:44:46.236]     }
[17:44:46.236]     ...future.result$conditions <- ...future.conditions
[17:44:46.236]     ...future.result$finished <- base::Sys.time()
[17:44:46.236]     ...future.result
[17:44:46.236] }
[17:44:46.238] assign_globals() ...
[17:44:46.238] List of 5
[17:44:46.238]  $ ...future.FUN            :function (x)  
[17:44:46.238]  $ MoreArgs                 : NULL
[17:44:46.238]  $ ...future.elements_ii    :List of 1
[17:44:46.238]   ..$ :List of 2
[17:44:46.238]   .. ..$ a: num 0
[17:44:46.238]   .. ..$ b: num 0
[17:44:46.238]  $ ...future.seeds_ii       : NULL
[17:44:46.238]  $ ...future.globals.maxSize: NULL
[17:44:46.238]  - attr(*, "where")=List of 5
[17:44:46.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.238]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.238]  - attr(*, "resolved")= logi FALSE
[17:44:46.238]  - attr(*, "total_size")= num 960
[17:44:46.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.238]  - attr(*, "already-done")= logi TRUE
[17:44:46.242] - copied ‘...future.FUN’ to environment
[17:44:46.242] - copied ‘MoreArgs’ to environment
[17:44:46.243] - copied ‘...future.elements_ii’ to environment
[17:44:46.243] - copied ‘...future.seeds_ii’ to environment
[17:44:46.243] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.243] assign_globals() ... done
[17:44:46.243] plan(): Setting new future strategy stack:
[17:44:46.243] List of future strategies:
[17:44:46.243] 1. sequential:
[17:44:46.243]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.243]    - tweaked: FALSE
[17:44:46.243]    - call: NULL
[17:44:46.244] plan(): nbrOfWorkers() = 1
[17:44:46.244] plan(): Setting new future strategy stack:
[17:44:46.244] List of future strategies:
[17:44:46.244] 1. sequential:
[17:44:46.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.244]    - tweaked: FALSE
[17:44:46.244]    - call: plan(strategy)
[17:44:46.245] plan(): nbrOfWorkers() = 1
[17:44:46.245] SequentialFuture started (and completed)
[17:44:46.245] - Launch lazy future ... done
[17:44:46.245] run() for ‘SequentialFuture’ ... done
[17:44:46.245] Created future:
[17:44:46.245] SequentialFuture:
[17:44:46.245] Label: ‘future_mapply-1’
[17:44:46.245] Expression:
[17:44:46.245] {
[17:44:46.245]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.245]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.245]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.245]         on.exit(options(oopts), add = TRUE)
[17:44:46.245]     }
[17:44:46.245]     {
[17:44:46.245]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.245]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.245]         do.call(mapply, args = args)
[17:44:46.245]     }
[17:44:46.245] }
[17:44:46.245] Lazy evaluation: FALSE
[17:44:46.245] Asynchronous evaluation: FALSE
[17:44:46.245] Local evaluation: TRUE
[17:44:46.245] Environment: R_GlobalEnv
[17:44:46.245] Capture standard output: TRUE
[17:44:46.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.245] Globals: 5 objects totaling 960 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.245] Packages: <none>
[17:44:46.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.245] Resolved: TRUE
[17:44:46.245] Value: 112 bytes of class ‘list’
[17:44:46.245] Early signaling: FALSE
[17:44:46.245] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.245] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:44:46.246] Chunk #1 of 1 ... DONE
[17:44:46.246] Launching 1 futures (chunks) ... DONE
[17:44:46.246] Resolving 1 futures (chunks) ...
[17:44:46.247] resolve() on list ...
[17:44:46.247]  recursive: 0
[17:44:46.247]  length: 1
[17:44:46.247] 
[17:44:46.247] resolved() for ‘SequentialFuture’ ...
[17:44:46.247] - state: ‘finished’
[17:44:46.247] - run: TRUE
[17:44:46.247] - result: ‘FutureResult’
[17:44:46.247] resolved() for ‘SequentialFuture’ ... done
[17:44:46.247] Future #1
[17:44:46.248] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:44:46.248] - nx: 1
[17:44:46.248] - relay: TRUE
[17:44:46.248] - stdout: TRUE
[17:44:46.248] - signal: TRUE
[17:44:46.248] - resignal: FALSE
[17:44:46.248] - force: TRUE
[17:44:46.248] - relayed: [n=1] FALSE
[17:44:46.248] - queued futures: [n=1] FALSE
[17:44:46.248]  - until=1
[17:44:46.248]  - relaying element #1
[17:44:46.249] - relayed: [n=1] TRUE
[17:44:46.249] - queued futures: [n=1] TRUE
[17:44:46.249] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:44:46.249]  length: 0 (resolved future 1)
[17:44:46.249] Relaying remaining futures
[17:44:46.249] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.249] - nx: 1
[17:44:46.249] - relay: TRUE
[17:44:46.249] - stdout: TRUE
[17:44:46.249] - signal: TRUE
[17:44:46.249] - resignal: FALSE
[17:44:46.249] - force: TRUE
[17:44:46.250] - relayed: [n=1] TRUE
[17:44:46.250] - queued futures: [n=1] TRUE
 - flush all
[17:44:46.250] - relayed: [n=1] TRUE
[17:44:46.250] - queued futures: [n=1] TRUE
[17:44:46.250] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.250] resolve() on list ... DONE
[17:44:46.250]  - Number of value chunks collected: 1
[17:44:46.250] Resolving 1 futures (chunks) ... DONE
[17:44:46.250] Reducing values from 1 chunks ...
[17:44:46.250]  - Number of values collected after concatenation: 2
[17:44:46.251]  - Number of values expected: 2
[17:44:46.251] Reducing values from 1 chunks ... DONE
[17:44:46.251] future_mapply() ... DONE
[17:44:46.251] plan(): Setting new future strategy stack:
[17:44:46.251] List of future strategies:
[17:44:46.251] 1. sequential:
[17:44:46.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.251]    - tweaked: FALSE
[17:44:46.251]    - call: plan(sequential)
[17:44:46.251] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:44:46.252] plan(): Setting new future strategy stack:
[17:44:46.252] List of future strategies:
[17:44:46.252] 1. multicore:
[17:44:46.252]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.252]    - tweaked: FALSE
[17:44:46.252]    - call: plan(strategy)
[17:44:46.256] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:44:46.256] future_mapply() ...
[17:44:46.259] Number of chunks: 2
[17:44:46.260] getGlobalsAndPackagesXApply() ...
[17:44:46.261]  - future.globals: TRUE
[17:44:46.262] getGlobalsAndPackages() ...
[17:44:46.262] Searching for globals...
[17:44:46.262] - globals found: [1] ‘FUN’
[17:44:46.262] Searching for globals ... DONE
[17:44:46.263] Resolving globals: FALSE
[17:44:46.263] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.263] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.263] - globals: [1] ‘FUN’
[17:44:46.264] 
[17:44:46.264] getGlobalsAndPackages() ... DONE
[17:44:46.264]  - globals found/used: [n=1] ‘FUN’
[17:44:46.264]  - needed namespaces: [n=0] 
[17:44:46.264] Finding globals ... DONE
[17:44:46.264] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.264] List of 2
[17:44:46.264]  $ ...future.FUN:function (x, ...)  
[17:44:46.264]  $ MoreArgs     : NULL
[17:44:46.264]  - attr(*, "where")=List of 2
[17:44:46.264]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.264]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.264]  - attr(*, "resolved")= logi FALSE
[17:44:46.264]  - attr(*, "total_size")= num NA
[17:44:46.267] Packages to be attached in all futures: [n=0] 
[17:44:46.267] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.267] Number of futures (= number of chunks): 2
[17:44:46.268] Launching 2 futures (chunks) ...
[17:44:46.268] Chunk #1 of 2 ...
[17:44:46.268]  - Finding globals in '...' for chunk #1 ...
[17:44:46.268] getGlobalsAndPackages() ...
[17:44:46.268] Searching for globals...
[17:44:46.268] 
[17:44:46.268] Searching for globals ... DONE
[17:44:46.268] - globals: [0] <none>
[17:44:46.269] getGlobalsAndPackages() ... DONE
[17:44:46.269]    + additional globals found: [n=0] 
[17:44:46.269]    + additional namespaces needed: [n=0] 
[17:44:46.269]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.269]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.269]  - seeds: <none>
[17:44:46.269]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.269] getGlobalsAndPackages() ...
[17:44:46.269] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.269] Resolving globals: FALSE
[17:44:46.270] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.270] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.270] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.271] 
[17:44:46.271] getGlobalsAndPackages() ... DONE
[17:44:46.271] run() for ‘Future’ ...
[17:44:46.271] - state: ‘created’
[17:44:46.271] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.275]   - Field: ‘label’
[17:44:46.275]   - Field: ‘local’
[17:44:46.275]   - Field: ‘owner’
[17:44:46.275]   - Field: ‘envir’
[17:44:46.275]   - Field: ‘workers’
[17:44:46.275]   - Field: ‘packages’
[17:44:46.276]   - Field: ‘gc’
[17:44:46.276]   - Field: ‘job’
[17:44:46.276]   - Field: ‘conditions’
[17:44:46.276]   - Field: ‘expr’
[17:44:46.276]   - Field: ‘uuid’
[17:44:46.276]   - Field: ‘seed’
[17:44:46.276]   - Field: ‘version’
[17:44:46.276]   - Field: ‘result’
[17:44:46.276]   - Field: ‘asynchronous’
[17:44:46.276]   - Field: ‘calls’
[17:44:46.276]   - Field: ‘globals’
[17:44:46.277]   - Field: ‘stdout’
[17:44:46.277]   - Field: ‘earlySignal’
[17:44:46.277]   - Field: ‘lazy’
[17:44:46.277]   - Field: ‘state’
[17:44:46.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.277] - Launch lazy future ...
[17:44:46.278] Packages needed by the future expression (n = 0): <none>
[17:44:46.278] Packages needed by future strategies (n = 0): <none>
[17:44:46.279] {
[17:44:46.279]     {
[17:44:46.279]         {
[17:44:46.279]             ...future.startTime <- base::Sys.time()
[17:44:46.279]             {
[17:44:46.279]                 {
[17:44:46.279]                   {
[17:44:46.279]                     {
[17:44:46.279]                       base::local({
[17:44:46.279]                         has_future <- base::requireNamespace("future", 
[17:44:46.279]                           quietly = TRUE)
[17:44:46.279]                         if (has_future) {
[17:44:46.279]                           ns <- base::getNamespace("future")
[17:44:46.279]                           version <- ns[[".package"]][["version"]]
[17:44:46.279]                           if (is.null(version)) 
[17:44:46.279]                             version <- utils::packageVersion("future")
[17:44:46.279]                         }
[17:44:46.279]                         else {
[17:44:46.279]                           version <- NULL
[17:44:46.279]                         }
[17:44:46.279]                         if (!has_future || version < "1.8.0") {
[17:44:46.279]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.279]                             "", base::R.version$version.string), 
[17:44:46.279]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.279]                               "release", "version")], collapse = " "), 
[17:44:46.279]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.279]                             info)
[17:44:46.279]                           info <- base::paste(info, collapse = "; ")
[17:44:46.279]                           if (!has_future) {
[17:44:46.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.279]                               info)
[17:44:46.279]                           }
[17:44:46.279]                           else {
[17:44:46.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.279]                               info, version)
[17:44:46.279]                           }
[17:44:46.279]                           base::stop(msg)
[17:44:46.279]                         }
[17:44:46.279]                       })
[17:44:46.279]                     }
[17:44:46.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.279]                     base::options(mc.cores = 1L)
[17:44:46.279]                   }
[17:44:46.279]                   ...future.strategy.old <- future::plan("list")
[17:44:46.279]                   options(future.plan = NULL)
[17:44:46.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.279]                 }
[17:44:46.279]                 ...future.workdir <- getwd()
[17:44:46.279]             }
[17:44:46.279]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.279]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.279]         }
[17:44:46.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.279]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.279]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.279]             base::names(...future.oldOptions))
[17:44:46.279]     }
[17:44:46.279]     if (FALSE) {
[17:44:46.279]     }
[17:44:46.279]     else {
[17:44:46.279]         if (TRUE) {
[17:44:46.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.279]                 open = "w")
[17:44:46.279]         }
[17:44:46.279]         else {
[17:44:46.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.279]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.279]         }
[17:44:46.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.279]             base::sink(type = "output", split = FALSE)
[17:44:46.279]             base::close(...future.stdout)
[17:44:46.279]         }, add = TRUE)
[17:44:46.279]     }
[17:44:46.279]     ...future.frame <- base::sys.nframe()
[17:44:46.279]     ...future.conditions <- base::list()
[17:44:46.279]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.279]     if (FALSE) {
[17:44:46.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.279]     }
[17:44:46.279]     ...future.result <- base::tryCatch({
[17:44:46.279]         base::withCallingHandlers({
[17:44:46.279]             ...future.value <- base::withVisible(base::local({
[17:44:46.279]                 withCallingHandlers({
[17:44:46.279]                   {
[17:44:46.279]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.279]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.279]                       ...future.globals.maxSize)) {
[17:44:46.279]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.279]                       on.exit(options(oopts), add = TRUE)
[17:44:46.279]                     }
[17:44:46.279]                     {
[17:44:46.279]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.279]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.279]                         USE.NAMES = FALSE)
[17:44:46.279]                       do.call(mapply, args = args)
[17:44:46.279]                     }
[17:44:46.279]                   }
[17:44:46.279]                 }, immediateCondition = function(cond) {
[17:44:46.279]                   save_rds <- function (object, pathname, ...) 
[17:44:46.279]                   {
[17:44:46.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.279]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.279]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.279]                         fi_tmp[["mtime"]])
[17:44:46.279]                     }
[17:44:46.279]                     tryCatch({
[17:44:46.279]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.279]                     }, error = function(ex) {
[17:44:46.279]                       msg <- conditionMessage(ex)
[17:44:46.279]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.279]                         fi_tmp[["mtime"]], msg)
[17:44:46.279]                       ex$message <- msg
[17:44:46.279]                       stop(ex)
[17:44:46.279]                     })
[17:44:46.279]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.279]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.279]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.279]                       fi <- file.info(pathname)
[17:44:46.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.279]                         fi[["size"]], fi[["mtime"]])
[17:44:46.279]                       stop(msg)
[17:44:46.279]                     }
[17:44:46.279]                     invisible(pathname)
[17:44:46.279]                   }
[17:44:46.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.279]                     rootPath = tempdir()) 
[17:44:46.279]                   {
[17:44:46.279]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.279]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.279]                       tmpdir = path, fileext = ".rds")
[17:44:46.279]                     save_rds(obj, file)
[17:44:46.279]                   }
[17:44:46.279]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.279]                   {
[17:44:46.279]                     inherits <- base::inherits
[17:44:46.279]                     invokeRestart <- base::invokeRestart
[17:44:46.279]                     is.null <- base::is.null
[17:44:46.279]                     muffled <- FALSE
[17:44:46.279]                     if (inherits(cond, "message")) {
[17:44:46.279]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.279]                       if (muffled) 
[17:44:46.279]                         invokeRestart("muffleMessage")
[17:44:46.279]                     }
[17:44:46.279]                     else if (inherits(cond, "warning")) {
[17:44:46.279]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.279]                       if (muffled) 
[17:44:46.279]                         invokeRestart("muffleWarning")
[17:44:46.279]                     }
[17:44:46.279]                     else if (inherits(cond, "condition")) {
[17:44:46.279]                       if (!is.null(pattern)) {
[17:44:46.279]                         computeRestarts <- base::computeRestarts
[17:44:46.279]                         grepl <- base::grepl
[17:44:46.279]                         restarts <- computeRestarts(cond)
[17:44:46.279]                         for (restart in restarts) {
[17:44:46.279]                           name <- restart$name
[17:44:46.279]                           if (is.null(name)) 
[17:44:46.279]                             next
[17:44:46.279]                           if (!grepl(pattern, name)) 
[17:44:46.279]                             next
[17:44:46.279]                           invokeRestart(restart)
[17:44:46.279]                           muffled <- TRUE
[17:44:46.279]                           break
[17:44:46.279]                         }
[17:44:46.279]                       }
[17:44:46.279]                     }
[17:44:46.279]                     invisible(muffled)
[17:44:46.279]                   }
[17:44:46.279]                   muffleCondition(cond)
[17:44:46.279]                 })
[17:44:46.279]             }))
[17:44:46.279]             future::FutureResult(value = ...future.value$value, 
[17:44:46.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.279]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.279]                     ...future.globalenv.names))
[17:44:46.279]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.279]         }, condition = base::local({
[17:44:46.279]             c <- base::c
[17:44:46.279]             inherits <- base::inherits
[17:44:46.279]             invokeRestart <- base::invokeRestart
[17:44:46.279]             length <- base::length
[17:44:46.279]             list <- base::list
[17:44:46.279]             seq.int <- base::seq.int
[17:44:46.279]             signalCondition <- base::signalCondition
[17:44:46.279]             sys.calls <- base::sys.calls
[17:44:46.279]             `[[` <- base::`[[`
[17:44:46.279]             `+` <- base::`+`
[17:44:46.279]             `<<-` <- base::`<<-`
[17:44:46.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.279]                   3L)]
[17:44:46.279]             }
[17:44:46.279]             function(cond) {
[17:44:46.279]                 is_error <- inherits(cond, "error")
[17:44:46.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.279]                   NULL)
[17:44:46.279]                 if (is_error) {
[17:44:46.279]                   sessionInformation <- function() {
[17:44:46.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.279]                       search = base::search(), system = base::Sys.info())
[17:44:46.279]                   }
[17:44:46.279]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.279]                     cond$call), session = sessionInformation(), 
[17:44:46.279]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.279]                   signalCondition(cond)
[17:44:46.279]                 }
[17:44:46.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.279]                 "immediateCondition"))) {
[17:44:46.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.279]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.279]                   if (TRUE && !signal) {
[17:44:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.279]                     {
[17:44:46.279]                       inherits <- base::inherits
[17:44:46.279]                       invokeRestart <- base::invokeRestart
[17:44:46.279]                       is.null <- base::is.null
[17:44:46.279]                       muffled <- FALSE
[17:44:46.279]                       if (inherits(cond, "message")) {
[17:44:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.279]                         if (muffled) 
[17:44:46.279]                           invokeRestart("muffleMessage")
[17:44:46.279]                       }
[17:44:46.279]                       else if (inherits(cond, "warning")) {
[17:44:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.279]                         if (muffled) 
[17:44:46.279]                           invokeRestart("muffleWarning")
[17:44:46.279]                       }
[17:44:46.279]                       else if (inherits(cond, "condition")) {
[17:44:46.279]                         if (!is.null(pattern)) {
[17:44:46.279]                           computeRestarts <- base::computeRestarts
[17:44:46.279]                           grepl <- base::grepl
[17:44:46.279]                           restarts <- computeRestarts(cond)
[17:44:46.279]                           for (restart in restarts) {
[17:44:46.279]                             name <- restart$name
[17:44:46.279]                             if (is.null(name)) 
[17:44:46.279]                               next
[17:44:46.279]                             if (!grepl(pattern, name)) 
[17:44:46.279]                               next
[17:44:46.279]                             invokeRestart(restart)
[17:44:46.279]                             muffled <- TRUE
[17:44:46.279]                             break
[17:44:46.279]                           }
[17:44:46.279]                         }
[17:44:46.279]                       }
[17:44:46.279]                       invisible(muffled)
[17:44:46.279]                     }
[17:44:46.279]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.279]                   }
[17:44:46.279]                 }
[17:44:46.279]                 else {
[17:44:46.279]                   if (TRUE) {
[17:44:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.279]                     {
[17:44:46.279]                       inherits <- base::inherits
[17:44:46.279]                       invokeRestart <- base::invokeRestart
[17:44:46.279]                       is.null <- base::is.null
[17:44:46.279]                       muffled <- FALSE
[17:44:46.279]                       if (inherits(cond, "message")) {
[17:44:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.279]                         if (muffled) 
[17:44:46.279]                           invokeRestart("muffleMessage")
[17:44:46.279]                       }
[17:44:46.279]                       else if (inherits(cond, "warning")) {
[17:44:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.279]                         if (muffled) 
[17:44:46.279]                           invokeRestart("muffleWarning")
[17:44:46.279]                       }
[17:44:46.279]                       else if (inherits(cond, "condition")) {
[17:44:46.279]                         if (!is.null(pattern)) {
[17:44:46.279]                           computeRestarts <- base::computeRestarts
[17:44:46.279]                           grepl <- base::grepl
[17:44:46.279]                           restarts <- computeRestarts(cond)
[17:44:46.279]                           for (restart in restarts) {
[17:44:46.279]                             name <- restart$name
[17:44:46.279]                             if (is.null(name)) 
[17:44:46.279]                               next
[17:44:46.279]                             if (!grepl(pattern, name)) 
[17:44:46.279]                               next
[17:44:46.279]                             invokeRestart(restart)
[17:44:46.279]                             muffled <- TRUE
[17:44:46.279]                             break
[17:44:46.279]                           }
[17:44:46.279]                         }
[17:44:46.279]                       }
[17:44:46.279]                       invisible(muffled)
[17:44:46.279]                     }
[17:44:46.279]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.279]                   }
[17:44:46.279]                 }
[17:44:46.279]             }
[17:44:46.279]         }))
[17:44:46.279]     }, error = function(ex) {
[17:44:46.279]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.279]                 ...future.rng), started = ...future.startTime, 
[17:44:46.279]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.279]             version = "1.8"), class = "FutureResult")
[17:44:46.279]     }, finally = {
[17:44:46.279]         if (!identical(...future.workdir, getwd())) 
[17:44:46.279]             setwd(...future.workdir)
[17:44:46.279]         {
[17:44:46.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.279]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.279]             }
[17:44:46.279]             base::options(...future.oldOptions)
[17:44:46.279]             if (.Platform$OS.type == "windows") {
[17:44:46.279]                 old_names <- names(...future.oldEnvVars)
[17:44:46.279]                 envs <- base::Sys.getenv()
[17:44:46.279]                 names <- names(envs)
[17:44:46.279]                 common <- intersect(names, old_names)
[17:44:46.279]                 added <- setdiff(names, old_names)
[17:44:46.279]                 removed <- setdiff(old_names, names)
[17:44:46.279]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.279]                   envs[common]]
[17:44:46.279]                 NAMES <- toupper(changed)
[17:44:46.279]                 args <- list()
[17:44:46.279]                 for (kk in seq_along(NAMES)) {
[17:44:46.279]                   name <- changed[[kk]]
[17:44:46.279]                   NAME <- NAMES[[kk]]
[17:44:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.279]                     next
[17:44:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.279]                 }
[17:44:46.279]                 NAMES <- toupper(added)
[17:44:46.279]                 for (kk in seq_along(NAMES)) {
[17:44:46.279]                   name <- added[[kk]]
[17:44:46.279]                   NAME <- NAMES[[kk]]
[17:44:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.279]                     next
[17:44:46.279]                   args[[name]] <- ""
[17:44:46.279]                 }
[17:44:46.279]                 NAMES <- toupper(removed)
[17:44:46.279]                 for (kk in seq_along(NAMES)) {
[17:44:46.279]                   name <- removed[[kk]]
[17:44:46.279]                   NAME <- NAMES[[kk]]
[17:44:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.279]                     next
[17:44:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.279]                 }
[17:44:46.279]                 if (length(args) > 0) 
[17:44:46.279]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.279]             }
[17:44:46.279]             else {
[17:44:46.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.279]             }
[17:44:46.279]             {
[17:44:46.279]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.279]                   0L) {
[17:44:46.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.279]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.279]                   base::options(opts)
[17:44:46.279]                 }
[17:44:46.279]                 {
[17:44:46.279]                   {
[17:44:46.279]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.279]                     NULL
[17:44:46.279]                   }
[17:44:46.279]                   options(future.plan = NULL)
[17:44:46.279]                   if (is.na(NA_character_)) 
[17:44:46.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.279]                     .init = FALSE)
[17:44:46.279]                 }
[17:44:46.279]             }
[17:44:46.279]         }
[17:44:46.279]     })
[17:44:46.279]     if (TRUE) {
[17:44:46.279]         base::sink(type = "output", split = FALSE)
[17:44:46.279]         if (TRUE) {
[17:44:46.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.279]         }
[17:44:46.279]         else {
[17:44:46.279]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.279]         }
[17:44:46.279]         base::close(...future.stdout)
[17:44:46.279]         ...future.stdout <- NULL
[17:44:46.279]     }
[17:44:46.279]     ...future.result$conditions <- ...future.conditions
[17:44:46.279]     ...future.result$finished <- base::Sys.time()
[17:44:46.279]     ...future.result
[17:44:46.279] }
[17:44:46.281] assign_globals() ...
[17:44:46.281] List of 5
[17:44:46.281]  $ ...future.FUN            :function (x, ...)  
[17:44:46.281]  $ MoreArgs                 : NULL
[17:44:46.281]  $ ...future.elements_ii    :List of 2
[17:44:46.281]   ..$ :List of 2
[17:44:46.281]   .. ..$ : int 1
[17:44:46.281]   .. ..$ : int 2
[17:44:46.281]   ..$ :List of 2
[17:44:46.281]   .. ..$ : int 4
[17:44:46.281]   .. ..$ : int 3
[17:44:46.281]  $ ...future.seeds_ii       : NULL
[17:44:46.281]  $ ...future.globals.maxSize: NULL
[17:44:46.281]  - attr(*, "where")=List of 5
[17:44:46.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.281]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.281]  - attr(*, "resolved")= logi FALSE
[17:44:46.281]  - attr(*, "total_size")= num 280
[17:44:46.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.281]  - attr(*, "already-done")= logi TRUE
[17:44:46.286] - copied ‘...future.FUN’ to environment
[17:44:46.287] - copied ‘MoreArgs’ to environment
[17:44:46.287] - copied ‘...future.elements_ii’ to environment
[17:44:46.287] - copied ‘...future.seeds_ii’ to environment
[17:44:46.287] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.287] assign_globals() ... done
[17:44:46.287] requestCore(): workers = 2
[17:44:46.290] MulticoreFuture started
[17:44:46.291] - Launch lazy future ... done
[17:44:46.291] plan(): Setting new future strategy stack:
[17:44:46.291] run() for ‘MulticoreFuture’ ... done
[17:44:46.291] Created future:
[17:44:46.291] List of future strategies:
[17:44:46.291] 1. sequential:
[17:44:46.291]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.291]    - tweaked: FALSE
[17:44:46.291]    - call: NULL
[17:44:46.292] plan(): nbrOfWorkers() = 1
[17:44:46.295] plan(): Setting new future strategy stack:
[17:44:46.295] List of future strategies:
[17:44:46.295] 1. multicore:
[17:44:46.295]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.295]    - tweaked: FALSE
[17:44:46.295]    - call: plan(strategy)
[17:44:46.306] plan(): nbrOfWorkers() = 2
[17:44:46.292] MulticoreFuture:
[17:44:46.292] Label: ‘future_mapply-1’
[17:44:46.292] Expression:
[17:44:46.292] {
[17:44:46.292]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.292]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.292]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.292]         on.exit(options(oopts), add = TRUE)
[17:44:46.292]     }
[17:44:46.292]     {
[17:44:46.292]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.292]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.292]         do.call(mapply, args = args)
[17:44:46.292]     }
[17:44:46.292] }
[17:44:46.292] Lazy evaluation: FALSE
[17:44:46.292] Asynchronous evaluation: TRUE
[17:44:46.292] Local evaluation: TRUE
[17:44:46.292] Environment: R_GlobalEnv
[17:44:46.292] Capture standard output: TRUE
[17:44:46.292] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.292] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.292] Packages: <none>
[17:44:46.292] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.292] Resolved: FALSE
[17:44:46.292] Value: <not collected>
[17:44:46.292] Conditions captured: <none>
[17:44:46.292] Early signaling: FALSE
[17:44:46.292] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.292] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.309] Chunk #1 of 2 ... DONE
[17:44:46.310] Chunk #2 of 2 ...
[17:44:46.310]  - Finding globals in '...' for chunk #2 ...
[17:44:46.310] getGlobalsAndPackages() ...
[17:44:46.311] Searching for globals...
[17:44:46.311] 
[17:44:46.312] Searching for globals ... DONE
[17:44:46.312] - globals: [0] <none>
[17:44:46.312] getGlobalsAndPackages() ... DONE
[17:44:46.312]    + additional globals found: [n=0] 
[17:44:46.312]    + additional namespaces needed: [n=0] 
[17:44:46.313]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.313]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.313]  - seeds: <none>
[17:44:46.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.314] getGlobalsAndPackages() ...
[17:44:46.314] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.314] Resolving globals: FALSE
[17:44:46.315] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.317] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.317] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.317] 
[17:44:46.317] getGlobalsAndPackages() ... DONE
[17:44:46.318] run() for ‘Future’ ...
[17:44:46.318] - state: ‘created’
[17:44:46.318] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.323] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.323]   - Field: ‘label’
[17:44:46.323]   - Field: ‘local’
[17:44:46.323]   - Field: ‘owner’
[17:44:46.323]   - Field: ‘envir’
[17:44:46.324]   - Field: ‘workers’
[17:44:46.324]   - Field: ‘packages’
[17:44:46.324]   - Field: ‘gc’
[17:44:46.324]   - Field: ‘job’
[17:44:46.324]   - Field: ‘conditions’
[17:44:46.324]   - Field: ‘expr’
[17:44:46.325]   - Field: ‘uuid’
[17:44:46.325]   - Field: ‘seed’
[17:44:46.325]   - Field: ‘version’
[17:44:46.325]   - Field: ‘result’
[17:44:46.325]   - Field: ‘asynchronous’
[17:44:46.325]   - Field: ‘calls’
[17:44:46.326]   - Field: ‘globals’
[17:44:46.326]   - Field: ‘stdout’
[17:44:46.326]   - Field: ‘earlySignal’
[17:44:46.326]   - Field: ‘lazy’
[17:44:46.326]   - Field: ‘state’
[17:44:46.326] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.326] - Launch lazy future ...
[17:44:46.327] Packages needed by the future expression (n = 0): <none>
[17:44:46.327] Packages needed by future strategies (n = 0): <none>
[17:44:46.328] {
[17:44:46.328]     {
[17:44:46.328]         {
[17:44:46.328]             ...future.startTime <- base::Sys.time()
[17:44:46.328]             {
[17:44:46.328]                 {
[17:44:46.328]                   {
[17:44:46.328]                     {
[17:44:46.328]                       base::local({
[17:44:46.328]                         has_future <- base::requireNamespace("future", 
[17:44:46.328]                           quietly = TRUE)
[17:44:46.328]                         if (has_future) {
[17:44:46.328]                           ns <- base::getNamespace("future")
[17:44:46.328]                           version <- ns[[".package"]][["version"]]
[17:44:46.328]                           if (is.null(version)) 
[17:44:46.328]                             version <- utils::packageVersion("future")
[17:44:46.328]                         }
[17:44:46.328]                         else {
[17:44:46.328]                           version <- NULL
[17:44:46.328]                         }
[17:44:46.328]                         if (!has_future || version < "1.8.0") {
[17:44:46.328]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.328]                             "", base::R.version$version.string), 
[17:44:46.328]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.328]                               "release", "version")], collapse = " "), 
[17:44:46.328]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.328]                             info)
[17:44:46.328]                           info <- base::paste(info, collapse = "; ")
[17:44:46.328]                           if (!has_future) {
[17:44:46.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.328]                               info)
[17:44:46.328]                           }
[17:44:46.328]                           else {
[17:44:46.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.328]                               info, version)
[17:44:46.328]                           }
[17:44:46.328]                           base::stop(msg)
[17:44:46.328]                         }
[17:44:46.328]                       })
[17:44:46.328]                     }
[17:44:46.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.328]                     base::options(mc.cores = 1L)
[17:44:46.328]                   }
[17:44:46.328]                   ...future.strategy.old <- future::plan("list")
[17:44:46.328]                   options(future.plan = NULL)
[17:44:46.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.328]                 }
[17:44:46.328]                 ...future.workdir <- getwd()
[17:44:46.328]             }
[17:44:46.328]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.328]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.328]         }
[17:44:46.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.328]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.328]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.328]             base::names(...future.oldOptions))
[17:44:46.328]     }
[17:44:46.328]     if (FALSE) {
[17:44:46.328]     }
[17:44:46.328]     else {
[17:44:46.328]         if (TRUE) {
[17:44:46.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.328]                 open = "w")
[17:44:46.328]         }
[17:44:46.328]         else {
[17:44:46.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.328]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.328]         }
[17:44:46.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.328]             base::sink(type = "output", split = FALSE)
[17:44:46.328]             base::close(...future.stdout)
[17:44:46.328]         }, add = TRUE)
[17:44:46.328]     }
[17:44:46.328]     ...future.frame <- base::sys.nframe()
[17:44:46.328]     ...future.conditions <- base::list()
[17:44:46.328]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.328]     if (FALSE) {
[17:44:46.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.328]     }
[17:44:46.328]     ...future.result <- base::tryCatch({
[17:44:46.328]         base::withCallingHandlers({
[17:44:46.328]             ...future.value <- base::withVisible(base::local({
[17:44:46.328]                 withCallingHandlers({
[17:44:46.328]                   {
[17:44:46.328]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.328]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.328]                       ...future.globals.maxSize)) {
[17:44:46.328]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.328]                       on.exit(options(oopts), add = TRUE)
[17:44:46.328]                     }
[17:44:46.328]                     {
[17:44:46.328]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.328]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.328]                         USE.NAMES = FALSE)
[17:44:46.328]                       do.call(mapply, args = args)
[17:44:46.328]                     }
[17:44:46.328]                   }
[17:44:46.328]                 }, immediateCondition = function(cond) {
[17:44:46.328]                   save_rds <- function (object, pathname, ...) 
[17:44:46.328]                   {
[17:44:46.328]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.328]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.328]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.328]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.328]                         fi_tmp[["mtime"]])
[17:44:46.328]                     }
[17:44:46.328]                     tryCatch({
[17:44:46.328]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.328]                     }, error = function(ex) {
[17:44:46.328]                       msg <- conditionMessage(ex)
[17:44:46.328]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.328]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.328]                         fi_tmp[["mtime"]], msg)
[17:44:46.328]                       ex$message <- msg
[17:44:46.328]                       stop(ex)
[17:44:46.328]                     })
[17:44:46.328]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.328]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.328]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.328]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.328]                       fi <- file.info(pathname)
[17:44:46.328]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.328]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.328]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.328]                         fi[["size"]], fi[["mtime"]])
[17:44:46.328]                       stop(msg)
[17:44:46.328]                     }
[17:44:46.328]                     invisible(pathname)
[17:44:46.328]                   }
[17:44:46.328]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.328]                     rootPath = tempdir()) 
[17:44:46.328]                   {
[17:44:46.328]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.328]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.328]                       tmpdir = path, fileext = ".rds")
[17:44:46.328]                     save_rds(obj, file)
[17:44:46.328]                   }
[17:44:46.328]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.328]                   {
[17:44:46.328]                     inherits <- base::inherits
[17:44:46.328]                     invokeRestart <- base::invokeRestart
[17:44:46.328]                     is.null <- base::is.null
[17:44:46.328]                     muffled <- FALSE
[17:44:46.328]                     if (inherits(cond, "message")) {
[17:44:46.328]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.328]                       if (muffled) 
[17:44:46.328]                         invokeRestart("muffleMessage")
[17:44:46.328]                     }
[17:44:46.328]                     else if (inherits(cond, "warning")) {
[17:44:46.328]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.328]                       if (muffled) 
[17:44:46.328]                         invokeRestart("muffleWarning")
[17:44:46.328]                     }
[17:44:46.328]                     else if (inherits(cond, "condition")) {
[17:44:46.328]                       if (!is.null(pattern)) {
[17:44:46.328]                         computeRestarts <- base::computeRestarts
[17:44:46.328]                         grepl <- base::grepl
[17:44:46.328]                         restarts <- computeRestarts(cond)
[17:44:46.328]                         for (restart in restarts) {
[17:44:46.328]                           name <- restart$name
[17:44:46.328]                           if (is.null(name)) 
[17:44:46.328]                             next
[17:44:46.328]                           if (!grepl(pattern, name)) 
[17:44:46.328]                             next
[17:44:46.328]                           invokeRestart(restart)
[17:44:46.328]                           muffled <- TRUE
[17:44:46.328]                           break
[17:44:46.328]                         }
[17:44:46.328]                       }
[17:44:46.328]                     }
[17:44:46.328]                     invisible(muffled)
[17:44:46.328]                   }
[17:44:46.328]                   muffleCondition(cond)
[17:44:46.328]                 })
[17:44:46.328]             }))
[17:44:46.328]             future::FutureResult(value = ...future.value$value, 
[17:44:46.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.328]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.328]                     ...future.globalenv.names))
[17:44:46.328]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.328]         }, condition = base::local({
[17:44:46.328]             c <- base::c
[17:44:46.328]             inherits <- base::inherits
[17:44:46.328]             invokeRestart <- base::invokeRestart
[17:44:46.328]             length <- base::length
[17:44:46.328]             list <- base::list
[17:44:46.328]             seq.int <- base::seq.int
[17:44:46.328]             signalCondition <- base::signalCondition
[17:44:46.328]             sys.calls <- base::sys.calls
[17:44:46.328]             `[[` <- base::`[[`
[17:44:46.328]             `+` <- base::`+`
[17:44:46.328]             `<<-` <- base::`<<-`
[17:44:46.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.328]                   3L)]
[17:44:46.328]             }
[17:44:46.328]             function(cond) {
[17:44:46.328]                 is_error <- inherits(cond, "error")
[17:44:46.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.328]                   NULL)
[17:44:46.328]                 if (is_error) {
[17:44:46.328]                   sessionInformation <- function() {
[17:44:46.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.328]                       search = base::search(), system = base::Sys.info())
[17:44:46.328]                   }
[17:44:46.328]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.328]                     cond$call), session = sessionInformation(), 
[17:44:46.328]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.328]                   signalCondition(cond)
[17:44:46.328]                 }
[17:44:46.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.328]                 "immediateCondition"))) {
[17:44:46.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.328]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.328]                   if (TRUE && !signal) {
[17:44:46.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.328]                     {
[17:44:46.328]                       inherits <- base::inherits
[17:44:46.328]                       invokeRestart <- base::invokeRestart
[17:44:46.328]                       is.null <- base::is.null
[17:44:46.328]                       muffled <- FALSE
[17:44:46.328]                       if (inherits(cond, "message")) {
[17:44:46.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.328]                         if (muffled) 
[17:44:46.328]                           invokeRestart("muffleMessage")
[17:44:46.328]                       }
[17:44:46.328]                       else if (inherits(cond, "warning")) {
[17:44:46.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.328]                         if (muffled) 
[17:44:46.328]                           invokeRestart("muffleWarning")
[17:44:46.328]                       }
[17:44:46.328]                       else if (inherits(cond, "condition")) {
[17:44:46.328]                         if (!is.null(pattern)) {
[17:44:46.328]                           computeRestarts <- base::computeRestarts
[17:44:46.328]                           grepl <- base::grepl
[17:44:46.328]                           restarts <- computeRestarts(cond)
[17:44:46.328]                           for (restart in restarts) {
[17:44:46.328]                             name <- restart$name
[17:44:46.328]                             if (is.null(name)) 
[17:44:46.328]                               next
[17:44:46.328]                             if (!grepl(pattern, name)) 
[17:44:46.328]                               next
[17:44:46.328]                             invokeRestart(restart)
[17:44:46.328]                             muffled <- TRUE
[17:44:46.328]                             break
[17:44:46.328]                           }
[17:44:46.328]                         }
[17:44:46.328]                       }
[17:44:46.328]                       invisible(muffled)
[17:44:46.328]                     }
[17:44:46.328]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.328]                   }
[17:44:46.328]                 }
[17:44:46.328]                 else {
[17:44:46.328]                   if (TRUE) {
[17:44:46.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.328]                     {
[17:44:46.328]                       inherits <- base::inherits
[17:44:46.328]                       invokeRestart <- base::invokeRestart
[17:44:46.328]                       is.null <- base::is.null
[17:44:46.328]                       muffled <- FALSE
[17:44:46.328]                       if (inherits(cond, "message")) {
[17:44:46.328]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.328]                         if (muffled) 
[17:44:46.328]                           invokeRestart("muffleMessage")
[17:44:46.328]                       }
[17:44:46.328]                       else if (inherits(cond, "warning")) {
[17:44:46.328]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.328]                         if (muffled) 
[17:44:46.328]                           invokeRestart("muffleWarning")
[17:44:46.328]                       }
[17:44:46.328]                       else if (inherits(cond, "condition")) {
[17:44:46.328]                         if (!is.null(pattern)) {
[17:44:46.328]                           computeRestarts <- base::computeRestarts
[17:44:46.328]                           grepl <- base::grepl
[17:44:46.328]                           restarts <- computeRestarts(cond)
[17:44:46.328]                           for (restart in restarts) {
[17:44:46.328]                             name <- restart$name
[17:44:46.328]                             if (is.null(name)) 
[17:44:46.328]                               next
[17:44:46.328]                             if (!grepl(pattern, name)) 
[17:44:46.328]                               next
[17:44:46.328]                             invokeRestart(restart)
[17:44:46.328]                             muffled <- TRUE
[17:44:46.328]                             break
[17:44:46.328]                           }
[17:44:46.328]                         }
[17:44:46.328]                       }
[17:44:46.328]                       invisible(muffled)
[17:44:46.328]                     }
[17:44:46.328]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.328]                   }
[17:44:46.328]                 }
[17:44:46.328]             }
[17:44:46.328]         }))
[17:44:46.328]     }, error = function(ex) {
[17:44:46.328]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.328]                 ...future.rng), started = ...future.startTime, 
[17:44:46.328]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.328]             version = "1.8"), class = "FutureResult")
[17:44:46.328]     }, finally = {
[17:44:46.328]         if (!identical(...future.workdir, getwd())) 
[17:44:46.328]             setwd(...future.workdir)
[17:44:46.328]         {
[17:44:46.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.328]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.328]             }
[17:44:46.328]             base::options(...future.oldOptions)
[17:44:46.328]             if (.Platform$OS.type == "windows") {
[17:44:46.328]                 old_names <- names(...future.oldEnvVars)
[17:44:46.328]                 envs <- base::Sys.getenv()
[17:44:46.328]                 names <- names(envs)
[17:44:46.328]                 common <- intersect(names, old_names)
[17:44:46.328]                 added <- setdiff(names, old_names)
[17:44:46.328]                 removed <- setdiff(old_names, names)
[17:44:46.328]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.328]                   envs[common]]
[17:44:46.328]                 NAMES <- toupper(changed)
[17:44:46.328]                 args <- list()
[17:44:46.328]                 for (kk in seq_along(NAMES)) {
[17:44:46.328]                   name <- changed[[kk]]
[17:44:46.328]                   NAME <- NAMES[[kk]]
[17:44:46.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.328]                     next
[17:44:46.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.328]                 }
[17:44:46.328]                 NAMES <- toupper(added)
[17:44:46.328]                 for (kk in seq_along(NAMES)) {
[17:44:46.328]                   name <- added[[kk]]
[17:44:46.328]                   NAME <- NAMES[[kk]]
[17:44:46.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.328]                     next
[17:44:46.328]                   args[[name]] <- ""
[17:44:46.328]                 }
[17:44:46.328]                 NAMES <- toupper(removed)
[17:44:46.328]                 for (kk in seq_along(NAMES)) {
[17:44:46.328]                   name <- removed[[kk]]
[17:44:46.328]                   NAME <- NAMES[[kk]]
[17:44:46.328]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.328]                     next
[17:44:46.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.328]                 }
[17:44:46.328]                 if (length(args) > 0) 
[17:44:46.328]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.328]             }
[17:44:46.328]             else {
[17:44:46.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.328]             }
[17:44:46.328]             {
[17:44:46.328]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.328]                   0L) {
[17:44:46.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.328]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.328]                   base::options(opts)
[17:44:46.328]                 }
[17:44:46.328]                 {
[17:44:46.328]                   {
[17:44:46.328]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.328]                     NULL
[17:44:46.328]                   }
[17:44:46.328]                   options(future.plan = NULL)
[17:44:46.328]                   if (is.na(NA_character_)) 
[17:44:46.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.328]                     .init = FALSE)
[17:44:46.328]                 }
[17:44:46.328]             }
[17:44:46.328]         }
[17:44:46.328]     })
[17:44:46.328]     if (TRUE) {
[17:44:46.328]         base::sink(type = "output", split = FALSE)
[17:44:46.328]         if (TRUE) {
[17:44:46.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.328]         }
[17:44:46.328]         else {
[17:44:46.328]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.328]         }
[17:44:46.328]         base::close(...future.stdout)
[17:44:46.328]         ...future.stdout <- NULL
[17:44:46.328]     }
[17:44:46.328]     ...future.result$conditions <- ...future.conditions
[17:44:46.328]     ...future.result$finished <- base::Sys.time()
[17:44:46.328]     ...future.result
[17:44:46.328] }
[17:44:46.330] assign_globals() ...
[17:44:46.330] List of 5
[17:44:46.330]  $ ...future.FUN            :function (x, ...)  
[17:44:46.330]  $ MoreArgs                 : NULL
[17:44:46.330]  $ ...future.elements_ii    :List of 2
[17:44:46.330]   ..$ :List of 2
[17:44:46.330]   .. ..$ : int 3
[17:44:46.330]   .. ..$ : int 4
[17:44:46.330]   ..$ :List of 2
[17:44:46.330]   .. ..$ : int 2
[17:44:46.330]   .. ..$ : int 1
[17:44:46.330]  $ ...future.seeds_ii       : NULL
[17:44:46.330]  $ ...future.globals.maxSize: NULL
[17:44:46.330]  - attr(*, "where")=List of 5
[17:44:46.330]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.330]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.330]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.330]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.330]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.330]  - attr(*, "resolved")= logi FALSE
[17:44:46.330]  - attr(*, "total_size")= num 280
[17:44:46.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.330]  - attr(*, "already-done")= logi TRUE
[17:44:46.337] - copied ‘...future.FUN’ to environment
[17:44:46.337] - copied ‘MoreArgs’ to environment
[17:44:46.337] - copied ‘...future.elements_ii’ to environment
[17:44:46.338] - copied ‘...future.seeds_ii’ to environment
[17:44:46.338] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.338] assign_globals() ... done
[17:44:46.338] requestCore(): workers = 2
[17:44:46.343] MulticoreFuture started
[17:44:46.344] - Launch lazy future ... done
[17:44:46.344] run() for ‘MulticoreFuture’ ... done
[17:44:46.344] Created future:
[17:44:46.344] plan(): Setting new future strategy stack:
[17:44:46.345] List of future strategies:
[17:44:46.345] 1. sequential:
[17:44:46.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.345]    - tweaked: FALSE
[17:44:46.345]    - call: NULL
[17:44:46.346] plan(): nbrOfWorkers() = 1
[17:44:46.348] plan(): Setting new future strategy stack:
[17:44:46.348] List of future strategies:
[17:44:46.348] 1. multicore:
[17:44:46.348]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.348]    - tweaked: FALSE
[17:44:46.348]    - call: plan(strategy)
[17:44:46.353] plan(): nbrOfWorkers() = 2
[17:44:46.344] MulticoreFuture:
[17:44:46.344] Label: ‘future_mapply-2’
[17:44:46.344] Expression:
[17:44:46.344] {
[17:44:46.344]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.344]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.344]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.344]         on.exit(options(oopts), add = TRUE)
[17:44:46.344]     }
[17:44:46.344]     {
[17:44:46.344]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.344]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.344]         do.call(mapply, args = args)
[17:44:46.344]     }
[17:44:46.344] }
[17:44:46.344] Lazy evaluation: FALSE
[17:44:46.344] Asynchronous evaluation: TRUE
[17:44:46.344] Local evaluation: TRUE
[17:44:46.344] Environment: R_GlobalEnv
[17:44:46.344] Capture standard output: TRUE
[17:44:46.344] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.344] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.344] Packages: <none>
[17:44:46.344] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.344] Resolved: TRUE
[17:44:46.344] Value: <not collected>
[17:44:46.344] Conditions captured: <none>
[17:44:46.344] Early signaling: FALSE
[17:44:46.344] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.344] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.354] Chunk #2 of 2 ... DONE
[17:44:46.354] Launching 2 futures (chunks) ... DONE
[17:44:46.355] Resolving 2 futures (chunks) ...
[17:44:46.355] resolve() on list ...
[17:44:46.355]  recursive: 0
[17:44:46.355]  length: 2
[17:44:46.355] 
[17:44:46.356] Future #1
[17:44:46.356] result() for MulticoreFuture ...
[17:44:46.358] result() for MulticoreFuture ...
[17:44:46.358] result() for MulticoreFuture ... done
[17:44:46.359] result() for MulticoreFuture ... done
[17:44:46.359] result() for MulticoreFuture ...
[17:44:46.359] result() for MulticoreFuture ... done
[17:44:46.359] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.359] - nx: 2
[17:44:46.359] - relay: TRUE
[17:44:46.359] - stdout: TRUE
[17:44:46.360] - signal: TRUE
[17:44:46.360] - resignal: FALSE
[17:44:46.364] - force: TRUE
[17:44:46.364] - relayed: [n=2] FALSE, FALSE
[17:44:46.364] - queued futures: [n=2] FALSE, FALSE
[17:44:46.365]  - until=1
[17:44:46.365]  - relaying element #1
[17:44:46.365] result() for MulticoreFuture ...
[17:44:46.366] result() for MulticoreFuture ... done
[17:44:46.366] result() for MulticoreFuture ...
[17:44:46.366] result() for MulticoreFuture ... done
[17:44:46.367] result() for MulticoreFuture ...
[17:44:46.367] result() for MulticoreFuture ... done
[17:44:46.367] result() for MulticoreFuture ...
[17:44:46.367] result() for MulticoreFuture ... done
[17:44:46.368] - relayed: [n=2] TRUE, FALSE
[17:44:46.368] - queued futures: [n=2] TRUE, FALSE
[17:44:46.368] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.368]  length: 1 (resolved future 1)
[17:44:46.369] Future #2
[17:44:46.369] result() for MulticoreFuture ...
[17:44:46.370] result() for MulticoreFuture ...
[17:44:46.370] result() for MulticoreFuture ... done
[17:44:46.370] result() for MulticoreFuture ... done
[17:44:46.371] result() for MulticoreFuture ...
[17:44:46.371] result() for MulticoreFuture ... done
[17:44:46.371] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.371] - nx: 2
[17:44:46.372] - relay: TRUE
[17:44:46.372] - stdout: TRUE
[17:44:46.372] - signal: TRUE
[17:44:46.372] - resignal: FALSE
[17:44:46.372] - force: TRUE
[17:44:46.372] - relayed: [n=2] TRUE, FALSE
[17:44:46.372] - queued futures: [n=2] TRUE, FALSE
[17:44:46.372]  - until=2
[17:44:46.373]  - relaying element #2
[17:44:46.373] result() for MulticoreFuture ...
[17:44:46.373] result() for MulticoreFuture ... done
[17:44:46.373] result() for MulticoreFuture ...
[17:44:46.373] result() for MulticoreFuture ... done
[17:44:46.373] result() for MulticoreFuture ...
[17:44:46.373] result() for MulticoreFuture ... done
[17:44:46.373] result() for MulticoreFuture ...
[17:44:46.374] result() for MulticoreFuture ... done
[17:44:46.374] - relayed: [n=2] TRUE, TRUE
[17:44:46.374] - queued futures: [n=2] TRUE, TRUE
[17:44:46.374] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.374]  length: 0 (resolved future 2)
[17:44:46.374] Relaying remaining futures
[17:44:46.374] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.374] - nx: 2
[17:44:46.374] - relay: TRUE
[17:44:46.375] - stdout: TRUE
[17:44:46.375] - signal: TRUE
[17:44:46.375] - resignal: FALSE
[17:44:46.375] - force: TRUE
[17:44:46.375] - relayed: [n=2] TRUE, TRUE
[17:44:46.375] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.375] - relayed: [n=2] TRUE, TRUE
[17:44:46.375] - queued futures: [n=2] TRUE, TRUE
[17:44:46.376] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.376] resolve() on list ... DONE
[17:44:46.376] result() for MulticoreFuture ...
[17:44:46.376] result() for MulticoreFuture ... done
[17:44:46.376] result() for MulticoreFuture ...
[17:44:46.376] result() for MulticoreFuture ... done
[17:44:46.376] result() for MulticoreFuture ...
[17:44:46.376] result() for MulticoreFuture ... done
[17:44:46.376] result() for MulticoreFuture ...
[17:44:46.377] result() for MulticoreFuture ... done
[17:44:46.377]  - Number of value chunks collected: 2
[17:44:46.377] Resolving 2 futures (chunks) ... DONE
[17:44:46.377] Reducing values from 2 chunks ...
[17:44:46.377]  - Number of values collected after concatenation: 4
[17:44:46.377]  - Number of values expected: 4
[17:44:46.377] Reducing values from 2 chunks ... DONE
[17:44:46.377] future_mapply() ... DONE
[17:44:46.377] future_mapply() ...
[17:44:46.382] Number of chunks: 2
[17:44:46.382] getGlobalsAndPackagesXApply() ...
[17:44:46.382]  - future.globals: TRUE
[17:44:46.382] getGlobalsAndPackages() ...
[17:44:46.382] Searching for globals...
[17:44:46.383] - globals found: [1] ‘FUN’
[17:44:46.383] Searching for globals ... DONE
[17:44:46.383] Resolving globals: FALSE
[17:44:46.384] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.384] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.384] - globals: [1] ‘FUN’
[17:44:46.384] 
[17:44:46.384] getGlobalsAndPackages() ... DONE
[17:44:46.385]  - globals found/used: [n=1] ‘FUN’
[17:44:46.385]  - needed namespaces: [n=0] 
[17:44:46.385] Finding globals ... DONE
[17:44:46.385] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.385] List of 2
[17:44:46.385]  $ ...future.FUN:function (x, ...)  
[17:44:46.385]  $ MoreArgs     : NULL
[17:44:46.385]  - attr(*, "where")=List of 2
[17:44:46.385]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.385]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.385]  - attr(*, "resolved")= logi FALSE
[17:44:46.385]  - attr(*, "total_size")= num NA
[17:44:46.388] Packages to be attached in all futures: [n=0] 
[17:44:46.388] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.388] Number of futures (= number of chunks): 2
[17:44:46.388] Launching 2 futures (chunks) ...
[17:44:46.388] Chunk #1 of 2 ...
[17:44:46.389]  - Finding globals in '...' for chunk #1 ...
[17:44:46.389] getGlobalsAndPackages() ...
[17:44:46.389] Searching for globals...
[17:44:46.389] 
[17:44:46.389] Searching for globals ... DONE
[17:44:46.389] - globals: [0] <none>
[17:44:46.389] getGlobalsAndPackages() ... DONE
[17:44:46.390]    + additional globals found: [n=0] 
[17:44:46.390]    + additional namespaces needed: [n=0] 
[17:44:46.390]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.390]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.390]  - seeds: <none>
[17:44:46.390]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.390] getGlobalsAndPackages() ...
[17:44:46.390] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.390] Resolving globals: FALSE
[17:44:46.391] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.392] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.392] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.392] 
[17:44:46.392] getGlobalsAndPackages() ... DONE
[17:44:46.392] run() for ‘Future’ ...
[17:44:46.392] - state: ‘created’
[17:44:46.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.396]   - Field: ‘label’
[17:44:46.397]   - Field: ‘local’
[17:44:46.397]   - Field: ‘owner’
[17:44:46.397]   - Field: ‘envir’
[17:44:46.397]   - Field: ‘workers’
[17:44:46.397]   - Field: ‘packages’
[17:44:46.397]   - Field: ‘gc’
[17:44:46.397]   - Field: ‘job’
[17:44:46.397]   - Field: ‘conditions’
[17:44:46.397]   - Field: ‘expr’
[17:44:46.397]   - Field: ‘uuid’
[17:44:46.397]   - Field: ‘seed’
[17:44:46.398]   - Field: ‘version’
[17:44:46.398]   - Field: ‘result’
[17:44:46.398]   - Field: ‘asynchronous’
[17:44:46.398]   - Field: ‘calls’
[17:44:46.398]   - Field: ‘globals’
[17:44:46.398]   - Field: ‘stdout’
[17:44:46.398]   - Field: ‘earlySignal’
[17:44:46.398]   - Field: ‘lazy’
[17:44:46.398]   - Field: ‘state’
[17:44:46.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.400] - Launch lazy future ...
[17:44:46.401] Packages needed by the future expression (n = 0): <none>
[17:44:46.401] Packages needed by future strategies (n = 0): <none>
[17:44:46.401] {
[17:44:46.401]     {
[17:44:46.401]         {
[17:44:46.401]             ...future.startTime <- base::Sys.time()
[17:44:46.401]             {
[17:44:46.401]                 {
[17:44:46.401]                   {
[17:44:46.401]                     {
[17:44:46.401]                       base::local({
[17:44:46.401]                         has_future <- base::requireNamespace("future", 
[17:44:46.401]                           quietly = TRUE)
[17:44:46.401]                         if (has_future) {
[17:44:46.401]                           ns <- base::getNamespace("future")
[17:44:46.401]                           version <- ns[[".package"]][["version"]]
[17:44:46.401]                           if (is.null(version)) 
[17:44:46.401]                             version <- utils::packageVersion("future")
[17:44:46.401]                         }
[17:44:46.401]                         else {
[17:44:46.401]                           version <- NULL
[17:44:46.401]                         }
[17:44:46.401]                         if (!has_future || version < "1.8.0") {
[17:44:46.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.401]                             "", base::R.version$version.string), 
[17:44:46.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.401]                               "release", "version")], collapse = " "), 
[17:44:46.401]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.401]                             info)
[17:44:46.401]                           info <- base::paste(info, collapse = "; ")
[17:44:46.401]                           if (!has_future) {
[17:44:46.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.401]                               info)
[17:44:46.401]                           }
[17:44:46.401]                           else {
[17:44:46.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.401]                               info, version)
[17:44:46.401]                           }
[17:44:46.401]                           base::stop(msg)
[17:44:46.401]                         }
[17:44:46.401]                       })
[17:44:46.401]                     }
[17:44:46.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.401]                     base::options(mc.cores = 1L)
[17:44:46.401]                   }
[17:44:46.401]                   ...future.strategy.old <- future::plan("list")
[17:44:46.401]                   options(future.plan = NULL)
[17:44:46.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.401]                 }
[17:44:46.401]                 ...future.workdir <- getwd()
[17:44:46.401]             }
[17:44:46.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.401]         }
[17:44:46.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.401]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.401]             base::names(...future.oldOptions))
[17:44:46.401]     }
[17:44:46.401]     if (FALSE) {
[17:44:46.401]     }
[17:44:46.401]     else {
[17:44:46.401]         if (TRUE) {
[17:44:46.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.401]                 open = "w")
[17:44:46.401]         }
[17:44:46.401]         else {
[17:44:46.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.401]         }
[17:44:46.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.401]             base::sink(type = "output", split = FALSE)
[17:44:46.401]             base::close(...future.stdout)
[17:44:46.401]         }, add = TRUE)
[17:44:46.401]     }
[17:44:46.401]     ...future.frame <- base::sys.nframe()
[17:44:46.401]     ...future.conditions <- base::list()
[17:44:46.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.401]     if (FALSE) {
[17:44:46.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.401]     }
[17:44:46.401]     ...future.result <- base::tryCatch({
[17:44:46.401]         base::withCallingHandlers({
[17:44:46.401]             ...future.value <- base::withVisible(base::local({
[17:44:46.401]                 withCallingHandlers({
[17:44:46.401]                   {
[17:44:46.401]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.401]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.401]                       ...future.globals.maxSize)) {
[17:44:46.401]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.401]                       on.exit(options(oopts), add = TRUE)
[17:44:46.401]                     }
[17:44:46.401]                     {
[17:44:46.401]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.401]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.401]                         USE.NAMES = FALSE)
[17:44:46.401]                       do.call(mapply, args = args)
[17:44:46.401]                     }
[17:44:46.401]                   }
[17:44:46.401]                 }, immediateCondition = function(cond) {
[17:44:46.401]                   save_rds <- function (object, pathname, ...) 
[17:44:46.401]                   {
[17:44:46.401]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.401]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.401]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.401]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.401]                         fi_tmp[["mtime"]])
[17:44:46.401]                     }
[17:44:46.401]                     tryCatch({
[17:44:46.401]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.401]                     }, error = function(ex) {
[17:44:46.401]                       msg <- conditionMessage(ex)
[17:44:46.401]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.401]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.401]                         fi_tmp[["mtime"]], msg)
[17:44:46.401]                       ex$message <- msg
[17:44:46.401]                       stop(ex)
[17:44:46.401]                     })
[17:44:46.401]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.401]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.401]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.401]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.401]                       fi <- file.info(pathname)
[17:44:46.401]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.401]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.401]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.401]                         fi[["size"]], fi[["mtime"]])
[17:44:46.401]                       stop(msg)
[17:44:46.401]                     }
[17:44:46.401]                     invisible(pathname)
[17:44:46.401]                   }
[17:44:46.401]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.401]                     rootPath = tempdir()) 
[17:44:46.401]                   {
[17:44:46.401]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.401]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.401]                       tmpdir = path, fileext = ".rds")
[17:44:46.401]                     save_rds(obj, file)
[17:44:46.401]                   }
[17:44:46.401]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.401]                   {
[17:44:46.401]                     inherits <- base::inherits
[17:44:46.401]                     invokeRestart <- base::invokeRestart
[17:44:46.401]                     is.null <- base::is.null
[17:44:46.401]                     muffled <- FALSE
[17:44:46.401]                     if (inherits(cond, "message")) {
[17:44:46.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.401]                       if (muffled) 
[17:44:46.401]                         invokeRestart("muffleMessage")
[17:44:46.401]                     }
[17:44:46.401]                     else if (inherits(cond, "warning")) {
[17:44:46.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.401]                       if (muffled) 
[17:44:46.401]                         invokeRestart("muffleWarning")
[17:44:46.401]                     }
[17:44:46.401]                     else if (inherits(cond, "condition")) {
[17:44:46.401]                       if (!is.null(pattern)) {
[17:44:46.401]                         computeRestarts <- base::computeRestarts
[17:44:46.401]                         grepl <- base::grepl
[17:44:46.401]                         restarts <- computeRestarts(cond)
[17:44:46.401]                         for (restart in restarts) {
[17:44:46.401]                           name <- restart$name
[17:44:46.401]                           if (is.null(name)) 
[17:44:46.401]                             next
[17:44:46.401]                           if (!grepl(pattern, name)) 
[17:44:46.401]                             next
[17:44:46.401]                           invokeRestart(restart)
[17:44:46.401]                           muffled <- TRUE
[17:44:46.401]                           break
[17:44:46.401]                         }
[17:44:46.401]                       }
[17:44:46.401]                     }
[17:44:46.401]                     invisible(muffled)
[17:44:46.401]                   }
[17:44:46.401]                   muffleCondition(cond)
[17:44:46.401]                 })
[17:44:46.401]             }))
[17:44:46.401]             future::FutureResult(value = ...future.value$value, 
[17:44:46.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.401]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.401]                     ...future.globalenv.names))
[17:44:46.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.401]         }, condition = base::local({
[17:44:46.401]             c <- base::c
[17:44:46.401]             inherits <- base::inherits
[17:44:46.401]             invokeRestart <- base::invokeRestart
[17:44:46.401]             length <- base::length
[17:44:46.401]             list <- base::list
[17:44:46.401]             seq.int <- base::seq.int
[17:44:46.401]             signalCondition <- base::signalCondition
[17:44:46.401]             sys.calls <- base::sys.calls
[17:44:46.401]             `[[` <- base::`[[`
[17:44:46.401]             `+` <- base::`+`
[17:44:46.401]             `<<-` <- base::`<<-`
[17:44:46.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.401]                   3L)]
[17:44:46.401]             }
[17:44:46.401]             function(cond) {
[17:44:46.401]                 is_error <- inherits(cond, "error")
[17:44:46.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.401]                   NULL)
[17:44:46.401]                 if (is_error) {
[17:44:46.401]                   sessionInformation <- function() {
[17:44:46.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.401]                       search = base::search(), system = base::Sys.info())
[17:44:46.401]                   }
[17:44:46.401]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.401]                     cond$call), session = sessionInformation(), 
[17:44:46.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.401]                   signalCondition(cond)
[17:44:46.401]                 }
[17:44:46.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.401]                 "immediateCondition"))) {
[17:44:46.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.401]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.401]                   if (TRUE && !signal) {
[17:44:46.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.401]                     {
[17:44:46.401]                       inherits <- base::inherits
[17:44:46.401]                       invokeRestart <- base::invokeRestart
[17:44:46.401]                       is.null <- base::is.null
[17:44:46.401]                       muffled <- FALSE
[17:44:46.401]                       if (inherits(cond, "message")) {
[17:44:46.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.401]                         if (muffled) 
[17:44:46.401]                           invokeRestart("muffleMessage")
[17:44:46.401]                       }
[17:44:46.401]                       else if (inherits(cond, "warning")) {
[17:44:46.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.401]                         if (muffled) 
[17:44:46.401]                           invokeRestart("muffleWarning")
[17:44:46.401]                       }
[17:44:46.401]                       else if (inherits(cond, "condition")) {
[17:44:46.401]                         if (!is.null(pattern)) {
[17:44:46.401]                           computeRestarts <- base::computeRestarts
[17:44:46.401]                           grepl <- base::grepl
[17:44:46.401]                           restarts <- computeRestarts(cond)
[17:44:46.401]                           for (restart in restarts) {
[17:44:46.401]                             name <- restart$name
[17:44:46.401]                             if (is.null(name)) 
[17:44:46.401]                               next
[17:44:46.401]                             if (!grepl(pattern, name)) 
[17:44:46.401]                               next
[17:44:46.401]                             invokeRestart(restart)
[17:44:46.401]                             muffled <- TRUE
[17:44:46.401]                             break
[17:44:46.401]                           }
[17:44:46.401]                         }
[17:44:46.401]                       }
[17:44:46.401]                       invisible(muffled)
[17:44:46.401]                     }
[17:44:46.401]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.401]                   }
[17:44:46.401]                 }
[17:44:46.401]                 else {
[17:44:46.401]                   if (TRUE) {
[17:44:46.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.401]                     {
[17:44:46.401]                       inherits <- base::inherits
[17:44:46.401]                       invokeRestart <- base::invokeRestart
[17:44:46.401]                       is.null <- base::is.null
[17:44:46.401]                       muffled <- FALSE
[17:44:46.401]                       if (inherits(cond, "message")) {
[17:44:46.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.401]                         if (muffled) 
[17:44:46.401]                           invokeRestart("muffleMessage")
[17:44:46.401]                       }
[17:44:46.401]                       else if (inherits(cond, "warning")) {
[17:44:46.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.401]                         if (muffled) 
[17:44:46.401]                           invokeRestart("muffleWarning")
[17:44:46.401]                       }
[17:44:46.401]                       else if (inherits(cond, "condition")) {
[17:44:46.401]                         if (!is.null(pattern)) {
[17:44:46.401]                           computeRestarts <- base::computeRestarts
[17:44:46.401]                           grepl <- base::grepl
[17:44:46.401]                           restarts <- computeRestarts(cond)
[17:44:46.401]                           for (restart in restarts) {
[17:44:46.401]                             name <- restart$name
[17:44:46.401]                             if (is.null(name)) 
[17:44:46.401]                               next
[17:44:46.401]                             if (!grepl(pattern, name)) 
[17:44:46.401]                               next
[17:44:46.401]                             invokeRestart(restart)
[17:44:46.401]                             muffled <- TRUE
[17:44:46.401]                             break
[17:44:46.401]                           }
[17:44:46.401]                         }
[17:44:46.401]                       }
[17:44:46.401]                       invisible(muffled)
[17:44:46.401]                     }
[17:44:46.401]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.401]                   }
[17:44:46.401]                 }
[17:44:46.401]             }
[17:44:46.401]         }))
[17:44:46.401]     }, error = function(ex) {
[17:44:46.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.401]                 ...future.rng), started = ...future.startTime, 
[17:44:46.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.401]             version = "1.8"), class = "FutureResult")
[17:44:46.401]     }, finally = {
[17:44:46.401]         if (!identical(...future.workdir, getwd())) 
[17:44:46.401]             setwd(...future.workdir)
[17:44:46.401]         {
[17:44:46.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.401]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.401]             }
[17:44:46.401]             base::options(...future.oldOptions)
[17:44:46.401]             if (.Platform$OS.type == "windows") {
[17:44:46.401]                 old_names <- names(...future.oldEnvVars)
[17:44:46.401]                 envs <- base::Sys.getenv()
[17:44:46.401]                 names <- names(envs)
[17:44:46.401]                 common <- intersect(names, old_names)
[17:44:46.401]                 added <- setdiff(names, old_names)
[17:44:46.401]                 removed <- setdiff(old_names, names)
[17:44:46.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.401]                   envs[common]]
[17:44:46.401]                 NAMES <- toupper(changed)
[17:44:46.401]                 args <- list()
[17:44:46.401]                 for (kk in seq_along(NAMES)) {
[17:44:46.401]                   name <- changed[[kk]]
[17:44:46.401]                   NAME <- NAMES[[kk]]
[17:44:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.401]                     next
[17:44:46.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.401]                 }
[17:44:46.401]                 NAMES <- toupper(added)
[17:44:46.401]                 for (kk in seq_along(NAMES)) {
[17:44:46.401]                   name <- added[[kk]]
[17:44:46.401]                   NAME <- NAMES[[kk]]
[17:44:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.401]                     next
[17:44:46.401]                   args[[name]] <- ""
[17:44:46.401]                 }
[17:44:46.401]                 NAMES <- toupper(removed)
[17:44:46.401]                 for (kk in seq_along(NAMES)) {
[17:44:46.401]                   name <- removed[[kk]]
[17:44:46.401]                   NAME <- NAMES[[kk]]
[17:44:46.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.401]                     next
[17:44:46.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.401]                 }
[17:44:46.401]                 if (length(args) > 0) 
[17:44:46.401]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.401]             }
[17:44:46.401]             else {
[17:44:46.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.401]             }
[17:44:46.401]             {
[17:44:46.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.401]                   0L) {
[17:44:46.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.401]                   base::options(opts)
[17:44:46.401]                 }
[17:44:46.401]                 {
[17:44:46.401]                   {
[17:44:46.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.401]                     NULL
[17:44:46.401]                   }
[17:44:46.401]                   options(future.plan = NULL)
[17:44:46.401]                   if (is.na(NA_character_)) 
[17:44:46.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.401]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.401]                     .init = FALSE)
[17:44:46.401]                 }
[17:44:46.401]             }
[17:44:46.401]         }
[17:44:46.401]     })
[17:44:46.401]     if (TRUE) {
[17:44:46.401]         base::sink(type = "output", split = FALSE)
[17:44:46.401]         if (TRUE) {
[17:44:46.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.401]         }
[17:44:46.401]         else {
[17:44:46.401]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.401]         }
[17:44:46.401]         base::close(...future.stdout)
[17:44:46.401]         ...future.stdout <- NULL
[17:44:46.401]     }
[17:44:46.401]     ...future.result$conditions <- ...future.conditions
[17:44:46.401]     ...future.result$finished <- base::Sys.time()
[17:44:46.401]     ...future.result
[17:44:46.401] }
[17:44:46.404] assign_globals() ...
[17:44:46.404] List of 5
[17:44:46.404]  $ ...future.FUN            :function (x, ...)  
[17:44:46.404]  $ MoreArgs                 : NULL
[17:44:46.404]  $ ...future.elements_ii    :List of 2
[17:44:46.404]   ..$ :List of 2
[17:44:46.404]   .. ..$ : int 1
[17:44:46.404]   .. ..$ : int 2
[17:44:46.404]   ..$ :List of 2
[17:44:46.404]   .. ..$ : int 4
[17:44:46.404]   .. ..$ : int 3
[17:44:46.404]  $ ...future.seeds_ii       : NULL
[17:44:46.404]  $ ...future.globals.maxSize: NULL
[17:44:46.404]  - attr(*, "where")=List of 5
[17:44:46.404]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.404]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.404]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.404]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.404]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.404]  - attr(*, "resolved")= logi FALSE
[17:44:46.404]  - attr(*, "total_size")= num 280
[17:44:46.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.404]  - attr(*, "already-done")= logi TRUE
[17:44:46.410] - copied ‘...future.FUN’ to environment
[17:44:46.410] - copied ‘MoreArgs’ to environment
[17:44:46.410] - copied ‘...future.elements_ii’ to environment
[17:44:46.410] - copied ‘...future.seeds_ii’ to environment
[17:44:46.410] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.410] assign_globals() ... done
[17:44:46.410] requestCore(): workers = 2
[17:44:46.413] MulticoreFuture started
[17:44:46.413] - Launch lazy future ... done
[17:44:46.413] run() for ‘MulticoreFuture’ ... done
[17:44:46.414] Created future:
[17:44:46.414] plan(): Setting new future strategy stack:
[17:44:46.414] List of future strategies:
[17:44:46.414] 1. sequential:
[17:44:46.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.414]    - tweaked: FALSE
[17:44:46.414]    - call: NULL
[17:44:46.415] plan(): nbrOfWorkers() = 1
[17:44:46.417] plan(): Setting new future strategy stack:
[17:44:46.417] List of future strategies:
[17:44:46.417] 1. multicore:
[17:44:46.417]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.417]    - tweaked: FALSE
[17:44:46.417]    - call: plan(strategy)
[17:44:46.422] plan(): nbrOfWorkers() = 2
[17:44:46.414] MulticoreFuture:
[17:44:46.414] Label: ‘future_mapply-1’
[17:44:46.414] Expression:
[17:44:46.414] {
[17:44:46.414]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.414]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.414]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.414]         on.exit(options(oopts), add = TRUE)
[17:44:46.414]     }
[17:44:46.414]     {
[17:44:46.414]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.414]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.414]         do.call(mapply, args = args)
[17:44:46.414]     }
[17:44:46.414] }
[17:44:46.414] Lazy evaluation: FALSE
[17:44:46.414] Asynchronous evaluation: TRUE
[17:44:46.414] Local evaluation: TRUE
[17:44:46.414] Environment: R_GlobalEnv
[17:44:46.414] Capture standard output: TRUE
[17:44:46.414] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.414] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.414] Packages: <none>
[17:44:46.414] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.414] Resolved: TRUE
[17:44:46.414] Value: <not collected>
[17:44:46.414] Conditions captured: <none>
[17:44:46.414] Early signaling: FALSE
[17:44:46.414] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.414] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.423] Chunk #1 of 2 ... DONE
[17:44:46.424] Chunk #2 of 2 ...
[17:44:46.424]  - Finding globals in '...' for chunk #2 ...
[17:44:46.424] getGlobalsAndPackages() ...
[17:44:46.424] Searching for globals...
[17:44:46.425] 
[17:44:46.425] Searching for globals ... DONE
[17:44:46.425] - globals: [0] <none>
[17:44:46.425] getGlobalsAndPackages() ... DONE
[17:44:46.425]    + additional globals found: [n=0] 
[17:44:46.425]    + additional namespaces needed: [n=0] 
[17:44:46.425]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.426]  - seeds: <none>
[17:44:46.426]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.426] getGlobalsAndPackages() ...
[17:44:46.426] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.426] Resolving globals: FALSE
[17:44:46.427] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.428] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.428] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.428] 
[17:44:46.428] getGlobalsAndPackages() ... DONE
[17:44:46.429] run() for ‘Future’ ...
[17:44:46.429] - state: ‘created’
[17:44:46.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.434] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.434]   - Field: ‘label’
[17:44:46.434]   - Field: ‘local’
[17:44:46.435]   - Field: ‘owner’
[17:44:46.435]   - Field: ‘envir’
[17:44:46.435]   - Field: ‘workers’
[17:44:46.435]   - Field: ‘packages’
[17:44:46.435]   - Field: ‘gc’
[17:44:46.435]   - Field: ‘job’
[17:44:46.435]   - Field: ‘conditions’
[17:44:46.436]   - Field: ‘expr’
[17:44:46.436]   - Field: ‘uuid’
[17:44:46.436]   - Field: ‘seed’
[17:44:46.436]   - Field: ‘version’
[17:44:46.436]   - Field: ‘result’
[17:44:46.436]   - Field: ‘asynchronous’
[17:44:46.436]   - Field: ‘calls’
[17:44:46.437]   - Field: ‘globals’
[17:44:46.437]   - Field: ‘stdout’
[17:44:46.437]   - Field: ‘earlySignal’
[17:44:46.437]   - Field: ‘lazy’
[17:44:46.437]   - Field: ‘state’
[17:44:46.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.438] - Launch lazy future ...
[17:44:46.438] Packages needed by the future expression (n = 0): <none>
[17:44:46.438] Packages needed by future strategies (n = 0): <none>
[17:44:46.439] {
[17:44:46.439]     {
[17:44:46.439]         {
[17:44:46.439]             ...future.startTime <- base::Sys.time()
[17:44:46.439]             {
[17:44:46.439]                 {
[17:44:46.439]                   {
[17:44:46.439]                     {
[17:44:46.439]                       base::local({
[17:44:46.439]                         has_future <- base::requireNamespace("future", 
[17:44:46.439]                           quietly = TRUE)
[17:44:46.439]                         if (has_future) {
[17:44:46.439]                           ns <- base::getNamespace("future")
[17:44:46.439]                           version <- ns[[".package"]][["version"]]
[17:44:46.439]                           if (is.null(version)) 
[17:44:46.439]                             version <- utils::packageVersion("future")
[17:44:46.439]                         }
[17:44:46.439]                         else {
[17:44:46.439]                           version <- NULL
[17:44:46.439]                         }
[17:44:46.439]                         if (!has_future || version < "1.8.0") {
[17:44:46.439]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.439]                             "", base::R.version$version.string), 
[17:44:46.439]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.439]                               "release", "version")], collapse = " "), 
[17:44:46.439]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.439]                             info)
[17:44:46.439]                           info <- base::paste(info, collapse = "; ")
[17:44:46.439]                           if (!has_future) {
[17:44:46.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.439]                               info)
[17:44:46.439]                           }
[17:44:46.439]                           else {
[17:44:46.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.439]                               info, version)
[17:44:46.439]                           }
[17:44:46.439]                           base::stop(msg)
[17:44:46.439]                         }
[17:44:46.439]                       })
[17:44:46.439]                     }
[17:44:46.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.439]                     base::options(mc.cores = 1L)
[17:44:46.439]                   }
[17:44:46.439]                   ...future.strategy.old <- future::plan("list")
[17:44:46.439]                   options(future.plan = NULL)
[17:44:46.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.439]                 }
[17:44:46.439]                 ...future.workdir <- getwd()
[17:44:46.439]             }
[17:44:46.439]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.439]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.439]         }
[17:44:46.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.439]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.439]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.439]             base::names(...future.oldOptions))
[17:44:46.439]     }
[17:44:46.439]     if (FALSE) {
[17:44:46.439]     }
[17:44:46.439]     else {
[17:44:46.439]         if (TRUE) {
[17:44:46.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.439]                 open = "w")
[17:44:46.439]         }
[17:44:46.439]         else {
[17:44:46.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.439]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.439]         }
[17:44:46.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.439]             base::sink(type = "output", split = FALSE)
[17:44:46.439]             base::close(...future.stdout)
[17:44:46.439]         }, add = TRUE)
[17:44:46.439]     }
[17:44:46.439]     ...future.frame <- base::sys.nframe()
[17:44:46.439]     ...future.conditions <- base::list()
[17:44:46.439]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.439]     if (FALSE) {
[17:44:46.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.439]     }
[17:44:46.439]     ...future.result <- base::tryCatch({
[17:44:46.439]         base::withCallingHandlers({
[17:44:46.439]             ...future.value <- base::withVisible(base::local({
[17:44:46.439]                 withCallingHandlers({
[17:44:46.439]                   {
[17:44:46.439]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.439]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.439]                       ...future.globals.maxSize)) {
[17:44:46.439]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.439]                       on.exit(options(oopts), add = TRUE)
[17:44:46.439]                     }
[17:44:46.439]                     {
[17:44:46.439]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.439]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.439]                         USE.NAMES = FALSE)
[17:44:46.439]                       do.call(mapply, args = args)
[17:44:46.439]                     }
[17:44:46.439]                   }
[17:44:46.439]                 }, immediateCondition = function(cond) {
[17:44:46.439]                   save_rds <- function (object, pathname, ...) 
[17:44:46.439]                   {
[17:44:46.439]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.439]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.439]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.439]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.439]                         fi_tmp[["mtime"]])
[17:44:46.439]                     }
[17:44:46.439]                     tryCatch({
[17:44:46.439]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.439]                     }, error = function(ex) {
[17:44:46.439]                       msg <- conditionMessage(ex)
[17:44:46.439]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.439]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.439]                         fi_tmp[["mtime"]], msg)
[17:44:46.439]                       ex$message <- msg
[17:44:46.439]                       stop(ex)
[17:44:46.439]                     })
[17:44:46.439]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.439]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.439]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.439]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.439]                       fi <- file.info(pathname)
[17:44:46.439]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.439]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.439]                         fi[["size"]], fi[["mtime"]])
[17:44:46.439]                       stop(msg)
[17:44:46.439]                     }
[17:44:46.439]                     invisible(pathname)
[17:44:46.439]                   }
[17:44:46.439]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.439]                     rootPath = tempdir()) 
[17:44:46.439]                   {
[17:44:46.439]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.439]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.439]                       tmpdir = path, fileext = ".rds")
[17:44:46.439]                     save_rds(obj, file)
[17:44:46.439]                   }
[17:44:46.439]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.439]                   {
[17:44:46.439]                     inherits <- base::inherits
[17:44:46.439]                     invokeRestart <- base::invokeRestart
[17:44:46.439]                     is.null <- base::is.null
[17:44:46.439]                     muffled <- FALSE
[17:44:46.439]                     if (inherits(cond, "message")) {
[17:44:46.439]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.439]                       if (muffled) 
[17:44:46.439]                         invokeRestart("muffleMessage")
[17:44:46.439]                     }
[17:44:46.439]                     else if (inherits(cond, "warning")) {
[17:44:46.439]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.439]                       if (muffled) 
[17:44:46.439]                         invokeRestart("muffleWarning")
[17:44:46.439]                     }
[17:44:46.439]                     else if (inherits(cond, "condition")) {
[17:44:46.439]                       if (!is.null(pattern)) {
[17:44:46.439]                         computeRestarts <- base::computeRestarts
[17:44:46.439]                         grepl <- base::grepl
[17:44:46.439]                         restarts <- computeRestarts(cond)
[17:44:46.439]                         for (restart in restarts) {
[17:44:46.439]                           name <- restart$name
[17:44:46.439]                           if (is.null(name)) 
[17:44:46.439]                             next
[17:44:46.439]                           if (!grepl(pattern, name)) 
[17:44:46.439]                             next
[17:44:46.439]                           invokeRestart(restart)
[17:44:46.439]                           muffled <- TRUE
[17:44:46.439]                           break
[17:44:46.439]                         }
[17:44:46.439]                       }
[17:44:46.439]                     }
[17:44:46.439]                     invisible(muffled)
[17:44:46.439]                   }
[17:44:46.439]                   muffleCondition(cond)
[17:44:46.439]                 })
[17:44:46.439]             }))
[17:44:46.439]             future::FutureResult(value = ...future.value$value, 
[17:44:46.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.439]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.439]                     ...future.globalenv.names))
[17:44:46.439]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.439]         }, condition = base::local({
[17:44:46.439]             c <- base::c
[17:44:46.439]             inherits <- base::inherits
[17:44:46.439]             invokeRestart <- base::invokeRestart
[17:44:46.439]             length <- base::length
[17:44:46.439]             list <- base::list
[17:44:46.439]             seq.int <- base::seq.int
[17:44:46.439]             signalCondition <- base::signalCondition
[17:44:46.439]             sys.calls <- base::sys.calls
[17:44:46.439]             `[[` <- base::`[[`
[17:44:46.439]             `+` <- base::`+`
[17:44:46.439]             `<<-` <- base::`<<-`
[17:44:46.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.439]                   3L)]
[17:44:46.439]             }
[17:44:46.439]             function(cond) {
[17:44:46.439]                 is_error <- inherits(cond, "error")
[17:44:46.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.439]                   NULL)
[17:44:46.439]                 if (is_error) {
[17:44:46.439]                   sessionInformation <- function() {
[17:44:46.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.439]                       search = base::search(), system = base::Sys.info())
[17:44:46.439]                   }
[17:44:46.439]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.439]                     cond$call), session = sessionInformation(), 
[17:44:46.439]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.439]                   signalCondition(cond)
[17:44:46.439]                 }
[17:44:46.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.439]                 "immediateCondition"))) {
[17:44:46.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.439]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.439]                   if (TRUE && !signal) {
[17:44:46.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.439]                     {
[17:44:46.439]                       inherits <- base::inherits
[17:44:46.439]                       invokeRestart <- base::invokeRestart
[17:44:46.439]                       is.null <- base::is.null
[17:44:46.439]                       muffled <- FALSE
[17:44:46.439]                       if (inherits(cond, "message")) {
[17:44:46.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.439]                         if (muffled) 
[17:44:46.439]                           invokeRestart("muffleMessage")
[17:44:46.439]                       }
[17:44:46.439]                       else if (inherits(cond, "warning")) {
[17:44:46.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.439]                         if (muffled) 
[17:44:46.439]                           invokeRestart("muffleWarning")
[17:44:46.439]                       }
[17:44:46.439]                       else if (inherits(cond, "condition")) {
[17:44:46.439]                         if (!is.null(pattern)) {
[17:44:46.439]                           computeRestarts <- base::computeRestarts
[17:44:46.439]                           grepl <- base::grepl
[17:44:46.439]                           restarts <- computeRestarts(cond)
[17:44:46.439]                           for (restart in restarts) {
[17:44:46.439]                             name <- restart$name
[17:44:46.439]                             if (is.null(name)) 
[17:44:46.439]                               next
[17:44:46.439]                             if (!grepl(pattern, name)) 
[17:44:46.439]                               next
[17:44:46.439]                             invokeRestart(restart)
[17:44:46.439]                             muffled <- TRUE
[17:44:46.439]                             break
[17:44:46.439]                           }
[17:44:46.439]                         }
[17:44:46.439]                       }
[17:44:46.439]                       invisible(muffled)
[17:44:46.439]                     }
[17:44:46.439]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.439]                   }
[17:44:46.439]                 }
[17:44:46.439]                 else {
[17:44:46.439]                   if (TRUE) {
[17:44:46.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.439]                     {
[17:44:46.439]                       inherits <- base::inherits
[17:44:46.439]                       invokeRestart <- base::invokeRestart
[17:44:46.439]                       is.null <- base::is.null
[17:44:46.439]                       muffled <- FALSE
[17:44:46.439]                       if (inherits(cond, "message")) {
[17:44:46.439]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.439]                         if (muffled) 
[17:44:46.439]                           invokeRestart("muffleMessage")
[17:44:46.439]                       }
[17:44:46.439]                       else if (inherits(cond, "warning")) {
[17:44:46.439]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.439]                         if (muffled) 
[17:44:46.439]                           invokeRestart("muffleWarning")
[17:44:46.439]                       }
[17:44:46.439]                       else if (inherits(cond, "condition")) {
[17:44:46.439]                         if (!is.null(pattern)) {
[17:44:46.439]                           computeRestarts <- base::computeRestarts
[17:44:46.439]                           grepl <- base::grepl
[17:44:46.439]                           restarts <- computeRestarts(cond)
[17:44:46.439]                           for (restart in restarts) {
[17:44:46.439]                             name <- restart$name
[17:44:46.439]                             if (is.null(name)) 
[17:44:46.439]                               next
[17:44:46.439]                             if (!grepl(pattern, name)) 
[17:44:46.439]                               next
[17:44:46.439]                             invokeRestart(restart)
[17:44:46.439]                             muffled <- TRUE
[17:44:46.439]                             break
[17:44:46.439]                           }
[17:44:46.439]                         }
[17:44:46.439]                       }
[17:44:46.439]                       invisible(muffled)
[17:44:46.439]                     }
[17:44:46.439]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.439]                   }
[17:44:46.439]                 }
[17:44:46.439]             }
[17:44:46.439]         }))
[17:44:46.439]     }, error = function(ex) {
[17:44:46.439]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.439]                 ...future.rng), started = ...future.startTime, 
[17:44:46.439]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.439]             version = "1.8"), class = "FutureResult")
[17:44:46.439]     }, finally = {
[17:44:46.439]         if (!identical(...future.workdir, getwd())) 
[17:44:46.439]             setwd(...future.workdir)
[17:44:46.439]         {
[17:44:46.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.439]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.439]             }
[17:44:46.439]             base::options(...future.oldOptions)
[17:44:46.439]             if (.Platform$OS.type == "windows") {
[17:44:46.439]                 old_names <- names(...future.oldEnvVars)
[17:44:46.439]                 envs <- base::Sys.getenv()
[17:44:46.439]                 names <- names(envs)
[17:44:46.439]                 common <- intersect(names, old_names)
[17:44:46.439]                 added <- setdiff(names, old_names)
[17:44:46.439]                 removed <- setdiff(old_names, names)
[17:44:46.439]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.439]                   envs[common]]
[17:44:46.439]                 NAMES <- toupper(changed)
[17:44:46.439]                 args <- list()
[17:44:46.439]                 for (kk in seq_along(NAMES)) {
[17:44:46.439]                   name <- changed[[kk]]
[17:44:46.439]                   NAME <- NAMES[[kk]]
[17:44:46.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.439]                     next
[17:44:46.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.439]                 }
[17:44:46.439]                 NAMES <- toupper(added)
[17:44:46.439]                 for (kk in seq_along(NAMES)) {
[17:44:46.439]                   name <- added[[kk]]
[17:44:46.439]                   NAME <- NAMES[[kk]]
[17:44:46.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.439]                     next
[17:44:46.439]                   args[[name]] <- ""
[17:44:46.439]                 }
[17:44:46.439]                 NAMES <- toupper(removed)
[17:44:46.439]                 for (kk in seq_along(NAMES)) {
[17:44:46.439]                   name <- removed[[kk]]
[17:44:46.439]                   NAME <- NAMES[[kk]]
[17:44:46.439]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.439]                     next
[17:44:46.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.439]                 }
[17:44:46.439]                 if (length(args) > 0) 
[17:44:46.439]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.439]             }
[17:44:46.439]             else {
[17:44:46.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.439]             }
[17:44:46.439]             {
[17:44:46.439]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.439]                   0L) {
[17:44:46.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.439]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.439]                   base::options(opts)
[17:44:46.439]                 }
[17:44:46.439]                 {
[17:44:46.439]                   {
[17:44:46.439]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.439]                     NULL
[17:44:46.439]                   }
[17:44:46.439]                   options(future.plan = NULL)
[17:44:46.439]                   if (is.na(NA_character_)) 
[17:44:46.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.439]                     .init = FALSE)
[17:44:46.439]                 }
[17:44:46.439]             }
[17:44:46.439]         }
[17:44:46.439]     })
[17:44:46.439]     if (TRUE) {
[17:44:46.439]         base::sink(type = "output", split = FALSE)
[17:44:46.439]         if (TRUE) {
[17:44:46.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.439]         }
[17:44:46.439]         else {
[17:44:46.439]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.439]         }
[17:44:46.439]         base::close(...future.stdout)
[17:44:46.439]         ...future.stdout <- NULL
[17:44:46.439]     }
[17:44:46.439]     ...future.result$conditions <- ...future.conditions
[17:44:46.439]     ...future.result$finished <- base::Sys.time()
[17:44:46.439]     ...future.result
[17:44:46.439] }
[17:44:46.442] assign_globals() ...
[17:44:46.442] List of 5
[17:44:46.442]  $ ...future.FUN            :function (x, ...)  
[17:44:46.442]  $ MoreArgs                 : NULL
[17:44:46.442]  $ ...future.elements_ii    :List of 2
[17:44:46.442]   ..$ :List of 2
[17:44:46.442]   .. ..$ : int 3
[17:44:46.442]   .. ..$ : int 4
[17:44:46.442]   ..$ :List of 2
[17:44:46.442]   .. ..$ : int 2
[17:44:46.442]   .. ..$ : int 1
[17:44:46.442]  $ ...future.seeds_ii       : NULL
[17:44:46.442]  $ ...future.globals.maxSize: NULL
[17:44:46.442]  - attr(*, "where")=List of 5
[17:44:46.442]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.442]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.442]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.442]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.442]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.442]  - attr(*, "resolved")= logi FALSE
[17:44:46.442]  - attr(*, "total_size")= num 280
[17:44:46.442]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.442]  - attr(*, "already-done")= logi TRUE
[17:44:46.455] - copied ‘...future.FUN’ to environment
[17:44:46.456] - copied ‘MoreArgs’ to environment
[17:44:46.456] - copied ‘...future.elements_ii’ to environment
[17:44:46.456] - copied ‘...future.seeds_ii’ to environment
[17:44:46.456] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.456] assign_globals() ... done
[17:44:46.456] requestCore(): workers = 2
[17:44:46.459] MulticoreFuture started
[17:44:46.459] - Launch lazy future ... done
[17:44:46.460] run() for ‘MulticoreFuture’ ... done
[17:44:46.460] plan(): Setting new future strategy stack:
[17:44:46.460] Created future:
[17:44:46.460] List of future strategies:
[17:44:46.460] 1. sequential:
[17:44:46.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.460]    - tweaked: FALSE
[17:44:46.460]    - call: NULL
[17:44:46.461] plan(): nbrOfWorkers() = 1
[17:44:46.464] plan(): Setting new future strategy stack:
[17:44:46.464] List of future strategies:
[17:44:46.464] 1. multicore:
[17:44:46.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.464]    - tweaked: FALSE
[17:44:46.464]    - call: plan(strategy)
[17:44:46.470] plan(): nbrOfWorkers() = 2
[17:44:46.460] MulticoreFuture:
[17:44:46.460] Label: ‘future_mapply-2’
[17:44:46.460] Expression:
[17:44:46.460] {
[17:44:46.460]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.460]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.460]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.460]         on.exit(options(oopts), add = TRUE)
[17:44:46.460]     }
[17:44:46.460]     {
[17:44:46.460]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.460]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.460]         do.call(mapply, args = args)
[17:44:46.460]     }
[17:44:46.460] }
[17:44:46.460] Lazy evaluation: FALSE
[17:44:46.460] Asynchronous evaluation: TRUE
[17:44:46.460] Local evaluation: TRUE
[17:44:46.460] Environment: R_GlobalEnv
[17:44:46.460] Capture standard output: TRUE
[17:44:46.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.460] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.460] Packages: <none>
[17:44:46.460] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.460] Resolved: TRUE
[17:44:46.460] Value: <not collected>
[17:44:46.460] Conditions captured: <none>
[17:44:46.460] Early signaling: FALSE
[17:44:46.460] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.460] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.471] Chunk #2 of 2 ... DONE
[17:44:46.471] Launching 2 futures (chunks) ... DONE
[17:44:46.471] Resolving 2 futures (chunks) ...
[17:44:46.472] resolve() on list ...
[17:44:46.472]  recursive: 0
[17:44:46.472]  length: 2
[17:44:46.472] 
[17:44:46.473] Future #1
[17:44:46.473] result() for MulticoreFuture ...
[17:44:46.474] result() for MulticoreFuture ...
[17:44:46.474] result() for MulticoreFuture ... done
[17:44:46.474] result() for MulticoreFuture ... done
[17:44:46.474] result() for MulticoreFuture ...
[17:44:46.475] result() for MulticoreFuture ... done
[17:44:46.475] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.475] - nx: 2
[17:44:46.475] - relay: TRUE
[17:44:46.475] - stdout: TRUE
[17:44:46.476] - signal: TRUE
[17:44:46.476] - resignal: FALSE
[17:44:46.476] - force: TRUE
[17:44:46.476] - relayed: [n=2] FALSE, FALSE
[17:44:46.476] - queued futures: [n=2] FALSE, FALSE
[17:44:46.477]  - until=1
[17:44:46.477]  - relaying element #1
[17:44:46.477] result() for MulticoreFuture ...
[17:44:46.477] result() for MulticoreFuture ... done
[17:44:46.478] result() for MulticoreFuture ...
[17:44:46.478] result() for MulticoreFuture ... done
[17:44:46.478] result() for MulticoreFuture ...
[17:44:46.478] result() for MulticoreFuture ... done
[17:44:46.478] result() for MulticoreFuture ...
[17:44:46.478] result() for MulticoreFuture ... done
[17:44:46.479] - relayed: [n=2] TRUE, FALSE
[17:44:46.479] - queued futures: [n=2] TRUE, FALSE
[17:44:46.479] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.479]  length: 1 (resolved future 1)
[17:44:46.479] Future #2
[17:44:46.480] result() for MulticoreFuture ...
[17:44:46.480] result() for MulticoreFuture ...
[17:44:46.480] result() for MulticoreFuture ... done
[17:44:46.481] result() for MulticoreFuture ... done
[17:44:46.481] result() for MulticoreFuture ...
[17:44:46.481] result() for MulticoreFuture ... done
[17:44:46.481] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.481] - nx: 2
[17:44:46.481] - relay: TRUE
[17:44:46.481] - stdout: TRUE
[17:44:46.481] - signal: TRUE
[17:44:46.482] - resignal: FALSE
[17:44:46.482] - force: TRUE
[17:44:46.482] - relayed: [n=2] TRUE, FALSE
[17:44:46.482] - queued futures: [n=2] TRUE, FALSE
[17:44:46.482]  - until=2
[17:44:46.482]  - relaying element #2
[17:44:46.482] result() for MulticoreFuture ...
[17:44:46.482] result() for MulticoreFuture ... done
[17:44:46.483] result() for MulticoreFuture ...
[17:44:46.483] result() for MulticoreFuture ... done
[17:44:46.483] result() for MulticoreFuture ...
[17:44:46.483] result() for MulticoreFuture ... done
[17:44:46.483] result() for MulticoreFuture ...
[17:44:46.483] result() for MulticoreFuture ... done
[17:44:46.483] - relayed: [n=2] TRUE, TRUE
[17:44:46.483] - queued futures: [n=2] TRUE, TRUE
[17:44:46.483] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.484]  length: 0 (resolved future 2)
[17:44:46.484] Relaying remaining futures
[17:44:46.484] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.484] - nx: 2
[17:44:46.484] - relay: TRUE
[17:44:46.484] - stdout: TRUE
[17:44:46.484] - signal: TRUE
[17:44:46.484] - resignal: FALSE
[17:44:46.484] - force: TRUE
[17:44:46.484] - relayed: [n=2] TRUE, TRUE
[17:44:46.485] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.485] - relayed: [n=2] TRUE, TRUE
[17:44:46.485] - queued futures: [n=2] TRUE, TRUE
[17:44:46.485] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.485] resolve() on list ... DONE
[17:44:46.485] result() for MulticoreFuture ...
[17:44:46.485] result() for MulticoreFuture ... done
[17:44:46.485] result() for MulticoreFuture ...
[17:44:46.486] result() for MulticoreFuture ... done
[17:44:46.486] result() for MulticoreFuture ...
[17:44:46.486] result() for MulticoreFuture ... done
[17:44:46.486] result() for MulticoreFuture ...
[17:44:46.486] result() for MulticoreFuture ... done
[17:44:46.486]  - Number of value chunks collected: 2
[17:44:46.486] Resolving 2 futures (chunks) ... DONE
[17:44:46.486] Reducing values from 2 chunks ...
[17:44:46.486]  - Number of values collected after concatenation: 4
[17:44:46.487]  - Number of values expected: 4
[17:44:46.487] Reducing values from 2 chunks ... DONE
[17:44:46.487] future_mapply() ... DONE
[17:44:46.487] future_mapply() ...
[17:44:46.491] Number of chunks: 2
[17:44:46.491] getGlobalsAndPackagesXApply() ...
[17:44:46.491]  - future.globals: TRUE
[17:44:46.492] getGlobalsAndPackages() ...
[17:44:46.492] Searching for globals...
[17:44:46.492] - globals found: [1] ‘FUN’
[17:44:46.493] Searching for globals ... DONE
[17:44:46.493] Resolving globals: FALSE
[17:44:46.493] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.493] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.494] - globals: [1] ‘FUN’
[17:44:46.494] 
[17:44:46.494] getGlobalsAndPackages() ... DONE
[17:44:46.494]  - globals found/used: [n=1] ‘FUN’
[17:44:46.494]  - needed namespaces: [n=0] 
[17:44:46.494] Finding globals ... DONE
[17:44:46.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.495] List of 2
[17:44:46.495]  $ ...future.FUN:function (x, ...)  
[17:44:46.495]  $ MoreArgs     : NULL
[17:44:46.495]  - attr(*, "where")=List of 2
[17:44:46.495]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.495]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.495]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.495]  - attr(*, "resolved")= logi FALSE
[17:44:46.495]  - attr(*, "total_size")= num NA
[17:44:46.498] Packages to be attached in all futures: [n=0] 
[17:44:46.498] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.498] Number of futures (= number of chunks): 2
[17:44:46.498] Launching 2 futures (chunks) ...
[17:44:46.500] Chunk #1 of 2 ...
[17:44:46.500]  - Finding globals in '...' for chunk #1 ...
[17:44:46.501] getGlobalsAndPackages() ...
[17:44:46.501] Searching for globals...
[17:44:46.501] 
[17:44:46.501] Searching for globals ... DONE
[17:44:46.501] - globals: [0] <none>
[17:44:46.502] getGlobalsAndPackages() ... DONE
[17:44:46.502]    + additional globals found: [n=0] 
[17:44:46.502]    + additional namespaces needed: [n=0] 
[17:44:46.502]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.502]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.502]  - seeds: <none>
[17:44:46.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.502] getGlobalsAndPackages() ...
[17:44:46.502] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.503] Resolving globals: FALSE
[17:44:46.503] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.504] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.504] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.504] 
[17:44:46.504] getGlobalsAndPackages() ... DONE
[17:44:46.505] run() for ‘Future’ ...
[17:44:46.505] - state: ‘created’
[17:44:46.505] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.508] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.508] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.509]   - Field: ‘label’
[17:44:46.509]   - Field: ‘local’
[17:44:46.509]   - Field: ‘owner’
[17:44:46.509]   - Field: ‘envir’
[17:44:46.509]   - Field: ‘workers’
[17:44:46.509]   - Field: ‘packages’
[17:44:46.509]   - Field: ‘gc’
[17:44:46.509]   - Field: ‘job’
[17:44:46.509]   - Field: ‘conditions’
[17:44:46.509]   - Field: ‘expr’
[17:44:46.510]   - Field: ‘uuid’
[17:44:46.510]   - Field: ‘seed’
[17:44:46.510]   - Field: ‘version’
[17:44:46.510]   - Field: ‘result’
[17:44:46.510]   - Field: ‘asynchronous’
[17:44:46.510]   - Field: ‘calls’
[17:44:46.510]   - Field: ‘globals’
[17:44:46.510]   - Field: ‘stdout’
[17:44:46.510]   - Field: ‘earlySignal’
[17:44:46.510]   - Field: ‘lazy’
[17:44:46.510]   - Field: ‘state’
[17:44:46.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.511] - Launch lazy future ...
[17:44:46.511] Packages needed by the future expression (n = 0): <none>
[17:44:46.511] Packages needed by future strategies (n = 0): <none>
[17:44:46.512] {
[17:44:46.512]     {
[17:44:46.512]         {
[17:44:46.512]             ...future.startTime <- base::Sys.time()
[17:44:46.512]             {
[17:44:46.512]                 {
[17:44:46.512]                   {
[17:44:46.512]                     {
[17:44:46.512]                       base::local({
[17:44:46.512]                         has_future <- base::requireNamespace("future", 
[17:44:46.512]                           quietly = TRUE)
[17:44:46.512]                         if (has_future) {
[17:44:46.512]                           ns <- base::getNamespace("future")
[17:44:46.512]                           version <- ns[[".package"]][["version"]]
[17:44:46.512]                           if (is.null(version)) 
[17:44:46.512]                             version <- utils::packageVersion("future")
[17:44:46.512]                         }
[17:44:46.512]                         else {
[17:44:46.512]                           version <- NULL
[17:44:46.512]                         }
[17:44:46.512]                         if (!has_future || version < "1.8.0") {
[17:44:46.512]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.512]                             "", base::R.version$version.string), 
[17:44:46.512]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.512]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.512]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.512]                               "release", "version")], collapse = " "), 
[17:44:46.512]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.512]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.512]                             info)
[17:44:46.512]                           info <- base::paste(info, collapse = "; ")
[17:44:46.512]                           if (!has_future) {
[17:44:46.512]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.512]                               info)
[17:44:46.512]                           }
[17:44:46.512]                           else {
[17:44:46.512]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.512]                               info, version)
[17:44:46.512]                           }
[17:44:46.512]                           base::stop(msg)
[17:44:46.512]                         }
[17:44:46.512]                       })
[17:44:46.512]                     }
[17:44:46.512]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.512]                     base::options(mc.cores = 1L)
[17:44:46.512]                   }
[17:44:46.512]                   ...future.strategy.old <- future::plan("list")
[17:44:46.512]                   options(future.plan = NULL)
[17:44:46.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.512]                 }
[17:44:46.512]                 ...future.workdir <- getwd()
[17:44:46.512]             }
[17:44:46.512]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.512]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.512]         }
[17:44:46.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.512]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.512]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.512]             base::names(...future.oldOptions))
[17:44:46.512]     }
[17:44:46.512]     if (FALSE) {
[17:44:46.512]     }
[17:44:46.512]     else {
[17:44:46.512]         if (TRUE) {
[17:44:46.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.512]                 open = "w")
[17:44:46.512]         }
[17:44:46.512]         else {
[17:44:46.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.512]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.512]         }
[17:44:46.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.512]             base::sink(type = "output", split = FALSE)
[17:44:46.512]             base::close(...future.stdout)
[17:44:46.512]         }, add = TRUE)
[17:44:46.512]     }
[17:44:46.512]     ...future.frame <- base::sys.nframe()
[17:44:46.512]     ...future.conditions <- base::list()
[17:44:46.512]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.512]     if (FALSE) {
[17:44:46.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.512]     }
[17:44:46.512]     ...future.result <- base::tryCatch({
[17:44:46.512]         base::withCallingHandlers({
[17:44:46.512]             ...future.value <- base::withVisible(base::local({
[17:44:46.512]                 withCallingHandlers({
[17:44:46.512]                   {
[17:44:46.512]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.512]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.512]                       ...future.globals.maxSize)) {
[17:44:46.512]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.512]                       on.exit(options(oopts), add = TRUE)
[17:44:46.512]                     }
[17:44:46.512]                     {
[17:44:46.512]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.512]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.512]                         USE.NAMES = FALSE)
[17:44:46.512]                       do.call(mapply, args = args)
[17:44:46.512]                     }
[17:44:46.512]                   }
[17:44:46.512]                 }, immediateCondition = function(cond) {
[17:44:46.512]                   save_rds <- function (object, pathname, ...) 
[17:44:46.512]                   {
[17:44:46.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.512]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.512]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.512]                         fi_tmp[["mtime"]])
[17:44:46.512]                     }
[17:44:46.512]                     tryCatch({
[17:44:46.512]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.512]                     }, error = function(ex) {
[17:44:46.512]                       msg <- conditionMessage(ex)
[17:44:46.512]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.512]                         fi_tmp[["mtime"]], msg)
[17:44:46.512]                       ex$message <- msg
[17:44:46.512]                       stop(ex)
[17:44:46.512]                     })
[17:44:46.512]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.512]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.512]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.512]                       fi <- file.info(pathname)
[17:44:46.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.512]                         fi[["size"]], fi[["mtime"]])
[17:44:46.512]                       stop(msg)
[17:44:46.512]                     }
[17:44:46.512]                     invisible(pathname)
[17:44:46.512]                   }
[17:44:46.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.512]                     rootPath = tempdir()) 
[17:44:46.512]                   {
[17:44:46.512]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.512]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.512]                       tmpdir = path, fileext = ".rds")
[17:44:46.512]                     save_rds(obj, file)
[17:44:46.512]                   }
[17:44:46.512]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.512]                   {
[17:44:46.512]                     inherits <- base::inherits
[17:44:46.512]                     invokeRestart <- base::invokeRestart
[17:44:46.512]                     is.null <- base::is.null
[17:44:46.512]                     muffled <- FALSE
[17:44:46.512]                     if (inherits(cond, "message")) {
[17:44:46.512]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.512]                       if (muffled) 
[17:44:46.512]                         invokeRestart("muffleMessage")
[17:44:46.512]                     }
[17:44:46.512]                     else if (inherits(cond, "warning")) {
[17:44:46.512]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.512]                       if (muffled) 
[17:44:46.512]                         invokeRestart("muffleWarning")
[17:44:46.512]                     }
[17:44:46.512]                     else if (inherits(cond, "condition")) {
[17:44:46.512]                       if (!is.null(pattern)) {
[17:44:46.512]                         computeRestarts <- base::computeRestarts
[17:44:46.512]                         grepl <- base::grepl
[17:44:46.512]                         restarts <- computeRestarts(cond)
[17:44:46.512]                         for (restart in restarts) {
[17:44:46.512]                           name <- restart$name
[17:44:46.512]                           if (is.null(name)) 
[17:44:46.512]                             next
[17:44:46.512]                           if (!grepl(pattern, name)) 
[17:44:46.512]                             next
[17:44:46.512]                           invokeRestart(restart)
[17:44:46.512]                           muffled <- TRUE
[17:44:46.512]                           break
[17:44:46.512]                         }
[17:44:46.512]                       }
[17:44:46.512]                     }
[17:44:46.512]                     invisible(muffled)
[17:44:46.512]                   }
[17:44:46.512]                   muffleCondition(cond)
[17:44:46.512]                 })
[17:44:46.512]             }))
[17:44:46.512]             future::FutureResult(value = ...future.value$value, 
[17:44:46.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.512]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.512]                     ...future.globalenv.names))
[17:44:46.512]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.512]         }, condition = base::local({
[17:44:46.512]             c <- base::c
[17:44:46.512]             inherits <- base::inherits
[17:44:46.512]             invokeRestart <- base::invokeRestart
[17:44:46.512]             length <- base::length
[17:44:46.512]             list <- base::list
[17:44:46.512]             seq.int <- base::seq.int
[17:44:46.512]             signalCondition <- base::signalCondition
[17:44:46.512]             sys.calls <- base::sys.calls
[17:44:46.512]             `[[` <- base::`[[`
[17:44:46.512]             `+` <- base::`+`
[17:44:46.512]             `<<-` <- base::`<<-`
[17:44:46.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.512]                   3L)]
[17:44:46.512]             }
[17:44:46.512]             function(cond) {
[17:44:46.512]                 is_error <- inherits(cond, "error")
[17:44:46.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.512]                   NULL)
[17:44:46.512]                 if (is_error) {
[17:44:46.512]                   sessionInformation <- function() {
[17:44:46.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.512]                       search = base::search(), system = base::Sys.info())
[17:44:46.512]                   }
[17:44:46.512]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.512]                     cond$call), session = sessionInformation(), 
[17:44:46.512]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.512]                   signalCondition(cond)
[17:44:46.512]                 }
[17:44:46.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.512]                 "immediateCondition"))) {
[17:44:46.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.512]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.512]                   if (TRUE && !signal) {
[17:44:46.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.512]                     {
[17:44:46.512]                       inherits <- base::inherits
[17:44:46.512]                       invokeRestart <- base::invokeRestart
[17:44:46.512]                       is.null <- base::is.null
[17:44:46.512]                       muffled <- FALSE
[17:44:46.512]                       if (inherits(cond, "message")) {
[17:44:46.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.512]                         if (muffled) 
[17:44:46.512]                           invokeRestart("muffleMessage")
[17:44:46.512]                       }
[17:44:46.512]                       else if (inherits(cond, "warning")) {
[17:44:46.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.512]                         if (muffled) 
[17:44:46.512]                           invokeRestart("muffleWarning")
[17:44:46.512]                       }
[17:44:46.512]                       else if (inherits(cond, "condition")) {
[17:44:46.512]                         if (!is.null(pattern)) {
[17:44:46.512]                           computeRestarts <- base::computeRestarts
[17:44:46.512]                           grepl <- base::grepl
[17:44:46.512]                           restarts <- computeRestarts(cond)
[17:44:46.512]                           for (restart in restarts) {
[17:44:46.512]                             name <- restart$name
[17:44:46.512]                             if (is.null(name)) 
[17:44:46.512]                               next
[17:44:46.512]                             if (!grepl(pattern, name)) 
[17:44:46.512]                               next
[17:44:46.512]                             invokeRestart(restart)
[17:44:46.512]                             muffled <- TRUE
[17:44:46.512]                             break
[17:44:46.512]                           }
[17:44:46.512]                         }
[17:44:46.512]                       }
[17:44:46.512]                       invisible(muffled)
[17:44:46.512]                     }
[17:44:46.512]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.512]                   }
[17:44:46.512]                 }
[17:44:46.512]                 else {
[17:44:46.512]                   if (TRUE) {
[17:44:46.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.512]                     {
[17:44:46.512]                       inherits <- base::inherits
[17:44:46.512]                       invokeRestart <- base::invokeRestart
[17:44:46.512]                       is.null <- base::is.null
[17:44:46.512]                       muffled <- FALSE
[17:44:46.512]                       if (inherits(cond, "message")) {
[17:44:46.512]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.512]                         if (muffled) 
[17:44:46.512]                           invokeRestart("muffleMessage")
[17:44:46.512]                       }
[17:44:46.512]                       else if (inherits(cond, "warning")) {
[17:44:46.512]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.512]                         if (muffled) 
[17:44:46.512]                           invokeRestart("muffleWarning")
[17:44:46.512]                       }
[17:44:46.512]                       else if (inherits(cond, "condition")) {
[17:44:46.512]                         if (!is.null(pattern)) {
[17:44:46.512]                           computeRestarts <- base::computeRestarts
[17:44:46.512]                           grepl <- base::grepl
[17:44:46.512]                           restarts <- computeRestarts(cond)
[17:44:46.512]                           for (restart in restarts) {
[17:44:46.512]                             name <- restart$name
[17:44:46.512]                             if (is.null(name)) 
[17:44:46.512]                               next
[17:44:46.512]                             if (!grepl(pattern, name)) 
[17:44:46.512]                               next
[17:44:46.512]                             invokeRestart(restart)
[17:44:46.512]                             muffled <- TRUE
[17:44:46.512]                             break
[17:44:46.512]                           }
[17:44:46.512]                         }
[17:44:46.512]                       }
[17:44:46.512]                       invisible(muffled)
[17:44:46.512]                     }
[17:44:46.512]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.512]                   }
[17:44:46.512]                 }
[17:44:46.512]             }
[17:44:46.512]         }))
[17:44:46.512]     }, error = function(ex) {
[17:44:46.512]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.512]                 ...future.rng), started = ...future.startTime, 
[17:44:46.512]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.512]             version = "1.8"), class = "FutureResult")
[17:44:46.512]     }, finally = {
[17:44:46.512]         if (!identical(...future.workdir, getwd())) 
[17:44:46.512]             setwd(...future.workdir)
[17:44:46.512]         {
[17:44:46.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.512]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.512]             }
[17:44:46.512]             base::options(...future.oldOptions)
[17:44:46.512]             if (.Platform$OS.type == "windows") {
[17:44:46.512]                 old_names <- names(...future.oldEnvVars)
[17:44:46.512]                 envs <- base::Sys.getenv()
[17:44:46.512]                 names <- names(envs)
[17:44:46.512]                 common <- intersect(names, old_names)
[17:44:46.512]                 added <- setdiff(names, old_names)
[17:44:46.512]                 removed <- setdiff(old_names, names)
[17:44:46.512]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.512]                   envs[common]]
[17:44:46.512]                 NAMES <- toupper(changed)
[17:44:46.512]                 args <- list()
[17:44:46.512]                 for (kk in seq_along(NAMES)) {
[17:44:46.512]                   name <- changed[[kk]]
[17:44:46.512]                   NAME <- NAMES[[kk]]
[17:44:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.512]                     next
[17:44:46.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.512]                 }
[17:44:46.512]                 NAMES <- toupper(added)
[17:44:46.512]                 for (kk in seq_along(NAMES)) {
[17:44:46.512]                   name <- added[[kk]]
[17:44:46.512]                   NAME <- NAMES[[kk]]
[17:44:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.512]                     next
[17:44:46.512]                   args[[name]] <- ""
[17:44:46.512]                 }
[17:44:46.512]                 NAMES <- toupper(removed)
[17:44:46.512]                 for (kk in seq_along(NAMES)) {
[17:44:46.512]                   name <- removed[[kk]]
[17:44:46.512]                   NAME <- NAMES[[kk]]
[17:44:46.512]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.512]                     next
[17:44:46.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.512]                 }
[17:44:46.512]                 if (length(args) > 0) 
[17:44:46.512]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.512]             }
[17:44:46.512]             else {
[17:44:46.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.512]             }
[17:44:46.512]             {
[17:44:46.512]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.512]                   0L) {
[17:44:46.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.512]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.512]                   base::options(opts)
[17:44:46.512]                 }
[17:44:46.512]                 {
[17:44:46.512]                   {
[17:44:46.512]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.512]                     NULL
[17:44:46.512]                   }
[17:44:46.512]                   options(future.plan = NULL)
[17:44:46.512]                   if (is.na(NA_character_)) 
[17:44:46.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.512]                     .init = FALSE)
[17:44:46.512]                 }
[17:44:46.512]             }
[17:44:46.512]         }
[17:44:46.512]     })
[17:44:46.512]     if (TRUE) {
[17:44:46.512]         base::sink(type = "output", split = FALSE)
[17:44:46.512]         if (TRUE) {
[17:44:46.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.512]         }
[17:44:46.512]         else {
[17:44:46.512]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.512]         }
[17:44:46.512]         base::close(...future.stdout)
[17:44:46.512]         ...future.stdout <- NULL
[17:44:46.512]     }
[17:44:46.512]     ...future.result$conditions <- ...future.conditions
[17:44:46.512]     ...future.result$finished <- base::Sys.time()
[17:44:46.512]     ...future.result
[17:44:46.512] }
[17:44:46.514] assign_globals() ...
[17:44:46.514] List of 5
[17:44:46.514]  $ ...future.FUN            :function (x, ...)  
[17:44:46.514]  $ MoreArgs                 : NULL
[17:44:46.514]  $ ...future.elements_ii    :List of 2
[17:44:46.514]   ..$ times:List of 2
[17:44:46.514]   .. ..$ : int 1
[17:44:46.514]   .. ..$ : int 2
[17:44:46.514]   ..$ x    :List of 2
[17:44:46.514]   .. ..$ : int 4
[17:44:46.514]   .. ..$ : int 3
[17:44:46.514]  $ ...future.seeds_ii       : NULL
[17:44:46.514]  $ ...future.globals.maxSize: NULL
[17:44:46.514]  - attr(*, "where")=List of 5
[17:44:46.514]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.514]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.514]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.514]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.514]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.514]  - attr(*, "resolved")= logi FALSE
[17:44:46.514]  - attr(*, "total_size")= num 280
[17:44:46.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.514]  - attr(*, "already-done")= logi TRUE
[17:44:46.520] - copied ‘...future.FUN’ to environment
[17:44:46.520] - copied ‘MoreArgs’ to environment
[17:44:46.520] - copied ‘...future.elements_ii’ to environment
[17:44:46.520] - copied ‘...future.seeds_ii’ to environment
[17:44:46.520] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.520] assign_globals() ... done
[17:44:46.520] requestCore(): workers = 2
[17:44:46.522] MulticoreFuture started
[17:44:46.523] - Launch lazy future ... done
[17:44:46.523] run() for ‘MulticoreFuture’ ... done
[17:44:46.523] Created future:
[17:44:46.523] plan(): Setting new future strategy stack:
[17:44:46.524] List of future strategies:
[17:44:46.524] 1. sequential:
[17:44:46.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.524]    - tweaked: FALSE
[17:44:46.524]    - call: NULL
[17:44:46.525] plan(): nbrOfWorkers() = 1
[17:44:46.527] plan(): Setting new future strategy stack:
[17:44:46.527] List of future strategies:
[17:44:46.527] 1. multicore:
[17:44:46.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.527]    - tweaked: FALSE
[17:44:46.527]    - call: plan(strategy)
[17:44:46.532] plan(): nbrOfWorkers() = 2
[17:44:46.523] MulticoreFuture:
[17:44:46.523] Label: ‘future_mapply-1’
[17:44:46.523] Expression:
[17:44:46.523] {
[17:44:46.523]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.523]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.523]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.523]         on.exit(options(oopts), add = TRUE)
[17:44:46.523]     }
[17:44:46.523]     {
[17:44:46.523]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.523]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.523]         do.call(mapply, args = args)
[17:44:46.523]     }
[17:44:46.523] }
[17:44:46.523] Lazy evaluation: FALSE
[17:44:46.523] Asynchronous evaluation: TRUE
[17:44:46.523] Local evaluation: TRUE
[17:44:46.523] Environment: R_GlobalEnv
[17:44:46.523] Capture standard output: TRUE
[17:44:46.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.523] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.523] Packages: <none>
[17:44:46.523] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.523] Resolved: TRUE
[17:44:46.523] Value: <not collected>
[17:44:46.523] Conditions captured: <none>
[17:44:46.523] Early signaling: FALSE
[17:44:46.523] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.523] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.533] Chunk #1 of 2 ... DONE
[17:44:46.533] Chunk #2 of 2 ...
[17:44:46.533]  - Finding globals in '...' for chunk #2 ...
[17:44:46.533] getGlobalsAndPackages() ...
[17:44:46.533] Searching for globals...
[17:44:46.534] 
[17:44:46.534] Searching for globals ... DONE
[17:44:46.534] - globals: [0] <none>
[17:44:46.534] getGlobalsAndPackages() ... DONE
[17:44:46.534]    + additional globals found: [n=0] 
[17:44:46.535]    + additional namespaces needed: [n=0] 
[17:44:46.535]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.535]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.535]  - seeds: <none>
[17:44:46.535]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.535] getGlobalsAndPackages() ...
[17:44:46.536] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.536] Resolving globals: FALSE
[17:44:46.537] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:46.537] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.538] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.538] 
[17:44:46.538] getGlobalsAndPackages() ... DONE
[17:44:46.538] run() for ‘Future’ ...
[17:44:46.539] - state: ‘created’
[17:44:46.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.547] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.547] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.547]   - Field: ‘label’
[17:44:46.548]   - Field: ‘local’
[17:44:46.548]   - Field: ‘owner’
[17:44:46.548]   - Field: ‘envir’
[17:44:46.549]   - Field: ‘workers’
[17:44:46.549]   - Field: ‘packages’
[17:44:46.549]   - Field: ‘gc’
[17:44:46.549]   - Field: ‘job’
[17:44:46.550]   - Field: ‘conditions’
[17:44:46.550]   - Field: ‘expr’
[17:44:46.550]   - Field: ‘uuid’
[17:44:46.550]   - Field: ‘seed’
[17:44:46.551]   - Field: ‘version’
[17:44:46.551]   - Field: ‘result’
[17:44:46.551]   - Field: ‘asynchronous’
[17:44:46.551]   - Field: ‘calls’
[17:44:46.552]   - Field: ‘globals’
[17:44:46.552]   - Field: ‘stdout’
[17:44:46.552]   - Field: ‘earlySignal’
[17:44:46.552]   - Field: ‘lazy’
[17:44:46.552]   - Field: ‘state’
[17:44:46.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.553] - Launch lazy future ...
[17:44:46.553] Packages needed by the future expression (n = 0): <none>
[17:44:46.554] Packages needed by future strategies (n = 0): <none>
[17:44:46.554] {
[17:44:46.554]     {
[17:44:46.554]         {
[17:44:46.554]             ...future.startTime <- base::Sys.time()
[17:44:46.554]             {
[17:44:46.554]                 {
[17:44:46.554]                   {
[17:44:46.554]                     {
[17:44:46.554]                       base::local({
[17:44:46.554]                         has_future <- base::requireNamespace("future", 
[17:44:46.554]                           quietly = TRUE)
[17:44:46.554]                         if (has_future) {
[17:44:46.554]                           ns <- base::getNamespace("future")
[17:44:46.554]                           version <- ns[[".package"]][["version"]]
[17:44:46.554]                           if (is.null(version)) 
[17:44:46.554]                             version <- utils::packageVersion("future")
[17:44:46.554]                         }
[17:44:46.554]                         else {
[17:44:46.554]                           version <- NULL
[17:44:46.554]                         }
[17:44:46.554]                         if (!has_future || version < "1.8.0") {
[17:44:46.554]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.554]                             "", base::R.version$version.string), 
[17:44:46.554]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.554]                               "release", "version")], collapse = " "), 
[17:44:46.554]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.554]                             info)
[17:44:46.554]                           info <- base::paste(info, collapse = "; ")
[17:44:46.554]                           if (!has_future) {
[17:44:46.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.554]                               info)
[17:44:46.554]                           }
[17:44:46.554]                           else {
[17:44:46.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.554]                               info, version)
[17:44:46.554]                           }
[17:44:46.554]                           base::stop(msg)
[17:44:46.554]                         }
[17:44:46.554]                       })
[17:44:46.554]                     }
[17:44:46.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.554]                     base::options(mc.cores = 1L)
[17:44:46.554]                   }
[17:44:46.554]                   ...future.strategy.old <- future::plan("list")
[17:44:46.554]                   options(future.plan = NULL)
[17:44:46.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.554]                 }
[17:44:46.554]                 ...future.workdir <- getwd()
[17:44:46.554]             }
[17:44:46.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.554]         }
[17:44:46.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.554]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.554]             base::names(...future.oldOptions))
[17:44:46.554]     }
[17:44:46.554]     if (FALSE) {
[17:44:46.554]     }
[17:44:46.554]     else {
[17:44:46.554]         if (TRUE) {
[17:44:46.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.554]                 open = "w")
[17:44:46.554]         }
[17:44:46.554]         else {
[17:44:46.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.554]         }
[17:44:46.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.554]             base::sink(type = "output", split = FALSE)
[17:44:46.554]             base::close(...future.stdout)
[17:44:46.554]         }, add = TRUE)
[17:44:46.554]     }
[17:44:46.554]     ...future.frame <- base::sys.nframe()
[17:44:46.554]     ...future.conditions <- base::list()
[17:44:46.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.554]     if (FALSE) {
[17:44:46.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.554]     }
[17:44:46.554]     ...future.result <- base::tryCatch({
[17:44:46.554]         base::withCallingHandlers({
[17:44:46.554]             ...future.value <- base::withVisible(base::local({
[17:44:46.554]                 withCallingHandlers({
[17:44:46.554]                   {
[17:44:46.554]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.554]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.554]                       ...future.globals.maxSize)) {
[17:44:46.554]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.554]                       on.exit(options(oopts), add = TRUE)
[17:44:46.554]                     }
[17:44:46.554]                     {
[17:44:46.554]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.554]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.554]                         USE.NAMES = FALSE)
[17:44:46.554]                       do.call(mapply, args = args)
[17:44:46.554]                     }
[17:44:46.554]                   }
[17:44:46.554]                 }, immediateCondition = function(cond) {
[17:44:46.554]                   save_rds <- function (object, pathname, ...) 
[17:44:46.554]                   {
[17:44:46.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.554]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.554]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.554]                         fi_tmp[["mtime"]])
[17:44:46.554]                     }
[17:44:46.554]                     tryCatch({
[17:44:46.554]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.554]                     }, error = function(ex) {
[17:44:46.554]                       msg <- conditionMessage(ex)
[17:44:46.554]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.554]                         fi_tmp[["mtime"]], msg)
[17:44:46.554]                       ex$message <- msg
[17:44:46.554]                       stop(ex)
[17:44:46.554]                     })
[17:44:46.554]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.554]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.554]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.554]                       fi <- file.info(pathname)
[17:44:46.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.554]                         fi[["size"]], fi[["mtime"]])
[17:44:46.554]                       stop(msg)
[17:44:46.554]                     }
[17:44:46.554]                     invisible(pathname)
[17:44:46.554]                   }
[17:44:46.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.554]                     rootPath = tempdir()) 
[17:44:46.554]                   {
[17:44:46.554]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.554]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.554]                       tmpdir = path, fileext = ".rds")
[17:44:46.554]                     save_rds(obj, file)
[17:44:46.554]                   }
[17:44:46.554]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.554]                   {
[17:44:46.554]                     inherits <- base::inherits
[17:44:46.554]                     invokeRestart <- base::invokeRestart
[17:44:46.554]                     is.null <- base::is.null
[17:44:46.554]                     muffled <- FALSE
[17:44:46.554]                     if (inherits(cond, "message")) {
[17:44:46.554]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.554]                       if (muffled) 
[17:44:46.554]                         invokeRestart("muffleMessage")
[17:44:46.554]                     }
[17:44:46.554]                     else if (inherits(cond, "warning")) {
[17:44:46.554]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.554]                       if (muffled) 
[17:44:46.554]                         invokeRestart("muffleWarning")
[17:44:46.554]                     }
[17:44:46.554]                     else if (inherits(cond, "condition")) {
[17:44:46.554]                       if (!is.null(pattern)) {
[17:44:46.554]                         computeRestarts <- base::computeRestarts
[17:44:46.554]                         grepl <- base::grepl
[17:44:46.554]                         restarts <- computeRestarts(cond)
[17:44:46.554]                         for (restart in restarts) {
[17:44:46.554]                           name <- restart$name
[17:44:46.554]                           if (is.null(name)) 
[17:44:46.554]                             next
[17:44:46.554]                           if (!grepl(pattern, name)) 
[17:44:46.554]                             next
[17:44:46.554]                           invokeRestart(restart)
[17:44:46.554]                           muffled <- TRUE
[17:44:46.554]                           break
[17:44:46.554]                         }
[17:44:46.554]                       }
[17:44:46.554]                     }
[17:44:46.554]                     invisible(muffled)
[17:44:46.554]                   }
[17:44:46.554]                   muffleCondition(cond)
[17:44:46.554]                 })
[17:44:46.554]             }))
[17:44:46.554]             future::FutureResult(value = ...future.value$value, 
[17:44:46.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.554]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.554]                     ...future.globalenv.names))
[17:44:46.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.554]         }, condition = base::local({
[17:44:46.554]             c <- base::c
[17:44:46.554]             inherits <- base::inherits
[17:44:46.554]             invokeRestart <- base::invokeRestart
[17:44:46.554]             length <- base::length
[17:44:46.554]             list <- base::list
[17:44:46.554]             seq.int <- base::seq.int
[17:44:46.554]             signalCondition <- base::signalCondition
[17:44:46.554]             sys.calls <- base::sys.calls
[17:44:46.554]             `[[` <- base::`[[`
[17:44:46.554]             `+` <- base::`+`
[17:44:46.554]             `<<-` <- base::`<<-`
[17:44:46.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.554]                   3L)]
[17:44:46.554]             }
[17:44:46.554]             function(cond) {
[17:44:46.554]                 is_error <- inherits(cond, "error")
[17:44:46.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.554]                   NULL)
[17:44:46.554]                 if (is_error) {
[17:44:46.554]                   sessionInformation <- function() {
[17:44:46.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.554]                       search = base::search(), system = base::Sys.info())
[17:44:46.554]                   }
[17:44:46.554]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.554]                     cond$call), session = sessionInformation(), 
[17:44:46.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.554]                   signalCondition(cond)
[17:44:46.554]                 }
[17:44:46.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.554]                 "immediateCondition"))) {
[17:44:46.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.554]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.554]                   if (TRUE && !signal) {
[17:44:46.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.554]                     {
[17:44:46.554]                       inherits <- base::inherits
[17:44:46.554]                       invokeRestart <- base::invokeRestart
[17:44:46.554]                       is.null <- base::is.null
[17:44:46.554]                       muffled <- FALSE
[17:44:46.554]                       if (inherits(cond, "message")) {
[17:44:46.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.554]                         if (muffled) 
[17:44:46.554]                           invokeRestart("muffleMessage")
[17:44:46.554]                       }
[17:44:46.554]                       else if (inherits(cond, "warning")) {
[17:44:46.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.554]                         if (muffled) 
[17:44:46.554]                           invokeRestart("muffleWarning")
[17:44:46.554]                       }
[17:44:46.554]                       else if (inherits(cond, "condition")) {
[17:44:46.554]                         if (!is.null(pattern)) {
[17:44:46.554]                           computeRestarts <- base::computeRestarts
[17:44:46.554]                           grepl <- base::grepl
[17:44:46.554]                           restarts <- computeRestarts(cond)
[17:44:46.554]                           for (restart in restarts) {
[17:44:46.554]                             name <- restart$name
[17:44:46.554]                             if (is.null(name)) 
[17:44:46.554]                               next
[17:44:46.554]                             if (!grepl(pattern, name)) 
[17:44:46.554]                               next
[17:44:46.554]                             invokeRestart(restart)
[17:44:46.554]                             muffled <- TRUE
[17:44:46.554]                             break
[17:44:46.554]                           }
[17:44:46.554]                         }
[17:44:46.554]                       }
[17:44:46.554]                       invisible(muffled)
[17:44:46.554]                     }
[17:44:46.554]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.554]                   }
[17:44:46.554]                 }
[17:44:46.554]                 else {
[17:44:46.554]                   if (TRUE) {
[17:44:46.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.554]                     {
[17:44:46.554]                       inherits <- base::inherits
[17:44:46.554]                       invokeRestart <- base::invokeRestart
[17:44:46.554]                       is.null <- base::is.null
[17:44:46.554]                       muffled <- FALSE
[17:44:46.554]                       if (inherits(cond, "message")) {
[17:44:46.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.554]                         if (muffled) 
[17:44:46.554]                           invokeRestart("muffleMessage")
[17:44:46.554]                       }
[17:44:46.554]                       else if (inherits(cond, "warning")) {
[17:44:46.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.554]                         if (muffled) 
[17:44:46.554]                           invokeRestart("muffleWarning")
[17:44:46.554]                       }
[17:44:46.554]                       else if (inherits(cond, "condition")) {
[17:44:46.554]                         if (!is.null(pattern)) {
[17:44:46.554]                           computeRestarts <- base::computeRestarts
[17:44:46.554]                           grepl <- base::grepl
[17:44:46.554]                           restarts <- computeRestarts(cond)
[17:44:46.554]                           for (restart in restarts) {
[17:44:46.554]                             name <- restart$name
[17:44:46.554]                             if (is.null(name)) 
[17:44:46.554]                               next
[17:44:46.554]                             if (!grepl(pattern, name)) 
[17:44:46.554]                               next
[17:44:46.554]                             invokeRestart(restart)
[17:44:46.554]                             muffled <- TRUE
[17:44:46.554]                             break
[17:44:46.554]                           }
[17:44:46.554]                         }
[17:44:46.554]                       }
[17:44:46.554]                       invisible(muffled)
[17:44:46.554]                     }
[17:44:46.554]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.554]                   }
[17:44:46.554]                 }
[17:44:46.554]             }
[17:44:46.554]         }))
[17:44:46.554]     }, error = function(ex) {
[17:44:46.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.554]                 ...future.rng), started = ...future.startTime, 
[17:44:46.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.554]             version = "1.8"), class = "FutureResult")
[17:44:46.554]     }, finally = {
[17:44:46.554]         if (!identical(...future.workdir, getwd())) 
[17:44:46.554]             setwd(...future.workdir)
[17:44:46.554]         {
[17:44:46.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.554]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.554]             }
[17:44:46.554]             base::options(...future.oldOptions)
[17:44:46.554]             if (.Platform$OS.type == "windows") {
[17:44:46.554]                 old_names <- names(...future.oldEnvVars)
[17:44:46.554]                 envs <- base::Sys.getenv()
[17:44:46.554]                 names <- names(envs)
[17:44:46.554]                 common <- intersect(names, old_names)
[17:44:46.554]                 added <- setdiff(names, old_names)
[17:44:46.554]                 removed <- setdiff(old_names, names)
[17:44:46.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.554]                   envs[common]]
[17:44:46.554]                 NAMES <- toupper(changed)
[17:44:46.554]                 args <- list()
[17:44:46.554]                 for (kk in seq_along(NAMES)) {
[17:44:46.554]                   name <- changed[[kk]]
[17:44:46.554]                   NAME <- NAMES[[kk]]
[17:44:46.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.554]                     next
[17:44:46.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.554]                 }
[17:44:46.554]                 NAMES <- toupper(added)
[17:44:46.554]                 for (kk in seq_along(NAMES)) {
[17:44:46.554]                   name <- added[[kk]]
[17:44:46.554]                   NAME <- NAMES[[kk]]
[17:44:46.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.554]                     next
[17:44:46.554]                   args[[name]] <- ""
[17:44:46.554]                 }
[17:44:46.554]                 NAMES <- toupper(removed)
[17:44:46.554]                 for (kk in seq_along(NAMES)) {
[17:44:46.554]                   name <- removed[[kk]]
[17:44:46.554]                   NAME <- NAMES[[kk]]
[17:44:46.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.554]                     next
[17:44:46.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.554]                 }
[17:44:46.554]                 if (length(args) > 0) 
[17:44:46.554]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.554]             }
[17:44:46.554]             else {
[17:44:46.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.554]             }
[17:44:46.554]             {
[17:44:46.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.554]                   0L) {
[17:44:46.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.554]                   base::options(opts)
[17:44:46.554]                 }
[17:44:46.554]                 {
[17:44:46.554]                   {
[17:44:46.554]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.554]                     NULL
[17:44:46.554]                   }
[17:44:46.554]                   options(future.plan = NULL)
[17:44:46.554]                   if (is.na(NA_character_)) 
[17:44:46.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.554]                     .init = FALSE)
[17:44:46.554]                 }
[17:44:46.554]             }
[17:44:46.554]         }
[17:44:46.554]     })
[17:44:46.554]     if (TRUE) {
[17:44:46.554]         base::sink(type = "output", split = FALSE)
[17:44:46.554]         if (TRUE) {
[17:44:46.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.554]         }
[17:44:46.554]         else {
[17:44:46.554]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.554]         }
[17:44:46.554]         base::close(...future.stdout)
[17:44:46.554]         ...future.stdout <- NULL
[17:44:46.554]     }
[17:44:46.554]     ...future.result$conditions <- ...future.conditions
[17:44:46.554]     ...future.result$finished <- base::Sys.time()
[17:44:46.554]     ...future.result
[17:44:46.554] }
[17:44:46.557] assign_globals() ...
[17:44:46.557] List of 5
[17:44:46.557]  $ ...future.FUN            :function (x, ...)  
[17:44:46.557]  $ MoreArgs                 : NULL
[17:44:46.557]  $ ...future.elements_ii    :List of 2
[17:44:46.557]   ..$ times:List of 2
[17:44:46.557]   .. ..$ : int 3
[17:44:46.557]   .. ..$ : int 4
[17:44:46.557]   ..$ x    :List of 2
[17:44:46.557]   .. ..$ : int 2
[17:44:46.557]   .. ..$ : int 1
[17:44:46.557]  $ ...future.seeds_ii       : NULL
[17:44:46.557]  $ ...future.globals.maxSize: NULL
[17:44:46.557]  - attr(*, "where")=List of 5
[17:44:46.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.557]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.557]  - attr(*, "resolved")= logi FALSE
[17:44:46.557]  - attr(*, "total_size")= num 280
[17:44:46.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.557]  - attr(*, "already-done")= logi TRUE
[17:44:46.565] - copied ‘...future.FUN’ to environment
[17:44:46.565] - copied ‘MoreArgs’ to environment
[17:44:46.566] - copied ‘...future.elements_ii’ to environment
[17:44:46.566] - copied ‘...future.seeds_ii’ to environment
[17:44:46.566] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.566] assign_globals() ... done
[17:44:46.566] requestCore(): workers = 2
[17:44:46.568] MulticoreFuture started
[17:44:46.568] - Launch lazy future ... done
[17:44:46.569] run() for ‘MulticoreFuture’ ... done
[17:44:46.569] Created future:
[17:44:46.569] plan(): Setting new future strategy stack:
[17:44:46.569] List of future strategies:
[17:44:46.569] 1. sequential:
[17:44:46.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.569]    - tweaked: FALSE
[17:44:46.569]    - call: NULL
[17:44:46.570] plan(): nbrOfWorkers() = 1
[17:44:46.572] plan(): Setting new future strategy stack:
[17:44:46.572] List of future strategies:
[17:44:46.572] 1. multicore:
[17:44:46.572]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.572]    - tweaked: FALSE
[17:44:46.572]    - call: plan(strategy)
[17:44:46.577] plan(): nbrOfWorkers() = 2
[17:44:46.569] MulticoreFuture:
[17:44:46.569] Label: ‘future_mapply-2’
[17:44:46.569] Expression:
[17:44:46.569] {
[17:44:46.569]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.569]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.569]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.569]         on.exit(options(oopts), add = TRUE)
[17:44:46.569]     }
[17:44:46.569]     {
[17:44:46.569]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.569]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.569]         do.call(mapply, args = args)
[17:44:46.569]     }
[17:44:46.569] }
[17:44:46.569] Lazy evaluation: FALSE
[17:44:46.569] Asynchronous evaluation: TRUE
[17:44:46.569] Local evaluation: TRUE
[17:44:46.569] Environment: R_GlobalEnv
[17:44:46.569] Capture standard output: TRUE
[17:44:46.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.569] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.569] Packages: <none>
[17:44:46.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.569] Resolved: TRUE
[17:44:46.569] Value: <not collected>
[17:44:46.569] Conditions captured: <none>
[17:44:46.569] Early signaling: FALSE
[17:44:46.569] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.569] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.578] Chunk #2 of 2 ... DONE
[17:44:46.579] Launching 2 futures (chunks) ... DONE
[17:44:46.579] Resolving 2 futures (chunks) ...
[17:44:46.579] resolve() on list ...
[17:44:46.579]  recursive: 0
[17:44:46.579]  length: 2
[17:44:46.579] 
[17:44:46.580] Future #1
[17:44:46.580] result() for MulticoreFuture ...
[17:44:46.581] result() for MulticoreFuture ...
[17:44:46.581] result() for MulticoreFuture ... done
[17:44:46.581] result() for MulticoreFuture ... done
[17:44:46.581] result() for MulticoreFuture ...
[17:44:46.581] result() for MulticoreFuture ... done
[17:44:46.582] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.582] - nx: 2
[17:44:46.582] - relay: TRUE
[17:44:46.582] - stdout: TRUE
[17:44:46.582] - signal: TRUE
[17:44:46.582] - resignal: FALSE
[17:44:46.582] - force: TRUE
[17:44:46.582] - relayed: [n=2] FALSE, FALSE
[17:44:46.583] - queued futures: [n=2] FALSE, FALSE
[17:44:46.583]  - until=1
[17:44:46.583]  - relaying element #1
[17:44:46.583] result() for MulticoreFuture ...
[17:44:46.583] result() for MulticoreFuture ... done
[17:44:46.583] result() for MulticoreFuture ...
[17:44:46.584] result() for MulticoreFuture ... done
[17:44:46.584] result() for MulticoreFuture ...
[17:44:46.584] result() for MulticoreFuture ... done
[17:44:46.584] result() for MulticoreFuture ...
[17:44:46.584] result() for MulticoreFuture ... done
[17:44:46.584] - relayed: [n=2] TRUE, FALSE
[17:44:46.585] - queued futures: [n=2] TRUE, FALSE
[17:44:46.585] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.585]  length: 1 (resolved future 1)
[17:44:46.585] Future #2
[17:44:46.585] result() for MulticoreFuture ...
[17:44:46.586] result() for MulticoreFuture ...
[17:44:46.586] result() for MulticoreFuture ... done
[17:44:46.586] result() for MulticoreFuture ... done
[17:44:46.587] result() for MulticoreFuture ...
[17:44:46.587] result() for MulticoreFuture ... done
[17:44:46.587] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.587] - nx: 2
[17:44:46.587] - relay: TRUE
[17:44:46.587] - stdout: TRUE
[17:44:46.587] - signal: TRUE
[17:44:46.588] - resignal: FALSE
[17:44:46.588] - force: TRUE
[17:44:46.588] - relayed: [n=2] TRUE, FALSE
[17:44:46.588] - queued futures: [n=2] TRUE, FALSE
[17:44:46.588]  - until=2
[17:44:46.588]  - relaying element #2
[17:44:46.588] result() for MulticoreFuture ...
[17:44:46.588] result() for MulticoreFuture ... done
[17:44:46.589] result() for MulticoreFuture ...
[17:44:46.589] result() for MulticoreFuture ... done
[17:44:46.589] result() for MulticoreFuture ...
[17:44:46.589] result() for MulticoreFuture ... done
[17:44:46.589] result() for MulticoreFuture ...
[17:44:46.589] result() for MulticoreFuture ... done
[17:44:46.589] - relayed: [n=2] TRUE, TRUE
[17:44:46.589] - queued futures: [n=2] TRUE, TRUE
[17:44:46.590] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.590]  length: 0 (resolved future 2)
[17:44:46.590] Relaying remaining futures
[17:44:46.590] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.590] - nx: 2
[17:44:46.590] - relay: TRUE
[17:44:46.590] - stdout: TRUE
[17:44:46.590] - signal: TRUE
[17:44:46.590] - resignal: FALSE
[17:44:46.591] - force: TRUE
[17:44:46.591] - relayed: [n=2] TRUE, TRUE
[17:44:46.591] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.591] - relayed: [n=2] TRUE, TRUE
[17:44:46.591] - queued futures: [n=2] TRUE, TRUE
[17:44:46.591] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.591] resolve() on list ... DONE
[17:44:46.591] result() for MulticoreFuture ...
[17:44:46.592] result() for MulticoreFuture ... done
[17:44:46.592] result() for MulticoreFuture ...
[17:44:46.592] result() for MulticoreFuture ... done
[17:44:46.592] result() for MulticoreFuture ...
[17:44:46.592] result() for MulticoreFuture ... done
[17:44:46.595] result() for MulticoreFuture ...
[17:44:46.595] result() for MulticoreFuture ... done
[17:44:46.595]  - Number of value chunks collected: 2
[17:44:46.595] Resolving 2 futures (chunks) ... DONE
[17:44:46.595] Reducing values from 2 chunks ...
[17:44:46.595]  - Number of values collected after concatenation: 4
[17:44:46.596]  - Number of values expected: 4
[17:44:46.596] Reducing values from 2 chunks ... DONE
[17:44:46.596] future_mapply() ... DONE
[17:44:46.596] future_mapply() ...
[17:44:46.601] Number of chunks: 2
[17:44:46.601] getGlobalsAndPackagesXApply() ...
[17:44:46.601]  - future.globals: TRUE
[17:44:46.601] getGlobalsAndPackages() ...
[17:44:46.601] Searching for globals...
[17:44:46.602] - globals found: [1] ‘FUN’
[17:44:46.602] Searching for globals ... DONE
[17:44:46.602] Resolving globals: FALSE
[17:44:46.603] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:46.603] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:46.603] - globals: [1] ‘FUN’
[17:44:46.603] 
[17:44:46.604] getGlobalsAndPackages() ... DONE
[17:44:46.604]  - globals found/used: [n=1] ‘FUN’
[17:44:46.604]  - needed namespaces: [n=0] 
[17:44:46.604] Finding globals ... DONE
[17:44:46.604] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.604] List of 2
[17:44:46.604]  $ ...future.FUN:function (x, ...)  
[17:44:46.604]  $ MoreArgs     :List of 1
[17:44:46.604]   ..$ x: num 42
[17:44:46.604]  - attr(*, "where")=List of 2
[17:44:46.604]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.604]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.604]  - attr(*, "resolved")= logi FALSE
[17:44:46.604]  - attr(*, "total_size")= num NA
[17:44:46.608] Packages to be attached in all futures: [n=0] 
[17:44:46.608] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.608] Number of futures (= number of chunks): 2
[17:44:46.608] Launching 2 futures (chunks) ...
[17:44:46.608] Chunk #1 of 2 ...
[17:44:46.608]  - Finding globals in '...' for chunk #1 ...
[17:44:46.609] getGlobalsAndPackages() ...
[17:44:46.609] Searching for globals...
[17:44:46.609] 
[17:44:46.609] Searching for globals ... DONE
[17:44:46.609] - globals: [0] <none>
[17:44:46.609] getGlobalsAndPackages() ... DONE
[17:44:46.609]    + additional globals found: [n=0] 
[17:44:46.610]    + additional namespaces needed: [n=0] 
[17:44:46.610]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.610]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.610]  - seeds: <none>
[17:44:46.610]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.610] getGlobalsAndPackages() ...
[17:44:46.610] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.610] Resolving globals: FALSE
[17:44:46.611] The total size of the 5 globals is 224 bytes (224 bytes)
[17:44:46.611] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:46.611] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.611] 
[17:44:46.612] getGlobalsAndPackages() ... DONE
[17:44:46.612] run() for ‘Future’ ...
[17:44:46.612] - state: ‘created’
[17:44:46.612] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.616] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.616]   - Field: ‘label’
[17:44:46.616]   - Field: ‘local’
[17:44:46.616]   - Field: ‘owner’
[17:44:46.616]   - Field: ‘envir’
[17:44:46.616]   - Field: ‘workers’
[17:44:46.616]   - Field: ‘packages’
[17:44:46.616]   - Field: ‘gc’
[17:44:46.617]   - Field: ‘job’
[17:44:46.617]   - Field: ‘conditions’
[17:44:46.617]   - Field: ‘expr’
[17:44:46.617]   - Field: ‘uuid’
[17:44:46.617]   - Field: ‘seed’
[17:44:46.617]   - Field: ‘version’
[17:44:46.617]   - Field: ‘result’
[17:44:46.617]   - Field: ‘asynchronous’
[17:44:46.617]   - Field: ‘calls’
[17:44:46.617]   - Field: ‘globals’
[17:44:46.617]   - Field: ‘stdout’
[17:44:46.617]   - Field: ‘earlySignal’
[17:44:46.618]   - Field: ‘lazy’
[17:44:46.618]   - Field: ‘state’
[17:44:46.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.618] - Launch lazy future ...
[17:44:46.618] Packages needed by the future expression (n = 0): <none>
[17:44:46.618] Packages needed by future strategies (n = 0): <none>
[17:44:46.619] {
[17:44:46.619]     {
[17:44:46.619]         {
[17:44:46.619]             ...future.startTime <- base::Sys.time()
[17:44:46.619]             {
[17:44:46.619]                 {
[17:44:46.619]                   {
[17:44:46.619]                     {
[17:44:46.619]                       base::local({
[17:44:46.619]                         has_future <- base::requireNamespace("future", 
[17:44:46.619]                           quietly = TRUE)
[17:44:46.619]                         if (has_future) {
[17:44:46.619]                           ns <- base::getNamespace("future")
[17:44:46.619]                           version <- ns[[".package"]][["version"]]
[17:44:46.619]                           if (is.null(version)) 
[17:44:46.619]                             version <- utils::packageVersion("future")
[17:44:46.619]                         }
[17:44:46.619]                         else {
[17:44:46.619]                           version <- NULL
[17:44:46.619]                         }
[17:44:46.619]                         if (!has_future || version < "1.8.0") {
[17:44:46.619]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.619]                             "", base::R.version$version.string), 
[17:44:46.619]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.619]                               "release", "version")], collapse = " "), 
[17:44:46.619]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.619]                             info)
[17:44:46.619]                           info <- base::paste(info, collapse = "; ")
[17:44:46.619]                           if (!has_future) {
[17:44:46.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.619]                               info)
[17:44:46.619]                           }
[17:44:46.619]                           else {
[17:44:46.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.619]                               info, version)
[17:44:46.619]                           }
[17:44:46.619]                           base::stop(msg)
[17:44:46.619]                         }
[17:44:46.619]                       })
[17:44:46.619]                     }
[17:44:46.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.619]                     base::options(mc.cores = 1L)
[17:44:46.619]                   }
[17:44:46.619]                   ...future.strategy.old <- future::plan("list")
[17:44:46.619]                   options(future.plan = NULL)
[17:44:46.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.619]                 }
[17:44:46.619]                 ...future.workdir <- getwd()
[17:44:46.619]             }
[17:44:46.619]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.619]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.619]         }
[17:44:46.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.619]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.619]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.619]             base::names(...future.oldOptions))
[17:44:46.619]     }
[17:44:46.619]     if (FALSE) {
[17:44:46.619]     }
[17:44:46.619]     else {
[17:44:46.619]         if (TRUE) {
[17:44:46.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.619]                 open = "w")
[17:44:46.619]         }
[17:44:46.619]         else {
[17:44:46.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.619]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.619]         }
[17:44:46.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.619]             base::sink(type = "output", split = FALSE)
[17:44:46.619]             base::close(...future.stdout)
[17:44:46.619]         }, add = TRUE)
[17:44:46.619]     }
[17:44:46.619]     ...future.frame <- base::sys.nframe()
[17:44:46.619]     ...future.conditions <- base::list()
[17:44:46.619]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.619]     if (FALSE) {
[17:44:46.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.619]     }
[17:44:46.619]     ...future.result <- base::tryCatch({
[17:44:46.619]         base::withCallingHandlers({
[17:44:46.619]             ...future.value <- base::withVisible(base::local({
[17:44:46.619]                 withCallingHandlers({
[17:44:46.619]                   {
[17:44:46.619]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.619]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.619]                       ...future.globals.maxSize)) {
[17:44:46.619]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.619]                       on.exit(options(oopts), add = TRUE)
[17:44:46.619]                     }
[17:44:46.619]                     {
[17:44:46.619]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.619]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.619]                         USE.NAMES = FALSE)
[17:44:46.619]                       do.call(mapply, args = args)
[17:44:46.619]                     }
[17:44:46.619]                   }
[17:44:46.619]                 }, immediateCondition = function(cond) {
[17:44:46.619]                   save_rds <- function (object, pathname, ...) 
[17:44:46.619]                   {
[17:44:46.619]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.619]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.619]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.619]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.619]                         fi_tmp[["mtime"]])
[17:44:46.619]                     }
[17:44:46.619]                     tryCatch({
[17:44:46.619]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.619]                     }, error = function(ex) {
[17:44:46.619]                       msg <- conditionMessage(ex)
[17:44:46.619]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.619]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.619]                         fi_tmp[["mtime"]], msg)
[17:44:46.619]                       ex$message <- msg
[17:44:46.619]                       stop(ex)
[17:44:46.619]                     })
[17:44:46.619]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.619]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.619]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.619]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.619]                       fi <- file.info(pathname)
[17:44:46.619]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.619]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.619]                         fi[["size"]], fi[["mtime"]])
[17:44:46.619]                       stop(msg)
[17:44:46.619]                     }
[17:44:46.619]                     invisible(pathname)
[17:44:46.619]                   }
[17:44:46.619]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.619]                     rootPath = tempdir()) 
[17:44:46.619]                   {
[17:44:46.619]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.619]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.619]                       tmpdir = path, fileext = ".rds")
[17:44:46.619]                     save_rds(obj, file)
[17:44:46.619]                   }
[17:44:46.619]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.619]                   {
[17:44:46.619]                     inherits <- base::inherits
[17:44:46.619]                     invokeRestart <- base::invokeRestart
[17:44:46.619]                     is.null <- base::is.null
[17:44:46.619]                     muffled <- FALSE
[17:44:46.619]                     if (inherits(cond, "message")) {
[17:44:46.619]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.619]                       if (muffled) 
[17:44:46.619]                         invokeRestart("muffleMessage")
[17:44:46.619]                     }
[17:44:46.619]                     else if (inherits(cond, "warning")) {
[17:44:46.619]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.619]                       if (muffled) 
[17:44:46.619]                         invokeRestart("muffleWarning")
[17:44:46.619]                     }
[17:44:46.619]                     else if (inherits(cond, "condition")) {
[17:44:46.619]                       if (!is.null(pattern)) {
[17:44:46.619]                         computeRestarts <- base::computeRestarts
[17:44:46.619]                         grepl <- base::grepl
[17:44:46.619]                         restarts <- computeRestarts(cond)
[17:44:46.619]                         for (restart in restarts) {
[17:44:46.619]                           name <- restart$name
[17:44:46.619]                           if (is.null(name)) 
[17:44:46.619]                             next
[17:44:46.619]                           if (!grepl(pattern, name)) 
[17:44:46.619]                             next
[17:44:46.619]                           invokeRestart(restart)
[17:44:46.619]                           muffled <- TRUE
[17:44:46.619]                           break
[17:44:46.619]                         }
[17:44:46.619]                       }
[17:44:46.619]                     }
[17:44:46.619]                     invisible(muffled)
[17:44:46.619]                   }
[17:44:46.619]                   muffleCondition(cond)
[17:44:46.619]                 })
[17:44:46.619]             }))
[17:44:46.619]             future::FutureResult(value = ...future.value$value, 
[17:44:46.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.619]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.619]                     ...future.globalenv.names))
[17:44:46.619]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.619]         }, condition = base::local({
[17:44:46.619]             c <- base::c
[17:44:46.619]             inherits <- base::inherits
[17:44:46.619]             invokeRestart <- base::invokeRestart
[17:44:46.619]             length <- base::length
[17:44:46.619]             list <- base::list
[17:44:46.619]             seq.int <- base::seq.int
[17:44:46.619]             signalCondition <- base::signalCondition
[17:44:46.619]             sys.calls <- base::sys.calls
[17:44:46.619]             `[[` <- base::`[[`
[17:44:46.619]             `+` <- base::`+`
[17:44:46.619]             `<<-` <- base::`<<-`
[17:44:46.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.619]                   3L)]
[17:44:46.619]             }
[17:44:46.619]             function(cond) {
[17:44:46.619]                 is_error <- inherits(cond, "error")
[17:44:46.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.619]                   NULL)
[17:44:46.619]                 if (is_error) {
[17:44:46.619]                   sessionInformation <- function() {
[17:44:46.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.619]                       search = base::search(), system = base::Sys.info())
[17:44:46.619]                   }
[17:44:46.619]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.619]                     cond$call), session = sessionInformation(), 
[17:44:46.619]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.619]                   signalCondition(cond)
[17:44:46.619]                 }
[17:44:46.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.619]                 "immediateCondition"))) {
[17:44:46.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.619]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.619]                   if (TRUE && !signal) {
[17:44:46.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.619]                     {
[17:44:46.619]                       inherits <- base::inherits
[17:44:46.619]                       invokeRestart <- base::invokeRestart
[17:44:46.619]                       is.null <- base::is.null
[17:44:46.619]                       muffled <- FALSE
[17:44:46.619]                       if (inherits(cond, "message")) {
[17:44:46.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.619]                         if (muffled) 
[17:44:46.619]                           invokeRestart("muffleMessage")
[17:44:46.619]                       }
[17:44:46.619]                       else if (inherits(cond, "warning")) {
[17:44:46.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.619]                         if (muffled) 
[17:44:46.619]                           invokeRestart("muffleWarning")
[17:44:46.619]                       }
[17:44:46.619]                       else if (inherits(cond, "condition")) {
[17:44:46.619]                         if (!is.null(pattern)) {
[17:44:46.619]                           computeRestarts <- base::computeRestarts
[17:44:46.619]                           grepl <- base::grepl
[17:44:46.619]                           restarts <- computeRestarts(cond)
[17:44:46.619]                           for (restart in restarts) {
[17:44:46.619]                             name <- restart$name
[17:44:46.619]                             if (is.null(name)) 
[17:44:46.619]                               next
[17:44:46.619]                             if (!grepl(pattern, name)) 
[17:44:46.619]                               next
[17:44:46.619]                             invokeRestart(restart)
[17:44:46.619]                             muffled <- TRUE
[17:44:46.619]                             break
[17:44:46.619]                           }
[17:44:46.619]                         }
[17:44:46.619]                       }
[17:44:46.619]                       invisible(muffled)
[17:44:46.619]                     }
[17:44:46.619]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.619]                   }
[17:44:46.619]                 }
[17:44:46.619]                 else {
[17:44:46.619]                   if (TRUE) {
[17:44:46.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.619]                     {
[17:44:46.619]                       inherits <- base::inherits
[17:44:46.619]                       invokeRestart <- base::invokeRestart
[17:44:46.619]                       is.null <- base::is.null
[17:44:46.619]                       muffled <- FALSE
[17:44:46.619]                       if (inherits(cond, "message")) {
[17:44:46.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.619]                         if (muffled) 
[17:44:46.619]                           invokeRestart("muffleMessage")
[17:44:46.619]                       }
[17:44:46.619]                       else if (inherits(cond, "warning")) {
[17:44:46.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.619]                         if (muffled) 
[17:44:46.619]                           invokeRestart("muffleWarning")
[17:44:46.619]                       }
[17:44:46.619]                       else if (inherits(cond, "condition")) {
[17:44:46.619]                         if (!is.null(pattern)) {
[17:44:46.619]                           computeRestarts <- base::computeRestarts
[17:44:46.619]                           grepl <- base::grepl
[17:44:46.619]                           restarts <- computeRestarts(cond)
[17:44:46.619]                           for (restart in restarts) {
[17:44:46.619]                             name <- restart$name
[17:44:46.619]                             if (is.null(name)) 
[17:44:46.619]                               next
[17:44:46.619]                             if (!grepl(pattern, name)) 
[17:44:46.619]                               next
[17:44:46.619]                             invokeRestart(restart)
[17:44:46.619]                             muffled <- TRUE
[17:44:46.619]                             break
[17:44:46.619]                           }
[17:44:46.619]                         }
[17:44:46.619]                       }
[17:44:46.619]                       invisible(muffled)
[17:44:46.619]                     }
[17:44:46.619]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.619]                   }
[17:44:46.619]                 }
[17:44:46.619]             }
[17:44:46.619]         }))
[17:44:46.619]     }, error = function(ex) {
[17:44:46.619]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.619]                 ...future.rng), started = ...future.startTime, 
[17:44:46.619]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.619]             version = "1.8"), class = "FutureResult")
[17:44:46.619]     }, finally = {
[17:44:46.619]         if (!identical(...future.workdir, getwd())) 
[17:44:46.619]             setwd(...future.workdir)
[17:44:46.619]         {
[17:44:46.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.619]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.619]             }
[17:44:46.619]             base::options(...future.oldOptions)
[17:44:46.619]             if (.Platform$OS.type == "windows") {
[17:44:46.619]                 old_names <- names(...future.oldEnvVars)
[17:44:46.619]                 envs <- base::Sys.getenv()
[17:44:46.619]                 names <- names(envs)
[17:44:46.619]                 common <- intersect(names, old_names)
[17:44:46.619]                 added <- setdiff(names, old_names)
[17:44:46.619]                 removed <- setdiff(old_names, names)
[17:44:46.619]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.619]                   envs[common]]
[17:44:46.619]                 NAMES <- toupper(changed)
[17:44:46.619]                 args <- list()
[17:44:46.619]                 for (kk in seq_along(NAMES)) {
[17:44:46.619]                   name <- changed[[kk]]
[17:44:46.619]                   NAME <- NAMES[[kk]]
[17:44:46.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.619]                     next
[17:44:46.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.619]                 }
[17:44:46.619]                 NAMES <- toupper(added)
[17:44:46.619]                 for (kk in seq_along(NAMES)) {
[17:44:46.619]                   name <- added[[kk]]
[17:44:46.619]                   NAME <- NAMES[[kk]]
[17:44:46.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.619]                     next
[17:44:46.619]                   args[[name]] <- ""
[17:44:46.619]                 }
[17:44:46.619]                 NAMES <- toupper(removed)
[17:44:46.619]                 for (kk in seq_along(NAMES)) {
[17:44:46.619]                   name <- removed[[kk]]
[17:44:46.619]                   NAME <- NAMES[[kk]]
[17:44:46.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.619]                     next
[17:44:46.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.619]                 }
[17:44:46.619]                 if (length(args) > 0) 
[17:44:46.619]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.619]             }
[17:44:46.619]             else {
[17:44:46.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.619]             }
[17:44:46.619]             {
[17:44:46.619]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.619]                   0L) {
[17:44:46.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.619]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.619]                   base::options(opts)
[17:44:46.619]                 }
[17:44:46.619]                 {
[17:44:46.619]                   {
[17:44:46.619]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.619]                     NULL
[17:44:46.619]                   }
[17:44:46.619]                   options(future.plan = NULL)
[17:44:46.619]                   if (is.na(NA_character_)) 
[17:44:46.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.619]                     .init = FALSE)
[17:44:46.619]                 }
[17:44:46.619]             }
[17:44:46.619]         }
[17:44:46.619]     })
[17:44:46.619]     if (TRUE) {
[17:44:46.619]         base::sink(type = "output", split = FALSE)
[17:44:46.619]         if (TRUE) {
[17:44:46.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.619]         }
[17:44:46.619]         else {
[17:44:46.619]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.619]         }
[17:44:46.619]         base::close(...future.stdout)
[17:44:46.619]         ...future.stdout <- NULL
[17:44:46.619]     }
[17:44:46.619]     ...future.result$conditions <- ...future.conditions
[17:44:46.619]     ...future.result$finished <- base::Sys.time()
[17:44:46.619]     ...future.result
[17:44:46.619] }
[17:44:46.621] assign_globals() ...
[17:44:46.621] List of 5
[17:44:46.621]  $ ...future.FUN            :function (x, ...)  
[17:44:46.621]  $ MoreArgs                 :List of 1
[17:44:46.621]   ..$ x: num 42
[17:44:46.621]  $ ...future.elements_ii    :List of 1
[17:44:46.621]   ..$ times:List of 2
[17:44:46.621]   .. ..$ : int 1
[17:44:46.621]   .. ..$ : int 2
[17:44:46.621]  $ ...future.seeds_ii       : NULL
[17:44:46.621]  $ ...future.globals.maxSize: NULL
[17:44:46.621]  - attr(*, "where")=List of 5
[17:44:46.621]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.621]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.621]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.621]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.621]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.621]  - attr(*, "resolved")= logi FALSE
[17:44:46.621]  - attr(*, "total_size")= num 224
[17:44:46.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.621]  - attr(*, "already-done")= logi TRUE
[17:44:46.628] - copied ‘...future.FUN’ to environment
[17:44:46.628] - copied ‘MoreArgs’ to environment
[17:44:46.628] - copied ‘...future.elements_ii’ to environment
[17:44:46.628] - copied ‘...future.seeds_ii’ to environment
[17:44:46.629] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.629] assign_globals() ... done
[17:44:46.629] requestCore(): workers = 2
[17:44:46.631] MulticoreFuture started
[17:44:46.631] - Launch lazy future ... done
[17:44:46.632] run() for ‘MulticoreFuture’ ... done
[17:44:46.632] plan(): Setting new future strategy stack:
[17:44:46.632] Created future:
[17:44:46.632] List of future strategies:
[17:44:46.632] 1. sequential:
[17:44:46.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.632]    - tweaked: FALSE
[17:44:46.632]    - call: NULL
[17:44:46.634] plan(): nbrOfWorkers() = 1
[17:44:46.637] plan(): Setting new future strategy stack:
[17:44:46.637] List of future strategies:
[17:44:46.637] 1. multicore:
[17:44:46.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.637]    - tweaked: FALSE
[17:44:46.637]    - call: plan(strategy)
[17:44:46.643] plan(): nbrOfWorkers() = 2
[17:44:46.633] MulticoreFuture:
[17:44:46.633] Label: ‘future_mapply-1’
[17:44:46.633] Expression:
[17:44:46.633] {
[17:44:46.633]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.633]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.633]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.633]         on.exit(options(oopts), add = TRUE)
[17:44:46.633]     }
[17:44:46.633]     {
[17:44:46.633]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.633]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.633]         do.call(mapply, args = args)
[17:44:46.633]     }
[17:44:46.633] }
[17:44:46.633] Lazy evaluation: FALSE
[17:44:46.633] Asynchronous evaluation: TRUE
[17:44:46.633] Local evaluation: TRUE
[17:44:46.633] Environment: R_GlobalEnv
[17:44:46.633] Capture standard output: TRUE
[17:44:46.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.633] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.633] Packages: <none>
[17:44:46.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.633] Resolved: TRUE
[17:44:46.633] Value: <not collected>
[17:44:46.633] Conditions captured: <none>
[17:44:46.633] Early signaling: FALSE
[17:44:46.633] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.633] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.644] Chunk #1 of 2 ... DONE
[17:44:46.644] Chunk #2 of 2 ...
[17:44:46.644]  - Finding globals in '...' for chunk #2 ...
[17:44:46.645] getGlobalsAndPackages() ...
[17:44:46.645] Searching for globals...
[17:44:46.645] 
[17:44:46.645] Searching for globals ... DONE
[17:44:46.646] - globals: [0] <none>
[17:44:46.646] getGlobalsAndPackages() ... DONE
[17:44:46.646]    + additional globals found: [n=0] 
[17:44:46.646]    + additional namespaces needed: [n=0] 
[17:44:46.646]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.646]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.646]  - seeds: <none>
[17:44:46.647]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.647] getGlobalsAndPackages() ...
[17:44:46.647] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.647] Resolving globals: FALSE
[17:44:46.648] The total size of the 5 globals is 224 bytes (224 bytes)
[17:44:46.649] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:46.649] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.649] 
[17:44:46.649] getGlobalsAndPackages() ... DONE
[17:44:46.650] run() for ‘Future’ ...
[17:44:46.650] - state: ‘created’
[17:44:46.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.655] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.655]   - Field: ‘label’
[17:44:46.655]   - Field: ‘local’
[17:44:46.656]   - Field: ‘owner’
[17:44:46.656]   - Field: ‘envir’
[17:44:46.656]   - Field: ‘workers’
[17:44:46.656]   - Field: ‘packages’
[17:44:46.656]   - Field: ‘gc’
[17:44:46.656]   - Field: ‘job’
[17:44:46.656]   - Field: ‘conditions’
[17:44:46.657]   - Field: ‘expr’
[17:44:46.657]   - Field: ‘uuid’
[17:44:46.657]   - Field: ‘seed’
[17:44:46.657]   - Field: ‘version’
[17:44:46.657]   - Field: ‘result’
[17:44:46.657]   - Field: ‘asynchronous’
[17:44:46.657]   - Field: ‘calls’
[17:44:46.658]   - Field: ‘globals’
[17:44:46.658]   - Field: ‘stdout’
[17:44:46.658]   - Field: ‘earlySignal’
[17:44:46.658]   - Field: ‘lazy’
[17:44:46.658]   - Field: ‘state’
[17:44:46.658] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.658] - Launch lazy future ...
[17:44:46.659] Packages needed by the future expression (n = 0): <none>
[17:44:46.659] Packages needed by future strategies (n = 0): <none>
[17:44:46.659] {
[17:44:46.659]     {
[17:44:46.659]         {
[17:44:46.659]             ...future.startTime <- base::Sys.time()
[17:44:46.659]             {
[17:44:46.659]                 {
[17:44:46.659]                   {
[17:44:46.659]                     {
[17:44:46.659]                       base::local({
[17:44:46.659]                         has_future <- base::requireNamespace("future", 
[17:44:46.659]                           quietly = TRUE)
[17:44:46.659]                         if (has_future) {
[17:44:46.659]                           ns <- base::getNamespace("future")
[17:44:46.659]                           version <- ns[[".package"]][["version"]]
[17:44:46.659]                           if (is.null(version)) 
[17:44:46.659]                             version <- utils::packageVersion("future")
[17:44:46.659]                         }
[17:44:46.659]                         else {
[17:44:46.659]                           version <- NULL
[17:44:46.659]                         }
[17:44:46.659]                         if (!has_future || version < "1.8.0") {
[17:44:46.659]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.659]                             "", base::R.version$version.string), 
[17:44:46.659]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.659]                               "release", "version")], collapse = " "), 
[17:44:46.659]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.659]                             info)
[17:44:46.659]                           info <- base::paste(info, collapse = "; ")
[17:44:46.659]                           if (!has_future) {
[17:44:46.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.659]                               info)
[17:44:46.659]                           }
[17:44:46.659]                           else {
[17:44:46.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.659]                               info, version)
[17:44:46.659]                           }
[17:44:46.659]                           base::stop(msg)
[17:44:46.659]                         }
[17:44:46.659]                       })
[17:44:46.659]                     }
[17:44:46.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.659]                     base::options(mc.cores = 1L)
[17:44:46.659]                   }
[17:44:46.659]                   ...future.strategy.old <- future::plan("list")
[17:44:46.659]                   options(future.plan = NULL)
[17:44:46.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.659]                 }
[17:44:46.659]                 ...future.workdir <- getwd()
[17:44:46.659]             }
[17:44:46.659]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.659]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.659]         }
[17:44:46.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.659]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.659]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.659]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.659]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.659]             base::names(...future.oldOptions))
[17:44:46.659]     }
[17:44:46.659]     if (FALSE) {
[17:44:46.659]     }
[17:44:46.659]     else {
[17:44:46.659]         if (TRUE) {
[17:44:46.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.659]                 open = "w")
[17:44:46.659]         }
[17:44:46.659]         else {
[17:44:46.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.659]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.659]         }
[17:44:46.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.659]             base::sink(type = "output", split = FALSE)
[17:44:46.659]             base::close(...future.stdout)
[17:44:46.659]         }, add = TRUE)
[17:44:46.659]     }
[17:44:46.659]     ...future.frame <- base::sys.nframe()
[17:44:46.659]     ...future.conditions <- base::list()
[17:44:46.659]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.659]     if (FALSE) {
[17:44:46.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.659]     }
[17:44:46.659]     ...future.result <- base::tryCatch({
[17:44:46.659]         base::withCallingHandlers({
[17:44:46.659]             ...future.value <- base::withVisible(base::local({
[17:44:46.659]                 withCallingHandlers({
[17:44:46.659]                   {
[17:44:46.659]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.659]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.659]                       ...future.globals.maxSize)) {
[17:44:46.659]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.659]                       on.exit(options(oopts), add = TRUE)
[17:44:46.659]                     }
[17:44:46.659]                     {
[17:44:46.659]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.659]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.659]                         USE.NAMES = FALSE)
[17:44:46.659]                       do.call(mapply, args = args)
[17:44:46.659]                     }
[17:44:46.659]                   }
[17:44:46.659]                 }, immediateCondition = function(cond) {
[17:44:46.659]                   save_rds <- function (object, pathname, ...) 
[17:44:46.659]                   {
[17:44:46.659]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.659]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.659]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.659]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.659]                         fi_tmp[["mtime"]])
[17:44:46.659]                     }
[17:44:46.659]                     tryCatch({
[17:44:46.659]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.659]                     }, error = function(ex) {
[17:44:46.659]                       msg <- conditionMessage(ex)
[17:44:46.659]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.659]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.659]                         fi_tmp[["mtime"]], msg)
[17:44:46.659]                       ex$message <- msg
[17:44:46.659]                       stop(ex)
[17:44:46.659]                     })
[17:44:46.659]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.659]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.659]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.659]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.659]                       fi <- file.info(pathname)
[17:44:46.659]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.659]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.659]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.659]                         fi[["size"]], fi[["mtime"]])
[17:44:46.659]                       stop(msg)
[17:44:46.659]                     }
[17:44:46.659]                     invisible(pathname)
[17:44:46.659]                   }
[17:44:46.659]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.659]                     rootPath = tempdir()) 
[17:44:46.659]                   {
[17:44:46.659]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.659]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.659]                       tmpdir = path, fileext = ".rds")
[17:44:46.659]                     save_rds(obj, file)
[17:44:46.659]                   }
[17:44:46.659]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.659]                   {
[17:44:46.659]                     inherits <- base::inherits
[17:44:46.659]                     invokeRestart <- base::invokeRestart
[17:44:46.659]                     is.null <- base::is.null
[17:44:46.659]                     muffled <- FALSE
[17:44:46.659]                     if (inherits(cond, "message")) {
[17:44:46.659]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.659]                       if (muffled) 
[17:44:46.659]                         invokeRestart("muffleMessage")
[17:44:46.659]                     }
[17:44:46.659]                     else if (inherits(cond, "warning")) {
[17:44:46.659]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.659]                       if (muffled) 
[17:44:46.659]                         invokeRestart("muffleWarning")
[17:44:46.659]                     }
[17:44:46.659]                     else if (inherits(cond, "condition")) {
[17:44:46.659]                       if (!is.null(pattern)) {
[17:44:46.659]                         computeRestarts <- base::computeRestarts
[17:44:46.659]                         grepl <- base::grepl
[17:44:46.659]                         restarts <- computeRestarts(cond)
[17:44:46.659]                         for (restart in restarts) {
[17:44:46.659]                           name <- restart$name
[17:44:46.659]                           if (is.null(name)) 
[17:44:46.659]                             next
[17:44:46.659]                           if (!grepl(pattern, name)) 
[17:44:46.659]                             next
[17:44:46.659]                           invokeRestart(restart)
[17:44:46.659]                           muffled <- TRUE
[17:44:46.659]                           break
[17:44:46.659]                         }
[17:44:46.659]                       }
[17:44:46.659]                     }
[17:44:46.659]                     invisible(muffled)
[17:44:46.659]                   }
[17:44:46.659]                   muffleCondition(cond)
[17:44:46.659]                 })
[17:44:46.659]             }))
[17:44:46.659]             future::FutureResult(value = ...future.value$value, 
[17:44:46.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.659]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.659]                     ...future.globalenv.names))
[17:44:46.659]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.659]         }, condition = base::local({
[17:44:46.659]             c <- base::c
[17:44:46.659]             inherits <- base::inherits
[17:44:46.659]             invokeRestart <- base::invokeRestart
[17:44:46.659]             length <- base::length
[17:44:46.659]             list <- base::list
[17:44:46.659]             seq.int <- base::seq.int
[17:44:46.659]             signalCondition <- base::signalCondition
[17:44:46.659]             sys.calls <- base::sys.calls
[17:44:46.659]             `[[` <- base::`[[`
[17:44:46.659]             `+` <- base::`+`
[17:44:46.659]             `<<-` <- base::`<<-`
[17:44:46.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.659]                   3L)]
[17:44:46.659]             }
[17:44:46.659]             function(cond) {
[17:44:46.659]                 is_error <- inherits(cond, "error")
[17:44:46.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.659]                   NULL)
[17:44:46.659]                 if (is_error) {
[17:44:46.659]                   sessionInformation <- function() {
[17:44:46.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.659]                       search = base::search(), system = base::Sys.info())
[17:44:46.659]                   }
[17:44:46.659]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.659]                     cond$call), session = sessionInformation(), 
[17:44:46.659]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.659]                   signalCondition(cond)
[17:44:46.659]                 }
[17:44:46.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.659]                 "immediateCondition"))) {
[17:44:46.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.659]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.659]                   if (TRUE && !signal) {
[17:44:46.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.659]                     {
[17:44:46.659]                       inherits <- base::inherits
[17:44:46.659]                       invokeRestart <- base::invokeRestart
[17:44:46.659]                       is.null <- base::is.null
[17:44:46.659]                       muffled <- FALSE
[17:44:46.659]                       if (inherits(cond, "message")) {
[17:44:46.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.659]                         if (muffled) 
[17:44:46.659]                           invokeRestart("muffleMessage")
[17:44:46.659]                       }
[17:44:46.659]                       else if (inherits(cond, "warning")) {
[17:44:46.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.659]                         if (muffled) 
[17:44:46.659]                           invokeRestart("muffleWarning")
[17:44:46.659]                       }
[17:44:46.659]                       else if (inherits(cond, "condition")) {
[17:44:46.659]                         if (!is.null(pattern)) {
[17:44:46.659]                           computeRestarts <- base::computeRestarts
[17:44:46.659]                           grepl <- base::grepl
[17:44:46.659]                           restarts <- computeRestarts(cond)
[17:44:46.659]                           for (restart in restarts) {
[17:44:46.659]                             name <- restart$name
[17:44:46.659]                             if (is.null(name)) 
[17:44:46.659]                               next
[17:44:46.659]                             if (!grepl(pattern, name)) 
[17:44:46.659]                               next
[17:44:46.659]                             invokeRestart(restart)
[17:44:46.659]                             muffled <- TRUE
[17:44:46.659]                             break
[17:44:46.659]                           }
[17:44:46.659]                         }
[17:44:46.659]                       }
[17:44:46.659]                       invisible(muffled)
[17:44:46.659]                     }
[17:44:46.659]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.659]                   }
[17:44:46.659]                 }
[17:44:46.659]                 else {
[17:44:46.659]                   if (TRUE) {
[17:44:46.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.659]                     {
[17:44:46.659]                       inherits <- base::inherits
[17:44:46.659]                       invokeRestart <- base::invokeRestart
[17:44:46.659]                       is.null <- base::is.null
[17:44:46.659]                       muffled <- FALSE
[17:44:46.659]                       if (inherits(cond, "message")) {
[17:44:46.659]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.659]                         if (muffled) 
[17:44:46.659]                           invokeRestart("muffleMessage")
[17:44:46.659]                       }
[17:44:46.659]                       else if (inherits(cond, "warning")) {
[17:44:46.659]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.659]                         if (muffled) 
[17:44:46.659]                           invokeRestart("muffleWarning")
[17:44:46.659]                       }
[17:44:46.659]                       else if (inherits(cond, "condition")) {
[17:44:46.659]                         if (!is.null(pattern)) {
[17:44:46.659]                           computeRestarts <- base::computeRestarts
[17:44:46.659]                           grepl <- base::grepl
[17:44:46.659]                           restarts <- computeRestarts(cond)
[17:44:46.659]                           for (restart in restarts) {
[17:44:46.659]                             name <- restart$name
[17:44:46.659]                             if (is.null(name)) 
[17:44:46.659]                               next
[17:44:46.659]                             if (!grepl(pattern, name)) 
[17:44:46.659]                               next
[17:44:46.659]                             invokeRestart(restart)
[17:44:46.659]                             muffled <- TRUE
[17:44:46.659]                             break
[17:44:46.659]                           }
[17:44:46.659]                         }
[17:44:46.659]                       }
[17:44:46.659]                       invisible(muffled)
[17:44:46.659]                     }
[17:44:46.659]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.659]                   }
[17:44:46.659]                 }
[17:44:46.659]             }
[17:44:46.659]         }))
[17:44:46.659]     }, error = function(ex) {
[17:44:46.659]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.659]                 ...future.rng), started = ...future.startTime, 
[17:44:46.659]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.659]             version = "1.8"), class = "FutureResult")
[17:44:46.659]     }, finally = {
[17:44:46.659]         if (!identical(...future.workdir, getwd())) 
[17:44:46.659]             setwd(...future.workdir)
[17:44:46.659]         {
[17:44:46.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.659]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.659]             }
[17:44:46.659]             base::options(...future.oldOptions)
[17:44:46.659]             if (.Platform$OS.type == "windows") {
[17:44:46.659]                 old_names <- names(...future.oldEnvVars)
[17:44:46.659]                 envs <- base::Sys.getenv()
[17:44:46.659]                 names <- names(envs)
[17:44:46.659]                 common <- intersect(names, old_names)
[17:44:46.659]                 added <- setdiff(names, old_names)
[17:44:46.659]                 removed <- setdiff(old_names, names)
[17:44:46.659]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.659]                   envs[common]]
[17:44:46.659]                 NAMES <- toupper(changed)
[17:44:46.659]                 args <- list()
[17:44:46.659]                 for (kk in seq_along(NAMES)) {
[17:44:46.659]                   name <- changed[[kk]]
[17:44:46.659]                   NAME <- NAMES[[kk]]
[17:44:46.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.659]                     next
[17:44:46.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.659]                 }
[17:44:46.659]                 NAMES <- toupper(added)
[17:44:46.659]                 for (kk in seq_along(NAMES)) {
[17:44:46.659]                   name <- added[[kk]]
[17:44:46.659]                   NAME <- NAMES[[kk]]
[17:44:46.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.659]                     next
[17:44:46.659]                   args[[name]] <- ""
[17:44:46.659]                 }
[17:44:46.659]                 NAMES <- toupper(removed)
[17:44:46.659]                 for (kk in seq_along(NAMES)) {
[17:44:46.659]                   name <- removed[[kk]]
[17:44:46.659]                   NAME <- NAMES[[kk]]
[17:44:46.659]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.659]                     next
[17:44:46.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.659]                 }
[17:44:46.659]                 if (length(args) > 0) 
[17:44:46.659]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.659]             }
[17:44:46.659]             else {
[17:44:46.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.659]             }
[17:44:46.659]             {
[17:44:46.659]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.659]                   0L) {
[17:44:46.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.659]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.659]                   base::options(opts)
[17:44:46.659]                 }
[17:44:46.659]                 {
[17:44:46.659]                   {
[17:44:46.659]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.659]                     NULL
[17:44:46.659]                   }
[17:44:46.659]                   options(future.plan = NULL)
[17:44:46.659]                   if (is.na(NA_character_)) 
[17:44:46.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.659]                     .init = FALSE)
[17:44:46.659]                 }
[17:44:46.659]             }
[17:44:46.659]         }
[17:44:46.659]     })
[17:44:46.659]     if (TRUE) {
[17:44:46.659]         base::sink(type = "output", split = FALSE)
[17:44:46.659]         if (TRUE) {
[17:44:46.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.659]         }
[17:44:46.659]         else {
[17:44:46.659]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.659]         }
[17:44:46.659]         base::close(...future.stdout)
[17:44:46.659]         ...future.stdout <- NULL
[17:44:46.659]     }
[17:44:46.659]     ...future.result$conditions <- ...future.conditions
[17:44:46.659]     ...future.result$finished <- base::Sys.time()
[17:44:46.659]     ...future.result
[17:44:46.659] }
[17:44:46.663] assign_globals() ...
[17:44:46.663] List of 5
[17:44:46.663]  $ ...future.FUN            :function (x, ...)  
[17:44:46.663]  $ MoreArgs                 :List of 1
[17:44:46.663]   ..$ x: num 42
[17:44:46.663]  $ ...future.elements_ii    :List of 1
[17:44:46.663]   ..$ times:List of 2
[17:44:46.663]   .. ..$ : int 3
[17:44:46.663]   .. ..$ : int 4
[17:44:46.663]  $ ...future.seeds_ii       : NULL
[17:44:46.663]  $ ...future.globals.maxSize: NULL
[17:44:46.663]  - attr(*, "where")=List of 5
[17:44:46.663]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.663]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.663]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.663]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.663]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.663]  - attr(*, "resolved")= logi FALSE
[17:44:46.663]  - attr(*, "total_size")= num 224
[17:44:46.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.663]  - attr(*, "already-done")= logi TRUE
[17:44:46.670] - copied ‘...future.FUN’ to environment
[17:44:46.671] - copied ‘MoreArgs’ to environment
[17:44:46.671] - copied ‘...future.elements_ii’ to environment
[17:44:46.671] - copied ‘...future.seeds_ii’ to environment
[17:44:46.671] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.671] assign_globals() ... done
[17:44:46.671] requestCore(): workers = 2
[17:44:46.674] MulticoreFuture started
[17:44:46.674] - Launch lazy future ... done
[17:44:46.674] run() for ‘MulticoreFuture’ ... done
[17:44:46.674] Created future:
[17:44:46.675] plan(): Setting new future strategy stack:
[17:44:46.675] List of future strategies:
[17:44:46.675] 1. sequential:
[17:44:46.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.675]    - tweaked: FALSE
[17:44:46.675]    - call: NULL
[17:44:46.676] plan(): nbrOfWorkers() = 1
[17:44:46.678] plan(): Setting new future strategy stack:
[17:44:46.678] List of future strategies:
[17:44:46.678] 1. multicore:
[17:44:46.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.678]    - tweaked: FALSE
[17:44:46.678]    - call: plan(strategy)
[17:44:46.683] plan(): nbrOfWorkers() = 2
[17:44:46.675] MulticoreFuture:
[17:44:46.675] Label: ‘future_mapply-2’
[17:44:46.675] Expression:
[17:44:46.675] {
[17:44:46.675]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.675]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.675]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.675]         on.exit(options(oopts), add = TRUE)
[17:44:46.675]     }
[17:44:46.675]     {
[17:44:46.675]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.675]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.675]         do.call(mapply, args = args)
[17:44:46.675]     }
[17:44:46.675] }
[17:44:46.675] Lazy evaluation: FALSE
[17:44:46.675] Asynchronous evaluation: TRUE
[17:44:46.675] Local evaluation: TRUE
[17:44:46.675] Environment: R_GlobalEnv
[17:44:46.675] Capture standard output: TRUE
[17:44:46.675] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.675] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.675] Packages: <none>
[17:44:46.675] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.675] Resolved: FALSE
[17:44:46.675] Value: <not collected>
[17:44:46.675] Conditions captured: <none>
[17:44:46.675] Early signaling: FALSE
[17:44:46.675] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.675] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.687] Chunk #2 of 2 ... DONE
[17:44:46.687] Launching 2 futures (chunks) ... DONE
[17:44:46.688] Resolving 2 futures (chunks) ...
[17:44:46.688] resolve() on list ...
[17:44:46.688]  recursive: 0
[17:44:46.688]  length: 2
[17:44:46.688] 
[17:44:46.689] Future #1
[17:44:46.689] result() for MulticoreFuture ...
[17:44:46.690] result() for MulticoreFuture ...
[17:44:46.690] result() for MulticoreFuture ... done
[17:44:46.690] result() for MulticoreFuture ... done
[17:44:46.690] result() for MulticoreFuture ...
[17:44:46.693] result() for MulticoreFuture ... done
[17:44:46.693] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.694] - nx: 2
[17:44:46.694] - relay: TRUE
[17:44:46.694] - stdout: TRUE
[17:44:46.695] - signal: TRUE
[17:44:46.695] - resignal: FALSE
[17:44:46.695] - force: TRUE
[17:44:46.695] - relayed: [n=2] FALSE, FALSE
[17:44:46.696] - queued futures: [n=2] FALSE, FALSE
[17:44:46.696]  - until=1
[17:44:46.697]  - relaying element #1
[17:44:46.697] result() for MulticoreFuture ...
[17:44:46.697] result() for MulticoreFuture ... done
[17:44:46.697] result() for MulticoreFuture ...
[17:44:46.698] result() for MulticoreFuture ... done
[17:44:46.698] result() for MulticoreFuture ...
[17:44:46.698] result() for MulticoreFuture ... done
[17:44:46.698] result() for MulticoreFuture ...
[17:44:46.699] result() for MulticoreFuture ... done
[17:44:46.699] - relayed: [n=2] TRUE, FALSE
[17:44:46.699] - queued futures: [n=2] TRUE, FALSE
[17:44:46.699] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.700]  length: 1 (resolved future 1)
[17:44:46.700] Future #2
[17:44:46.700] result() for MulticoreFuture ...
[17:44:46.701] result() for MulticoreFuture ...
[17:44:46.701] result() for MulticoreFuture ... done
[17:44:46.702] result() for MulticoreFuture ... done
[17:44:46.702] result() for MulticoreFuture ...
[17:44:46.702] result() for MulticoreFuture ... done
[17:44:46.702] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.702] - nx: 2
[17:44:46.702] - relay: TRUE
[17:44:46.702] - stdout: TRUE
[17:44:46.703] - signal: TRUE
[17:44:46.703] - resignal: FALSE
[17:44:46.703] - force: TRUE
[17:44:46.703] - relayed: [n=2] TRUE, FALSE
[17:44:46.703] - queued futures: [n=2] TRUE, FALSE
[17:44:46.703]  - until=2
[17:44:46.703]  - relaying element #2
[17:44:46.703] result() for MulticoreFuture ...
[17:44:46.704] result() for MulticoreFuture ... done
[17:44:46.704] result() for MulticoreFuture ...
[17:44:46.704] result() for MulticoreFuture ... done
[17:44:46.704] result() for MulticoreFuture ...
[17:44:46.704] result() for MulticoreFuture ... done
[17:44:46.704] result() for MulticoreFuture ...
[17:44:46.704] result() for MulticoreFuture ... done
[17:44:46.704] - relayed: [n=2] TRUE, TRUE
[17:44:46.704] - queued futures: [n=2] TRUE, TRUE
[17:44:46.705] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.705]  length: 0 (resolved future 2)
[17:44:46.705] Relaying remaining futures
[17:44:46.705] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.705] - nx: 2
[17:44:46.705] - relay: TRUE
[17:44:46.705] - stdout: TRUE
[17:44:46.705] - signal: TRUE
[17:44:46.705] - resignal: FALSE
[17:44:46.706] - force: TRUE
[17:44:46.706] - relayed: [n=2] TRUE, TRUE
[17:44:46.706] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.706] - relayed: [n=2] TRUE, TRUE
[17:44:46.706] - queued futures: [n=2] TRUE, TRUE
[17:44:46.706] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.706] resolve() on list ... DONE
[17:44:46.706] result() for MulticoreFuture ...
[17:44:46.706] result() for MulticoreFuture ... done
[17:44:46.707] result() for MulticoreFuture ...
[17:44:46.707] result() for MulticoreFuture ... done
[17:44:46.707] result() for MulticoreFuture ...
[17:44:46.707] result() for MulticoreFuture ... done
[17:44:46.707] result() for MulticoreFuture ...
[17:44:46.707] result() for MulticoreFuture ... done
[17:44:46.707]  - Number of value chunks collected: 2
[17:44:46.707] Resolving 2 futures (chunks) ... DONE
[17:44:46.707] Reducing values from 2 chunks ...
[17:44:46.708]  - Number of values collected after concatenation: 4
[17:44:46.708]  - Number of values expected: 4
[17:44:46.708] Reducing values from 2 chunks ... DONE
[17:44:46.708] future_mapply() ... DONE
[17:44:46.708] future_mapply() ...
[17:44:46.712] Number of chunks: 2
[17:44:46.712] getGlobalsAndPackagesXApply() ...
[17:44:46.713]  - future.globals: TRUE
[17:44:46.713] getGlobalsAndPackages() ...
[17:44:46.713] Searching for globals...
[17:44:46.714] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:46.714] Searching for globals ... DONE
[17:44:46.715] Resolving globals: FALSE
[17:44:46.715] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:46.715] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:46.716] - globals: [1] ‘FUN’
[17:44:46.716] 
[17:44:46.716] getGlobalsAndPackages() ... DONE
[17:44:46.716]  - globals found/used: [n=1] ‘FUN’
[17:44:46.716]  - needed namespaces: [n=0] 
[17:44:46.716] Finding globals ... DONE
[17:44:46.716] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.716] List of 2
[17:44:46.716]  $ ...future.FUN:function (x, y)  
[17:44:46.716]  $ MoreArgs     : NULL
[17:44:46.716]  - attr(*, "where")=List of 2
[17:44:46.716]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.716]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.716]  - attr(*, "resolved")= logi FALSE
[17:44:46.716]  - attr(*, "total_size")= num NA
[17:44:46.719] Packages to be attached in all futures: [n=0] 
[17:44:46.719] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.720] Number of futures (= number of chunks): 2
[17:44:46.720] Launching 2 futures (chunks) ...
[17:44:46.720] Chunk #1 of 2 ...
[17:44:46.720]  - Finding globals in '...' for chunk #1 ...
[17:44:46.720] getGlobalsAndPackages() ...
[17:44:46.720] Searching for globals...
[17:44:46.721] 
[17:44:46.721] Searching for globals ... DONE
[17:44:46.721] - globals: [0] <none>
[17:44:46.721] getGlobalsAndPackages() ... DONE
[17:44:46.721]    + additional globals found: [n=0] 
[17:44:46.721]    + additional namespaces needed: [n=0] 
[17:44:46.721]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.721]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.721]  - seeds: <none>
[17:44:46.721]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.722] getGlobalsAndPackages() ...
[17:44:46.722] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.722] Resolving globals: FALSE
[17:44:46.722] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:44:46.723] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.723] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.723] 
[17:44:46.723] getGlobalsAndPackages() ... DONE
[17:44:46.723] run() for ‘Future’ ...
[17:44:46.724] - state: ‘created’
[17:44:46.724] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.729] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.730]   - Field: ‘label’
[17:44:46.730]   - Field: ‘local’
[17:44:46.730]   - Field: ‘owner’
[17:44:46.730]   - Field: ‘envir’
[17:44:46.730]   - Field: ‘workers’
[17:44:46.730]   - Field: ‘packages’
[17:44:46.730]   - Field: ‘gc’
[17:44:46.730]   - Field: ‘job’
[17:44:46.730]   - Field: ‘conditions’
[17:44:46.731]   - Field: ‘expr’
[17:44:46.731]   - Field: ‘uuid’
[17:44:46.731]   - Field: ‘seed’
[17:44:46.731]   - Field: ‘version’
[17:44:46.731]   - Field: ‘result’
[17:44:46.731]   - Field: ‘asynchronous’
[17:44:46.731]   - Field: ‘calls’
[17:44:46.732]   - Field: ‘globals’
[17:44:46.732]   - Field: ‘stdout’
[17:44:46.732]   - Field: ‘earlySignal’
[17:44:46.732]   - Field: ‘lazy’
[17:44:46.732]   - Field: ‘state’
[17:44:46.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.732] - Launch lazy future ...
[17:44:46.732] Packages needed by the future expression (n = 0): <none>
[17:44:46.733] Packages needed by future strategies (n = 0): <none>
[17:44:46.733] {
[17:44:46.733]     {
[17:44:46.733]         {
[17:44:46.733]             ...future.startTime <- base::Sys.time()
[17:44:46.733]             {
[17:44:46.733]                 {
[17:44:46.733]                   {
[17:44:46.733]                     {
[17:44:46.733]                       base::local({
[17:44:46.733]                         has_future <- base::requireNamespace("future", 
[17:44:46.733]                           quietly = TRUE)
[17:44:46.733]                         if (has_future) {
[17:44:46.733]                           ns <- base::getNamespace("future")
[17:44:46.733]                           version <- ns[[".package"]][["version"]]
[17:44:46.733]                           if (is.null(version)) 
[17:44:46.733]                             version <- utils::packageVersion("future")
[17:44:46.733]                         }
[17:44:46.733]                         else {
[17:44:46.733]                           version <- NULL
[17:44:46.733]                         }
[17:44:46.733]                         if (!has_future || version < "1.8.0") {
[17:44:46.733]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.733]                             "", base::R.version$version.string), 
[17:44:46.733]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.733]                               "release", "version")], collapse = " "), 
[17:44:46.733]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.733]                             info)
[17:44:46.733]                           info <- base::paste(info, collapse = "; ")
[17:44:46.733]                           if (!has_future) {
[17:44:46.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.733]                               info)
[17:44:46.733]                           }
[17:44:46.733]                           else {
[17:44:46.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.733]                               info, version)
[17:44:46.733]                           }
[17:44:46.733]                           base::stop(msg)
[17:44:46.733]                         }
[17:44:46.733]                       })
[17:44:46.733]                     }
[17:44:46.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.733]                     base::options(mc.cores = 1L)
[17:44:46.733]                   }
[17:44:46.733]                   ...future.strategy.old <- future::plan("list")
[17:44:46.733]                   options(future.plan = NULL)
[17:44:46.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.733]                 }
[17:44:46.733]                 ...future.workdir <- getwd()
[17:44:46.733]             }
[17:44:46.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.733]         }
[17:44:46.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.733]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.733]             base::names(...future.oldOptions))
[17:44:46.733]     }
[17:44:46.733]     if (FALSE) {
[17:44:46.733]     }
[17:44:46.733]     else {
[17:44:46.733]         if (TRUE) {
[17:44:46.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.733]                 open = "w")
[17:44:46.733]         }
[17:44:46.733]         else {
[17:44:46.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.733]         }
[17:44:46.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.733]             base::sink(type = "output", split = FALSE)
[17:44:46.733]             base::close(...future.stdout)
[17:44:46.733]         }, add = TRUE)
[17:44:46.733]     }
[17:44:46.733]     ...future.frame <- base::sys.nframe()
[17:44:46.733]     ...future.conditions <- base::list()
[17:44:46.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.733]     if (FALSE) {
[17:44:46.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.733]     }
[17:44:46.733]     ...future.result <- base::tryCatch({
[17:44:46.733]         base::withCallingHandlers({
[17:44:46.733]             ...future.value <- base::withVisible(base::local({
[17:44:46.733]                 withCallingHandlers({
[17:44:46.733]                   {
[17:44:46.733]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.733]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.733]                       ...future.globals.maxSize)) {
[17:44:46.733]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.733]                       on.exit(options(oopts), add = TRUE)
[17:44:46.733]                     }
[17:44:46.733]                     {
[17:44:46.733]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.733]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.733]                         USE.NAMES = FALSE)
[17:44:46.733]                       do.call(mapply, args = args)
[17:44:46.733]                     }
[17:44:46.733]                   }
[17:44:46.733]                 }, immediateCondition = function(cond) {
[17:44:46.733]                   save_rds <- function (object, pathname, ...) 
[17:44:46.733]                   {
[17:44:46.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.733]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.733]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.733]                         fi_tmp[["mtime"]])
[17:44:46.733]                     }
[17:44:46.733]                     tryCatch({
[17:44:46.733]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.733]                     }, error = function(ex) {
[17:44:46.733]                       msg <- conditionMessage(ex)
[17:44:46.733]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.733]                         fi_tmp[["mtime"]], msg)
[17:44:46.733]                       ex$message <- msg
[17:44:46.733]                       stop(ex)
[17:44:46.733]                     })
[17:44:46.733]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.733]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.733]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.733]                       fi <- file.info(pathname)
[17:44:46.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.733]                         fi[["size"]], fi[["mtime"]])
[17:44:46.733]                       stop(msg)
[17:44:46.733]                     }
[17:44:46.733]                     invisible(pathname)
[17:44:46.733]                   }
[17:44:46.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.733]                     rootPath = tempdir()) 
[17:44:46.733]                   {
[17:44:46.733]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.733]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.733]                       tmpdir = path, fileext = ".rds")
[17:44:46.733]                     save_rds(obj, file)
[17:44:46.733]                   }
[17:44:46.733]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.733]                   {
[17:44:46.733]                     inherits <- base::inherits
[17:44:46.733]                     invokeRestart <- base::invokeRestart
[17:44:46.733]                     is.null <- base::is.null
[17:44:46.733]                     muffled <- FALSE
[17:44:46.733]                     if (inherits(cond, "message")) {
[17:44:46.733]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.733]                       if (muffled) 
[17:44:46.733]                         invokeRestart("muffleMessage")
[17:44:46.733]                     }
[17:44:46.733]                     else if (inherits(cond, "warning")) {
[17:44:46.733]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.733]                       if (muffled) 
[17:44:46.733]                         invokeRestart("muffleWarning")
[17:44:46.733]                     }
[17:44:46.733]                     else if (inherits(cond, "condition")) {
[17:44:46.733]                       if (!is.null(pattern)) {
[17:44:46.733]                         computeRestarts <- base::computeRestarts
[17:44:46.733]                         grepl <- base::grepl
[17:44:46.733]                         restarts <- computeRestarts(cond)
[17:44:46.733]                         for (restart in restarts) {
[17:44:46.733]                           name <- restart$name
[17:44:46.733]                           if (is.null(name)) 
[17:44:46.733]                             next
[17:44:46.733]                           if (!grepl(pattern, name)) 
[17:44:46.733]                             next
[17:44:46.733]                           invokeRestart(restart)
[17:44:46.733]                           muffled <- TRUE
[17:44:46.733]                           break
[17:44:46.733]                         }
[17:44:46.733]                       }
[17:44:46.733]                     }
[17:44:46.733]                     invisible(muffled)
[17:44:46.733]                   }
[17:44:46.733]                   muffleCondition(cond)
[17:44:46.733]                 })
[17:44:46.733]             }))
[17:44:46.733]             future::FutureResult(value = ...future.value$value, 
[17:44:46.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.733]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.733]                     ...future.globalenv.names))
[17:44:46.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.733]         }, condition = base::local({
[17:44:46.733]             c <- base::c
[17:44:46.733]             inherits <- base::inherits
[17:44:46.733]             invokeRestart <- base::invokeRestart
[17:44:46.733]             length <- base::length
[17:44:46.733]             list <- base::list
[17:44:46.733]             seq.int <- base::seq.int
[17:44:46.733]             signalCondition <- base::signalCondition
[17:44:46.733]             sys.calls <- base::sys.calls
[17:44:46.733]             `[[` <- base::`[[`
[17:44:46.733]             `+` <- base::`+`
[17:44:46.733]             `<<-` <- base::`<<-`
[17:44:46.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.733]                   3L)]
[17:44:46.733]             }
[17:44:46.733]             function(cond) {
[17:44:46.733]                 is_error <- inherits(cond, "error")
[17:44:46.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.733]                   NULL)
[17:44:46.733]                 if (is_error) {
[17:44:46.733]                   sessionInformation <- function() {
[17:44:46.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.733]                       search = base::search(), system = base::Sys.info())
[17:44:46.733]                   }
[17:44:46.733]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.733]                     cond$call), session = sessionInformation(), 
[17:44:46.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.733]                   signalCondition(cond)
[17:44:46.733]                 }
[17:44:46.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.733]                 "immediateCondition"))) {
[17:44:46.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.733]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.733]                   if (TRUE && !signal) {
[17:44:46.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.733]                     {
[17:44:46.733]                       inherits <- base::inherits
[17:44:46.733]                       invokeRestart <- base::invokeRestart
[17:44:46.733]                       is.null <- base::is.null
[17:44:46.733]                       muffled <- FALSE
[17:44:46.733]                       if (inherits(cond, "message")) {
[17:44:46.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.733]                         if (muffled) 
[17:44:46.733]                           invokeRestart("muffleMessage")
[17:44:46.733]                       }
[17:44:46.733]                       else if (inherits(cond, "warning")) {
[17:44:46.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.733]                         if (muffled) 
[17:44:46.733]                           invokeRestart("muffleWarning")
[17:44:46.733]                       }
[17:44:46.733]                       else if (inherits(cond, "condition")) {
[17:44:46.733]                         if (!is.null(pattern)) {
[17:44:46.733]                           computeRestarts <- base::computeRestarts
[17:44:46.733]                           grepl <- base::grepl
[17:44:46.733]                           restarts <- computeRestarts(cond)
[17:44:46.733]                           for (restart in restarts) {
[17:44:46.733]                             name <- restart$name
[17:44:46.733]                             if (is.null(name)) 
[17:44:46.733]                               next
[17:44:46.733]                             if (!grepl(pattern, name)) 
[17:44:46.733]                               next
[17:44:46.733]                             invokeRestart(restart)
[17:44:46.733]                             muffled <- TRUE
[17:44:46.733]                             break
[17:44:46.733]                           }
[17:44:46.733]                         }
[17:44:46.733]                       }
[17:44:46.733]                       invisible(muffled)
[17:44:46.733]                     }
[17:44:46.733]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.733]                   }
[17:44:46.733]                 }
[17:44:46.733]                 else {
[17:44:46.733]                   if (TRUE) {
[17:44:46.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.733]                     {
[17:44:46.733]                       inherits <- base::inherits
[17:44:46.733]                       invokeRestart <- base::invokeRestart
[17:44:46.733]                       is.null <- base::is.null
[17:44:46.733]                       muffled <- FALSE
[17:44:46.733]                       if (inherits(cond, "message")) {
[17:44:46.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.733]                         if (muffled) 
[17:44:46.733]                           invokeRestart("muffleMessage")
[17:44:46.733]                       }
[17:44:46.733]                       else if (inherits(cond, "warning")) {
[17:44:46.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.733]                         if (muffled) 
[17:44:46.733]                           invokeRestart("muffleWarning")
[17:44:46.733]                       }
[17:44:46.733]                       else if (inherits(cond, "condition")) {
[17:44:46.733]                         if (!is.null(pattern)) {
[17:44:46.733]                           computeRestarts <- base::computeRestarts
[17:44:46.733]                           grepl <- base::grepl
[17:44:46.733]                           restarts <- computeRestarts(cond)
[17:44:46.733]                           for (restart in restarts) {
[17:44:46.733]                             name <- restart$name
[17:44:46.733]                             if (is.null(name)) 
[17:44:46.733]                               next
[17:44:46.733]                             if (!grepl(pattern, name)) 
[17:44:46.733]                               next
[17:44:46.733]                             invokeRestart(restart)
[17:44:46.733]                             muffled <- TRUE
[17:44:46.733]                             break
[17:44:46.733]                           }
[17:44:46.733]                         }
[17:44:46.733]                       }
[17:44:46.733]                       invisible(muffled)
[17:44:46.733]                     }
[17:44:46.733]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.733]                   }
[17:44:46.733]                 }
[17:44:46.733]             }
[17:44:46.733]         }))
[17:44:46.733]     }, error = function(ex) {
[17:44:46.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.733]                 ...future.rng), started = ...future.startTime, 
[17:44:46.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.733]             version = "1.8"), class = "FutureResult")
[17:44:46.733]     }, finally = {
[17:44:46.733]         if (!identical(...future.workdir, getwd())) 
[17:44:46.733]             setwd(...future.workdir)
[17:44:46.733]         {
[17:44:46.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.733]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.733]             }
[17:44:46.733]             base::options(...future.oldOptions)
[17:44:46.733]             if (.Platform$OS.type == "windows") {
[17:44:46.733]                 old_names <- names(...future.oldEnvVars)
[17:44:46.733]                 envs <- base::Sys.getenv()
[17:44:46.733]                 names <- names(envs)
[17:44:46.733]                 common <- intersect(names, old_names)
[17:44:46.733]                 added <- setdiff(names, old_names)
[17:44:46.733]                 removed <- setdiff(old_names, names)
[17:44:46.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.733]                   envs[common]]
[17:44:46.733]                 NAMES <- toupper(changed)
[17:44:46.733]                 args <- list()
[17:44:46.733]                 for (kk in seq_along(NAMES)) {
[17:44:46.733]                   name <- changed[[kk]]
[17:44:46.733]                   NAME <- NAMES[[kk]]
[17:44:46.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.733]                     next
[17:44:46.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.733]                 }
[17:44:46.733]                 NAMES <- toupper(added)
[17:44:46.733]                 for (kk in seq_along(NAMES)) {
[17:44:46.733]                   name <- added[[kk]]
[17:44:46.733]                   NAME <- NAMES[[kk]]
[17:44:46.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.733]                     next
[17:44:46.733]                   args[[name]] <- ""
[17:44:46.733]                 }
[17:44:46.733]                 NAMES <- toupper(removed)
[17:44:46.733]                 for (kk in seq_along(NAMES)) {
[17:44:46.733]                   name <- removed[[kk]]
[17:44:46.733]                   NAME <- NAMES[[kk]]
[17:44:46.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.733]                     next
[17:44:46.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.733]                 }
[17:44:46.733]                 if (length(args) > 0) 
[17:44:46.733]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.733]             }
[17:44:46.733]             else {
[17:44:46.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.733]             }
[17:44:46.733]             {
[17:44:46.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.733]                   0L) {
[17:44:46.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.733]                   base::options(opts)
[17:44:46.733]                 }
[17:44:46.733]                 {
[17:44:46.733]                   {
[17:44:46.733]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.733]                     NULL
[17:44:46.733]                   }
[17:44:46.733]                   options(future.plan = NULL)
[17:44:46.733]                   if (is.na(NA_character_)) 
[17:44:46.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.733]                     .init = FALSE)
[17:44:46.733]                 }
[17:44:46.733]             }
[17:44:46.733]         }
[17:44:46.733]     })
[17:44:46.733]     if (TRUE) {
[17:44:46.733]         base::sink(type = "output", split = FALSE)
[17:44:46.733]         if (TRUE) {
[17:44:46.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.733]         }
[17:44:46.733]         else {
[17:44:46.733]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.733]         }
[17:44:46.733]         base::close(...future.stdout)
[17:44:46.733]         ...future.stdout <- NULL
[17:44:46.733]     }
[17:44:46.733]     ...future.result$conditions <- ...future.conditions
[17:44:46.733]     ...future.result$finished <- base::Sys.time()
[17:44:46.733]     ...future.result
[17:44:46.733] }
[17:44:46.735] assign_globals() ...
[17:44:46.736] List of 5
[17:44:46.736]  $ ...future.FUN            :function (x, y)  
[17:44:46.736]  $ MoreArgs                 : NULL
[17:44:46.736]  $ ...future.elements_ii    :List of 2
[17:44:46.736]   ..$ :List of 1
[17:44:46.736]   .. ..$ a: num 1
[17:44:46.736]   ..$ :List of 1
[17:44:46.736]   .. ..$ A: num 10
[17:44:46.736]  $ ...future.seeds_ii       : NULL
[17:44:46.736]  $ ...future.globals.maxSize: NULL
[17:44:46.736]  - attr(*, "where")=List of 5
[17:44:46.736]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.736]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.736]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.736]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.736]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.736]  - attr(*, "resolved")= logi FALSE
[17:44:46.736]  - attr(*, "total_size")= num 2088
[17:44:46.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.736]  - attr(*, "already-done")= logi TRUE
[17:44:46.741] - reassign environment for ‘...future.FUN’
[17:44:46.741] - copied ‘...future.FUN’ to environment
[17:44:46.741] - copied ‘MoreArgs’ to environment
[17:44:46.741] - copied ‘...future.elements_ii’ to environment
[17:44:46.741] - copied ‘...future.seeds_ii’ to environment
[17:44:46.741] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.741] assign_globals() ... done
[17:44:46.741] requestCore(): workers = 2
[17:44:46.744] MulticoreFuture started
[17:44:46.744] - Launch lazy future ... done
[17:44:46.744] run() for ‘MulticoreFuture’ ... done
[17:44:46.744] Created future:
[17:44:46.745] plan(): Setting new future strategy stack:
[17:44:46.745] List of future strategies:
[17:44:46.745] 1. sequential:
[17:44:46.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.745]    - tweaked: FALSE
[17:44:46.745]    - call: NULL
[17:44:46.746] plan(): nbrOfWorkers() = 1
[17:44:46.748] plan(): Setting new future strategy stack:
[17:44:46.748] List of future strategies:
[17:44:46.748] 1. multicore:
[17:44:46.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.748]    - tweaked: FALSE
[17:44:46.748]    - call: plan(strategy)
[17:44:46.753] plan(): nbrOfWorkers() = 2
[17:44:46.744] MulticoreFuture:
[17:44:46.744] Label: ‘future_mapply-1’
[17:44:46.744] Expression:
[17:44:46.744] {
[17:44:46.744]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.744]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.744]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.744]         on.exit(options(oopts), add = TRUE)
[17:44:46.744]     }
[17:44:46.744]     {
[17:44:46.744]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.744]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.744]         do.call(mapply, args = args)
[17:44:46.744]     }
[17:44:46.744] }
[17:44:46.744] Lazy evaluation: FALSE
[17:44:46.744] Asynchronous evaluation: TRUE
[17:44:46.744] Local evaluation: TRUE
[17:44:46.744] Environment: R_GlobalEnv
[17:44:46.744] Capture standard output: TRUE
[17:44:46.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.744] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.744] Packages: <none>
[17:44:46.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.744] Resolved: TRUE
[17:44:46.744] Value: <not collected>
[17:44:46.744] Conditions captured: <none>
[17:44:46.744] Early signaling: FALSE
[17:44:46.744] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.754] Chunk #1 of 2 ... DONE
[17:44:46.754] Chunk #2 of 2 ...
[17:44:46.755]  - Finding globals in '...' for chunk #2 ...
[17:44:46.755] getGlobalsAndPackages() ...
[17:44:46.755] Searching for globals...
[17:44:46.755] 
[17:44:46.756] Searching for globals ... DONE
[17:44:46.756] - globals: [0] <none>
[17:44:46.756] getGlobalsAndPackages() ... DONE
[17:44:46.756]    + additional globals found: [n=0] 
[17:44:46.756]    + additional namespaces needed: [n=0] 
[17:44:46.756]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.756]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.757]  - seeds: <none>
[17:44:46.757]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.757] getGlobalsAndPackages() ...
[17:44:46.757] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.757] Resolving globals: FALSE
[17:44:46.758] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:44:46.759] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.759] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.759] 
[17:44:46.759] getGlobalsAndPackages() ... DONE
[17:44:46.760] run() for ‘Future’ ...
[17:44:46.760] - state: ‘created’
[17:44:46.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.765] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.765]   - Field: ‘label’
[17:44:46.766]   - Field: ‘local’
[17:44:46.766]   - Field: ‘owner’
[17:44:46.766]   - Field: ‘envir’
[17:44:46.766]   - Field: ‘workers’
[17:44:46.766]   - Field: ‘packages’
[17:44:46.766]   - Field: ‘gc’
[17:44:46.767]   - Field: ‘job’
[17:44:46.767]   - Field: ‘conditions’
[17:44:46.767]   - Field: ‘expr’
[17:44:46.767]   - Field: ‘uuid’
[17:44:46.767]   - Field: ‘seed’
[17:44:46.767]   - Field: ‘version’
[17:44:46.767]   - Field: ‘result’
[17:44:46.768]   - Field: ‘asynchronous’
[17:44:46.768]   - Field: ‘calls’
[17:44:46.768]   - Field: ‘globals’
[17:44:46.768]   - Field: ‘stdout’
[17:44:46.768]   - Field: ‘earlySignal’
[17:44:46.768]   - Field: ‘lazy’
[17:44:46.769]   - Field: ‘state’
[17:44:46.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.769] - Launch lazy future ...
[17:44:46.769] Packages needed by the future expression (n = 0): <none>
[17:44:46.769] Packages needed by future strategies (n = 0): <none>
[17:44:46.770] {
[17:44:46.770]     {
[17:44:46.770]         {
[17:44:46.770]             ...future.startTime <- base::Sys.time()
[17:44:46.770]             {
[17:44:46.770]                 {
[17:44:46.770]                   {
[17:44:46.770]                     {
[17:44:46.770]                       base::local({
[17:44:46.770]                         has_future <- base::requireNamespace("future", 
[17:44:46.770]                           quietly = TRUE)
[17:44:46.770]                         if (has_future) {
[17:44:46.770]                           ns <- base::getNamespace("future")
[17:44:46.770]                           version <- ns[[".package"]][["version"]]
[17:44:46.770]                           if (is.null(version)) 
[17:44:46.770]                             version <- utils::packageVersion("future")
[17:44:46.770]                         }
[17:44:46.770]                         else {
[17:44:46.770]                           version <- NULL
[17:44:46.770]                         }
[17:44:46.770]                         if (!has_future || version < "1.8.0") {
[17:44:46.770]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.770]                             "", base::R.version$version.string), 
[17:44:46.770]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.770]                               "release", "version")], collapse = " "), 
[17:44:46.770]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.770]                             info)
[17:44:46.770]                           info <- base::paste(info, collapse = "; ")
[17:44:46.770]                           if (!has_future) {
[17:44:46.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.770]                               info)
[17:44:46.770]                           }
[17:44:46.770]                           else {
[17:44:46.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.770]                               info, version)
[17:44:46.770]                           }
[17:44:46.770]                           base::stop(msg)
[17:44:46.770]                         }
[17:44:46.770]                       })
[17:44:46.770]                     }
[17:44:46.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.770]                     base::options(mc.cores = 1L)
[17:44:46.770]                   }
[17:44:46.770]                   ...future.strategy.old <- future::plan("list")
[17:44:46.770]                   options(future.plan = NULL)
[17:44:46.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.770]                 }
[17:44:46.770]                 ...future.workdir <- getwd()
[17:44:46.770]             }
[17:44:46.770]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.770]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.770]         }
[17:44:46.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.770]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.770]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.770]             base::names(...future.oldOptions))
[17:44:46.770]     }
[17:44:46.770]     if (FALSE) {
[17:44:46.770]     }
[17:44:46.770]     else {
[17:44:46.770]         if (TRUE) {
[17:44:46.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.770]                 open = "w")
[17:44:46.770]         }
[17:44:46.770]         else {
[17:44:46.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.770]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.770]         }
[17:44:46.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.770]             base::sink(type = "output", split = FALSE)
[17:44:46.770]             base::close(...future.stdout)
[17:44:46.770]         }, add = TRUE)
[17:44:46.770]     }
[17:44:46.770]     ...future.frame <- base::sys.nframe()
[17:44:46.770]     ...future.conditions <- base::list()
[17:44:46.770]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.770]     if (FALSE) {
[17:44:46.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.770]     }
[17:44:46.770]     ...future.result <- base::tryCatch({
[17:44:46.770]         base::withCallingHandlers({
[17:44:46.770]             ...future.value <- base::withVisible(base::local({
[17:44:46.770]                 withCallingHandlers({
[17:44:46.770]                   {
[17:44:46.770]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.770]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.770]                       ...future.globals.maxSize)) {
[17:44:46.770]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.770]                       on.exit(options(oopts), add = TRUE)
[17:44:46.770]                     }
[17:44:46.770]                     {
[17:44:46.770]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.770]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.770]                         USE.NAMES = FALSE)
[17:44:46.770]                       do.call(mapply, args = args)
[17:44:46.770]                     }
[17:44:46.770]                   }
[17:44:46.770]                 }, immediateCondition = function(cond) {
[17:44:46.770]                   save_rds <- function (object, pathname, ...) 
[17:44:46.770]                   {
[17:44:46.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.770]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.770]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.770]                         fi_tmp[["mtime"]])
[17:44:46.770]                     }
[17:44:46.770]                     tryCatch({
[17:44:46.770]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.770]                     }, error = function(ex) {
[17:44:46.770]                       msg <- conditionMessage(ex)
[17:44:46.770]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.770]                         fi_tmp[["mtime"]], msg)
[17:44:46.770]                       ex$message <- msg
[17:44:46.770]                       stop(ex)
[17:44:46.770]                     })
[17:44:46.770]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.770]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.770]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.770]                       fi <- file.info(pathname)
[17:44:46.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.770]                         fi[["size"]], fi[["mtime"]])
[17:44:46.770]                       stop(msg)
[17:44:46.770]                     }
[17:44:46.770]                     invisible(pathname)
[17:44:46.770]                   }
[17:44:46.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.770]                     rootPath = tempdir()) 
[17:44:46.770]                   {
[17:44:46.770]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.770]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.770]                       tmpdir = path, fileext = ".rds")
[17:44:46.770]                     save_rds(obj, file)
[17:44:46.770]                   }
[17:44:46.770]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.770]                   {
[17:44:46.770]                     inherits <- base::inherits
[17:44:46.770]                     invokeRestart <- base::invokeRestart
[17:44:46.770]                     is.null <- base::is.null
[17:44:46.770]                     muffled <- FALSE
[17:44:46.770]                     if (inherits(cond, "message")) {
[17:44:46.770]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.770]                       if (muffled) 
[17:44:46.770]                         invokeRestart("muffleMessage")
[17:44:46.770]                     }
[17:44:46.770]                     else if (inherits(cond, "warning")) {
[17:44:46.770]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.770]                       if (muffled) 
[17:44:46.770]                         invokeRestart("muffleWarning")
[17:44:46.770]                     }
[17:44:46.770]                     else if (inherits(cond, "condition")) {
[17:44:46.770]                       if (!is.null(pattern)) {
[17:44:46.770]                         computeRestarts <- base::computeRestarts
[17:44:46.770]                         grepl <- base::grepl
[17:44:46.770]                         restarts <- computeRestarts(cond)
[17:44:46.770]                         for (restart in restarts) {
[17:44:46.770]                           name <- restart$name
[17:44:46.770]                           if (is.null(name)) 
[17:44:46.770]                             next
[17:44:46.770]                           if (!grepl(pattern, name)) 
[17:44:46.770]                             next
[17:44:46.770]                           invokeRestart(restart)
[17:44:46.770]                           muffled <- TRUE
[17:44:46.770]                           break
[17:44:46.770]                         }
[17:44:46.770]                       }
[17:44:46.770]                     }
[17:44:46.770]                     invisible(muffled)
[17:44:46.770]                   }
[17:44:46.770]                   muffleCondition(cond)
[17:44:46.770]                 })
[17:44:46.770]             }))
[17:44:46.770]             future::FutureResult(value = ...future.value$value, 
[17:44:46.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.770]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.770]                     ...future.globalenv.names))
[17:44:46.770]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.770]         }, condition = base::local({
[17:44:46.770]             c <- base::c
[17:44:46.770]             inherits <- base::inherits
[17:44:46.770]             invokeRestart <- base::invokeRestart
[17:44:46.770]             length <- base::length
[17:44:46.770]             list <- base::list
[17:44:46.770]             seq.int <- base::seq.int
[17:44:46.770]             signalCondition <- base::signalCondition
[17:44:46.770]             sys.calls <- base::sys.calls
[17:44:46.770]             `[[` <- base::`[[`
[17:44:46.770]             `+` <- base::`+`
[17:44:46.770]             `<<-` <- base::`<<-`
[17:44:46.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.770]                   3L)]
[17:44:46.770]             }
[17:44:46.770]             function(cond) {
[17:44:46.770]                 is_error <- inherits(cond, "error")
[17:44:46.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.770]                   NULL)
[17:44:46.770]                 if (is_error) {
[17:44:46.770]                   sessionInformation <- function() {
[17:44:46.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.770]                       search = base::search(), system = base::Sys.info())
[17:44:46.770]                   }
[17:44:46.770]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.770]                     cond$call), session = sessionInformation(), 
[17:44:46.770]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.770]                   signalCondition(cond)
[17:44:46.770]                 }
[17:44:46.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.770]                 "immediateCondition"))) {
[17:44:46.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.770]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.770]                   if (TRUE && !signal) {
[17:44:46.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.770]                     {
[17:44:46.770]                       inherits <- base::inherits
[17:44:46.770]                       invokeRestart <- base::invokeRestart
[17:44:46.770]                       is.null <- base::is.null
[17:44:46.770]                       muffled <- FALSE
[17:44:46.770]                       if (inherits(cond, "message")) {
[17:44:46.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.770]                         if (muffled) 
[17:44:46.770]                           invokeRestart("muffleMessage")
[17:44:46.770]                       }
[17:44:46.770]                       else if (inherits(cond, "warning")) {
[17:44:46.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.770]                         if (muffled) 
[17:44:46.770]                           invokeRestart("muffleWarning")
[17:44:46.770]                       }
[17:44:46.770]                       else if (inherits(cond, "condition")) {
[17:44:46.770]                         if (!is.null(pattern)) {
[17:44:46.770]                           computeRestarts <- base::computeRestarts
[17:44:46.770]                           grepl <- base::grepl
[17:44:46.770]                           restarts <- computeRestarts(cond)
[17:44:46.770]                           for (restart in restarts) {
[17:44:46.770]                             name <- restart$name
[17:44:46.770]                             if (is.null(name)) 
[17:44:46.770]                               next
[17:44:46.770]                             if (!grepl(pattern, name)) 
[17:44:46.770]                               next
[17:44:46.770]                             invokeRestart(restart)
[17:44:46.770]                             muffled <- TRUE
[17:44:46.770]                             break
[17:44:46.770]                           }
[17:44:46.770]                         }
[17:44:46.770]                       }
[17:44:46.770]                       invisible(muffled)
[17:44:46.770]                     }
[17:44:46.770]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.770]                   }
[17:44:46.770]                 }
[17:44:46.770]                 else {
[17:44:46.770]                   if (TRUE) {
[17:44:46.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.770]                     {
[17:44:46.770]                       inherits <- base::inherits
[17:44:46.770]                       invokeRestart <- base::invokeRestart
[17:44:46.770]                       is.null <- base::is.null
[17:44:46.770]                       muffled <- FALSE
[17:44:46.770]                       if (inherits(cond, "message")) {
[17:44:46.770]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.770]                         if (muffled) 
[17:44:46.770]                           invokeRestart("muffleMessage")
[17:44:46.770]                       }
[17:44:46.770]                       else if (inherits(cond, "warning")) {
[17:44:46.770]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.770]                         if (muffled) 
[17:44:46.770]                           invokeRestart("muffleWarning")
[17:44:46.770]                       }
[17:44:46.770]                       else if (inherits(cond, "condition")) {
[17:44:46.770]                         if (!is.null(pattern)) {
[17:44:46.770]                           computeRestarts <- base::computeRestarts
[17:44:46.770]                           grepl <- base::grepl
[17:44:46.770]                           restarts <- computeRestarts(cond)
[17:44:46.770]                           for (restart in restarts) {
[17:44:46.770]                             name <- restart$name
[17:44:46.770]                             if (is.null(name)) 
[17:44:46.770]                               next
[17:44:46.770]                             if (!grepl(pattern, name)) 
[17:44:46.770]                               next
[17:44:46.770]                             invokeRestart(restart)
[17:44:46.770]                             muffled <- TRUE
[17:44:46.770]                             break
[17:44:46.770]                           }
[17:44:46.770]                         }
[17:44:46.770]                       }
[17:44:46.770]                       invisible(muffled)
[17:44:46.770]                     }
[17:44:46.770]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.770]                   }
[17:44:46.770]                 }
[17:44:46.770]             }
[17:44:46.770]         }))
[17:44:46.770]     }, error = function(ex) {
[17:44:46.770]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.770]                 ...future.rng), started = ...future.startTime, 
[17:44:46.770]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.770]             version = "1.8"), class = "FutureResult")
[17:44:46.770]     }, finally = {
[17:44:46.770]         if (!identical(...future.workdir, getwd())) 
[17:44:46.770]             setwd(...future.workdir)
[17:44:46.770]         {
[17:44:46.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.770]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.770]             }
[17:44:46.770]             base::options(...future.oldOptions)
[17:44:46.770]             if (.Platform$OS.type == "windows") {
[17:44:46.770]                 old_names <- names(...future.oldEnvVars)
[17:44:46.770]                 envs <- base::Sys.getenv()
[17:44:46.770]                 names <- names(envs)
[17:44:46.770]                 common <- intersect(names, old_names)
[17:44:46.770]                 added <- setdiff(names, old_names)
[17:44:46.770]                 removed <- setdiff(old_names, names)
[17:44:46.770]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.770]                   envs[common]]
[17:44:46.770]                 NAMES <- toupper(changed)
[17:44:46.770]                 args <- list()
[17:44:46.770]                 for (kk in seq_along(NAMES)) {
[17:44:46.770]                   name <- changed[[kk]]
[17:44:46.770]                   NAME <- NAMES[[kk]]
[17:44:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.770]                     next
[17:44:46.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.770]                 }
[17:44:46.770]                 NAMES <- toupper(added)
[17:44:46.770]                 for (kk in seq_along(NAMES)) {
[17:44:46.770]                   name <- added[[kk]]
[17:44:46.770]                   NAME <- NAMES[[kk]]
[17:44:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.770]                     next
[17:44:46.770]                   args[[name]] <- ""
[17:44:46.770]                 }
[17:44:46.770]                 NAMES <- toupper(removed)
[17:44:46.770]                 for (kk in seq_along(NAMES)) {
[17:44:46.770]                   name <- removed[[kk]]
[17:44:46.770]                   NAME <- NAMES[[kk]]
[17:44:46.770]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.770]                     next
[17:44:46.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.770]                 }
[17:44:46.770]                 if (length(args) > 0) 
[17:44:46.770]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.770]             }
[17:44:46.770]             else {
[17:44:46.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.770]             }
[17:44:46.770]             {
[17:44:46.770]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.770]                   0L) {
[17:44:46.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.770]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.770]                   base::options(opts)
[17:44:46.770]                 }
[17:44:46.770]                 {
[17:44:46.770]                   {
[17:44:46.770]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.770]                     NULL
[17:44:46.770]                   }
[17:44:46.770]                   options(future.plan = NULL)
[17:44:46.770]                   if (is.na(NA_character_)) 
[17:44:46.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.770]                     .init = FALSE)
[17:44:46.770]                 }
[17:44:46.770]             }
[17:44:46.770]         }
[17:44:46.770]     })
[17:44:46.770]     if (TRUE) {
[17:44:46.770]         base::sink(type = "output", split = FALSE)
[17:44:46.770]         if (TRUE) {
[17:44:46.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.770]         }
[17:44:46.770]         else {
[17:44:46.770]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.770]         }
[17:44:46.770]         base::close(...future.stdout)
[17:44:46.770]         ...future.stdout <- NULL
[17:44:46.770]     }
[17:44:46.770]     ...future.result$conditions <- ...future.conditions
[17:44:46.770]     ...future.result$finished <- base::Sys.time()
[17:44:46.770]     ...future.result
[17:44:46.770] }
[17:44:46.774] assign_globals() ...
[17:44:46.774] List of 5
[17:44:46.774]  $ ...future.FUN            :function (x, y)  
[17:44:46.774]  $ MoreArgs                 : NULL
[17:44:46.774]  $ ...future.elements_ii    :List of 2
[17:44:46.774]   ..$ :List of 2
[17:44:46.774]   .. ..$ b: num 2
[17:44:46.774]   .. ..$ c: num 3
[17:44:46.774]   ..$ :List of 2
[17:44:46.774]   .. ..$ B: num 0
[17:44:46.774]   .. ..$ C: num -10
[17:44:46.774]  $ ...future.seeds_ii       : NULL
[17:44:46.774]  $ ...future.globals.maxSize: NULL
[17:44:46.774]  - attr(*, "where")=List of 5
[17:44:46.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.774]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.774]  - attr(*, "resolved")= logi FALSE
[17:44:46.774]  - attr(*, "total_size")= num 2200
[17:44:46.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.774]  - attr(*, "already-done")= logi TRUE
[17:44:46.788] - reassign environment for ‘...future.FUN’
[17:44:46.788] - copied ‘...future.FUN’ to environment
[17:44:46.788] - copied ‘MoreArgs’ to environment
[17:44:46.788] - copied ‘...future.elements_ii’ to environment
[17:44:46.789] - copied ‘...future.seeds_ii’ to environment
[17:44:46.789] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.789] assign_globals() ... done
[17:44:46.789] requestCore(): workers = 2
[17:44:46.791] MulticoreFuture started
[17:44:46.792] - Launch lazy future ... done
[17:44:46.792] run() for ‘MulticoreFuture’ ... done
[17:44:46.792] Created future:
[17:44:46.792] plan(): Setting new future strategy stack:
[17:44:46.793] List of future strategies:
[17:44:46.793] 1. sequential:
[17:44:46.793]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.793]    - tweaked: FALSE
[17:44:46.793]    - call: NULL
[17:44:46.794] plan(): nbrOfWorkers() = 1
[17:44:46.796] plan(): Setting new future strategy stack:
[17:44:46.796] List of future strategies:
[17:44:46.796] 1. multicore:
[17:44:46.796]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.796]    - tweaked: FALSE
[17:44:46.796]    - call: plan(strategy)
[17:44:46.802] plan(): nbrOfWorkers() = 2
[17:44:46.792] MulticoreFuture:
[17:44:46.792] Label: ‘future_mapply-2’
[17:44:46.792] Expression:
[17:44:46.792] {
[17:44:46.792]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.792]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.792]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.792]         on.exit(options(oopts), add = TRUE)
[17:44:46.792]     }
[17:44:46.792]     {
[17:44:46.792]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.792]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.792]         do.call(mapply, args = args)
[17:44:46.792]     }
[17:44:46.792] }
[17:44:46.792] Lazy evaluation: FALSE
[17:44:46.792] Asynchronous evaluation: TRUE
[17:44:46.792] Local evaluation: TRUE
[17:44:46.792] Environment: R_GlobalEnv
[17:44:46.792] Capture standard output: TRUE
[17:44:46.792] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.792] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.792] Packages: <none>
[17:44:46.792] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.792] Resolved: TRUE
[17:44:46.792] Value: <not collected>
[17:44:46.792] Conditions captured: <none>
[17:44:46.792] Early signaling: FALSE
[17:44:46.792] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.792] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.803] Chunk #2 of 2 ... DONE
[17:44:46.803] Launching 2 futures (chunks) ... DONE
[17:44:46.803] Resolving 2 futures (chunks) ...
[17:44:46.803] resolve() on list ...
[17:44:46.803]  recursive: 0
[17:44:46.804]  length: 2
[17:44:46.804] 
[17:44:46.804] Future #1
[17:44:46.804] result() for MulticoreFuture ...
[17:44:46.805] result() for MulticoreFuture ...
[17:44:46.805] result() for MulticoreFuture ... done
[17:44:46.806] result() for MulticoreFuture ... done
[17:44:46.806] result() for MulticoreFuture ...
[17:44:46.806] result() for MulticoreFuture ... done
[17:44:46.806] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.806] - nx: 2
[17:44:46.806] - relay: TRUE
[17:44:46.806] - stdout: TRUE
[17:44:46.807] - signal: TRUE
[17:44:46.807] - resignal: FALSE
[17:44:46.807] - force: TRUE
[17:44:46.807] - relayed: [n=2] FALSE, FALSE
[17:44:46.807] - queued futures: [n=2] FALSE, FALSE
[17:44:46.807]  - until=1
[17:44:46.807]  - relaying element #1
[17:44:46.808] result() for MulticoreFuture ...
[17:44:46.808] result() for MulticoreFuture ... done
[17:44:46.808] result() for MulticoreFuture ...
[17:44:46.808] result() for MulticoreFuture ... done
[17:44:46.808] result() for MulticoreFuture ...
[17:44:46.808] result() for MulticoreFuture ... done
[17:44:46.809] result() for MulticoreFuture ...
[17:44:46.809] result() for MulticoreFuture ... done
[17:44:46.809] - relayed: [n=2] TRUE, FALSE
[17:44:46.809] - queued futures: [n=2] TRUE, FALSE
[17:44:46.809] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.809]  length: 1 (resolved future 1)
[17:44:46.810] Future #2
[17:44:46.810] result() for MulticoreFuture ...
[17:44:46.810] result() for MulticoreFuture ...
[17:44:46.811] result() for MulticoreFuture ... done
[17:44:46.811] result() for MulticoreFuture ... done
[17:44:46.811] result() for MulticoreFuture ...
[17:44:46.811] result() for MulticoreFuture ... done
[17:44:46.811] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.811] - nx: 2
[17:44:46.812] - relay: TRUE
[17:44:46.812] - stdout: TRUE
[17:44:46.812] - signal: TRUE
[17:44:46.812] - resignal: FALSE
[17:44:46.812] - force: TRUE
[17:44:46.812] - relayed: [n=2] TRUE, FALSE
[17:44:46.812] - queued futures: [n=2] TRUE, FALSE
[17:44:46.812]  - until=2
[17:44:46.812]  - relaying element #2
[17:44:46.813] result() for MulticoreFuture ...
[17:44:46.813] result() for MulticoreFuture ... done
[17:44:46.813] result() for MulticoreFuture ...
[17:44:46.813] result() for MulticoreFuture ... done
[17:44:46.813] result() for MulticoreFuture ...
[17:44:46.813] result() for MulticoreFuture ... done
[17:44:46.813] result() for MulticoreFuture ...
[17:44:46.814] result() for MulticoreFuture ... done
[17:44:46.814] - relayed: [n=2] TRUE, TRUE
[17:44:46.814] - queued futures: [n=2] TRUE, TRUE
[17:44:46.814] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.814]  length: 0 (resolved future 2)
[17:44:46.814] Relaying remaining futures
[17:44:46.814] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.814] - nx: 2
[17:44:46.814] - relay: TRUE
[17:44:46.815] - stdout: TRUE
[17:44:46.815] - signal: TRUE
[17:44:46.815] - resignal: FALSE
[17:44:46.815] - force: TRUE
[17:44:46.815] - relayed: [n=2] TRUE, TRUE
[17:44:46.815] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.815] - relayed: [n=2] TRUE, TRUE
[17:44:46.815] - queued futures: [n=2] TRUE, TRUE
[17:44:46.816] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.816] resolve() on list ... DONE
[17:44:46.816] result() for MulticoreFuture ...
[17:44:46.816] result() for MulticoreFuture ... done
[17:44:46.816] result() for MulticoreFuture ...
[17:44:46.816] result() for MulticoreFuture ... done
[17:44:46.816] result() for MulticoreFuture ...
[17:44:46.816] result() for MulticoreFuture ... done
[17:44:46.817] result() for MulticoreFuture ...
[17:44:46.817] result() for MulticoreFuture ... done
[17:44:46.817]  - Number of value chunks collected: 2
[17:44:46.817] Resolving 2 futures (chunks) ... DONE
[17:44:46.817] Reducing values from 2 chunks ...
[17:44:46.817]  - Number of values collected after concatenation: 3
[17:44:46.817]  - Number of values expected: 3
[17:44:46.817] Reducing values from 2 chunks ... DONE
[17:44:46.817] future_mapply() ... DONE
- future_.mapply()
[17:44:46.818] future_mapply() ...
[17:44:46.823] Number of chunks: 2
[17:44:46.823] getGlobalsAndPackagesXApply() ...
[17:44:46.823]  - future.globals: TRUE
[17:44:46.823] getGlobalsAndPackages() ...
[17:44:46.823] Searching for globals...
[17:44:46.827] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:46.828] Searching for globals ... DONE
[17:44:46.828] Resolving globals: FALSE
[17:44:46.828] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:46.829] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:46.829] - globals: [1] ‘FUN’
[17:44:46.829] 
[17:44:46.829] getGlobalsAndPackages() ... DONE
[17:44:46.829]  - globals found/used: [n=1] ‘FUN’
[17:44:46.830]  - needed namespaces: [n=0] 
[17:44:46.830] Finding globals ... DONE
[17:44:46.830] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.830] List of 2
[17:44:46.830]  $ ...future.FUN:function (x, y)  
[17:44:46.830]  $ MoreArgs     : list()
[17:44:46.830]  - attr(*, "where")=List of 2
[17:44:46.830]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.830]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.830]  - attr(*, "resolved")= logi FALSE
[17:44:46.830]  - attr(*, "total_size")= num NA
[17:44:46.833] Packages to be attached in all futures: [n=0] 
[17:44:46.834] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.834] Number of futures (= number of chunks): 2
[17:44:46.834] Launching 2 futures (chunks) ...
[17:44:46.834] Chunk #1 of 2 ...
[17:44:46.834]  - Finding globals in '...' for chunk #1 ...
[17:44:46.834] getGlobalsAndPackages() ...
[17:44:46.834] Searching for globals...
[17:44:46.835] 
[17:44:46.835] Searching for globals ... DONE
[17:44:46.835] - globals: [0] <none>
[17:44:46.835] getGlobalsAndPackages() ... DONE
[17:44:46.835]    + additional globals found: [n=0] 
[17:44:46.835]    + additional namespaces needed: [n=0] 
[17:44:46.835]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.836]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.836]  - seeds: <none>
[17:44:46.836]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.836] getGlobalsAndPackages() ...
[17:44:46.836] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.836] Resolving globals: FALSE
[17:44:46.837] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:44:46.837] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:46.837] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.837] 
[17:44:46.837] getGlobalsAndPackages() ... DONE
[17:44:46.838] run() for ‘Future’ ...
[17:44:46.838] - state: ‘created’
[17:44:46.838] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.842] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.842]   - Field: ‘label’
[17:44:46.842]   - Field: ‘local’
[17:44:46.842]   - Field: ‘owner’
[17:44:46.842]   - Field: ‘envir’
[17:44:46.842]   - Field: ‘workers’
[17:44:46.842]   - Field: ‘packages’
[17:44:46.842]   - Field: ‘gc’
[17:44:46.843]   - Field: ‘job’
[17:44:46.843]   - Field: ‘conditions’
[17:44:46.843]   - Field: ‘expr’
[17:44:46.843]   - Field: ‘uuid’
[17:44:46.843]   - Field: ‘seed’
[17:44:46.843]   - Field: ‘version’
[17:44:46.843]   - Field: ‘result’
[17:44:46.843]   - Field: ‘asynchronous’
[17:44:46.843]   - Field: ‘calls’
[17:44:46.843]   - Field: ‘globals’
[17:44:46.844]   - Field: ‘stdout’
[17:44:46.844]   - Field: ‘earlySignal’
[17:44:46.844]   - Field: ‘lazy’
[17:44:46.844]   - Field: ‘state’
[17:44:46.844] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.844] - Launch lazy future ...
[17:44:46.844] Packages needed by the future expression (n = 0): <none>
[17:44:46.844] Packages needed by future strategies (n = 0): <none>
[17:44:46.845] {
[17:44:46.845]     {
[17:44:46.845]         {
[17:44:46.845]             ...future.startTime <- base::Sys.time()
[17:44:46.845]             {
[17:44:46.845]                 {
[17:44:46.845]                   {
[17:44:46.845]                     {
[17:44:46.845]                       base::local({
[17:44:46.845]                         has_future <- base::requireNamespace("future", 
[17:44:46.845]                           quietly = TRUE)
[17:44:46.845]                         if (has_future) {
[17:44:46.845]                           ns <- base::getNamespace("future")
[17:44:46.845]                           version <- ns[[".package"]][["version"]]
[17:44:46.845]                           if (is.null(version)) 
[17:44:46.845]                             version <- utils::packageVersion("future")
[17:44:46.845]                         }
[17:44:46.845]                         else {
[17:44:46.845]                           version <- NULL
[17:44:46.845]                         }
[17:44:46.845]                         if (!has_future || version < "1.8.0") {
[17:44:46.845]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.845]                             "", base::R.version$version.string), 
[17:44:46.845]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.845]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.845]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.845]                               "release", "version")], collapse = " "), 
[17:44:46.845]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.845]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.845]                             info)
[17:44:46.845]                           info <- base::paste(info, collapse = "; ")
[17:44:46.845]                           if (!has_future) {
[17:44:46.845]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.845]                               info)
[17:44:46.845]                           }
[17:44:46.845]                           else {
[17:44:46.845]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.845]                               info, version)
[17:44:46.845]                           }
[17:44:46.845]                           base::stop(msg)
[17:44:46.845]                         }
[17:44:46.845]                       })
[17:44:46.845]                     }
[17:44:46.845]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.845]                     base::options(mc.cores = 1L)
[17:44:46.845]                   }
[17:44:46.845]                   ...future.strategy.old <- future::plan("list")
[17:44:46.845]                   options(future.plan = NULL)
[17:44:46.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.845]                 }
[17:44:46.845]                 ...future.workdir <- getwd()
[17:44:46.845]             }
[17:44:46.845]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.845]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.845]         }
[17:44:46.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.845]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.845]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.845]             base::names(...future.oldOptions))
[17:44:46.845]     }
[17:44:46.845]     if (FALSE) {
[17:44:46.845]     }
[17:44:46.845]     else {
[17:44:46.845]         if (TRUE) {
[17:44:46.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.845]                 open = "w")
[17:44:46.845]         }
[17:44:46.845]         else {
[17:44:46.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.845]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.845]         }
[17:44:46.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.845]             base::sink(type = "output", split = FALSE)
[17:44:46.845]             base::close(...future.stdout)
[17:44:46.845]         }, add = TRUE)
[17:44:46.845]     }
[17:44:46.845]     ...future.frame <- base::sys.nframe()
[17:44:46.845]     ...future.conditions <- base::list()
[17:44:46.845]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.845]     if (FALSE) {
[17:44:46.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.845]     }
[17:44:46.845]     ...future.result <- base::tryCatch({
[17:44:46.845]         base::withCallingHandlers({
[17:44:46.845]             ...future.value <- base::withVisible(base::local({
[17:44:46.845]                 withCallingHandlers({
[17:44:46.845]                   {
[17:44:46.845]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.845]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.845]                       ...future.globals.maxSize)) {
[17:44:46.845]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.845]                       on.exit(options(oopts), add = TRUE)
[17:44:46.845]                     }
[17:44:46.845]                     {
[17:44:46.845]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.845]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.845]                         USE.NAMES = FALSE)
[17:44:46.845]                       do.call(mapply, args = args)
[17:44:46.845]                     }
[17:44:46.845]                   }
[17:44:46.845]                 }, immediateCondition = function(cond) {
[17:44:46.845]                   save_rds <- function (object, pathname, ...) 
[17:44:46.845]                   {
[17:44:46.845]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.845]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.845]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.845]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.845]                         fi_tmp[["mtime"]])
[17:44:46.845]                     }
[17:44:46.845]                     tryCatch({
[17:44:46.845]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.845]                     }, error = function(ex) {
[17:44:46.845]                       msg <- conditionMessage(ex)
[17:44:46.845]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.845]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.845]                         fi_tmp[["mtime"]], msg)
[17:44:46.845]                       ex$message <- msg
[17:44:46.845]                       stop(ex)
[17:44:46.845]                     })
[17:44:46.845]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.845]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.845]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.845]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.845]                       fi <- file.info(pathname)
[17:44:46.845]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.845]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.845]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.845]                         fi[["size"]], fi[["mtime"]])
[17:44:46.845]                       stop(msg)
[17:44:46.845]                     }
[17:44:46.845]                     invisible(pathname)
[17:44:46.845]                   }
[17:44:46.845]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.845]                     rootPath = tempdir()) 
[17:44:46.845]                   {
[17:44:46.845]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.845]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.845]                       tmpdir = path, fileext = ".rds")
[17:44:46.845]                     save_rds(obj, file)
[17:44:46.845]                   }
[17:44:46.845]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.845]                   {
[17:44:46.845]                     inherits <- base::inherits
[17:44:46.845]                     invokeRestart <- base::invokeRestart
[17:44:46.845]                     is.null <- base::is.null
[17:44:46.845]                     muffled <- FALSE
[17:44:46.845]                     if (inherits(cond, "message")) {
[17:44:46.845]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.845]                       if (muffled) 
[17:44:46.845]                         invokeRestart("muffleMessage")
[17:44:46.845]                     }
[17:44:46.845]                     else if (inherits(cond, "warning")) {
[17:44:46.845]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.845]                       if (muffled) 
[17:44:46.845]                         invokeRestart("muffleWarning")
[17:44:46.845]                     }
[17:44:46.845]                     else if (inherits(cond, "condition")) {
[17:44:46.845]                       if (!is.null(pattern)) {
[17:44:46.845]                         computeRestarts <- base::computeRestarts
[17:44:46.845]                         grepl <- base::grepl
[17:44:46.845]                         restarts <- computeRestarts(cond)
[17:44:46.845]                         for (restart in restarts) {
[17:44:46.845]                           name <- restart$name
[17:44:46.845]                           if (is.null(name)) 
[17:44:46.845]                             next
[17:44:46.845]                           if (!grepl(pattern, name)) 
[17:44:46.845]                             next
[17:44:46.845]                           invokeRestart(restart)
[17:44:46.845]                           muffled <- TRUE
[17:44:46.845]                           break
[17:44:46.845]                         }
[17:44:46.845]                       }
[17:44:46.845]                     }
[17:44:46.845]                     invisible(muffled)
[17:44:46.845]                   }
[17:44:46.845]                   muffleCondition(cond)
[17:44:46.845]                 })
[17:44:46.845]             }))
[17:44:46.845]             future::FutureResult(value = ...future.value$value, 
[17:44:46.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.845]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.845]                     ...future.globalenv.names))
[17:44:46.845]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.845]         }, condition = base::local({
[17:44:46.845]             c <- base::c
[17:44:46.845]             inherits <- base::inherits
[17:44:46.845]             invokeRestart <- base::invokeRestart
[17:44:46.845]             length <- base::length
[17:44:46.845]             list <- base::list
[17:44:46.845]             seq.int <- base::seq.int
[17:44:46.845]             signalCondition <- base::signalCondition
[17:44:46.845]             sys.calls <- base::sys.calls
[17:44:46.845]             `[[` <- base::`[[`
[17:44:46.845]             `+` <- base::`+`
[17:44:46.845]             `<<-` <- base::`<<-`
[17:44:46.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.845]                   3L)]
[17:44:46.845]             }
[17:44:46.845]             function(cond) {
[17:44:46.845]                 is_error <- inherits(cond, "error")
[17:44:46.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.845]                   NULL)
[17:44:46.845]                 if (is_error) {
[17:44:46.845]                   sessionInformation <- function() {
[17:44:46.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.845]                       search = base::search(), system = base::Sys.info())
[17:44:46.845]                   }
[17:44:46.845]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.845]                     cond$call), session = sessionInformation(), 
[17:44:46.845]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.845]                   signalCondition(cond)
[17:44:46.845]                 }
[17:44:46.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.845]                 "immediateCondition"))) {
[17:44:46.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.845]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.845]                   if (TRUE && !signal) {
[17:44:46.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.845]                     {
[17:44:46.845]                       inherits <- base::inherits
[17:44:46.845]                       invokeRestart <- base::invokeRestart
[17:44:46.845]                       is.null <- base::is.null
[17:44:46.845]                       muffled <- FALSE
[17:44:46.845]                       if (inherits(cond, "message")) {
[17:44:46.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.845]                         if (muffled) 
[17:44:46.845]                           invokeRestart("muffleMessage")
[17:44:46.845]                       }
[17:44:46.845]                       else if (inherits(cond, "warning")) {
[17:44:46.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.845]                         if (muffled) 
[17:44:46.845]                           invokeRestart("muffleWarning")
[17:44:46.845]                       }
[17:44:46.845]                       else if (inherits(cond, "condition")) {
[17:44:46.845]                         if (!is.null(pattern)) {
[17:44:46.845]                           computeRestarts <- base::computeRestarts
[17:44:46.845]                           grepl <- base::grepl
[17:44:46.845]                           restarts <- computeRestarts(cond)
[17:44:46.845]                           for (restart in restarts) {
[17:44:46.845]                             name <- restart$name
[17:44:46.845]                             if (is.null(name)) 
[17:44:46.845]                               next
[17:44:46.845]                             if (!grepl(pattern, name)) 
[17:44:46.845]                               next
[17:44:46.845]                             invokeRestart(restart)
[17:44:46.845]                             muffled <- TRUE
[17:44:46.845]                             break
[17:44:46.845]                           }
[17:44:46.845]                         }
[17:44:46.845]                       }
[17:44:46.845]                       invisible(muffled)
[17:44:46.845]                     }
[17:44:46.845]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.845]                   }
[17:44:46.845]                 }
[17:44:46.845]                 else {
[17:44:46.845]                   if (TRUE) {
[17:44:46.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.845]                     {
[17:44:46.845]                       inherits <- base::inherits
[17:44:46.845]                       invokeRestart <- base::invokeRestart
[17:44:46.845]                       is.null <- base::is.null
[17:44:46.845]                       muffled <- FALSE
[17:44:46.845]                       if (inherits(cond, "message")) {
[17:44:46.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.845]                         if (muffled) 
[17:44:46.845]                           invokeRestart("muffleMessage")
[17:44:46.845]                       }
[17:44:46.845]                       else if (inherits(cond, "warning")) {
[17:44:46.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.845]                         if (muffled) 
[17:44:46.845]                           invokeRestart("muffleWarning")
[17:44:46.845]                       }
[17:44:46.845]                       else if (inherits(cond, "condition")) {
[17:44:46.845]                         if (!is.null(pattern)) {
[17:44:46.845]                           computeRestarts <- base::computeRestarts
[17:44:46.845]                           grepl <- base::grepl
[17:44:46.845]                           restarts <- computeRestarts(cond)
[17:44:46.845]                           for (restart in restarts) {
[17:44:46.845]                             name <- restart$name
[17:44:46.845]                             if (is.null(name)) 
[17:44:46.845]                               next
[17:44:46.845]                             if (!grepl(pattern, name)) 
[17:44:46.845]                               next
[17:44:46.845]                             invokeRestart(restart)
[17:44:46.845]                             muffled <- TRUE
[17:44:46.845]                             break
[17:44:46.845]                           }
[17:44:46.845]                         }
[17:44:46.845]                       }
[17:44:46.845]                       invisible(muffled)
[17:44:46.845]                     }
[17:44:46.845]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.845]                   }
[17:44:46.845]                 }
[17:44:46.845]             }
[17:44:46.845]         }))
[17:44:46.845]     }, error = function(ex) {
[17:44:46.845]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.845]                 ...future.rng), started = ...future.startTime, 
[17:44:46.845]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.845]             version = "1.8"), class = "FutureResult")
[17:44:46.845]     }, finally = {
[17:44:46.845]         if (!identical(...future.workdir, getwd())) 
[17:44:46.845]             setwd(...future.workdir)
[17:44:46.845]         {
[17:44:46.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.845]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.845]             }
[17:44:46.845]             base::options(...future.oldOptions)
[17:44:46.845]             if (.Platform$OS.type == "windows") {
[17:44:46.845]                 old_names <- names(...future.oldEnvVars)
[17:44:46.845]                 envs <- base::Sys.getenv()
[17:44:46.845]                 names <- names(envs)
[17:44:46.845]                 common <- intersect(names, old_names)
[17:44:46.845]                 added <- setdiff(names, old_names)
[17:44:46.845]                 removed <- setdiff(old_names, names)
[17:44:46.845]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.845]                   envs[common]]
[17:44:46.845]                 NAMES <- toupper(changed)
[17:44:46.845]                 args <- list()
[17:44:46.845]                 for (kk in seq_along(NAMES)) {
[17:44:46.845]                   name <- changed[[kk]]
[17:44:46.845]                   NAME <- NAMES[[kk]]
[17:44:46.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.845]                     next
[17:44:46.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.845]                 }
[17:44:46.845]                 NAMES <- toupper(added)
[17:44:46.845]                 for (kk in seq_along(NAMES)) {
[17:44:46.845]                   name <- added[[kk]]
[17:44:46.845]                   NAME <- NAMES[[kk]]
[17:44:46.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.845]                     next
[17:44:46.845]                   args[[name]] <- ""
[17:44:46.845]                 }
[17:44:46.845]                 NAMES <- toupper(removed)
[17:44:46.845]                 for (kk in seq_along(NAMES)) {
[17:44:46.845]                   name <- removed[[kk]]
[17:44:46.845]                   NAME <- NAMES[[kk]]
[17:44:46.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.845]                     next
[17:44:46.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.845]                 }
[17:44:46.845]                 if (length(args) > 0) 
[17:44:46.845]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.845]             }
[17:44:46.845]             else {
[17:44:46.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.845]             }
[17:44:46.845]             {
[17:44:46.845]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.845]                   0L) {
[17:44:46.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.845]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.845]                   base::options(opts)
[17:44:46.845]                 }
[17:44:46.845]                 {
[17:44:46.845]                   {
[17:44:46.845]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.845]                     NULL
[17:44:46.845]                   }
[17:44:46.845]                   options(future.plan = NULL)
[17:44:46.845]                   if (is.na(NA_character_)) 
[17:44:46.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.845]                     .init = FALSE)
[17:44:46.845]                 }
[17:44:46.845]             }
[17:44:46.845]         }
[17:44:46.845]     })
[17:44:46.845]     if (TRUE) {
[17:44:46.845]         base::sink(type = "output", split = FALSE)
[17:44:46.845]         if (TRUE) {
[17:44:46.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.845]         }
[17:44:46.845]         else {
[17:44:46.845]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.845]         }
[17:44:46.845]         base::close(...future.stdout)
[17:44:46.845]         ...future.stdout <- NULL
[17:44:46.845]     }
[17:44:46.845]     ...future.result$conditions <- ...future.conditions
[17:44:46.845]     ...future.result$finished <- base::Sys.time()
[17:44:46.845]     ...future.result
[17:44:46.845] }
[17:44:46.847] assign_globals() ...
[17:44:46.848] List of 5
[17:44:46.848]  $ ...future.FUN            :function (x, y)  
[17:44:46.848]  $ MoreArgs                 : list()
[17:44:46.848]  $ ...future.elements_ii    :List of 2
[17:44:46.848]   ..$ :List of 1
[17:44:46.848]   .. ..$ a: num 1
[17:44:46.848]   ..$ :List of 1
[17:44:46.848]   .. ..$ A: num 10
[17:44:46.848]  $ ...future.seeds_ii       : NULL
[17:44:46.848]  $ ...future.globals.maxSize: NULL
[17:44:46.848]  - attr(*, "where")=List of 5
[17:44:46.848]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.848]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.848]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.848]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.848]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.848]  - attr(*, "resolved")= logi FALSE
[17:44:46.848]  - attr(*, "total_size")= num 2088
[17:44:46.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.848]  - attr(*, "already-done")= logi TRUE
[17:44:46.853] - reassign environment for ‘...future.FUN’
[17:44:46.853] - copied ‘...future.FUN’ to environment
[17:44:46.853] - copied ‘MoreArgs’ to environment
[17:44:46.853] - copied ‘...future.elements_ii’ to environment
[17:44:46.853] - copied ‘...future.seeds_ii’ to environment
[17:44:46.853] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.853] assign_globals() ... done
[17:44:46.853] requestCore(): workers = 2
[17:44:46.858] MulticoreFuture started
[17:44:46.858] - Launch lazy future ... done
[17:44:46.859] run() for ‘MulticoreFuture’ ... done
[17:44:46.860] plan(): Setting new future strategy stack:
[17:44:46.860] Created future:
[17:44:46.860] List of future strategies:
[17:44:46.860] 1. sequential:
[17:44:46.860]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.860]    - tweaked: FALSE
[17:44:46.860]    - call: NULL
[17:44:46.862] plan(): nbrOfWorkers() = 1
[17:44:46.864] plan(): Setting new future strategy stack:
[17:44:46.865] List of future strategies:
[17:44:46.865] 1. multicore:
[17:44:46.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.865]    - tweaked: FALSE
[17:44:46.865]    - call: plan(strategy)
[17:44:46.871] plan(): nbrOfWorkers() = 2
[17:44:46.860] MulticoreFuture:
[17:44:46.860] Label: ‘future_.mapply-1’
[17:44:46.860] Expression:
[17:44:46.860] {
[17:44:46.860]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.860]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.860]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.860]         on.exit(options(oopts), add = TRUE)
[17:44:46.860]     }
[17:44:46.860]     {
[17:44:46.860]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.860]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.860]         do.call(mapply, args = args)
[17:44:46.860]     }
[17:44:46.860] }
[17:44:46.860] Lazy evaluation: FALSE
[17:44:46.860] Asynchronous evaluation: TRUE
[17:44:46.860] Local evaluation: TRUE
[17:44:46.860] Environment: R_GlobalEnv
[17:44:46.860] Capture standard output: TRUE
[17:44:46.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.860] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.860] Packages: <none>
[17:44:46.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.860] Resolved: TRUE
[17:44:46.860] Value: <not collected>
[17:44:46.860] Conditions captured: <none>
[17:44:46.860] Early signaling: FALSE
[17:44:46.860] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.860] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.873] Chunk #1 of 2 ... DONE
[17:44:46.873] Chunk #2 of 2 ...
[17:44:46.873]  - Finding globals in '...' for chunk #2 ...
[17:44:46.873] getGlobalsAndPackages() ...
[17:44:46.874] Searching for globals...
[17:44:46.874] 
[17:44:46.875] Searching for globals ... DONE
[17:44:46.875] - globals: [0] <none>
[17:44:46.875] getGlobalsAndPackages() ... DONE
[17:44:46.875]    + additional globals found: [n=0] 
[17:44:46.875]    + additional namespaces needed: [n=0] 
[17:44:46.875]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:46.876]  - seeds: <none>
[17:44:46.876]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.876] getGlobalsAndPackages() ...
[17:44:46.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.877] Resolving globals: FALSE
[17:44:46.878] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:44:46.878] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:46.878] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.879] 
[17:44:46.879] getGlobalsAndPackages() ... DONE
[17:44:46.879] run() for ‘Future’ ...
[17:44:46.880] - state: ‘created’
[17:44:46.880] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.884] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.885]   - Field: ‘label’
[17:44:46.885]   - Field: ‘local’
[17:44:46.885]   - Field: ‘owner’
[17:44:46.885]   - Field: ‘envir’
[17:44:46.885]   - Field: ‘workers’
[17:44:46.886]   - Field: ‘packages’
[17:44:46.886]   - Field: ‘gc’
[17:44:46.886]   - Field: ‘job’
[17:44:46.886]   - Field: ‘conditions’
[17:44:46.886]   - Field: ‘expr’
[17:44:46.886]   - Field: ‘uuid’
[17:44:46.886]   - Field: ‘seed’
[17:44:46.886]   - Field: ‘version’
[17:44:46.887]   - Field: ‘result’
[17:44:46.887]   - Field: ‘asynchronous’
[17:44:46.887]   - Field: ‘calls’
[17:44:46.887]   - Field: ‘globals’
[17:44:46.887]   - Field: ‘stdout’
[17:44:46.887]   - Field: ‘earlySignal’
[17:44:46.887]   - Field: ‘lazy’
[17:44:46.888]   - Field: ‘state’
[17:44:46.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.888] - Launch lazy future ...
[17:44:46.888] Packages needed by the future expression (n = 0): <none>
[17:44:46.888] Packages needed by future strategies (n = 0): <none>
[17:44:46.889] {
[17:44:46.889]     {
[17:44:46.889]         {
[17:44:46.889]             ...future.startTime <- base::Sys.time()
[17:44:46.889]             {
[17:44:46.889]                 {
[17:44:46.889]                   {
[17:44:46.889]                     {
[17:44:46.889]                       base::local({
[17:44:46.889]                         has_future <- base::requireNamespace("future", 
[17:44:46.889]                           quietly = TRUE)
[17:44:46.889]                         if (has_future) {
[17:44:46.889]                           ns <- base::getNamespace("future")
[17:44:46.889]                           version <- ns[[".package"]][["version"]]
[17:44:46.889]                           if (is.null(version)) 
[17:44:46.889]                             version <- utils::packageVersion("future")
[17:44:46.889]                         }
[17:44:46.889]                         else {
[17:44:46.889]                           version <- NULL
[17:44:46.889]                         }
[17:44:46.889]                         if (!has_future || version < "1.8.0") {
[17:44:46.889]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.889]                             "", base::R.version$version.string), 
[17:44:46.889]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.889]                               "release", "version")], collapse = " "), 
[17:44:46.889]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.889]                             info)
[17:44:46.889]                           info <- base::paste(info, collapse = "; ")
[17:44:46.889]                           if (!has_future) {
[17:44:46.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.889]                               info)
[17:44:46.889]                           }
[17:44:46.889]                           else {
[17:44:46.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.889]                               info, version)
[17:44:46.889]                           }
[17:44:46.889]                           base::stop(msg)
[17:44:46.889]                         }
[17:44:46.889]                       })
[17:44:46.889]                     }
[17:44:46.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.889]                     base::options(mc.cores = 1L)
[17:44:46.889]                   }
[17:44:46.889]                   ...future.strategy.old <- future::plan("list")
[17:44:46.889]                   options(future.plan = NULL)
[17:44:46.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.889]                 }
[17:44:46.889]                 ...future.workdir <- getwd()
[17:44:46.889]             }
[17:44:46.889]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.889]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.889]         }
[17:44:46.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.889]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:46.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.889]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.889]             base::names(...future.oldOptions))
[17:44:46.889]     }
[17:44:46.889]     if (FALSE) {
[17:44:46.889]     }
[17:44:46.889]     else {
[17:44:46.889]         if (TRUE) {
[17:44:46.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.889]                 open = "w")
[17:44:46.889]         }
[17:44:46.889]         else {
[17:44:46.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.889]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.889]         }
[17:44:46.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.889]             base::sink(type = "output", split = FALSE)
[17:44:46.889]             base::close(...future.stdout)
[17:44:46.889]         }, add = TRUE)
[17:44:46.889]     }
[17:44:46.889]     ...future.frame <- base::sys.nframe()
[17:44:46.889]     ...future.conditions <- base::list()
[17:44:46.889]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.889]     if (FALSE) {
[17:44:46.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.889]     }
[17:44:46.889]     ...future.result <- base::tryCatch({
[17:44:46.889]         base::withCallingHandlers({
[17:44:46.889]             ...future.value <- base::withVisible(base::local({
[17:44:46.889]                 withCallingHandlers({
[17:44:46.889]                   {
[17:44:46.889]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.889]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.889]                       ...future.globals.maxSize)) {
[17:44:46.889]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.889]                       on.exit(options(oopts), add = TRUE)
[17:44:46.889]                     }
[17:44:46.889]                     {
[17:44:46.889]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.889]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.889]                         USE.NAMES = FALSE)
[17:44:46.889]                       do.call(mapply, args = args)
[17:44:46.889]                     }
[17:44:46.889]                   }
[17:44:46.889]                 }, immediateCondition = function(cond) {
[17:44:46.889]                   save_rds <- function (object, pathname, ...) 
[17:44:46.889]                   {
[17:44:46.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.889]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.889]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.889]                         fi_tmp[["mtime"]])
[17:44:46.889]                     }
[17:44:46.889]                     tryCatch({
[17:44:46.889]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.889]                     }, error = function(ex) {
[17:44:46.889]                       msg <- conditionMessage(ex)
[17:44:46.889]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.889]                         fi_tmp[["mtime"]], msg)
[17:44:46.889]                       ex$message <- msg
[17:44:46.889]                       stop(ex)
[17:44:46.889]                     })
[17:44:46.889]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.889]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.889]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.889]                       fi <- file.info(pathname)
[17:44:46.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.889]                         fi[["size"]], fi[["mtime"]])
[17:44:46.889]                       stop(msg)
[17:44:46.889]                     }
[17:44:46.889]                     invisible(pathname)
[17:44:46.889]                   }
[17:44:46.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.889]                     rootPath = tempdir()) 
[17:44:46.889]                   {
[17:44:46.889]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.889]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.889]                       tmpdir = path, fileext = ".rds")
[17:44:46.889]                     save_rds(obj, file)
[17:44:46.889]                   }
[17:44:46.889]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.889]                   {
[17:44:46.889]                     inherits <- base::inherits
[17:44:46.889]                     invokeRestart <- base::invokeRestart
[17:44:46.889]                     is.null <- base::is.null
[17:44:46.889]                     muffled <- FALSE
[17:44:46.889]                     if (inherits(cond, "message")) {
[17:44:46.889]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.889]                       if (muffled) 
[17:44:46.889]                         invokeRestart("muffleMessage")
[17:44:46.889]                     }
[17:44:46.889]                     else if (inherits(cond, "warning")) {
[17:44:46.889]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.889]                       if (muffled) 
[17:44:46.889]                         invokeRestart("muffleWarning")
[17:44:46.889]                     }
[17:44:46.889]                     else if (inherits(cond, "condition")) {
[17:44:46.889]                       if (!is.null(pattern)) {
[17:44:46.889]                         computeRestarts <- base::computeRestarts
[17:44:46.889]                         grepl <- base::grepl
[17:44:46.889]                         restarts <- computeRestarts(cond)
[17:44:46.889]                         for (restart in restarts) {
[17:44:46.889]                           name <- restart$name
[17:44:46.889]                           if (is.null(name)) 
[17:44:46.889]                             next
[17:44:46.889]                           if (!grepl(pattern, name)) 
[17:44:46.889]                             next
[17:44:46.889]                           invokeRestart(restart)
[17:44:46.889]                           muffled <- TRUE
[17:44:46.889]                           break
[17:44:46.889]                         }
[17:44:46.889]                       }
[17:44:46.889]                     }
[17:44:46.889]                     invisible(muffled)
[17:44:46.889]                   }
[17:44:46.889]                   muffleCondition(cond)
[17:44:46.889]                 })
[17:44:46.889]             }))
[17:44:46.889]             future::FutureResult(value = ...future.value$value, 
[17:44:46.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.889]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.889]                     ...future.globalenv.names))
[17:44:46.889]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.889]         }, condition = base::local({
[17:44:46.889]             c <- base::c
[17:44:46.889]             inherits <- base::inherits
[17:44:46.889]             invokeRestart <- base::invokeRestart
[17:44:46.889]             length <- base::length
[17:44:46.889]             list <- base::list
[17:44:46.889]             seq.int <- base::seq.int
[17:44:46.889]             signalCondition <- base::signalCondition
[17:44:46.889]             sys.calls <- base::sys.calls
[17:44:46.889]             `[[` <- base::`[[`
[17:44:46.889]             `+` <- base::`+`
[17:44:46.889]             `<<-` <- base::`<<-`
[17:44:46.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.889]                   3L)]
[17:44:46.889]             }
[17:44:46.889]             function(cond) {
[17:44:46.889]                 is_error <- inherits(cond, "error")
[17:44:46.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.889]                   NULL)
[17:44:46.889]                 if (is_error) {
[17:44:46.889]                   sessionInformation <- function() {
[17:44:46.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.889]                       search = base::search(), system = base::Sys.info())
[17:44:46.889]                   }
[17:44:46.889]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.889]                     cond$call), session = sessionInformation(), 
[17:44:46.889]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.889]                   signalCondition(cond)
[17:44:46.889]                 }
[17:44:46.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.889]                 "immediateCondition"))) {
[17:44:46.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.889]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.889]                   if (TRUE && !signal) {
[17:44:46.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.889]                     {
[17:44:46.889]                       inherits <- base::inherits
[17:44:46.889]                       invokeRestart <- base::invokeRestart
[17:44:46.889]                       is.null <- base::is.null
[17:44:46.889]                       muffled <- FALSE
[17:44:46.889]                       if (inherits(cond, "message")) {
[17:44:46.889]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.889]                         if (muffled) 
[17:44:46.889]                           invokeRestart("muffleMessage")
[17:44:46.889]                       }
[17:44:46.889]                       else if (inherits(cond, "warning")) {
[17:44:46.889]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.889]                         if (muffled) 
[17:44:46.889]                           invokeRestart("muffleWarning")
[17:44:46.889]                       }
[17:44:46.889]                       else if (inherits(cond, "condition")) {
[17:44:46.889]                         if (!is.null(pattern)) {
[17:44:46.889]                           computeRestarts <- base::computeRestarts
[17:44:46.889]                           grepl <- base::grepl
[17:44:46.889]                           restarts <- computeRestarts(cond)
[17:44:46.889]                           for (restart in restarts) {
[17:44:46.889]                             name <- restart$name
[17:44:46.889]                             if (is.null(name)) 
[17:44:46.889]                               next
[17:44:46.889]                             if (!grepl(pattern, name)) 
[17:44:46.889]                               next
[17:44:46.889]                             invokeRestart(restart)
[17:44:46.889]                             muffled <- TRUE
[17:44:46.889]                             break
[17:44:46.889]                           }
[17:44:46.889]                         }
[17:44:46.889]                       }
[17:44:46.889]                       invisible(muffled)
[17:44:46.889]                     }
[17:44:46.889]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.889]                   }
[17:44:46.889]                 }
[17:44:46.889]                 else {
[17:44:46.889]                   if (TRUE) {
[17:44:46.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.889]                     {
[17:44:46.889]                       inherits <- base::inherits
[17:44:46.889]                       invokeRestart <- base::invokeRestart
[17:44:46.889]                       is.null <- base::is.null
[17:44:46.889]                       muffled <- FALSE
[17:44:46.889]                       if (inherits(cond, "message")) {
[17:44:46.889]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.889]                         if (muffled) 
[17:44:46.889]                           invokeRestart("muffleMessage")
[17:44:46.889]                       }
[17:44:46.889]                       else if (inherits(cond, "warning")) {
[17:44:46.889]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.889]                         if (muffled) 
[17:44:46.889]                           invokeRestart("muffleWarning")
[17:44:46.889]                       }
[17:44:46.889]                       else if (inherits(cond, "condition")) {
[17:44:46.889]                         if (!is.null(pattern)) {
[17:44:46.889]                           computeRestarts <- base::computeRestarts
[17:44:46.889]                           grepl <- base::grepl
[17:44:46.889]                           restarts <- computeRestarts(cond)
[17:44:46.889]                           for (restart in restarts) {
[17:44:46.889]                             name <- restart$name
[17:44:46.889]                             if (is.null(name)) 
[17:44:46.889]                               next
[17:44:46.889]                             if (!grepl(pattern, name)) 
[17:44:46.889]                               next
[17:44:46.889]                             invokeRestart(restart)
[17:44:46.889]                             muffled <- TRUE
[17:44:46.889]                             break
[17:44:46.889]                           }
[17:44:46.889]                         }
[17:44:46.889]                       }
[17:44:46.889]                       invisible(muffled)
[17:44:46.889]                     }
[17:44:46.889]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.889]                   }
[17:44:46.889]                 }
[17:44:46.889]             }
[17:44:46.889]         }))
[17:44:46.889]     }, error = function(ex) {
[17:44:46.889]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.889]                 ...future.rng), started = ...future.startTime, 
[17:44:46.889]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.889]             version = "1.8"), class = "FutureResult")
[17:44:46.889]     }, finally = {
[17:44:46.889]         if (!identical(...future.workdir, getwd())) 
[17:44:46.889]             setwd(...future.workdir)
[17:44:46.889]         {
[17:44:46.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.889]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.889]             }
[17:44:46.889]             base::options(...future.oldOptions)
[17:44:46.889]             if (.Platform$OS.type == "windows") {
[17:44:46.889]                 old_names <- names(...future.oldEnvVars)
[17:44:46.889]                 envs <- base::Sys.getenv()
[17:44:46.889]                 names <- names(envs)
[17:44:46.889]                 common <- intersect(names, old_names)
[17:44:46.889]                 added <- setdiff(names, old_names)
[17:44:46.889]                 removed <- setdiff(old_names, names)
[17:44:46.889]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.889]                   envs[common]]
[17:44:46.889]                 NAMES <- toupper(changed)
[17:44:46.889]                 args <- list()
[17:44:46.889]                 for (kk in seq_along(NAMES)) {
[17:44:46.889]                   name <- changed[[kk]]
[17:44:46.889]                   NAME <- NAMES[[kk]]
[17:44:46.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.889]                     next
[17:44:46.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.889]                 }
[17:44:46.889]                 NAMES <- toupper(added)
[17:44:46.889]                 for (kk in seq_along(NAMES)) {
[17:44:46.889]                   name <- added[[kk]]
[17:44:46.889]                   NAME <- NAMES[[kk]]
[17:44:46.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.889]                     next
[17:44:46.889]                   args[[name]] <- ""
[17:44:46.889]                 }
[17:44:46.889]                 NAMES <- toupper(removed)
[17:44:46.889]                 for (kk in seq_along(NAMES)) {
[17:44:46.889]                   name <- removed[[kk]]
[17:44:46.889]                   NAME <- NAMES[[kk]]
[17:44:46.889]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.889]                     next
[17:44:46.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.889]                 }
[17:44:46.889]                 if (length(args) > 0) 
[17:44:46.889]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.889]             }
[17:44:46.889]             else {
[17:44:46.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.889]             }
[17:44:46.889]             {
[17:44:46.889]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.889]                   0L) {
[17:44:46.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.889]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.889]                   base::options(opts)
[17:44:46.889]                 }
[17:44:46.889]                 {
[17:44:46.889]                   {
[17:44:46.889]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.889]                     NULL
[17:44:46.889]                   }
[17:44:46.889]                   options(future.plan = NULL)
[17:44:46.889]                   if (is.na(NA_character_)) 
[17:44:46.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.889]                     .init = FALSE)
[17:44:46.889]                 }
[17:44:46.889]             }
[17:44:46.889]         }
[17:44:46.889]     })
[17:44:46.889]     if (TRUE) {
[17:44:46.889]         base::sink(type = "output", split = FALSE)
[17:44:46.889]         if (TRUE) {
[17:44:46.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.889]         }
[17:44:46.889]         else {
[17:44:46.889]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.889]         }
[17:44:46.889]         base::close(...future.stdout)
[17:44:46.889]         ...future.stdout <- NULL
[17:44:46.889]     }
[17:44:46.889]     ...future.result$conditions <- ...future.conditions
[17:44:46.889]     ...future.result$finished <- base::Sys.time()
[17:44:46.889]     ...future.result
[17:44:46.889] }
[17:44:46.892] assign_globals() ...
[17:44:46.892] List of 5
[17:44:46.892]  $ ...future.FUN            :function (x, y)  
[17:44:46.892]  $ MoreArgs                 : list()
[17:44:46.892]  $ ...future.elements_ii    :List of 2
[17:44:46.892]   ..$ :List of 2
[17:44:46.892]   .. ..$ b: num 2
[17:44:46.892]   .. ..$ c: num 3
[17:44:46.892]   ..$ :List of 2
[17:44:46.892]   .. ..$ B: num 0
[17:44:46.892]   .. ..$ C: num -10
[17:44:46.892]  $ ...future.seeds_ii       : NULL
[17:44:46.892]  $ ...future.globals.maxSize: NULL
[17:44:46.892]  - attr(*, "where")=List of 5
[17:44:46.892]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.892]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.892]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.892]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.892]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.892]  - attr(*, "resolved")= logi FALSE
[17:44:46.892]  - attr(*, "total_size")= num 2200
[17:44:46.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.892]  - attr(*, "already-done")= logi TRUE
[17:44:46.899] - reassign environment for ‘...future.FUN’
[17:44:46.899] - copied ‘...future.FUN’ to environment
[17:44:46.900] - copied ‘MoreArgs’ to environment
[17:44:46.900] - copied ‘...future.elements_ii’ to environment
[17:44:46.900] - copied ‘...future.seeds_ii’ to environment
[17:44:46.900] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.900] assign_globals() ... done
[17:44:46.900] requestCore(): workers = 2
[17:44:46.903] MulticoreFuture started
[17:44:46.903] - Launch lazy future ... done
[17:44:46.903] run() for ‘MulticoreFuture’ ... done
[17:44:46.903] Created future:
[17:44:46.904] plan(): Setting new future strategy stack:
[17:44:46.904] List of future strategies:
[17:44:46.904] 1. sequential:
[17:44:46.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.904]    - tweaked: FALSE
[17:44:46.904]    - call: NULL
[17:44:46.905] plan(): nbrOfWorkers() = 1
[17:44:46.907] plan(): Setting new future strategy stack:
[17:44:46.907] List of future strategies:
[17:44:46.907] 1. multicore:
[17:44:46.907]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.907]    - tweaked: FALSE
[17:44:46.907]    - call: plan(strategy)
[17:44:46.912] plan(): nbrOfWorkers() = 2
[17:44:46.904] MulticoreFuture:
[17:44:46.904] Label: ‘future_.mapply-2’
[17:44:46.904] Expression:
[17:44:46.904] {
[17:44:46.904]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.904]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.904]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.904]         on.exit(options(oopts), add = TRUE)
[17:44:46.904]     }
[17:44:46.904]     {
[17:44:46.904]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.904]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.904]         do.call(mapply, args = args)
[17:44:46.904]     }
[17:44:46.904] }
[17:44:46.904] Lazy evaluation: FALSE
[17:44:46.904] Asynchronous evaluation: TRUE
[17:44:46.904] Local evaluation: TRUE
[17:44:46.904] Environment: R_GlobalEnv
[17:44:46.904] Capture standard output: TRUE
[17:44:46.904] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.904] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.904] Packages: <none>
[17:44:46.904] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.904] Resolved: TRUE
[17:44:46.904] Value: <not collected>
[17:44:46.904] Conditions captured: <none>
[17:44:46.904] Early signaling: FALSE
[17:44:46.904] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.904] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.913] Chunk #2 of 2 ... DONE
[17:44:46.913] Launching 2 futures (chunks) ... DONE
[17:44:46.913] Resolving 2 futures (chunks) ...
[17:44:46.914] resolve() on list ...
[17:44:46.914]  recursive: 0
[17:44:46.914]  length: 2
[17:44:46.914] 
[17:44:46.914] Future #1
[17:44:46.915] result() for MulticoreFuture ...
[17:44:46.916] result() for MulticoreFuture ...
[17:44:46.916] result() for MulticoreFuture ... done
[17:44:46.916] result() for MulticoreFuture ... done
[17:44:46.916] result() for MulticoreFuture ...
[17:44:46.916] result() for MulticoreFuture ... done
[17:44:46.916] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:46.916] - nx: 2
[17:44:46.917] - relay: TRUE
[17:44:46.917] - stdout: TRUE
[17:44:46.921] - signal: TRUE
[17:44:46.921] - resignal: FALSE
[17:44:46.921] - force: TRUE
[17:44:46.922] - relayed: [n=2] FALSE, FALSE
[17:44:46.922] - queued futures: [n=2] FALSE, FALSE
[17:44:46.922]  - until=1
[17:44:46.923]  - relaying element #1
[17:44:46.923] result() for MulticoreFuture ...
[17:44:46.923] result() for MulticoreFuture ... done
[17:44:46.924] result() for MulticoreFuture ...
[17:44:46.924] result() for MulticoreFuture ... done
[17:44:46.924] result() for MulticoreFuture ...
[17:44:46.925] result() for MulticoreFuture ... done
[17:44:46.925] result() for MulticoreFuture ...
[17:44:46.925] result() for MulticoreFuture ... done
[17:44:46.925] - relayed: [n=2] TRUE, FALSE
[17:44:46.926] - queued futures: [n=2] TRUE, FALSE
[17:44:46.926] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:46.926]  length: 1 (resolved future 1)
[17:44:46.927] Future #2
[17:44:46.927] result() for MulticoreFuture ...
[17:44:46.928] result() for MulticoreFuture ...
[17:44:46.928] result() for MulticoreFuture ... done
[17:44:46.928] result() for MulticoreFuture ... done
[17:44:46.929] result() for MulticoreFuture ...
[17:44:46.929] result() for MulticoreFuture ... done
[17:44:46.929] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:46.929] - nx: 2
[17:44:46.929] - relay: TRUE
[17:44:46.929] - stdout: TRUE
[17:44:46.930] - signal: TRUE
[17:44:46.930] - resignal: FALSE
[17:44:46.930] - force: TRUE
[17:44:46.930] - relayed: [n=2] TRUE, FALSE
[17:44:46.930] - queued futures: [n=2] TRUE, FALSE
[17:44:46.930]  - until=2
[17:44:46.930]  - relaying element #2
[17:44:46.930] result() for MulticoreFuture ...
[17:44:46.930] result() for MulticoreFuture ... done
[17:44:46.931] result() for MulticoreFuture ...
[17:44:46.931] result() for MulticoreFuture ... done
[17:44:46.931] result() for MulticoreFuture ...
[17:44:46.931] result() for MulticoreFuture ... done
[17:44:46.931] result() for MulticoreFuture ...
[17:44:46.931] result() for MulticoreFuture ... done
[17:44:46.931] - relayed: [n=2] TRUE, TRUE
[17:44:46.931] - queued futures: [n=2] TRUE, TRUE
[17:44:46.932] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:46.932]  length: 0 (resolved future 2)
[17:44:46.932] Relaying remaining futures
[17:44:46.932] signalConditionsASAP(NULL, pos=0) ...
[17:44:46.932] - nx: 2
[17:44:46.932] - relay: TRUE
[17:44:46.932] - stdout: TRUE
[17:44:46.932] - signal: TRUE
[17:44:46.932] - resignal: FALSE
[17:44:46.933] - force: TRUE
[17:44:46.933] - relayed: [n=2] TRUE, TRUE
[17:44:46.933] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:46.933] - relayed: [n=2] TRUE, TRUE
[17:44:46.933] - queued futures: [n=2] TRUE, TRUE
[17:44:46.933] signalConditionsASAP(NULL, pos=0) ... done
[17:44:46.933] resolve() on list ... DONE
[17:44:46.933] result() for MulticoreFuture ...
[17:44:46.933] result() for MulticoreFuture ... done
[17:44:46.934] result() for MulticoreFuture ...
[17:44:46.934] result() for MulticoreFuture ... done
[17:44:46.934] result() for MulticoreFuture ...
[17:44:46.934] result() for MulticoreFuture ... done
[17:44:46.934] result() for MulticoreFuture ...
[17:44:46.934] result() for MulticoreFuture ... done
[17:44:46.934]  - Number of value chunks collected: 2
[17:44:46.934] Resolving 2 futures (chunks) ... DONE
[17:44:46.934] Reducing values from 2 chunks ...
[17:44:46.935]  - Number of values collected after concatenation: 3
[17:44:46.935]  - Number of values expected: 3
[17:44:46.935] Reducing values from 2 chunks ... DONE
[17:44:46.935] future_mapply() ... DONE
[17:44:46.935] future_mapply() ...
[17:44:46.940] Number of chunks: 5
[17:44:46.940] getGlobalsAndPackagesXApply() ...
[17:44:46.940]  - future.globals: TRUE
[17:44:46.940] getGlobalsAndPackages() ...
[17:44:46.940] Searching for globals...
[17:44:46.941] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:46.942] Searching for globals ... DONE
[17:44:46.942] Resolving globals: FALSE
[17:44:46.942] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:46.942] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:46.943] - globals: [1] ‘FUN’
[17:44:46.943] 
[17:44:46.943] getGlobalsAndPackages() ... DONE
[17:44:46.943]  - globals found/used: [n=1] ‘FUN’
[17:44:46.943]  - needed namespaces: [n=0] 
[17:44:46.943] Finding globals ... DONE
[17:44:46.943] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:46.944] List of 2
[17:44:46.944]  $ ...future.FUN:function (C, k)  
[17:44:46.944]  $ MoreArgs     : NULL
[17:44:46.944]  - attr(*, "where")=List of 2
[17:44:46.944]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:46.944]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:46.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.944]  - attr(*, "resolved")= logi FALSE
[17:44:46.944]  - attr(*, "total_size")= num NA
[17:44:46.946] Packages to be attached in all futures: [n=0] 
[17:44:46.946] getGlobalsAndPackagesXApply() ... DONE
[17:44:46.947] Number of futures (= number of chunks): 5
[17:44:46.947] Launching 5 futures (chunks) ...
[17:44:46.947] Chunk #1 of 5 ...
[17:44:46.947]  - Finding globals in '...' for chunk #1 ...
[17:44:46.947] getGlobalsAndPackages() ...
[17:44:46.947] Searching for globals...
[17:44:46.948] 
[17:44:46.948] Searching for globals ... DONE
[17:44:46.948] - globals: [0] <none>
[17:44:46.948] getGlobalsAndPackages() ... DONE
[17:44:46.948]    + additional globals found: [n=0] 
[17:44:46.948]    + additional namespaces needed: [n=0] 
[17:44:46.948]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:46.948]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:46.948]  - seeds: <none>
[17:44:46.949]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.949] getGlobalsAndPackages() ...
[17:44:46.949] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.949] Resolving globals: FALSE
[17:44:46.949] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:46.950] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.950] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.950] 
[17:44:46.950] getGlobalsAndPackages() ... DONE
[17:44:46.950] run() for ‘Future’ ...
[17:44:46.951] - state: ‘created’
[17:44:46.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.957] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.957]   - Field: ‘label’
[17:44:46.957]   - Field: ‘local’
[17:44:46.957]   - Field: ‘owner’
[17:44:46.958]   - Field: ‘envir’
[17:44:46.958]   - Field: ‘workers’
[17:44:46.958]   - Field: ‘packages’
[17:44:46.958]   - Field: ‘gc’
[17:44:46.958]   - Field: ‘job’
[17:44:46.958]   - Field: ‘conditions’
[17:44:46.958]   - Field: ‘expr’
[17:44:46.958]   - Field: ‘uuid’
[17:44:46.958]   - Field: ‘seed’
[17:44:46.959]   - Field: ‘version’
[17:44:46.959]   - Field: ‘result’
[17:44:46.959]   - Field: ‘asynchronous’
[17:44:46.959]   - Field: ‘calls’
[17:44:46.959]   - Field: ‘globals’
[17:44:46.959]   - Field: ‘stdout’
[17:44:46.959]   - Field: ‘earlySignal’
[17:44:46.959]   - Field: ‘lazy’
[17:44:46.960]   - Field: ‘state’
[17:44:46.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.960] - Launch lazy future ...
[17:44:46.960] Packages needed by the future expression (n = 0): <none>
[17:44:46.960] Packages needed by future strategies (n = 0): <none>
[17:44:46.961] {
[17:44:46.961]     {
[17:44:46.961]         {
[17:44:46.961]             ...future.startTime <- base::Sys.time()
[17:44:46.961]             {
[17:44:46.961]                 {
[17:44:46.961]                   {
[17:44:46.961]                     {
[17:44:46.961]                       base::local({
[17:44:46.961]                         has_future <- base::requireNamespace("future", 
[17:44:46.961]                           quietly = TRUE)
[17:44:46.961]                         if (has_future) {
[17:44:46.961]                           ns <- base::getNamespace("future")
[17:44:46.961]                           version <- ns[[".package"]][["version"]]
[17:44:46.961]                           if (is.null(version)) 
[17:44:46.961]                             version <- utils::packageVersion("future")
[17:44:46.961]                         }
[17:44:46.961]                         else {
[17:44:46.961]                           version <- NULL
[17:44:46.961]                         }
[17:44:46.961]                         if (!has_future || version < "1.8.0") {
[17:44:46.961]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.961]                             "", base::R.version$version.string), 
[17:44:46.961]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.961]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.961]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.961]                               "release", "version")], collapse = " "), 
[17:44:46.961]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.961]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.961]                             info)
[17:44:46.961]                           info <- base::paste(info, collapse = "; ")
[17:44:46.961]                           if (!has_future) {
[17:44:46.961]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.961]                               info)
[17:44:46.961]                           }
[17:44:46.961]                           else {
[17:44:46.961]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.961]                               info, version)
[17:44:46.961]                           }
[17:44:46.961]                           base::stop(msg)
[17:44:46.961]                         }
[17:44:46.961]                       })
[17:44:46.961]                     }
[17:44:46.961]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.961]                     base::options(mc.cores = 1L)
[17:44:46.961]                   }
[17:44:46.961]                   ...future.strategy.old <- future::plan("list")
[17:44:46.961]                   options(future.plan = NULL)
[17:44:46.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.961]                 }
[17:44:46.961]                 ...future.workdir <- getwd()
[17:44:46.961]             }
[17:44:46.961]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.961]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.961]         }
[17:44:46.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.961]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:46.961]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.961]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.961]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.961]             base::names(...future.oldOptions))
[17:44:46.961]     }
[17:44:46.961]     if (FALSE) {
[17:44:46.961]     }
[17:44:46.961]     else {
[17:44:46.961]         if (TRUE) {
[17:44:46.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.961]                 open = "w")
[17:44:46.961]         }
[17:44:46.961]         else {
[17:44:46.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.961]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.961]         }
[17:44:46.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.961]             base::sink(type = "output", split = FALSE)
[17:44:46.961]             base::close(...future.stdout)
[17:44:46.961]         }, add = TRUE)
[17:44:46.961]     }
[17:44:46.961]     ...future.frame <- base::sys.nframe()
[17:44:46.961]     ...future.conditions <- base::list()
[17:44:46.961]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.961]     if (FALSE) {
[17:44:46.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.961]     }
[17:44:46.961]     ...future.result <- base::tryCatch({
[17:44:46.961]         base::withCallingHandlers({
[17:44:46.961]             ...future.value <- base::withVisible(base::local({
[17:44:46.961]                 withCallingHandlers({
[17:44:46.961]                   {
[17:44:46.961]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.961]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.961]                       ...future.globals.maxSize)) {
[17:44:46.961]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.961]                       on.exit(options(oopts), add = TRUE)
[17:44:46.961]                     }
[17:44:46.961]                     {
[17:44:46.961]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.961]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.961]                         USE.NAMES = FALSE)
[17:44:46.961]                       do.call(mapply, args = args)
[17:44:46.961]                     }
[17:44:46.961]                   }
[17:44:46.961]                 }, immediateCondition = function(cond) {
[17:44:46.961]                   save_rds <- function (object, pathname, ...) 
[17:44:46.961]                   {
[17:44:46.961]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.961]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.961]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.961]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.961]                         fi_tmp[["mtime"]])
[17:44:46.961]                     }
[17:44:46.961]                     tryCatch({
[17:44:46.961]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.961]                     }, error = function(ex) {
[17:44:46.961]                       msg <- conditionMessage(ex)
[17:44:46.961]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.961]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.961]                         fi_tmp[["mtime"]], msg)
[17:44:46.961]                       ex$message <- msg
[17:44:46.961]                       stop(ex)
[17:44:46.961]                     })
[17:44:46.961]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.961]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.961]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.961]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.961]                       fi <- file.info(pathname)
[17:44:46.961]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.961]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.961]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.961]                         fi[["size"]], fi[["mtime"]])
[17:44:46.961]                       stop(msg)
[17:44:46.961]                     }
[17:44:46.961]                     invisible(pathname)
[17:44:46.961]                   }
[17:44:46.961]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.961]                     rootPath = tempdir()) 
[17:44:46.961]                   {
[17:44:46.961]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.961]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.961]                       tmpdir = path, fileext = ".rds")
[17:44:46.961]                     save_rds(obj, file)
[17:44:46.961]                   }
[17:44:46.961]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.961]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.961]                   {
[17:44:46.961]                     inherits <- base::inherits
[17:44:46.961]                     invokeRestart <- base::invokeRestart
[17:44:46.961]                     is.null <- base::is.null
[17:44:46.961]                     muffled <- FALSE
[17:44:46.961]                     if (inherits(cond, "message")) {
[17:44:46.961]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.961]                       if (muffled) 
[17:44:46.961]                         invokeRestart("muffleMessage")
[17:44:46.961]                     }
[17:44:46.961]                     else if (inherits(cond, "warning")) {
[17:44:46.961]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.961]                       if (muffled) 
[17:44:46.961]                         invokeRestart("muffleWarning")
[17:44:46.961]                     }
[17:44:46.961]                     else if (inherits(cond, "condition")) {
[17:44:46.961]                       if (!is.null(pattern)) {
[17:44:46.961]                         computeRestarts <- base::computeRestarts
[17:44:46.961]                         grepl <- base::grepl
[17:44:46.961]                         restarts <- computeRestarts(cond)
[17:44:46.961]                         for (restart in restarts) {
[17:44:46.961]                           name <- restart$name
[17:44:46.961]                           if (is.null(name)) 
[17:44:46.961]                             next
[17:44:46.961]                           if (!grepl(pattern, name)) 
[17:44:46.961]                             next
[17:44:46.961]                           invokeRestart(restart)
[17:44:46.961]                           muffled <- TRUE
[17:44:46.961]                           break
[17:44:46.961]                         }
[17:44:46.961]                       }
[17:44:46.961]                     }
[17:44:46.961]                     invisible(muffled)
[17:44:46.961]                   }
[17:44:46.961]                   muffleCondition(cond)
[17:44:46.961]                 })
[17:44:46.961]             }))
[17:44:46.961]             future::FutureResult(value = ...future.value$value, 
[17:44:46.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.961]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.961]                     ...future.globalenv.names))
[17:44:46.961]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.961]         }, condition = base::local({
[17:44:46.961]             c <- base::c
[17:44:46.961]             inherits <- base::inherits
[17:44:46.961]             invokeRestart <- base::invokeRestart
[17:44:46.961]             length <- base::length
[17:44:46.961]             list <- base::list
[17:44:46.961]             seq.int <- base::seq.int
[17:44:46.961]             signalCondition <- base::signalCondition
[17:44:46.961]             sys.calls <- base::sys.calls
[17:44:46.961]             `[[` <- base::`[[`
[17:44:46.961]             `+` <- base::`+`
[17:44:46.961]             `<<-` <- base::`<<-`
[17:44:46.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.961]                   3L)]
[17:44:46.961]             }
[17:44:46.961]             function(cond) {
[17:44:46.961]                 is_error <- inherits(cond, "error")
[17:44:46.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.961]                   NULL)
[17:44:46.961]                 if (is_error) {
[17:44:46.961]                   sessionInformation <- function() {
[17:44:46.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.961]                       search = base::search(), system = base::Sys.info())
[17:44:46.961]                   }
[17:44:46.961]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.961]                     cond$call), session = sessionInformation(), 
[17:44:46.961]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.961]                   signalCondition(cond)
[17:44:46.961]                 }
[17:44:46.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.961]                 "immediateCondition"))) {
[17:44:46.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.961]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.961]                   if (TRUE && !signal) {
[17:44:46.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.961]                     {
[17:44:46.961]                       inherits <- base::inherits
[17:44:46.961]                       invokeRestart <- base::invokeRestart
[17:44:46.961]                       is.null <- base::is.null
[17:44:46.961]                       muffled <- FALSE
[17:44:46.961]                       if (inherits(cond, "message")) {
[17:44:46.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.961]                         if (muffled) 
[17:44:46.961]                           invokeRestart("muffleMessage")
[17:44:46.961]                       }
[17:44:46.961]                       else if (inherits(cond, "warning")) {
[17:44:46.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.961]                         if (muffled) 
[17:44:46.961]                           invokeRestart("muffleWarning")
[17:44:46.961]                       }
[17:44:46.961]                       else if (inherits(cond, "condition")) {
[17:44:46.961]                         if (!is.null(pattern)) {
[17:44:46.961]                           computeRestarts <- base::computeRestarts
[17:44:46.961]                           grepl <- base::grepl
[17:44:46.961]                           restarts <- computeRestarts(cond)
[17:44:46.961]                           for (restart in restarts) {
[17:44:46.961]                             name <- restart$name
[17:44:46.961]                             if (is.null(name)) 
[17:44:46.961]                               next
[17:44:46.961]                             if (!grepl(pattern, name)) 
[17:44:46.961]                               next
[17:44:46.961]                             invokeRestart(restart)
[17:44:46.961]                             muffled <- TRUE
[17:44:46.961]                             break
[17:44:46.961]                           }
[17:44:46.961]                         }
[17:44:46.961]                       }
[17:44:46.961]                       invisible(muffled)
[17:44:46.961]                     }
[17:44:46.961]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.961]                   }
[17:44:46.961]                 }
[17:44:46.961]                 else {
[17:44:46.961]                   if (TRUE) {
[17:44:46.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.961]                     {
[17:44:46.961]                       inherits <- base::inherits
[17:44:46.961]                       invokeRestart <- base::invokeRestart
[17:44:46.961]                       is.null <- base::is.null
[17:44:46.961]                       muffled <- FALSE
[17:44:46.961]                       if (inherits(cond, "message")) {
[17:44:46.961]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.961]                         if (muffled) 
[17:44:46.961]                           invokeRestart("muffleMessage")
[17:44:46.961]                       }
[17:44:46.961]                       else if (inherits(cond, "warning")) {
[17:44:46.961]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.961]                         if (muffled) 
[17:44:46.961]                           invokeRestart("muffleWarning")
[17:44:46.961]                       }
[17:44:46.961]                       else if (inherits(cond, "condition")) {
[17:44:46.961]                         if (!is.null(pattern)) {
[17:44:46.961]                           computeRestarts <- base::computeRestarts
[17:44:46.961]                           grepl <- base::grepl
[17:44:46.961]                           restarts <- computeRestarts(cond)
[17:44:46.961]                           for (restart in restarts) {
[17:44:46.961]                             name <- restart$name
[17:44:46.961]                             if (is.null(name)) 
[17:44:46.961]                               next
[17:44:46.961]                             if (!grepl(pattern, name)) 
[17:44:46.961]                               next
[17:44:46.961]                             invokeRestart(restart)
[17:44:46.961]                             muffled <- TRUE
[17:44:46.961]                             break
[17:44:46.961]                           }
[17:44:46.961]                         }
[17:44:46.961]                       }
[17:44:46.961]                       invisible(muffled)
[17:44:46.961]                     }
[17:44:46.961]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.961]                   }
[17:44:46.961]                 }
[17:44:46.961]             }
[17:44:46.961]         }))
[17:44:46.961]     }, error = function(ex) {
[17:44:46.961]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.961]                 ...future.rng), started = ...future.startTime, 
[17:44:46.961]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.961]             version = "1.8"), class = "FutureResult")
[17:44:46.961]     }, finally = {
[17:44:46.961]         if (!identical(...future.workdir, getwd())) 
[17:44:46.961]             setwd(...future.workdir)
[17:44:46.961]         {
[17:44:46.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.961]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.961]             }
[17:44:46.961]             base::options(...future.oldOptions)
[17:44:46.961]             if (.Platform$OS.type == "windows") {
[17:44:46.961]                 old_names <- names(...future.oldEnvVars)
[17:44:46.961]                 envs <- base::Sys.getenv()
[17:44:46.961]                 names <- names(envs)
[17:44:46.961]                 common <- intersect(names, old_names)
[17:44:46.961]                 added <- setdiff(names, old_names)
[17:44:46.961]                 removed <- setdiff(old_names, names)
[17:44:46.961]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.961]                   envs[common]]
[17:44:46.961]                 NAMES <- toupper(changed)
[17:44:46.961]                 args <- list()
[17:44:46.961]                 for (kk in seq_along(NAMES)) {
[17:44:46.961]                   name <- changed[[kk]]
[17:44:46.961]                   NAME <- NAMES[[kk]]
[17:44:46.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.961]                     next
[17:44:46.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.961]                 }
[17:44:46.961]                 NAMES <- toupper(added)
[17:44:46.961]                 for (kk in seq_along(NAMES)) {
[17:44:46.961]                   name <- added[[kk]]
[17:44:46.961]                   NAME <- NAMES[[kk]]
[17:44:46.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.961]                     next
[17:44:46.961]                   args[[name]] <- ""
[17:44:46.961]                 }
[17:44:46.961]                 NAMES <- toupper(removed)
[17:44:46.961]                 for (kk in seq_along(NAMES)) {
[17:44:46.961]                   name <- removed[[kk]]
[17:44:46.961]                   NAME <- NAMES[[kk]]
[17:44:46.961]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.961]                     next
[17:44:46.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.961]                 }
[17:44:46.961]                 if (length(args) > 0) 
[17:44:46.961]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.961]             }
[17:44:46.961]             else {
[17:44:46.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.961]             }
[17:44:46.961]             {
[17:44:46.961]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.961]                   0L) {
[17:44:46.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.961]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.961]                   base::options(opts)
[17:44:46.961]                 }
[17:44:46.961]                 {
[17:44:46.961]                   {
[17:44:46.961]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.961]                     NULL
[17:44:46.961]                   }
[17:44:46.961]                   options(future.plan = NULL)
[17:44:46.961]                   if (is.na(NA_character_)) 
[17:44:46.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.961]                     .init = FALSE)
[17:44:46.961]                 }
[17:44:46.961]             }
[17:44:46.961]         }
[17:44:46.961]     })
[17:44:46.961]     if (TRUE) {
[17:44:46.961]         base::sink(type = "output", split = FALSE)
[17:44:46.961]         if (TRUE) {
[17:44:46.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.961]         }
[17:44:46.961]         else {
[17:44:46.961]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.961]         }
[17:44:46.961]         base::close(...future.stdout)
[17:44:46.961]         ...future.stdout <- NULL
[17:44:46.961]     }
[17:44:46.961]     ...future.result$conditions <- ...future.conditions
[17:44:46.961]     ...future.result$finished <- base::Sys.time()
[17:44:46.961]     ...future.result
[17:44:46.961] }
[17:44:46.963] assign_globals() ...
[17:44:46.963] List of 5
[17:44:46.963]  $ ...future.FUN            :function (C, k)  
[17:44:46.963]  $ MoreArgs                 : NULL
[17:44:46.963]  $ ...future.elements_ii    :List of 2
[17:44:46.963]   ..$ :List of 1
[17:44:46.963]   .. ..$ : chr "A"
[17:44:46.963]   ..$ :List of 1
[17:44:46.963]   .. ..$ : int 5
[17:44:46.963]  $ ...future.seeds_ii       : NULL
[17:44:46.963]  $ ...future.globals.maxSize: NULL
[17:44:46.963]  - attr(*, "where")=List of 5
[17:44:46.963]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:46.963]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:46.963]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:46.963]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:46.963]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:46.963]  - attr(*, "resolved")= logi FALSE
[17:44:46.963]  - attr(*, "total_size")= num 3488
[17:44:46.963]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:46.963]  - attr(*, "already-done")= logi TRUE
[17:44:46.968] - reassign environment for ‘...future.FUN’
[17:44:46.968] - copied ‘...future.FUN’ to environment
[17:44:46.968] - copied ‘MoreArgs’ to environment
[17:44:46.969] - copied ‘...future.elements_ii’ to environment
[17:44:46.969] - copied ‘...future.seeds_ii’ to environment
[17:44:46.969] - copied ‘...future.globals.maxSize’ to environment
[17:44:46.969] assign_globals() ... done
[17:44:46.969] requestCore(): workers = 2
[17:44:46.971] MulticoreFuture started
[17:44:46.971] - Launch lazy future ... done
[17:44:46.972] run() for ‘MulticoreFuture’ ... done
[17:44:46.972] Created future:
[17:44:46.972] plan(): Setting new future strategy stack:
[17:44:46.972] List of future strategies:
[17:44:46.972] 1. sequential:
[17:44:46.972]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:46.972]    - tweaked: FALSE
[17:44:46.972]    - call: NULL
[17:44:46.973] plan(): nbrOfWorkers() = 1
[17:44:46.975] plan(): Setting new future strategy stack:
[17:44:46.976] List of future strategies:
[17:44:46.976] 1. multicore:
[17:44:46.976]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:46.976]    - tweaked: FALSE
[17:44:46.976]    - call: plan(strategy)
[17:44:46.981] plan(): nbrOfWorkers() = 2
[17:44:46.972] MulticoreFuture:
[17:44:46.972] Label: ‘future_mapply-1’
[17:44:46.972] Expression:
[17:44:46.972] {
[17:44:46.972]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.972]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:46.972]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.972]         on.exit(options(oopts), add = TRUE)
[17:44:46.972]     }
[17:44:46.972]     {
[17:44:46.972]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.972]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:46.972]         do.call(mapply, args = args)
[17:44:46.972]     }
[17:44:46.972] }
[17:44:46.972] Lazy evaluation: FALSE
[17:44:46.972] Asynchronous evaluation: TRUE
[17:44:46.972] Local evaluation: TRUE
[17:44:46.972] Environment: R_GlobalEnv
[17:44:46.972] Capture standard output: TRUE
[17:44:46.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:46.972] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:46.972] Packages: <none>
[17:44:46.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:46.972] Resolved: TRUE
[17:44:46.972] Value: <not collected>
[17:44:46.972] Conditions captured: <none>
[17:44:46.972] Early signaling: FALSE
[17:44:46.972] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:46.972] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.982] Chunk #1 of 5 ... DONE
[17:44:46.982] Chunk #2 of 5 ...
[17:44:46.982]  - Finding globals in '...' for chunk #2 ...
[17:44:46.982] getGlobalsAndPackages() ...
[17:44:46.982] Searching for globals...
[17:44:46.983] 
[17:44:46.983] Searching for globals ... DONE
[17:44:46.983] - globals: [0] <none>
[17:44:46.983] getGlobalsAndPackages() ... DONE
[17:44:46.983]    + additional globals found: [n=0] 
[17:44:46.983]    + additional namespaces needed: [n=0] 
[17:44:46.984]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:46.984]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:46.984]  - seeds: <none>
[17:44:46.984]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.984] getGlobalsAndPackages() ...
[17:44:46.984] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.984] Resolving globals: FALSE
[17:44:46.985] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:46.986] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:46.986] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:46.986] 
[17:44:46.987] getGlobalsAndPackages() ... DONE
[17:44:46.987] run() for ‘Future’ ...
[17:44:46.987] - state: ‘created’
[17:44:46.988] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:46.992] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:46.992] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:46.993]   - Field: ‘label’
[17:44:46.993]   - Field: ‘local’
[17:44:46.993]   - Field: ‘owner’
[17:44:46.993]   - Field: ‘envir’
[17:44:46.993]   - Field: ‘workers’
[17:44:46.993]   - Field: ‘packages’
[17:44:46.993]   - Field: ‘gc’
[17:44:46.994]   - Field: ‘job’
[17:44:46.994]   - Field: ‘conditions’
[17:44:46.994]   - Field: ‘expr’
[17:44:46.994]   - Field: ‘uuid’
[17:44:46.994]   - Field: ‘seed’
[17:44:46.994]   - Field: ‘version’
[17:44:46.995]   - Field: ‘result’
[17:44:46.995]   - Field: ‘asynchronous’
[17:44:46.995]   - Field: ‘calls’
[17:44:46.995]   - Field: ‘globals’
[17:44:46.995]   - Field: ‘stdout’
[17:44:46.995]   - Field: ‘earlySignal’
[17:44:46.995]   - Field: ‘lazy’
[17:44:46.996]   - Field: ‘state’
[17:44:46.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:46.996] - Launch lazy future ...
[17:44:46.996] Packages needed by the future expression (n = 0): <none>
[17:44:46.997] Packages needed by future strategies (n = 0): <none>
[17:44:46.997] {
[17:44:46.997]     {
[17:44:46.997]         {
[17:44:46.997]             ...future.startTime <- base::Sys.time()
[17:44:46.997]             {
[17:44:46.997]                 {
[17:44:46.997]                   {
[17:44:46.997]                     {
[17:44:46.997]                       base::local({
[17:44:46.997]                         has_future <- base::requireNamespace("future", 
[17:44:46.997]                           quietly = TRUE)
[17:44:46.997]                         if (has_future) {
[17:44:46.997]                           ns <- base::getNamespace("future")
[17:44:46.997]                           version <- ns[[".package"]][["version"]]
[17:44:46.997]                           if (is.null(version)) 
[17:44:46.997]                             version <- utils::packageVersion("future")
[17:44:46.997]                         }
[17:44:46.997]                         else {
[17:44:46.997]                           version <- NULL
[17:44:46.997]                         }
[17:44:46.997]                         if (!has_future || version < "1.8.0") {
[17:44:46.997]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:46.997]                             "", base::R.version$version.string), 
[17:44:46.997]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:46.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:46.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:46.997]                               "release", "version")], collapse = " "), 
[17:44:46.997]                             hostname = base::Sys.info()[["nodename"]])
[17:44:46.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:46.997]                             info)
[17:44:46.997]                           info <- base::paste(info, collapse = "; ")
[17:44:46.997]                           if (!has_future) {
[17:44:46.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:46.997]                               info)
[17:44:46.997]                           }
[17:44:46.997]                           else {
[17:44:46.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:46.997]                               info, version)
[17:44:46.997]                           }
[17:44:46.997]                           base::stop(msg)
[17:44:46.997]                         }
[17:44:46.997]                       })
[17:44:46.997]                     }
[17:44:46.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:46.997]                     base::options(mc.cores = 1L)
[17:44:46.997]                   }
[17:44:46.997]                   ...future.strategy.old <- future::plan("list")
[17:44:46.997]                   options(future.plan = NULL)
[17:44:46.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:46.997]                 }
[17:44:46.997]                 ...future.workdir <- getwd()
[17:44:46.997]             }
[17:44:46.997]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:46.997]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:46.997]         }
[17:44:46.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:46.997]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:46.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:46.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:46.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:46.997]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:46.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:46.997]             base::names(...future.oldOptions))
[17:44:46.997]     }
[17:44:46.997]     if (FALSE) {
[17:44:46.997]     }
[17:44:46.997]     else {
[17:44:46.997]         if (TRUE) {
[17:44:46.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:46.997]                 open = "w")
[17:44:46.997]         }
[17:44:46.997]         else {
[17:44:46.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:46.997]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:46.997]         }
[17:44:46.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:46.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:46.997]             base::sink(type = "output", split = FALSE)
[17:44:46.997]             base::close(...future.stdout)
[17:44:46.997]         }, add = TRUE)
[17:44:46.997]     }
[17:44:46.997]     ...future.frame <- base::sys.nframe()
[17:44:46.997]     ...future.conditions <- base::list()
[17:44:46.997]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:46.997]     if (FALSE) {
[17:44:46.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:46.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:46.997]     }
[17:44:46.997]     ...future.result <- base::tryCatch({
[17:44:46.997]         base::withCallingHandlers({
[17:44:46.997]             ...future.value <- base::withVisible(base::local({
[17:44:46.997]                 withCallingHandlers({
[17:44:46.997]                   {
[17:44:46.997]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:46.997]                     if (!identical(...future.globals.maxSize.org, 
[17:44:46.997]                       ...future.globals.maxSize)) {
[17:44:46.997]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:46.997]                       on.exit(options(oopts), add = TRUE)
[17:44:46.997]                     }
[17:44:46.997]                     {
[17:44:46.997]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:46.997]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:46.997]                         USE.NAMES = FALSE)
[17:44:46.997]                       do.call(mapply, args = args)
[17:44:46.997]                     }
[17:44:46.997]                   }
[17:44:46.997]                 }, immediateCondition = function(cond) {
[17:44:46.997]                   save_rds <- function (object, pathname, ...) 
[17:44:46.997]                   {
[17:44:46.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:46.997]                     if (file_test("-f", pathname_tmp)) {
[17:44:46.997]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:46.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.997]                         fi_tmp[["mtime"]])
[17:44:46.997]                     }
[17:44:46.997]                     tryCatch({
[17:44:46.997]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:46.997]                     }, error = function(ex) {
[17:44:46.997]                       msg <- conditionMessage(ex)
[17:44:46.997]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:46.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.997]                         fi_tmp[["mtime"]], msg)
[17:44:46.997]                       ex$message <- msg
[17:44:46.997]                       stop(ex)
[17:44:46.997]                     })
[17:44:46.997]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:46.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:46.997]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:46.997]                       fi_tmp <- file.info(pathname_tmp)
[17:44:46.997]                       fi <- file.info(pathname)
[17:44:46.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:46.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:46.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:46.997]                         fi[["size"]], fi[["mtime"]])
[17:44:46.997]                       stop(msg)
[17:44:46.997]                     }
[17:44:46.997]                     invisible(pathname)
[17:44:46.997]                   }
[17:44:46.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:46.997]                     rootPath = tempdir()) 
[17:44:46.997]                   {
[17:44:46.997]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:46.997]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:46.997]                       tmpdir = path, fileext = ".rds")
[17:44:46.997]                     save_rds(obj, file)
[17:44:46.997]                   }
[17:44:46.997]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:46.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.997]                   {
[17:44:46.997]                     inherits <- base::inherits
[17:44:46.997]                     invokeRestart <- base::invokeRestart
[17:44:46.997]                     is.null <- base::is.null
[17:44:46.997]                     muffled <- FALSE
[17:44:46.997]                     if (inherits(cond, "message")) {
[17:44:46.997]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:46.997]                       if (muffled) 
[17:44:46.997]                         invokeRestart("muffleMessage")
[17:44:46.997]                     }
[17:44:46.997]                     else if (inherits(cond, "warning")) {
[17:44:46.997]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:46.997]                       if (muffled) 
[17:44:46.997]                         invokeRestart("muffleWarning")
[17:44:46.997]                     }
[17:44:46.997]                     else if (inherits(cond, "condition")) {
[17:44:46.997]                       if (!is.null(pattern)) {
[17:44:46.997]                         computeRestarts <- base::computeRestarts
[17:44:46.997]                         grepl <- base::grepl
[17:44:46.997]                         restarts <- computeRestarts(cond)
[17:44:46.997]                         for (restart in restarts) {
[17:44:46.997]                           name <- restart$name
[17:44:46.997]                           if (is.null(name)) 
[17:44:46.997]                             next
[17:44:46.997]                           if (!grepl(pattern, name)) 
[17:44:46.997]                             next
[17:44:46.997]                           invokeRestart(restart)
[17:44:46.997]                           muffled <- TRUE
[17:44:46.997]                           break
[17:44:46.997]                         }
[17:44:46.997]                       }
[17:44:46.997]                     }
[17:44:46.997]                     invisible(muffled)
[17:44:46.997]                   }
[17:44:46.997]                   muffleCondition(cond)
[17:44:46.997]                 })
[17:44:46.997]             }))
[17:44:46.997]             future::FutureResult(value = ...future.value$value, 
[17:44:46.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.997]                   ...future.rng), globalenv = if (FALSE) 
[17:44:46.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:46.997]                     ...future.globalenv.names))
[17:44:46.997]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:46.997]         }, condition = base::local({
[17:44:46.997]             c <- base::c
[17:44:46.997]             inherits <- base::inherits
[17:44:46.997]             invokeRestart <- base::invokeRestart
[17:44:46.997]             length <- base::length
[17:44:46.997]             list <- base::list
[17:44:46.997]             seq.int <- base::seq.int
[17:44:46.997]             signalCondition <- base::signalCondition
[17:44:46.997]             sys.calls <- base::sys.calls
[17:44:46.997]             `[[` <- base::`[[`
[17:44:46.997]             `+` <- base::`+`
[17:44:46.997]             `<<-` <- base::`<<-`
[17:44:46.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:46.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:46.997]                   3L)]
[17:44:46.997]             }
[17:44:46.997]             function(cond) {
[17:44:46.997]                 is_error <- inherits(cond, "error")
[17:44:46.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:46.997]                   NULL)
[17:44:46.997]                 if (is_error) {
[17:44:46.997]                   sessionInformation <- function() {
[17:44:46.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:46.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:46.997]                       search = base::search(), system = base::Sys.info())
[17:44:46.997]                   }
[17:44:46.997]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:46.997]                     cond$call), session = sessionInformation(), 
[17:44:46.997]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:46.997]                   signalCondition(cond)
[17:44:46.997]                 }
[17:44:46.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:46.997]                 "immediateCondition"))) {
[17:44:46.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:46.997]                   ...future.conditions[[length(...future.conditions) + 
[17:44:46.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:46.997]                   if (TRUE && !signal) {
[17:44:46.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.997]                     {
[17:44:46.997]                       inherits <- base::inherits
[17:44:46.997]                       invokeRestart <- base::invokeRestart
[17:44:46.997]                       is.null <- base::is.null
[17:44:46.997]                       muffled <- FALSE
[17:44:46.997]                       if (inherits(cond, "message")) {
[17:44:46.997]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.997]                         if (muffled) 
[17:44:46.997]                           invokeRestart("muffleMessage")
[17:44:46.997]                       }
[17:44:46.997]                       else if (inherits(cond, "warning")) {
[17:44:46.997]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.997]                         if (muffled) 
[17:44:46.997]                           invokeRestart("muffleWarning")
[17:44:46.997]                       }
[17:44:46.997]                       else if (inherits(cond, "condition")) {
[17:44:46.997]                         if (!is.null(pattern)) {
[17:44:46.997]                           computeRestarts <- base::computeRestarts
[17:44:46.997]                           grepl <- base::grepl
[17:44:46.997]                           restarts <- computeRestarts(cond)
[17:44:46.997]                           for (restart in restarts) {
[17:44:46.997]                             name <- restart$name
[17:44:46.997]                             if (is.null(name)) 
[17:44:46.997]                               next
[17:44:46.997]                             if (!grepl(pattern, name)) 
[17:44:46.997]                               next
[17:44:46.997]                             invokeRestart(restart)
[17:44:46.997]                             muffled <- TRUE
[17:44:46.997]                             break
[17:44:46.997]                           }
[17:44:46.997]                         }
[17:44:46.997]                       }
[17:44:46.997]                       invisible(muffled)
[17:44:46.997]                     }
[17:44:46.997]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.997]                   }
[17:44:46.997]                 }
[17:44:46.997]                 else {
[17:44:46.997]                   if (TRUE) {
[17:44:46.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:46.997]                     {
[17:44:46.997]                       inherits <- base::inherits
[17:44:46.997]                       invokeRestart <- base::invokeRestart
[17:44:46.997]                       is.null <- base::is.null
[17:44:46.997]                       muffled <- FALSE
[17:44:46.997]                       if (inherits(cond, "message")) {
[17:44:46.997]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:46.997]                         if (muffled) 
[17:44:46.997]                           invokeRestart("muffleMessage")
[17:44:46.997]                       }
[17:44:46.997]                       else if (inherits(cond, "warning")) {
[17:44:46.997]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:46.997]                         if (muffled) 
[17:44:46.997]                           invokeRestart("muffleWarning")
[17:44:46.997]                       }
[17:44:46.997]                       else if (inherits(cond, "condition")) {
[17:44:46.997]                         if (!is.null(pattern)) {
[17:44:46.997]                           computeRestarts <- base::computeRestarts
[17:44:46.997]                           grepl <- base::grepl
[17:44:46.997]                           restarts <- computeRestarts(cond)
[17:44:46.997]                           for (restart in restarts) {
[17:44:46.997]                             name <- restart$name
[17:44:46.997]                             if (is.null(name)) 
[17:44:46.997]                               next
[17:44:46.997]                             if (!grepl(pattern, name)) 
[17:44:46.997]                               next
[17:44:46.997]                             invokeRestart(restart)
[17:44:46.997]                             muffled <- TRUE
[17:44:46.997]                             break
[17:44:46.997]                           }
[17:44:46.997]                         }
[17:44:46.997]                       }
[17:44:46.997]                       invisible(muffled)
[17:44:46.997]                     }
[17:44:46.997]                     muffleCondition(cond, pattern = "^muffle")
[17:44:46.997]                   }
[17:44:46.997]                 }
[17:44:46.997]             }
[17:44:46.997]         }))
[17:44:46.997]     }, error = function(ex) {
[17:44:46.997]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:46.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:46.997]                 ...future.rng), started = ...future.startTime, 
[17:44:46.997]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:46.997]             version = "1.8"), class = "FutureResult")
[17:44:46.997]     }, finally = {
[17:44:46.997]         if (!identical(...future.workdir, getwd())) 
[17:44:46.997]             setwd(...future.workdir)
[17:44:46.997]         {
[17:44:46.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:46.997]                 ...future.oldOptions$nwarnings <- NULL
[17:44:46.997]             }
[17:44:46.997]             base::options(...future.oldOptions)
[17:44:46.997]             if (.Platform$OS.type == "windows") {
[17:44:46.997]                 old_names <- names(...future.oldEnvVars)
[17:44:46.997]                 envs <- base::Sys.getenv()
[17:44:46.997]                 names <- names(envs)
[17:44:46.997]                 common <- intersect(names, old_names)
[17:44:46.997]                 added <- setdiff(names, old_names)
[17:44:46.997]                 removed <- setdiff(old_names, names)
[17:44:46.997]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:46.997]                   envs[common]]
[17:44:46.997]                 NAMES <- toupper(changed)
[17:44:46.997]                 args <- list()
[17:44:46.997]                 for (kk in seq_along(NAMES)) {
[17:44:46.997]                   name <- changed[[kk]]
[17:44:46.997]                   NAME <- NAMES[[kk]]
[17:44:46.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.997]                     next
[17:44:46.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.997]                 }
[17:44:46.997]                 NAMES <- toupper(added)
[17:44:46.997]                 for (kk in seq_along(NAMES)) {
[17:44:46.997]                   name <- added[[kk]]
[17:44:46.997]                   NAME <- NAMES[[kk]]
[17:44:46.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.997]                     next
[17:44:46.997]                   args[[name]] <- ""
[17:44:46.997]                 }
[17:44:46.997]                 NAMES <- toupper(removed)
[17:44:46.997]                 for (kk in seq_along(NAMES)) {
[17:44:46.997]                   name <- removed[[kk]]
[17:44:46.997]                   NAME <- NAMES[[kk]]
[17:44:46.997]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:46.997]                     next
[17:44:46.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:46.997]                 }
[17:44:46.997]                 if (length(args) > 0) 
[17:44:46.997]                   base::do.call(base::Sys.setenv, args = args)
[17:44:46.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:46.997]             }
[17:44:46.997]             else {
[17:44:46.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:46.997]             }
[17:44:46.997]             {
[17:44:46.997]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:46.997]                   0L) {
[17:44:46.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:46.997]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:46.997]                   base::options(opts)
[17:44:46.997]                 }
[17:44:46.997]                 {
[17:44:46.997]                   {
[17:44:46.997]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:46.997]                     NULL
[17:44:46.997]                   }
[17:44:46.997]                   options(future.plan = NULL)
[17:44:46.997]                   if (is.na(NA_character_)) 
[17:44:46.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:46.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:46.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:46.997]                     .init = FALSE)
[17:44:46.997]                 }
[17:44:46.997]             }
[17:44:46.997]         }
[17:44:46.997]     })
[17:44:46.997]     if (TRUE) {
[17:44:46.997]         base::sink(type = "output", split = FALSE)
[17:44:46.997]         if (TRUE) {
[17:44:46.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:46.997]         }
[17:44:46.997]         else {
[17:44:46.997]             ...future.result["stdout"] <- base::list(NULL)
[17:44:46.997]         }
[17:44:46.997]         base::close(...future.stdout)
[17:44:46.997]         ...future.stdout <- NULL
[17:44:46.997]     }
[17:44:46.997]     ...future.result$conditions <- ...future.conditions
[17:44:46.997]     ...future.result$finished <- base::Sys.time()
[17:44:46.997]     ...future.result
[17:44:46.997] }
[17:44:47.004] assign_globals() ...
[17:44:47.004] List of 5
[17:44:47.004]  $ ...future.FUN            :function (C, k)  
[17:44:47.004]  $ MoreArgs                 : NULL
[17:44:47.004]  $ ...future.elements_ii    :List of 2
[17:44:47.004]   ..$ :List of 1
[17:44:47.004]   .. ..$ : chr "B"
[17:44:47.004]   ..$ :List of 1
[17:44:47.004]   .. ..$ : int 4
[17:44:47.004]  $ ...future.seeds_ii       : NULL
[17:44:47.004]  $ ...future.globals.maxSize: NULL
[17:44:47.004]  - attr(*, "where")=List of 5
[17:44:47.004]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.004]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.004]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.004]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.004]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.004]  - attr(*, "resolved")= logi FALSE
[17:44:47.004]  - attr(*, "total_size")= num 3488
[17:44:47.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.004]  - attr(*, "already-done")= logi TRUE
[17:44:47.014] - reassign environment for ‘...future.FUN’
[17:44:47.014] - copied ‘...future.FUN’ to environment
[17:44:47.014] - copied ‘MoreArgs’ to environment
[17:44:47.014] - copied ‘...future.elements_ii’ to environment
[17:44:47.014] - copied ‘...future.seeds_ii’ to environment
[17:44:47.015] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.015] assign_globals() ... done
[17:44:47.015] requestCore(): workers = 2
[17:44:47.017] MulticoreFuture started
[17:44:47.017] - Launch lazy future ... done
[17:44:47.018] run() for ‘MulticoreFuture’ ... done
[17:44:47.018] Created future:
[17:44:47.018] plan(): Setting new future strategy stack:
[17:44:47.018] List of future strategies:
[17:44:47.018] 1. sequential:
[17:44:47.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.018]    - tweaked: FALSE
[17:44:47.018]    - call: NULL
[17:44:47.019] plan(): nbrOfWorkers() = 1
[17:44:47.022] plan(): Setting new future strategy stack:
[17:44:47.022] List of future strategies:
[17:44:47.022] 1. multicore:
[17:44:47.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.022]    - tweaked: FALSE
[17:44:47.022]    - call: plan(strategy)
[17:44:47.027] plan(): nbrOfWorkers() = 2
[17:44:47.018] MulticoreFuture:
[17:44:47.018] Label: ‘future_mapply-2’
[17:44:47.018] Expression:
[17:44:47.018] {
[17:44:47.018]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.018]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.018]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.018]         on.exit(options(oopts), add = TRUE)
[17:44:47.018]     }
[17:44:47.018]     {
[17:44:47.018]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.018]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.018]         do.call(mapply, args = args)
[17:44:47.018]     }
[17:44:47.018] }
[17:44:47.018] Lazy evaluation: FALSE
[17:44:47.018] Asynchronous evaluation: TRUE
[17:44:47.018] Local evaluation: TRUE
[17:44:47.018] Environment: R_GlobalEnv
[17:44:47.018] Capture standard output: TRUE
[17:44:47.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.018] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.018] Packages: <none>
[17:44:47.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.018] Resolved: TRUE
[17:44:47.018] Value: <not collected>
[17:44:47.018] Conditions captured: <none>
[17:44:47.018] Early signaling: FALSE
[17:44:47.018] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.028] Chunk #2 of 5 ... DONE
[17:44:47.028] Chunk #3 of 5 ...
[17:44:47.029]  - Finding globals in '...' for chunk #3 ...
[17:44:47.029] getGlobalsAndPackages() ...
[17:44:47.029] Searching for globals...
[17:44:47.030] 
[17:44:47.030] Searching for globals ... DONE
[17:44:47.030] - globals: [0] <none>
[17:44:47.030] getGlobalsAndPackages() ... DONE
[17:44:47.030]    + additional globals found: [n=0] 
[17:44:47.030]    + additional namespaces needed: [n=0] 
[17:44:47.031]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:47.031]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:47.031]  - seeds: <none>
[17:44:47.031]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.031] getGlobalsAndPackages() ...
[17:44:47.031] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.032] Resolving globals: FALSE
[17:44:47.032] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:47.033] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.033] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.033] 
[17:44:47.034] getGlobalsAndPackages() ... DONE
[17:44:47.034] run() for ‘Future’ ...
[17:44:47.034] - state: ‘created’
[17:44:47.034] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.039] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.039] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.039]   - Field: ‘label’
[17:44:47.039]   - Field: ‘local’
[17:44:47.040]   - Field: ‘owner’
[17:44:47.040]   - Field: ‘envir’
[17:44:47.040]   - Field: ‘workers’
[17:44:47.040]   - Field: ‘packages’
[17:44:47.040]   - Field: ‘gc’
[17:44:47.040]   - Field: ‘job’
[17:44:47.040]   - Field: ‘conditions’
[17:44:47.041]   - Field: ‘expr’
[17:44:47.041]   - Field: ‘uuid’
[17:44:47.041]   - Field: ‘seed’
[17:44:47.041]   - Field: ‘version’
[17:44:47.041]   - Field: ‘result’
[17:44:47.041]   - Field: ‘asynchronous’
[17:44:47.041]   - Field: ‘calls’
[17:44:47.042]   - Field: ‘globals’
[17:44:47.042]   - Field: ‘stdout’
[17:44:47.042]   - Field: ‘earlySignal’
[17:44:47.042]   - Field: ‘lazy’
[17:44:47.042]   - Field: ‘state’
[17:44:47.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.042] - Launch lazy future ...
[17:44:47.043] Packages needed by the future expression (n = 0): <none>
[17:44:47.043] Packages needed by future strategies (n = 0): <none>
[17:44:47.044] {
[17:44:47.044]     {
[17:44:47.044]         {
[17:44:47.044]             ...future.startTime <- base::Sys.time()
[17:44:47.044]             {
[17:44:47.044]                 {
[17:44:47.044]                   {
[17:44:47.044]                     {
[17:44:47.044]                       base::local({
[17:44:47.044]                         has_future <- base::requireNamespace("future", 
[17:44:47.044]                           quietly = TRUE)
[17:44:47.044]                         if (has_future) {
[17:44:47.044]                           ns <- base::getNamespace("future")
[17:44:47.044]                           version <- ns[[".package"]][["version"]]
[17:44:47.044]                           if (is.null(version)) 
[17:44:47.044]                             version <- utils::packageVersion("future")
[17:44:47.044]                         }
[17:44:47.044]                         else {
[17:44:47.044]                           version <- NULL
[17:44:47.044]                         }
[17:44:47.044]                         if (!has_future || version < "1.8.0") {
[17:44:47.044]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.044]                             "", base::R.version$version.string), 
[17:44:47.044]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.044]                               "release", "version")], collapse = " "), 
[17:44:47.044]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.044]                             info)
[17:44:47.044]                           info <- base::paste(info, collapse = "; ")
[17:44:47.044]                           if (!has_future) {
[17:44:47.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.044]                               info)
[17:44:47.044]                           }
[17:44:47.044]                           else {
[17:44:47.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.044]                               info, version)
[17:44:47.044]                           }
[17:44:47.044]                           base::stop(msg)
[17:44:47.044]                         }
[17:44:47.044]                       })
[17:44:47.044]                     }
[17:44:47.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.044]                     base::options(mc.cores = 1L)
[17:44:47.044]                   }
[17:44:47.044]                   ...future.strategy.old <- future::plan("list")
[17:44:47.044]                   options(future.plan = NULL)
[17:44:47.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.044]                 }
[17:44:47.044]                 ...future.workdir <- getwd()
[17:44:47.044]             }
[17:44:47.044]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.044]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.044]         }
[17:44:47.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.044]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:47.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.044]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.044]             base::names(...future.oldOptions))
[17:44:47.044]     }
[17:44:47.044]     if (FALSE) {
[17:44:47.044]     }
[17:44:47.044]     else {
[17:44:47.044]         if (TRUE) {
[17:44:47.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.044]                 open = "w")
[17:44:47.044]         }
[17:44:47.044]         else {
[17:44:47.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.044]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.044]         }
[17:44:47.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.044]             base::sink(type = "output", split = FALSE)
[17:44:47.044]             base::close(...future.stdout)
[17:44:47.044]         }, add = TRUE)
[17:44:47.044]     }
[17:44:47.044]     ...future.frame <- base::sys.nframe()
[17:44:47.044]     ...future.conditions <- base::list()
[17:44:47.044]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.044]     if (FALSE) {
[17:44:47.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.044]     }
[17:44:47.044]     ...future.result <- base::tryCatch({
[17:44:47.044]         base::withCallingHandlers({
[17:44:47.044]             ...future.value <- base::withVisible(base::local({
[17:44:47.044]                 withCallingHandlers({
[17:44:47.044]                   {
[17:44:47.044]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.044]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.044]                       ...future.globals.maxSize)) {
[17:44:47.044]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.044]                       on.exit(options(oopts), add = TRUE)
[17:44:47.044]                     }
[17:44:47.044]                     {
[17:44:47.044]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.044]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.044]                         USE.NAMES = FALSE)
[17:44:47.044]                       do.call(mapply, args = args)
[17:44:47.044]                     }
[17:44:47.044]                   }
[17:44:47.044]                 }, immediateCondition = function(cond) {
[17:44:47.044]                   save_rds <- function (object, pathname, ...) 
[17:44:47.044]                   {
[17:44:47.044]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.044]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.044]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.044]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.044]                         fi_tmp[["mtime"]])
[17:44:47.044]                     }
[17:44:47.044]                     tryCatch({
[17:44:47.044]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.044]                     }, error = function(ex) {
[17:44:47.044]                       msg <- conditionMessage(ex)
[17:44:47.044]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.044]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.044]                         fi_tmp[["mtime"]], msg)
[17:44:47.044]                       ex$message <- msg
[17:44:47.044]                       stop(ex)
[17:44:47.044]                     })
[17:44:47.044]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.044]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.044]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.044]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.044]                       fi <- file.info(pathname)
[17:44:47.044]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.044]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.044]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.044]                         fi[["size"]], fi[["mtime"]])
[17:44:47.044]                       stop(msg)
[17:44:47.044]                     }
[17:44:47.044]                     invisible(pathname)
[17:44:47.044]                   }
[17:44:47.044]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.044]                     rootPath = tempdir()) 
[17:44:47.044]                   {
[17:44:47.044]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.044]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.044]                       tmpdir = path, fileext = ".rds")
[17:44:47.044]                     save_rds(obj, file)
[17:44:47.044]                   }
[17:44:47.044]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.044]                   {
[17:44:47.044]                     inherits <- base::inherits
[17:44:47.044]                     invokeRestart <- base::invokeRestart
[17:44:47.044]                     is.null <- base::is.null
[17:44:47.044]                     muffled <- FALSE
[17:44:47.044]                     if (inherits(cond, "message")) {
[17:44:47.044]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.044]                       if (muffled) 
[17:44:47.044]                         invokeRestart("muffleMessage")
[17:44:47.044]                     }
[17:44:47.044]                     else if (inherits(cond, "warning")) {
[17:44:47.044]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.044]                       if (muffled) 
[17:44:47.044]                         invokeRestart("muffleWarning")
[17:44:47.044]                     }
[17:44:47.044]                     else if (inherits(cond, "condition")) {
[17:44:47.044]                       if (!is.null(pattern)) {
[17:44:47.044]                         computeRestarts <- base::computeRestarts
[17:44:47.044]                         grepl <- base::grepl
[17:44:47.044]                         restarts <- computeRestarts(cond)
[17:44:47.044]                         for (restart in restarts) {
[17:44:47.044]                           name <- restart$name
[17:44:47.044]                           if (is.null(name)) 
[17:44:47.044]                             next
[17:44:47.044]                           if (!grepl(pattern, name)) 
[17:44:47.044]                             next
[17:44:47.044]                           invokeRestart(restart)
[17:44:47.044]                           muffled <- TRUE
[17:44:47.044]                           break
[17:44:47.044]                         }
[17:44:47.044]                       }
[17:44:47.044]                     }
[17:44:47.044]                     invisible(muffled)
[17:44:47.044]                   }
[17:44:47.044]                   muffleCondition(cond)
[17:44:47.044]                 })
[17:44:47.044]             }))
[17:44:47.044]             future::FutureResult(value = ...future.value$value, 
[17:44:47.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.044]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.044]                     ...future.globalenv.names))
[17:44:47.044]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.044]         }, condition = base::local({
[17:44:47.044]             c <- base::c
[17:44:47.044]             inherits <- base::inherits
[17:44:47.044]             invokeRestart <- base::invokeRestart
[17:44:47.044]             length <- base::length
[17:44:47.044]             list <- base::list
[17:44:47.044]             seq.int <- base::seq.int
[17:44:47.044]             signalCondition <- base::signalCondition
[17:44:47.044]             sys.calls <- base::sys.calls
[17:44:47.044]             `[[` <- base::`[[`
[17:44:47.044]             `+` <- base::`+`
[17:44:47.044]             `<<-` <- base::`<<-`
[17:44:47.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.044]                   3L)]
[17:44:47.044]             }
[17:44:47.044]             function(cond) {
[17:44:47.044]                 is_error <- inherits(cond, "error")
[17:44:47.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.044]                   NULL)
[17:44:47.044]                 if (is_error) {
[17:44:47.044]                   sessionInformation <- function() {
[17:44:47.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.044]                       search = base::search(), system = base::Sys.info())
[17:44:47.044]                   }
[17:44:47.044]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.044]                     cond$call), session = sessionInformation(), 
[17:44:47.044]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.044]                   signalCondition(cond)
[17:44:47.044]                 }
[17:44:47.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.044]                 "immediateCondition"))) {
[17:44:47.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.044]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.044]                   if (TRUE && !signal) {
[17:44:47.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.044]                     {
[17:44:47.044]                       inherits <- base::inherits
[17:44:47.044]                       invokeRestart <- base::invokeRestart
[17:44:47.044]                       is.null <- base::is.null
[17:44:47.044]                       muffled <- FALSE
[17:44:47.044]                       if (inherits(cond, "message")) {
[17:44:47.044]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.044]                         if (muffled) 
[17:44:47.044]                           invokeRestart("muffleMessage")
[17:44:47.044]                       }
[17:44:47.044]                       else if (inherits(cond, "warning")) {
[17:44:47.044]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.044]                         if (muffled) 
[17:44:47.044]                           invokeRestart("muffleWarning")
[17:44:47.044]                       }
[17:44:47.044]                       else if (inherits(cond, "condition")) {
[17:44:47.044]                         if (!is.null(pattern)) {
[17:44:47.044]                           computeRestarts <- base::computeRestarts
[17:44:47.044]                           grepl <- base::grepl
[17:44:47.044]                           restarts <- computeRestarts(cond)
[17:44:47.044]                           for (restart in restarts) {
[17:44:47.044]                             name <- restart$name
[17:44:47.044]                             if (is.null(name)) 
[17:44:47.044]                               next
[17:44:47.044]                             if (!grepl(pattern, name)) 
[17:44:47.044]                               next
[17:44:47.044]                             invokeRestart(restart)
[17:44:47.044]                             muffled <- TRUE
[17:44:47.044]                             break
[17:44:47.044]                           }
[17:44:47.044]                         }
[17:44:47.044]                       }
[17:44:47.044]                       invisible(muffled)
[17:44:47.044]                     }
[17:44:47.044]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.044]                   }
[17:44:47.044]                 }
[17:44:47.044]                 else {
[17:44:47.044]                   if (TRUE) {
[17:44:47.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.044]                     {
[17:44:47.044]                       inherits <- base::inherits
[17:44:47.044]                       invokeRestart <- base::invokeRestart
[17:44:47.044]                       is.null <- base::is.null
[17:44:47.044]                       muffled <- FALSE
[17:44:47.044]                       if (inherits(cond, "message")) {
[17:44:47.044]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.044]                         if (muffled) 
[17:44:47.044]                           invokeRestart("muffleMessage")
[17:44:47.044]                       }
[17:44:47.044]                       else if (inherits(cond, "warning")) {
[17:44:47.044]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.044]                         if (muffled) 
[17:44:47.044]                           invokeRestart("muffleWarning")
[17:44:47.044]                       }
[17:44:47.044]                       else if (inherits(cond, "condition")) {
[17:44:47.044]                         if (!is.null(pattern)) {
[17:44:47.044]                           computeRestarts <- base::computeRestarts
[17:44:47.044]                           grepl <- base::grepl
[17:44:47.044]                           restarts <- computeRestarts(cond)
[17:44:47.044]                           for (restart in restarts) {
[17:44:47.044]                             name <- restart$name
[17:44:47.044]                             if (is.null(name)) 
[17:44:47.044]                               next
[17:44:47.044]                             if (!grepl(pattern, name)) 
[17:44:47.044]                               next
[17:44:47.044]                             invokeRestart(restart)
[17:44:47.044]                             muffled <- TRUE
[17:44:47.044]                             break
[17:44:47.044]                           }
[17:44:47.044]                         }
[17:44:47.044]                       }
[17:44:47.044]                       invisible(muffled)
[17:44:47.044]                     }
[17:44:47.044]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.044]                   }
[17:44:47.044]                 }
[17:44:47.044]             }
[17:44:47.044]         }))
[17:44:47.044]     }, error = function(ex) {
[17:44:47.044]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.044]                 ...future.rng), started = ...future.startTime, 
[17:44:47.044]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.044]             version = "1.8"), class = "FutureResult")
[17:44:47.044]     }, finally = {
[17:44:47.044]         if (!identical(...future.workdir, getwd())) 
[17:44:47.044]             setwd(...future.workdir)
[17:44:47.044]         {
[17:44:47.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.044]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.044]             }
[17:44:47.044]             base::options(...future.oldOptions)
[17:44:47.044]             if (.Platform$OS.type == "windows") {
[17:44:47.044]                 old_names <- names(...future.oldEnvVars)
[17:44:47.044]                 envs <- base::Sys.getenv()
[17:44:47.044]                 names <- names(envs)
[17:44:47.044]                 common <- intersect(names, old_names)
[17:44:47.044]                 added <- setdiff(names, old_names)
[17:44:47.044]                 removed <- setdiff(old_names, names)
[17:44:47.044]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.044]                   envs[common]]
[17:44:47.044]                 NAMES <- toupper(changed)
[17:44:47.044]                 args <- list()
[17:44:47.044]                 for (kk in seq_along(NAMES)) {
[17:44:47.044]                   name <- changed[[kk]]
[17:44:47.044]                   NAME <- NAMES[[kk]]
[17:44:47.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.044]                     next
[17:44:47.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.044]                 }
[17:44:47.044]                 NAMES <- toupper(added)
[17:44:47.044]                 for (kk in seq_along(NAMES)) {
[17:44:47.044]                   name <- added[[kk]]
[17:44:47.044]                   NAME <- NAMES[[kk]]
[17:44:47.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.044]                     next
[17:44:47.044]                   args[[name]] <- ""
[17:44:47.044]                 }
[17:44:47.044]                 NAMES <- toupper(removed)
[17:44:47.044]                 for (kk in seq_along(NAMES)) {
[17:44:47.044]                   name <- removed[[kk]]
[17:44:47.044]                   NAME <- NAMES[[kk]]
[17:44:47.044]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.044]                     next
[17:44:47.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.044]                 }
[17:44:47.044]                 if (length(args) > 0) 
[17:44:47.044]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.044]             }
[17:44:47.044]             else {
[17:44:47.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.044]             }
[17:44:47.044]             {
[17:44:47.044]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.044]                   0L) {
[17:44:47.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.044]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.044]                   base::options(opts)
[17:44:47.044]                 }
[17:44:47.044]                 {
[17:44:47.044]                   {
[17:44:47.044]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.044]                     NULL
[17:44:47.044]                   }
[17:44:47.044]                   options(future.plan = NULL)
[17:44:47.044]                   if (is.na(NA_character_)) 
[17:44:47.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.044]                     .init = FALSE)
[17:44:47.044]                 }
[17:44:47.044]             }
[17:44:47.044]         }
[17:44:47.044]     })
[17:44:47.044]     if (TRUE) {
[17:44:47.044]         base::sink(type = "output", split = FALSE)
[17:44:47.044]         if (TRUE) {
[17:44:47.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.044]         }
[17:44:47.044]         else {
[17:44:47.044]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.044]         }
[17:44:47.044]         base::close(...future.stdout)
[17:44:47.044]         ...future.stdout <- NULL
[17:44:47.044]     }
[17:44:47.044]     ...future.result$conditions <- ...future.conditions
[17:44:47.044]     ...future.result$finished <- base::Sys.time()
[17:44:47.044]     ...future.result
[17:44:47.044] }
[17:44:47.047] assign_globals() ...
[17:44:47.047] List of 5
[17:44:47.047]  $ ...future.FUN            :function (C, k)  
[17:44:47.047]  $ MoreArgs                 : NULL
[17:44:47.047]  $ ...future.elements_ii    :List of 2
[17:44:47.047]   ..$ :List of 1
[17:44:47.047]   .. ..$ : chr "C"
[17:44:47.047]   ..$ :List of 1
[17:44:47.047]   .. ..$ : int 3
[17:44:47.047]  $ ...future.seeds_ii       : NULL
[17:44:47.047]  $ ...future.globals.maxSize: NULL
[17:44:47.047]  - attr(*, "where")=List of 5
[17:44:47.047]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.047]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.047]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.047]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.047]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.047]  - attr(*, "resolved")= logi FALSE
[17:44:47.047]  - attr(*, "total_size")= num 3488
[17:44:47.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.047]  - attr(*, "already-done")= logi TRUE
[17:44:47.059] - reassign environment for ‘...future.FUN’
[17:44:47.059] - copied ‘...future.FUN’ to environment
[17:44:47.060] - copied ‘MoreArgs’ to environment
[17:44:47.060] - copied ‘...future.elements_ii’ to environment
[17:44:47.060] - copied ‘...future.seeds_ii’ to environment
[17:44:47.060] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.060] assign_globals() ... done
[17:44:47.061] requestCore(): workers = 2
[17:44:47.061] Poll #1 (0): usedCores() = 2, workers = 2
[17:44:47.071] result() for MulticoreFuture ...
[17:44:47.072] result() for MulticoreFuture ...
[17:44:47.072] result() for MulticoreFuture ... done
[17:44:47.072] result() for MulticoreFuture ... done
[17:44:47.073] result() for MulticoreFuture ...
[17:44:47.073] result() for MulticoreFuture ... done
[17:44:47.076] MulticoreFuture started
[17:44:47.076] - Launch lazy future ... done
[17:44:47.077] run() for ‘MulticoreFuture’ ... done
[17:44:47.077] plan(): Setting new future strategy stack:
[17:44:47.077] Created future:
[17:44:47.077] List of future strategies:
[17:44:47.077] 1. sequential:
[17:44:47.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.077]    - tweaked: FALSE
[17:44:47.077]    - call: NULL
[17:44:47.079] plan(): nbrOfWorkers() = 1
[17:44:47.082] plan(): Setting new future strategy stack:
[17:44:47.082] List of future strategies:
[17:44:47.082] 1. multicore:
[17:44:47.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.082]    - tweaked: FALSE
[17:44:47.082]    - call: plan(strategy)
[17:44:47.088] plan(): nbrOfWorkers() = 2
[17:44:47.078] MulticoreFuture:
[17:44:47.078] Label: ‘future_mapply-3’
[17:44:47.078] Expression:
[17:44:47.078] {
[17:44:47.078]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.078]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.078]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.078]         on.exit(options(oopts), add = TRUE)
[17:44:47.078]     }
[17:44:47.078]     {
[17:44:47.078]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.078]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.078]         do.call(mapply, args = args)
[17:44:47.078]     }
[17:44:47.078] }
[17:44:47.078] Lazy evaluation: FALSE
[17:44:47.078] Asynchronous evaluation: TRUE
[17:44:47.078] Local evaluation: TRUE
[17:44:47.078] Environment: R_GlobalEnv
[17:44:47.078] Capture standard output: TRUE
[17:44:47.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.078] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.078] Packages: <none>
[17:44:47.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.078] Resolved: TRUE
[17:44:47.078] Value: <not collected>
[17:44:47.078] Conditions captured: <none>
[17:44:47.078] Early signaling: FALSE
[17:44:47.078] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.078] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.089] Chunk #3 of 5 ... DONE
[17:44:47.089] Chunk #4 of 5 ...
[17:44:47.090]  - Finding globals in '...' for chunk #4 ...
[17:44:47.090] getGlobalsAndPackages() ...
[17:44:47.090] Searching for globals...
[17:44:47.091] 
[17:44:47.091] Searching for globals ... DONE
[17:44:47.091] - globals: [0] <none>
[17:44:47.091] getGlobalsAndPackages() ... DONE
[17:44:47.091]    + additional globals found: [n=0] 
[17:44:47.092]    + additional namespaces needed: [n=0] 
[17:44:47.092]  - Finding globals in '...' for chunk #4 ... DONE
[17:44:47.092]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:47.092]  - seeds: <none>
[17:44:47.092]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.092] getGlobalsAndPackages() ...
[17:44:47.093] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.093] Resolving globals: FALSE
[17:44:47.094] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:47.095] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.095] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.095] 
[17:44:47.096] getGlobalsAndPackages() ... DONE
[17:44:47.096] run() for ‘Future’ ...
[17:44:47.096] - state: ‘created’
[17:44:47.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.102] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.103] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.103]   - Field: ‘label’
[17:44:47.103]   - Field: ‘local’
[17:44:47.104]   - Field: ‘owner’
[17:44:47.104]   - Field: ‘envir’
[17:44:47.104]   - Field: ‘workers’
[17:44:47.104]   - Field: ‘packages’
[17:44:47.105]   - Field: ‘gc’
[17:44:47.105]   - Field: ‘job’
[17:44:47.105]   - Field: ‘conditions’
[17:44:47.105]   - Field: ‘expr’
[17:44:47.105]   - Field: ‘uuid’
[17:44:47.106]   - Field: ‘seed’
[17:44:47.106]   - Field: ‘version’
[17:44:47.106]   - Field: ‘result’
[17:44:47.107]   - Field: ‘asynchronous’
[17:44:47.107]   - Field: ‘calls’
[17:44:47.107]   - Field: ‘globals’
[17:44:47.107]   - Field: ‘stdout’
[17:44:47.108]   - Field: ‘earlySignal’
[17:44:47.108]   - Field: ‘lazy’
[17:44:47.108]   - Field: ‘state’
[17:44:47.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.109] - Launch lazy future ...
[17:44:47.109] Packages needed by the future expression (n = 0): <none>
[17:44:47.110] Packages needed by future strategies (n = 0): <none>
[17:44:47.111] {
[17:44:47.111]     {
[17:44:47.111]         {
[17:44:47.111]             ...future.startTime <- base::Sys.time()
[17:44:47.111]             {
[17:44:47.111]                 {
[17:44:47.111]                   {
[17:44:47.111]                     {
[17:44:47.111]                       base::local({
[17:44:47.111]                         has_future <- base::requireNamespace("future", 
[17:44:47.111]                           quietly = TRUE)
[17:44:47.111]                         if (has_future) {
[17:44:47.111]                           ns <- base::getNamespace("future")
[17:44:47.111]                           version <- ns[[".package"]][["version"]]
[17:44:47.111]                           if (is.null(version)) 
[17:44:47.111]                             version <- utils::packageVersion("future")
[17:44:47.111]                         }
[17:44:47.111]                         else {
[17:44:47.111]                           version <- NULL
[17:44:47.111]                         }
[17:44:47.111]                         if (!has_future || version < "1.8.0") {
[17:44:47.111]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.111]                             "", base::R.version$version.string), 
[17:44:47.111]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.111]                               "release", "version")], collapse = " "), 
[17:44:47.111]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.111]                             info)
[17:44:47.111]                           info <- base::paste(info, collapse = "; ")
[17:44:47.111]                           if (!has_future) {
[17:44:47.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.111]                               info)
[17:44:47.111]                           }
[17:44:47.111]                           else {
[17:44:47.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.111]                               info, version)
[17:44:47.111]                           }
[17:44:47.111]                           base::stop(msg)
[17:44:47.111]                         }
[17:44:47.111]                       })
[17:44:47.111]                     }
[17:44:47.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.111]                     base::options(mc.cores = 1L)
[17:44:47.111]                   }
[17:44:47.111]                   ...future.strategy.old <- future::plan("list")
[17:44:47.111]                   options(future.plan = NULL)
[17:44:47.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.111]                 }
[17:44:47.111]                 ...future.workdir <- getwd()
[17:44:47.111]             }
[17:44:47.111]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.111]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.111]         }
[17:44:47.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.111]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:47.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.111]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.111]             base::names(...future.oldOptions))
[17:44:47.111]     }
[17:44:47.111]     if (FALSE) {
[17:44:47.111]     }
[17:44:47.111]     else {
[17:44:47.111]         if (TRUE) {
[17:44:47.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.111]                 open = "w")
[17:44:47.111]         }
[17:44:47.111]         else {
[17:44:47.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.111]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.111]         }
[17:44:47.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.111]             base::sink(type = "output", split = FALSE)
[17:44:47.111]             base::close(...future.stdout)
[17:44:47.111]         }, add = TRUE)
[17:44:47.111]     }
[17:44:47.111]     ...future.frame <- base::sys.nframe()
[17:44:47.111]     ...future.conditions <- base::list()
[17:44:47.111]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.111]     if (FALSE) {
[17:44:47.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.111]     }
[17:44:47.111]     ...future.result <- base::tryCatch({
[17:44:47.111]         base::withCallingHandlers({
[17:44:47.111]             ...future.value <- base::withVisible(base::local({
[17:44:47.111]                 withCallingHandlers({
[17:44:47.111]                   {
[17:44:47.111]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.111]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.111]                       ...future.globals.maxSize)) {
[17:44:47.111]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.111]                       on.exit(options(oopts), add = TRUE)
[17:44:47.111]                     }
[17:44:47.111]                     {
[17:44:47.111]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.111]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.111]                         USE.NAMES = FALSE)
[17:44:47.111]                       do.call(mapply, args = args)
[17:44:47.111]                     }
[17:44:47.111]                   }
[17:44:47.111]                 }, immediateCondition = function(cond) {
[17:44:47.111]                   save_rds <- function (object, pathname, ...) 
[17:44:47.111]                   {
[17:44:47.111]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.111]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.111]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.111]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.111]                         fi_tmp[["mtime"]])
[17:44:47.111]                     }
[17:44:47.111]                     tryCatch({
[17:44:47.111]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.111]                     }, error = function(ex) {
[17:44:47.111]                       msg <- conditionMessage(ex)
[17:44:47.111]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.111]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.111]                         fi_tmp[["mtime"]], msg)
[17:44:47.111]                       ex$message <- msg
[17:44:47.111]                       stop(ex)
[17:44:47.111]                     })
[17:44:47.111]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.111]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.111]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.111]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.111]                       fi <- file.info(pathname)
[17:44:47.111]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.111]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.111]                         fi[["size"]], fi[["mtime"]])
[17:44:47.111]                       stop(msg)
[17:44:47.111]                     }
[17:44:47.111]                     invisible(pathname)
[17:44:47.111]                   }
[17:44:47.111]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.111]                     rootPath = tempdir()) 
[17:44:47.111]                   {
[17:44:47.111]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.111]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.111]                       tmpdir = path, fileext = ".rds")
[17:44:47.111]                     save_rds(obj, file)
[17:44:47.111]                   }
[17:44:47.111]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.111]                   {
[17:44:47.111]                     inherits <- base::inherits
[17:44:47.111]                     invokeRestart <- base::invokeRestart
[17:44:47.111]                     is.null <- base::is.null
[17:44:47.111]                     muffled <- FALSE
[17:44:47.111]                     if (inherits(cond, "message")) {
[17:44:47.111]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.111]                       if (muffled) 
[17:44:47.111]                         invokeRestart("muffleMessage")
[17:44:47.111]                     }
[17:44:47.111]                     else if (inherits(cond, "warning")) {
[17:44:47.111]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.111]                       if (muffled) 
[17:44:47.111]                         invokeRestart("muffleWarning")
[17:44:47.111]                     }
[17:44:47.111]                     else if (inherits(cond, "condition")) {
[17:44:47.111]                       if (!is.null(pattern)) {
[17:44:47.111]                         computeRestarts <- base::computeRestarts
[17:44:47.111]                         grepl <- base::grepl
[17:44:47.111]                         restarts <- computeRestarts(cond)
[17:44:47.111]                         for (restart in restarts) {
[17:44:47.111]                           name <- restart$name
[17:44:47.111]                           if (is.null(name)) 
[17:44:47.111]                             next
[17:44:47.111]                           if (!grepl(pattern, name)) 
[17:44:47.111]                             next
[17:44:47.111]                           invokeRestart(restart)
[17:44:47.111]                           muffled <- TRUE
[17:44:47.111]                           break
[17:44:47.111]                         }
[17:44:47.111]                       }
[17:44:47.111]                     }
[17:44:47.111]                     invisible(muffled)
[17:44:47.111]                   }
[17:44:47.111]                   muffleCondition(cond)
[17:44:47.111]                 })
[17:44:47.111]             }))
[17:44:47.111]             future::FutureResult(value = ...future.value$value, 
[17:44:47.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.111]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.111]                     ...future.globalenv.names))
[17:44:47.111]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.111]         }, condition = base::local({
[17:44:47.111]             c <- base::c
[17:44:47.111]             inherits <- base::inherits
[17:44:47.111]             invokeRestart <- base::invokeRestart
[17:44:47.111]             length <- base::length
[17:44:47.111]             list <- base::list
[17:44:47.111]             seq.int <- base::seq.int
[17:44:47.111]             signalCondition <- base::signalCondition
[17:44:47.111]             sys.calls <- base::sys.calls
[17:44:47.111]             `[[` <- base::`[[`
[17:44:47.111]             `+` <- base::`+`
[17:44:47.111]             `<<-` <- base::`<<-`
[17:44:47.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.111]                   3L)]
[17:44:47.111]             }
[17:44:47.111]             function(cond) {
[17:44:47.111]                 is_error <- inherits(cond, "error")
[17:44:47.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.111]                   NULL)
[17:44:47.111]                 if (is_error) {
[17:44:47.111]                   sessionInformation <- function() {
[17:44:47.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.111]                       search = base::search(), system = base::Sys.info())
[17:44:47.111]                   }
[17:44:47.111]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.111]                     cond$call), session = sessionInformation(), 
[17:44:47.111]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.111]                   signalCondition(cond)
[17:44:47.111]                 }
[17:44:47.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.111]                 "immediateCondition"))) {
[17:44:47.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.111]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.111]                   if (TRUE && !signal) {
[17:44:47.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.111]                     {
[17:44:47.111]                       inherits <- base::inherits
[17:44:47.111]                       invokeRestart <- base::invokeRestart
[17:44:47.111]                       is.null <- base::is.null
[17:44:47.111]                       muffled <- FALSE
[17:44:47.111]                       if (inherits(cond, "message")) {
[17:44:47.111]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.111]                         if (muffled) 
[17:44:47.111]                           invokeRestart("muffleMessage")
[17:44:47.111]                       }
[17:44:47.111]                       else if (inherits(cond, "warning")) {
[17:44:47.111]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.111]                         if (muffled) 
[17:44:47.111]                           invokeRestart("muffleWarning")
[17:44:47.111]                       }
[17:44:47.111]                       else if (inherits(cond, "condition")) {
[17:44:47.111]                         if (!is.null(pattern)) {
[17:44:47.111]                           computeRestarts <- base::computeRestarts
[17:44:47.111]                           grepl <- base::grepl
[17:44:47.111]                           restarts <- computeRestarts(cond)
[17:44:47.111]                           for (restart in restarts) {
[17:44:47.111]                             name <- restart$name
[17:44:47.111]                             if (is.null(name)) 
[17:44:47.111]                               next
[17:44:47.111]                             if (!grepl(pattern, name)) 
[17:44:47.111]                               next
[17:44:47.111]                             invokeRestart(restart)
[17:44:47.111]                             muffled <- TRUE
[17:44:47.111]                             break
[17:44:47.111]                           }
[17:44:47.111]                         }
[17:44:47.111]                       }
[17:44:47.111]                       invisible(muffled)
[17:44:47.111]                     }
[17:44:47.111]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.111]                   }
[17:44:47.111]                 }
[17:44:47.111]                 else {
[17:44:47.111]                   if (TRUE) {
[17:44:47.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.111]                     {
[17:44:47.111]                       inherits <- base::inherits
[17:44:47.111]                       invokeRestart <- base::invokeRestart
[17:44:47.111]                       is.null <- base::is.null
[17:44:47.111]                       muffled <- FALSE
[17:44:47.111]                       if (inherits(cond, "message")) {
[17:44:47.111]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.111]                         if (muffled) 
[17:44:47.111]                           invokeRestart("muffleMessage")
[17:44:47.111]                       }
[17:44:47.111]                       else if (inherits(cond, "warning")) {
[17:44:47.111]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.111]                         if (muffled) 
[17:44:47.111]                           invokeRestart("muffleWarning")
[17:44:47.111]                       }
[17:44:47.111]                       else if (inherits(cond, "condition")) {
[17:44:47.111]                         if (!is.null(pattern)) {
[17:44:47.111]                           computeRestarts <- base::computeRestarts
[17:44:47.111]                           grepl <- base::grepl
[17:44:47.111]                           restarts <- computeRestarts(cond)
[17:44:47.111]                           for (restart in restarts) {
[17:44:47.111]                             name <- restart$name
[17:44:47.111]                             if (is.null(name)) 
[17:44:47.111]                               next
[17:44:47.111]                             if (!grepl(pattern, name)) 
[17:44:47.111]                               next
[17:44:47.111]                             invokeRestart(restart)
[17:44:47.111]                             muffled <- TRUE
[17:44:47.111]                             break
[17:44:47.111]                           }
[17:44:47.111]                         }
[17:44:47.111]                       }
[17:44:47.111]                       invisible(muffled)
[17:44:47.111]                     }
[17:44:47.111]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.111]                   }
[17:44:47.111]                 }
[17:44:47.111]             }
[17:44:47.111]         }))
[17:44:47.111]     }, error = function(ex) {
[17:44:47.111]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.111]                 ...future.rng), started = ...future.startTime, 
[17:44:47.111]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.111]             version = "1.8"), class = "FutureResult")
[17:44:47.111]     }, finally = {
[17:44:47.111]         if (!identical(...future.workdir, getwd())) 
[17:44:47.111]             setwd(...future.workdir)
[17:44:47.111]         {
[17:44:47.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.111]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.111]             }
[17:44:47.111]             base::options(...future.oldOptions)
[17:44:47.111]             if (.Platform$OS.type == "windows") {
[17:44:47.111]                 old_names <- names(...future.oldEnvVars)
[17:44:47.111]                 envs <- base::Sys.getenv()
[17:44:47.111]                 names <- names(envs)
[17:44:47.111]                 common <- intersect(names, old_names)
[17:44:47.111]                 added <- setdiff(names, old_names)
[17:44:47.111]                 removed <- setdiff(old_names, names)
[17:44:47.111]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.111]                   envs[common]]
[17:44:47.111]                 NAMES <- toupper(changed)
[17:44:47.111]                 args <- list()
[17:44:47.111]                 for (kk in seq_along(NAMES)) {
[17:44:47.111]                   name <- changed[[kk]]
[17:44:47.111]                   NAME <- NAMES[[kk]]
[17:44:47.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.111]                     next
[17:44:47.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.111]                 }
[17:44:47.111]                 NAMES <- toupper(added)
[17:44:47.111]                 for (kk in seq_along(NAMES)) {
[17:44:47.111]                   name <- added[[kk]]
[17:44:47.111]                   NAME <- NAMES[[kk]]
[17:44:47.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.111]                     next
[17:44:47.111]                   args[[name]] <- ""
[17:44:47.111]                 }
[17:44:47.111]                 NAMES <- toupper(removed)
[17:44:47.111]                 for (kk in seq_along(NAMES)) {
[17:44:47.111]                   name <- removed[[kk]]
[17:44:47.111]                   NAME <- NAMES[[kk]]
[17:44:47.111]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.111]                     next
[17:44:47.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.111]                 }
[17:44:47.111]                 if (length(args) > 0) 
[17:44:47.111]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.111]             }
[17:44:47.111]             else {
[17:44:47.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.111]             }
[17:44:47.111]             {
[17:44:47.111]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.111]                   0L) {
[17:44:47.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.111]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.111]                   base::options(opts)
[17:44:47.111]                 }
[17:44:47.111]                 {
[17:44:47.111]                   {
[17:44:47.111]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.111]                     NULL
[17:44:47.111]                   }
[17:44:47.111]                   options(future.plan = NULL)
[17:44:47.111]                   if (is.na(NA_character_)) 
[17:44:47.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.111]                     .init = FALSE)
[17:44:47.111]                 }
[17:44:47.111]             }
[17:44:47.111]         }
[17:44:47.111]     })
[17:44:47.111]     if (TRUE) {
[17:44:47.111]         base::sink(type = "output", split = FALSE)
[17:44:47.111]         if (TRUE) {
[17:44:47.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.111]         }
[17:44:47.111]         else {
[17:44:47.111]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.111]         }
[17:44:47.111]         base::close(...future.stdout)
[17:44:47.111]         ...future.stdout <- NULL
[17:44:47.111]     }
[17:44:47.111]     ...future.result$conditions <- ...future.conditions
[17:44:47.111]     ...future.result$finished <- base::Sys.time()
[17:44:47.111]     ...future.result
[17:44:47.111] }
[17:44:47.117] assign_globals() ...
[17:44:47.117] List of 5
[17:44:47.117]  $ ...future.FUN            :function (C, k)  
[17:44:47.117]  $ MoreArgs                 : NULL
[17:44:47.117]  $ ...future.elements_ii    :List of 2
[17:44:47.117]   ..$ :List of 1
[17:44:47.117]   .. ..$ : chr "D"
[17:44:47.117]   ..$ :List of 1
[17:44:47.117]   .. ..$ : int 2
[17:44:47.117]  $ ...future.seeds_ii       : NULL
[17:44:47.117]  $ ...future.globals.maxSize: NULL
[17:44:47.117]  - attr(*, "where")=List of 5
[17:44:47.117]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.117]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.117]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.117]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.117]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.117]  - attr(*, "resolved")= logi FALSE
[17:44:47.117]  - attr(*, "total_size")= num 3488
[17:44:47.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.117]  - attr(*, "already-done")= logi TRUE
[17:44:47.129] - reassign environment for ‘...future.FUN’
[17:44:47.129] - copied ‘...future.FUN’ to environment
[17:44:47.129] - copied ‘MoreArgs’ to environment
[17:44:47.129] - copied ‘...future.elements_ii’ to environment
[17:44:47.130] - copied ‘...future.seeds_ii’ to environment
[17:44:47.130] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.130] assign_globals() ... done
[17:44:47.130] requestCore(): workers = 2
[17:44:47.131] Poll #1 (0): usedCores() = 2, workers = 2
[17:44:47.151] result() for MulticoreFuture ...
[17:44:47.152] result() for MulticoreFuture ...
[17:44:47.152] result() for MulticoreFuture ... done
[17:44:47.152] result() for MulticoreFuture ... done
[17:44:47.152] result() for MulticoreFuture ...
[17:44:47.152] result() for MulticoreFuture ... done
[17:44:47.155] MulticoreFuture started
[17:44:47.155] - Launch lazy future ... done
[17:44:47.156] run() for ‘MulticoreFuture’ ... done
[17:44:47.156] Created future:
[17:44:47.156] plan(): Setting new future strategy stack:
[17:44:47.156] List of future strategies:
[17:44:47.156] 1. sequential:
[17:44:47.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.156]    - tweaked: FALSE
[17:44:47.156]    - call: NULL
[17:44:47.158] plan(): nbrOfWorkers() = 1
[17:44:47.160] plan(): Setting new future strategy stack:
[17:44:47.160] List of future strategies:
[17:44:47.160] 1. multicore:
[17:44:47.160]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.160]    - tweaked: FALSE
[17:44:47.160]    - call: plan(strategy)
[17:44:47.165] plan(): nbrOfWorkers() = 2
[17:44:47.156] MulticoreFuture:
[17:44:47.156] Label: ‘future_mapply-4’
[17:44:47.156] Expression:
[17:44:47.156] {
[17:44:47.156]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.156]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.156]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.156]         on.exit(options(oopts), add = TRUE)
[17:44:47.156]     }
[17:44:47.156]     {
[17:44:47.156]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.156]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.156]         do.call(mapply, args = args)
[17:44:47.156]     }
[17:44:47.156] }
[17:44:47.156] Lazy evaluation: FALSE
[17:44:47.156] Asynchronous evaluation: TRUE
[17:44:47.156] Local evaluation: TRUE
[17:44:47.156] Environment: R_GlobalEnv
[17:44:47.156] Capture standard output: TRUE
[17:44:47.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.156] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.156] Packages: <none>
[17:44:47.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.156] Resolved: TRUE
[17:44:47.156] Value: <not collected>
[17:44:47.156] Conditions captured: <none>
[17:44:47.156] Early signaling: FALSE
[17:44:47.156] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.156] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.166] Chunk #4 of 5 ... DONE
[17:44:47.167] Chunk #5 of 5 ...
[17:44:47.167]  - Finding globals in '...' for chunk #5 ...
[17:44:47.167] getGlobalsAndPackages() ...
[17:44:47.167] Searching for globals...
[17:44:47.168] 
[17:44:47.168] Searching for globals ... DONE
[17:44:47.168] - globals: [0] <none>
[17:44:47.168] getGlobalsAndPackages() ... DONE
[17:44:47.168]    + additional globals found: [n=0] 
[17:44:47.168]    + additional namespaces needed: [n=0] 
[17:44:47.169]  - Finding globals in '...' for chunk #5 ... DONE
[17:44:47.169]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:47.169]  - seeds: <none>
[17:44:47.169]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.169] getGlobalsAndPackages() ...
[17:44:47.169] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.169] Resolving globals: FALSE
[17:44:47.170] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:47.171] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.171] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.172] 
[17:44:47.172] getGlobalsAndPackages() ... DONE
[17:44:47.172] run() for ‘Future’ ...
[17:44:47.172] - state: ‘created’
[17:44:47.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.177] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.177] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.178]   - Field: ‘label’
[17:44:47.178]   - Field: ‘local’
[17:44:47.178]   - Field: ‘owner’
[17:44:47.178]   - Field: ‘envir’
[17:44:47.187]   - Field: ‘workers’
[17:44:47.187]   - Field: ‘packages’
[17:44:47.187]   - Field: ‘gc’
[17:44:47.187]   - Field: ‘job’
[17:44:47.187]   - Field: ‘conditions’
[17:44:47.187]   - Field: ‘expr’
[17:44:47.187]   - Field: ‘uuid’
[17:44:47.187]   - Field: ‘seed’
[17:44:47.188]   - Field: ‘version’
[17:44:47.188]   - Field: ‘result’
[17:44:47.188]   - Field: ‘asynchronous’
[17:44:47.188]   - Field: ‘calls’
[17:44:47.188]   - Field: ‘globals’
[17:44:47.188]   - Field: ‘stdout’
[17:44:47.188]   - Field: ‘earlySignal’
[17:44:47.188]   - Field: ‘lazy’
[17:44:47.188]   - Field: ‘state’
[17:44:47.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.189] - Launch lazy future ...
[17:44:47.189] Packages needed by the future expression (n = 0): <none>
[17:44:47.189] Packages needed by future strategies (n = 0): <none>
[17:44:47.190] {
[17:44:47.190]     {
[17:44:47.190]         {
[17:44:47.190]             ...future.startTime <- base::Sys.time()
[17:44:47.190]             {
[17:44:47.190]                 {
[17:44:47.190]                   {
[17:44:47.190]                     {
[17:44:47.190]                       base::local({
[17:44:47.190]                         has_future <- base::requireNamespace("future", 
[17:44:47.190]                           quietly = TRUE)
[17:44:47.190]                         if (has_future) {
[17:44:47.190]                           ns <- base::getNamespace("future")
[17:44:47.190]                           version <- ns[[".package"]][["version"]]
[17:44:47.190]                           if (is.null(version)) 
[17:44:47.190]                             version <- utils::packageVersion("future")
[17:44:47.190]                         }
[17:44:47.190]                         else {
[17:44:47.190]                           version <- NULL
[17:44:47.190]                         }
[17:44:47.190]                         if (!has_future || version < "1.8.0") {
[17:44:47.190]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.190]                             "", base::R.version$version.string), 
[17:44:47.190]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.190]                               "release", "version")], collapse = " "), 
[17:44:47.190]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.190]                             info)
[17:44:47.190]                           info <- base::paste(info, collapse = "; ")
[17:44:47.190]                           if (!has_future) {
[17:44:47.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.190]                               info)
[17:44:47.190]                           }
[17:44:47.190]                           else {
[17:44:47.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.190]                               info, version)
[17:44:47.190]                           }
[17:44:47.190]                           base::stop(msg)
[17:44:47.190]                         }
[17:44:47.190]                       })
[17:44:47.190]                     }
[17:44:47.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.190]                     base::options(mc.cores = 1L)
[17:44:47.190]                   }
[17:44:47.190]                   ...future.strategy.old <- future::plan("list")
[17:44:47.190]                   options(future.plan = NULL)
[17:44:47.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.190]                 }
[17:44:47.190]                 ...future.workdir <- getwd()
[17:44:47.190]             }
[17:44:47.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.190]         }
[17:44:47.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.190]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:47.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.190]             base::names(...future.oldOptions))
[17:44:47.190]     }
[17:44:47.190]     if (FALSE) {
[17:44:47.190]     }
[17:44:47.190]     else {
[17:44:47.190]         if (TRUE) {
[17:44:47.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.190]                 open = "w")
[17:44:47.190]         }
[17:44:47.190]         else {
[17:44:47.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.190]         }
[17:44:47.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.190]             base::sink(type = "output", split = FALSE)
[17:44:47.190]             base::close(...future.stdout)
[17:44:47.190]         }, add = TRUE)
[17:44:47.190]     }
[17:44:47.190]     ...future.frame <- base::sys.nframe()
[17:44:47.190]     ...future.conditions <- base::list()
[17:44:47.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.190]     if (FALSE) {
[17:44:47.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.190]     }
[17:44:47.190]     ...future.result <- base::tryCatch({
[17:44:47.190]         base::withCallingHandlers({
[17:44:47.190]             ...future.value <- base::withVisible(base::local({
[17:44:47.190]                 withCallingHandlers({
[17:44:47.190]                   {
[17:44:47.190]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.190]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.190]                       ...future.globals.maxSize)) {
[17:44:47.190]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.190]                       on.exit(options(oopts), add = TRUE)
[17:44:47.190]                     }
[17:44:47.190]                     {
[17:44:47.190]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.190]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.190]                         USE.NAMES = FALSE)
[17:44:47.190]                       do.call(mapply, args = args)
[17:44:47.190]                     }
[17:44:47.190]                   }
[17:44:47.190]                 }, immediateCondition = function(cond) {
[17:44:47.190]                   save_rds <- function (object, pathname, ...) 
[17:44:47.190]                   {
[17:44:47.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.190]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.190]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.190]                         fi_tmp[["mtime"]])
[17:44:47.190]                     }
[17:44:47.190]                     tryCatch({
[17:44:47.190]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.190]                     }, error = function(ex) {
[17:44:47.190]                       msg <- conditionMessage(ex)
[17:44:47.190]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.190]                         fi_tmp[["mtime"]], msg)
[17:44:47.190]                       ex$message <- msg
[17:44:47.190]                       stop(ex)
[17:44:47.190]                     })
[17:44:47.190]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.190]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.190]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.190]                       fi <- file.info(pathname)
[17:44:47.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.190]                         fi[["size"]], fi[["mtime"]])
[17:44:47.190]                       stop(msg)
[17:44:47.190]                     }
[17:44:47.190]                     invisible(pathname)
[17:44:47.190]                   }
[17:44:47.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.190]                     rootPath = tempdir()) 
[17:44:47.190]                   {
[17:44:47.190]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.190]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.190]                       tmpdir = path, fileext = ".rds")
[17:44:47.190]                     save_rds(obj, file)
[17:44:47.190]                   }
[17:44:47.190]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.190]                   {
[17:44:47.190]                     inherits <- base::inherits
[17:44:47.190]                     invokeRestart <- base::invokeRestart
[17:44:47.190]                     is.null <- base::is.null
[17:44:47.190]                     muffled <- FALSE
[17:44:47.190]                     if (inherits(cond, "message")) {
[17:44:47.190]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.190]                       if (muffled) 
[17:44:47.190]                         invokeRestart("muffleMessage")
[17:44:47.190]                     }
[17:44:47.190]                     else if (inherits(cond, "warning")) {
[17:44:47.190]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.190]                       if (muffled) 
[17:44:47.190]                         invokeRestart("muffleWarning")
[17:44:47.190]                     }
[17:44:47.190]                     else if (inherits(cond, "condition")) {
[17:44:47.190]                       if (!is.null(pattern)) {
[17:44:47.190]                         computeRestarts <- base::computeRestarts
[17:44:47.190]                         grepl <- base::grepl
[17:44:47.190]                         restarts <- computeRestarts(cond)
[17:44:47.190]                         for (restart in restarts) {
[17:44:47.190]                           name <- restart$name
[17:44:47.190]                           if (is.null(name)) 
[17:44:47.190]                             next
[17:44:47.190]                           if (!grepl(pattern, name)) 
[17:44:47.190]                             next
[17:44:47.190]                           invokeRestart(restart)
[17:44:47.190]                           muffled <- TRUE
[17:44:47.190]                           break
[17:44:47.190]                         }
[17:44:47.190]                       }
[17:44:47.190]                     }
[17:44:47.190]                     invisible(muffled)
[17:44:47.190]                   }
[17:44:47.190]                   muffleCondition(cond)
[17:44:47.190]                 })
[17:44:47.190]             }))
[17:44:47.190]             future::FutureResult(value = ...future.value$value, 
[17:44:47.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.190]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.190]                     ...future.globalenv.names))
[17:44:47.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.190]         }, condition = base::local({
[17:44:47.190]             c <- base::c
[17:44:47.190]             inherits <- base::inherits
[17:44:47.190]             invokeRestart <- base::invokeRestart
[17:44:47.190]             length <- base::length
[17:44:47.190]             list <- base::list
[17:44:47.190]             seq.int <- base::seq.int
[17:44:47.190]             signalCondition <- base::signalCondition
[17:44:47.190]             sys.calls <- base::sys.calls
[17:44:47.190]             `[[` <- base::`[[`
[17:44:47.190]             `+` <- base::`+`
[17:44:47.190]             `<<-` <- base::`<<-`
[17:44:47.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.190]                   3L)]
[17:44:47.190]             }
[17:44:47.190]             function(cond) {
[17:44:47.190]                 is_error <- inherits(cond, "error")
[17:44:47.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.190]                   NULL)
[17:44:47.190]                 if (is_error) {
[17:44:47.190]                   sessionInformation <- function() {
[17:44:47.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.190]                       search = base::search(), system = base::Sys.info())
[17:44:47.190]                   }
[17:44:47.190]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.190]                     cond$call), session = sessionInformation(), 
[17:44:47.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.190]                   signalCondition(cond)
[17:44:47.190]                 }
[17:44:47.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.190]                 "immediateCondition"))) {
[17:44:47.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.190]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.190]                   if (TRUE && !signal) {
[17:44:47.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.190]                     {
[17:44:47.190]                       inherits <- base::inherits
[17:44:47.190]                       invokeRestart <- base::invokeRestart
[17:44:47.190]                       is.null <- base::is.null
[17:44:47.190]                       muffled <- FALSE
[17:44:47.190]                       if (inherits(cond, "message")) {
[17:44:47.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.190]                         if (muffled) 
[17:44:47.190]                           invokeRestart("muffleMessage")
[17:44:47.190]                       }
[17:44:47.190]                       else if (inherits(cond, "warning")) {
[17:44:47.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.190]                         if (muffled) 
[17:44:47.190]                           invokeRestart("muffleWarning")
[17:44:47.190]                       }
[17:44:47.190]                       else if (inherits(cond, "condition")) {
[17:44:47.190]                         if (!is.null(pattern)) {
[17:44:47.190]                           computeRestarts <- base::computeRestarts
[17:44:47.190]                           grepl <- base::grepl
[17:44:47.190]                           restarts <- computeRestarts(cond)
[17:44:47.190]                           for (restart in restarts) {
[17:44:47.190]                             name <- restart$name
[17:44:47.190]                             if (is.null(name)) 
[17:44:47.190]                               next
[17:44:47.190]                             if (!grepl(pattern, name)) 
[17:44:47.190]                               next
[17:44:47.190]                             invokeRestart(restart)
[17:44:47.190]                             muffled <- TRUE
[17:44:47.190]                             break
[17:44:47.190]                           }
[17:44:47.190]                         }
[17:44:47.190]                       }
[17:44:47.190]                       invisible(muffled)
[17:44:47.190]                     }
[17:44:47.190]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.190]                   }
[17:44:47.190]                 }
[17:44:47.190]                 else {
[17:44:47.190]                   if (TRUE) {
[17:44:47.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.190]                     {
[17:44:47.190]                       inherits <- base::inherits
[17:44:47.190]                       invokeRestart <- base::invokeRestart
[17:44:47.190]                       is.null <- base::is.null
[17:44:47.190]                       muffled <- FALSE
[17:44:47.190]                       if (inherits(cond, "message")) {
[17:44:47.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.190]                         if (muffled) 
[17:44:47.190]                           invokeRestart("muffleMessage")
[17:44:47.190]                       }
[17:44:47.190]                       else if (inherits(cond, "warning")) {
[17:44:47.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.190]                         if (muffled) 
[17:44:47.190]                           invokeRestart("muffleWarning")
[17:44:47.190]                       }
[17:44:47.190]                       else if (inherits(cond, "condition")) {
[17:44:47.190]                         if (!is.null(pattern)) {
[17:44:47.190]                           computeRestarts <- base::computeRestarts
[17:44:47.190]                           grepl <- base::grepl
[17:44:47.190]                           restarts <- computeRestarts(cond)
[17:44:47.190]                           for (restart in restarts) {
[17:44:47.190]                             name <- restart$name
[17:44:47.190]                             if (is.null(name)) 
[17:44:47.190]                               next
[17:44:47.190]                             if (!grepl(pattern, name)) 
[17:44:47.190]                               next
[17:44:47.190]                             invokeRestart(restart)
[17:44:47.190]                             muffled <- TRUE
[17:44:47.190]                             break
[17:44:47.190]                           }
[17:44:47.190]                         }
[17:44:47.190]                       }
[17:44:47.190]                       invisible(muffled)
[17:44:47.190]                     }
[17:44:47.190]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.190]                   }
[17:44:47.190]                 }
[17:44:47.190]             }
[17:44:47.190]         }))
[17:44:47.190]     }, error = function(ex) {
[17:44:47.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.190]                 ...future.rng), started = ...future.startTime, 
[17:44:47.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.190]             version = "1.8"), class = "FutureResult")
[17:44:47.190]     }, finally = {
[17:44:47.190]         if (!identical(...future.workdir, getwd())) 
[17:44:47.190]             setwd(...future.workdir)
[17:44:47.190]         {
[17:44:47.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.190]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.190]             }
[17:44:47.190]             base::options(...future.oldOptions)
[17:44:47.190]             if (.Platform$OS.type == "windows") {
[17:44:47.190]                 old_names <- names(...future.oldEnvVars)
[17:44:47.190]                 envs <- base::Sys.getenv()
[17:44:47.190]                 names <- names(envs)
[17:44:47.190]                 common <- intersect(names, old_names)
[17:44:47.190]                 added <- setdiff(names, old_names)
[17:44:47.190]                 removed <- setdiff(old_names, names)
[17:44:47.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.190]                   envs[common]]
[17:44:47.190]                 NAMES <- toupper(changed)
[17:44:47.190]                 args <- list()
[17:44:47.190]                 for (kk in seq_along(NAMES)) {
[17:44:47.190]                   name <- changed[[kk]]
[17:44:47.190]                   NAME <- NAMES[[kk]]
[17:44:47.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.190]                     next
[17:44:47.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.190]                 }
[17:44:47.190]                 NAMES <- toupper(added)
[17:44:47.190]                 for (kk in seq_along(NAMES)) {
[17:44:47.190]                   name <- added[[kk]]
[17:44:47.190]                   NAME <- NAMES[[kk]]
[17:44:47.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.190]                     next
[17:44:47.190]                   args[[name]] <- ""
[17:44:47.190]                 }
[17:44:47.190]                 NAMES <- toupper(removed)
[17:44:47.190]                 for (kk in seq_along(NAMES)) {
[17:44:47.190]                   name <- removed[[kk]]
[17:44:47.190]                   NAME <- NAMES[[kk]]
[17:44:47.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.190]                     next
[17:44:47.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.190]                 }
[17:44:47.190]                 if (length(args) > 0) 
[17:44:47.190]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.190]             }
[17:44:47.190]             else {
[17:44:47.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.190]             }
[17:44:47.190]             {
[17:44:47.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.190]                   0L) {
[17:44:47.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.190]                   base::options(opts)
[17:44:47.190]                 }
[17:44:47.190]                 {
[17:44:47.190]                   {
[17:44:47.190]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.190]                     NULL
[17:44:47.190]                   }
[17:44:47.190]                   options(future.plan = NULL)
[17:44:47.190]                   if (is.na(NA_character_)) 
[17:44:47.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.190]                     .init = FALSE)
[17:44:47.190]                 }
[17:44:47.190]             }
[17:44:47.190]         }
[17:44:47.190]     })
[17:44:47.190]     if (TRUE) {
[17:44:47.190]         base::sink(type = "output", split = FALSE)
[17:44:47.190]         if (TRUE) {
[17:44:47.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.190]         }
[17:44:47.190]         else {
[17:44:47.190]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.190]         }
[17:44:47.190]         base::close(...future.stdout)
[17:44:47.190]         ...future.stdout <- NULL
[17:44:47.190]     }
[17:44:47.190]     ...future.result$conditions <- ...future.conditions
[17:44:47.190]     ...future.result$finished <- base::Sys.time()
[17:44:47.190]     ...future.result
[17:44:47.190] }
[17:44:47.193] assign_globals() ...
[17:44:47.193] List of 5
[17:44:47.193]  $ ...future.FUN            :function (C, k)  
[17:44:47.193]  $ MoreArgs                 : NULL
[17:44:47.193]  $ ...future.elements_ii    :List of 2
[17:44:47.193]   ..$ :List of 1
[17:44:47.193]   .. ..$ : chr "E"
[17:44:47.193]   ..$ :List of 1
[17:44:47.193]   .. ..$ : int 1
[17:44:47.193]  $ ...future.seeds_ii       : NULL
[17:44:47.193]  $ ...future.globals.maxSize: NULL
[17:44:47.193]  - attr(*, "where")=List of 5
[17:44:47.193]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.193]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.193]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.193]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.193]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.193]  - attr(*, "resolved")= logi FALSE
[17:44:47.193]  - attr(*, "total_size")= num 3488
[17:44:47.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.193]  - attr(*, "already-done")= logi TRUE
[17:44:47.201] - reassign environment for ‘...future.FUN’
[17:44:47.201] - copied ‘...future.FUN’ to environment
[17:44:47.201] - copied ‘MoreArgs’ to environment
[17:44:47.202] - copied ‘...future.elements_ii’ to environment
[17:44:47.202] - copied ‘...future.seeds_ii’ to environment
[17:44:47.202] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.202] assign_globals() ... done
[17:44:47.202] requestCore(): workers = 2
[17:44:47.203] Poll #1 (0): usedCores() = 2, workers = 2
[17:44:47.213] result() for MulticoreFuture ...
[17:44:47.214] result() for MulticoreFuture ...
[17:44:47.214] result() for MulticoreFuture ... done
[17:44:47.214] result() for MulticoreFuture ... done
[17:44:47.214] result() for MulticoreFuture ...
[17:44:47.215] result() for MulticoreFuture ... done
[17:44:47.217] MulticoreFuture started
[17:44:47.218] - Launch lazy future ... done
[17:44:47.218] run() for ‘MulticoreFuture’ ... done
[17:44:47.219] Created future:
[17:44:47.218] plan(): Setting new future strategy stack:
[17:44:47.219] List of future strategies:
[17:44:47.219] 1. sequential:
[17:44:47.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.219]    - tweaked: FALSE
[17:44:47.219]    - call: NULL
[17:44:47.220] plan(): nbrOfWorkers() = 1
[17:44:47.222] plan(): Setting new future strategy stack:
[17:44:47.222] List of future strategies:
[17:44:47.222] 1. multicore:
[17:44:47.222]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.222]    - tweaked: FALSE
[17:44:47.222]    - call: plan(strategy)
[17:44:47.228] plan(): nbrOfWorkers() = 2
[17:44:47.219] MulticoreFuture:
[17:44:47.219] Label: ‘future_mapply-5’
[17:44:47.219] Expression:
[17:44:47.219] {
[17:44:47.219]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.219]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.219]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.219]         on.exit(options(oopts), add = TRUE)
[17:44:47.219]     }
[17:44:47.219]     {
[17:44:47.219]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.219]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.219]         do.call(mapply, args = args)
[17:44:47.219]     }
[17:44:47.219] }
[17:44:47.219] Lazy evaluation: FALSE
[17:44:47.219] Asynchronous evaluation: TRUE
[17:44:47.219] Local evaluation: TRUE
[17:44:47.219] Environment: R_GlobalEnv
[17:44:47.219] Capture standard output: TRUE
[17:44:47.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.219] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.219] Packages: <none>
[17:44:47.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.219] Resolved: TRUE
[17:44:47.219] Value: <not collected>
[17:44:47.219] Conditions captured: <none>
[17:44:47.219] Early signaling: FALSE
[17:44:47.219] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.219] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.229] Chunk #5 of 5 ... DONE
[17:44:47.229] Launching 5 futures (chunks) ... DONE
[17:44:47.229] Resolving 5 futures (chunks) ...
[17:44:47.229] resolve() on list ...
[17:44:47.229]  recursive: 0
[17:44:47.229]  length: 5
[17:44:47.229] 
[17:44:47.230] Future #1
[17:44:47.230] result() for MulticoreFuture ...
[17:44:47.230] result() for MulticoreFuture ... done
[17:44:47.230] result() for MulticoreFuture ...
[17:44:47.230] result() for MulticoreFuture ... done
[17:44:47.230] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.230] - nx: 5
[17:44:47.231] - relay: TRUE
[17:44:47.231] - stdout: TRUE
[17:44:47.231] - signal: TRUE
[17:44:47.231] - resignal: FALSE
[17:44:47.231] - force: TRUE
[17:44:47.231] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:47.231] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:47.232]  - until=1
[17:44:47.232]  - relaying element #1
[17:44:47.232] result() for MulticoreFuture ...
[17:44:47.232] result() for MulticoreFuture ... done
[17:44:47.232] result() for MulticoreFuture ...
[17:44:47.232] result() for MulticoreFuture ... done
[17:44:47.233] result() for MulticoreFuture ...
[17:44:47.233] result() for MulticoreFuture ... done
[17:44:47.233] result() for MulticoreFuture ...
[17:44:47.233] result() for MulticoreFuture ... done
[17:44:47.233] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:47.233] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:47.233] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.234]  length: 4 (resolved future 1)
[17:44:47.234] Future #2
[17:44:47.234] result() for MulticoreFuture ...
[17:44:47.234] result() for MulticoreFuture ... done
[17:44:47.234] result() for MulticoreFuture ...
[17:44:47.234] result() for MulticoreFuture ... done
[17:44:47.235] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.235] - nx: 5
[17:44:47.235] - relay: TRUE
[17:44:47.235] - stdout: TRUE
[17:44:47.235] - signal: TRUE
[17:44:47.235] - resignal: FALSE
[17:44:47.235] - force: TRUE
[17:44:47.236] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:47.236] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:47.236]  - until=2
[17:44:47.236]  - relaying element #2
[17:44:47.236] result() for MulticoreFuture ...
[17:44:47.236] result() for MulticoreFuture ... done
[17:44:47.237] result() for MulticoreFuture ...
[17:44:47.237] result() for MulticoreFuture ... done
[17:44:47.237] result() for MulticoreFuture ...
[17:44:47.237] result() for MulticoreFuture ... done
[17:44:47.237] result() for MulticoreFuture ...
[17:44:47.237] result() for MulticoreFuture ... done
[17:44:47.237] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:47.238] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:47.238] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.238]  length: 3 (resolved future 2)
[17:44:47.238] Future #3
[17:44:47.238] result() for MulticoreFuture ...
[17:44:47.238] result() for MulticoreFuture ... done
[17:44:47.239] result() for MulticoreFuture ...
[17:44:47.239] result() for MulticoreFuture ... done
[17:44:47.239] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:44:47.239] - nx: 5
[17:44:47.239] - relay: TRUE
[17:44:47.239] - stdout: TRUE
[17:44:47.239] - signal: TRUE
[17:44:47.240] - resignal: FALSE
[17:44:47.240] - force: TRUE
[17:44:47.240] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:47.240] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:47.240]  - until=3
[17:44:47.240]  - relaying element #3
[17:44:47.240] result() for MulticoreFuture ...
[17:44:47.241] result() for MulticoreFuture ... done
[17:44:47.241] result() for MulticoreFuture ...
[17:44:47.241] result() for MulticoreFuture ... done
[17:44:47.241] result() for MulticoreFuture ...
[17:44:47.241] result() for MulticoreFuture ... done
[17:44:47.241] result() for MulticoreFuture ...
[17:44:47.242] result() for MulticoreFuture ... done
[17:44:47.242] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:47.242] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:47.242] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:44:47.242]  length: 2 (resolved future 3)
[17:44:47.247] Future #4
[17:44:47.248] result() for MulticoreFuture ...
[17:44:47.250] result() for MulticoreFuture ...
[17:44:47.250] result() for MulticoreFuture ... done
[17:44:47.250] result() for MulticoreFuture ... done
[17:44:47.251] result() for MulticoreFuture ...
[17:44:47.251] result() for MulticoreFuture ... done
[17:44:47.251] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:44:47.252] - nx: 5
[17:44:47.252] - relay: TRUE
[17:44:47.252] - stdout: TRUE
[17:44:47.253] - signal: TRUE
[17:44:47.253] - resignal: FALSE
[17:44:47.253] - force: TRUE
[17:44:47.253] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:47.254] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:47.254]  - until=4
[17:44:47.254]  - relaying element #4
[17:44:47.255] result() for MulticoreFuture ...
[17:44:47.255] result() for MulticoreFuture ... done
[17:44:47.255] result() for MulticoreFuture ...
[17:44:47.255] result() for MulticoreFuture ... done
[17:44:47.256] result() for MulticoreFuture ...
[17:44:47.256] result() for MulticoreFuture ... done
[17:44:47.257] result() for MulticoreFuture ...
[17:44:47.257] result() for MulticoreFuture ... done
[17:44:47.257] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:47.257] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:47.258] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:44:47.258]  length: 1 (resolved future 4)
[17:44:47.258] Future #5
[17:44:47.259] result() for MulticoreFuture ...
[17:44:47.260] result() for MulticoreFuture ...
[17:44:47.260] result() for MulticoreFuture ... done
[17:44:47.261] result() for MulticoreFuture ... done
[17:44:47.261] result() for MulticoreFuture ...
[17:44:47.261] result() for MulticoreFuture ... done
[17:44:47.262] signalConditionsASAP(MulticoreFuture, pos=5) ...
[17:44:47.262] - nx: 5
[17:44:47.262] - relay: TRUE
[17:44:47.262] - stdout: TRUE
[17:44:47.262] - signal: TRUE
[17:44:47.263] - resignal: FALSE
[17:44:47.263] - force: TRUE
[17:44:47.263] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:47.263] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:47.263]  - until=5
[17:44:47.264]  - relaying element #5
[17:44:47.264] result() for MulticoreFuture ...
[17:44:47.264] result() for MulticoreFuture ... done
[17:44:47.264] result() for MulticoreFuture ...
[17:44:47.264] result() for MulticoreFuture ... done
[17:44:47.265] result() for MulticoreFuture ...
[17:44:47.265] result() for MulticoreFuture ... done
[17:44:47.265] result() for MulticoreFuture ...
[17:44:47.265] result() for MulticoreFuture ... done
[17:44:47.265] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:47.266] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:47.266] signalConditionsASAP(MulticoreFuture, pos=5) ... done
[17:44:47.266]  length: 0 (resolved future 5)
[17:44:47.266] Relaying remaining futures
[17:44:47.266] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.267] - nx: 5
[17:44:47.267] - relay: TRUE
[17:44:47.267] - stdout: TRUE
[17:44:47.267] - signal: TRUE
[17:44:47.267] - resignal: FALSE
[17:44:47.267] - force: TRUE
[17:44:47.268] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:47.268] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:44:47.268] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:47.268] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:47.269] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.269] resolve() on list ... DONE
[17:44:47.269] result() for MulticoreFuture ...
[17:44:47.269] result() for MulticoreFuture ... done
[17:44:47.269] result() for MulticoreFuture ...
[17:44:47.269] result() for MulticoreFuture ... done
[17:44:47.270] result() for MulticoreFuture ...
[17:44:47.270] result() for MulticoreFuture ... done
[17:44:47.270] result() for MulticoreFuture ...
[17:44:47.270] result() for MulticoreFuture ... done
[17:44:47.270] result() for MulticoreFuture ...
[17:44:47.271] result() for MulticoreFuture ... done
[17:44:47.271] result() for MulticoreFuture ...
[17:44:47.271] result() for MulticoreFuture ... done
[17:44:47.271] result() for MulticoreFuture ...
[17:44:47.271] result() for MulticoreFuture ... done
[17:44:47.272] result() for MulticoreFuture ...
[17:44:47.272] result() for MulticoreFuture ... done
[17:44:47.272] result() for MulticoreFuture ...
[17:44:47.272] result() for MulticoreFuture ... done
[17:44:47.272] result() for MulticoreFuture ...
[17:44:47.273] result() for MulticoreFuture ... done
[17:44:47.273]  - Number of value chunks collected: 5
[17:44:47.273] Resolving 5 futures (chunks) ... DONE
[17:44:47.273] Reducing values from 5 chunks ...
[17:44:47.273]  - Number of values collected after concatenation: 5
[17:44:47.273]  - Number of values expected: 5
[17:44:47.274] Reducing values from 5 chunks ... DONE
[17:44:47.274] future_mapply() ... DONE
[17:44:47.274] future_mapply() ...
[17:44:47.279] Number of chunks: 2
[17:44:47.280] getGlobalsAndPackagesXApply() ...
[17:44:47.280]  - future.globals: TRUE
[17:44:47.280] getGlobalsAndPackages() ...
[17:44:47.280] Searching for globals...
[17:44:47.281] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:47.282] Searching for globals ... DONE
[17:44:47.282] Resolving globals: FALSE
[17:44:47.282] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:47.283] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:47.283] - globals: [1] ‘FUN’
[17:44:47.283] 
[17:44:47.283] getGlobalsAndPackages() ... DONE
[17:44:47.283]  - globals found/used: [n=1] ‘FUN’
[17:44:47.283]  - needed namespaces: [n=0] 
[17:44:47.283] Finding globals ... DONE
[17:44:47.283] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.284] List of 2
[17:44:47.284]  $ ...future.FUN:function (C, k)  
[17:44:47.284]  $ MoreArgs     : list()
[17:44:47.284]  - attr(*, "where")=List of 2
[17:44:47.284]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.284]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.284]  - attr(*, "resolved")= logi FALSE
[17:44:47.284]  - attr(*, "total_size")= num NA
[17:44:47.286] Packages to be attached in all futures: [n=0] 
[17:44:47.286] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.286] Number of futures (= number of chunks): 2
[17:44:47.287] Launching 2 futures (chunks) ...
[17:44:47.287] Chunk #1 of 2 ...
[17:44:47.287]  - Finding globals in '...' for chunk #1 ...
[17:44:47.287] getGlobalsAndPackages() ...
[17:44:47.287] Searching for globals...
[17:44:47.287] 
[17:44:47.287] Searching for globals ... DONE
[17:44:47.288] - globals: [0] <none>
[17:44:47.288] getGlobalsAndPackages() ... DONE
[17:44:47.288]    + additional globals found: [n=0] 
[17:44:47.288]    + additional namespaces needed: [n=0] 
[17:44:47.288]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.288]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.288]  - seeds: <none>
[17:44:47.288]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.288] getGlobalsAndPackages() ...
[17:44:47.288] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.289] Resolving globals: FALSE
[17:44:47.291] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.292] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.292] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.292] 
[17:44:47.292] getGlobalsAndPackages() ... DONE
[17:44:47.292] run() for ‘Future’ ...
[17:44:47.292] - state: ‘created’
[17:44:47.293] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.296] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.297]   - Field: ‘label’
[17:44:47.297]   - Field: ‘local’
[17:44:47.297]   - Field: ‘owner’
[17:44:47.297]   - Field: ‘envir’
[17:44:47.297]   - Field: ‘workers’
[17:44:47.297]   - Field: ‘packages’
[17:44:47.297]   - Field: ‘gc’
[17:44:47.298]   - Field: ‘job’
[17:44:47.298]   - Field: ‘conditions’
[17:44:47.298]   - Field: ‘expr’
[17:44:47.298]   - Field: ‘uuid’
[17:44:47.298]   - Field: ‘seed’
[17:44:47.298]   - Field: ‘version’
[17:44:47.298]   - Field: ‘result’
[17:44:47.298]   - Field: ‘asynchronous’
[17:44:47.298]   - Field: ‘calls’
[17:44:47.299]   - Field: ‘globals’
[17:44:47.299]   - Field: ‘stdout’
[17:44:47.299]   - Field: ‘earlySignal’
[17:44:47.299]   - Field: ‘lazy’
[17:44:47.299]   - Field: ‘state’
[17:44:47.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.299] - Launch lazy future ...
[17:44:47.300] Packages needed by the future expression (n = 0): <none>
[17:44:47.300] Packages needed by future strategies (n = 0): <none>
[17:44:47.300] {
[17:44:47.300]     {
[17:44:47.300]         {
[17:44:47.300]             ...future.startTime <- base::Sys.time()
[17:44:47.300]             {
[17:44:47.300]                 {
[17:44:47.300]                   {
[17:44:47.300]                     {
[17:44:47.300]                       base::local({
[17:44:47.300]                         has_future <- base::requireNamespace("future", 
[17:44:47.300]                           quietly = TRUE)
[17:44:47.300]                         if (has_future) {
[17:44:47.300]                           ns <- base::getNamespace("future")
[17:44:47.300]                           version <- ns[[".package"]][["version"]]
[17:44:47.300]                           if (is.null(version)) 
[17:44:47.300]                             version <- utils::packageVersion("future")
[17:44:47.300]                         }
[17:44:47.300]                         else {
[17:44:47.300]                           version <- NULL
[17:44:47.300]                         }
[17:44:47.300]                         if (!has_future || version < "1.8.0") {
[17:44:47.300]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.300]                             "", base::R.version$version.string), 
[17:44:47.300]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.300]                               "release", "version")], collapse = " "), 
[17:44:47.300]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.300]                             info)
[17:44:47.300]                           info <- base::paste(info, collapse = "; ")
[17:44:47.300]                           if (!has_future) {
[17:44:47.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.300]                               info)
[17:44:47.300]                           }
[17:44:47.300]                           else {
[17:44:47.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.300]                               info, version)
[17:44:47.300]                           }
[17:44:47.300]                           base::stop(msg)
[17:44:47.300]                         }
[17:44:47.300]                       })
[17:44:47.300]                     }
[17:44:47.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.300]                     base::options(mc.cores = 1L)
[17:44:47.300]                   }
[17:44:47.300]                   ...future.strategy.old <- future::plan("list")
[17:44:47.300]                   options(future.plan = NULL)
[17:44:47.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.300]                 }
[17:44:47.300]                 ...future.workdir <- getwd()
[17:44:47.300]             }
[17:44:47.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.300]         }
[17:44:47.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.300]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.300]             base::names(...future.oldOptions))
[17:44:47.300]     }
[17:44:47.300]     if (FALSE) {
[17:44:47.300]     }
[17:44:47.300]     else {
[17:44:47.300]         if (TRUE) {
[17:44:47.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.300]                 open = "w")
[17:44:47.300]         }
[17:44:47.300]         else {
[17:44:47.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.300]         }
[17:44:47.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.300]             base::sink(type = "output", split = FALSE)
[17:44:47.300]             base::close(...future.stdout)
[17:44:47.300]         }, add = TRUE)
[17:44:47.300]     }
[17:44:47.300]     ...future.frame <- base::sys.nframe()
[17:44:47.300]     ...future.conditions <- base::list()
[17:44:47.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.300]     if (FALSE) {
[17:44:47.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.300]     }
[17:44:47.300]     ...future.result <- base::tryCatch({
[17:44:47.300]         base::withCallingHandlers({
[17:44:47.300]             ...future.value <- base::withVisible(base::local({
[17:44:47.300]                 withCallingHandlers({
[17:44:47.300]                   {
[17:44:47.300]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.300]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.300]                       ...future.globals.maxSize)) {
[17:44:47.300]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.300]                       on.exit(options(oopts), add = TRUE)
[17:44:47.300]                     }
[17:44:47.300]                     {
[17:44:47.300]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.300]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.300]                         USE.NAMES = FALSE)
[17:44:47.300]                       do.call(mapply, args = args)
[17:44:47.300]                     }
[17:44:47.300]                   }
[17:44:47.300]                 }, immediateCondition = function(cond) {
[17:44:47.300]                   save_rds <- function (object, pathname, ...) 
[17:44:47.300]                   {
[17:44:47.300]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.300]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.300]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.300]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.300]                         fi_tmp[["mtime"]])
[17:44:47.300]                     }
[17:44:47.300]                     tryCatch({
[17:44:47.300]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.300]                     }, error = function(ex) {
[17:44:47.300]                       msg <- conditionMessage(ex)
[17:44:47.300]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.300]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.300]                         fi_tmp[["mtime"]], msg)
[17:44:47.300]                       ex$message <- msg
[17:44:47.300]                       stop(ex)
[17:44:47.300]                     })
[17:44:47.300]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.300]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.300]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.300]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.300]                       fi <- file.info(pathname)
[17:44:47.300]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.300]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.300]                         fi[["size"]], fi[["mtime"]])
[17:44:47.300]                       stop(msg)
[17:44:47.300]                     }
[17:44:47.300]                     invisible(pathname)
[17:44:47.300]                   }
[17:44:47.300]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.300]                     rootPath = tempdir()) 
[17:44:47.300]                   {
[17:44:47.300]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.300]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.300]                       tmpdir = path, fileext = ".rds")
[17:44:47.300]                     save_rds(obj, file)
[17:44:47.300]                   }
[17:44:47.300]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.300]                   {
[17:44:47.300]                     inherits <- base::inherits
[17:44:47.300]                     invokeRestart <- base::invokeRestart
[17:44:47.300]                     is.null <- base::is.null
[17:44:47.300]                     muffled <- FALSE
[17:44:47.300]                     if (inherits(cond, "message")) {
[17:44:47.300]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.300]                       if (muffled) 
[17:44:47.300]                         invokeRestart("muffleMessage")
[17:44:47.300]                     }
[17:44:47.300]                     else if (inherits(cond, "warning")) {
[17:44:47.300]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.300]                       if (muffled) 
[17:44:47.300]                         invokeRestart("muffleWarning")
[17:44:47.300]                     }
[17:44:47.300]                     else if (inherits(cond, "condition")) {
[17:44:47.300]                       if (!is.null(pattern)) {
[17:44:47.300]                         computeRestarts <- base::computeRestarts
[17:44:47.300]                         grepl <- base::grepl
[17:44:47.300]                         restarts <- computeRestarts(cond)
[17:44:47.300]                         for (restart in restarts) {
[17:44:47.300]                           name <- restart$name
[17:44:47.300]                           if (is.null(name)) 
[17:44:47.300]                             next
[17:44:47.300]                           if (!grepl(pattern, name)) 
[17:44:47.300]                             next
[17:44:47.300]                           invokeRestart(restart)
[17:44:47.300]                           muffled <- TRUE
[17:44:47.300]                           break
[17:44:47.300]                         }
[17:44:47.300]                       }
[17:44:47.300]                     }
[17:44:47.300]                     invisible(muffled)
[17:44:47.300]                   }
[17:44:47.300]                   muffleCondition(cond)
[17:44:47.300]                 })
[17:44:47.300]             }))
[17:44:47.300]             future::FutureResult(value = ...future.value$value, 
[17:44:47.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.300]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.300]                     ...future.globalenv.names))
[17:44:47.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.300]         }, condition = base::local({
[17:44:47.300]             c <- base::c
[17:44:47.300]             inherits <- base::inherits
[17:44:47.300]             invokeRestart <- base::invokeRestart
[17:44:47.300]             length <- base::length
[17:44:47.300]             list <- base::list
[17:44:47.300]             seq.int <- base::seq.int
[17:44:47.300]             signalCondition <- base::signalCondition
[17:44:47.300]             sys.calls <- base::sys.calls
[17:44:47.300]             `[[` <- base::`[[`
[17:44:47.300]             `+` <- base::`+`
[17:44:47.300]             `<<-` <- base::`<<-`
[17:44:47.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.300]                   3L)]
[17:44:47.300]             }
[17:44:47.300]             function(cond) {
[17:44:47.300]                 is_error <- inherits(cond, "error")
[17:44:47.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.300]                   NULL)
[17:44:47.300]                 if (is_error) {
[17:44:47.300]                   sessionInformation <- function() {
[17:44:47.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.300]                       search = base::search(), system = base::Sys.info())
[17:44:47.300]                   }
[17:44:47.300]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.300]                     cond$call), session = sessionInformation(), 
[17:44:47.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.300]                   signalCondition(cond)
[17:44:47.300]                 }
[17:44:47.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.300]                 "immediateCondition"))) {
[17:44:47.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.300]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.300]                   if (TRUE && !signal) {
[17:44:47.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.300]                     {
[17:44:47.300]                       inherits <- base::inherits
[17:44:47.300]                       invokeRestart <- base::invokeRestart
[17:44:47.300]                       is.null <- base::is.null
[17:44:47.300]                       muffled <- FALSE
[17:44:47.300]                       if (inherits(cond, "message")) {
[17:44:47.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.300]                         if (muffled) 
[17:44:47.300]                           invokeRestart("muffleMessage")
[17:44:47.300]                       }
[17:44:47.300]                       else if (inherits(cond, "warning")) {
[17:44:47.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.300]                         if (muffled) 
[17:44:47.300]                           invokeRestart("muffleWarning")
[17:44:47.300]                       }
[17:44:47.300]                       else if (inherits(cond, "condition")) {
[17:44:47.300]                         if (!is.null(pattern)) {
[17:44:47.300]                           computeRestarts <- base::computeRestarts
[17:44:47.300]                           grepl <- base::grepl
[17:44:47.300]                           restarts <- computeRestarts(cond)
[17:44:47.300]                           for (restart in restarts) {
[17:44:47.300]                             name <- restart$name
[17:44:47.300]                             if (is.null(name)) 
[17:44:47.300]                               next
[17:44:47.300]                             if (!grepl(pattern, name)) 
[17:44:47.300]                               next
[17:44:47.300]                             invokeRestart(restart)
[17:44:47.300]                             muffled <- TRUE
[17:44:47.300]                             break
[17:44:47.300]                           }
[17:44:47.300]                         }
[17:44:47.300]                       }
[17:44:47.300]                       invisible(muffled)
[17:44:47.300]                     }
[17:44:47.300]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.300]                   }
[17:44:47.300]                 }
[17:44:47.300]                 else {
[17:44:47.300]                   if (TRUE) {
[17:44:47.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.300]                     {
[17:44:47.300]                       inherits <- base::inherits
[17:44:47.300]                       invokeRestart <- base::invokeRestart
[17:44:47.300]                       is.null <- base::is.null
[17:44:47.300]                       muffled <- FALSE
[17:44:47.300]                       if (inherits(cond, "message")) {
[17:44:47.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.300]                         if (muffled) 
[17:44:47.300]                           invokeRestart("muffleMessage")
[17:44:47.300]                       }
[17:44:47.300]                       else if (inherits(cond, "warning")) {
[17:44:47.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.300]                         if (muffled) 
[17:44:47.300]                           invokeRestart("muffleWarning")
[17:44:47.300]                       }
[17:44:47.300]                       else if (inherits(cond, "condition")) {
[17:44:47.300]                         if (!is.null(pattern)) {
[17:44:47.300]                           computeRestarts <- base::computeRestarts
[17:44:47.300]                           grepl <- base::grepl
[17:44:47.300]                           restarts <- computeRestarts(cond)
[17:44:47.300]                           for (restart in restarts) {
[17:44:47.300]                             name <- restart$name
[17:44:47.300]                             if (is.null(name)) 
[17:44:47.300]                               next
[17:44:47.300]                             if (!grepl(pattern, name)) 
[17:44:47.300]                               next
[17:44:47.300]                             invokeRestart(restart)
[17:44:47.300]                             muffled <- TRUE
[17:44:47.300]                             break
[17:44:47.300]                           }
[17:44:47.300]                         }
[17:44:47.300]                       }
[17:44:47.300]                       invisible(muffled)
[17:44:47.300]                     }
[17:44:47.300]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.300]                   }
[17:44:47.300]                 }
[17:44:47.300]             }
[17:44:47.300]         }))
[17:44:47.300]     }, error = function(ex) {
[17:44:47.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.300]                 ...future.rng), started = ...future.startTime, 
[17:44:47.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.300]             version = "1.8"), class = "FutureResult")
[17:44:47.300]     }, finally = {
[17:44:47.300]         if (!identical(...future.workdir, getwd())) 
[17:44:47.300]             setwd(...future.workdir)
[17:44:47.300]         {
[17:44:47.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.300]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.300]             }
[17:44:47.300]             base::options(...future.oldOptions)
[17:44:47.300]             if (.Platform$OS.type == "windows") {
[17:44:47.300]                 old_names <- names(...future.oldEnvVars)
[17:44:47.300]                 envs <- base::Sys.getenv()
[17:44:47.300]                 names <- names(envs)
[17:44:47.300]                 common <- intersect(names, old_names)
[17:44:47.300]                 added <- setdiff(names, old_names)
[17:44:47.300]                 removed <- setdiff(old_names, names)
[17:44:47.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.300]                   envs[common]]
[17:44:47.300]                 NAMES <- toupper(changed)
[17:44:47.300]                 args <- list()
[17:44:47.300]                 for (kk in seq_along(NAMES)) {
[17:44:47.300]                   name <- changed[[kk]]
[17:44:47.300]                   NAME <- NAMES[[kk]]
[17:44:47.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.300]                     next
[17:44:47.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.300]                 }
[17:44:47.300]                 NAMES <- toupper(added)
[17:44:47.300]                 for (kk in seq_along(NAMES)) {
[17:44:47.300]                   name <- added[[kk]]
[17:44:47.300]                   NAME <- NAMES[[kk]]
[17:44:47.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.300]                     next
[17:44:47.300]                   args[[name]] <- ""
[17:44:47.300]                 }
[17:44:47.300]                 NAMES <- toupper(removed)
[17:44:47.300]                 for (kk in seq_along(NAMES)) {
[17:44:47.300]                   name <- removed[[kk]]
[17:44:47.300]                   NAME <- NAMES[[kk]]
[17:44:47.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.300]                     next
[17:44:47.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.300]                 }
[17:44:47.300]                 if (length(args) > 0) 
[17:44:47.300]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.300]             }
[17:44:47.300]             else {
[17:44:47.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.300]             }
[17:44:47.300]             {
[17:44:47.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.300]                   0L) {
[17:44:47.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.300]                   base::options(opts)
[17:44:47.300]                 }
[17:44:47.300]                 {
[17:44:47.300]                   {
[17:44:47.300]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.300]                     NULL
[17:44:47.300]                   }
[17:44:47.300]                   options(future.plan = NULL)
[17:44:47.300]                   if (is.na(NA_character_)) 
[17:44:47.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.300]                     .init = FALSE)
[17:44:47.300]                 }
[17:44:47.300]             }
[17:44:47.300]         }
[17:44:47.300]     })
[17:44:47.300]     if (TRUE) {
[17:44:47.300]         base::sink(type = "output", split = FALSE)
[17:44:47.300]         if (TRUE) {
[17:44:47.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.300]         }
[17:44:47.300]         else {
[17:44:47.300]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.300]         }
[17:44:47.300]         base::close(...future.stdout)
[17:44:47.300]         ...future.stdout <- NULL
[17:44:47.300]     }
[17:44:47.300]     ...future.result$conditions <- ...future.conditions
[17:44:47.300]     ...future.result$finished <- base::Sys.time()
[17:44:47.300]     ...future.result
[17:44:47.300] }
[17:44:47.303] assign_globals() ...
[17:44:47.303] List of 5
[17:44:47.303]  $ ...future.FUN            :function (C, k)  
[17:44:47.303]  $ MoreArgs                 : list()
[17:44:47.303]  $ ...future.elements_ii    :List of 2
[17:44:47.303]   ..$ :List of 2
[17:44:47.303]   .. ..$ : chr "A"
[17:44:47.303]   .. ..$ : chr "B"
[17:44:47.303]   ..$ :List of 2
[17:44:47.303]   .. ..$ : int 5
[17:44:47.303]   .. ..$ : int 4
[17:44:47.303]  $ ...future.seeds_ii       : NULL
[17:44:47.303]  $ ...future.globals.maxSize: NULL
[17:44:47.303]  - attr(*, "where")=List of 5
[17:44:47.303]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.303]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.303]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.303]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.303]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.303]  - attr(*, "resolved")= logi FALSE
[17:44:47.303]  - attr(*, "total_size")= num 3656
[17:44:47.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.303]  - attr(*, "already-done")= logi TRUE
[17:44:47.308] - reassign environment for ‘...future.FUN’
[17:44:47.308] - copied ‘...future.FUN’ to environment
[17:44:47.308] - copied ‘MoreArgs’ to environment
[17:44:47.308] - copied ‘...future.elements_ii’ to environment
[17:44:47.309] - copied ‘...future.seeds_ii’ to environment
[17:44:47.309] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.309] assign_globals() ... done
[17:44:47.309] requestCore(): workers = 2
[17:44:47.311] MulticoreFuture started
[17:44:47.311] - Launch lazy future ... done
[17:44:47.312] run() for ‘MulticoreFuture’ ... done
[17:44:47.312] Created future:
[17:44:47.312] plan(): Setting new future strategy stack:
[17:44:47.312] List of future strategies:
[17:44:47.312] 1. sequential:
[17:44:47.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.312]    - tweaked: FALSE
[17:44:47.312]    - call: NULL
[17:44:47.313] plan(): nbrOfWorkers() = 1
[17:44:47.315] plan(): Setting new future strategy stack:
[17:44:47.316] List of future strategies:
[17:44:47.316] 1. multicore:
[17:44:47.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.316]    - tweaked: FALSE
[17:44:47.316]    - call: plan(strategy)
[17:44:47.321] plan(): nbrOfWorkers() = 2
[17:44:47.312] MulticoreFuture:
[17:44:47.312] Label: ‘future_.mapply-1’
[17:44:47.312] Expression:
[17:44:47.312] {
[17:44:47.312]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.312]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.312]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.312]         on.exit(options(oopts), add = TRUE)
[17:44:47.312]     }
[17:44:47.312]     {
[17:44:47.312]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.312]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.312]         do.call(mapply, args = args)
[17:44:47.312]     }
[17:44:47.312] }
[17:44:47.312] Lazy evaluation: FALSE
[17:44:47.312] Asynchronous evaluation: TRUE
[17:44:47.312] Local evaluation: TRUE
[17:44:47.312] Environment: R_GlobalEnv
[17:44:47.312] Capture standard output: TRUE
[17:44:47.312] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.312] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.312] Packages: <none>
[17:44:47.312] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.312] Resolved: TRUE
[17:44:47.312] Value: <not collected>
[17:44:47.312] Conditions captured: <none>
[17:44:47.312] Early signaling: FALSE
[17:44:47.312] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.312] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.322] Chunk #1 of 2 ... DONE
[17:44:47.322] Chunk #2 of 2 ...
[17:44:47.322]  - Finding globals in '...' for chunk #2 ...
[17:44:47.322] getGlobalsAndPackages() ...
[17:44:47.322] Searching for globals...
[17:44:47.323] 
[17:44:47.323] Searching for globals ... DONE
[17:44:47.323] - globals: [0] <none>
[17:44:47.324] getGlobalsAndPackages() ... DONE
[17:44:47.324]    + additional globals found: [n=0] 
[17:44:47.324]    + additional namespaces needed: [n=0] 
[17:44:47.324]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:47.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.324]  - seeds: <none>
[17:44:47.324]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.325] getGlobalsAndPackages() ...
[17:44:47.325] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.325] Resolving globals: FALSE
[17:44:47.326] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:47.327] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.327] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.327] 
[17:44:47.327] getGlobalsAndPackages() ... DONE
[17:44:47.328] run() for ‘Future’ ...
[17:44:47.328] - state: ‘created’
[17:44:47.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.333]   - Field: ‘label’
[17:44:47.333]   - Field: ‘local’
[17:44:47.334]   - Field: ‘owner’
[17:44:47.334]   - Field: ‘envir’
[17:44:47.334]   - Field: ‘workers’
[17:44:47.334]   - Field: ‘packages’
[17:44:47.334]   - Field: ‘gc’
[17:44:47.334]   - Field: ‘job’
[17:44:47.335]   - Field: ‘conditions’
[17:44:47.335]   - Field: ‘expr’
[17:44:47.335]   - Field: ‘uuid’
[17:44:47.335]   - Field: ‘seed’
[17:44:47.335]   - Field: ‘version’
[17:44:47.335]   - Field: ‘result’
[17:44:47.339]   - Field: ‘asynchronous’
[17:44:47.339]   - Field: ‘calls’
[17:44:47.340]   - Field: ‘globals’
[17:44:47.340]   - Field: ‘stdout’
[17:44:47.340]   - Field: ‘earlySignal’
[17:44:47.340]   - Field: ‘lazy’
[17:44:47.341]   - Field: ‘state’
[17:44:47.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.341] - Launch lazy future ...
[17:44:47.342] Packages needed by the future expression (n = 0): <none>
[17:44:47.342] Packages needed by future strategies (n = 0): <none>
[17:44:47.343] {
[17:44:47.343]     {
[17:44:47.343]         {
[17:44:47.343]             ...future.startTime <- base::Sys.time()
[17:44:47.343]             {
[17:44:47.343]                 {
[17:44:47.343]                   {
[17:44:47.343]                     {
[17:44:47.343]                       base::local({
[17:44:47.343]                         has_future <- base::requireNamespace("future", 
[17:44:47.343]                           quietly = TRUE)
[17:44:47.343]                         if (has_future) {
[17:44:47.343]                           ns <- base::getNamespace("future")
[17:44:47.343]                           version <- ns[[".package"]][["version"]]
[17:44:47.343]                           if (is.null(version)) 
[17:44:47.343]                             version <- utils::packageVersion("future")
[17:44:47.343]                         }
[17:44:47.343]                         else {
[17:44:47.343]                           version <- NULL
[17:44:47.343]                         }
[17:44:47.343]                         if (!has_future || version < "1.8.0") {
[17:44:47.343]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.343]                             "", base::R.version$version.string), 
[17:44:47.343]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.343]                               "release", "version")], collapse = " "), 
[17:44:47.343]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.343]                             info)
[17:44:47.343]                           info <- base::paste(info, collapse = "; ")
[17:44:47.343]                           if (!has_future) {
[17:44:47.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.343]                               info)
[17:44:47.343]                           }
[17:44:47.343]                           else {
[17:44:47.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.343]                               info, version)
[17:44:47.343]                           }
[17:44:47.343]                           base::stop(msg)
[17:44:47.343]                         }
[17:44:47.343]                       })
[17:44:47.343]                     }
[17:44:47.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.343]                     base::options(mc.cores = 1L)
[17:44:47.343]                   }
[17:44:47.343]                   ...future.strategy.old <- future::plan("list")
[17:44:47.343]                   options(future.plan = NULL)
[17:44:47.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.343]                 }
[17:44:47.343]                 ...future.workdir <- getwd()
[17:44:47.343]             }
[17:44:47.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.343]         }
[17:44:47.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.343]             base::names(...future.oldOptions))
[17:44:47.343]     }
[17:44:47.343]     if (FALSE) {
[17:44:47.343]     }
[17:44:47.343]     else {
[17:44:47.343]         if (TRUE) {
[17:44:47.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.343]                 open = "w")
[17:44:47.343]         }
[17:44:47.343]         else {
[17:44:47.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.343]         }
[17:44:47.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.343]             base::sink(type = "output", split = FALSE)
[17:44:47.343]             base::close(...future.stdout)
[17:44:47.343]         }, add = TRUE)
[17:44:47.343]     }
[17:44:47.343]     ...future.frame <- base::sys.nframe()
[17:44:47.343]     ...future.conditions <- base::list()
[17:44:47.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.343]     if (FALSE) {
[17:44:47.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.343]     }
[17:44:47.343]     ...future.result <- base::tryCatch({
[17:44:47.343]         base::withCallingHandlers({
[17:44:47.343]             ...future.value <- base::withVisible(base::local({
[17:44:47.343]                 withCallingHandlers({
[17:44:47.343]                   {
[17:44:47.343]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.343]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.343]                       ...future.globals.maxSize)) {
[17:44:47.343]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.343]                       on.exit(options(oopts), add = TRUE)
[17:44:47.343]                     }
[17:44:47.343]                     {
[17:44:47.343]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.343]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.343]                         USE.NAMES = FALSE)
[17:44:47.343]                       do.call(mapply, args = args)
[17:44:47.343]                     }
[17:44:47.343]                   }
[17:44:47.343]                 }, immediateCondition = function(cond) {
[17:44:47.343]                   save_rds <- function (object, pathname, ...) 
[17:44:47.343]                   {
[17:44:47.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.343]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.343]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.343]                         fi_tmp[["mtime"]])
[17:44:47.343]                     }
[17:44:47.343]                     tryCatch({
[17:44:47.343]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.343]                     }, error = function(ex) {
[17:44:47.343]                       msg <- conditionMessage(ex)
[17:44:47.343]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.343]                         fi_tmp[["mtime"]], msg)
[17:44:47.343]                       ex$message <- msg
[17:44:47.343]                       stop(ex)
[17:44:47.343]                     })
[17:44:47.343]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.343]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.343]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.343]                       fi <- file.info(pathname)
[17:44:47.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.343]                         fi[["size"]], fi[["mtime"]])
[17:44:47.343]                       stop(msg)
[17:44:47.343]                     }
[17:44:47.343]                     invisible(pathname)
[17:44:47.343]                   }
[17:44:47.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.343]                     rootPath = tempdir()) 
[17:44:47.343]                   {
[17:44:47.343]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.343]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.343]                       tmpdir = path, fileext = ".rds")
[17:44:47.343]                     save_rds(obj, file)
[17:44:47.343]                   }
[17:44:47.343]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.343]                   {
[17:44:47.343]                     inherits <- base::inherits
[17:44:47.343]                     invokeRestart <- base::invokeRestart
[17:44:47.343]                     is.null <- base::is.null
[17:44:47.343]                     muffled <- FALSE
[17:44:47.343]                     if (inherits(cond, "message")) {
[17:44:47.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.343]                       if (muffled) 
[17:44:47.343]                         invokeRestart("muffleMessage")
[17:44:47.343]                     }
[17:44:47.343]                     else if (inherits(cond, "warning")) {
[17:44:47.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.343]                       if (muffled) 
[17:44:47.343]                         invokeRestart("muffleWarning")
[17:44:47.343]                     }
[17:44:47.343]                     else if (inherits(cond, "condition")) {
[17:44:47.343]                       if (!is.null(pattern)) {
[17:44:47.343]                         computeRestarts <- base::computeRestarts
[17:44:47.343]                         grepl <- base::grepl
[17:44:47.343]                         restarts <- computeRestarts(cond)
[17:44:47.343]                         for (restart in restarts) {
[17:44:47.343]                           name <- restart$name
[17:44:47.343]                           if (is.null(name)) 
[17:44:47.343]                             next
[17:44:47.343]                           if (!grepl(pattern, name)) 
[17:44:47.343]                             next
[17:44:47.343]                           invokeRestart(restart)
[17:44:47.343]                           muffled <- TRUE
[17:44:47.343]                           break
[17:44:47.343]                         }
[17:44:47.343]                       }
[17:44:47.343]                     }
[17:44:47.343]                     invisible(muffled)
[17:44:47.343]                   }
[17:44:47.343]                   muffleCondition(cond)
[17:44:47.343]                 })
[17:44:47.343]             }))
[17:44:47.343]             future::FutureResult(value = ...future.value$value, 
[17:44:47.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.343]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.343]                     ...future.globalenv.names))
[17:44:47.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.343]         }, condition = base::local({
[17:44:47.343]             c <- base::c
[17:44:47.343]             inherits <- base::inherits
[17:44:47.343]             invokeRestart <- base::invokeRestart
[17:44:47.343]             length <- base::length
[17:44:47.343]             list <- base::list
[17:44:47.343]             seq.int <- base::seq.int
[17:44:47.343]             signalCondition <- base::signalCondition
[17:44:47.343]             sys.calls <- base::sys.calls
[17:44:47.343]             `[[` <- base::`[[`
[17:44:47.343]             `+` <- base::`+`
[17:44:47.343]             `<<-` <- base::`<<-`
[17:44:47.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.343]                   3L)]
[17:44:47.343]             }
[17:44:47.343]             function(cond) {
[17:44:47.343]                 is_error <- inherits(cond, "error")
[17:44:47.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.343]                   NULL)
[17:44:47.343]                 if (is_error) {
[17:44:47.343]                   sessionInformation <- function() {
[17:44:47.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.343]                       search = base::search(), system = base::Sys.info())
[17:44:47.343]                   }
[17:44:47.343]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.343]                     cond$call), session = sessionInformation(), 
[17:44:47.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.343]                   signalCondition(cond)
[17:44:47.343]                 }
[17:44:47.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.343]                 "immediateCondition"))) {
[17:44:47.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.343]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.343]                   if (TRUE && !signal) {
[17:44:47.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.343]                     {
[17:44:47.343]                       inherits <- base::inherits
[17:44:47.343]                       invokeRestart <- base::invokeRestart
[17:44:47.343]                       is.null <- base::is.null
[17:44:47.343]                       muffled <- FALSE
[17:44:47.343]                       if (inherits(cond, "message")) {
[17:44:47.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.343]                         if (muffled) 
[17:44:47.343]                           invokeRestart("muffleMessage")
[17:44:47.343]                       }
[17:44:47.343]                       else if (inherits(cond, "warning")) {
[17:44:47.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.343]                         if (muffled) 
[17:44:47.343]                           invokeRestart("muffleWarning")
[17:44:47.343]                       }
[17:44:47.343]                       else if (inherits(cond, "condition")) {
[17:44:47.343]                         if (!is.null(pattern)) {
[17:44:47.343]                           computeRestarts <- base::computeRestarts
[17:44:47.343]                           grepl <- base::grepl
[17:44:47.343]                           restarts <- computeRestarts(cond)
[17:44:47.343]                           for (restart in restarts) {
[17:44:47.343]                             name <- restart$name
[17:44:47.343]                             if (is.null(name)) 
[17:44:47.343]                               next
[17:44:47.343]                             if (!grepl(pattern, name)) 
[17:44:47.343]                               next
[17:44:47.343]                             invokeRestart(restart)
[17:44:47.343]                             muffled <- TRUE
[17:44:47.343]                             break
[17:44:47.343]                           }
[17:44:47.343]                         }
[17:44:47.343]                       }
[17:44:47.343]                       invisible(muffled)
[17:44:47.343]                     }
[17:44:47.343]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.343]                   }
[17:44:47.343]                 }
[17:44:47.343]                 else {
[17:44:47.343]                   if (TRUE) {
[17:44:47.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.343]                     {
[17:44:47.343]                       inherits <- base::inherits
[17:44:47.343]                       invokeRestart <- base::invokeRestart
[17:44:47.343]                       is.null <- base::is.null
[17:44:47.343]                       muffled <- FALSE
[17:44:47.343]                       if (inherits(cond, "message")) {
[17:44:47.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.343]                         if (muffled) 
[17:44:47.343]                           invokeRestart("muffleMessage")
[17:44:47.343]                       }
[17:44:47.343]                       else if (inherits(cond, "warning")) {
[17:44:47.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.343]                         if (muffled) 
[17:44:47.343]                           invokeRestart("muffleWarning")
[17:44:47.343]                       }
[17:44:47.343]                       else if (inherits(cond, "condition")) {
[17:44:47.343]                         if (!is.null(pattern)) {
[17:44:47.343]                           computeRestarts <- base::computeRestarts
[17:44:47.343]                           grepl <- base::grepl
[17:44:47.343]                           restarts <- computeRestarts(cond)
[17:44:47.343]                           for (restart in restarts) {
[17:44:47.343]                             name <- restart$name
[17:44:47.343]                             if (is.null(name)) 
[17:44:47.343]                               next
[17:44:47.343]                             if (!grepl(pattern, name)) 
[17:44:47.343]                               next
[17:44:47.343]                             invokeRestart(restart)
[17:44:47.343]                             muffled <- TRUE
[17:44:47.343]                             break
[17:44:47.343]                           }
[17:44:47.343]                         }
[17:44:47.343]                       }
[17:44:47.343]                       invisible(muffled)
[17:44:47.343]                     }
[17:44:47.343]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.343]                   }
[17:44:47.343]                 }
[17:44:47.343]             }
[17:44:47.343]         }))
[17:44:47.343]     }, error = function(ex) {
[17:44:47.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.343]                 ...future.rng), started = ...future.startTime, 
[17:44:47.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.343]             version = "1.8"), class = "FutureResult")
[17:44:47.343]     }, finally = {
[17:44:47.343]         if (!identical(...future.workdir, getwd())) 
[17:44:47.343]             setwd(...future.workdir)
[17:44:47.343]         {
[17:44:47.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.343]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.343]             }
[17:44:47.343]             base::options(...future.oldOptions)
[17:44:47.343]             if (.Platform$OS.type == "windows") {
[17:44:47.343]                 old_names <- names(...future.oldEnvVars)
[17:44:47.343]                 envs <- base::Sys.getenv()
[17:44:47.343]                 names <- names(envs)
[17:44:47.343]                 common <- intersect(names, old_names)
[17:44:47.343]                 added <- setdiff(names, old_names)
[17:44:47.343]                 removed <- setdiff(old_names, names)
[17:44:47.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.343]                   envs[common]]
[17:44:47.343]                 NAMES <- toupper(changed)
[17:44:47.343]                 args <- list()
[17:44:47.343]                 for (kk in seq_along(NAMES)) {
[17:44:47.343]                   name <- changed[[kk]]
[17:44:47.343]                   NAME <- NAMES[[kk]]
[17:44:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.343]                     next
[17:44:47.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.343]                 }
[17:44:47.343]                 NAMES <- toupper(added)
[17:44:47.343]                 for (kk in seq_along(NAMES)) {
[17:44:47.343]                   name <- added[[kk]]
[17:44:47.343]                   NAME <- NAMES[[kk]]
[17:44:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.343]                     next
[17:44:47.343]                   args[[name]] <- ""
[17:44:47.343]                 }
[17:44:47.343]                 NAMES <- toupper(removed)
[17:44:47.343]                 for (kk in seq_along(NAMES)) {
[17:44:47.343]                   name <- removed[[kk]]
[17:44:47.343]                   NAME <- NAMES[[kk]]
[17:44:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.343]                     next
[17:44:47.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.343]                 }
[17:44:47.343]                 if (length(args) > 0) 
[17:44:47.343]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.343]             }
[17:44:47.343]             else {
[17:44:47.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.343]             }
[17:44:47.343]             {
[17:44:47.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.343]                   0L) {
[17:44:47.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.343]                   base::options(opts)
[17:44:47.343]                 }
[17:44:47.343]                 {
[17:44:47.343]                   {
[17:44:47.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.343]                     NULL
[17:44:47.343]                   }
[17:44:47.343]                   options(future.plan = NULL)
[17:44:47.343]                   if (is.na(NA_character_)) 
[17:44:47.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.343]                     .init = FALSE)
[17:44:47.343]                 }
[17:44:47.343]             }
[17:44:47.343]         }
[17:44:47.343]     })
[17:44:47.343]     if (TRUE) {
[17:44:47.343]         base::sink(type = "output", split = FALSE)
[17:44:47.343]         if (TRUE) {
[17:44:47.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.343]         }
[17:44:47.343]         else {
[17:44:47.343]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.343]         }
[17:44:47.343]         base::close(...future.stdout)
[17:44:47.343]         ...future.stdout <- NULL
[17:44:47.343]     }
[17:44:47.343]     ...future.result$conditions <- ...future.conditions
[17:44:47.343]     ...future.result$finished <- base::Sys.time()
[17:44:47.343]     ...future.result
[17:44:47.343] }
[17:44:47.346] assign_globals() ...
[17:44:47.346] List of 5
[17:44:47.346]  $ ...future.FUN            :function (C, k)  
[17:44:47.346]  $ MoreArgs                 : list()
[17:44:47.346]  $ ...future.elements_ii    :List of 2
[17:44:47.346]   ..$ :List of 3
[17:44:47.346]   .. ..$ : chr "C"
[17:44:47.346]   .. ..$ : chr "D"
[17:44:47.346]   .. ..$ : chr "E"
[17:44:47.346]   ..$ :List of 3
[17:44:47.346]   .. ..$ : int 3
[17:44:47.346]   .. ..$ : int 2
[17:44:47.346]   .. ..$ : int 1
[17:44:47.346]  $ ...future.seeds_ii       : NULL
[17:44:47.346]  $ ...future.globals.maxSize: NULL
[17:44:47.346]  - attr(*, "where")=List of 5
[17:44:47.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.346]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.346]  - attr(*, "resolved")= logi FALSE
[17:44:47.346]  - attr(*, "total_size")= num 3824
[17:44:47.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.346]  - attr(*, "already-done")= logi TRUE
[17:44:47.356] - reassign environment for ‘...future.FUN’
[17:44:47.356] - copied ‘...future.FUN’ to environment
[17:44:47.356] - copied ‘MoreArgs’ to environment
[17:44:47.357] - copied ‘...future.elements_ii’ to environment
[17:44:47.357] - copied ‘...future.seeds_ii’ to environment
[17:44:47.357] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.357] assign_globals() ... done
[17:44:47.357] requestCore(): workers = 2
[17:44:47.359] MulticoreFuture started
[17:44:47.360] - Launch lazy future ... done
[17:44:47.360] run() for ‘MulticoreFuture’ ... done
[17:44:47.360] Created future:
[17:44:47.360] plan(): Setting new future strategy stack:
[17:44:47.361] List of future strategies:
[17:44:47.361] 1. sequential:
[17:44:47.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.361]    - tweaked: FALSE
[17:44:47.361]    - call: NULL
[17:44:47.362] plan(): nbrOfWorkers() = 1
[17:44:47.364] plan(): Setting new future strategy stack:
[17:44:47.364] List of future strategies:
[17:44:47.364] 1. multicore:
[17:44:47.364]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.364]    - tweaked: FALSE
[17:44:47.364]    - call: plan(strategy)
[17:44:47.369] plan(): nbrOfWorkers() = 2
[17:44:47.360] MulticoreFuture:
[17:44:47.360] Label: ‘future_.mapply-2’
[17:44:47.360] Expression:
[17:44:47.360] {
[17:44:47.360]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.360]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.360]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.360]         on.exit(options(oopts), add = TRUE)
[17:44:47.360]     }
[17:44:47.360]     {
[17:44:47.360]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.360]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.360]         do.call(mapply, args = args)
[17:44:47.360]     }
[17:44:47.360] }
[17:44:47.360] Lazy evaluation: FALSE
[17:44:47.360] Asynchronous evaluation: TRUE
[17:44:47.360] Local evaluation: TRUE
[17:44:47.360] Environment: R_GlobalEnv
[17:44:47.360] Capture standard output: TRUE
[17:44:47.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.360] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.360] Packages: <none>
[17:44:47.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.360] Resolved: TRUE
[17:44:47.360] Value: <not collected>
[17:44:47.360] Conditions captured: <none>
[17:44:47.360] Early signaling: FALSE
[17:44:47.360] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.360] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.370] Chunk #2 of 2 ... DONE
[17:44:47.370] Launching 2 futures (chunks) ... DONE
[17:44:47.371] Resolving 2 futures (chunks) ...
[17:44:47.371] resolve() on list ...
[17:44:47.371]  recursive: 0
[17:44:47.371]  length: 2
[17:44:47.371] 
[17:44:47.372] Future #1
[17:44:47.372] result() for MulticoreFuture ...
[17:44:47.373] result() for MulticoreFuture ...
[17:44:47.373] result() for MulticoreFuture ... done
[17:44:47.373] result() for MulticoreFuture ... done
[17:44:47.373] result() for MulticoreFuture ...
[17:44:47.373] result() for MulticoreFuture ... done
[17:44:47.373] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.373] - nx: 2
[17:44:47.374] - relay: TRUE
[17:44:47.374] - stdout: TRUE
[17:44:47.374] - signal: TRUE
[17:44:47.374] - resignal: FALSE
[17:44:47.374] - force: TRUE
[17:44:47.374] - relayed: [n=2] FALSE, FALSE
[17:44:47.374] - queued futures: [n=2] FALSE, FALSE
[17:44:47.375]  - until=1
[17:44:47.375]  - relaying element #1
[17:44:47.375] result() for MulticoreFuture ...
[17:44:47.375] result() for MulticoreFuture ... done
[17:44:47.375] result() for MulticoreFuture ...
[17:44:47.375] result() for MulticoreFuture ... done
[17:44:47.376] result() for MulticoreFuture ...
[17:44:47.376] result() for MulticoreFuture ... done
[17:44:47.376] result() for MulticoreFuture ...
[17:44:47.376] result() for MulticoreFuture ... done
[17:44:47.376] - relayed: [n=2] TRUE, FALSE
[17:44:47.376] - queued futures: [n=2] TRUE, FALSE
[17:44:47.376] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.377]  length: 1 (resolved future 1)
[17:44:47.377] Future #2
[17:44:47.377] result() for MulticoreFuture ...
[17:44:47.378] result() for MulticoreFuture ...
[17:44:47.378] result() for MulticoreFuture ... done
[17:44:47.378] result() for MulticoreFuture ... done
[17:44:47.378] result() for MulticoreFuture ...
[17:44:47.379] result() for MulticoreFuture ... done
[17:44:47.379] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.379] - nx: 2
[17:44:47.379] - relay: TRUE
[17:44:47.379] - stdout: TRUE
[17:44:47.379] - signal: TRUE
[17:44:47.379] - resignal: FALSE
[17:44:47.379] - force: TRUE
[17:44:47.380] - relayed: [n=2] TRUE, FALSE
[17:44:47.380] - queued futures: [n=2] TRUE, FALSE
[17:44:47.380]  - until=2
[17:44:47.380]  - relaying element #2
[17:44:47.380] result() for MulticoreFuture ...
[17:44:47.380] result() for MulticoreFuture ... done
[17:44:47.380] result() for MulticoreFuture ...
[17:44:47.380] result() for MulticoreFuture ... done
[17:44:47.381] result() for MulticoreFuture ...
[17:44:47.381] result() for MulticoreFuture ... done
[17:44:47.381] result() for MulticoreFuture ...
[17:44:47.381] result() for MulticoreFuture ... done
[17:44:47.381] - relayed: [n=2] TRUE, TRUE
[17:44:47.381] - queued futures: [n=2] TRUE, TRUE
[17:44:47.381] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.381]  length: 0 (resolved future 2)
[17:44:47.382] Relaying remaining futures
[17:44:47.382] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.382] - nx: 2
[17:44:47.382] - relay: TRUE
[17:44:47.382] - stdout: TRUE
[17:44:47.382] - signal: TRUE
[17:44:47.382] - resignal: FALSE
[17:44:47.382] - force: TRUE
[17:44:47.382] - relayed: [n=2] TRUE, TRUE
[17:44:47.382] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:47.383] - relayed: [n=2] TRUE, TRUE
[17:44:47.383] - queued futures: [n=2] TRUE, TRUE
[17:44:47.383] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.383] resolve() on list ... DONE
[17:44:47.383] result() for MulticoreFuture ...
[17:44:47.383] result() for MulticoreFuture ... done
[17:44:47.383] result() for MulticoreFuture ...
[17:44:47.383] result() for MulticoreFuture ... done
[17:44:47.384] result() for MulticoreFuture ...
[17:44:47.384] result() for MulticoreFuture ... done
[17:44:47.384] result() for MulticoreFuture ...
[17:44:47.384] result() for MulticoreFuture ... done
[17:44:47.384]  - Number of value chunks collected: 2
[17:44:47.384] Resolving 2 futures (chunks) ... DONE
[17:44:47.387] Reducing values from 2 chunks ...
[17:44:47.387]  - Number of values collected after concatenation: 5
[17:44:47.387]  - Number of values expected: 5
[17:44:47.388] Reducing values from 2 chunks ... DONE
[17:44:47.388] future_mapply() ... DONE
[17:44:47.388] future_mapply() ...
[17:44:47.393] Number of chunks: 3
[17:44:47.393] Index remapping (attribute 'ordering'): [n = 5] 1, 4, 5, 2, 3
[17:44:47.393] getGlobalsAndPackagesXApply() ...
[17:44:47.393]  - future.globals: TRUE
[17:44:47.393] getGlobalsAndPackages() ...
[17:44:47.393] Searching for globals...
[17:44:47.395] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:47.396] Searching for globals ... DONE
[17:44:47.396] Resolving globals: FALSE
[17:44:47.396] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:47.397] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:47.397] - globals: [1] ‘FUN’
[17:44:47.397] 
[17:44:47.397] getGlobalsAndPackages() ... DONE
[17:44:47.397]  - globals found/used: [n=1] ‘FUN’
[17:44:47.397]  - needed namespaces: [n=0] 
[17:44:47.397] Finding globals ... DONE
[17:44:47.398] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.398] List of 2
[17:44:47.398]  $ ...future.FUN:function (C, k)  
[17:44:47.398]  $ MoreArgs     : NULL
[17:44:47.398]  - attr(*, "where")=List of 2
[17:44:47.398]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.398]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.398]  - attr(*, "resolved")= logi FALSE
[17:44:47.398]  - attr(*, "total_size")= num NA
[17:44:47.401] Packages to be attached in all futures: [n=0] 
[17:44:47.401] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.401] Number of futures (= number of chunks): 3
[17:44:47.401] Launching 3 futures (chunks) ...
[17:44:47.401] Chunk #1 of 3 ...
[17:44:47.401]  - Finding globals in '...' for chunk #1 ...
[17:44:47.402] getGlobalsAndPackages() ...
[17:44:47.402] Searching for globals...
[17:44:47.402] 
[17:44:47.402] Searching for globals ... DONE
[17:44:47.402] - globals: [0] <none>
[17:44:47.402] getGlobalsAndPackages() ... DONE
[17:44:47.402]    + additional globals found: [n=0] 
[17:44:47.402]    + additional namespaces needed: [n=0] 
[17:44:47.403]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.403]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:47.403]  - seeds: <none>
[17:44:47.403]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.403] getGlobalsAndPackages() ...
[17:44:47.403] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.403] Resolving globals: FALSE
[17:44:47.404] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.404] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.404] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.404] 
[17:44:47.404] getGlobalsAndPackages() ... DONE
[17:44:47.405] run() for ‘Future’ ...
[17:44:47.405] - state: ‘created’
[17:44:47.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.409]   - Field: ‘label’
[17:44:47.409]   - Field: ‘local’
[17:44:47.409]   - Field: ‘owner’
[17:44:47.409]   - Field: ‘envir’
[17:44:47.409]   - Field: ‘workers’
[17:44:47.409]   - Field: ‘packages’
[17:44:47.409]   - Field: ‘gc’
[17:44:47.409]   - Field: ‘job’
[17:44:47.410]   - Field: ‘conditions’
[17:44:47.410]   - Field: ‘expr’
[17:44:47.410]   - Field: ‘uuid’
[17:44:47.410]   - Field: ‘seed’
[17:44:47.410]   - Field: ‘version’
[17:44:47.410]   - Field: ‘result’
[17:44:47.410]   - Field: ‘asynchronous’
[17:44:47.410]   - Field: ‘calls’
[17:44:47.410]   - Field: ‘globals’
[17:44:47.410]   - Field: ‘stdout’
[17:44:47.410]   - Field: ‘earlySignal’
[17:44:47.411]   - Field: ‘lazy’
[17:44:47.411]   - Field: ‘state’
[17:44:47.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.411] - Launch lazy future ...
[17:44:47.411] Packages needed by the future expression (n = 0): <none>
[17:44:47.411] Packages needed by future strategies (n = 0): <none>
[17:44:47.412] {
[17:44:47.412]     {
[17:44:47.412]         {
[17:44:47.412]             ...future.startTime <- base::Sys.time()
[17:44:47.412]             {
[17:44:47.412]                 {
[17:44:47.412]                   {
[17:44:47.412]                     {
[17:44:47.412]                       base::local({
[17:44:47.412]                         has_future <- base::requireNamespace("future", 
[17:44:47.412]                           quietly = TRUE)
[17:44:47.412]                         if (has_future) {
[17:44:47.412]                           ns <- base::getNamespace("future")
[17:44:47.412]                           version <- ns[[".package"]][["version"]]
[17:44:47.412]                           if (is.null(version)) 
[17:44:47.412]                             version <- utils::packageVersion("future")
[17:44:47.412]                         }
[17:44:47.412]                         else {
[17:44:47.412]                           version <- NULL
[17:44:47.412]                         }
[17:44:47.412]                         if (!has_future || version < "1.8.0") {
[17:44:47.412]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.412]                             "", base::R.version$version.string), 
[17:44:47.412]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.412]                               "release", "version")], collapse = " "), 
[17:44:47.412]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.412]                             info)
[17:44:47.412]                           info <- base::paste(info, collapse = "; ")
[17:44:47.412]                           if (!has_future) {
[17:44:47.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.412]                               info)
[17:44:47.412]                           }
[17:44:47.412]                           else {
[17:44:47.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.412]                               info, version)
[17:44:47.412]                           }
[17:44:47.412]                           base::stop(msg)
[17:44:47.412]                         }
[17:44:47.412]                       })
[17:44:47.412]                     }
[17:44:47.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.412]                     base::options(mc.cores = 1L)
[17:44:47.412]                   }
[17:44:47.412]                   ...future.strategy.old <- future::plan("list")
[17:44:47.412]                   options(future.plan = NULL)
[17:44:47.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.412]                 }
[17:44:47.412]                 ...future.workdir <- getwd()
[17:44:47.412]             }
[17:44:47.412]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.412]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.412]         }
[17:44:47.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.412]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:47.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.412]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.412]             base::names(...future.oldOptions))
[17:44:47.412]     }
[17:44:47.412]     if (FALSE) {
[17:44:47.412]     }
[17:44:47.412]     else {
[17:44:47.412]         if (TRUE) {
[17:44:47.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.412]                 open = "w")
[17:44:47.412]         }
[17:44:47.412]         else {
[17:44:47.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.412]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.412]         }
[17:44:47.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.412]             base::sink(type = "output", split = FALSE)
[17:44:47.412]             base::close(...future.stdout)
[17:44:47.412]         }, add = TRUE)
[17:44:47.412]     }
[17:44:47.412]     ...future.frame <- base::sys.nframe()
[17:44:47.412]     ...future.conditions <- base::list()
[17:44:47.412]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.412]     if (FALSE) {
[17:44:47.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.412]     }
[17:44:47.412]     ...future.result <- base::tryCatch({
[17:44:47.412]         base::withCallingHandlers({
[17:44:47.412]             ...future.value <- base::withVisible(base::local({
[17:44:47.412]                 withCallingHandlers({
[17:44:47.412]                   {
[17:44:47.412]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.412]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.412]                       ...future.globals.maxSize)) {
[17:44:47.412]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.412]                       on.exit(options(oopts), add = TRUE)
[17:44:47.412]                     }
[17:44:47.412]                     {
[17:44:47.412]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.412]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.412]                         USE.NAMES = FALSE)
[17:44:47.412]                       do.call(mapply, args = args)
[17:44:47.412]                     }
[17:44:47.412]                   }
[17:44:47.412]                 }, immediateCondition = function(cond) {
[17:44:47.412]                   save_rds <- function (object, pathname, ...) 
[17:44:47.412]                   {
[17:44:47.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.412]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.412]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.412]                         fi_tmp[["mtime"]])
[17:44:47.412]                     }
[17:44:47.412]                     tryCatch({
[17:44:47.412]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.412]                     }, error = function(ex) {
[17:44:47.412]                       msg <- conditionMessage(ex)
[17:44:47.412]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.412]                         fi_tmp[["mtime"]], msg)
[17:44:47.412]                       ex$message <- msg
[17:44:47.412]                       stop(ex)
[17:44:47.412]                     })
[17:44:47.412]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.412]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.412]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.412]                       fi <- file.info(pathname)
[17:44:47.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.412]                         fi[["size"]], fi[["mtime"]])
[17:44:47.412]                       stop(msg)
[17:44:47.412]                     }
[17:44:47.412]                     invisible(pathname)
[17:44:47.412]                   }
[17:44:47.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.412]                     rootPath = tempdir()) 
[17:44:47.412]                   {
[17:44:47.412]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.412]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.412]                       tmpdir = path, fileext = ".rds")
[17:44:47.412]                     save_rds(obj, file)
[17:44:47.412]                   }
[17:44:47.412]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.412]                   {
[17:44:47.412]                     inherits <- base::inherits
[17:44:47.412]                     invokeRestart <- base::invokeRestart
[17:44:47.412]                     is.null <- base::is.null
[17:44:47.412]                     muffled <- FALSE
[17:44:47.412]                     if (inherits(cond, "message")) {
[17:44:47.412]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.412]                       if (muffled) 
[17:44:47.412]                         invokeRestart("muffleMessage")
[17:44:47.412]                     }
[17:44:47.412]                     else if (inherits(cond, "warning")) {
[17:44:47.412]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.412]                       if (muffled) 
[17:44:47.412]                         invokeRestart("muffleWarning")
[17:44:47.412]                     }
[17:44:47.412]                     else if (inherits(cond, "condition")) {
[17:44:47.412]                       if (!is.null(pattern)) {
[17:44:47.412]                         computeRestarts <- base::computeRestarts
[17:44:47.412]                         grepl <- base::grepl
[17:44:47.412]                         restarts <- computeRestarts(cond)
[17:44:47.412]                         for (restart in restarts) {
[17:44:47.412]                           name <- restart$name
[17:44:47.412]                           if (is.null(name)) 
[17:44:47.412]                             next
[17:44:47.412]                           if (!grepl(pattern, name)) 
[17:44:47.412]                             next
[17:44:47.412]                           invokeRestart(restart)
[17:44:47.412]                           muffled <- TRUE
[17:44:47.412]                           break
[17:44:47.412]                         }
[17:44:47.412]                       }
[17:44:47.412]                     }
[17:44:47.412]                     invisible(muffled)
[17:44:47.412]                   }
[17:44:47.412]                   muffleCondition(cond)
[17:44:47.412]                 })
[17:44:47.412]             }))
[17:44:47.412]             future::FutureResult(value = ...future.value$value, 
[17:44:47.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.412]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.412]                     ...future.globalenv.names))
[17:44:47.412]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.412]         }, condition = base::local({
[17:44:47.412]             c <- base::c
[17:44:47.412]             inherits <- base::inherits
[17:44:47.412]             invokeRestart <- base::invokeRestart
[17:44:47.412]             length <- base::length
[17:44:47.412]             list <- base::list
[17:44:47.412]             seq.int <- base::seq.int
[17:44:47.412]             signalCondition <- base::signalCondition
[17:44:47.412]             sys.calls <- base::sys.calls
[17:44:47.412]             `[[` <- base::`[[`
[17:44:47.412]             `+` <- base::`+`
[17:44:47.412]             `<<-` <- base::`<<-`
[17:44:47.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.412]                   3L)]
[17:44:47.412]             }
[17:44:47.412]             function(cond) {
[17:44:47.412]                 is_error <- inherits(cond, "error")
[17:44:47.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.412]                   NULL)
[17:44:47.412]                 if (is_error) {
[17:44:47.412]                   sessionInformation <- function() {
[17:44:47.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.412]                       search = base::search(), system = base::Sys.info())
[17:44:47.412]                   }
[17:44:47.412]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.412]                     cond$call), session = sessionInformation(), 
[17:44:47.412]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.412]                   signalCondition(cond)
[17:44:47.412]                 }
[17:44:47.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.412]                 "immediateCondition"))) {
[17:44:47.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.412]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.412]                   if (TRUE && !signal) {
[17:44:47.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.412]                     {
[17:44:47.412]                       inherits <- base::inherits
[17:44:47.412]                       invokeRestart <- base::invokeRestart
[17:44:47.412]                       is.null <- base::is.null
[17:44:47.412]                       muffled <- FALSE
[17:44:47.412]                       if (inherits(cond, "message")) {
[17:44:47.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.412]                         if (muffled) 
[17:44:47.412]                           invokeRestart("muffleMessage")
[17:44:47.412]                       }
[17:44:47.412]                       else if (inherits(cond, "warning")) {
[17:44:47.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.412]                         if (muffled) 
[17:44:47.412]                           invokeRestart("muffleWarning")
[17:44:47.412]                       }
[17:44:47.412]                       else if (inherits(cond, "condition")) {
[17:44:47.412]                         if (!is.null(pattern)) {
[17:44:47.412]                           computeRestarts <- base::computeRestarts
[17:44:47.412]                           grepl <- base::grepl
[17:44:47.412]                           restarts <- computeRestarts(cond)
[17:44:47.412]                           for (restart in restarts) {
[17:44:47.412]                             name <- restart$name
[17:44:47.412]                             if (is.null(name)) 
[17:44:47.412]                               next
[17:44:47.412]                             if (!grepl(pattern, name)) 
[17:44:47.412]                               next
[17:44:47.412]                             invokeRestart(restart)
[17:44:47.412]                             muffled <- TRUE
[17:44:47.412]                             break
[17:44:47.412]                           }
[17:44:47.412]                         }
[17:44:47.412]                       }
[17:44:47.412]                       invisible(muffled)
[17:44:47.412]                     }
[17:44:47.412]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.412]                   }
[17:44:47.412]                 }
[17:44:47.412]                 else {
[17:44:47.412]                   if (TRUE) {
[17:44:47.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.412]                     {
[17:44:47.412]                       inherits <- base::inherits
[17:44:47.412]                       invokeRestart <- base::invokeRestart
[17:44:47.412]                       is.null <- base::is.null
[17:44:47.412]                       muffled <- FALSE
[17:44:47.412]                       if (inherits(cond, "message")) {
[17:44:47.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.412]                         if (muffled) 
[17:44:47.412]                           invokeRestart("muffleMessage")
[17:44:47.412]                       }
[17:44:47.412]                       else if (inherits(cond, "warning")) {
[17:44:47.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.412]                         if (muffled) 
[17:44:47.412]                           invokeRestart("muffleWarning")
[17:44:47.412]                       }
[17:44:47.412]                       else if (inherits(cond, "condition")) {
[17:44:47.412]                         if (!is.null(pattern)) {
[17:44:47.412]                           computeRestarts <- base::computeRestarts
[17:44:47.412]                           grepl <- base::grepl
[17:44:47.412]                           restarts <- computeRestarts(cond)
[17:44:47.412]                           for (restart in restarts) {
[17:44:47.412]                             name <- restart$name
[17:44:47.412]                             if (is.null(name)) 
[17:44:47.412]                               next
[17:44:47.412]                             if (!grepl(pattern, name)) 
[17:44:47.412]                               next
[17:44:47.412]                             invokeRestart(restart)
[17:44:47.412]                             muffled <- TRUE
[17:44:47.412]                             break
[17:44:47.412]                           }
[17:44:47.412]                         }
[17:44:47.412]                       }
[17:44:47.412]                       invisible(muffled)
[17:44:47.412]                     }
[17:44:47.412]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.412]                   }
[17:44:47.412]                 }
[17:44:47.412]             }
[17:44:47.412]         }))
[17:44:47.412]     }, error = function(ex) {
[17:44:47.412]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.412]                 ...future.rng), started = ...future.startTime, 
[17:44:47.412]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.412]             version = "1.8"), class = "FutureResult")
[17:44:47.412]     }, finally = {
[17:44:47.412]         if (!identical(...future.workdir, getwd())) 
[17:44:47.412]             setwd(...future.workdir)
[17:44:47.412]         {
[17:44:47.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.412]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.412]             }
[17:44:47.412]             base::options(...future.oldOptions)
[17:44:47.412]             if (.Platform$OS.type == "windows") {
[17:44:47.412]                 old_names <- names(...future.oldEnvVars)
[17:44:47.412]                 envs <- base::Sys.getenv()
[17:44:47.412]                 names <- names(envs)
[17:44:47.412]                 common <- intersect(names, old_names)
[17:44:47.412]                 added <- setdiff(names, old_names)
[17:44:47.412]                 removed <- setdiff(old_names, names)
[17:44:47.412]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.412]                   envs[common]]
[17:44:47.412]                 NAMES <- toupper(changed)
[17:44:47.412]                 args <- list()
[17:44:47.412]                 for (kk in seq_along(NAMES)) {
[17:44:47.412]                   name <- changed[[kk]]
[17:44:47.412]                   NAME <- NAMES[[kk]]
[17:44:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.412]                     next
[17:44:47.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.412]                 }
[17:44:47.412]                 NAMES <- toupper(added)
[17:44:47.412]                 for (kk in seq_along(NAMES)) {
[17:44:47.412]                   name <- added[[kk]]
[17:44:47.412]                   NAME <- NAMES[[kk]]
[17:44:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.412]                     next
[17:44:47.412]                   args[[name]] <- ""
[17:44:47.412]                 }
[17:44:47.412]                 NAMES <- toupper(removed)
[17:44:47.412]                 for (kk in seq_along(NAMES)) {
[17:44:47.412]                   name <- removed[[kk]]
[17:44:47.412]                   NAME <- NAMES[[kk]]
[17:44:47.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.412]                     next
[17:44:47.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.412]                 }
[17:44:47.412]                 if (length(args) > 0) 
[17:44:47.412]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.412]             }
[17:44:47.412]             else {
[17:44:47.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.412]             }
[17:44:47.412]             {
[17:44:47.412]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.412]                   0L) {
[17:44:47.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.412]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.412]                   base::options(opts)
[17:44:47.412]                 }
[17:44:47.412]                 {
[17:44:47.412]                   {
[17:44:47.412]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.412]                     NULL
[17:44:47.412]                   }
[17:44:47.412]                   options(future.plan = NULL)
[17:44:47.412]                   if (is.na(NA_character_)) 
[17:44:47.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.412]                     .init = FALSE)
[17:44:47.412]                 }
[17:44:47.412]             }
[17:44:47.412]         }
[17:44:47.412]     })
[17:44:47.412]     if (TRUE) {
[17:44:47.412]         base::sink(type = "output", split = FALSE)
[17:44:47.412]         if (TRUE) {
[17:44:47.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.412]         }
[17:44:47.412]         else {
[17:44:47.412]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.412]         }
[17:44:47.412]         base::close(...future.stdout)
[17:44:47.412]         ...future.stdout <- NULL
[17:44:47.412]     }
[17:44:47.412]     ...future.result$conditions <- ...future.conditions
[17:44:47.412]     ...future.result$finished <- base::Sys.time()
[17:44:47.412]     ...future.result
[17:44:47.412] }
[17:44:47.414] assign_globals() ...
[17:44:47.414] List of 5
[17:44:47.414]  $ ...future.FUN            :function (C, k)  
[17:44:47.414]  $ MoreArgs                 : NULL
[17:44:47.414]  $ ...future.elements_ii    :List of 2
[17:44:47.414]   ..$ :List of 2
[17:44:47.414]   .. ..$ : chr "A"
[17:44:47.414]   .. ..$ : chr "D"
[17:44:47.414]   ..$ :List of 2
[17:44:47.414]   .. ..$ : int 5
[17:44:47.414]   .. ..$ : int 2
[17:44:47.414]  $ ...future.seeds_ii       : NULL
[17:44:47.414]  $ ...future.globals.maxSize: NULL
[17:44:47.414]  - attr(*, "where")=List of 5
[17:44:47.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.414]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.414]  - attr(*, "resolved")= logi FALSE
[17:44:47.414]  - attr(*, "total_size")= num 3656
[17:44:47.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.414]  - attr(*, "already-done")= logi TRUE
[17:44:47.422] - reassign environment for ‘...future.FUN’
[17:44:47.422] - copied ‘...future.FUN’ to environment
[17:44:47.422] - copied ‘MoreArgs’ to environment
[17:44:47.422] - copied ‘...future.elements_ii’ to environment
[17:44:47.422] - copied ‘...future.seeds_ii’ to environment
[17:44:47.422] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.422] assign_globals() ... done
[17:44:47.423] requestCore(): workers = 2
[17:44:47.425] MulticoreFuture started
[17:44:47.426] - Launch lazy future ... done
[17:44:47.426] plan(): Setting new future strategy stack:
[17:44:47.426] run() for ‘MulticoreFuture’ ... done
[17:44:47.427] Created future:
[17:44:47.427] List of future strategies:
[17:44:47.427] 1. sequential:
[17:44:47.427]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.427]    - tweaked: FALSE
[17:44:47.427]    - call: NULL
[17:44:47.428] plan(): nbrOfWorkers() = 1
[17:44:47.431] plan(): Setting new future strategy stack:
[17:44:47.431] List of future strategies:
[17:44:47.431] 1. multicore:
[17:44:47.431]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.431]    - tweaked: FALSE
[17:44:47.431]    - call: plan(strategy)
[17:44:47.437] plan(): nbrOfWorkers() = 2
[17:44:47.427] MulticoreFuture:
[17:44:47.427] Label: ‘future_mapply-1’
[17:44:47.427] Expression:
[17:44:47.427] {
[17:44:47.427]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.427]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.427]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.427]         on.exit(options(oopts), add = TRUE)
[17:44:47.427]     }
[17:44:47.427]     {
[17:44:47.427]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.427]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.427]         do.call(mapply, args = args)
[17:44:47.427]     }
[17:44:47.427] }
[17:44:47.427] Lazy evaluation: FALSE
[17:44:47.427] Asynchronous evaluation: TRUE
[17:44:47.427] Local evaluation: TRUE
[17:44:47.427] Environment: R_GlobalEnv
[17:44:47.427] Capture standard output: TRUE
[17:44:47.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.427] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.427] Packages: <none>
[17:44:47.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.427] Resolved: TRUE
[17:44:47.427] Value: <not collected>
[17:44:47.427] Conditions captured: <none>
[17:44:47.427] Early signaling: FALSE
[17:44:47.427] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.427] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.438] Chunk #1 of 3 ... DONE
[17:44:47.438] Chunk #2 of 3 ...
[17:44:47.439]  - Finding globals in '...' for chunk #2 ...
[17:44:47.439] getGlobalsAndPackages() ...
[17:44:47.439] Searching for globals...
[17:44:47.440] 
[17:44:47.440] Searching for globals ... DONE
[17:44:47.440] - globals: [0] <none>
[17:44:47.440] getGlobalsAndPackages() ... DONE
[17:44:47.440]    + additional globals found: [n=0] 
[17:44:47.440]    + additional namespaces needed: [n=0] 
[17:44:47.441]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:47.441]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:47.441]  - seeds: <none>
[17:44:47.441]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.441] getGlobalsAndPackages() ...
[17:44:47.441] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.441] Resolving globals: FALSE
[17:44:47.442] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:47.443] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.443] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.444] 
[17:44:47.444] getGlobalsAndPackages() ... DONE
[17:44:47.444] run() for ‘Future’ ...
[17:44:47.445] - state: ‘created’
[17:44:47.445] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.449] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.450]   - Field: ‘label’
[17:44:47.450]   - Field: ‘local’
[17:44:47.450]   - Field: ‘owner’
[17:44:47.450]   - Field: ‘envir’
[17:44:47.450]   - Field: ‘workers’
[17:44:47.450]   - Field: ‘packages’
[17:44:47.450]   - Field: ‘gc’
[17:44:47.451]   - Field: ‘job’
[17:44:47.451]   - Field: ‘conditions’
[17:44:47.451]   - Field: ‘expr’
[17:44:47.451]   - Field: ‘uuid’
[17:44:47.451]   - Field: ‘seed’
[17:44:47.451]   - Field: ‘version’
[17:44:47.452]   - Field: ‘result’
[17:44:47.452]   - Field: ‘asynchronous’
[17:44:47.452]   - Field: ‘calls’
[17:44:47.452]   - Field: ‘globals’
[17:44:47.452]   - Field: ‘stdout’
[17:44:47.452]   - Field: ‘earlySignal’
[17:44:47.452]   - Field: ‘lazy’
[17:44:47.452]   - Field: ‘state’
[17:44:47.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.453] - Launch lazy future ...
[17:44:47.453] Packages needed by the future expression (n = 0): <none>
[17:44:47.453] Packages needed by future strategies (n = 0): <none>
[17:44:47.454] {
[17:44:47.454]     {
[17:44:47.454]         {
[17:44:47.454]             ...future.startTime <- base::Sys.time()
[17:44:47.454]             {
[17:44:47.454]                 {
[17:44:47.454]                   {
[17:44:47.454]                     {
[17:44:47.454]                       base::local({
[17:44:47.454]                         has_future <- base::requireNamespace("future", 
[17:44:47.454]                           quietly = TRUE)
[17:44:47.454]                         if (has_future) {
[17:44:47.454]                           ns <- base::getNamespace("future")
[17:44:47.454]                           version <- ns[[".package"]][["version"]]
[17:44:47.454]                           if (is.null(version)) 
[17:44:47.454]                             version <- utils::packageVersion("future")
[17:44:47.454]                         }
[17:44:47.454]                         else {
[17:44:47.454]                           version <- NULL
[17:44:47.454]                         }
[17:44:47.454]                         if (!has_future || version < "1.8.0") {
[17:44:47.454]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.454]                             "", base::R.version$version.string), 
[17:44:47.454]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.454]                               "release", "version")], collapse = " "), 
[17:44:47.454]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.454]                             info)
[17:44:47.454]                           info <- base::paste(info, collapse = "; ")
[17:44:47.454]                           if (!has_future) {
[17:44:47.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.454]                               info)
[17:44:47.454]                           }
[17:44:47.454]                           else {
[17:44:47.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.454]                               info, version)
[17:44:47.454]                           }
[17:44:47.454]                           base::stop(msg)
[17:44:47.454]                         }
[17:44:47.454]                       })
[17:44:47.454]                     }
[17:44:47.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.454]                     base::options(mc.cores = 1L)
[17:44:47.454]                   }
[17:44:47.454]                   ...future.strategy.old <- future::plan("list")
[17:44:47.454]                   options(future.plan = NULL)
[17:44:47.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.454]                 }
[17:44:47.454]                 ...future.workdir <- getwd()
[17:44:47.454]             }
[17:44:47.454]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.454]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.454]         }
[17:44:47.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.454]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:47.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.454]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.454]             base::names(...future.oldOptions))
[17:44:47.454]     }
[17:44:47.454]     if (FALSE) {
[17:44:47.454]     }
[17:44:47.454]     else {
[17:44:47.454]         if (TRUE) {
[17:44:47.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.454]                 open = "w")
[17:44:47.454]         }
[17:44:47.454]         else {
[17:44:47.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.454]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.454]         }
[17:44:47.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.454]             base::sink(type = "output", split = FALSE)
[17:44:47.454]             base::close(...future.stdout)
[17:44:47.454]         }, add = TRUE)
[17:44:47.454]     }
[17:44:47.454]     ...future.frame <- base::sys.nframe()
[17:44:47.454]     ...future.conditions <- base::list()
[17:44:47.454]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.454]     if (FALSE) {
[17:44:47.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.454]     }
[17:44:47.454]     ...future.result <- base::tryCatch({
[17:44:47.454]         base::withCallingHandlers({
[17:44:47.454]             ...future.value <- base::withVisible(base::local({
[17:44:47.454]                 withCallingHandlers({
[17:44:47.454]                   {
[17:44:47.454]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.454]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.454]                       ...future.globals.maxSize)) {
[17:44:47.454]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.454]                       on.exit(options(oopts), add = TRUE)
[17:44:47.454]                     }
[17:44:47.454]                     {
[17:44:47.454]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.454]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.454]                         USE.NAMES = FALSE)
[17:44:47.454]                       do.call(mapply, args = args)
[17:44:47.454]                     }
[17:44:47.454]                   }
[17:44:47.454]                 }, immediateCondition = function(cond) {
[17:44:47.454]                   save_rds <- function (object, pathname, ...) 
[17:44:47.454]                   {
[17:44:47.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.454]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.454]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.454]                         fi_tmp[["mtime"]])
[17:44:47.454]                     }
[17:44:47.454]                     tryCatch({
[17:44:47.454]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.454]                     }, error = function(ex) {
[17:44:47.454]                       msg <- conditionMessage(ex)
[17:44:47.454]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.454]                         fi_tmp[["mtime"]], msg)
[17:44:47.454]                       ex$message <- msg
[17:44:47.454]                       stop(ex)
[17:44:47.454]                     })
[17:44:47.454]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.454]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.454]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.454]                       fi <- file.info(pathname)
[17:44:47.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.454]                         fi[["size"]], fi[["mtime"]])
[17:44:47.454]                       stop(msg)
[17:44:47.454]                     }
[17:44:47.454]                     invisible(pathname)
[17:44:47.454]                   }
[17:44:47.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.454]                     rootPath = tempdir()) 
[17:44:47.454]                   {
[17:44:47.454]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.454]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.454]                       tmpdir = path, fileext = ".rds")
[17:44:47.454]                     save_rds(obj, file)
[17:44:47.454]                   }
[17:44:47.454]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.454]                   {
[17:44:47.454]                     inherits <- base::inherits
[17:44:47.454]                     invokeRestart <- base::invokeRestart
[17:44:47.454]                     is.null <- base::is.null
[17:44:47.454]                     muffled <- FALSE
[17:44:47.454]                     if (inherits(cond, "message")) {
[17:44:47.454]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.454]                       if (muffled) 
[17:44:47.454]                         invokeRestart("muffleMessage")
[17:44:47.454]                     }
[17:44:47.454]                     else if (inherits(cond, "warning")) {
[17:44:47.454]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.454]                       if (muffled) 
[17:44:47.454]                         invokeRestart("muffleWarning")
[17:44:47.454]                     }
[17:44:47.454]                     else if (inherits(cond, "condition")) {
[17:44:47.454]                       if (!is.null(pattern)) {
[17:44:47.454]                         computeRestarts <- base::computeRestarts
[17:44:47.454]                         grepl <- base::grepl
[17:44:47.454]                         restarts <- computeRestarts(cond)
[17:44:47.454]                         for (restart in restarts) {
[17:44:47.454]                           name <- restart$name
[17:44:47.454]                           if (is.null(name)) 
[17:44:47.454]                             next
[17:44:47.454]                           if (!grepl(pattern, name)) 
[17:44:47.454]                             next
[17:44:47.454]                           invokeRestart(restart)
[17:44:47.454]                           muffled <- TRUE
[17:44:47.454]                           break
[17:44:47.454]                         }
[17:44:47.454]                       }
[17:44:47.454]                     }
[17:44:47.454]                     invisible(muffled)
[17:44:47.454]                   }
[17:44:47.454]                   muffleCondition(cond)
[17:44:47.454]                 })
[17:44:47.454]             }))
[17:44:47.454]             future::FutureResult(value = ...future.value$value, 
[17:44:47.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.454]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.454]                     ...future.globalenv.names))
[17:44:47.454]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.454]         }, condition = base::local({
[17:44:47.454]             c <- base::c
[17:44:47.454]             inherits <- base::inherits
[17:44:47.454]             invokeRestart <- base::invokeRestart
[17:44:47.454]             length <- base::length
[17:44:47.454]             list <- base::list
[17:44:47.454]             seq.int <- base::seq.int
[17:44:47.454]             signalCondition <- base::signalCondition
[17:44:47.454]             sys.calls <- base::sys.calls
[17:44:47.454]             `[[` <- base::`[[`
[17:44:47.454]             `+` <- base::`+`
[17:44:47.454]             `<<-` <- base::`<<-`
[17:44:47.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.454]                   3L)]
[17:44:47.454]             }
[17:44:47.454]             function(cond) {
[17:44:47.454]                 is_error <- inherits(cond, "error")
[17:44:47.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.454]                   NULL)
[17:44:47.454]                 if (is_error) {
[17:44:47.454]                   sessionInformation <- function() {
[17:44:47.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.454]                       search = base::search(), system = base::Sys.info())
[17:44:47.454]                   }
[17:44:47.454]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.454]                     cond$call), session = sessionInformation(), 
[17:44:47.454]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.454]                   signalCondition(cond)
[17:44:47.454]                 }
[17:44:47.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.454]                 "immediateCondition"))) {
[17:44:47.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.454]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.454]                   if (TRUE && !signal) {
[17:44:47.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.454]                     {
[17:44:47.454]                       inherits <- base::inherits
[17:44:47.454]                       invokeRestart <- base::invokeRestart
[17:44:47.454]                       is.null <- base::is.null
[17:44:47.454]                       muffled <- FALSE
[17:44:47.454]                       if (inherits(cond, "message")) {
[17:44:47.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.454]                         if (muffled) 
[17:44:47.454]                           invokeRestart("muffleMessage")
[17:44:47.454]                       }
[17:44:47.454]                       else if (inherits(cond, "warning")) {
[17:44:47.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.454]                         if (muffled) 
[17:44:47.454]                           invokeRestart("muffleWarning")
[17:44:47.454]                       }
[17:44:47.454]                       else if (inherits(cond, "condition")) {
[17:44:47.454]                         if (!is.null(pattern)) {
[17:44:47.454]                           computeRestarts <- base::computeRestarts
[17:44:47.454]                           grepl <- base::grepl
[17:44:47.454]                           restarts <- computeRestarts(cond)
[17:44:47.454]                           for (restart in restarts) {
[17:44:47.454]                             name <- restart$name
[17:44:47.454]                             if (is.null(name)) 
[17:44:47.454]                               next
[17:44:47.454]                             if (!grepl(pattern, name)) 
[17:44:47.454]                               next
[17:44:47.454]                             invokeRestart(restart)
[17:44:47.454]                             muffled <- TRUE
[17:44:47.454]                             break
[17:44:47.454]                           }
[17:44:47.454]                         }
[17:44:47.454]                       }
[17:44:47.454]                       invisible(muffled)
[17:44:47.454]                     }
[17:44:47.454]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.454]                   }
[17:44:47.454]                 }
[17:44:47.454]                 else {
[17:44:47.454]                   if (TRUE) {
[17:44:47.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.454]                     {
[17:44:47.454]                       inherits <- base::inherits
[17:44:47.454]                       invokeRestart <- base::invokeRestart
[17:44:47.454]                       is.null <- base::is.null
[17:44:47.454]                       muffled <- FALSE
[17:44:47.454]                       if (inherits(cond, "message")) {
[17:44:47.454]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.454]                         if (muffled) 
[17:44:47.454]                           invokeRestart("muffleMessage")
[17:44:47.454]                       }
[17:44:47.454]                       else if (inherits(cond, "warning")) {
[17:44:47.454]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.454]                         if (muffled) 
[17:44:47.454]                           invokeRestart("muffleWarning")
[17:44:47.454]                       }
[17:44:47.454]                       else if (inherits(cond, "condition")) {
[17:44:47.454]                         if (!is.null(pattern)) {
[17:44:47.454]                           computeRestarts <- base::computeRestarts
[17:44:47.454]                           grepl <- base::grepl
[17:44:47.454]                           restarts <- computeRestarts(cond)
[17:44:47.454]                           for (restart in restarts) {
[17:44:47.454]                             name <- restart$name
[17:44:47.454]                             if (is.null(name)) 
[17:44:47.454]                               next
[17:44:47.454]                             if (!grepl(pattern, name)) 
[17:44:47.454]                               next
[17:44:47.454]                             invokeRestart(restart)
[17:44:47.454]                             muffled <- TRUE
[17:44:47.454]                             break
[17:44:47.454]                           }
[17:44:47.454]                         }
[17:44:47.454]                       }
[17:44:47.454]                       invisible(muffled)
[17:44:47.454]                     }
[17:44:47.454]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.454]                   }
[17:44:47.454]                 }
[17:44:47.454]             }
[17:44:47.454]         }))
[17:44:47.454]     }, error = function(ex) {
[17:44:47.454]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.454]                 ...future.rng), started = ...future.startTime, 
[17:44:47.454]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.454]             version = "1.8"), class = "FutureResult")
[17:44:47.454]     }, finally = {
[17:44:47.454]         if (!identical(...future.workdir, getwd())) 
[17:44:47.454]             setwd(...future.workdir)
[17:44:47.454]         {
[17:44:47.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.454]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.454]             }
[17:44:47.454]             base::options(...future.oldOptions)
[17:44:47.454]             if (.Platform$OS.type == "windows") {
[17:44:47.454]                 old_names <- names(...future.oldEnvVars)
[17:44:47.454]                 envs <- base::Sys.getenv()
[17:44:47.454]                 names <- names(envs)
[17:44:47.454]                 common <- intersect(names, old_names)
[17:44:47.454]                 added <- setdiff(names, old_names)
[17:44:47.454]                 removed <- setdiff(old_names, names)
[17:44:47.454]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.454]                   envs[common]]
[17:44:47.454]                 NAMES <- toupper(changed)
[17:44:47.454]                 args <- list()
[17:44:47.454]                 for (kk in seq_along(NAMES)) {
[17:44:47.454]                   name <- changed[[kk]]
[17:44:47.454]                   NAME <- NAMES[[kk]]
[17:44:47.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.454]                     next
[17:44:47.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.454]                 }
[17:44:47.454]                 NAMES <- toupper(added)
[17:44:47.454]                 for (kk in seq_along(NAMES)) {
[17:44:47.454]                   name <- added[[kk]]
[17:44:47.454]                   NAME <- NAMES[[kk]]
[17:44:47.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.454]                     next
[17:44:47.454]                   args[[name]] <- ""
[17:44:47.454]                 }
[17:44:47.454]                 NAMES <- toupper(removed)
[17:44:47.454]                 for (kk in seq_along(NAMES)) {
[17:44:47.454]                   name <- removed[[kk]]
[17:44:47.454]                   NAME <- NAMES[[kk]]
[17:44:47.454]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.454]                     next
[17:44:47.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.454]                 }
[17:44:47.454]                 if (length(args) > 0) 
[17:44:47.454]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.454]             }
[17:44:47.454]             else {
[17:44:47.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.454]             }
[17:44:47.454]             {
[17:44:47.454]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.454]                   0L) {
[17:44:47.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.454]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.454]                   base::options(opts)
[17:44:47.454]                 }
[17:44:47.454]                 {
[17:44:47.454]                   {
[17:44:47.454]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.454]                     NULL
[17:44:47.454]                   }
[17:44:47.454]                   options(future.plan = NULL)
[17:44:47.454]                   if (is.na(NA_character_)) 
[17:44:47.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.454]                     .init = FALSE)
[17:44:47.454]                 }
[17:44:47.454]             }
[17:44:47.454]         }
[17:44:47.454]     })
[17:44:47.454]     if (TRUE) {
[17:44:47.454]         base::sink(type = "output", split = FALSE)
[17:44:47.454]         if (TRUE) {
[17:44:47.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.454]         }
[17:44:47.454]         else {
[17:44:47.454]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.454]         }
[17:44:47.454]         base::close(...future.stdout)
[17:44:47.454]         ...future.stdout <- NULL
[17:44:47.454]     }
[17:44:47.454]     ...future.result$conditions <- ...future.conditions
[17:44:47.454]     ...future.result$finished <- base::Sys.time()
[17:44:47.454]     ...future.result
[17:44:47.454] }
[17:44:47.457] assign_globals() ...
[17:44:47.457] List of 5
[17:44:47.457]  $ ...future.FUN            :function (C, k)  
[17:44:47.457]  $ MoreArgs                 : NULL
[17:44:47.457]  $ ...future.elements_ii    :List of 2
[17:44:47.457]   ..$ :List of 1
[17:44:47.457]   .. ..$ : chr "E"
[17:44:47.457]   ..$ :List of 1
[17:44:47.457]   .. ..$ : int 1
[17:44:47.457]  $ ...future.seeds_ii       : NULL
[17:44:47.457]  $ ...future.globals.maxSize: NULL
[17:44:47.457]  - attr(*, "where")=List of 5
[17:44:47.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.457]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.457]  - attr(*, "resolved")= logi FALSE
[17:44:47.457]  - attr(*, "total_size")= num 3488
[17:44:47.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.457]  - attr(*, "already-done")= logi TRUE
[17:44:47.464] - reassign environment for ‘...future.FUN’
[17:44:47.465] - copied ‘...future.FUN’ to environment
[17:44:47.465] - copied ‘MoreArgs’ to environment
[17:44:47.465] - copied ‘...future.elements_ii’ to environment
[17:44:47.465] - copied ‘...future.seeds_ii’ to environment
[17:44:47.465] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.465] assign_globals() ... done
[17:44:47.465] requestCore(): workers = 2
[17:44:47.468] MulticoreFuture started
[17:44:47.468] - Launch lazy future ... done
[17:44:47.468] run() for ‘MulticoreFuture’ ... done
[17:44:47.469] Created future:
[17:44:47.469] plan(): Setting new future strategy stack:
[17:44:47.469] List of future strategies:
[17:44:47.469] 1. sequential:
[17:44:47.469]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.469]    - tweaked: FALSE
[17:44:47.469]    - call: NULL
[17:44:47.470] plan(): nbrOfWorkers() = 1
[17:44:47.477] plan(): Setting new future strategy stack:
[17:44:47.477] List of future strategies:
[17:44:47.477] 1. multicore:
[17:44:47.477]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.477]    - tweaked: FALSE
[17:44:47.477]    - call: plan(strategy)
[17:44:47.484] plan(): nbrOfWorkers() = 2
[17:44:47.469] MulticoreFuture:
[17:44:47.469] Label: ‘future_mapply-2’
[17:44:47.469] Expression:
[17:44:47.469] {
[17:44:47.469]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.469]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.469]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.469]         on.exit(options(oopts), add = TRUE)
[17:44:47.469]     }
[17:44:47.469]     {
[17:44:47.469]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.469]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.469]         do.call(mapply, args = args)
[17:44:47.469]     }
[17:44:47.469] }
[17:44:47.469] Lazy evaluation: FALSE
[17:44:47.469] Asynchronous evaluation: TRUE
[17:44:47.469] Local evaluation: TRUE
[17:44:47.469] Environment: R_GlobalEnv
[17:44:47.469] Capture standard output: TRUE
[17:44:47.469] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.469] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.469] Packages: <none>
[17:44:47.469] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.469] Resolved: TRUE
[17:44:47.469] Value: <not collected>
[17:44:47.469] Conditions captured: <none>
[17:44:47.469] Early signaling: FALSE
[17:44:47.469] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.469] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.485] Chunk #2 of 3 ... DONE
[17:44:47.486] Chunk #3 of 3 ...
[17:44:47.486]  - Finding globals in '...' for chunk #3 ...
[17:44:47.486] getGlobalsAndPackages() ...
[17:44:47.486] Searching for globals...
[17:44:47.487] 
[17:44:47.488] Searching for globals ... DONE
[17:44:47.488] - globals: [0] <none>
[17:44:47.488] getGlobalsAndPackages() ... DONE
[17:44:47.488]    + additional globals found: [n=0] 
[17:44:47.488]    + additional namespaces needed: [n=0] 
[17:44:47.489]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:47.489]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:47.489]  - seeds: <none>
[17:44:47.489]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.490] getGlobalsAndPackages() ...
[17:44:47.490] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.490] Resolving globals: FALSE
[17:44:47.491] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.492] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.492] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.493] 
[17:44:47.493] getGlobalsAndPackages() ... DONE
[17:44:47.494] run() for ‘Future’ ...
[17:44:47.494] - state: ‘created’
[17:44:47.494] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.499] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.499] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.499]   - Field: ‘label’
[17:44:47.500]   - Field: ‘local’
[17:44:47.500]   - Field: ‘owner’
[17:44:47.500]   - Field: ‘envir’
[17:44:47.500]   - Field: ‘workers’
[17:44:47.500]   - Field: ‘packages’
[17:44:47.500]   - Field: ‘gc’
[17:44:47.500]   - Field: ‘job’
[17:44:47.500]   - Field: ‘conditions’
[17:44:47.501]   - Field: ‘expr’
[17:44:47.501]   - Field: ‘uuid’
[17:44:47.501]   - Field: ‘seed’
[17:44:47.501]   - Field: ‘version’
[17:44:47.501]   - Field: ‘result’
[17:44:47.501]   - Field: ‘asynchronous’
[17:44:47.501]   - Field: ‘calls’
[17:44:47.502]   - Field: ‘globals’
[17:44:47.502]   - Field: ‘stdout’
[17:44:47.502]   - Field: ‘earlySignal’
[17:44:47.502]   - Field: ‘lazy’
[17:44:47.502]   - Field: ‘state’
[17:44:47.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.503] - Launch lazy future ...
[17:44:47.503] Packages needed by the future expression (n = 0): <none>
[17:44:47.503] Packages needed by future strategies (n = 0): <none>
[17:44:47.504] {
[17:44:47.504]     {
[17:44:47.504]         {
[17:44:47.504]             ...future.startTime <- base::Sys.time()
[17:44:47.504]             {
[17:44:47.504]                 {
[17:44:47.504]                   {
[17:44:47.504]                     {
[17:44:47.504]                       base::local({
[17:44:47.504]                         has_future <- base::requireNamespace("future", 
[17:44:47.504]                           quietly = TRUE)
[17:44:47.504]                         if (has_future) {
[17:44:47.504]                           ns <- base::getNamespace("future")
[17:44:47.504]                           version <- ns[[".package"]][["version"]]
[17:44:47.504]                           if (is.null(version)) 
[17:44:47.504]                             version <- utils::packageVersion("future")
[17:44:47.504]                         }
[17:44:47.504]                         else {
[17:44:47.504]                           version <- NULL
[17:44:47.504]                         }
[17:44:47.504]                         if (!has_future || version < "1.8.0") {
[17:44:47.504]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.504]                             "", base::R.version$version.string), 
[17:44:47.504]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.504]                               "release", "version")], collapse = " "), 
[17:44:47.504]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.504]                             info)
[17:44:47.504]                           info <- base::paste(info, collapse = "; ")
[17:44:47.504]                           if (!has_future) {
[17:44:47.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.504]                               info)
[17:44:47.504]                           }
[17:44:47.504]                           else {
[17:44:47.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.504]                               info, version)
[17:44:47.504]                           }
[17:44:47.504]                           base::stop(msg)
[17:44:47.504]                         }
[17:44:47.504]                       })
[17:44:47.504]                     }
[17:44:47.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.504]                     base::options(mc.cores = 1L)
[17:44:47.504]                   }
[17:44:47.504]                   ...future.strategy.old <- future::plan("list")
[17:44:47.504]                   options(future.plan = NULL)
[17:44:47.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.504]                 }
[17:44:47.504]                 ...future.workdir <- getwd()
[17:44:47.504]             }
[17:44:47.504]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.504]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.504]         }
[17:44:47.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.504]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:47.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.504]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.504]             base::names(...future.oldOptions))
[17:44:47.504]     }
[17:44:47.504]     if (FALSE) {
[17:44:47.504]     }
[17:44:47.504]     else {
[17:44:47.504]         if (TRUE) {
[17:44:47.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.504]                 open = "w")
[17:44:47.504]         }
[17:44:47.504]         else {
[17:44:47.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.504]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.504]         }
[17:44:47.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.504]             base::sink(type = "output", split = FALSE)
[17:44:47.504]             base::close(...future.stdout)
[17:44:47.504]         }, add = TRUE)
[17:44:47.504]     }
[17:44:47.504]     ...future.frame <- base::sys.nframe()
[17:44:47.504]     ...future.conditions <- base::list()
[17:44:47.504]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.504]     if (FALSE) {
[17:44:47.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.504]     }
[17:44:47.504]     ...future.result <- base::tryCatch({
[17:44:47.504]         base::withCallingHandlers({
[17:44:47.504]             ...future.value <- base::withVisible(base::local({
[17:44:47.504]                 withCallingHandlers({
[17:44:47.504]                   {
[17:44:47.504]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.504]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.504]                       ...future.globals.maxSize)) {
[17:44:47.504]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.504]                       on.exit(options(oopts), add = TRUE)
[17:44:47.504]                     }
[17:44:47.504]                     {
[17:44:47.504]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.504]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.504]                         USE.NAMES = FALSE)
[17:44:47.504]                       do.call(mapply, args = args)
[17:44:47.504]                     }
[17:44:47.504]                   }
[17:44:47.504]                 }, immediateCondition = function(cond) {
[17:44:47.504]                   save_rds <- function (object, pathname, ...) 
[17:44:47.504]                   {
[17:44:47.504]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.504]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.504]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.504]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.504]                         fi_tmp[["mtime"]])
[17:44:47.504]                     }
[17:44:47.504]                     tryCatch({
[17:44:47.504]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.504]                     }, error = function(ex) {
[17:44:47.504]                       msg <- conditionMessage(ex)
[17:44:47.504]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.504]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.504]                         fi_tmp[["mtime"]], msg)
[17:44:47.504]                       ex$message <- msg
[17:44:47.504]                       stop(ex)
[17:44:47.504]                     })
[17:44:47.504]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.504]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.504]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.504]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.504]                       fi <- file.info(pathname)
[17:44:47.504]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.504]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.504]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.504]                         fi[["size"]], fi[["mtime"]])
[17:44:47.504]                       stop(msg)
[17:44:47.504]                     }
[17:44:47.504]                     invisible(pathname)
[17:44:47.504]                   }
[17:44:47.504]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.504]                     rootPath = tempdir()) 
[17:44:47.504]                   {
[17:44:47.504]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.504]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.504]                       tmpdir = path, fileext = ".rds")
[17:44:47.504]                     save_rds(obj, file)
[17:44:47.504]                   }
[17:44:47.504]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.504]                   {
[17:44:47.504]                     inherits <- base::inherits
[17:44:47.504]                     invokeRestart <- base::invokeRestart
[17:44:47.504]                     is.null <- base::is.null
[17:44:47.504]                     muffled <- FALSE
[17:44:47.504]                     if (inherits(cond, "message")) {
[17:44:47.504]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.504]                       if (muffled) 
[17:44:47.504]                         invokeRestart("muffleMessage")
[17:44:47.504]                     }
[17:44:47.504]                     else if (inherits(cond, "warning")) {
[17:44:47.504]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.504]                       if (muffled) 
[17:44:47.504]                         invokeRestart("muffleWarning")
[17:44:47.504]                     }
[17:44:47.504]                     else if (inherits(cond, "condition")) {
[17:44:47.504]                       if (!is.null(pattern)) {
[17:44:47.504]                         computeRestarts <- base::computeRestarts
[17:44:47.504]                         grepl <- base::grepl
[17:44:47.504]                         restarts <- computeRestarts(cond)
[17:44:47.504]                         for (restart in restarts) {
[17:44:47.504]                           name <- restart$name
[17:44:47.504]                           if (is.null(name)) 
[17:44:47.504]                             next
[17:44:47.504]                           if (!grepl(pattern, name)) 
[17:44:47.504]                             next
[17:44:47.504]                           invokeRestart(restart)
[17:44:47.504]                           muffled <- TRUE
[17:44:47.504]                           break
[17:44:47.504]                         }
[17:44:47.504]                       }
[17:44:47.504]                     }
[17:44:47.504]                     invisible(muffled)
[17:44:47.504]                   }
[17:44:47.504]                   muffleCondition(cond)
[17:44:47.504]                 })
[17:44:47.504]             }))
[17:44:47.504]             future::FutureResult(value = ...future.value$value, 
[17:44:47.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.504]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.504]                     ...future.globalenv.names))
[17:44:47.504]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.504]         }, condition = base::local({
[17:44:47.504]             c <- base::c
[17:44:47.504]             inherits <- base::inherits
[17:44:47.504]             invokeRestart <- base::invokeRestart
[17:44:47.504]             length <- base::length
[17:44:47.504]             list <- base::list
[17:44:47.504]             seq.int <- base::seq.int
[17:44:47.504]             signalCondition <- base::signalCondition
[17:44:47.504]             sys.calls <- base::sys.calls
[17:44:47.504]             `[[` <- base::`[[`
[17:44:47.504]             `+` <- base::`+`
[17:44:47.504]             `<<-` <- base::`<<-`
[17:44:47.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.504]                   3L)]
[17:44:47.504]             }
[17:44:47.504]             function(cond) {
[17:44:47.504]                 is_error <- inherits(cond, "error")
[17:44:47.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.504]                   NULL)
[17:44:47.504]                 if (is_error) {
[17:44:47.504]                   sessionInformation <- function() {
[17:44:47.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.504]                       search = base::search(), system = base::Sys.info())
[17:44:47.504]                   }
[17:44:47.504]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.504]                     cond$call), session = sessionInformation(), 
[17:44:47.504]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.504]                   signalCondition(cond)
[17:44:47.504]                 }
[17:44:47.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.504]                 "immediateCondition"))) {
[17:44:47.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.504]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.504]                   if (TRUE && !signal) {
[17:44:47.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.504]                     {
[17:44:47.504]                       inherits <- base::inherits
[17:44:47.504]                       invokeRestart <- base::invokeRestart
[17:44:47.504]                       is.null <- base::is.null
[17:44:47.504]                       muffled <- FALSE
[17:44:47.504]                       if (inherits(cond, "message")) {
[17:44:47.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.504]                         if (muffled) 
[17:44:47.504]                           invokeRestart("muffleMessage")
[17:44:47.504]                       }
[17:44:47.504]                       else if (inherits(cond, "warning")) {
[17:44:47.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.504]                         if (muffled) 
[17:44:47.504]                           invokeRestart("muffleWarning")
[17:44:47.504]                       }
[17:44:47.504]                       else if (inherits(cond, "condition")) {
[17:44:47.504]                         if (!is.null(pattern)) {
[17:44:47.504]                           computeRestarts <- base::computeRestarts
[17:44:47.504]                           grepl <- base::grepl
[17:44:47.504]                           restarts <- computeRestarts(cond)
[17:44:47.504]                           for (restart in restarts) {
[17:44:47.504]                             name <- restart$name
[17:44:47.504]                             if (is.null(name)) 
[17:44:47.504]                               next
[17:44:47.504]                             if (!grepl(pattern, name)) 
[17:44:47.504]                               next
[17:44:47.504]                             invokeRestart(restart)
[17:44:47.504]                             muffled <- TRUE
[17:44:47.504]                             break
[17:44:47.504]                           }
[17:44:47.504]                         }
[17:44:47.504]                       }
[17:44:47.504]                       invisible(muffled)
[17:44:47.504]                     }
[17:44:47.504]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.504]                   }
[17:44:47.504]                 }
[17:44:47.504]                 else {
[17:44:47.504]                   if (TRUE) {
[17:44:47.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.504]                     {
[17:44:47.504]                       inherits <- base::inherits
[17:44:47.504]                       invokeRestart <- base::invokeRestart
[17:44:47.504]                       is.null <- base::is.null
[17:44:47.504]                       muffled <- FALSE
[17:44:47.504]                       if (inherits(cond, "message")) {
[17:44:47.504]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.504]                         if (muffled) 
[17:44:47.504]                           invokeRestart("muffleMessage")
[17:44:47.504]                       }
[17:44:47.504]                       else if (inherits(cond, "warning")) {
[17:44:47.504]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.504]                         if (muffled) 
[17:44:47.504]                           invokeRestart("muffleWarning")
[17:44:47.504]                       }
[17:44:47.504]                       else if (inherits(cond, "condition")) {
[17:44:47.504]                         if (!is.null(pattern)) {
[17:44:47.504]                           computeRestarts <- base::computeRestarts
[17:44:47.504]                           grepl <- base::grepl
[17:44:47.504]                           restarts <- computeRestarts(cond)
[17:44:47.504]                           for (restart in restarts) {
[17:44:47.504]                             name <- restart$name
[17:44:47.504]                             if (is.null(name)) 
[17:44:47.504]                               next
[17:44:47.504]                             if (!grepl(pattern, name)) 
[17:44:47.504]                               next
[17:44:47.504]                             invokeRestart(restart)
[17:44:47.504]                             muffled <- TRUE
[17:44:47.504]                             break
[17:44:47.504]                           }
[17:44:47.504]                         }
[17:44:47.504]                       }
[17:44:47.504]                       invisible(muffled)
[17:44:47.504]                     }
[17:44:47.504]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.504]                   }
[17:44:47.504]                 }
[17:44:47.504]             }
[17:44:47.504]         }))
[17:44:47.504]     }, error = function(ex) {
[17:44:47.504]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.504]                 ...future.rng), started = ...future.startTime, 
[17:44:47.504]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.504]             version = "1.8"), class = "FutureResult")
[17:44:47.504]     }, finally = {
[17:44:47.504]         if (!identical(...future.workdir, getwd())) 
[17:44:47.504]             setwd(...future.workdir)
[17:44:47.504]         {
[17:44:47.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.504]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.504]             }
[17:44:47.504]             base::options(...future.oldOptions)
[17:44:47.504]             if (.Platform$OS.type == "windows") {
[17:44:47.504]                 old_names <- names(...future.oldEnvVars)
[17:44:47.504]                 envs <- base::Sys.getenv()
[17:44:47.504]                 names <- names(envs)
[17:44:47.504]                 common <- intersect(names, old_names)
[17:44:47.504]                 added <- setdiff(names, old_names)
[17:44:47.504]                 removed <- setdiff(old_names, names)
[17:44:47.504]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.504]                   envs[common]]
[17:44:47.504]                 NAMES <- toupper(changed)
[17:44:47.504]                 args <- list()
[17:44:47.504]                 for (kk in seq_along(NAMES)) {
[17:44:47.504]                   name <- changed[[kk]]
[17:44:47.504]                   NAME <- NAMES[[kk]]
[17:44:47.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.504]                     next
[17:44:47.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.504]                 }
[17:44:47.504]                 NAMES <- toupper(added)
[17:44:47.504]                 for (kk in seq_along(NAMES)) {
[17:44:47.504]                   name <- added[[kk]]
[17:44:47.504]                   NAME <- NAMES[[kk]]
[17:44:47.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.504]                     next
[17:44:47.504]                   args[[name]] <- ""
[17:44:47.504]                 }
[17:44:47.504]                 NAMES <- toupper(removed)
[17:44:47.504]                 for (kk in seq_along(NAMES)) {
[17:44:47.504]                   name <- removed[[kk]]
[17:44:47.504]                   NAME <- NAMES[[kk]]
[17:44:47.504]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.504]                     next
[17:44:47.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.504]                 }
[17:44:47.504]                 if (length(args) > 0) 
[17:44:47.504]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.504]             }
[17:44:47.504]             else {
[17:44:47.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.504]             }
[17:44:47.504]             {
[17:44:47.504]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.504]                   0L) {
[17:44:47.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.504]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.504]                   base::options(opts)
[17:44:47.504]                 }
[17:44:47.504]                 {
[17:44:47.504]                   {
[17:44:47.504]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.504]                     NULL
[17:44:47.504]                   }
[17:44:47.504]                   options(future.plan = NULL)
[17:44:47.504]                   if (is.na(NA_character_)) 
[17:44:47.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.504]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.504]                     .init = FALSE)
[17:44:47.504]                 }
[17:44:47.504]             }
[17:44:47.504]         }
[17:44:47.504]     })
[17:44:47.504]     if (TRUE) {
[17:44:47.504]         base::sink(type = "output", split = FALSE)
[17:44:47.504]         if (TRUE) {
[17:44:47.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.504]         }
[17:44:47.504]         else {
[17:44:47.504]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.504]         }
[17:44:47.504]         base::close(...future.stdout)
[17:44:47.504]         ...future.stdout <- NULL
[17:44:47.504]     }
[17:44:47.504]     ...future.result$conditions <- ...future.conditions
[17:44:47.504]     ...future.result$finished <- base::Sys.time()
[17:44:47.504]     ...future.result
[17:44:47.504] }
[17:44:47.506] assign_globals() ...
[17:44:47.507] List of 5
[17:44:47.507]  $ ...future.FUN            :function (C, k)  
[17:44:47.507]  $ MoreArgs                 : NULL
[17:44:47.507]  $ ...future.elements_ii    :List of 2
[17:44:47.507]   ..$ :List of 2
[17:44:47.507]   .. ..$ : chr "B"
[17:44:47.507]   .. ..$ : chr "C"
[17:44:47.507]   ..$ :List of 2
[17:44:47.507]   .. ..$ : int 4
[17:44:47.507]   .. ..$ : int 3
[17:44:47.507]  $ ...future.seeds_ii       : NULL
[17:44:47.507]  $ ...future.globals.maxSize: NULL
[17:44:47.507]  - attr(*, "where")=List of 5
[17:44:47.507]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.507]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.507]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.507]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.507]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.507]  - attr(*, "resolved")= logi FALSE
[17:44:47.507]  - attr(*, "total_size")= num 3656
[17:44:47.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.507]  - attr(*, "already-done")= logi TRUE
[17:44:47.513] - reassign environment for ‘...future.FUN’
[17:44:47.513] - copied ‘...future.FUN’ to environment
[17:44:47.514] - copied ‘MoreArgs’ to environment
[17:44:47.514] - copied ‘...future.elements_ii’ to environment
[17:44:47.514] - copied ‘...future.seeds_ii’ to environment
[17:44:47.514] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.514] assign_globals() ... done
[17:44:47.514] requestCore(): workers = 2
[17:44:47.515] Poll #1 (0): usedCores() = 2, workers = 2
[17:44:47.525] result() for MulticoreFuture ...
[17:44:47.526] result() for MulticoreFuture ...
[17:44:47.526] result() for MulticoreFuture ... done
[17:44:47.526] result() for MulticoreFuture ... done
[17:44:47.526] result() for MulticoreFuture ...
[17:44:47.526] result() for MulticoreFuture ... done
[17:44:47.529] MulticoreFuture started
[17:44:47.529] - Launch lazy future ... done
[17:44:47.529] run() for ‘MulticoreFuture’ ... done
[17:44:47.530] Created future:
[17:44:47.530] plan(): Setting new future strategy stack:
[17:44:47.530] List of future strategies:
[17:44:47.530] 1. sequential:
[17:44:47.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.530]    - tweaked: FALSE
[17:44:47.530]    - call: NULL
[17:44:47.532] plan(): nbrOfWorkers() = 1
[17:44:47.534] plan(): Setting new future strategy stack:
[17:44:47.534] List of future strategies:
[17:44:47.534] 1. multicore:
[17:44:47.534]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.534]    - tweaked: FALSE
[17:44:47.534]    - call: plan(strategy)
[17:44:47.540] plan(): nbrOfWorkers() = 2
[17:44:47.530] MulticoreFuture:
[17:44:47.530] Label: ‘future_mapply-3’
[17:44:47.530] Expression:
[17:44:47.530] {
[17:44:47.530]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.530]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.530]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.530]         on.exit(options(oopts), add = TRUE)
[17:44:47.530]     }
[17:44:47.530]     {
[17:44:47.530]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.530]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.530]         do.call(mapply, args = args)
[17:44:47.530]     }
[17:44:47.530] }
[17:44:47.530] Lazy evaluation: FALSE
[17:44:47.530] Asynchronous evaluation: TRUE
[17:44:47.530] Local evaluation: TRUE
[17:44:47.530] Environment: R_GlobalEnv
[17:44:47.530] Capture standard output: TRUE
[17:44:47.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.530] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.530] Packages: <none>
[17:44:47.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.530] Resolved: TRUE
[17:44:47.530] Value: <not collected>
[17:44:47.530] Conditions captured: <none>
[17:44:47.530] Early signaling: FALSE
[17:44:47.530] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.530] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.541] Chunk #3 of 3 ... DONE
[17:44:47.541] Launching 3 futures (chunks) ... DONE
[17:44:47.541] Resolving 3 futures (chunks) ...
[17:44:47.541] resolve() on list ...
[17:44:47.542]  recursive: 0
[17:44:47.542]  length: 3
[17:44:47.542] 
[17:44:47.542] Future #1
[17:44:47.542] result() for MulticoreFuture ...
[17:44:47.542] result() for MulticoreFuture ... done
[17:44:47.542] result() for MulticoreFuture ...
[17:44:47.543] result() for MulticoreFuture ... done
[17:44:47.543] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.543] - nx: 3
[17:44:47.543] - relay: TRUE
[17:44:47.543] - stdout: TRUE
[17:44:47.543] - signal: TRUE
[17:44:47.543] - resignal: FALSE
[17:44:47.544] - force: TRUE
[17:44:47.544] - relayed: [n=3] FALSE, FALSE, FALSE
[17:44:47.548] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:44:47.548]  - until=1
[17:44:47.549]  - relaying element #1
[17:44:47.549] result() for MulticoreFuture ...
[17:44:47.549] result() for MulticoreFuture ... done
[17:44:47.550] result() for MulticoreFuture ...
[17:44:47.550] result() for MulticoreFuture ... done
[17:44:47.550] result() for MulticoreFuture ...
[17:44:47.551] result() for MulticoreFuture ... done
[17:44:47.551] result() for MulticoreFuture ...
[17:44:47.551] result() for MulticoreFuture ... done
[17:44:47.552] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:47.552] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:47.552] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.552]  length: 2 (resolved future 1)
[17:44:47.553] Future #2
[17:44:47.553] result() for MulticoreFuture ...
[17:44:47.554] result() for MulticoreFuture ...
[17:44:47.555] result() for MulticoreFuture ... done
[17:44:47.555] result() for MulticoreFuture ... done
[17:44:47.555] result() for MulticoreFuture ...
[17:44:47.555] result() for MulticoreFuture ... done
[17:44:47.556] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.556] - nx: 3
[17:44:47.556] - relay: TRUE
[17:44:47.556] - stdout: TRUE
[17:44:47.556] - signal: TRUE
[17:44:47.556] - resignal: FALSE
[17:44:47.557] - force: TRUE
[17:44:47.557] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:47.557] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:47.557]  - until=2
[17:44:47.557]  - relaying element #2
[17:44:47.558] result() for MulticoreFuture ...
[17:44:47.558] result() for MulticoreFuture ... done
[17:44:47.558] result() for MulticoreFuture ...
[17:44:47.558] result() for MulticoreFuture ... done
[17:44:47.558] result() for MulticoreFuture ...
[17:44:47.559] result() for MulticoreFuture ... done
[17:44:47.559] result() for MulticoreFuture ...
[17:44:47.559] result() for MulticoreFuture ... done
[17:44:47.559] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:47.559] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:47.560] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.560]  length: 1 (resolved future 2)
[17:44:47.560] Future #3
[17:44:47.560] result() for MulticoreFuture ...
[17:44:47.561] result() for MulticoreFuture ...
[17:44:47.561] result() for MulticoreFuture ... done
[17:44:47.561] result() for MulticoreFuture ... done
[17:44:47.561] result() for MulticoreFuture ...
[17:44:47.561] result() for MulticoreFuture ... done
[17:44:47.562] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:44:47.562] - nx: 3
[17:44:47.562] - relay: TRUE
[17:44:47.562] - stdout: TRUE
[17:44:47.562] - signal: TRUE
[17:44:47.562] - resignal: FALSE
[17:44:47.562] - force: TRUE
[17:44:47.562] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:47.562] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:47.563]  - until=3
[17:44:47.563]  - relaying element #3
[17:44:47.563] result() for MulticoreFuture ...
[17:44:47.563] result() for MulticoreFuture ... done
[17:44:47.563] result() for MulticoreFuture ...
[17:44:47.563] result() for MulticoreFuture ... done
[17:44:47.563] result() for MulticoreFuture ...
[17:44:47.564] result() for MulticoreFuture ... done
[17:44:47.564] result() for MulticoreFuture ...
[17:44:47.564] result() for MulticoreFuture ... done
[17:44:47.564] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:47.564] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:47.564] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:44:47.564]  length: 0 (resolved future 3)
[17:44:47.564] Relaying remaining futures
[17:44:47.564] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.565] - nx: 3
[17:44:47.565] - relay: TRUE
[17:44:47.565] - stdout: TRUE
[17:44:47.565] - signal: TRUE
[17:44:47.565] - resignal: FALSE
[17:44:47.565] - force: TRUE
[17:44:47.565] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:47.565] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:44:47.565] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:47.565] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:47.566] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.566] resolve() on list ... DONE
[17:44:47.566] result() for MulticoreFuture ...
[17:44:47.566] result() for MulticoreFuture ... done
[17:44:47.566] result() for MulticoreFuture ...
[17:44:47.566] result() for MulticoreFuture ... done
[17:44:47.566] result() for MulticoreFuture ...
[17:44:47.566] result() for MulticoreFuture ... done
[17:44:47.566] result() for MulticoreFuture ...
[17:44:47.566] result() for MulticoreFuture ... done
[17:44:47.567] result() for MulticoreFuture ...
[17:44:47.567] result() for MulticoreFuture ... done
[17:44:47.567] result() for MulticoreFuture ...
[17:44:47.567] result() for MulticoreFuture ... done
[17:44:47.567]  - Number of value chunks collected: 3
[17:44:47.567] Resolving 3 futures (chunks) ... DONE
[17:44:47.567] Reducing values from 3 chunks ...
[17:44:47.567]  - Number of values collected after concatenation: 5
[17:44:47.567]  - Number of values expected: 5
[17:44:47.568] Reverse index remapping (attribute 'ordering'): [n = 5] 1, 4, 5, 2, 3
[17:44:47.568] Reducing values from 3 chunks ... DONE
[17:44:47.568] future_mapply() ... DONE
[17:44:47.568] future_mapply() ...
[17:44:47.572] Number of chunks: 2
[17:44:47.572] getGlobalsAndPackagesXApply() ...
[17:44:47.573]  - future.globals: TRUE
[17:44:47.573] getGlobalsAndPackages() ...
[17:44:47.573] Searching for globals...
[17:44:47.574] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:47.574] Searching for globals ... DONE
[17:44:47.574] Resolving globals: FALSE
[17:44:47.575] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:47.575] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:47.576] - globals: [1] ‘FUN’
[17:44:47.576] 
[17:44:47.577] getGlobalsAndPackages() ... DONE
[17:44:47.577]  - globals found/used: [n=1] ‘FUN’
[17:44:47.577]  - needed namespaces: [n=0] 
[17:44:47.577] Finding globals ... DONE
[17:44:47.577] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.577] List of 2
[17:44:47.577]  $ ...future.FUN:function (C, k)  
[17:44:47.577]  $ MoreArgs     : list()
[17:44:47.577]  - attr(*, "where")=List of 2
[17:44:47.577]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.577]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.577]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.577]  - attr(*, "resolved")= logi FALSE
[17:44:47.577]  - attr(*, "total_size")= num NA
[17:44:47.580] Packages to be attached in all futures: [n=0] 
[17:44:47.580] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.580] Number of futures (= number of chunks): 2
[17:44:47.580] Launching 2 futures (chunks) ...
[17:44:47.580] Chunk #1 of 2 ...
[17:44:47.581]  - Finding globals in '...' for chunk #1 ...
[17:44:47.581] getGlobalsAndPackages() ...
[17:44:47.581] Searching for globals...
[17:44:47.583] 
[17:44:47.583] Searching for globals ... DONE
[17:44:47.584] - globals: [0] <none>
[17:44:47.584] getGlobalsAndPackages() ... DONE
[17:44:47.584]    + additional globals found: [n=0] 
[17:44:47.584]    + additional namespaces needed: [n=0] 
[17:44:47.584]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.584]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.584]  - seeds: <none>
[17:44:47.584]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.585] getGlobalsAndPackages() ...
[17:44:47.585] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.585] Resolving globals: FALSE
[17:44:47.585] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.586] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.586] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.586] 
[17:44:47.586] getGlobalsAndPackages() ... DONE
[17:44:47.587] run() for ‘Future’ ...
[17:44:47.587] - state: ‘created’
[17:44:47.587] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.591] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.591]   - Field: ‘label’
[17:44:47.592]   - Field: ‘local’
[17:44:47.592]   - Field: ‘owner’
[17:44:47.592]   - Field: ‘envir’
[17:44:47.592]   - Field: ‘workers’
[17:44:47.592]   - Field: ‘packages’
[17:44:47.592]   - Field: ‘gc’
[17:44:47.592]   - Field: ‘job’
[17:44:47.592]   - Field: ‘conditions’
[17:44:47.593]   - Field: ‘expr’
[17:44:47.593]   - Field: ‘uuid’
[17:44:47.593]   - Field: ‘seed’
[17:44:47.593]   - Field: ‘version’
[17:44:47.593]   - Field: ‘result’
[17:44:47.593]   - Field: ‘asynchronous’
[17:44:47.593]   - Field: ‘calls’
[17:44:47.593]   - Field: ‘globals’
[17:44:47.593]   - Field: ‘stdout’
[17:44:47.593]   - Field: ‘earlySignal’
[17:44:47.593]   - Field: ‘lazy’
[17:44:47.594]   - Field: ‘state’
[17:44:47.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.594] - Launch lazy future ...
[17:44:47.594] Packages needed by the future expression (n = 0): <none>
[17:44:47.594] Packages needed by future strategies (n = 0): <none>
[17:44:47.595] {
[17:44:47.595]     {
[17:44:47.595]         {
[17:44:47.595]             ...future.startTime <- base::Sys.time()
[17:44:47.595]             {
[17:44:47.595]                 {
[17:44:47.595]                   {
[17:44:47.595]                     {
[17:44:47.595]                       base::local({
[17:44:47.595]                         has_future <- base::requireNamespace("future", 
[17:44:47.595]                           quietly = TRUE)
[17:44:47.595]                         if (has_future) {
[17:44:47.595]                           ns <- base::getNamespace("future")
[17:44:47.595]                           version <- ns[[".package"]][["version"]]
[17:44:47.595]                           if (is.null(version)) 
[17:44:47.595]                             version <- utils::packageVersion("future")
[17:44:47.595]                         }
[17:44:47.595]                         else {
[17:44:47.595]                           version <- NULL
[17:44:47.595]                         }
[17:44:47.595]                         if (!has_future || version < "1.8.0") {
[17:44:47.595]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.595]                             "", base::R.version$version.string), 
[17:44:47.595]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.595]                               "release", "version")], collapse = " "), 
[17:44:47.595]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.595]                             info)
[17:44:47.595]                           info <- base::paste(info, collapse = "; ")
[17:44:47.595]                           if (!has_future) {
[17:44:47.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.595]                               info)
[17:44:47.595]                           }
[17:44:47.595]                           else {
[17:44:47.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.595]                               info, version)
[17:44:47.595]                           }
[17:44:47.595]                           base::stop(msg)
[17:44:47.595]                         }
[17:44:47.595]                       })
[17:44:47.595]                     }
[17:44:47.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.595]                     base::options(mc.cores = 1L)
[17:44:47.595]                   }
[17:44:47.595]                   ...future.strategy.old <- future::plan("list")
[17:44:47.595]                   options(future.plan = NULL)
[17:44:47.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.595]                 }
[17:44:47.595]                 ...future.workdir <- getwd()
[17:44:47.595]             }
[17:44:47.595]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.595]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.595]         }
[17:44:47.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.595]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.595]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.595]             base::names(...future.oldOptions))
[17:44:47.595]     }
[17:44:47.595]     if (FALSE) {
[17:44:47.595]     }
[17:44:47.595]     else {
[17:44:47.595]         if (TRUE) {
[17:44:47.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.595]                 open = "w")
[17:44:47.595]         }
[17:44:47.595]         else {
[17:44:47.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.595]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.595]         }
[17:44:47.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.595]             base::sink(type = "output", split = FALSE)
[17:44:47.595]             base::close(...future.stdout)
[17:44:47.595]         }, add = TRUE)
[17:44:47.595]     }
[17:44:47.595]     ...future.frame <- base::sys.nframe()
[17:44:47.595]     ...future.conditions <- base::list()
[17:44:47.595]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.595]     if (FALSE) {
[17:44:47.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.595]     }
[17:44:47.595]     ...future.result <- base::tryCatch({
[17:44:47.595]         base::withCallingHandlers({
[17:44:47.595]             ...future.value <- base::withVisible(base::local({
[17:44:47.595]                 withCallingHandlers({
[17:44:47.595]                   {
[17:44:47.595]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.595]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.595]                       ...future.globals.maxSize)) {
[17:44:47.595]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.595]                       on.exit(options(oopts), add = TRUE)
[17:44:47.595]                     }
[17:44:47.595]                     {
[17:44:47.595]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.595]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.595]                         USE.NAMES = FALSE)
[17:44:47.595]                       do.call(mapply, args = args)
[17:44:47.595]                     }
[17:44:47.595]                   }
[17:44:47.595]                 }, immediateCondition = function(cond) {
[17:44:47.595]                   save_rds <- function (object, pathname, ...) 
[17:44:47.595]                   {
[17:44:47.595]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.595]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.595]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.595]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.595]                         fi_tmp[["mtime"]])
[17:44:47.595]                     }
[17:44:47.595]                     tryCatch({
[17:44:47.595]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.595]                     }, error = function(ex) {
[17:44:47.595]                       msg <- conditionMessage(ex)
[17:44:47.595]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.595]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.595]                         fi_tmp[["mtime"]], msg)
[17:44:47.595]                       ex$message <- msg
[17:44:47.595]                       stop(ex)
[17:44:47.595]                     })
[17:44:47.595]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.595]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.595]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.595]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.595]                       fi <- file.info(pathname)
[17:44:47.595]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.595]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.595]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.595]                         fi[["size"]], fi[["mtime"]])
[17:44:47.595]                       stop(msg)
[17:44:47.595]                     }
[17:44:47.595]                     invisible(pathname)
[17:44:47.595]                   }
[17:44:47.595]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.595]                     rootPath = tempdir()) 
[17:44:47.595]                   {
[17:44:47.595]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.595]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.595]                       tmpdir = path, fileext = ".rds")
[17:44:47.595]                     save_rds(obj, file)
[17:44:47.595]                   }
[17:44:47.595]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.595]                   {
[17:44:47.595]                     inherits <- base::inherits
[17:44:47.595]                     invokeRestart <- base::invokeRestart
[17:44:47.595]                     is.null <- base::is.null
[17:44:47.595]                     muffled <- FALSE
[17:44:47.595]                     if (inherits(cond, "message")) {
[17:44:47.595]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.595]                       if (muffled) 
[17:44:47.595]                         invokeRestart("muffleMessage")
[17:44:47.595]                     }
[17:44:47.595]                     else if (inherits(cond, "warning")) {
[17:44:47.595]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.595]                       if (muffled) 
[17:44:47.595]                         invokeRestart("muffleWarning")
[17:44:47.595]                     }
[17:44:47.595]                     else if (inherits(cond, "condition")) {
[17:44:47.595]                       if (!is.null(pattern)) {
[17:44:47.595]                         computeRestarts <- base::computeRestarts
[17:44:47.595]                         grepl <- base::grepl
[17:44:47.595]                         restarts <- computeRestarts(cond)
[17:44:47.595]                         for (restart in restarts) {
[17:44:47.595]                           name <- restart$name
[17:44:47.595]                           if (is.null(name)) 
[17:44:47.595]                             next
[17:44:47.595]                           if (!grepl(pattern, name)) 
[17:44:47.595]                             next
[17:44:47.595]                           invokeRestart(restart)
[17:44:47.595]                           muffled <- TRUE
[17:44:47.595]                           break
[17:44:47.595]                         }
[17:44:47.595]                       }
[17:44:47.595]                     }
[17:44:47.595]                     invisible(muffled)
[17:44:47.595]                   }
[17:44:47.595]                   muffleCondition(cond)
[17:44:47.595]                 })
[17:44:47.595]             }))
[17:44:47.595]             future::FutureResult(value = ...future.value$value, 
[17:44:47.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.595]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.595]                     ...future.globalenv.names))
[17:44:47.595]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.595]         }, condition = base::local({
[17:44:47.595]             c <- base::c
[17:44:47.595]             inherits <- base::inherits
[17:44:47.595]             invokeRestart <- base::invokeRestart
[17:44:47.595]             length <- base::length
[17:44:47.595]             list <- base::list
[17:44:47.595]             seq.int <- base::seq.int
[17:44:47.595]             signalCondition <- base::signalCondition
[17:44:47.595]             sys.calls <- base::sys.calls
[17:44:47.595]             `[[` <- base::`[[`
[17:44:47.595]             `+` <- base::`+`
[17:44:47.595]             `<<-` <- base::`<<-`
[17:44:47.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.595]                   3L)]
[17:44:47.595]             }
[17:44:47.595]             function(cond) {
[17:44:47.595]                 is_error <- inherits(cond, "error")
[17:44:47.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.595]                   NULL)
[17:44:47.595]                 if (is_error) {
[17:44:47.595]                   sessionInformation <- function() {
[17:44:47.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.595]                       search = base::search(), system = base::Sys.info())
[17:44:47.595]                   }
[17:44:47.595]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.595]                     cond$call), session = sessionInformation(), 
[17:44:47.595]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.595]                   signalCondition(cond)
[17:44:47.595]                 }
[17:44:47.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.595]                 "immediateCondition"))) {
[17:44:47.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.595]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.595]                   if (TRUE && !signal) {
[17:44:47.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.595]                     {
[17:44:47.595]                       inherits <- base::inherits
[17:44:47.595]                       invokeRestart <- base::invokeRestart
[17:44:47.595]                       is.null <- base::is.null
[17:44:47.595]                       muffled <- FALSE
[17:44:47.595]                       if (inherits(cond, "message")) {
[17:44:47.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.595]                         if (muffled) 
[17:44:47.595]                           invokeRestart("muffleMessage")
[17:44:47.595]                       }
[17:44:47.595]                       else if (inherits(cond, "warning")) {
[17:44:47.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.595]                         if (muffled) 
[17:44:47.595]                           invokeRestart("muffleWarning")
[17:44:47.595]                       }
[17:44:47.595]                       else if (inherits(cond, "condition")) {
[17:44:47.595]                         if (!is.null(pattern)) {
[17:44:47.595]                           computeRestarts <- base::computeRestarts
[17:44:47.595]                           grepl <- base::grepl
[17:44:47.595]                           restarts <- computeRestarts(cond)
[17:44:47.595]                           for (restart in restarts) {
[17:44:47.595]                             name <- restart$name
[17:44:47.595]                             if (is.null(name)) 
[17:44:47.595]                               next
[17:44:47.595]                             if (!grepl(pattern, name)) 
[17:44:47.595]                               next
[17:44:47.595]                             invokeRestart(restart)
[17:44:47.595]                             muffled <- TRUE
[17:44:47.595]                             break
[17:44:47.595]                           }
[17:44:47.595]                         }
[17:44:47.595]                       }
[17:44:47.595]                       invisible(muffled)
[17:44:47.595]                     }
[17:44:47.595]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.595]                   }
[17:44:47.595]                 }
[17:44:47.595]                 else {
[17:44:47.595]                   if (TRUE) {
[17:44:47.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.595]                     {
[17:44:47.595]                       inherits <- base::inherits
[17:44:47.595]                       invokeRestart <- base::invokeRestart
[17:44:47.595]                       is.null <- base::is.null
[17:44:47.595]                       muffled <- FALSE
[17:44:47.595]                       if (inherits(cond, "message")) {
[17:44:47.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.595]                         if (muffled) 
[17:44:47.595]                           invokeRestart("muffleMessage")
[17:44:47.595]                       }
[17:44:47.595]                       else if (inherits(cond, "warning")) {
[17:44:47.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.595]                         if (muffled) 
[17:44:47.595]                           invokeRestart("muffleWarning")
[17:44:47.595]                       }
[17:44:47.595]                       else if (inherits(cond, "condition")) {
[17:44:47.595]                         if (!is.null(pattern)) {
[17:44:47.595]                           computeRestarts <- base::computeRestarts
[17:44:47.595]                           grepl <- base::grepl
[17:44:47.595]                           restarts <- computeRestarts(cond)
[17:44:47.595]                           for (restart in restarts) {
[17:44:47.595]                             name <- restart$name
[17:44:47.595]                             if (is.null(name)) 
[17:44:47.595]                               next
[17:44:47.595]                             if (!grepl(pattern, name)) 
[17:44:47.595]                               next
[17:44:47.595]                             invokeRestart(restart)
[17:44:47.595]                             muffled <- TRUE
[17:44:47.595]                             break
[17:44:47.595]                           }
[17:44:47.595]                         }
[17:44:47.595]                       }
[17:44:47.595]                       invisible(muffled)
[17:44:47.595]                     }
[17:44:47.595]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.595]                   }
[17:44:47.595]                 }
[17:44:47.595]             }
[17:44:47.595]         }))
[17:44:47.595]     }, error = function(ex) {
[17:44:47.595]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.595]                 ...future.rng), started = ...future.startTime, 
[17:44:47.595]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.595]             version = "1.8"), class = "FutureResult")
[17:44:47.595]     }, finally = {
[17:44:47.595]         if (!identical(...future.workdir, getwd())) 
[17:44:47.595]             setwd(...future.workdir)
[17:44:47.595]         {
[17:44:47.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.595]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.595]             }
[17:44:47.595]             base::options(...future.oldOptions)
[17:44:47.595]             if (.Platform$OS.type == "windows") {
[17:44:47.595]                 old_names <- names(...future.oldEnvVars)
[17:44:47.595]                 envs <- base::Sys.getenv()
[17:44:47.595]                 names <- names(envs)
[17:44:47.595]                 common <- intersect(names, old_names)
[17:44:47.595]                 added <- setdiff(names, old_names)
[17:44:47.595]                 removed <- setdiff(old_names, names)
[17:44:47.595]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.595]                   envs[common]]
[17:44:47.595]                 NAMES <- toupper(changed)
[17:44:47.595]                 args <- list()
[17:44:47.595]                 for (kk in seq_along(NAMES)) {
[17:44:47.595]                   name <- changed[[kk]]
[17:44:47.595]                   NAME <- NAMES[[kk]]
[17:44:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.595]                     next
[17:44:47.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.595]                 }
[17:44:47.595]                 NAMES <- toupper(added)
[17:44:47.595]                 for (kk in seq_along(NAMES)) {
[17:44:47.595]                   name <- added[[kk]]
[17:44:47.595]                   NAME <- NAMES[[kk]]
[17:44:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.595]                     next
[17:44:47.595]                   args[[name]] <- ""
[17:44:47.595]                 }
[17:44:47.595]                 NAMES <- toupper(removed)
[17:44:47.595]                 for (kk in seq_along(NAMES)) {
[17:44:47.595]                   name <- removed[[kk]]
[17:44:47.595]                   NAME <- NAMES[[kk]]
[17:44:47.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.595]                     next
[17:44:47.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.595]                 }
[17:44:47.595]                 if (length(args) > 0) 
[17:44:47.595]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.595]             }
[17:44:47.595]             else {
[17:44:47.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.595]             }
[17:44:47.595]             {
[17:44:47.595]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.595]                   0L) {
[17:44:47.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.595]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.595]                   base::options(opts)
[17:44:47.595]                 }
[17:44:47.595]                 {
[17:44:47.595]                   {
[17:44:47.595]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.595]                     NULL
[17:44:47.595]                   }
[17:44:47.595]                   options(future.plan = NULL)
[17:44:47.595]                   if (is.na(NA_character_)) 
[17:44:47.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.595]                     .init = FALSE)
[17:44:47.595]                 }
[17:44:47.595]             }
[17:44:47.595]         }
[17:44:47.595]     })
[17:44:47.595]     if (TRUE) {
[17:44:47.595]         base::sink(type = "output", split = FALSE)
[17:44:47.595]         if (TRUE) {
[17:44:47.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.595]         }
[17:44:47.595]         else {
[17:44:47.595]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.595]         }
[17:44:47.595]         base::close(...future.stdout)
[17:44:47.595]         ...future.stdout <- NULL
[17:44:47.595]     }
[17:44:47.595]     ...future.result$conditions <- ...future.conditions
[17:44:47.595]     ...future.result$finished <- base::Sys.time()
[17:44:47.595]     ...future.result
[17:44:47.595] }
[17:44:47.597] assign_globals() ...
[17:44:47.597] List of 5
[17:44:47.597]  $ ...future.FUN            :function (C, k)  
[17:44:47.597]  $ MoreArgs                 : list()
[17:44:47.597]  $ ...future.elements_ii    :List of 2
[17:44:47.597]   ..$ :List of 2
[17:44:47.597]   .. ..$ : chr "A"
[17:44:47.597]   .. ..$ : chr "B"
[17:44:47.597]   ..$ :List of 2
[17:44:47.597]   .. ..$ : int 5
[17:44:47.597]   .. ..$ : int 4
[17:44:47.597]  $ ...future.seeds_ii       : NULL
[17:44:47.597]  $ ...future.globals.maxSize: NULL
[17:44:47.597]  - attr(*, "where")=List of 5
[17:44:47.597]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.597]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.597]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.597]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.597]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.597]  - attr(*, "resolved")= logi FALSE
[17:44:47.597]  - attr(*, "total_size")= num 3656
[17:44:47.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.597]  - attr(*, "already-done")= logi TRUE
[17:44:47.603] - reassign environment for ‘...future.FUN’
[17:44:47.603] - copied ‘...future.FUN’ to environment
[17:44:47.603] - copied ‘MoreArgs’ to environment
[17:44:47.603] - copied ‘...future.elements_ii’ to environment
[17:44:47.603] - copied ‘...future.seeds_ii’ to environment
[17:44:47.603] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.604] assign_globals() ... done
[17:44:47.604] requestCore(): workers = 2
[17:44:47.606] MulticoreFuture started
[17:44:47.606] - Launch lazy future ... done
[17:44:47.607] run() for ‘MulticoreFuture’ ... done
[17:44:47.607] Created future:
[17:44:47.607] plan(): Setting new future strategy stack:
[17:44:47.607] List of future strategies:
[17:44:47.607] 1. sequential:
[17:44:47.607]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.607]    - tweaked: FALSE
[17:44:47.607]    - call: NULL
[17:44:47.608] plan(): nbrOfWorkers() = 1
[17:44:47.611] plan(): Setting new future strategy stack:
[17:44:47.611] List of future strategies:
[17:44:47.611] 1. multicore:
[17:44:47.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.611]    - tweaked: FALSE
[17:44:47.611]    - call: plan(strategy)
[17:44:47.616] plan(): nbrOfWorkers() = 2
[17:44:47.607] MulticoreFuture:
[17:44:47.607] Label: ‘future_.mapply-1’
[17:44:47.607] Expression:
[17:44:47.607] {
[17:44:47.607]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.607]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.607]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.607]         on.exit(options(oopts), add = TRUE)
[17:44:47.607]     }
[17:44:47.607]     {
[17:44:47.607]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.607]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.607]         do.call(mapply, args = args)
[17:44:47.607]     }
[17:44:47.607] }
[17:44:47.607] Lazy evaluation: FALSE
[17:44:47.607] Asynchronous evaluation: TRUE
[17:44:47.607] Local evaluation: TRUE
[17:44:47.607] Environment: R_GlobalEnv
[17:44:47.607] Capture standard output: TRUE
[17:44:47.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.607] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.607] Packages: <none>
[17:44:47.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.607] Resolved: TRUE
[17:44:47.607] Value: <not collected>
[17:44:47.607] Conditions captured: <none>
[17:44:47.607] Early signaling: FALSE
[17:44:47.607] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.607] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.617] Chunk #1 of 2 ... DONE
[17:44:47.618] Chunk #2 of 2 ...
[17:44:47.618]  - Finding globals in '...' for chunk #2 ...
[17:44:47.618] getGlobalsAndPackages() ...
[17:44:47.618] Searching for globals...
[17:44:47.619] 
[17:44:47.619] Searching for globals ... DONE
[17:44:47.619] - globals: [0] <none>
[17:44:47.619] getGlobalsAndPackages() ... DONE
[17:44:47.619]    + additional globals found: [n=0] 
[17:44:47.619]    + additional namespaces needed: [n=0] 
[17:44:47.620]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:47.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.620]  - seeds: <none>
[17:44:47.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.620] getGlobalsAndPackages() ...
[17:44:47.620] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.621] Resolving globals: FALSE
[17:44:47.621] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:47.622] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.622] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.623] 
[17:44:47.623] getGlobalsAndPackages() ... DONE
[17:44:47.623] run() for ‘Future’ ...
[17:44:47.624] - state: ‘created’
[17:44:47.624] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.634]   - Field: ‘label’
[17:44:47.634]   - Field: ‘local’
[17:44:47.635]   - Field: ‘owner’
[17:44:47.635]   - Field: ‘envir’
[17:44:47.635]   - Field: ‘workers’
[17:44:47.635]   - Field: ‘packages’
[17:44:47.636]   - Field: ‘gc’
[17:44:47.636]   - Field: ‘job’
[17:44:47.636]   - Field: ‘conditions’
[17:44:47.636]   - Field: ‘expr’
[17:44:47.637]   - Field: ‘uuid’
[17:44:47.637]   - Field: ‘seed’
[17:44:47.637]   - Field: ‘version’
[17:44:47.637]   - Field: ‘result’
[17:44:47.637]   - Field: ‘asynchronous’
[17:44:47.638]   - Field: ‘calls’
[17:44:47.638]   - Field: ‘globals’
[17:44:47.638]   - Field: ‘stdout’
[17:44:47.638]   - Field: ‘earlySignal’
[17:44:47.638]   - Field: ‘lazy’
[17:44:47.639]   - Field: ‘state’
[17:44:47.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.639] - Launch lazy future ...
[17:44:47.640] Packages needed by the future expression (n = 0): <none>
[17:44:47.640] Packages needed by future strategies (n = 0): <none>
[17:44:47.641] {
[17:44:47.641]     {
[17:44:47.641]         {
[17:44:47.641]             ...future.startTime <- base::Sys.time()
[17:44:47.641]             {
[17:44:47.641]                 {
[17:44:47.641]                   {
[17:44:47.641]                     {
[17:44:47.641]                       base::local({
[17:44:47.641]                         has_future <- base::requireNamespace("future", 
[17:44:47.641]                           quietly = TRUE)
[17:44:47.641]                         if (has_future) {
[17:44:47.641]                           ns <- base::getNamespace("future")
[17:44:47.641]                           version <- ns[[".package"]][["version"]]
[17:44:47.641]                           if (is.null(version)) 
[17:44:47.641]                             version <- utils::packageVersion("future")
[17:44:47.641]                         }
[17:44:47.641]                         else {
[17:44:47.641]                           version <- NULL
[17:44:47.641]                         }
[17:44:47.641]                         if (!has_future || version < "1.8.0") {
[17:44:47.641]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.641]                             "", base::R.version$version.string), 
[17:44:47.641]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.641]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.641]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.641]                               "release", "version")], collapse = " "), 
[17:44:47.641]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.641]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.641]                             info)
[17:44:47.641]                           info <- base::paste(info, collapse = "; ")
[17:44:47.641]                           if (!has_future) {
[17:44:47.641]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.641]                               info)
[17:44:47.641]                           }
[17:44:47.641]                           else {
[17:44:47.641]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.641]                               info, version)
[17:44:47.641]                           }
[17:44:47.641]                           base::stop(msg)
[17:44:47.641]                         }
[17:44:47.641]                       })
[17:44:47.641]                     }
[17:44:47.641]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.641]                     base::options(mc.cores = 1L)
[17:44:47.641]                   }
[17:44:47.641]                   ...future.strategy.old <- future::plan("list")
[17:44:47.641]                   options(future.plan = NULL)
[17:44:47.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.641]                 }
[17:44:47.641]                 ...future.workdir <- getwd()
[17:44:47.641]             }
[17:44:47.641]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.641]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.641]         }
[17:44:47.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.641]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.641]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.641]             base::names(...future.oldOptions))
[17:44:47.641]     }
[17:44:47.641]     if (FALSE) {
[17:44:47.641]     }
[17:44:47.641]     else {
[17:44:47.641]         if (TRUE) {
[17:44:47.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.641]                 open = "w")
[17:44:47.641]         }
[17:44:47.641]         else {
[17:44:47.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.641]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.641]         }
[17:44:47.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.641]             base::sink(type = "output", split = FALSE)
[17:44:47.641]             base::close(...future.stdout)
[17:44:47.641]         }, add = TRUE)
[17:44:47.641]     }
[17:44:47.641]     ...future.frame <- base::sys.nframe()
[17:44:47.641]     ...future.conditions <- base::list()
[17:44:47.641]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.641]     if (FALSE) {
[17:44:47.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.641]     }
[17:44:47.641]     ...future.result <- base::tryCatch({
[17:44:47.641]         base::withCallingHandlers({
[17:44:47.641]             ...future.value <- base::withVisible(base::local({
[17:44:47.641]                 withCallingHandlers({
[17:44:47.641]                   {
[17:44:47.641]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.641]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.641]                       ...future.globals.maxSize)) {
[17:44:47.641]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.641]                       on.exit(options(oopts), add = TRUE)
[17:44:47.641]                     }
[17:44:47.641]                     {
[17:44:47.641]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.641]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.641]                         USE.NAMES = FALSE)
[17:44:47.641]                       do.call(mapply, args = args)
[17:44:47.641]                     }
[17:44:47.641]                   }
[17:44:47.641]                 }, immediateCondition = function(cond) {
[17:44:47.641]                   save_rds <- function (object, pathname, ...) 
[17:44:47.641]                   {
[17:44:47.641]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.641]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.641]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.641]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.641]                         fi_tmp[["mtime"]])
[17:44:47.641]                     }
[17:44:47.641]                     tryCatch({
[17:44:47.641]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.641]                     }, error = function(ex) {
[17:44:47.641]                       msg <- conditionMessage(ex)
[17:44:47.641]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.641]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.641]                         fi_tmp[["mtime"]], msg)
[17:44:47.641]                       ex$message <- msg
[17:44:47.641]                       stop(ex)
[17:44:47.641]                     })
[17:44:47.641]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.641]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.641]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.641]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.641]                       fi <- file.info(pathname)
[17:44:47.641]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.641]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.641]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.641]                         fi[["size"]], fi[["mtime"]])
[17:44:47.641]                       stop(msg)
[17:44:47.641]                     }
[17:44:47.641]                     invisible(pathname)
[17:44:47.641]                   }
[17:44:47.641]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.641]                     rootPath = tempdir()) 
[17:44:47.641]                   {
[17:44:47.641]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.641]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.641]                       tmpdir = path, fileext = ".rds")
[17:44:47.641]                     save_rds(obj, file)
[17:44:47.641]                   }
[17:44:47.641]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.641]                   {
[17:44:47.641]                     inherits <- base::inherits
[17:44:47.641]                     invokeRestart <- base::invokeRestart
[17:44:47.641]                     is.null <- base::is.null
[17:44:47.641]                     muffled <- FALSE
[17:44:47.641]                     if (inherits(cond, "message")) {
[17:44:47.641]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.641]                       if (muffled) 
[17:44:47.641]                         invokeRestart("muffleMessage")
[17:44:47.641]                     }
[17:44:47.641]                     else if (inherits(cond, "warning")) {
[17:44:47.641]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.641]                       if (muffled) 
[17:44:47.641]                         invokeRestart("muffleWarning")
[17:44:47.641]                     }
[17:44:47.641]                     else if (inherits(cond, "condition")) {
[17:44:47.641]                       if (!is.null(pattern)) {
[17:44:47.641]                         computeRestarts <- base::computeRestarts
[17:44:47.641]                         grepl <- base::grepl
[17:44:47.641]                         restarts <- computeRestarts(cond)
[17:44:47.641]                         for (restart in restarts) {
[17:44:47.641]                           name <- restart$name
[17:44:47.641]                           if (is.null(name)) 
[17:44:47.641]                             next
[17:44:47.641]                           if (!grepl(pattern, name)) 
[17:44:47.641]                             next
[17:44:47.641]                           invokeRestart(restart)
[17:44:47.641]                           muffled <- TRUE
[17:44:47.641]                           break
[17:44:47.641]                         }
[17:44:47.641]                       }
[17:44:47.641]                     }
[17:44:47.641]                     invisible(muffled)
[17:44:47.641]                   }
[17:44:47.641]                   muffleCondition(cond)
[17:44:47.641]                 })
[17:44:47.641]             }))
[17:44:47.641]             future::FutureResult(value = ...future.value$value, 
[17:44:47.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.641]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.641]                     ...future.globalenv.names))
[17:44:47.641]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.641]         }, condition = base::local({
[17:44:47.641]             c <- base::c
[17:44:47.641]             inherits <- base::inherits
[17:44:47.641]             invokeRestart <- base::invokeRestart
[17:44:47.641]             length <- base::length
[17:44:47.641]             list <- base::list
[17:44:47.641]             seq.int <- base::seq.int
[17:44:47.641]             signalCondition <- base::signalCondition
[17:44:47.641]             sys.calls <- base::sys.calls
[17:44:47.641]             `[[` <- base::`[[`
[17:44:47.641]             `+` <- base::`+`
[17:44:47.641]             `<<-` <- base::`<<-`
[17:44:47.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.641]                   3L)]
[17:44:47.641]             }
[17:44:47.641]             function(cond) {
[17:44:47.641]                 is_error <- inherits(cond, "error")
[17:44:47.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.641]                   NULL)
[17:44:47.641]                 if (is_error) {
[17:44:47.641]                   sessionInformation <- function() {
[17:44:47.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.641]                       search = base::search(), system = base::Sys.info())
[17:44:47.641]                   }
[17:44:47.641]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.641]                     cond$call), session = sessionInformation(), 
[17:44:47.641]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.641]                   signalCondition(cond)
[17:44:47.641]                 }
[17:44:47.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.641]                 "immediateCondition"))) {
[17:44:47.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.641]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.641]                   if (TRUE && !signal) {
[17:44:47.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.641]                     {
[17:44:47.641]                       inherits <- base::inherits
[17:44:47.641]                       invokeRestart <- base::invokeRestart
[17:44:47.641]                       is.null <- base::is.null
[17:44:47.641]                       muffled <- FALSE
[17:44:47.641]                       if (inherits(cond, "message")) {
[17:44:47.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.641]                         if (muffled) 
[17:44:47.641]                           invokeRestart("muffleMessage")
[17:44:47.641]                       }
[17:44:47.641]                       else if (inherits(cond, "warning")) {
[17:44:47.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.641]                         if (muffled) 
[17:44:47.641]                           invokeRestart("muffleWarning")
[17:44:47.641]                       }
[17:44:47.641]                       else if (inherits(cond, "condition")) {
[17:44:47.641]                         if (!is.null(pattern)) {
[17:44:47.641]                           computeRestarts <- base::computeRestarts
[17:44:47.641]                           grepl <- base::grepl
[17:44:47.641]                           restarts <- computeRestarts(cond)
[17:44:47.641]                           for (restart in restarts) {
[17:44:47.641]                             name <- restart$name
[17:44:47.641]                             if (is.null(name)) 
[17:44:47.641]                               next
[17:44:47.641]                             if (!grepl(pattern, name)) 
[17:44:47.641]                               next
[17:44:47.641]                             invokeRestart(restart)
[17:44:47.641]                             muffled <- TRUE
[17:44:47.641]                             break
[17:44:47.641]                           }
[17:44:47.641]                         }
[17:44:47.641]                       }
[17:44:47.641]                       invisible(muffled)
[17:44:47.641]                     }
[17:44:47.641]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.641]                   }
[17:44:47.641]                 }
[17:44:47.641]                 else {
[17:44:47.641]                   if (TRUE) {
[17:44:47.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.641]                     {
[17:44:47.641]                       inherits <- base::inherits
[17:44:47.641]                       invokeRestart <- base::invokeRestart
[17:44:47.641]                       is.null <- base::is.null
[17:44:47.641]                       muffled <- FALSE
[17:44:47.641]                       if (inherits(cond, "message")) {
[17:44:47.641]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.641]                         if (muffled) 
[17:44:47.641]                           invokeRestart("muffleMessage")
[17:44:47.641]                       }
[17:44:47.641]                       else if (inherits(cond, "warning")) {
[17:44:47.641]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.641]                         if (muffled) 
[17:44:47.641]                           invokeRestart("muffleWarning")
[17:44:47.641]                       }
[17:44:47.641]                       else if (inherits(cond, "condition")) {
[17:44:47.641]                         if (!is.null(pattern)) {
[17:44:47.641]                           computeRestarts <- base::computeRestarts
[17:44:47.641]                           grepl <- base::grepl
[17:44:47.641]                           restarts <- computeRestarts(cond)
[17:44:47.641]                           for (restart in restarts) {
[17:44:47.641]                             name <- restart$name
[17:44:47.641]                             if (is.null(name)) 
[17:44:47.641]                               next
[17:44:47.641]                             if (!grepl(pattern, name)) 
[17:44:47.641]                               next
[17:44:47.641]                             invokeRestart(restart)
[17:44:47.641]                             muffled <- TRUE
[17:44:47.641]                             break
[17:44:47.641]                           }
[17:44:47.641]                         }
[17:44:47.641]                       }
[17:44:47.641]                       invisible(muffled)
[17:44:47.641]                     }
[17:44:47.641]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.641]                   }
[17:44:47.641]                 }
[17:44:47.641]             }
[17:44:47.641]         }))
[17:44:47.641]     }, error = function(ex) {
[17:44:47.641]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.641]                 ...future.rng), started = ...future.startTime, 
[17:44:47.641]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.641]             version = "1.8"), class = "FutureResult")
[17:44:47.641]     }, finally = {
[17:44:47.641]         if (!identical(...future.workdir, getwd())) 
[17:44:47.641]             setwd(...future.workdir)
[17:44:47.641]         {
[17:44:47.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.641]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.641]             }
[17:44:47.641]             base::options(...future.oldOptions)
[17:44:47.641]             if (.Platform$OS.type == "windows") {
[17:44:47.641]                 old_names <- names(...future.oldEnvVars)
[17:44:47.641]                 envs <- base::Sys.getenv()
[17:44:47.641]                 names <- names(envs)
[17:44:47.641]                 common <- intersect(names, old_names)
[17:44:47.641]                 added <- setdiff(names, old_names)
[17:44:47.641]                 removed <- setdiff(old_names, names)
[17:44:47.641]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.641]                   envs[common]]
[17:44:47.641]                 NAMES <- toupper(changed)
[17:44:47.641]                 args <- list()
[17:44:47.641]                 for (kk in seq_along(NAMES)) {
[17:44:47.641]                   name <- changed[[kk]]
[17:44:47.641]                   NAME <- NAMES[[kk]]
[17:44:47.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.641]                     next
[17:44:47.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.641]                 }
[17:44:47.641]                 NAMES <- toupper(added)
[17:44:47.641]                 for (kk in seq_along(NAMES)) {
[17:44:47.641]                   name <- added[[kk]]
[17:44:47.641]                   NAME <- NAMES[[kk]]
[17:44:47.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.641]                     next
[17:44:47.641]                   args[[name]] <- ""
[17:44:47.641]                 }
[17:44:47.641]                 NAMES <- toupper(removed)
[17:44:47.641]                 for (kk in seq_along(NAMES)) {
[17:44:47.641]                   name <- removed[[kk]]
[17:44:47.641]                   NAME <- NAMES[[kk]]
[17:44:47.641]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.641]                     next
[17:44:47.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.641]                 }
[17:44:47.641]                 if (length(args) > 0) 
[17:44:47.641]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.641]             }
[17:44:47.641]             else {
[17:44:47.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.641]             }
[17:44:47.641]             {
[17:44:47.641]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.641]                   0L) {
[17:44:47.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.641]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.641]                   base::options(opts)
[17:44:47.641]                 }
[17:44:47.641]                 {
[17:44:47.641]                   {
[17:44:47.641]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.641]                     NULL
[17:44:47.641]                   }
[17:44:47.641]                   options(future.plan = NULL)
[17:44:47.641]                   if (is.na(NA_character_)) 
[17:44:47.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.641]                     .init = FALSE)
[17:44:47.641]                 }
[17:44:47.641]             }
[17:44:47.641]         }
[17:44:47.641]     })
[17:44:47.641]     if (TRUE) {
[17:44:47.641]         base::sink(type = "output", split = FALSE)
[17:44:47.641]         if (TRUE) {
[17:44:47.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.641]         }
[17:44:47.641]         else {
[17:44:47.641]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.641]         }
[17:44:47.641]         base::close(...future.stdout)
[17:44:47.641]         ...future.stdout <- NULL
[17:44:47.641]     }
[17:44:47.641]     ...future.result$conditions <- ...future.conditions
[17:44:47.641]     ...future.result$finished <- base::Sys.time()
[17:44:47.641]     ...future.result
[17:44:47.641] }
[17:44:47.644] assign_globals() ...
[17:44:47.644] List of 5
[17:44:47.644]  $ ...future.FUN            :function (C, k)  
[17:44:47.644]  $ MoreArgs                 : list()
[17:44:47.644]  $ ...future.elements_ii    :List of 2
[17:44:47.644]   ..$ :List of 3
[17:44:47.644]   .. ..$ : chr "C"
[17:44:47.644]   .. ..$ : chr "D"
[17:44:47.644]   .. ..$ : chr "E"
[17:44:47.644]   ..$ :List of 3
[17:44:47.644]   .. ..$ : int 3
[17:44:47.644]   .. ..$ : int 2
[17:44:47.644]   .. ..$ : int 1
[17:44:47.644]  $ ...future.seeds_ii       : NULL
[17:44:47.644]  $ ...future.globals.maxSize: NULL
[17:44:47.644]  - attr(*, "where")=List of 5
[17:44:47.644]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.644]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.644]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.644]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.644]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.644]  - attr(*, "resolved")= logi FALSE
[17:44:47.644]  - attr(*, "total_size")= num 3824
[17:44:47.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.644]  - attr(*, "already-done")= logi TRUE
[17:44:47.653] - reassign environment for ‘...future.FUN’
[17:44:47.653] - copied ‘...future.FUN’ to environment
[17:44:47.653] - copied ‘MoreArgs’ to environment
[17:44:47.653] - copied ‘...future.elements_ii’ to environment
[17:44:47.653] - copied ‘...future.seeds_ii’ to environment
[17:44:47.653] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.653] assign_globals() ... done
[17:44:47.653] requestCore(): workers = 2
[17:44:47.656] MulticoreFuture started
[17:44:47.656] - Launch lazy future ... done
[17:44:47.656] run() for ‘MulticoreFuture’ ... done
[17:44:47.657] Created future:
[17:44:47.657] plan(): Setting new future strategy stack:
[17:44:47.657] List of future strategies:
[17:44:47.657] 1. sequential:
[17:44:47.657]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.657]    - tweaked: FALSE
[17:44:47.657]    - call: NULL
[17:44:47.658] plan(): nbrOfWorkers() = 1
[17:44:47.660] plan(): Setting new future strategy stack:
[17:44:47.660] List of future strategies:
[17:44:47.660] 1. multicore:
[17:44:47.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.660]    - tweaked: FALSE
[17:44:47.660]    - call: plan(strategy)
[17:44:47.665] plan(): nbrOfWorkers() = 2
[17:44:47.657] MulticoreFuture:
[17:44:47.657] Label: ‘future_.mapply-2’
[17:44:47.657] Expression:
[17:44:47.657] {
[17:44:47.657]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.657]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.657]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.657]         on.exit(options(oopts), add = TRUE)
[17:44:47.657]     }
[17:44:47.657]     {
[17:44:47.657]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.657]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.657]         do.call(mapply, args = args)
[17:44:47.657]     }
[17:44:47.657] }
[17:44:47.657] Lazy evaluation: FALSE
[17:44:47.657] Asynchronous evaluation: TRUE
[17:44:47.657] Local evaluation: TRUE
[17:44:47.657] Environment: R_GlobalEnv
[17:44:47.657] Capture standard output: TRUE
[17:44:47.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.657] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.657] Packages: <none>
[17:44:47.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.657] Resolved: TRUE
[17:44:47.657] Value: <not collected>
[17:44:47.657] Conditions captured: <none>
[17:44:47.657] Early signaling: FALSE
[17:44:47.657] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.657] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.666] Chunk #2 of 2 ... DONE
[17:44:47.666] Launching 2 futures (chunks) ... DONE
[17:44:47.667] Resolving 2 futures (chunks) ...
[17:44:47.667] resolve() on list ...
[17:44:47.667]  recursive: 0
[17:44:47.667]  length: 2
[17:44:47.667] 
[17:44:47.668] Future #1
[17:44:47.668] result() for MulticoreFuture ...
[17:44:47.669] result() for MulticoreFuture ...
[17:44:47.669] result() for MulticoreFuture ... done
[17:44:47.669] result() for MulticoreFuture ... done
[17:44:47.669] result() for MulticoreFuture ...
[17:44:47.669] result() for MulticoreFuture ... done
[17:44:47.669] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.670] - nx: 2
[17:44:47.670] - relay: TRUE
[17:44:47.670] - stdout: TRUE
[17:44:47.670] - signal: TRUE
[17:44:47.670] - resignal: FALSE
[17:44:47.670] - force: TRUE
[17:44:47.670] - relayed: [n=2] FALSE, FALSE
[17:44:47.671] - queued futures: [n=2] FALSE, FALSE
[17:44:47.671]  - until=1
[17:44:47.671]  - relaying element #1
[17:44:47.671] result() for MulticoreFuture ...
[17:44:47.671] result() for MulticoreFuture ... done
[17:44:47.671] result() for MulticoreFuture ...
[17:44:47.672] result() for MulticoreFuture ... done
[17:44:47.672] result() for MulticoreFuture ...
[17:44:47.672] result() for MulticoreFuture ... done
[17:44:47.672] result() for MulticoreFuture ...
[17:44:47.672] result() for MulticoreFuture ... done
[17:44:47.672] - relayed: [n=2] TRUE, FALSE
[17:44:47.673] - queued futures: [n=2] TRUE, FALSE
[17:44:47.673] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.673]  length: 1 (resolved future 1)
[17:44:47.673] Future #2
[17:44:47.673] result() for MulticoreFuture ...
[17:44:47.674] result() for MulticoreFuture ...
[17:44:47.674] result() for MulticoreFuture ... done
[17:44:47.675] result() for MulticoreFuture ... done
[17:44:47.675] result() for MulticoreFuture ...
[17:44:47.675] result() for MulticoreFuture ... done
[17:44:47.675] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.675] - nx: 2
[17:44:47.676] - relay: TRUE
[17:44:47.676] - stdout: TRUE
[17:44:47.676] - signal: TRUE
[17:44:47.676] - resignal: FALSE
[17:44:47.676] - force: TRUE
[17:44:47.676] - relayed: [n=2] TRUE, FALSE
[17:44:47.677] - queued futures: [n=2] TRUE, FALSE
[17:44:47.677]  - until=2
[17:44:47.677]  - relaying element #2
[17:44:47.677] result() for MulticoreFuture ...
[17:44:47.677] result() for MulticoreFuture ... done
[17:44:47.677] result() for MulticoreFuture ...
[17:44:47.678] result() for MulticoreFuture ... done
[17:44:47.681] result() for MulticoreFuture ...
[17:44:47.681] result() for MulticoreFuture ... done
[17:44:47.681] result() for MulticoreFuture ...
[17:44:47.681] result() for MulticoreFuture ... done
[17:44:47.681] - relayed: [n=2] TRUE, TRUE
[17:44:47.681] - queued futures: [n=2] TRUE, TRUE
[17:44:47.682] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.682]  length: 0 (resolved future 2)
[17:44:47.682] Relaying remaining futures
[17:44:47.682] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.682] - nx: 2
[17:44:47.683] - relay: TRUE
[17:44:47.683] - stdout: TRUE
[17:44:47.683] - signal: TRUE
[17:44:47.683] - resignal: FALSE
[17:44:47.683] - force: TRUE
[17:44:47.683] - relayed: [n=2] TRUE, TRUE
[17:44:47.683] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:47.684] - relayed: [n=2] TRUE, TRUE
[17:44:47.684] - queued futures: [n=2] TRUE, TRUE
[17:44:47.684] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.684] resolve() on list ... DONE
[17:44:47.684] result() for MulticoreFuture ...
[17:44:47.684] result() for MulticoreFuture ... done
[17:44:47.685] result() for MulticoreFuture ...
[17:44:47.685] result() for MulticoreFuture ... done
[17:44:47.685] result() for MulticoreFuture ...
[17:44:47.685] result() for MulticoreFuture ... done
[17:44:47.685] result() for MulticoreFuture ...
[17:44:47.685] result() for MulticoreFuture ... done
[17:44:47.686]  - Number of value chunks collected: 2
[17:44:47.686] Resolving 2 futures (chunks) ... DONE
[17:44:47.686] Reducing values from 2 chunks ...
[17:44:47.686]  - Number of values collected after concatenation: 5
[17:44:47.686]  - Number of values expected: 5
[17:44:47.686] Reducing values from 2 chunks ... DONE
[17:44:47.686] future_mapply() ... DONE
[17:44:47.687] future_mapply() ...
[17:44:47.691] Number of chunks: 2
[17:44:47.691] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:47.692] getGlobalsAndPackagesXApply() ...
[17:44:47.692]  - future.globals: TRUE
[17:44:47.692] getGlobalsAndPackages() ...
[17:44:47.692] Searching for globals...
[17:44:47.693] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:47.694] Searching for globals ... DONE
[17:44:47.694] Resolving globals: FALSE
[17:44:47.694] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:47.695] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:47.695] - globals: [1] ‘FUN’
[17:44:47.695] 
[17:44:47.695] getGlobalsAndPackages() ... DONE
[17:44:47.695]  - globals found/used: [n=1] ‘FUN’
[17:44:47.695]  - needed namespaces: [n=0] 
[17:44:47.695] Finding globals ... DONE
[17:44:47.696] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.696] List of 2
[17:44:47.696]  $ ...future.FUN:function (C, k)  
[17:44:47.696]  $ MoreArgs     : NULL
[17:44:47.696]  - attr(*, "where")=List of 2
[17:44:47.696]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.696]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.696]  - attr(*, "resolved")= logi FALSE
[17:44:47.696]  - attr(*, "total_size")= num NA
[17:44:47.698] Packages to be attached in all futures: [n=0] 
[17:44:47.699] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.699] Number of futures (= number of chunks): 2
[17:44:47.699] Launching 2 futures (chunks) ...
[17:44:47.699] Chunk #1 of 2 ...
[17:44:47.699]  - Finding globals in '...' for chunk #1 ...
[17:44:47.699] getGlobalsAndPackages() ...
[17:44:47.699] Searching for globals...
[17:44:47.700] 
[17:44:47.700] Searching for globals ... DONE
[17:44:47.700] - globals: [0] <none>
[17:44:47.700] getGlobalsAndPackages() ... DONE
[17:44:47.700]    + additional globals found: [n=0] 
[17:44:47.700]    + additional namespaces needed: [n=0] 
[17:44:47.700]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.700]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.701]  - seeds: <none>
[17:44:47.701]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.701] getGlobalsAndPackages() ...
[17:44:47.701] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.701] Resolving globals: FALSE
[17:44:47.701] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.702] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.702] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.702] 
[17:44:47.702] getGlobalsAndPackages() ... DONE
[17:44:47.703] run() for ‘Future’ ...
[17:44:47.703] - state: ‘created’
[17:44:47.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.707]   - Field: ‘label’
[17:44:47.707]   - Field: ‘local’
[17:44:47.707]   - Field: ‘owner’
[17:44:47.707]   - Field: ‘envir’
[17:44:47.707]   - Field: ‘workers’
[17:44:47.707]   - Field: ‘packages’
[17:44:47.707]   - Field: ‘gc’
[17:44:47.708]   - Field: ‘job’
[17:44:47.708]   - Field: ‘conditions’
[17:44:47.708]   - Field: ‘expr’
[17:44:47.708]   - Field: ‘uuid’
[17:44:47.708]   - Field: ‘seed’
[17:44:47.708]   - Field: ‘version’
[17:44:47.708]   - Field: ‘result’
[17:44:47.708]   - Field: ‘asynchronous’
[17:44:47.708]   - Field: ‘calls’
[17:44:47.708]   - Field: ‘globals’
[17:44:47.709]   - Field: ‘stdout’
[17:44:47.709]   - Field: ‘earlySignal’
[17:44:47.709]   - Field: ‘lazy’
[17:44:47.709]   - Field: ‘state’
[17:44:47.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.709] - Launch lazy future ...
[17:44:47.709] Packages needed by the future expression (n = 0): <none>
[17:44:47.709] Packages needed by future strategies (n = 0): <none>
[17:44:47.710] {
[17:44:47.710]     {
[17:44:47.710]         {
[17:44:47.710]             ...future.startTime <- base::Sys.time()
[17:44:47.710]             {
[17:44:47.710]                 {
[17:44:47.710]                   {
[17:44:47.710]                     {
[17:44:47.710]                       base::local({
[17:44:47.710]                         has_future <- base::requireNamespace("future", 
[17:44:47.710]                           quietly = TRUE)
[17:44:47.710]                         if (has_future) {
[17:44:47.710]                           ns <- base::getNamespace("future")
[17:44:47.710]                           version <- ns[[".package"]][["version"]]
[17:44:47.710]                           if (is.null(version)) 
[17:44:47.710]                             version <- utils::packageVersion("future")
[17:44:47.710]                         }
[17:44:47.710]                         else {
[17:44:47.710]                           version <- NULL
[17:44:47.710]                         }
[17:44:47.710]                         if (!has_future || version < "1.8.0") {
[17:44:47.710]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.710]                             "", base::R.version$version.string), 
[17:44:47.710]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.710]                               "release", "version")], collapse = " "), 
[17:44:47.710]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.710]                             info)
[17:44:47.710]                           info <- base::paste(info, collapse = "; ")
[17:44:47.710]                           if (!has_future) {
[17:44:47.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.710]                               info)
[17:44:47.710]                           }
[17:44:47.710]                           else {
[17:44:47.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.710]                               info, version)
[17:44:47.710]                           }
[17:44:47.710]                           base::stop(msg)
[17:44:47.710]                         }
[17:44:47.710]                       })
[17:44:47.710]                     }
[17:44:47.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.710]                     base::options(mc.cores = 1L)
[17:44:47.710]                   }
[17:44:47.710]                   ...future.strategy.old <- future::plan("list")
[17:44:47.710]                   options(future.plan = NULL)
[17:44:47.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.710]                 }
[17:44:47.710]                 ...future.workdir <- getwd()
[17:44:47.710]             }
[17:44:47.710]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.710]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.710]         }
[17:44:47.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.710]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.710]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.710]             base::names(...future.oldOptions))
[17:44:47.710]     }
[17:44:47.710]     if (FALSE) {
[17:44:47.710]     }
[17:44:47.710]     else {
[17:44:47.710]         if (TRUE) {
[17:44:47.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.710]                 open = "w")
[17:44:47.710]         }
[17:44:47.710]         else {
[17:44:47.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.710]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.710]         }
[17:44:47.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.710]             base::sink(type = "output", split = FALSE)
[17:44:47.710]             base::close(...future.stdout)
[17:44:47.710]         }, add = TRUE)
[17:44:47.710]     }
[17:44:47.710]     ...future.frame <- base::sys.nframe()
[17:44:47.710]     ...future.conditions <- base::list()
[17:44:47.710]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.710]     if (FALSE) {
[17:44:47.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.710]     }
[17:44:47.710]     ...future.result <- base::tryCatch({
[17:44:47.710]         base::withCallingHandlers({
[17:44:47.710]             ...future.value <- base::withVisible(base::local({
[17:44:47.710]                 withCallingHandlers({
[17:44:47.710]                   {
[17:44:47.710]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.710]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.710]                       ...future.globals.maxSize)) {
[17:44:47.710]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.710]                       on.exit(options(oopts), add = TRUE)
[17:44:47.710]                     }
[17:44:47.710]                     {
[17:44:47.710]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.710]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.710]                         USE.NAMES = FALSE)
[17:44:47.710]                       do.call(mapply, args = args)
[17:44:47.710]                     }
[17:44:47.710]                   }
[17:44:47.710]                 }, immediateCondition = function(cond) {
[17:44:47.710]                   save_rds <- function (object, pathname, ...) 
[17:44:47.710]                   {
[17:44:47.710]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.710]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.710]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.710]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.710]                         fi_tmp[["mtime"]])
[17:44:47.710]                     }
[17:44:47.710]                     tryCatch({
[17:44:47.710]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.710]                     }, error = function(ex) {
[17:44:47.710]                       msg <- conditionMessage(ex)
[17:44:47.710]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.710]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.710]                         fi_tmp[["mtime"]], msg)
[17:44:47.710]                       ex$message <- msg
[17:44:47.710]                       stop(ex)
[17:44:47.710]                     })
[17:44:47.710]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.710]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.710]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.710]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.710]                       fi <- file.info(pathname)
[17:44:47.710]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.710]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.710]                         fi[["size"]], fi[["mtime"]])
[17:44:47.710]                       stop(msg)
[17:44:47.710]                     }
[17:44:47.710]                     invisible(pathname)
[17:44:47.710]                   }
[17:44:47.710]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.710]                     rootPath = tempdir()) 
[17:44:47.710]                   {
[17:44:47.710]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.710]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.710]                       tmpdir = path, fileext = ".rds")
[17:44:47.710]                     save_rds(obj, file)
[17:44:47.710]                   }
[17:44:47.710]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.710]                   {
[17:44:47.710]                     inherits <- base::inherits
[17:44:47.710]                     invokeRestart <- base::invokeRestart
[17:44:47.710]                     is.null <- base::is.null
[17:44:47.710]                     muffled <- FALSE
[17:44:47.710]                     if (inherits(cond, "message")) {
[17:44:47.710]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.710]                       if (muffled) 
[17:44:47.710]                         invokeRestart("muffleMessage")
[17:44:47.710]                     }
[17:44:47.710]                     else if (inherits(cond, "warning")) {
[17:44:47.710]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.710]                       if (muffled) 
[17:44:47.710]                         invokeRestart("muffleWarning")
[17:44:47.710]                     }
[17:44:47.710]                     else if (inherits(cond, "condition")) {
[17:44:47.710]                       if (!is.null(pattern)) {
[17:44:47.710]                         computeRestarts <- base::computeRestarts
[17:44:47.710]                         grepl <- base::grepl
[17:44:47.710]                         restarts <- computeRestarts(cond)
[17:44:47.710]                         for (restart in restarts) {
[17:44:47.710]                           name <- restart$name
[17:44:47.710]                           if (is.null(name)) 
[17:44:47.710]                             next
[17:44:47.710]                           if (!grepl(pattern, name)) 
[17:44:47.710]                             next
[17:44:47.710]                           invokeRestart(restart)
[17:44:47.710]                           muffled <- TRUE
[17:44:47.710]                           break
[17:44:47.710]                         }
[17:44:47.710]                       }
[17:44:47.710]                     }
[17:44:47.710]                     invisible(muffled)
[17:44:47.710]                   }
[17:44:47.710]                   muffleCondition(cond)
[17:44:47.710]                 })
[17:44:47.710]             }))
[17:44:47.710]             future::FutureResult(value = ...future.value$value, 
[17:44:47.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.710]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.710]                     ...future.globalenv.names))
[17:44:47.710]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.710]         }, condition = base::local({
[17:44:47.710]             c <- base::c
[17:44:47.710]             inherits <- base::inherits
[17:44:47.710]             invokeRestart <- base::invokeRestart
[17:44:47.710]             length <- base::length
[17:44:47.710]             list <- base::list
[17:44:47.710]             seq.int <- base::seq.int
[17:44:47.710]             signalCondition <- base::signalCondition
[17:44:47.710]             sys.calls <- base::sys.calls
[17:44:47.710]             `[[` <- base::`[[`
[17:44:47.710]             `+` <- base::`+`
[17:44:47.710]             `<<-` <- base::`<<-`
[17:44:47.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.710]                   3L)]
[17:44:47.710]             }
[17:44:47.710]             function(cond) {
[17:44:47.710]                 is_error <- inherits(cond, "error")
[17:44:47.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.710]                   NULL)
[17:44:47.710]                 if (is_error) {
[17:44:47.710]                   sessionInformation <- function() {
[17:44:47.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.710]                       search = base::search(), system = base::Sys.info())
[17:44:47.710]                   }
[17:44:47.710]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.710]                     cond$call), session = sessionInformation(), 
[17:44:47.710]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.710]                   signalCondition(cond)
[17:44:47.710]                 }
[17:44:47.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.710]                 "immediateCondition"))) {
[17:44:47.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.710]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.710]                   if (TRUE && !signal) {
[17:44:47.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.710]                     {
[17:44:47.710]                       inherits <- base::inherits
[17:44:47.710]                       invokeRestart <- base::invokeRestart
[17:44:47.710]                       is.null <- base::is.null
[17:44:47.710]                       muffled <- FALSE
[17:44:47.710]                       if (inherits(cond, "message")) {
[17:44:47.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.710]                         if (muffled) 
[17:44:47.710]                           invokeRestart("muffleMessage")
[17:44:47.710]                       }
[17:44:47.710]                       else if (inherits(cond, "warning")) {
[17:44:47.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.710]                         if (muffled) 
[17:44:47.710]                           invokeRestart("muffleWarning")
[17:44:47.710]                       }
[17:44:47.710]                       else if (inherits(cond, "condition")) {
[17:44:47.710]                         if (!is.null(pattern)) {
[17:44:47.710]                           computeRestarts <- base::computeRestarts
[17:44:47.710]                           grepl <- base::grepl
[17:44:47.710]                           restarts <- computeRestarts(cond)
[17:44:47.710]                           for (restart in restarts) {
[17:44:47.710]                             name <- restart$name
[17:44:47.710]                             if (is.null(name)) 
[17:44:47.710]                               next
[17:44:47.710]                             if (!grepl(pattern, name)) 
[17:44:47.710]                               next
[17:44:47.710]                             invokeRestart(restart)
[17:44:47.710]                             muffled <- TRUE
[17:44:47.710]                             break
[17:44:47.710]                           }
[17:44:47.710]                         }
[17:44:47.710]                       }
[17:44:47.710]                       invisible(muffled)
[17:44:47.710]                     }
[17:44:47.710]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.710]                   }
[17:44:47.710]                 }
[17:44:47.710]                 else {
[17:44:47.710]                   if (TRUE) {
[17:44:47.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.710]                     {
[17:44:47.710]                       inherits <- base::inherits
[17:44:47.710]                       invokeRestart <- base::invokeRestart
[17:44:47.710]                       is.null <- base::is.null
[17:44:47.710]                       muffled <- FALSE
[17:44:47.710]                       if (inherits(cond, "message")) {
[17:44:47.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.710]                         if (muffled) 
[17:44:47.710]                           invokeRestart("muffleMessage")
[17:44:47.710]                       }
[17:44:47.710]                       else if (inherits(cond, "warning")) {
[17:44:47.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.710]                         if (muffled) 
[17:44:47.710]                           invokeRestart("muffleWarning")
[17:44:47.710]                       }
[17:44:47.710]                       else if (inherits(cond, "condition")) {
[17:44:47.710]                         if (!is.null(pattern)) {
[17:44:47.710]                           computeRestarts <- base::computeRestarts
[17:44:47.710]                           grepl <- base::grepl
[17:44:47.710]                           restarts <- computeRestarts(cond)
[17:44:47.710]                           for (restart in restarts) {
[17:44:47.710]                             name <- restart$name
[17:44:47.710]                             if (is.null(name)) 
[17:44:47.710]                               next
[17:44:47.710]                             if (!grepl(pattern, name)) 
[17:44:47.710]                               next
[17:44:47.710]                             invokeRestart(restart)
[17:44:47.710]                             muffled <- TRUE
[17:44:47.710]                             break
[17:44:47.710]                           }
[17:44:47.710]                         }
[17:44:47.710]                       }
[17:44:47.710]                       invisible(muffled)
[17:44:47.710]                     }
[17:44:47.710]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.710]                   }
[17:44:47.710]                 }
[17:44:47.710]             }
[17:44:47.710]         }))
[17:44:47.710]     }, error = function(ex) {
[17:44:47.710]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.710]                 ...future.rng), started = ...future.startTime, 
[17:44:47.710]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.710]             version = "1.8"), class = "FutureResult")
[17:44:47.710]     }, finally = {
[17:44:47.710]         if (!identical(...future.workdir, getwd())) 
[17:44:47.710]             setwd(...future.workdir)
[17:44:47.710]         {
[17:44:47.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.710]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.710]             }
[17:44:47.710]             base::options(...future.oldOptions)
[17:44:47.710]             if (.Platform$OS.type == "windows") {
[17:44:47.710]                 old_names <- names(...future.oldEnvVars)
[17:44:47.710]                 envs <- base::Sys.getenv()
[17:44:47.710]                 names <- names(envs)
[17:44:47.710]                 common <- intersect(names, old_names)
[17:44:47.710]                 added <- setdiff(names, old_names)
[17:44:47.710]                 removed <- setdiff(old_names, names)
[17:44:47.710]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.710]                   envs[common]]
[17:44:47.710]                 NAMES <- toupper(changed)
[17:44:47.710]                 args <- list()
[17:44:47.710]                 for (kk in seq_along(NAMES)) {
[17:44:47.710]                   name <- changed[[kk]]
[17:44:47.710]                   NAME <- NAMES[[kk]]
[17:44:47.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.710]                     next
[17:44:47.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.710]                 }
[17:44:47.710]                 NAMES <- toupper(added)
[17:44:47.710]                 for (kk in seq_along(NAMES)) {
[17:44:47.710]                   name <- added[[kk]]
[17:44:47.710]                   NAME <- NAMES[[kk]]
[17:44:47.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.710]                     next
[17:44:47.710]                   args[[name]] <- ""
[17:44:47.710]                 }
[17:44:47.710]                 NAMES <- toupper(removed)
[17:44:47.710]                 for (kk in seq_along(NAMES)) {
[17:44:47.710]                   name <- removed[[kk]]
[17:44:47.710]                   NAME <- NAMES[[kk]]
[17:44:47.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.710]                     next
[17:44:47.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.710]                 }
[17:44:47.710]                 if (length(args) > 0) 
[17:44:47.710]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.710]             }
[17:44:47.710]             else {
[17:44:47.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.710]             }
[17:44:47.710]             {
[17:44:47.710]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.710]                   0L) {
[17:44:47.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.710]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.710]                   base::options(opts)
[17:44:47.710]                 }
[17:44:47.710]                 {
[17:44:47.710]                   {
[17:44:47.710]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.710]                     NULL
[17:44:47.710]                   }
[17:44:47.710]                   options(future.plan = NULL)
[17:44:47.710]                   if (is.na(NA_character_)) 
[17:44:47.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.710]                     .init = FALSE)
[17:44:47.710]                 }
[17:44:47.710]             }
[17:44:47.710]         }
[17:44:47.710]     })
[17:44:47.710]     if (TRUE) {
[17:44:47.710]         base::sink(type = "output", split = FALSE)
[17:44:47.710]         if (TRUE) {
[17:44:47.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.710]         }
[17:44:47.710]         else {
[17:44:47.710]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.710]         }
[17:44:47.710]         base::close(...future.stdout)
[17:44:47.710]         ...future.stdout <- NULL
[17:44:47.710]     }
[17:44:47.710]     ...future.result$conditions <- ...future.conditions
[17:44:47.710]     ...future.result$finished <- base::Sys.time()
[17:44:47.710]     ...future.result
[17:44:47.710] }
[17:44:47.714] assign_globals() ...
[17:44:47.715] List of 5
[17:44:47.715]  $ ...future.FUN            :function (C, k)  
[17:44:47.715]  $ MoreArgs                 : NULL
[17:44:47.715]  $ ...future.elements_ii    :List of 2
[17:44:47.715]   ..$ :List of 2
[17:44:47.715]   .. ..$ : chr "E"
[17:44:47.715]   .. ..$ : chr "D"
[17:44:47.715]   ..$ :List of 2
[17:44:47.715]   .. ..$ : int 1
[17:44:47.715]   .. ..$ : int 2
[17:44:47.715]  $ ...future.seeds_ii       : NULL
[17:44:47.715]  $ ...future.globals.maxSize: NULL
[17:44:47.715]  - attr(*, "where")=List of 5
[17:44:47.715]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.715]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.715]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.715]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.715]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.715]  - attr(*, "resolved")= logi FALSE
[17:44:47.715]  - attr(*, "total_size")= num 3656
[17:44:47.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.715]  - attr(*, "already-done")= logi TRUE
[17:44:47.721] - reassign environment for ‘...future.FUN’
[17:44:47.721] - copied ‘...future.FUN’ to environment
[17:44:47.721] - copied ‘MoreArgs’ to environment
[17:44:47.721] - copied ‘...future.elements_ii’ to environment
[17:44:47.721] - copied ‘...future.seeds_ii’ to environment
[17:44:47.722] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.722] assign_globals() ... done
[17:44:47.722] requestCore(): workers = 2
[17:44:47.724] MulticoreFuture started
[17:44:47.725] - Launch lazy future ... done
[17:44:47.725] run() for ‘MulticoreFuture’ ... done
[17:44:47.725] Created future:
[17:44:47.725] plan(): Setting new future strategy stack:
[17:44:47.725] List of future strategies:
[17:44:47.725] 1. sequential:
[17:44:47.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.725]    - tweaked: FALSE
[17:44:47.725]    - call: NULL
[17:44:47.726] plan(): nbrOfWorkers() = 1
[17:44:47.729] plan(): Setting new future strategy stack:
[17:44:47.729] List of future strategies:
[17:44:47.729] 1. multicore:
[17:44:47.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.729]    - tweaked: FALSE
[17:44:47.729]    - call: plan(strategy)
[17:44:47.734] plan(): nbrOfWorkers() = 2
[17:44:47.725] MulticoreFuture:
[17:44:47.725] Label: ‘future_mapply-1’
[17:44:47.725] Expression:
[17:44:47.725] {
[17:44:47.725]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.725]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.725]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.725]         on.exit(options(oopts), add = TRUE)
[17:44:47.725]     }
[17:44:47.725]     {
[17:44:47.725]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.725]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.725]         do.call(mapply, args = args)
[17:44:47.725]     }
[17:44:47.725] }
[17:44:47.725] Lazy evaluation: FALSE
[17:44:47.725] Asynchronous evaluation: TRUE
[17:44:47.725] Local evaluation: TRUE
[17:44:47.725] Environment: R_GlobalEnv
[17:44:47.725] Capture standard output: TRUE
[17:44:47.725] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.725] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.725] Packages: <none>
[17:44:47.725] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.725] Resolved: TRUE
[17:44:47.725] Value: <not collected>
[17:44:47.725] Conditions captured: <none>
[17:44:47.725] Early signaling: FALSE
[17:44:47.725] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.725] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.735] Chunk #1 of 2 ... DONE
[17:44:47.735] Chunk #2 of 2 ...
[17:44:47.736]  - Finding globals in '...' for chunk #2 ...
[17:44:47.736] getGlobalsAndPackages() ...
[17:44:47.736] Searching for globals...
[17:44:47.737] 
[17:44:47.737] Searching for globals ... DONE
[17:44:47.737] - globals: [0] <none>
[17:44:47.737] getGlobalsAndPackages() ... DONE
[17:44:47.737]    + additional globals found: [n=0] 
[17:44:47.737]    + additional namespaces needed: [n=0] 
[17:44:47.737]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:47.738]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.738]  - seeds: <none>
[17:44:47.738]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.738] getGlobalsAndPackages() ...
[17:44:47.738] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.738] Resolving globals: FALSE
[17:44:47.739] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:47.740] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.740] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.740] 
[17:44:47.741] getGlobalsAndPackages() ... DONE
[17:44:47.741] run() for ‘Future’ ...
[17:44:47.741] - state: ‘created’
[17:44:47.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.746]   - Field: ‘label’
[17:44:47.746]   - Field: ‘local’
[17:44:47.746]   - Field: ‘owner’
[17:44:47.747]   - Field: ‘envir’
[17:44:47.747]   - Field: ‘workers’
[17:44:47.747]   - Field: ‘packages’
[17:44:47.747]   - Field: ‘gc’
[17:44:47.747]   - Field: ‘job’
[17:44:47.747]   - Field: ‘conditions’
[17:44:47.748]   - Field: ‘expr’
[17:44:47.748]   - Field: ‘uuid’
[17:44:47.748]   - Field: ‘seed’
[17:44:47.748]   - Field: ‘version’
[17:44:47.748]   - Field: ‘result’
[17:44:47.748]   - Field: ‘asynchronous’
[17:44:47.748]   - Field: ‘calls’
[17:44:47.749]   - Field: ‘globals’
[17:44:47.749]   - Field: ‘stdout’
[17:44:47.749]   - Field: ‘earlySignal’
[17:44:47.749]   - Field: ‘lazy’
[17:44:47.749]   - Field: ‘state’
[17:44:47.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.750] - Launch lazy future ...
[17:44:47.750] Packages needed by the future expression (n = 0): <none>
[17:44:47.750] Packages needed by future strategies (n = 0): <none>
[17:44:47.751] {
[17:44:47.751]     {
[17:44:47.751]         {
[17:44:47.751]             ...future.startTime <- base::Sys.time()
[17:44:47.751]             {
[17:44:47.751]                 {
[17:44:47.751]                   {
[17:44:47.751]                     {
[17:44:47.751]                       base::local({
[17:44:47.751]                         has_future <- base::requireNamespace("future", 
[17:44:47.751]                           quietly = TRUE)
[17:44:47.751]                         if (has_future) {
[17:44:47.751]                           ns <- base::getNamespace("future")
[17:44:47.751]                           version <- ns[[".package"]][["version"]]
[17:44:47.751]                           if (is.null(version)) 
[17:44:47.751]                             version <- utils::packageVersion("future")
[17:44:47.751]                         }
[17:44:47.751]                         else {
[17:44:47.751]                           version <- NULL
[17:44:47.751]                         }
[17:44:47.751]                         if (!has_future || version < "1.8.0") {
[17:44:47.751]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.751]                             "", base::R.version$version.string), 
[17:44:47.751]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.751]                               "release", "version")], collapse = " "), 
[17:44:47.751]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.751]                             info)
[17:44:47.751]                           info <- base::paste(info, collapse = "; ")
[17:44:47.751]                           if (!has_future) {
[17:44:47.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.751]                               info)
[17:44:47.751]                           }
[17:44:47.751]                           else {
[17:44:47.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.751]                               info, version)
[17:44:47.751]                           }
[17:44:47.751]                           base::stop(msg)
[17:44:47.751]                         }
[17:44:47.751]                       })
[17:44:47.751]                     }
[17:44:47.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.751]                     base::options(mc.cores = 1L)
[17:44:47.751]                   }
[17:44:47.751]                   ...future.strategy.old <- future::plan("list")
[17:44:47.751]                   options(future.plan = NULL)
[17:44:47.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.751]                 }
[17:44:47.751]                 ...future.workdir <- getwd()
[17:44:47.751]             }
[17:44:47.751]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.751]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.751]         }
[17:44:47.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.751]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.751]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.751]             base::names(...future.oldOptions))
[17:44:47.751]     }
[17:44:47.751]     if (FALSE) {
[17:44:47.751]     }
[17:44:47.751]     else {
[17:44:47.751]         if (TRUE) {
[17:44:47.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.751]                 open = "w")
[17:44:47.751]         }
[17:44:47.751]         else {
[17:44:47.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.751]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.751]         }
[17:44:47.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.751]             base::sink(type = "output", split = FALSE)
[17:44:47.751]             base::close(...future.stdout)
[17:44:47.751]         }, add = TRUE)
[17:44:47.751]     }
[17:44:47.751]     ...future.frame <- base::sys.nframe()
[17:44:47.751]     ...future.conditions <- base::list()
[17:44:47.751]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.751]     if (FALSE) {
[17:44:47.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.751]     }
[17:44:47.751]     ...future.result <- base::tryCatch({
[17:44:47.751]         base::withCallingHandlers({
[17:44:47.751]             ...future.value <- base::withVisible(base::local({
[17:44:47.751]                 withCallingHandlers({
[17:44:47.751]                   {
[17:44:47.751]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.751]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.751]                       ...future.globals.maxSize)) {
[17:44:47.751]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.751]                       on.exit(options(oopts), add = TRUE)
[17:44:47.751]                     }
[17:44:47.751]                     {
[17:44:47.751]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.751]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.751]                         USE.NAMES = FALSE)
[17:44:47.751]                       do.call(mapply, args = args)
[17:44:47.751]                     }
[17:44:47.751]                   }
[17:44:47.751]                 }, immediateCondition = function(cond) {
[17:44:47.751]                   save_rds <- function (object, pathname, ...) 
[17:44:47.751]                   {
[17:44:47.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.751]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.751]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.751]                         fi_tmp[["mtime"]])
[17:44:47.751]                     }
[17:44:47.751]                     tryCatch({
[17:44:47.751]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.751]                     }, error = function(ex) {
[17:44:47.751]                       msg <- conditionMessage(ex)
[17:44:47.751]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.751]                         fi_tmp[["mtime"]], msg)
[17:44:47.751]                       ex$message <- msg
[17:44:47.751]                       stop(ex)
[17:44:47.751]                     })
[17:44:47.751]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.751]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.751]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.751]                       fi <- file.info(pathname)
[17:44:47.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.751]                         fi[["size"]], fi[["mtime"]])
[17:44:47.751]                       stop(msg)
[17:44:47.751]                     }
[17:44:47.751]                     invisible(pathname)
[17:44:47.751]                   }
[17:44:47.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.751]                     rootPath = tempdir()) 
[17:44:47.751]                   {
[17:44:47.751]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.751]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.751]                       tmpdir = path, fileext = ".rds")
[17:44:47.751]                     save_rds(obj, file)
[17:44:47.751]                   }
[17:44:47.751]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.751]                   {
[17:44:47.751]                     inherits <- base::inherits
[17:44:47.751]                     invokeRestart <- base::invokeRestart
[17:44:47.751]                     is.null <- base::is.null
[17:44:47.751]                     muffled <- FALSE
[17:44:47.751]                     if (inherits(cond, "message")) {
[17:44:47.751]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.751]                       if (muffled) 
[17:44:47.751]                         invokeRestart("muffleMessage")
[17:44:47.751]                     }
[17:44:47.751]                     else if (inherits(cond, "warning")) {
[17:44:47.751]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.751]                       if (muffled) 
[17:44:47.751]                         invokeRestart("muffleWarning")
[17:44:47.751]                     }
[17:44:47.751]                     else if (inherits(cond, "condition")) {
[17:44:47.751]                       if (!is.null(pattern)) {
[17:44:47.751]                         computeRestarts <- base::computeRestarts
[17:44:47.751]                         grepl <- base::grepl
[17:44:47.751]                         restarts <- computeRestarts(cond)
[17:44:47.751]                         for (restart in restarts) {
[17:44:47.751]                           name <- restart$name
[17:44:47.751]                           if (is.null(name)) 
[17:44:47.751]                             next
[17:44:47.751]                           if (!grepl(pattern, name)) 
[17:44:47.751]                             next
[17:44:47.751]                           invokeRestart(restart)
[17:44:47.751]                           muffled <- TRUE
[17:44:47.751]                           break
[17:44:47.751]                         }
[17:44:47.751]                       }
[17:44:47.751]                     }
[17:44:47.751]                     invisible(muffled)
[17:44:47.751]                   }
[17:44:47.751]                   muffleCondition(cond)
[17:44:47.751]                 })
[17:44:47.751]             }))
[17:44:47.751]             future::FutureResult(value = ...future.value$value, 
[17:44:47.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.751]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.751]                     ...future.globalenv.names))
[17:44:47.751]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.751]         }, condition = base::local({
[17:44:47.751]             c <- base::c
[17:44:47.751]             inherits <- base::inherits
[17:44:47.751]             invokeRestart <- base::invokeRestart
[17:44:47.751]             length <- base::length
[17:44:47.751]             list <- base::list
[17:44:47.751]             seq.int <- base::seq.int
[17:44:47.751]             signalCondition <- base::signalCondition
[17:44:47.751]             sys.calls <- base::sys.calls
[17:44:47.751]             `[[` <- base::`[[`
[17:44:47.751]             `+` <- base::`+`
[17:44:47.751]             `<<-` <- base::`<<-`
[17:44:47.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.751]                   3L)]
[17:44:47.751]             }
[17:44:47.751]             function(cond) {
[17:44:47.751]                 is_error <- inherits(cond, "error")
[17:44:47.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.751]                   NULL)
[17:44:47.751]                 if (is_error) {
[17:44:47.751]                   sessionInformation <- function() {
[17:44:47.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.751]                       search = base::search(), system = base::Sys.info())
[17:44:47.751]                   }
[17:44:47.751]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.751]                     cond$call), session = sessionInformation(), 
[17:44:47.751]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.751]                   signalCondition(cond)
[17:44:47.751]                 }
[17:44:47.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.751]                 "immediateCondition"))) {
[17:44:47.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.751]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.751]                   if (TRUE && !signal) {
[17:44:47.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.751]                     {
[17:44:47.751]                       inherits <- base::inherits
[17:44:47.751]                       invokeRestart <- base::invokeRestart
[17:44:47.751]                       is.null <- base::is.null
[17:44:47.751]                       muffled <- FALSE
[17:44:47.751]                       if (inherits(cond, "message")) {
[17:44:47.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.751]                         if (muffled) 
[17:44:47.751]                           invokeRestart("muffleMessage")
[17:44:47.751]                       }
[17:44:47.751]                       else if (inherits(cond, "warning")) {
[17:44:47.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.751]                         if (muffled) 
[17:44:47.751]                           invokeRestart("muffleWarning")
[17:44:47.751]                       }
[17:44:47.751]                       else if (inherits(cond, "condition")) {
[17:44:47.751]                         if (!is.null(pattern)) {
[17:44:47.751]                           computeRestarts <- base::computeRestarts
[17:44:47.751]                           grepl <- base::grepl
[17:44:47.751]                           restarts <- computeRestarts(cond)
[17:44:47.751]                           for (restart in restarts) {
[17:44:47.751]                             name <- restart$name
[17:44:47.751]                             if (is.null(name)) 
[17:44:47.751]                               next
[17:44:47.751]                             if (!grepl(pattern, name)) 
[17:44:47.751]                               next
[17:44:47.751]                             invokeRestart(restart)
[17:44:47.751]                             muffled <- TRUE
[17:44:47.751]                             break
[17:44:47.751]                           }
[17:44:47.751]                         }
[17:44:47.751]                       }
[17:44:47.751]                       invisible(muffled)
[17:44:47.751]                     }
[17:44:47.751]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.751]                   }
[17:44:47.751]                 }
[17:44:47.751]                 else {
[17:44:47.751]                   if (TRUE) {
[17:44:47.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.751]                     {
[17:44:47.751]                       inherits <- base::inherits
[17:44:47.751]                       invokeRestart <- base::invokeRestart
[17:44:47.751]                       is.null <- base::is.null
[17:44:47.751]                       muffled <- FALSE
[17:44:47.751]                       if (inherits(cond, "message")) {
[17:44:47.751]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.751]                         if (muffled) 
[17:44:47.751]                           invokeRestart("muffleMessage")
[17:44:47.751]                       }
[17:44:47.751]                       else if (inherits(cond, "warning")) {
[17:44:47.751]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.751]                         if (muffled) 
[17:44:47.751]                           invokeRestart("muffleWarning")
[17:44:47.751]                       }
[17:44:47.751]                       else if (inherits(cond, "condition")) {
[17:44:47.751]                         if (!is.null(pattern)) {
[17:44:47.751]                           computeRestarts <- base::computeRestarts
[17:44:47.751]                           grepl <- base::grepl
[17:44:47.751]                           restarts <- computeRestarts(cond)
[17:44:47.751]                           for (restart in restarts) {
[17:44:47.751]                             name <- restart$name
[17:44:47.751]                             if (is.null(name)) 
[17:44:47.751]                               next
[17:44:47.751]                             if (!grepl(pattern, name)) 
[17:44:47.751]                               next
[17:44:47.751]                             invokeRestart(restart)
[17:44:47.751]                             muffled <- TRUE
[17:44:47.751]                             break
[17:44:47.751]                           }
[17:44:47.751]                         }
[17:44:47.751]                       }
[17:44:47.751]                       invisible(muffled)
[17:44:47.751]                     }
[17:44:47.751]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.751]                   }
[17:44:47.751]                 }
[17:44:47.751]             }
[17:44:47.751]         }))
[17:44:47.751]     }, error = function(ex) {
[17:44:47.751]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.751]                 ...future.rng), started = ...future.startTime, 
[17:44:47.751]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.751]             version = "1.8"), class = "FutureResult")
[17:44:47.751]     }, finally = {
[17:44:47.751]         if (!identical(...future.workdir, getwd())) 
[17:44:47.751]             setwd(...future.workdir)
[17:44:47.751]         {
[17:44:47.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.751]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.751]             }
[17:44:47.751]             base::options(...future.oldOptions)
[17:44:47.751]             if (.Platform$OS.type == "windows") {
[17:44:47.751]                 old_names <- names(...future.oldEnvVars)
[17:44:47.751]                 envs <- base::Sys.getenv()
[17:44:47.751]                 names <- names(envs)
[17:44:47.751]                 common <- intersect(names, old_names)
[17:44:47.751]                 added <- setdiff(names, old_names)
[17:44:47.751]                 removed <- setdiff(old_names, names)
[17:44:47.751]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.751]                   envs[common]]
[17:44:47.751]                 NAMES <- toupper(changed)
[17:44:47.751]                 args <- list()
[17:44:47.751]                 for (kk in seq_along(NAMES)) {
[17:44:47.751]                   name <- changed[[kk]]
[17:44:47.751]                   NAME <- NAMES[[kk]]
[17:44:47.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.751]                     next
[17:44:47.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.751]                 }
[17:44:47.751]                 NAMES <- toupper(added)
[17:44:47.751]                 for (kk in seq_along(NAMES)) {
[17:44:47.751]                   name <- added[[kk]]
[17:44:47.751]                   NAME <- NAMES[[kk]]
[17:44:47.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.751]                     next
[17:44:47.751]                   args[[name]] <- ""
[17:44:47.751]                 }
[17:44:47.751]                 NAMES <- toupper(removed)
[17:44:47.751]                 for (kk in seq_along(NAMES)) {
[17:44:47.751]                   name <- removed[[kk]]
[17:44:47.751]                   NAME <- NAMES[[kk]]
[17:44:47.751]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.751]                     next
[17:44:47.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.751]                 }
[17:44:47.751]                 if (length(args) > 0) 
[17:44:47.751]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.751]             }
[17:44:47.751]             else {
[17:44:47.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.751]             }
[17:44:47.751]             {
[17:44:47.751]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.751]                   0L) {
[17:44:47.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.751]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.751]                   base::options(opts)
[17:44:47.751]                 }
[17:44:47.751]                 {
[17:44:47.751]                   {
[17:44:47.751]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.751]                     NULL
[17:44:47.751]                   }
[17:44:47.751]                   options(future.plan = NULL)
[17:44:47.751]                   if (is.na(NA_character_)) 
[17:44:47.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.751]                     .init = FALSE)
[17:44:47.751]                 }
[17:44:47.751]             }
[17:44:47.751]         }
[17:44:47.751]     })
[17:44:47.751]     if (TRUE) {
[17:44:47.751]         base::sink(type = "output", split = FALSE)
[17:44:47.751]         if (TRUE) {
[17:44:47.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.751]         }
[17:44:47.751]         else {
[17:44:47.751]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.751]         }
[17:44:47.751]         base::close(...future.stdout)
[17:44:47.751]         ...future.stdout <- NULL
[17:44:47.751]     }
[17:44:47.751]     ...future.result$conditions <- ...future.conditions
[17:44:47.751]     ...future.result$finished <- base::Sys.time()
[17:44:47.751]     ...future.result
[17:44:47.751] }
[17:44:47.754] assign_globals() ...
[17:44:47.754] List of 5
[17:44:47.754]  $ ...future.FUN            :function (C, k)  
[17:44:47.754]  $ MoreArgs                 : NULL
[17:44:47.754]  $ ...future.elements_ii    :List of 2
[17:44:47.754]   ..$ :List of 3
[17:44:47.754]   .. ..$ : chr "C"
[17:44:47.754]   .. ..$ : chr "B"
[17:44:47.754]   .. ..$ : chr "A"
[17:44:47.754]   ..$ :List of 3
[17:44:47.754]   .. ..$ : int 3
[17:44:47.754]   .. ..$ : int 4
[17:44:47.754]   .. ..$ : int 5
[17:44:47.754]  $ ...future.seeds_ii       : NULL
[17:44:47.754]  $ ...future.globals.maxSize: NULL
[17:44:47.754]  - attr(*, "where")=List of 5
[17:44:47.754]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.754]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.754]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.754]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.754]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.754]  - attr(*, "resolved")= logi FALSE
[17:44:47.754]  - attr(*, "total_size")= num 3824
[17:44:47.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.754]  - attr(*, "already-done")= logi TRUE
[17:44:47.768] - reassign environment for ‘...future.FUN’
[17:44:47.769] - copied ‘...future.FUN’ to environment
[17:44:47.769] - copied ‘MoreArgs’ to environment
[17:44:47.769] - copied ‘...future.elements_ii’ to environment
[17:44:47.769] - copied ‘...future.seeds_ii’ to environment
[17:44:47.769] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.769] assign_globals() ... done
[17:44:47.770] requestCore(): workers = 2
[17:44:47.772] MulticoreFuture started
[17:44:47.773] - Launch lazy future ... done
[17:44:47.773] run() for ‘MulticoreFuture’ ... done
[17:44:47.773] plan(): Setting new future strategy stack:
[17:44:47.773] Created future:
[17:44:47.773] List of future strategies:
[17:44:47.773] 1. sequential:
[17:44:47.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.773]    - tweaked: FALSE
[17:44:47.773]    - call: NULL
[17:44:47.775] plan(): nbrOfWorkers() = 1
[17:44:47.777] plan(): Setting new future strategy stack:
[17:44:47.777] List of future strategies:
[17:44:47.777] 1. multicore:
[17:44:47.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.777]    - tweaked: FALSE
[17:44:47.777]    - call: plan(strategy)
[17:44:47.783] plan(): nbrOfWorkers() = 2
[17:44:47.774] MulticoreFuture:
[17:44:47.774] Label: ‘future_mapply-2’
[17:44:47.774] Expression:
[17:44:47.774] {
[17:44:47.774]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.774]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.774]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.774]         on.exit(options(oopts), add = TRUE)
[17:44:47.774]     }
[17:44:47.774]     {
[17:44:47.774]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.774]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.774]         do.call(mapply, args = args)
[17:44:47.774]     }
[17:44:47.774] }
[17:44:47.774] Lazy evaluation: FALSE
[17:44:47.774] Asynchronous evaluation: TRUE
[17:44:47.774] Local evaluation: TRUE
[17:44:47.774] Environment: R_GlobalEnv
[17:44:47.774] Capture standard output: TRUE
[17:44:47.774] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.774] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.774] Packages: <none>
[17:44:47.774] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.774] Resolved: TRUE
[17:44:47.774] Value: <not collected>
[17:44:47.774] Conditions captured: <none>
[17:44:47.774] Early signaling: FALSE
[17:44:47.774] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.774] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.784] Chunk #2 of 2 ... DONE
[17:44:47.784] Launching 2 futures (chunks) ... DONE
[17:44:47.784] Resolving 2 futures (chunks) ...
[17:44:47.785] resolve() on list ...
[17:44:47.785]  recursive: 0
[17:44:47.785]  length: 2
[17:44:47.785] 
[17:44:47.785] Future #1
[17:44:47.786] result() for MulticoreFuture ...
[17:44:47.786] result() for MulticoreFuture ...
[17:44:47.787] result() for MulticoreFuture ... done
[17:44:47.787] result() for MulticoreFuture ... done
[17:44:47.787] result() for MulticoreFuture ...
[17:44:47.787] result() for MulticoreFuture ... done
[17:44:47.787] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.788] - nx: 2
[17:44:47.788] - relay: TRUE
[17:44:47.788] - stdout: TRUE
[17:44:47.788] - signal: TRUE
[17:44:47.788] - resignal: FALSE
[17:44:47.788] - force: TRUE
[17:44:47.788] - relayed: [n=2] FALSE, FALSE
[17:44:47.789] - queued futures: [n=2] FALSE, FALSE
[17:44:47.789]  - until=1
[17:44:47.789]  - relaying element #1
[17:44:47.789] result() for MulticoreFuture ...
[17:44:47.789] result() for MulticoreFuture ... done
[17:44:47.789] result() for MulticoreFuture ...
[17:44:47.789] result() for MulticoreFuture ... done
[17:44:47.790] result() for MulticoreFuture ...
[17:44:47.790] result() for MulticoreFuture ... done
[17:44:47.790] result() for MulticoreFuture ...
[17:44:47.790] result() for MulticoreFuture ... done
[17:44:47.790] - relayed: [n=2] TRUE, FALSE
[17:44:47.790] - queued futures: [n=2] TRUE, FALSE
[17:44:47.791] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.791]  length: 1 (resolved future 1)
[17:44:47.791] Future #2
[17:44:47.791] result() for MulticoreFuture ...
[17:44:47.792] result() for MulticoreFuture ...
[17:44:47.792] result() for MulticoreFuture ... done
[17:44:47.792] result() for MulticoreFuture ... done
[17:44:47.792] result() for MulticoreFuture ...
[17:44:47.793] result() for MulticoreFuture ... done
[17:44:47.793] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.793] - nx: 2
[17:44:47.793] - relay: TRUE
[17:44:47.793] - stdout: TRUE
[17:44:47.793] - signal: TRUE
[17:44:47.793] - resignal: FALSE
[17:44:47.793] - force: TRUE
[17:44:47.793] - relayed: [n=2] TRUE, FALSE
[17:44:47.794] - queued futures: [n=2] TRUE, FALSE
[17:44:47.794]  - until=2
[17:44:47.794]  - relaying element #2
[17:44:47.794] result() for MulticoreFuture ...
[17:44:47.794] result() for MulticoreFuture ... done
[17:44:47.794] result() for MulticoreFuture ...
[17:44:47.794] result() for MulticoreFuture ... done
[17:44:47.794] result() for MulticoreFuture ...
[17:44:47.795] result() for MulticoreFuture ... done
[17:44:47.795] result() for MulticoreFuture ...
[17:44:47.795] result() for MulticoreFuture ... done
[17:44:47.795] - relayed: [n=2] TRUE, TRUE
[17:44:47.795] - queued futures: [n=2] TRUE, TRUE
[17:44:47.795] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.795]  length: 0 (resolved future 2)
[17:44:47.795] Relaying remaining futures
[17:44:47.796] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.796] - nx: 2
[17:44:47.796] - relay: TRUE
[17:44:47.796] - stdout: TRUE
[17:44:47.796] - signal: TRUE
[17:44:47.796] - resignal: FALSE
[17:44:47.796] - force: TRUE
[17:44:47.796] - relayed: [n=2] TRUE, TRUE
[17:44:47.796] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:47.797] - relayed: [n=2] TRUE, TRUE
[17:44:47.797] - queued futures: [n=2] TRUE, TRUE
[17:44:47.797] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.797] resolve() on list ... DONE
[17:44:47.797] result() for MulticoreFuture ...
[17:44:47.797] result() for MulticoreFuture ... done
[17:44:47.797] result() for MulticoreFuture ...
[17:44:47.797] result() for MulticoreFuture ... done
[17:44:47.797] result() for MulticoreFuture ...
[17:44:47.798] result() for MulticoreFuture ... done
[17:44:47.798] result() for MulticoreFuture ...
[17:44:47.798] result() for MulticoreFuture ... done
[17:44:47.798]  - Number of value chunks collected: 2
[17:44:47.798] Resolving 2 futures (chunks) ... DONE
[17:44:47.798] Reducing values from 2 chunks ...
[17:44:47.798]  - Number of values collected after concatenation: 5
[17:44:47.798]  - Number of values expected: 5
[17:44:47.799] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:47.799] Reducing values from 2 chunks ... DONE
[17:44:47.799] future_mapply() ... DONE
[17:44:47.799] future_mapply() ...
[17:44:47.803] Number of chunks: 2
[17:44:47.803] getGlobalsAndPackagesXApply() ...
[17:44:47.804]  - future.globals: TRUE
[17:44:47.804] getGlobalsAndPackages() ...
[17:44:47.804] Searching for globals...
[17:44:47.808] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:47.809] Searching for globals ... DONE
[17:44:47.809] Resolving globals: FALSE
[17:44:47.809] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:47.810] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:47.810] - globals: [1] ‘FUN’
[17:44:47.810] 
[17:44:47.810] getGlobalsAndPackages() ... DONE
[17:44:47.810]  - globals found/used: [n=1] ‘FUN’
[17:44:47.810]  - needed namespaces: [n=0] 
[17:44:47.811] Finding globals ... DONE
[17:44:47.811] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.811] List of 2
[17:44:47.811]  $ ...future.FUN:function (C, k)  
[17:44:47.811]  $ MoreArgs     : list()
[17:44:47.811]  - attr(*, "where")=List of 2
[17:44:47.811]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.811]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.811]  - attr(*, "resolved")= logi FALSE
[17:44:47.811]  - attr(*, "total_size")= num NA
[17:44:47.814] Packages to be attached in all futures: [n=0] 
[17:44:47.815] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.815] Number of futures (= number of chunks): 2
[17:44:47.815] Launching 2 futures (chunks) ...
[17:44:47.815] Chunk #1 of 2 ...
[17:44:47.815]  - Finding globals in '...' for chunk #1 ...
[17:44:47.815] getGlobalsAndPackages() ...
[17:44:47.815] Searching for globals...
[17:44:47.816] 
[17:44:47.816] Searching for globals ... DONE
[17:44:47.816] - globals: [0] <none>
[17:44:47.816] getGlobalsAndPackages() ... DONE
[17:44:47.816]    + additional globals found: [n=0] 
[17:44:47.816]    + additional namespaces needed: [n=0] 
[17:44:47.816]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.816]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.817]  - seeds: <none>
[17:44:47.817]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.817] getGlobalsAndPackages() ...
[17:44:47.817] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.817] Resolving globals: FALSE
[17:44:47.817] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:47.818] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.818] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.818] 
[17:44:47.818] getGlobalsAndPackages() ... DONE
[17:44:47.819] run() for ‘Future’ ...
[17:44:47.819] - state: ‘created’
[17:44:47.819] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.823] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.823]   - Field: ‘label’
[17:44:47.823]   - Field: ‘local’
[17:44:47.823]   - Field: ‘owner’
[17:44:47.823]   - Field: ‘envir’
[17:44:47.823]   - Field: ‘workers’
[17:44:47.823]   - Field: ‘packages’
[17:44:47.824]   - Field: ‘gc’
[17:44:47.824]   - Field: ‘job’
[17:44:47.824]   - Field: ‘conditions’
[17:44:47.824]   - Field: ‘expr’
[17:44:47.824]   - Field: ‘uuid’
[17:44:47.824]   - Field: ‘seed’
[17:44:47.824]   - Field: ‘version’
[17:44:47.824]   - Field: ‘result’
[17:44:47.824]   - Field: ‘asynchronous’
[17:44:47.824]   - Field: ‘calls’
[17:44:47.825]   - Field: ‘globals’
[17:44:47.825]   - Field: ‘stdout’
[17:44:47.825]   - Field: ‘earlySignal’
[17:44:47.825]   - Field: ‘lazy’
[17:44:47.825]   - Field: ‘state’
[17:44:47.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.825] - Launch lazy future ...
[17:44:47.825] Packages needed by the future expression (n = 0): <none>
[17:44:47.825] Packages needed by future strategies (n = 0): <none>
[17:44:47.826] {
[17:44:47.826]     {
[17:44:47.826]         {
[17:44:47.826]             ...future.startTime <- base::Sys.time()
[17:44:47.826]             {
[17:44:47.826]                 {
[17:44:47.826]                   {
[17:44:47.826]                     {
[17:44:47.826]                       base::local({
[17:44:47.826]                         has_future <- base::requireNamespace("future", 
[17:44:47.826]                           quietly = TRUE)
[17:44:47.826]                         if (has_future) {
[17:44:47.826]                           ns <- base::getNamespace("future")
[17:44:47.826]                           version <- ns[[".package"]][["version"]]
[17:44:47.826]                           if (is.null(version)) 
[17:44:47.826]                             version <- utils::packageVersion("future")
[17:44:47.826]                         }
[17:44:47.826]                         else {
[17:44:47.826]                           version <- NULL
[17:44:47.826]                         }
[17:44:47.826]                         if (!has_future || version < "1.8.0") {
[17:44:47.826]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.826]                             "", base::R.version$version.string), 
[17:44:47.826]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.826]                               "release", "version")], collapse = " "), 
[17:44:47.826]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.826]                             info)
[17:44:47.826]                           info <- base::paste(info, collapse = "; ")
[17:44:47.826]                           if (!has_future) {
[17:44:47.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.826]                               info)
[17:44:47.826]                           }
[17:44:47.826]                           else {
[17:44:47.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.826]                               info, version)
[17:44:47.826]                           }
[17:44:47.826]                           base::stop(msg)
[17:44:47.826]                         }
[17:44:47.826]                       })
[17:44:47.826]                     }
[17:44:47.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.826]                     base::options(mc.cores = 1L)
[17:44:47.826]                   }
[17:44:47.826]                   ...future.strategy.old <- future::plan("list")
[17:44:47.826]                   options(future.plan = NULL)
[17:44:47.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.826]                 }
[17:44:47.826]                 ...future.workdir <- getwd()
[17:44:47.826]             }
[17:44:47.826]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.826]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.826]         }
[17:44:47.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.826]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.826]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.826]             base::names(...future.oldOptions))
[17:44:47.826]     }
[17:44:47.826]     if (FALSE) {
[17:44:47.826]     }
[17:44:47.826]     else {
[17:44:47.826]         if (TRUE) {
[17:44:47.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.826]                 open = "w")
[17:44:47.826]         }
[17:44:47.826]         else {
[17:44:47.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.826]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.826]         }
[17:44:47.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.826]             base::sink(type = "output", split = FALSE)
[17:44:47.826]             base::close(...future.stdout)
[17:44:47.826]         }, add = TRUE)
[17:44:47.826]     }
[17:44:47.826]     ...future.frame <- base::sys.nframe()
[17:44:47.826]     ...future.conditions <- base::list()
[17:44:47.826]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.826]     if (FALSE) {
[17:44:47.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.826]     }
[17:44:47.826]     ...future.result <- base::tryCatch({
[17:44:47.826]         base::withCallingHandlers({
[17:44:47.826]             ...future.value <- base::withVisible(base::local({
[17:44:47.826]                 withCallingHandlers({
[17:44:47.826]                   {
[17:44:47.826]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.826]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.826]                       ...future.globals.maxSize)) {
[17:44:47.826]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.826]                       on.exit(options(oopts), add = TRUE)
[17:44:47.826]                     }
[17:44:47.826]                     {
[17:44:47.826]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.826]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.826]                         USE.NAMES = FALSE)
[17:44:47.826]                       do.call(mapply, args = args)
[17:44:47.826]                     }
[17:44:47.826]                   }
[17:44:47.826]                 }, immediateCondition = function(cond) {
[17:44:47.826]                   save_rds <- function (object, pathname, ...) 
[17:44:47.826]                   {
[17:44:47.826]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.826]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.826]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.826]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.826]                         fi_tmp[["mtime"]])
[17:44:47.826]                     }
[17:44:47.826]                     tryCatch({
[17:44:47.826]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.826]                     }, error = function(ex) {
[17:44:47.826]                       msg <- conditionMessage(ex)
[17:44:47.826]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.826]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.826]                         fi_tmp[["mtime"]], msg)
[17:44:47.826]                       ex$message <- msg
[17:44:47.826]                       stop(ex)
[17:44:47.826]                     })
[17:44:47.826]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.826]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.826]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.826]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.826]                       fi <- file.info(pathname)
[17:44:47.826]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.826]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.826]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.826]                         fi[["size"]], fi[["mtime"]])
[17:44:47.826]                       stop(msg)
[17:44:47.826]                     }
[17:44:47.826]                     invisible(pathname)
[17:44:47.826]                   }
[17:44:47.826]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.826]                     rootPath = tempdir()) 
[17:44:47.826]                   {
[17:44:47.826]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.826]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.826]                       tmpdir = path, fileext = ".rds")
[17:44:47.826]                     save_rds(obj, file)
[17:44:47.826]                   }
[17:44:47.826]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.826]                   {
[17:44:47.826]                     inherits <- base::inherits
[17:44:47.826]                     invokeRestart <- base::invokeRestart
[17:44:47.826]                     is.null <- base::is.null
[17:44:47.826]                     muffled <- FALSE
[17:44:47.826]                     if (inherits(cond, "message")) {
[17:44:47.826]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.826]                       if (muffled) 
[17:44:47.826]                         invokeRestart("muffleMessage")
[17:44:47.826]                     }
[17:44:47.826]                     else if (inherits(cond, "warning")) {
[17:44:47.826]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.826]                       if (muffled) 
[17:44:47.826]                         invokeRestart("muffleWarning")
[17:44:47.826]                     }
[17:44:47.826]                     else if (inherits(cond, "condition")) {
[17:44:47.826]                       if (!is.null(pattern)) {
[17:44:47.826]                         computeRestarts <- base::computeRestarts
[17:44:47.826]                         grepl <- base::grepl
[17:44:47.826]                         restarts <- computeRestarts(cond)
[17:44:47.826]                         for (restart in restarts) {
[17:44:47.826]                           name <- restart$name
[17:44:47.826]                           if (is.null(name)) 
[17:44:47.826]                             next
[17:44:47.826]                           if (!grepl(pattern, name)) 
[17:44:47.826]                             next
[17:44:47.826]                           invokeRestart(restart)
[17:44:47.826]                           muffled <- TRUE
[17:44:47.826]                           break
[17:44:47.826]                         }
[17:44:47.826]                       }
[17:44:47.826]                     }
[17:44:47.826]                     invisible(muffled)
[17:44:47.826]                   }
[17:44:47.826]                   muffleCondition(cond)
[17:44:47.826]                 })
[17:44:47.826]             }))
[17:44:47.826]             future::FutureResult(value = ...future.value$value, 
[17:44:47.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.826]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.826]                     ...future.globalenv.names))
[17:44:47.826]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.826]         }, condition = base::local({
[17:44:47.826]             c <- base::c
[17:44:47.826]             inherits <- base::inherits
[17:44:47.826]             invokeRestart <- base::invokeRestart
[17:44:47.826]             length <- base::length
[17:44:47.826]             list <- base::list
[17:44:47.826]             seq.int <- base::seq.int
[17:44:47.826]             signalCondition <- base::signalCondition
[17:44:47.826]             sys.calls <- base::sys.calls
[17:44:47.826]             `[[` <- base::`[[`
[17:44:47.826]             `+` <- base::`+`
[17:44:47.826]             `<<-` <- base::`<<-`
[17:44:47.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.826]                   3L)]
[17:44:47.826]             }
[17:44:47.826]             function(cond) {
[17:44:47.826]                 is_error <- inherits(cond, "error")
[17:44:47.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.826]                   NULL)
[17:44:47.826]                 if (is_error) {
[17:44:47.826]                   sessionInformation <- function() {
[17:44:47.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.826]                       search = base::search(), system = base::Sys.info())
[17:44:47.826]                   }
[17:44:47.826]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.826]                     cond$call), session = sessionInformation(), 
[17:44:47.826]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.826]                   signalCondition(cond)
[17:44:47.826]                 }
[17:44:47.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.826]                 "immediateCondition"))) {
[17:44:47.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.826]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.826]                   if (TRUE && !signal) {
[17:44:47.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.826]                     {
[17:44:47.826]                       inherits <- base::inherits
[17:44:47.826]                       invokeRestart <- base::invokeRestart
[17:44:47.826]                       is.null <- base::is.null
[17:44:47.826]                       muffled <- FALSE
[17:44:47.826]                       if (inherits(cond, "message")) {
[17:44:47.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.826]                         if (muffled) 
[17:44:47.826]                           invokeRestart("muffleMessage")
[17:44:47.826]                       }
[17:44:47.826]                       else if (inherits(cond, "warning")) {
[17:44:47.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.826]                         if (muffled) 
[17:44:47.826]                           invokeRestart("muffleWarning")
[17:44:47.826]                       }
[17:44:47.826]                       else if (inherits(cond, "condition")) {
[17:44:47.826]                         if (!is.null(pattern)) {
[17:44:47.826]                           computeRestarts <- base::computeRestarts
[17:44:47.826]                           grepl <- base::grepl
[17:44:47.826]                           restarts <- computeRestarts(cond)
[17:44:47.826]                           for (restart in restarts) {
[17:44:47.826]                             name <- restart$name
[17:44:47.826]                             if (is.null(name)) 
[17:44:47.826]                               next
[17:44:47.826]                             if (!grepl(pattern, name)) 
[17:44:47.826]                               next
[17:44:47.826]                             invokeRestart(restart)
[17:44:47.826]                             muffled <- TRUE
[17:44:47.826]                             break
[17:44:47.826]                           }
[17:44:47.826]                         }
[17:44:47.826]                       }
[17:44:47.826]                       invisible(muffled)
[17:44:47.826]                     }
[17:44:47.826]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.826]                   }
[17:44:47.826]                 }
[17:44:47.826]                 else {
[17:44:47.826]                   if (TRUE) {
[17:44:47.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.826]                     {
[17:44:47.826]                       inherits <- base::inherits
[17:44:47.826]                       invokeRestart <- base::invokeRestart
[17:44:47.826]                       is.null <- base::is.null
[17:44:47.826]                       muffled <- FALSE
[17:44:47.826]                       if (inherits(cond, "message")) {
[17:44:47.826]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.826]                         if (muffled) 
[17:44:47.826]                           invokeRestart("muffleMessage")
[17:44:47.826]                       }
[17:44:47.826]                       else if (inherits(cond, "warning")) {
[17:44:47.826]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.826]                         if (muffled) 
[17:44:47.826]                           invokeRestart("muffleWarning")
[17:44:47.826]                       }
[17:44:47.826]                       else if (inherits(cond, "condition")) {
[17:44:47.826]                         if (!is.null(pattern)) {
[17:44:47.826]                           computeRestarts <- base::computeRestarts
[17:44:47.826]                           grepl <- base::grepl
[17:44:47.826]                           restarts <- computeRestarts(cond)
[17:44:47.826]                           for (restart in restarts) {
[17:44:47.826]                             name <- restart$name
[17:44:47.826]                             if (is.null(name)) 
[17:44:47.826]                               next
[17:44:47.826]                             if (!grepl(pattern, name)) 
[17:44:47.826]                               next
[17:44:47.826]                             invokeRestart(restart)
[17:44:47.826]                             muffled <- TRUE
[17:44:47.826]                             break
[17:44:47.826]                           }
[17:44:47.826]                         }
[17:44:47.826]                       }
[17:44:47.826]                       invisible(muffled)
[17:44:47.826]                     }
[17:44:47.826]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.826]                   }
[17:44:47.826]                 }
[17:44:47.826]             }
[17:44:47.826]         }))
[17:44:47.826]     }, error = function(ex) {
[17:44:47.826]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.826]                 ...future.rng), started = ...future.startTime, 
[17:44:47.826]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.826]             version = "1.8"), class = "FutureResult")
[17:44:47.826]     }, finally = {
[17:44:47.826]         if (!identical(...future.workdir, getwd())) 
[17:44:47.826]             setwd(...future.workdir)
[17:44:47.826]         {
[17:44:47.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.826]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.826]             }
[17:44:47.826]             base::options(...future.oldOptions)
[17:44:47.826]             if (.Platform$OS.type == "windows") {
[17:44:47.826]                 old_names <- names(...future.oldEnvVars)
[17:44:47.826]                 envs <- base::Sys.getenv()
[17:44:47.826]                 names <- names(envs)
[17:44:47.826]                 common <- intersect(names, old_names)
[17:44:47.826]                 added <- setdiff(names, old_names)
[17:44:47.826]                 removed <- setdiff(old_names, names)
[17:44:47.826]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.826]                   envs[common]]
[17:44:47.826]                 NAMES <- toupper(changed)
[17:44:47.826]                 args <- list()
[17:44:47.826]                 for (kk in seq_along(NAMES)) {
[17:44:47.826]                   name <- changed[[kk]]
[17:44:47.826]                   NAME <- NAMES[[kk]]
[17:44:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.826]                     next
[17:44:47.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.826]                 }
[17:44:47.826]                 NAMES <- toupper(added)
[17:44:47.826]                 for (kk in seq_along(NAMES)) {
[17:44:47.826]                   name <- added[[kk]]
[17:44:47.826]                   NAME <- NAMES[[kk]]
[17:44:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.826]                     next
[17:44:47.826]                   args[[name]] <- ""
[17:44:47.826]                 }
[17:44:47.826]                 NAMES <- toupper(removed)
[17:44:47.826]                 for (kk in seq_along(NAMES)) {
[17:44:47.826]                   name <- removed[[kk]]
[17:44:47.826]                   NAME <- NAMES[[kk]]
[17:44:47.826]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.826]                     next
[17:44:47.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.826]                 }
[17:44:47.826]                 if (length(args) > 0) 
[17:44:47.826]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.826]             }
[17:44:47.826]             else {
[17:44:47.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.826]             }
[17:44:47.826]             {
[17:44:47.826]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.826]                   0L) {
[17:44:47.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.826]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.826]                   base::options(opts)
[17:44:47.826]                 }
[17:44:47.826]                 {
[17:44:47.826]                   {
[17:44:47.826]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.826]                     NULL
[17:44:47.826]                   }
[17:44:47.826]                   options(future.plan = NULL)
[17:44:47.826]                   if (is.na(NA_character_)) 
[17:44:47.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.826]                     .init = FALSE)
[17:44:47.826]                 }
[17:44:47.826]             }
[17:44:47.826]         }
[17:44:47.826]     })
[17:44:47.826]     if (TRUE) {
[17:44:47.826]         base::sink(type = "output", split = FALSE)
[17:44:47.826]         if (TRUE) {
[17:44:47.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.826]         }
[17:44:47.826]         else {
[17:44:47.826]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.826]         }
[17:44:47.826]         base::close(...future.stdout)
[17:44:47.826]         ...future.stdout <- NULL
[17:44:47.826]     }
[17:44:47.826]     ...future.result$conditions <- ...future.conditions
[17:44:47.826]     ...future.result$finished <- base::Sys.time()
[17:44:47.826]     ...future.result
[17:44:47.826] }
[17:44:47.829] assign_globals() ...
[17:44:47.829] List of 5
[17:44:47.829]  $ ...future.FUN            :function (C, k)  
[17:44:47.829]  $ MoreArgs                 : list()
[17:44:47.829]  $ ...future.elements_ii    :List of 2
[17:44:47.829]   ..$ :List of 2
[17:44:47.829]   .. ..$ : chr "A"
[17:44:47.829]   .. ..$ : chr "B"
[17:44:47.829]   ..$ :List of 2
[17:44:47.829]   .. ..$ : int 5
[17:44:47.829]   .. ..$ : int 4
[17:44:47.829]  $ ...future.seeds_ii       : NULL
[17:44:47.829]  $ ...future.globals.maxSize: NULL
[17:44:47.829]  - attr(*, "where")=List of 5
[17:44:47.829]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.829]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.829]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.829]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.829]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.829]  - attr(*, "resolved")= logi FALSE
[17:44:47.829]  - attr(*, "total_size")= num 3656
[17:44:47.829]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.829]  - attr(*, "already-done")= logi TRUE
[17:44:47.837] - reassign environment for ‘...future.FUN’
[17:44:47.837] - copied ‘...future.FUN’ to environment
[17:44:47.837] - copied ‘MoreArgs’ to environment
[17:44:47.837] - copied ‘...future.elements_ii’ to environment
[17:44:47.838] - copied ‘...future.seeds_ii’ to environment
[17:44:47.838] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.838] assign_globals() ... done
[17:44:47.838] requestCore(): workers = 2
[17:44:47.841] MulticoreFuture started
[17:44:47.842] - Launch lazy future ... done
[17:44:47.842] plan(): Setting new future strategy stack:
[17:44:47.842] run() for ‘MulticoreFuture’ ... done
[17:44:47.843] Created future:
[17:44:47.842] List of future strategies:
[17:44:47.842] 1. sequential:
[17:44:47.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.842]    - tweaked: FALSE
[17:44:47.842]    - call: NULL
[17:44:47.844] plan(): nbrOfWorkers() = 1
[17:44:47.847] plan(): Setting new future strategy stack:
[17:44:47.848] List of future strategies:
[17:44:47.848] 1. multicore:
[17:44:47.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.848]    - tweaked: FALSE
[17:44:47.848]    - call: plan(strategy)
[17:44:47.854] plan(): nbrOfWorkers() = 2
[17:44:47.843] MulticoreFuture:
[17:44:47.843] Label: ‘future_.mapply-1’
[17:44:47.843] Expression:
[17:44:47.843] {
[17:44:47.843]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.843]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.843]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.843]         on.exit(options(oopts), add = TRUE)
[17:44:47.843]     }
[17:44:47.843]     {
[17:44:47.843]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.843]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.843]         do.call(mapply, args = args)
[17:44:47.843]     }
[17:44:47.843] }
[17:44:47.843] Lazy evaluation: FALSE
[17:44:47.843] Asynchronous evaluation: TRUE
[17:44:47.843] Local evaluation: TRUE
[17:44:47.843] Environment: R_GlobalEnv
[17:44:47.843] Capture standard output: TRUE
[17:44:47.843] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.843] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.843] Packages: <none>
[17:44:47.843] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.843] Resolved: TRUE
[17:44:47.843] Value: <not collected>
[17:44:47.843] Conditions captured: <none>
[17:44:47.843] Early signaling: FALSE
[17:44:47.843] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.843] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.855] Chunk #1 of 2 ... DONE
[17:44:47.856] Chunk #2 of 2 ...
[17:44:47.856]  - Finding globals in '...' for chunk #2 ...
[17:44:47.856] getGlobalsAndPackages() ...
[17:44:47.856] Searching for globals...
[17:44:47.857] 
[17:44:47.857] Searching for globals ... DONE
[17:44:47.858] - globals: [0] <none>
[17:44:47.858] getGlobalsAndPackages() ... DONE
[17:44:47.858]    + additional globals found: [n=0] 
[17:44:47.858]    + additional namespaces needed: [n=0] 
[17:44:47.858]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:47.858]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:47.859]  - seeds: <none>
[17:44:47.859]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.859] getGlobalsAndPackages() ...
[17:44:47.859] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.860] Resolving globals: FALSE
[17:44:47.860] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:47.861] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.861] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.861] 
[17:44:47.862] getGlobalsAndPackages() ... DONE
[17:44:47.862] run() for ‘Future’ ...
[17:44:47.862] - state: ‘created’
[17:44:47.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.868]   - Field: ‘label’
[17:44:47.868]   - Field: ‘local’
[17:44:47.868]   - Field: ‘owner’
[17:44:47.868]   - Field: ‘envir’
[17:44:47.868]   - Field: ‘workers’
[17:44:47.868]   - Field: ‘packages’
[17:44:47.869]   - Field: ‘gc’
[17:44:47.869]   - Field: ‘job’
[17:44:47.869]   - Field: ‘conditions’
[17:44:47.869]   - Field: ‘expr’
[17:44:47.869]   - Field: ‘uuid’
[17:44:47.869]   - Field: ‘seed’
[17:44:47.869]   - Field: ‘version’
[17:44:47.869]   - Field: ‘result’
[17:44:47.870]   - Field: ‘asynchronous’
[17:44:47.870]   - Field: ‘calls’
[17:44:47.870]   - Field: ‘globals’
[17:44:47.870]   - Field: ‘stdout’
[17:44:47.870]   - Field: ‘earlySignal’
[17:44:47.870]   - Field: ‘lazy’
[17:44:47.870]   - Field: ‘state’
[17:44:47.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.871] - Launch lazy future ...
[17:44:47.871] Packages needed by the future expression (n = 0): <none>
[17:44:47.871] Packages needed by future strategies (n = 0): <none>
[17:44:47.872] {
[17:44:47.872]     {
[17:44:47.872]         {
[17:44:47.872]             ...future.startTime <- base::Sys.time()
[17:44:47.872]             {
[17:44:47.872]                 {
[17:44:47.872]                   {
[17:44:47.872]                     {
[17:44:47.872]                       base::local({
[17:44:47.872]                         has_future <- base::requireNamespace("future", 
[17:44:47.872]                           quietly = TRUE)
[17:44:47.872]                         if (has_future) {
[17:44:47.872]                           ns <- base::getNamespace("future")
[17:44:47.872]                           version <- ns[[".package"]][["version"]]
[17:44:47.872]                           if (is.null(version)) 
[17:44:47.872]                             version <- utils::packageVersion("future")
[17:44:47.872]                         }
[17:44:47.872]                         else {
[17:44:47.872]                           version <- NULL
[17:44:47.872]                         }
[17:44:47.872]                         if (!has_future || version < "1.8.0") {
[17:44:47.872]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.872]                             "", base::R.version$version.string), 
[17:44:47.872]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.872]                               "release", "version")], collapse = " "), 
[17:44:47.872]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.872]                             info)
[17:44:47.872]                           info <- base::paste(info, collapse = "; ")
[17:44:47.872]                           if (!has_future) {
[17:44:47.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.872]                               info)
[17:44:47.872]                           }
[17:44:47.872]                           else {
[17:44:47.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.872]                               info, version)
[17:44:47.872]                           }
[17:44:47.872]                           base::stop(msg)
[17:44:47.872]                         }
[17:44:47.872]                       })
[17:44:47.872]                     }
[17:44:47.872]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.872]                     base::options(mc.cores = 1L)
[17:44:47.872]                   }
[17:44:47.872]                   ...future.strategy.old <- future::plan("list")
[17:44:47.872]                   options(future.plan = NULL)
[17:44:47.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.872]                 }
[17:44:47.872]                 ...future.workdir <- getwd()
[17:44:47.872]             }
[17:44:47.872]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.872]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.872]         }
[17:44:47.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.872]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:47.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.872]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.872]             base::names(...future.oldOptions))
[17:44:47.872]     }
[17:44:47.872]     if (FALSE) {
[17:44:47.872]     }
[17:44:47.872]     else {
[17:44:47.872]         if (TRUE) {
[17:44:47.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.872]                 open = "w")
[17:44:47.872]         }
[17:44:47.872]         else {
[17:44:47.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.872]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.872]         }
[17:44:47.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.872]             base::sink(type = "output", split = FALSE)
[17:44:47.872]             base::close(...future.stdout)
[17:44:47.872]         }, add = TRUE)
[17:44:47.872]     }
[17:44:47.872]     ...future.frame <- base::sys.nframe()
[17:44:47.872]     ...future.conditions <- base::list()
[17:44:47.872]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.872]     if (FALSE) {
[17:44:47.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.872]     }
[17:44:47.872]     ...future.result <- base::tryCatch({
[17:44:47.872]         base::withCallingHandlers({
[17:44:47.872]             ...future.value <- base::withVisible(base::local({
[17:44:47.872]                 withCallingHandlers({
[17:44:47.872]                   {
[17:44:47.872]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.872]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.872]                       ...future.globals.maxSize)) {
[17:44:47.872]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.872]                       on.exit(options(oopts), add = TRUE)
[17:44:47.872]                     }
[17:44:47.872]                     {
[17:44:47.872]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.872]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.872]                         USE.NAMES = FALSE)
[17:44:47.872]                       do.call(mapply, args = args)
[17:44:47.872]                     }
[17:44:47.872]                   }
[17:44:47.872]                 }, immediateCondition = function(cond) {
[17:44:47.872]                   save_rds <- function (object, pathname, ...) 
[17:44:47.872]                   {
[17:44:47.872]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.872]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.872]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.872]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.872]                         fi_tmp[["mtime"]])
[17:44:47.872]                     }
[17:44:47.872]                     tryCatch({
[17:44:47.872]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.872]                     }, error = function(ex) {
[17:44:47.872]                       msg <- conditionMessage(ex)
[17:44:47.872]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.872]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.872]                         fi_tmp[["mtime"]], msg)
[17:44:47.872]                       ex$message <- msg
[17:44:47.872]                       stop(ex)
[17:44:47.872]                     })
[17:44:47.872]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.872]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.872]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.872]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.872]                       fi <- file.info(pathname)
[17:44:47.872]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.872]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.872]                         fi[["size"]], fi[["mtime"]])
[17:44:47.872]                       stop(msg)
[17:44:47.872]                     }
[17:44:47.872]                     invisible(pathname)
[17:44:47.872]                   }
[17:44:47.872]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.872]                     rootPath = tempdir()) 
[17:44:47.872]                   {
[17:44:47.872]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.872]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.872]                       tmpdir = path, fileext = ".rds")
[17:44:47.872]                     save_rds(obj, file)
[17:44:47.872]                   }
[17:44:47.872]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.872]                   {
[17:44:47.872]                     inherits <- base::inherits
[17:44:47.872]                     invokeRestart <- base::invokeRestart
[17:44:47.872]                     is.null <- base::is.null
[17:44:47.872]                     muffled <- FALSE
[17:44:47.872]                     if (inherits(cond, "message")) {
[17:44:47.872]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.872]                       if (muffled) 
[17:44:47.872]                         invokeRestart("muffleMessage")
[17:44:47.872]                     }
[17:44:47.872]                     else if (inherits(cond, "warning")) {
[17:44:47.872]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.872]                       if (muffled) 
[17:44:47.872]                         invokeRestart("muffleWarning")
[17:44:47.872]                     }
[17:44:47.872]                     else if (inherits(cond, "condition")) {
[17:44:47.872]                       if (!is.null(pattern)) {
[17:44:47.872]                         computeRestarts <- base::computeRestarts
[17:44:47.872]                         grepl <- base::grepl
[17:44:47.872]                         restarts <- computeRestarts(cond)
[17:44:47.872]                         for (restart in restarts) {
[17:44:47.872]                           name <- restart$name
[17:44:47.872]                           if (is.null(name)) 
[17:44:47.872]                             next
[17:44:47.872]                           if (!grepl(pattern, name)) 
[17:44:47.872]                             next
[17:44:47.872]                           invokeRestart(restart)
[17:44:47.872]                           muffled <- TRUE
[17:44:47.872]                           break
[17:44:47.872]                         }
[17:44:47.872]                       }
[17:44:47.872]                     }
[17:44:47.872]                     invisible(muffled)
[17:44:47.872]                   }
[17:44:47.872]                   muffleCondition(cond)
[17:44:47.872]                 })
[17:44:47.872]             }))
[17:44:47.872]             future::FutureResult(value = ...future.value$value, 
[17:44:47.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.872]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.872]                     ...future.globalenv.names))
[17:44:47.872]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.872]         }, condition = base::local({
[17:44:47.872]             c <- base::c
[17:44:47.872]             inherits <- base::inherits
[17:44:47.872]             invokeRestart <- base::invokeRestart
[17:44:47.872]             length <- base::length
[17:44:47.872]             list <- base::list
[17:44:47.872]             seq.int <- base::seq.int
[17:44:47.872]             signalCondition <- base::signalCondition
[17:44:47.872]             sys.calls <- base::sys.calls
[17:44:47.872]             `[[` <- base::`[[`
[17:44:47.872]             `+` <- base::`+`
[17:44:47.872]             `<<-` <- base::`<<-`
[17:44:47.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.872]                   3L)]
[17:44:47.872]             }
[17:44:47.872]             function(cond) {
[17:44:47.872]                 is_error <- inherits(cond, "error")
[17:44:47.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.872]                   NULL)
[17:44:47.872]                 if (is_error) {
[17:44:47.872]                   sessionInformation <- function() {
[17:44:47.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.872]                       search = base::search(), system = base::Sys.info())
[17:44:47.872]                   }
[17:44:47.872]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.872]                     cond$call), session = sessionInformation(), 
[17:44:47.872]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.872]                   signalCondition(cond)
[17:44:47.872]                 }
[17:44:47.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.872]                 "immediateCondition"))) {
[17:44:47.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.872]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.872]                   if (TRUE && !signal) {
[17:44:47.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.872]                     {
[17:44:47.872]                       inherits <- base::inherits
[17:44:47.872]                       invokeRestart <- base::invokeRestart
[17:44:47.872]                       is.null <- base::is.null
[17:44:47.872]                       muffled <- FALSE
[17:44:47.872]                       if (inherits(cond, "message")) {
[17:44:47.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.872]                         if (muffled) 
[17:44:47.872]                           invokeRestart("muffleMessage")
[17:44:47.872]                       }
[17:44:47.872]                       else if (inherits(cond, "warning")) {
[17:44:47.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.872]                         if (muffled) 
[17:44:47.872]                           invokeRestart("muffleWarning")
[17:44:47.872]                       }
[17:44:47.872]                       else if (inherits(cond, "condition")) {
[17:44:47.872]                         if (!is.null(pattern)) {
[17:44:47.872]                           computeRestarts <- base::computeRestarts
[17:44:47.872]                           grepl <- base::grepl
[17:44:47.872]                           restarts <- computeRestarts(cond)
[17:44:47.872]                           for (restart in restarts) {
[17:44:47.872]                             name <- restart$name
[17:44:47.872]                             if (is.null(name)) 
[17:44:47.872]                               next
[17:44:47.872]                             if (!grepl(pattern, name)) 
[17:44:47.872]                               next
[17:44:47.872]                             invokeRestart(restart)
[17:44:47.872]                             muffled <- TRUE
[17:44:47.872]                             break
[17:44:47.872]                           }
[17:44:47.872]                         }
[17:44:47.872]                       }
[17:44:47.872]                       invisible(muffled)
[17:44:47.872]                     }
[17:44:47.872]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.872]                   }
[17:44:47.872]                 }
[17:44:47.872]                 else {
[17:44:47.872]                   if (TRUE) {
[17:44:47.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.872]                     {
[17:44:47.872]                       inherits <- base::inherits
[17:44:47.872]                       invokeRestart <- base::invokeRestart
[17:44:47.872]                       is.null <- base::is.null
[17:44:47.872]                       muffled <- FALSE
[17:44:47.872]                       if (inherits(cond, "message")) {
[17:44:47.872]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.872]                         if (muffled) 
[17:44:47.872]                           invokeRestart("muffleMessage")
[17:44:47.872]                       }
[17:44:47.872]                       else if (inherits(cond, "warning")) {
[17:44:47.872]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.872]                         if (muffled) 
[17:44:47.872]                           invokeRestart("muffleWarning")
[17:44:47.872]                       }
[17:44:47.872]                       else if (inherits(cond, "condition")) {
[17:44:47.872]                         if (!is.null(pattern)) {
[17:44:47.872]                           computeRestarts <- base::computeRestarts
[17:44:47.872]                           grepl <- base::grepl
[17:44:47.872]                           restarts <- computeRestarts(cond)
[17:44:47.872]                           for (restart in restarts) {
[17:44:47.872]                             name <- restart$name
[17:44:47.872]                             if (is.null(name)) 
[17:44:47.872]                               next
[17:44:47.872]                             if (!grepl(pattern, name)) 
[17:44:47.872]                               next
[17:44:47.872]                             invokeRestart(restart)
[17:44:47.872]                             muffled <- TRUE
[17:44:47.872]                             break
[17:44:47.872]                           }
[17:44:47.872]                         }
[17:44:47.872]                       }
[17:44:47.872]                       invisible(muffled)
[17:44:47.872]                     }
[17:44:47.872]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.872]                   }
[17:44:47.872]                 }
[17:44:47.872]             }
[17:44:47.872]         }))
[17:44:47.872]     }, error = function(ex) {
[17:44:47.872]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.872]                 ...future.rng), started = ...future.startTime, 
[17:44:47.872]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.872]             version = "1.8"), class = "FutureResult")
[17:44:47.872]     }, finally = {
[17:44:47.872]         if (!identical(...future.workdir, getwd())) 
[17:44:47.872]             setwd(...future.workdir)
[17:44:47.872]         {
[17:44:47.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.872]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.872]             }
[17:44:47.872]             base::options(...future.oldOptions)
[17:44:47.872]             if (.Platform$OS.type == "windows") {
[17:44:47.872]                 old_names <- names(...future.oldEnvVars)
[17:44:47.872]                 envs <- base::Sys.getenv()
[17:44:47.872]                 names <- names(envs)
[17:44:47.872]                 common <- intersect(names, old_names)
[17:44:47.872]                 added <- setdiff(names, old_names)
[17:44:47.872]                 removed <- setdiff(old_names, names)
[17:44:47.872]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.872]                   envs[common]]
[17:44:47.872]                 NAMES <- toupper(changed)
[17:44:47.872]                 args <- list()
[17:44:47.872]                 for (kk in seq_along(NAMES)) {
[17:44:47.872]                   name <- changed[[kk]]
[17:44:47.872]                   NAME <- NAMES[[kk]]
[17:44:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.872]                     next
[17:44:47.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.872]                 }
[17:44:47.872]                 NAMES <- toupper(added)
[17:44:47.872]                 for (kk in seq_along(NAMES)) {
[17:44:47.872]                   name <- added[[kk]]
[17:44:47.872]                   NAME <- NAMES[[kk]]
[17:44:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.872]                     next
[17:44:47.872]                   args[[name]] <- ""
[17:44:47.872]                 }
[17:44:47.872]                 NAMES <- toupper(removed)
[17:44:47.872]                 for (kk in seq_along(NAMES)) {
[17:44:47.872]                   name <- removed[[kk]]
[17:44:47.872]                   NAME <- NAMES[[kk]]
[17:44:47.872]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.872]                     next
[17:44:47.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.872]                 }
[17:44:47.872]                 if (length(args) > 0) 
[17:44:47.872]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.872]             }
[17:44:47.872]             else {
[17:44:47.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.872]             }
[17:44:47.872]             {
[17:44:47.872]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.872]                   0L) {
[17:44:47.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.872]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.872]                   base::options(opts)
[17:44:47.872]                 }
[17:44:47.872]                 {
[17:44:47.872]                   {
[17:44:47.872]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.872]                     NULL
[17:44:47.872]                   }
[17:44:47.872]                   options(future.plan = NULL)
[17:44:47.872]                   if (is.na(NA_character_)) 
[17:44:47.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.872]                     .init = FALSE)
[17:44:47.872]                 }
[17:44:47.872]             }
[17:44:47.872]         }
[17:44:47.872]     })
[17:44:47.872]     if (TRUE) {
[17:44:47.872]         base::sink(type = "output", split = FALSE)
[17:44:47.872]         if (TRUE) {
[17:44:47.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.872]         }
[17:44:47.872]         else {
[17:44:47.872]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.872]         }
[17:44:47.872]         base::close(...future.stdout)
[17:44:47.872]         ...future.stdout <- NULL
[17:44:47.872]     }
[17:44:47.872]     ...future.result$conditions <- ...future.conditions
[17:44:47.872]     ...future.result$finished <- base::Sys.time()
[17:44:47.872]     ...future.result
[17:44:47.872] }
[17:44:47.875] assign_globals() ...
[17:44:47.875] List of 5
[17:44:47.875]  $ ...future.FUN            :function (C, k)  
[17:44:47.875]  $ MoreArgs                 : list()
[17:44:47.875]  $ ...future.elements_ii    :List of 2
[17:44:47.875]   ..$ :List of 3
[17:44:47.875]   .. ..$ : chr "C"
[17:44:47.875]   .. ..$ : chr "D"
[17:44:47.875]   .. ..$ : chr "E"
[17:44:47.875]   ..$ :List of 3
[17:44:47.875]   .. ..$ : int 3
[17:44:47.875]   .. ..$ : int 2
[17:44:47.875]   .. ..$ : int 1
[17:44:47.875]  $ ...future.seeds_ii       : NULL
[17:44:47.875]  $ ...future.globals.maxSize: NULL
[17:44:47.875]  - attr(*, "where")=List of 5
[17:44:47.875]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.875]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.875]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.875]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.875]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.875]  - attr(*, "resolved")= logi FALSE
[17:44:47.875]  - attr(*, "total_size")= num 3824
[17:44:47.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.875]  - attr(*, "already-done")= logi TRUE
[17:44:47.883] - reassign environment for ‘...future.FUN’
[17:44:47.883] - copied ‘...future.FUN’ to environment
[17:44:47.884] - copied ‘MoreArgs’ to environment
[17:44:47.884] - copied ‘...future.elements_ii’ to environment
[17:44:47.884] - copied ‘...future.seeds_ii’ to environment
[17:44:47.884] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.884] assign_globals() ... done
[17:44:47.884] requestCore(): workers = 2
[17:44:47.889] MulticoreFuture started
[17:44:47.890] - Launch lazy future ... done
[17:44:47.891] run() for ‘MulticoreFuture’ ... done
[17:44:47.891] plan(): Setting new future strategy stack:
[17:44:47.891] Created future:
[17:44:47.891] List of future strategies:
[17:44:47.891] 1. sequential:
[17:44:47.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.891]    - tweaked: FALSE
[17:44:47.891]    - call: NULL
[17:44:47.893] plan(): nbrOfWorkers() = 1
[17:44:47.896] plan(): Setting new future strategy stack:
[17:44:47.896] List of future strategies:
[17:44:47.896] 1. multicore:
[17:44:47.896]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.896]    - tweaked: FALSE
[17:44:47.896]    - call: plan(strategy)
[17:44:47.903] plan(): nbrOfWorkers() = 2
[17:44:47.892] MulticoreFuture:
[17:44:47.892] Label: ‘future_.mapply-2’
[17:44:47.892] Expression:
[17:44:47.892] {
[17:44:47.892]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.892]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.892]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.892]         on.exit(options(oopts), add = TRUE)
[17:44:47.892]     }
[17:44:47.892]     {
[17:44:47.892]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.892]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.892]         do.call(mapply, args = args)
[17:44:47.892]     }
[17:44:47.892] }
[17:44:47.892] Lazy evaluation: FALSE
[17:44:47.892] Asynchronous evaluation: TRUE
[17:44:47.892] Local evaluation: TRUE
[17:44:47.892] Environment: R_GlobalEnv
[17:44:47.892] Capture standard output: TRUE
[17:44:47.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.892] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.892] Packages: <none>
[17:44:47.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.892] Resolved: TRUE
[17:44:47.892] Value: <not collected>
[17:44:47.892] Conditions captured: <none>
[17:44:47.892] Early signaling: FALSE
[17:44:47.892] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.892] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.904] Chunk #2 of 2 ... DONE
[17:44:47.904] Launching 2 futures (chunks) ... DONE
[17:44:47.905] Resolving 2 futures (chunks) ...
[17:44:47.905] resolve() on list ...
[17:44:47.905]  recursive: 0
[17:44:47.905]  length: 2
[17:44:47.905] 
[17:44:47.906] Future #1
[17:44:47.906] result() for MulticoreFuture ...
[17:44:47.907] result() for MulticoreFuture ...
[17:44:47.907] result() for MulticoreFuture ... done
[17:44:47.907] result() for MulticoreFuture ... done
[17:44:47.908] result() for MulticoreFuture ...
[17:44:47.908] result() for MulticoreFuture ... done
[17:44:47.908] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.908] - nx: 2
[17:44:47.908] - relay: TRUE
[17:44:47.909] - stdout: TRUE
[17:44:47.909] - signal: TRUE
[17:44:47.909] - resignal: FALSE
[17:44:47.909] - force: TRUE
[17:44:47.909] - relayed: [n=2] FALSE, FALSE
[17:44:47.910] - queued futures: [n=2] FALSE, FALSE
[17:44:47.910]  - until=1
[17:44:47.910]  - relaying element #1
[17:44:47.910] result() for MulticoreFuture ...
[17:44:47.911] result() for MulticoreFuture ... done
[17:44:47.911] result() for MulticoreFuture ...
[17:44:47.911] result() for MulticoreFuture ... done
[17:44:47.911] result() for MulticoreFuture ...
[17:44:47.911] result() for MulticoreFuture ... done
[17:44:47.912] result() for MulticoreFuture ...
[17:44:47.912] result() for MulticoreFuture ... done
[17:44:47.912] - relayed: [n=2] TRUE, FALSE
[17:44:47.912] - queued futures: [n=2] TRUE, FALSE
[17:44:47.912] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.912]  length: 1 (resolved future 1)
[17:44:47.913] Future #2
[17:44:47.913] result() for MulticoreFuture ...
[17:44:47.914] result() for MulticoreFuture ...
[17:44:47.914] result() for MulticoreFuture ... done
[17:44:47.914] result() for MulticoreFuture ... done
[17:44:47.914] result() for MulticoreFuture ...
[17:44:47.914] result() for MulticoreFuture ... done
[17:44:47.914] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:47.914] - nx: 2
[17:44:47.915] - relay: TRUE
[17:44:47.915] - stdout: TRUE
[17:44:47.915] - signal: TRUE
[17:44:47.915] - resignal: FALSE
[17:44:47.915] - force: TRUE
[17:44:47.915] - relayed: [n=2] TRUE, FALSE
[17:44:47.915] - queued futures: [n=2] TRUE, FALSE
[17:44:47.915]  - until=2
[17:44:47.916]  - relaying element #2
[17:44:47.916] result() for MulticoreFuture ...
[17:44:47.916] result() for MulticoreFuture ... done
[17:44:47.916] result() for MulticoreFuture ...
[17:44:47.916] result() for MulticoreFuture ... done
[17:44:47.916] result() for MulticoreFuture ...
[17:44:47.916] result() for MulticoreFuture ... done
[17:44:47.916] result() for MulticoreFuture ...
[17:44:47.917] result() for MulticoreFuture ... done
[17:44:47.917] - relayed: [n=2] TRUE, TRUE
[17:44:47.917] - queued futures: [n=2] TRUE, TRUE
[17:44:47.917] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:47.917]  length: 0 (resolved future 2)
[17:44:47.917] Relaying remaining futures
[17:44:47.917] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.917] - nx: 2
[17:44:47.917] - relay: TRUE
[17:44:47.917] - stdout: TRUE
[17:44:47.918] - signal: TRUE
[17:44:47.918] - resignal: FALSE
[17:44:47.918] - force: TRUE
[17:44:47.918] - relayed: [n=2] TRUE, TRUE
[17:44:47.918] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:47.918] - relayed: [n=2] TRUE, TRUE
[17:44:47.918] - queued futures: [n=2] TRUE, TRUE
[17:44:47.918] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.918] resolve() on list ... DONE
[17:44:47.918] result() for MulticoreFuture ...
[17:44:47.919] result() for MulticoreFuture ... done
[17:44:47.919] result() for MulticoreFuture ...
[17:44:47.919] result() for MulticoreFuture ... done
[17:44:47.919] result() for MulticoreFuture ...
[17:44:47.919] result() for MulticoreFuture ... done
[17:44:47.919] result() for MulticoreFuture ...
[17:44:47.919] result() for MulticoreFuture ... done
[17:44:47.919]  - Number of value chunks collected: 2
[17:44:47.920] Resolving 2 futures (chunks) ... DONE
[17:44:47.920] Reducing values from 2 chunks ...
[17:44:47.920]  - Number of values collected after concatenation: 5
[17:44:47.920]  - Number of values expected: 5
[17:44:47.920] Reducing values from 2 chunks ... DONE
[17:44:47.920] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:44:47.920] future_mapply() ...
[17:44:47.925] Number of chunks: 1
[17:44:47.925] getGlobalsAndPackagesXApply() ...
[17:44:47.925]  - future.globals: TRUE
[17:44:47.925] getGlobalsAndPackages() ...
[17:44:47.925] Searching for globals...
[17:44:47.927] - globals found: [1] ‘FUN’
[17:44:47.927] Searching for globals ... DONE
[17:44:47.927] Resolving globals: FALSE
[17:44:47.927] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:47.928] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:47.928] - globals: [1] ‘FUN’
[17:44:47.928] 
[17:44:47.928] getGlobalsAndPackages() ... DONE
[17:44:47.928]  - globals found/used: [n=1] ‘FUN’
[17:44:47.928]  - needed namespaces: [n=0] 
[17:44:47.928] Finding globals ... DONE
[17:44:47.929] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.929] List of 2
[17:44:47.929]  $ ...future.FUN:function (x)  
[17:44:47.929]  $ MoreArgs     : NULL
[17:44:47.929]  - attr(*, "where")=List of 2
[17:44:47.929]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.929]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.929]  - attr(*, "resolved")= logi FALSE
[17:44:47.929]  - attr(*, "total_size")= num NA
[17:44:47.931] Packages to be attached in all futures: [n=0] 
[17:44:47.932] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.932] Number of futures (= number of chunks): 1
[17:44:47.932] Launching 1 futures (chunks) ...
[17:44:47.935] Chunk #1 of 1 ...
[17:44:47.935]  - Finding globals in '...' for chunk #1 ...
[17:44:47.935] getGlobalsAndPackages() ...
[17:44:47.935] Searching for globals...
[17:44:47.935] 
[17:44:47.936] Searching for globals ... DONE
[17:44:47.936] - globals: [0] <none>
[17:44:47.936] getGlobalsAndPackages() ... DONE
[17:44:47.936]    + additional globals found: [n=0] 
[17:44:47.936]    + additional namespaces needed: [n=0] 
[17:44:47.936]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.936]  - seeds: <none>
[17:44:47.936]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.936] getGlobalsAndPackages() ...
[17:44:47.937] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.937] Resolving globals: FALSE
[17:44:47.937] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:47.938] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:47.938] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.938] 
[17:44:47.938] getGlobalsAndPackages() ... DONE
[17:44:47.939] run() for ‘Future’ ...
[17:44:47.939] - state: ‘created’
[17:44:47.939] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:47.943] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:47.943]   - Field: ‘label’
[17:44:47.943]   - Field: ‘local’
[17:44:47.943]   - Field: ‘owner’
[17:44:47.943]   - Field: ‘envir’
[17:44:47.943]   - Field: ‘workers’
[17:44:47.944]   - Field: ‘packages’
[17:44:47.944]   - Field: ‘gc’
[17:44:47.944]   - Field: ‘job’
[17:44:47.944]   - Field: ‘conditions’
[17:44:47.944]   - Field: ‘expr’
[17:44:47.944]   - Field: ‘uuid’
[17:44:47.944]   - Field: ‘seed’
[17:44:47.944]   - Field: ‘version’
[17:44:47.944]   - Field: ‘result’
[17:44:47.944]   - Field: ‘asynchronous’
[17:44:47.945]   - Field: ‘calls’
[17:44:47.945]   - Field: ‘globals’
[17:44:47.945]   - Field: ‘stdout’
[17:44:47.945]   - Field: ‘earlySignal’
[17:44:47.945]   - Field: ‘lazy’
[17:44:47.945]   - Field: ‘state’
[17:44:47.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:47.945] - Launch lazy future ...
[17:44:47.945] Packages needed by the future expression (n = 0): <none>
[17:44:47.946] Packages needed by future strategies (n = 0): <none>
[17:44:47.946] {
[17:44:47.946]     {
[17:44:47.946]         {
[17:44:47.946]             ...future.startTime <- base::Sys.time()
[17:44:47.946]             {
[17:44:47.946]                 {
[17:44:47.946]                   {
[17:44:47.946]                     {
[17:44:47.946]                       base::local({
[17:44:47.946]                         has_future <- base::requireNamespace("future", 
[17:44:47.946]                           quietly = TRUE)
[17:44:47.946]                         if (has_future) {
[17:44:47.946]                           ns <- base::getNamespace("future")
[17:44:47.946]                           version <- ns[[".package"]][["version"]]
[17:44:47.946]                           if (is.null(version)) 
[17:44:47.946]                             version <- utils::packageVersion("future")
[17:44:47.946]                         }
[17:44:47.946]                         else {
[17:44:47.946]                           version <- NULL
[17:44:47.946]                         }
[17:44:47.946]                         if (!has_future || version < "1.8.0") {
[17:44:47.946]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:47.946]                             "", base::R.version$version.string), 
[17:44:47.946]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:47.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:47.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:47.946]                               "release", "version")], collapse = " "), 
[17:44:47.946]                             hostname = base::Sys.info()[["nodename"]])
[17:44:47.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:47.946]                             info)
[17:44:47.946]                           info <- base::paste(info, collapse = "; ")
[17:44:47.946]                           if (!has_future) {
[17:44:47.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:47.946]                               info)
[17:44:47.946]                           }
[17:44:47.946]                           else {
[17:44:47.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:47.946]                               info, version)
[17:44:47.946]                           }
[17:44:47.946]                           base::stop(msg)
[17:44:47.946]                         }
[17:44:47.946]                       })
[17:44:47.946]                     }
[17:44:47.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:47.946]                     base::options(mc.cores = 1L)
[17:44:47.946]                   }
[17:44:47.946]                   ...future.strategy.old <- future::plan("list")
[17:44:47.946]                   options(future.plan = NULL)
[17:44:47.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:47.946]                 }
[17:44:47.946]                 ...future.workdir <- getwd()
[17:44:47.946]             }
[17:44:47.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:47.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:47.946]         }
[17:44:47.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:47.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:47.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:47.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:47.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:47.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:47.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:47.946]             base::names(...future.oldOptions))
[17:44:47.946]     }
[17:44:47.946]     if (FALSE) {
[17:44:47.946]     }
[17:44:47.946]     else {
[17:44:47.946]         if (TRUE) {
[17:44:47.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:47.946]                 open = "w")
[17:44:47.946]         }
[17:44:47.946]         else {
[17:44:47.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:47.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:47.946]         }
[17:44:47.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:47.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:47.946]             base::sink(type = "output", split = FALSE)
[17:44:47.946]             base::close(...future.stdout)
[17:44:47.946]         }, add = TRUE)
[17:44:47.946]     }
[17:44:47.946]     ...future.frame <- base::sys.nframe()
[17:44:47.946]     ...future.conditions <- base::list()
[17:44:47.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:47.946]     if (FALSE) {
[17:44:47.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:47.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:47.946]     }
[17:44:47.946]     ...future.result <- base::tryCatch({
[17:44:47.946]         base::withCallingHandlers({
[17:44:47.946]             ...future.value <- base::withVisible(base::local({
[17:44:47.946]                 withCallingHandlers({
[17:44:47.946]                   {
[17:44:47.946]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.946]                     if (!identical(...future.globals.maxSize.org, 
[17:44:47.946]                       ...future.globals.maxSize)) {
[17:44:47.946]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.946]                       on.exit(options(oopts), add = TRUE)
[17:44:47.946]                     }
[17:44:47.946]                     {
[17:44:47.946]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.946]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:47.946]                         USE.NAMES = FALSE)
[17:44:47.946]                       do.call(mapply, args = args)
[17:44:47.946]                     }
[17:44:47.946]                   }
[17:44:47.946]                 }, immediateCondition = function(cond) {
[17:44:47.946]                   save_rds <- function (object, pathname, ...) 
[17:44:47.946]                   {
[17:44:47.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:47.946]                     if (file_test("-f", pathname_tmp)) {
[17:44:47.946]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.946]                         fi_tmp[["mtime"]])
[17:44:47.946]                     }
[17:44:47.946]                     tryCatch({
[17:44:47.946]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:47.946]                     }, error = function(ex) {
[17:44:47.946]                       msg <- conditionMessage(ex)
[17:44:47.946]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.946]                         fi_tmp[["mtime"]], msg)
[17:44:47.946]                       ex$message <- msg
[17:44:47.946]                       stop(ex)
[17:44:47.946]                     })
[17:44:47.946]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:47.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:47.946]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:47.946]                       fi_tmp <- file.info(pathname_tmp)
[17:44:47.946]                       fi <- file.info(pathname)
[17:44:47.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:47.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:47.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:47.946]                         fi[["size"]], fi[["mtime"]])
[17:44:47.946]                       stop(msg)
[17:44:47.946]                     }
[17:44:47.946]                     invisible(pathname)
[17:44:47.946]                   }
[17:44:47.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:47.946]                     rootPath = tempdir()) 
[17:44:47.946]                   {
[17:44:47.946]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:47.946]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:47.946]                       tmpdir = path, fileext = ".rds")
[17:44:47.946]                     save_rds(obj, file)
[17:44:47.946]                   }
[17:44:47.946]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:47.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.946]                   {
[17:44:47.946]                     inherits <- base::inherits
[17:44:47.946]                     invokeRestart <- base::invokeRestart
[17:44:47.946]                     is.null <- base::is.null
[17:44:47.946]                     muffled <- FALSE
[17:44:47.946]                     if (inherits(cond, "message")) {
[17:44:47.946]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:47.946]                       if (muffled) 
[17:44:47.946]                         invokeRestart("muffleMessage")
[17:44:47.946]                     }
[17:44:47.946]                     else if (inherits(cond, "warning")) {
[17:44:47.946]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:47.946]                       if (muffled) 
[17:44:47.946]                         invokeRestart("muffleWarning")
[17:44:47.946]                     }
[17:44:47.946]                     else if (inherits(cond, "condition")) {
[17:44:47.946]                       if (!is.null(pattern)) {
[17:44:47.946]                         computeRestarts <- base::computeRestarts
[17:44:47.946]                         grepl <- base::grepl
[17:44:47.946]                         restarts <- computeRestarts(cond)
[17:44:47.946]                         for (restart in restarts) {
[17:44:47.946]                           name <- restart$name
[17:44:47.946]                           if (is.null(name)) 
[17:44:47.946]                             next
[17:44:47.946]                           if (!grepl(pattern, name)) 
[17:44:47.946]                             next
[17:44:47.946]                           invokeRestart(restart)
[17:44:47.946]                           muffled <- TRUE
[17:44:47.946]                           break
[17:44:47.946]                         }
[17:44:47.946]                       }
[17:44:47.946]                     }
[17:44:47.946]                     invisible(muffled)
[17:44:47.946]                   }
[17:44:47.946]                   muffleCondition(cond)
[17:44:47.946]                 })
[17:44:47.946]             }))
[17:44:47.946]             future::FutureResult(value = ...future.value$value, 
[17:44:47.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.946]                   ...future.rng), globalenv = if (FALSE) 
[17:44:47.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:47.946]                     ...future.globalenv.names))
[17:44:47.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:47.946]         }, condition = base::local({
[17:44:47.946]             c <- base::c
[17:44:47.946]             inherits <- base::inherits
[17:44:47.946]             invokeRestart <- base::invokeRestart
[17:44:47.946]             length <- base::length
[17:44:47.946]             list <- base::list
[17:44:47.946]             seq.int <- base::seq.int
[17:44:47.946]             signalCondition <- base::signalCondition
[17:44:47.946]             sys.calls <- base::sys.calls
[17:44:47.946]             `[[` <- base::`[[`
[17:44:47.946]             `+` <- base::`+`
[17:44:47.946]             `<<-` <- base::`<<-`
[17:44:47.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:47.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:47.946]                   3L)]
[17:44:47.946]             }
[17:44:47.946]             function(cond) {
[17:44:47.946]                 is_error <- inherits(cond, "error")
[17:44:47.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:47.946]                   NULL)
[17:44:47.946]                 if (is_error) {
[17:44:47.946]                   sessionInformation <- function() {
[17:44:47.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:47.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:47.946]                       search = base::search(), system = base::Sys.info())
[17:44:47.946]                   }
[17:44:47.946]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:47.946]                     cond$call), session = sessionInformation(), 
[17:44:47.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:47.946]                   signalCondition(cond)
[17:44:47.946]                 }
[17:44:47.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:47.946]                 "immediateCondition"))) {
[17:44:47.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:47.946]                   ...future.conditions[[length(...future.conditions) + 
[17:44:47.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:47.946]                   if (TRUE && !signal) {
[17:44:47.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.946]                     {
[17:44:47.946]                       inherits <- base::inherits
[17:44:47.946]                       invokeRestart <- base::invokeRestart
[17:44:47.946]                       is.null <- base::is.null
[17:44:47.946]                       muffled <- FALSE
[17:44:47.946]                       if (inherits(cond, "message")) {
[17:44:47.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.946]                         if (muffled) 
[17:44:47.946]                           invokeRestart("muffleMessage")
[17:44:47.946]                       }
[17:44:47.946]                       else if (inherits(cond, "warning")) {
[17:44:47.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.946]                         if (muffled) 
[17:44:47.946]                           invokeRestart("muffleWarning")
[17:44:47.946]                       }
[17:44:47.946]                       else if (inherits(cond, "condition")) {
[17:44:47.946]                         if (!is.null(pattern)) {
[17:44:47.946]                           computeRestarts <- base::computeRestarts
[17:44:47.946]                           grepl <- base::grepl
[17:44:47.946]                           restarts <- computeRestarts(cond)
[17:44:47.946]                           for (restart in restarts) {
[17:44:47.946]                             name <- restart$name
[17:44:47.946]                             if (is.null(name)) 
[17:44:47.946]                               next
[17:44:47.946]                             if (!grepl(pattern, name)) 
[17:44:47.946]                               next
[17:44:47.946]                             invokeRestart(restart)
[17:44:47.946]                             muffled <- TRUE
[17:44:47.946]                             break
[17:44:47.946]                           }
[17:44:47.946]                         }
[17:44:47.946]                       }
[17:44:47.946]                       invisible(muffled)
[17:44:47.946]                     }
[17:44:47.946]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.946]                   }
[17:44:47.946]                 }
[17:44:47.946]                 else {
[17:44:47.946]                   if (TRUE) {
[17:44:47.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:47.946]                     {
[17:44:47.946]                       inherits <- base::inherits
[17:44:47.946]                       invokeRestart <- base::invokeRestart
[17:44:47.946]                       is.null <- base::is.null
[17:44:47.946]                       muffled <- FALSE
[17:44:47.946]                       if (inherits(cond, "message")) {
[17:44:47.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:47.946]                         if (muffled) 
[17:44:47.946]                           invokeRestart("muffleMessage")
[17:44:47.946]                       }
[17:44:47.946]                       else if (inherits(cond, "warning")) {
[17:44:47.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:47.946]                         if (muffled) 
[17:44:47.946]                           invokeRestart("muffleWarning")
[17:44:47.946]                       }
[17:44:47.946]                       else if (inherits(cond, "condition")) {
[17:44:47.946]                         if (!is.null(pattern)) {
[17:44:47.946]                           computeRestarts <- base::computeRestarts
[17:44:47.946]                           grepl <- base::grepl
[17:44:47.946]                           restarts <- computeRestarts(cond)
[17:44:47.946]                           for (restart in restarts) {
[17:44:47.946]                             name <- restart$name
[17:44:47.946]                             if (is.null(name)) 
[17:44:47.946]                               next
[17:44:47.946]                             if (!grepl(pattern, name)) 
[17:44:47.946]                               next
[17:44:47.946]                             invokeRestart(restart)
[17:44:47.946]                             muffled <- TRUE
[17:44:47.946]                             break
[17:44:47.946]                           }
[17:44:47.946]                         }
[17:44:47.946]                       }
[17:44:47.946]                       invisible(muffled)
[17:44:47.946]                     }
[17:44:47.946]                     muffleCondition(cond, pattern = "^muffle")
[17:44:47.946]                   }
[17:44:47.946]                 }
[17:44:47.946]             }
[17:44:47.946]         }))
[17:44:47.946]     }, error = function(ex) {
[17:44:47.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:47.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:47.946]                 ...future.rng), started = ...future.startTime, 
[17:44:47.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:47.946]             version = "1.8"), class = "FutureResult")
[17:44:47.946]     }, finally = {
[17:44:47.946]         if (!identical(...future.workdir, getwd())) 
[17:44:47.946]             setwd(...future.workdir)
[17:44:47.946]         {
[17:44:47.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:47.946]                 ...future.oldOptions$nwarnings <- NULL
[17:44:47.946]             }
[17:44:47.946]             base::options(...future.oldOptions)
[17:44:47.946]             if (.Platform$OS.type == "windows") {
[17:44:47.946]                 old_names <- names(...future.oldEnvVars)
[17:44:47.946]                 envs <- base::Sys.getenv()
[17:44:47.946]                 names <- names(envs)
[17:44:47.946]                 common <- intersect(names, old_names)
[17:44:47.946]                 added <- setdiff(names, old_names)
[17:44:47.946]                 removed <- setdiff(old_names, names)
[17:44:47.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:47.946]                   envs[common]]
[17:44:47.946]                 NAMES <- toupper(changed)
[17:44:47.946]                 args <- list()
[17:44:47.946]                 for (kk in seq_along(NAMES)) {
[17:44:47.946]                   name <- changed[[kk]]
[17:44:47.946]                   NAME <- NAMES[[kk]]
[17:44:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.946]                     next
[17:44:47.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.946]                 }
[17:44:47.946]                 NAMES <- toupper(added)
[17:44:47.946]                 for (kk in seq_along(NAMES)) {
[17:44:47.946]                   name <- added[[kk]]
[17:44:47.946]                   NAME <- NAMES[[kk]]
[17:44:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.946]                     next
[17:44:47.946]                   args[[name]] <- ""
[17:44:47.946]                 }
[17:44:47.946]                 NAMES <- toupper(removed)
[17:44:47.946]                 for (kk in seq_along(NAMES)) {
[17:44:47.946]                   name <- removed[[kk]]
[17:44:47.946]                   NAME <- NAMES[[kk]]
[17:44:47.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:47.946]                     next
[17:44:47.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:47.946]                 }
[17:44:47.946]                 if (length(args) > 0) 
[17:44:47.946]                   base::do.call(base::Sys.setenv, args = args)
[17:44:47.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:47.946]             }
[17:44:47.946]             else {
[17:44:47.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:47.946]             }
[17:44:47.946]             {
[17:44:47.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:47.946]                   0L) {
[17:44:47.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:47.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:47.946]                   base::options(opts)
[17:44:47.946]                 }
[17:44:47.946]                 {
[17:44:47.946]                   {
[17:44:47.946]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:47.946]                     NULL
[17:44:47.946]                   }
[17:44:47.946]                   options(future.plan = NULL)
[17:44:47.946]                   if (is.na(NA_character_)) 
[17:44:47.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:47.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:47.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:47.946]                     .init = FALSE)
[17:44:47.946]                 }
[17:44:47.946]             }
[17:44:47.946]         }
[17:44:47.946]     })
[17:44:47.946]     if (TRUE) {
[17:44:47.946]         base::sink(type = "output", split = FALSE)
[17:44:47.946]         if (TRUE) {
[17:44:47.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:47.946]         }
[17:44:47.946]         else {
[17:44:47.946]             ...future.result["stdout"] <- base::list(NULL)
[17:44:47.946]         }
[17:44:47.946]         base::close(...future.stdout)
[17:44:47.946]         ...future.stdout <- NULL
[17:44:47.946]     }
[17:44:47.946]     ...future.result$conditions <- ...future.conditions
[17:44:47.946]     ...future.result$finished <- base::Sys.time()
[17:44:47.946]     ...future.result
[17:44:47.946] }
[17:44:47.948] assign_globals() ...
[17:44:47.949] List of 5
[17:44:47.949]  $ ...future.FUN            :function (x)  
[17:44:47.949]  $ MoreArgs                 : NULL
[17:44:47.949]  $ ...future.elements_ii    :List of 1
[17:44:47.949]   ..$ :List of 1
[17:44:47.949]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:44:47.949]  $ ...future.seeds_ii       : NULL
[17:44:47.949]  $ ...future.globals.maxSize: NULL
[17:44:47.949]  - attr(*, "where")=List of 5
[17:44:47.949]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:47.949]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:47.949]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:47.949]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:47.949]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:47.949]  - attr(*, "resolved")= logi FALSE
[17:44:47.949]  - attr(*, "total_size")= num 1128
[17:44:47.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.949]  - attr(*, "already-done")= logi TRUE
[17:44:47.953] - copied ‘...future.FUN’ to environment
[17:44:47.953] - copied ‘MoreArgs’ to environment
[17:44:47.953] - copied ‘...future.elements_ii’ to environment
[17:44:47.953] - copied ‘...future.seeds_ii’ to environment
[17:44:47.954] - copied ‘...future.globals.maxSize’ to environment
[17:44:47.954] assign_globals() ... done
[17:44:47.954] requestCore(): workers = 2
[17:44:47.956] MulticoreFuture started
[17:44:47.956] - Launch lazy future ... done
[17:44:47.957] run() for ‘MulticoreFuture’ ... done
[17:44:47.957] Created future:
[17:44:47.957] plan(): Setting new future strategy stack:
[17:44:47.957] List of future strategies:
[17:44:47.957] 1. sequential:
[17:44:47.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:47.957]    - tweaked: FALSE
[17:44:47.957]    - call: NULL
[17:44:47.958] plan(): nbrOfWorkers() = 1
[17:44:47.960] plan(): Setting new future strategy stack:
[17:44:47.960] List of future strategies:
[17:44:47.960] 1. multicore:
[17:44:47.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:47.960]    - tweaked: FALSE
[17:44:47.960]    - call: plan(strategy)
[17:44:47.966] plan(): nbrOfWorkers() = 2
[17:44:47.957] MulticoreFuture:
[17:44:47.957] Label: ‘future_mapply-1’
[17:44:47.957] Expression:
[17:44:47.957] {
[17:44:47.957]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:47.957]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:47.957]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:47.957]         on.exit(options(oopts), add = TRUE)
[17:44:47.957]     }
[17:44:47.957]     {
[17:44:47.957]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:47.957]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:47.957]         do.call(mapply, args = args)
[17:44:47.957]     }
[17:44:47.957] }
[17:44:47.957] Lazy evaluation: FALSE
[17:44:47.957] Asynchronous evaluation: TRUE
[17:44:47.957] Local evaluation: TRUE
[17:44:47.957] Environment: R_GlobalEnv
[17:44:47.957] Capture standard output: TRUE
[17:44:47.957] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:47.957] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:47.957] Packages: <none>
[17:44:47.957] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:47.957] Resolved: TRUE
[17:44:47.957] Value: <not collected>
[17:44:47.957] Conditions captured: <none>
[17:44:47.957] Early signaling: FALSE
[17:44:47.957] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:47.957] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:47.967] Chunk #1 of 1 ... DONE
[17:44:47.967] Launching 1 futures (chunks) ... DONE
[17:44:47.967] Resolving 1 futures (chunks) ...
[17:44:47.967] resolve() on list ...
[17:44:47.968]  recursive: 0
[17:44:47.968]  length: 1
[17:44:47.968] 
[17:44:47.968] Future #1
[17:44:47.968] result() for MulticoreFuture ...
[17:44:47.969] result() for MulticoreFuture ...
[17:44:47.969] result() for MulticoreFuture ... done
[17:44:47.970] result() for MulticoreFuture ... done
[17:44:47.970] result() for MulticoreFuture ...
[17:44:47.970] result() for MulticoreFuture ... done
[17:44:47.970] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:47.970] - nx: 1
[17:44:47.970] - relay: TRUE
[17:44:47.970] - stdout: TRUE
[17:44:47.971] - signal: TRUE
[17:44:47.971] - resignal: FALSE
[17:44:47.971] - force: TRUE
[17:44:47.971] - relayed: [n=1] FALSE
[17:44:47.971] - queued futures: [n=1] FALSE
[17:44:47.971]  - until=1
[17:44:47.971]  - relaying element #1
[17:44:47.972] result() for MulticoreFuture ...
[17:44:47.972] result() for MulticoreFuture ... done
[17:44:47.972] result() for MulticoreFuture ...
[17:44:47.972] result() for MulticoreFuture ... done
[17:44:47.972] result() for MulticoreFuture ...
[17:44:47.972] result() for MulticoreFuture ... done
[17:44:47.972] result() for MulticoreFuture ...
[17:44:47.972] result() for MulticoreFuture ... done
[17:44:47.976] - relayed: [n=1] TRUE
[17:44:47.976] - queued futures: [n=1] TRUE
[17:44:47.976] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:47.976]  length: 0 (resolved future 1)
[17:44:47.976] Relaying remaining futures
[17:44:47.977] signalConditionsASAP(NULL, pos=0) ...
[17:44:47.977] - nx: 1
[17:44:47.977] - relay: TRUE
[17:44:47.977] - stdout: TRUE
[17:44:47.977] - signal: TRUE
[17:44:47.977] - resignal: FALSE
[17:44:47.978] - force: TRUE
[17:44:47.978] - relayed: [n=1] TRUE
[17:44:47.978] - queued futures: [n=1] TRUE
 - flush all
[17:44:47.978] - relayed: [n=1] TRUE
[17:44:47.978] - queued futures: [n=1] TRUE
[17:44:47.979] signalConditionsASAP(NULL, pos=0) ... done
[17:44:47.979] resolve() on list ... DONE
[17:44:47.979] result() for MulticoreFuture ...
[17:44:47.979] result() for MulticoreFuture ... done
[17:44:47.979] result() for MulticoreFuture ...
[17:44:47.979] result() for MulticoreFuture ... done
[17:44:47.980]  - Number of value chunks collected: 1
[17:44:47.980] Resolving 1 futures (chunks) ... DONE
[17:44:47.980] Reducing values from 1 chunks ...
[17:44:47.980]  - Number of values collected after concatenation: 1
[17:44:47.980]  - Number of values expected: 1
[17:44:47.980] Reducing values from 1 chunks ... DONE
[17:44:47.980] future_mapply() ... DONE
[17:44:47.981] future_mapply() ...
[17:44:47.985] Number of chunks: 1
[17:44:47.985] getGlobalsAndPackagesXApply() ...
[17:44:47.985]  - future.globals: TRUE
[17:44:47.986] getGlobalsAndPackages() ...
[17:44:47.986] Searching for globals...
[17:44:47.987] - globals found: [1] ‘FUN’
[17:44:47.987] Searching for globals ... DONE
[17:44:47.987] Resolving globals: FALSE
[17:44:47.988] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:47.988] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:47.988] - globals: [1] ‘FUN’
[17:44:47.988] 
[17:44:47.988] getGlobalsAndPackages() ... DONE
[17:44:47.989]  - globals found/used: [n=1] ‘FUN’
[17:44:47.989]  - needed namespaces: [n=0] 
[17:44:47.989] Finding globals ... DONE
[17:44:47.989] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:47.989] List of 2
[17:44:47.989]  $ ...future.FUN:function (x)  
[17:44:47.989]  $ MoreArgs     : list()
[17:44:47.989]  - attr(*, "where")=List of 2
[17:44:47.989]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:47.989]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:47.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:47.989]  - attr(*, "resolved")= logi FALSE
[17:44:47.989]  - attr(*, "total_size")= num NA
[17:44:47.992] Packages to be attached in all futures: [n=0] 
[17:44:47.992] getGlobalsAndPackagesXApply() ... DONE
[17:44:47.992] Number of futures (= number of chunks): 1
[17:44:47.993] Launching 1 futures (chunks) ...
[17:44:47.993] Chunk #1 of 1 ...
[17:44:47.993]  - Finding globals in '...' for chunk #1 ...
[17:44:47.993] getGlobalsAndPackages() ...
[17:44:47.993] Searching for globals...
[17:44:47.993] 
[17:44:47.993] Searching for globals ... DONE
[17:44:47.994] - globals: [0] <none>
[17:44:47.994] getGlobalsAndPackages() ... DONE
[17:44:47.994]    + additional globals found: [n=0] 
[17:44:47.994]    + additional namespaces needed: [n=0] 
[17:44:47.994]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:47.994]  - seeds: <none>
[17:44:47.994]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.994] getGlobalsAndPackages() ...
[17:44:47.994] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.995] Resolving globals: FALSE
[17:44:47.995] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:47.995] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:47.996] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:47.996] 
[17:44:47.996] getGlobalsAndPackages() ... DONE
[17:44:47.996] run() for ‘Future’ ...
[17:44:47.996] - state: ‘created’
[17:44:47.996] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.000]   - Field: ‘label’
[17:44:48.000]   - Field: ‘local’
[17:44:48.001]   - Field: ‘owner’
[17:44:48.001]   - Field: ‘envir’
[17:44:48.001]   - Field: ‘workers’
[17:44:48.001]   - Field: ‘packages’
[17:44:48.001]   - Field: ‘gc’
[17:44:48.001]   - Field: ‘job’
[17:44:48.001]   - Field: ‘conditions’
[17:44:48.001]   - Field: ‘expr’
[17:44:48.001]   - Field: ‘uuid’
[17:44:48.001]   - Field: ‘seed’
[17:44:48.002]   - Field: ‘version’
[17:44:48.002]   - Field: ‘result’
[17:44:48.002]   - Field: ‘asynchronous’
[17:44:48.002]   - Field: ‘calls’
[17:44:48.002]   - Field: ‘globals’
[17:44:48.002]   - Field: ‘stdout’
[17:44:48.002]   - Field: ‘earlySignal’
[17:44:48.002]   - Field: ‘lazy’
[17:44:48.002]   - Field: ‘state’
[17:44:48.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.002] - Launch lazy future ...
[17:44:48.003] Packages needed by the future expression (n = 0): <none>
[17:44:48.003] Packages needed by future strategies (n = 0): <none>
[17:44:48.003] {
[17:44:48.003]     {
[17:44:48.003]         {
[17:44:48.003]             ...future.startTime <- base::Sys.time()
[17:44:48.003]             {
[17:44:48.003]                 {
[17:44:48.003]                   {
[17:44:48.003]                     {
[17:44:48.003]                       base::local({
[17:44:48.003]                         has_future <- base::requireNamespace("future", 
[17:44:48.003]                           quietly = TRUE)
[17:44:48.003]                         if (has_future) {
[17:44:48.003]                           ns <- base::getNamespace("future")
[17:44:48.003]                           version <- ns[[".package"]][["version"]]
[17:44:48.003]                           if (is.null(version)) 
[17:44:48.003]                             version <- utils::packageVersion("future")
[17:44:48.003]                         }
[17:44:48.003]                         else {
[17:44:48.003]                           version <- NULL
[17:44:48.003]                         }
[17:44:48.003]                         if (!has_future || version < "1.8.0") {
[17:44:48.003]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.003]                             "", base::R.version$version.string), 
[17:44:48.003]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.003]                               "release", "version")], collapse = " "), 
[17:44:48.003]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.003]                             info)
[17:44:48.003]                           info <- base::paste(info, collapse = "; ")
[17:44:48.003]                           if (!has_future) {
[17:44:48.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.003]                               info)
[17:44:48.003]                           }
[17:44:48.003]                           else {
[17:44:48.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.003]                               info, version)
[17:44:48.003]                           }
[17:44:48.003]                           base::stop(msg)
[17:44:48.003]                         }
[17:44:48.003]                       })
[17:44:48.003]                     }
[17:44:48.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.003]                     base::options(mc.cores = 1L)
[17:44:48.003]                   }
[17:44:48.003]                   ...future.strategy.old <- future::plan("list")
[17:44:48.003]                   options(future.plan = NULL)
[17:44:48.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.003]                 }
[17:44:48.003]                 ...future.workdir <- getwd()
[17:44:48.003]             }
[17:44:48.003]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.003]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.003]         }
[17:44:48.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:48.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.003]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.003]             base::names(...future.oldOptions))
[17:44:48.003]     }
[17:44:48.003]     if (FALSE) {
[17:44:48.003]     }
[17:44:48.003]     else {
[17:44:48.003]         if (TRUE) {
[17:44:48.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.003]                 open = "w")
[17:44:48.003]         }
[17:44:48.003]         else {
[17:44:48.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.003]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.003]         }
[17:44:48.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.003]             base::sink(type = "output", split = FALSE)
[17:44:48.003]             base::close(...future.stdout)
[17:44:48.003]         }, add = TRUE)
[17:44:48.003]     }
[17:44:48.003]     ...future.frame <- base::sys.nframe()
[17:44:48.003]     ...future.conditions <- base::list()
[17:44:48.003]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.003]     if (FALSE) {
[17:44:48.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.003]     }
[17:44:48.003]     ...future.result <- base::tryCatch({
[17:44:48.003]         base::withCallingHandlers({
[17:44:48.003]             ...future.value <- base::withVisible(base::local({
[17:44:48.003]                 withCallingHandlers({
[17:44:48.003]                   {
[17:44:48.003]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.003]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.003]                       ...future.globals.maxSize)) {
[17:44:48.003]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.003]                       on.exit(options(oopts), add = TRUE)
[17:44:48.003]                     }
[17:44:48.003]                     {
[17:44:48.003]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.003]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.003]                         USE.NAMES = FALSE)
[17:44:48.003]                       do.call(mapply, args = args)
[17:44:48.003]                     }
[17:44:48.003]                   }
[17:44:48.003]                 }, immediateCondition = function(cond) {
[17:44:48.003]                   save_rds <- function (object, pathname, ...) 
[17:44:48.003]                   {
[17:44:48.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.003]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.003]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.003]                         fi_tmp[["mtime"]])
[17:44:48.003]                     }
[17:44:48.003]                     tryCatch({
[17:44:48.003]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.003]                     }, error = function(ex) {
[17:44:48.003]                       msg <- conditionMessage(ex)
[17:44:48.003]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.003]                         fi_tmp[["mtime"]], msg)
[17:44:48.003]                       ex$message <- msg
[17:44:48.003]                       stop(ex)
[17:44:48.003]                     })
[17:44:48.003]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.003]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.003]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.003]                       fi <- file.info(pathname)
[17:44:48.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.003]                         fi[["size"]], fi[["mtime"]])
[17:44:48.003]                       stop(msg)
[17:44:48.003]                     }
[17:44:48.003]                     invisible(pathname)
[17:44:48.003]                   }
[17:44:48.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.003]                     rootPath = tempdir()) 
[17:44:48.003]                   {
[17:44:48.003]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.003]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.003]                       tmpdir = path, fileext = ".rds")
[17:44:48.003]                     save_rds(obj, file)
[17:44:48.003]                   }
[17:44:48.003]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.003]                   {
[17:44:48.003]                     inherits <- base::inherits
[17:44:48.003]                     invokeRestart <- base::invokeRestart
[17:44:48.003]                     is.null <- base::is.null
[17:44:48.003]                     muffled <- FALSE
[17:44:48.003]                     if (inherits(cond, "message")) {
[17:44:48.003]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.003]                       if (muffled) 
[17:44:48.003]                         invokeRestart("muffleMessage")
[17:44:48.003]                     }
[17:44:48.003]                     else if (inherits(cond, "warning")) {
[17:44:48.003]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.003]                       if (muffled) 
[17:44:48.003]                         invokeRestart("muffleWarning")
[17:44:48.003]                     }
[17:44:48.003]                     else if (inherits(cond, "condition")) {
[17:44:48.003]                       if (!is.null(pattern)) {
[17:44:48.003]                         computeRestarts <- base::computeRestarts
[17:44:48.003]                         grepl <- base::grepl
[17:44:48.003]                         restarts <- computeRestarts(cond)
[17:44:48.003]                         for (restart in restarts) {
[17:44:48.003]                           name <- restart$name
[17:44:48.003]                           if (is.null(name)) 
[17:44:48.003]                             next
[17:44:48.003]                           if (!grepl(pattern, name)) 
[17:44:48.003]                             next
[17:44:48.003]                           invokeRestart(restart)
[17:44:48.003]                           muffled <- TRUE
[17:44:48.003]                           break
[17:44:48.003]                         }
[17:44:48.003]                       }
[17:44:48.003]                     }
[17:44:48.003]                     invisible(muffled)
[17:44:48.003]                   }
[17:44:48.003]                   muffleCondition(cond)
[17:44:48.003]                 })
[17:44:48.003]             }))
[17:44:48.003]             future::FutureResult(value = ...future.value$value, 
[17:44:48.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.003]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.003]                     ...future.globalenv.names))
[17:44:48.003]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.003]         }, condition = base::local({
[17:44:48.003]             c <- base::c
[17:44:48.003]             inherits <- base::inherits
[17:44:48.003]             invokeRestart <- base::invokeRestart
[17:44:48.003]             length <- base::length
[17:44:48.003]             list <- base::list
[17:44:48.003]             seq.int <- base::seq.int
[17:44:48.003]             signalCondition <- base::signalCondition
[17:44:48.003]             sys.calls <- base::sys.calls
[17:44:48.003]             `[[` <- base::`[[`
[17:44:48.003]             `+` <- base::`+`
[17:44:48.003]             `<<-` <- base::`<<-`
[17:44:48.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.003]                   3L)]
[17:44:48.003]             }
[17:44:48.003]             function(cond) {
[17:44:48.003]                 is_error <- inherits(cond, "error")
[17:44:48.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.003]                   NULL)
[17:44:48.003]                 if (is_error) {
[17:44:48.003]                   sessionInformation <- function() {
[17:44:48.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.003]                       search = base::search(), system = base::Sys.info())
[17:44:48.003]                   }
[17:44:48.003]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.003]                     cond$call), session = sessionInformation(), 
[17:44:48.003]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.003]                   signalCondition(cond)
[17:44:48.003]                 }
[17:44:48.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.003]                 "immediateCondition"))) {
[17:44:48.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.003]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.003]                   if (TRUE && !signal) {
[17:44:48.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.003]                     {
[17:44:48.003]                       inherits <- base::inherits
[17:44:48.003]                       invokeRestart <- base::invokeRestart
[17:44:48.003]                       is.null <- base::is.null
[17:44:48.003]                       muffled <- FALSE
[17:44:48.003]                       if (inherits(cond, "message")) {
[17:44:48.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.003]                         if (muffled) 
[17:44:48.003]                           invokeRestart("muffleMessage")
[17:44:48.003]                       }
[17:44:48.003]                       else if (inherits(cond, "warning")) {
[17:44:48.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.003]                         if (muffled) 
[17:44:48.003]                           invokeRestart("muffleWarning")
[17:44:48.003]                       }
[17:44:48.003]                       else if (inherits(cond, "condition")) {
[17:44:48.003]                         if (!is.null(pattern)) {
[17:44:48.003]                           computeRestarts <- base::computeRestarts
[17:44:48.003]                           grepl <- base::grepl
[17:44:48.003]                           restarts <- computeRestarts(cond)
[17:44:48.003]                           for (restart in restarts) {
[17:44:48.003]                             name <- restart$name
[17:44:48.003]                             if (is.null(name)) 
[17:44:48.003]                               next
[17:44:48.003]                             if (!grepl(pattern, name)) 
[17:44:48.003]                               next
[17:44:48.003]                             invokeRestart(restart)
[17:44:48.003]                             muffled <- TRUE
[17:44:48.003]                             break
[17:44:48.003]                           }
[17:44:48.003]                         }
[17:44:48.003]                       }
[17:44:48.003]                       invisible(muffled)
[17:44:48.003]                     }
[17:44:48.003]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.003]                   }
[17:44:48.003]                 }
[17:44:48.003]                 else {
[17:44:48.003]                   if (TRUE) {
[17:44:48.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.003]                     {
[17:44:48.003]                       inherits <- base::inherits
[17:44:48.003]                       invokeRestart <- base::invokeRestart
[17:44:48.003]                       is.null <- base::is.null
[17:44:48.003]                       muffled <- FALSE
[17:44:48.003]                       if (inherits(cond, "message")) {
[17:44:48.003]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.003]                         if (muffled) 
[17:44:48.003]                           invokeRestart("muffleMessage")
[17:44:48.003]                       }
[17:44:48.003]                       else if (inherits(cond, "warning")) {
[17:44:48.003]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.003]                         if (muffled) 
[17:44:48.003]                           invokeRestart("muffleWarning")
[17:44:48.003]                       }
[17:44:48.003]                       else if (inherits(cond, "condition")) {
[17:44:48.003]                         if (!is.null(pattern)) {
[17:44:48.003]                           computeRestarts <- base::computeRestarts
[17:44:48.003]                           grepl <- base::grepl
[17:44:48.003]                           restarts <- computeRestarts(cond)
[17:44:48.003]                           for (restart in restarts) {
[17:44:48.003]                             name <- restart$name
[17:44:48.003]                             if (is.null(name)) 
[17:44:48.003]                               next
[17:44:48.003]                             if (!grepl(pattern, name)) 
[17:44:48.003]                               next
[17:44:48.003]                             invokeRestart(restart)
[17:44:48.003]                             muffled <- TRUE
[17:44:48.003]                             break
[17:44:48.003]                           }
[17:44:48.003]                         }
[17:44:48.003]                       }
[17:44:48.003]                       invisible(muffled)
[17:44:48.003]                     }
[17:44:48.003]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.003]                   }
[17:44:48.003]                 }
[17:44:48.003]             }
[17:44:48.003]         }))
[17:44:48.003]     }, error = function(ex) {
[17:44:48.003]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.003]                 ...future.rng), started = ...future.startTime, 
[17:44:48.003]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.003]             version = "1.8"), class = "FutureResult")
[17:44:48.003]     }, finally = {
[17:44:48.003]         if (!identical(...future.workdir, getwd())) 
[17:44:48.003]             setwd(...future.workdir)
[17:44:48.003]         {
[17:44:48.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.003]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.003]             }
[17:44:48.003]             base::options(...future.oldOptions)
[17:44:48.003]             if (.Platform$OS.type == "windows") {
[17:44:48.003]                 old_names <- names(...future.oldEnvVars)
[17:44:48.003]                 envs <- base::Sys.getenv()
[17:44:48.003]                 names <- names(envs)
[17:44:48.003]                 common <- intersect(names, old_names)
[17:44:48.003]                 added <- setdiff(names, old_names)
[17:44:48.003]                 removed <- setdiff(old_names, names)
[17:44:48.003]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.003]                   envs[common]]
[17:44:48.003]                 NAMES <- toupper(changed)
[17:44:48.003]                 args <- list()
[17:44:48.003]                 for (kk in seq_along(NAMES)) {
[17:44:48.003]                   name <- changed[[kk]]
[17:44:48.003]                   NAME <- NAMES[[kk]]
[17:44:48.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.003]                     next
[17:44:48.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.003]                 }
[17:44:48.003]                 NAMES <- toupper(added)
[17:44:48.003]                 for (kk in seq_along(NAMES)) {
[17:44:48.003]                   name <- added[[kk]]
[17:44:48.003]                   NAME <- NAMES[[kk]]
[17:44:48.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.003]                     next
[17:44:48.003]                   args[[name]] <- ""
[17:44:48.003]                 }
[17:44:48.003]                 NAMES <- toupper(removed)
[17:44:48.003]                 for (kk in seq_along(NAMES)) {
[17:44:48.003]                   name <- removed[[kk]]
[17:44:48.003]                   NAME <- NAMES[[kk]]
[17:44:48.003]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.003]                     next
[17:44:48.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.003]                 }
[17:44:48.003]                 if (length(args) > 0) 
[17:44:48.003]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.003]             }
[17:44:48.003]             else {
[17:44:48.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.003]             }
[17:44:48.003]             {
[17:44:48.003]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.003]                   0L) {
[17:44:48.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.003]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.003]                   base::options(opts)
[17:44:48.003]                 }
[17:44:48.003]                 {
[17:44:48.003]                   {
[17:44:48.003]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.003]                     NULL
[17:44:48.003]                   }
[17:44:48.003]                   options(future.plan = NULL)
[17:44:48.003]                   if (is.na(NA_character_)) 
[17:44:48.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.003]                     .init = FALSE)
[17:44:48.003]                 }
[17:44:48.003]             }
[17:44:48.003]         }
[17:44:48.003]     })
[17:44:48.003]     if (TRUE) {
[17:44:48.003]         base::sink(type = "output", split = FALSE)
[17:44:48.003]         if (TRUE) {
[17:44:48.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.003]         }
[17:44:48.003]         else {
[17:44:48.003]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.003]         }
[17:44:48.003]         base::close(...future.stdout)
[17:44:48.003]         ...future.stdout <- NULL
[17:44:48.003]     }
[17:44:48.003]     ...future.result$conditions <- ...future.conditions
[17:44:48.003]     ...future.result$finished <- base::Sys.time()
[17:44:48.003]     ...future.result
[17:44:48.003] }
[17:44:48.006] assign_globals() ...
[17:44:48.006] List of 5
[17:44:48.006]  $ ...future.FUN            :function (x)  
[17:44:48.006]  $ MoreArgs                 : list()
[17:44:48.006]  $ ...future.elements_ii    :List of 1
[17:44:48.006]   ..$ :List of 1
[17:44:48.006]   .. ..$ : Date[1:1], format: "2018-06-01"
[17:44:48.006]  $ ...future.seeds_ii       : NULL
[17:44:48.006]  $ ...future.globals.maxSize: NULL
[17:44:48.006]  - attr(*, "where")=List of 5
[17:44:48.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.006]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.006]  - attr(*, "resolved")= logi FALSE
[17:44:48.006]  - attr(*, "total_size")= num 1128
[17:44:48.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.006]  - attr(*, "already-done")= logi TRUE
[17:44:48.014] - copied ‘...future.FUN’ to environment
[17:44:48.014] - copied ‘MoreArgs’ to environment
[17:44:48.014] - copied ‘...future.elements_ii’ to environment
[17:44:48.014] - copied ‘...future.seeds_ii’ to environment
[17:44:48.014] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.014] assign_globals() ... done
[17:44:48.015] requestCore(): workers = 2
[17:44:48.017] MulticoreFuture started
[17:44:48.017] - Launch lazy future ... done
[17:44:48.018] run() for ‘MulticoreFuture’ ... done
[17:44:48.018] plan(): Setting new future strategy stack:
[17:44:48.018] Created future:
[17:44:48.018] List of future strategies:
[17:44:48.018] 1. sequential:
[17:44:48.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.018]    - tweaked: FALSE
[17:44:48.018]    - call: NULL
[17:44:48.019] plan(): nbrOfWorkers() = 1
[17:44:48.022] plan(): Setting new future strategy stack:
[17:44:48.022] List of future strategies:
[17:44:48.022] 1. multicore:
[17:44:48.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.022]    - tweaked: FALSE
[17:44:48.022]    - call: plan(strategy)
[17:44:48.027] plan(): nbrOfWorkers() = 2
[17:44:48.018] MulticoreFuture:
[17:44:48.018] Label: ‘future_.mapply-1’
[17:44:48.018] Expression:
[17:44:48.018] {
[17:44:48.018]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.018]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.018]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.018]         on.exit(options(oopts), add = TRUE)
[17:44:48.018]     }
[17:44:48.018]     {
[17:44:48.018]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.018]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.018]         do.call(mapply, args = args)
[17:44:48.018]     }
[17:44:48.018] }
[17:44:48.018] Lazy evaluation: FALSE
[17:44:48.018] Asynchronous evaluation: TRUE
[17:44:48.018] Local evaluation: TRUE
[17:44:48.018] Environment: R_GlobalEnv
[17:44:48.018] Capture standard output: TRUE
[17:44:48.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.018] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.018] Packages: <none>
[17:44:48.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.018] Resolved: TRUE
[17:44:48.018] Value: <not collected>
[17:44:48.018] Conditions captured: <none>
[17:44:48.018] Early signaling: FALSE
[17:44:48.018] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.029] Chunk #1 of 1 ... DONE
[17:44:48.029] Launching 1 futures (chunks) ... DONE
[17:44:48.029] Resolving 1 futures (chunks) ...
[17:44:48.029] resolve() on list ...
[17:44:48.029]  recursive: 0
[17:44:48.029]  length: 1
[17:44:48.030] 
[17:44:48.030] Future #1
[17:44:48.030] result() for MulticoreFuture ...
[17:44:48.031] result() for MulticoreFuture ...
[17:44:48.031] result() for MulticoreFuture ... done
[17:44:48.031] result() for MulticoreFuture ... done
[17:44:48.031] result() for MulticoreFuture ...
[17:44:48.031] result() for MulticoreFuture ... done
[17:44:48.032] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.032] - nx: 1
[17:44:48.032] - relay: TRUE
[17:44:48.032] - stdout: TRUE
[17:44:48.032] - signal: TRUE
[17:44:48.032] - resignal: FALSE
[17:44:48.032] - force: TRUE
[17:44:48.033] - relayed: [n=1] FALSE
[17:44:48.033] - queued futures: [n=1] FALSE
[17:44:48.033]  - until=1
[17:44:48.033]  - relaying element #1
[17:44:48.033] result() for MulticoreFuture ...
[17:44:48.033] result() for MulticoreFuture ... done
[17:44:48.033] result() for MulticoreFuture ...
[17:44:48.033] result() for MulticoreFuture ... done
[17:44:48.034] result() for MulticoreFuture ...
[17:44:48.034] result() for MulticoreFuture ... done
[17:44:48.034] result() for MulticoreFuture ...
[17:44:48.034] result() for MulticoreFuture ... done
[17:44:48.034] - relayed: [n=1] TRUE
[17:44:48.034] - queued futures: [n=1] TRUE
[17:44:48.034] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.034]  length: 0 (resolved future 1)
[17:44:48.035] Relaying remaining futures
[17:44:48.035] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.035] - nx: 1
[17:44:48.035] - relay: TRUE
[17:44:48.035] - stdout: TRUE
[17:44:48.035] - signal: TRUE
[17:44:48.035] - resignal: FALSE
[17:44:48.035] - force: TRUE
[17:44:48.035] - relayed: [n=1] TRUE
[17:44:48.036] - queued futures: [n=1] TRUE
 - flush all
[17:44:48.036] - relayed: [n=1] TRUE
[17:44:48.036] - queued futures: [n=1] TRUE
[17:44:48.036] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.036] resolve() on list ... DONE
[17:44:48.036] result() for MulticoreFuture ...
[17:44:48.036] result() for MulticoreFuture ... done
[17:44:48.036] result() for MulticoreFuture ...
[17:44:48.037] result() for MulticoreFuture ... done
[17:44:48.037]  - Number of value chunks collected: 1
[17:44:48.037] Resolving 1 futures (chunks) ... DONE
[17:44:48.037] Reducing values from 1 chunks ...
[17:44:48.037]  - Number of values collected after concatenation: 1
[17:44:48.037]  - Number of values expected: 1
[17:44:48.037] Reducing values from 1 chunks ... DONE
[17:44:48.037] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:44:48.038] future_mapply() ...
[17:44:48.042] Number of chunks: 2
[17:44:48.042] getGlobalsAndPackagesXApply() ...
[17:44:48.042]  - future.globals: TRUE
[17:44:48.042] getGlobalsAndPackages() ...
[17:44:48.042] Searching for globals...
[17:44:48.044] - globals found: [1] ‘FUN’
[17:44:48.044] Searching for globals ... DONE
[17:44:48.044] Resolving globals: FALSE
[17:44:48.044] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:48.045] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:48.045] - globals: [1] ‘FUN’
[17:44:48.045] 
[17:44:48.045] getGlobalsAndPackages() ... DONE
[17:44:48.045]  - globals found/used: [n=1] ‘FUN’
[17:44:48.045]  - needed namespaces: [n=0] 
[17:44:48.046] Finding globals ... DONE
[17:44:48.046] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.046] List of 2
[17:44:48.046]  $ ...future.FUN:function (x, y)  
[17:44:48.046]  $ MoreArgs     :List of 1
[17:44:48.046]   ..$ y: int [1:2] 3 4
[17:44:48.046]  - attr(*, "where")=List of 2
[17:44:48.046]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.046]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.046]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.046]  - attr(*, "resolved")= logi FALSE
[17:44:48.046]  - attr(*, "total_size")= num NA
[17:44:48.052] Packages to be attached in all futures: [n=0] 
[17:44:48.053] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.053] Number of futures (= number of chunks): 2
[17:44:48.053] Launching 2 futures (chunks) ...
[17:44:48.053] Chunk #1 of 2 ...
[17:44:48.053]  - Finding globals in '...' for chunk #1 ...
[17:44:48.054] getGlobalsAndPackages() ...
[17:44:48.054] Searching for globals...
[17:44:48.054] 
[17:44:48.054] Searching for globals ... DONE
[17:44:48.054] - globals: [0] <none>
[17:44:48.054] getGlobalsAndPackages() ... DONE
[17:44:48.055]    + additional globals found: [n=0] 
[17:44:48.055]    + additional namespaces needed: [n=0] 
[17:44:48.055]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.055]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.055]  - seeds: <none>
[17:44:48.055]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.055] getGlobalsAndPackages() ...
[17:44:48.056] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.056] Resolving globals: FALSE
[17:44:48.056] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:48.057] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:48.057] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.057] 
[17:44:48.057] getGlobalsAndPackages() ... DONE
[17:44:48.058] run() for ‘Future’ ...
[17:44:48.058] - state: ‘created’
[17:44:48.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.062] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.062]   - Field: ‘label’
[17:44:48.062]   - Field: ‘local’
[17:44:48.062]   - Field: ‘owner’
[17:44:48.063]   - Field: ‘envir’
[17:44:48.063]   - Field: ‘workers’
[17:44:48.063]   - Field: ‘packages’
[17:44:48.063]   - Field: ‘gc’
[17:44:48.063]   - Field: ‘job’
[17:44:48.063]   - Field: ‘conditions’
[17:44:48.063]   - Field: ‘expr’
[17:44:48.063]   - Field: ‘uuid’
[17:44:48.063]   - Field: ‘seed’
[17:44:48.063]   - Field: ‘version’
[17:44:48.064]   - Field: ‘result’
[17:44:48.064]   - Field: ‘asynchronous’
[17:44:48.064]   - Field: ‘calls’
[17:44:48.064]   - Field: ‘globals’
[17:44:48.064]   - Field: ‘stdout’
[17:44:48.064]   - Field: ‘earlySignal’
[17:44:48.064]   - Field: ‘lazy’
[17:44:48.064]   - Field: ‘state’
[17:44:48.064] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.064] - Launch lazy future ...
[17:44:48.065] Packages needed by the future expression (n = 0): <none>
[17:44:48.065] Packages needed by future strategies (n = 0): <none>
[17:44:48.065] {
[17:44:48.065]     {
[17:44:48.065]         {
[17:44:48.065]             ...future.startTime <- base::Sys.time()
[17:44:48.065]             {
[17:44:48.065]                 {
[17:44:48.065]                   {
[17:44:48.065]                     {
[17:44:48.065]                       base::local({
[17:44:48.065]                         has_future <- base::requireNamespace("future", 
[17:44:48.065]                           quietly = TRUE)
[17:44:48.065]                         if (has_future) {
[17:44:48.065]                           ns <- base::getNamespace("future")
[17:44:48.065]                           version <- ns[[".package"]][["version"]]
[17:44:48.065]                           if (is.null(version)) 
[17:44:48.065]                             version <- utils::packageVersion("future")
[17:44:48.065]                         }
[17:44:48.065]                         else {
[17:44:48.065]                           version <- NULL
[17:44:48.065]                         }
[17:44:48.065]                         if (!has_future || version < "1.8.0") {
[17:44:48.065]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.065]                             "", base::R.version$version.string), 
[17:44:48.065]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.065]                               "release", "version")], collapse = " "), 
[17:44:48.065]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.065]                             info)
[17:44:48.065]                           info <- base::paste(info, collapse = "; ")
[17:44:48.065]                           if (!has_future) {
[17:44:48.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.065]                               info)
[17:44:48.065]                           }
[17:44:48.065]                           else {
[17:44:48.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.065]                               info, version)
[17:44:48.065]                           }
[17:44:48.065]                           base::stop(msg)
[17:44:48.065]                         }
[17:44:48.065]                       })
[17:44:48.065]                     }
[17:44:48.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.065]                     base::options(mc.cores = 1L)
[17:44:48.065]                   }
[17:44:48.065]                   ...future.strategy.old <- future::plan("list")
[17:44:48.065]                   options(future.plan = NULL)
[17:44:48.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.065]                 }
[17:44:48.065]                 ...future.workdir <- getwd()
[17:44:48.065]             }
[17:44:48.065]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.065]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.065]         }
[17:44:48.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.065]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.065]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.065]             base::names(...future.oldOptions))
[17:44:48.065]     }
[17:44:48.065]     if (FALSE) {
[17:44:48.065]     }
[17:44:48.065]     else {
[17:44:48.065]         if (TRUE) {
[17:44:48.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.065]                 open = "w")
[17:44:48.065]         }
[17:44:48.065]         else {
[17:44:48.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.065]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.065]         }
[17:44:48.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.065]             base::sink(type = "output", split = FALSE)
[17:44:48.065]             base::close(...future.stdout)
[17:44:48.065]         }, add = TRUE)
[17:44:48.065]     }
[17:44:48.065]     ...future.frame <- base::sys.nframe()
[17:44:48.065]     ...future.conditions <- base::list()
[17:44:48.065]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.065]     if (FALSE) {
[17:44:48.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.065]     }
[17:44:48.065]     ...future.result <- base::tryCatch({
[17:44:48.065]         base::withCallingHandlers({
[17:44:48.065]             ...future.value <- base::withVisible(base::local({
[17:44:48.065]                 withCallingHandlers({
[17:44:48.065]                   {
[17:44:48.065]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.065]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.065]                       ...future.globals.maxSize)) {
[17:44:48.065]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.065]                       on.exit(options(oopts), add = TRUE)
[17:44:48.065]                     }
[17:44:48.065]                     {
[17:44:48.065]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.065]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.065]                         USE.NAMES = FALSE)
[17:44:48.065]                       do.call(mapply, args = args)
[17:44:48.065]                     }
[17:44:48.065]                   }
[17:44:48.065]                 }, immediateCondition = function(cond) {
[17:44:48.065]                   save_rds <- function (object, pathname, ...) 
[17:44:48.065]                   {
[17:44:48.065]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.065]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.065]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.065]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.065]                         fi_tmp[["mtime"]])
[17:44:48.065]                     }
[17:44:48.065]                     tryCatch({
[17:44:48.065]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.065]                     }, error = function(ex) {
[17:44:48.065]                       msg <- conditionMessage(ex)
[17:44:48.065]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.065]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.065]                         fi_tmp[["mtime"]], msg)
[17:44:48.065]                       ex$message <- msg
[17:44:48.065]                       stop(ex)
[17:44:48.065]                     })
[17:44:48.065]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.065]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.065]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.065]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.065]                       fi <- file.info(pathname)
[17:44:48.065]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.065]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.065]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.065]                         fi[["size"]], fi[["mtime"]])
[17:44:48.065]                       stop(msg)
[17:44:48.065]                     }
[17:44:48.065]                     invisible(pathname)
[17:44:48.065]                   }
[17:44:48.065]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.065]                     rootPath = tempdir()) 
[17:44:48.065]                   {
[17:44:48.065]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.065]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.065]                       tmpdir = path, fileext = ".rds")
[17:44:48.065]                     save_rds(obj, file)
[17:44:48.065]                   }
[17:44:48.065]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.065]                   {
[17:44:48.065]                     inherits <- base::inherits
[17:44:48.065]                     invokeRestart <- base::invokeRestart
[17:44:48.065]                     is.null <- base::is.null
[17:44:48.065]                     muffled <- FALSE
[17:44:48.065]                     if (inherits(cond, "message")) {
[17:44:48.065]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.065]                       if (muffled) 
[17:44:48.065]                         invokeRestart("muffleMessage")
[17:44:48.065]                     }
[17:44:48.065]                     else if (inherits(cond, "warning")) {
[17:44:48.065]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.065]                       if (muffled) 
[17:44:48.065]                         invokeRestart("muffleWarning")
[17:44:48.065]                     }
[17:44:48.065]                     else if (inherits(cond, "condition")) {
[17:44:48.065]                       if (!is.null(pattern)) {
[17:44:48.065]                         computeRestarts <- base::computeRestarts
[17:44:48.065]                         grepl <- base::grepl
[17:44:48.065]                         restarts <- computeRestarts(cond)
[17:44:48.065]                         for (restart in restarts) {
[17:44:48.065]                           name <- restart$name
[17:44:48.065]                           if (is.null(name)) 
[17:44:48.065]                             next
[17:44:48.065]                           if (!grepl(pattern, name)) 
[17:44:48.065]                             next
[17:44:48.065]                           invokeRestart(restart)
[17:44:48.065]                           muffled <- TRUE
[17:44:48.065]                           break
[17:44:48.065]                         }
[17:44:48.065]                       }
[17:44:48.065]                     }
[17:44:48.065]                     invisible(muffled)
[17:44:48.065]                   }
[17:44:48.065]                   muffleCondition(cond)
[17:44:48.065]                 })
[17:44:48.065]             }))
[17:44:48.065]             future::FutureResult(value = ...future.value$value, 
[17:44:48.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.065]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.065]                     ...future.globalenv.names))
[17:44:48.065]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.065]         }, condition = base::local({
[17:44:48.065]             c <- base::c
[17:44:48.065]             inherits <- base::inherits
[17:44:48.065]             invokeRestart <- base::invokeRestart
[17:44:48.065]             length <- base::length
[17:44:48.065]             list <- base::list
[17:44:48.065]             seq.int <- base::seq.int
[17:44:48.065]             signalCondition <- base::signalCondition
[17:44:48.065]             sys.calls <- base::sys.calls
[17:44:48.065]             `[[` <- base::`[[`
[17:44:48.065]             `+` <- base::`+`
[17:44:48.065]             `<<-` <- base::`<<-`
[17:44:48.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.065]                   3L)]
[17:44:48.065]             }
[17:44:48.065]             function(cond) {
[17:44:48.065]                 is_error <- inherits(cond, "error")
[17:44:48.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.065]                   NULL)
[17:44:48.065]                 if (is_error) {
[17:44:48.065]                   sessionInformation <- function() {
[17:44:48.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.065]                       search = base::search(), system = base::Sys.info())
[17:44:48.065]                   }
[17:44:48.065]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.065]                     cond$call), session = sessionInformation(), 
[17:44:48.065]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.065]                   signalCondition(cond)
[17:44:48.065]                 }
[17:44:48.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.065]                 "immediateCondition"))) {
[17:44:48.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.065]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.065]                   if (TRUE && !signal) {
[17:44:48.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.065]                     {
[17:44:48.065]                       inherits <- base::inherits
[17:44:48.065]                       invokeRestart <- base::invokeRestart
[17:44:48.065]                       is.null <- base::is.null
[17:44:48.065]                       muffled <- FALSE
[17:44:48.065]                       if (inherits(cond, "message")) {
[17:44:48.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.065]                         if (muffled) 
[17:44:48.065]                           invokeRestart("muffleMessage")
[17:44:48.065]                       }
[17:44:48.065]                       else if (inherits(cond, "warning")) {
[17:44:48.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.065]                         if (muffled) 
[17:44:48.065]                           invokeRestart("muffleWarning")
[17:44:48.065]                       }
[17:44:48.065]                       else if (inherits(cond, "condition")) {
[17:44:48.065]                         if (!is.null(pattern)) {
[17:44:48.065]                           computeRestarts <- base::computeRestarts
[17:44:48.065]                           grepl <- base::grepl
[17:44:48.065]                           restarts <- computeRestarts(cond)
[17:44:48.065]                           for (restart in restarts) {
[17:44:48.065]                             name <- restart$name
[17:44:48.065]                             if (is.null(name)) 
[17:44:48.065]                               next
[17:44:48.065]                             if (!grepl(pattern, name)) 
[17:44:48.065]                               next
[17:44:48.065]                             invokeRestart(restart)
[17:44:48.065]                             muffled <- TRUE
[17:44:48.065]                             break
[17:44:48.065]                           }
[17:44:48.065]                         }
[17:44:48.065]                       }
[17:44:48.065]                       invisible(muffled)
[17:44:48.065]                     }
[17:44:48.065]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.065]                   }
[17:44:48.065]                 }
[17:44:48.065]                 else {
[17:44:48.065]                   if (TRUE) {
[17:44:48.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.065]                     {
[17:44:48.065]                       inherits <- base::inherits
[17:44:48.065]                       invokeRestart <- base::invokeRestart
[17:44:48.065]                       is.null <- base::is.null
[17:44:48.065]                       muffled <- FALSE
[17:44:48.065]                       if (inherits(cond, "message")) {
[17:44:48.065]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.065]                         if (muffled) 
[17:44:48.065]                           invokeRestart("muffleMessage")
[17:44:48.065]                       }
[17:44:48.065]                       else if (inherits(cond, "warning")) {
[17:44:48.065]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.065]                         if (muffled) 
[17:44:48.065]                           invokeRestart("muffleWarning")
[17:44:48.065]                       }
[17:44:48.065]                       else if (inherits(cond, "condition")) {
[17:44:48.065]                         if (!is.null(pattern)) {
[17:44:48.065]                           computeRestarts <- base::computeRestarts
[17:44:48.065]                           grepl <- base::grepl
[17:44:48.065]                           restarts <- computeRestarts(cond)
[17:44:48.065]                           for (restart in restarts) {
[17:44:48.065]                             name <- restart$name
[17:44:48.065]                             if (is.null(name)) 
[17:44:48.065]                               next
[17:44:48.065]                             if (!grepl(pattern, name)) 
[17:44:48.065]                               next
[17:44:48.065]                             invokeRestart(restart)
[17:44:48.065]                             muffled <- TRUE
[17:44:48.065]                             break
[17:44:48.065]                           }
[17:44:48.065]                         }
[17:44:48.065]                       }
[17:44:48.065]                       invisible(muffled)
[17:44:48.065]                     }
[17:44:48.065]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.065]                   }
[17:44:48.065]                 }
[17:44:48.065]             }
[17:44:48.065]         }))
[17:44:48.065]     }, error = function(ex) {
[17:44:48.065]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.065]                 ...future.rng), started = ...future.startTime, 
[17:44:48.065]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.065]             version = "1.8"), class = "FutureResult")
[17:44:48.065]     }, finally = {
[17:44:48.065]         if (!identical(...future.workdir, getwd())) 
[17:44:48.065]             setwd(...future.workdir)
[17:44:48.065]         {
[17:44:48.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.065]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.065]             }
[17:44:48.065]             base::options(...future.oldOptions)
[17:44:48.065]             if (.Platform$OS.type == "windows") {
[17:44:48.065]                 old_names <- names(...future.oldEnvVars)
[17:44:48.065]                 envs <- base::Sys.getenv()
[17:44:48.065]                 names <- names(envs)
[17:44:48.065]                 common <- intersect(names, old_names)
[17:44:48.065]                 added <- setdiff(names, old_names)
[17:44:48.065]                 removed <- setdiff(old_names, names)
[17:44:48.065]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.065]                   envs[common]]
[17:44:48.065]                 NAMES <- toupper(changed)
[17:44:48.065]                 args <- list()
[17:44:48.065]                 for (kk in seq_along(NAMES)) {
[17:44:48.065]                   name <- changed[[kk]]
[17:44:48.065]                   NAME <- NAMES[[kk]]
[17:44:48.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.065]                     next
[17:44:48.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.065]                 }
[17:44:48.065]                 NAMES <- toupper(added)
[17:44:48.065]                 for (kk in seq_along(NAMES)) {
[17:44:48.065]                   name <- added[[kk]]
[17:44:48.065]                   NAME <- NAMES[[kk]]
[17:44:48.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.065]                     next
[17:44:48.065]                   args[[name]] <- ""
[17:44:48.065]                 }
[17:44:48.065]                 NAMES <- toupper(removed)
[17:44:48.065]                 for (kk in seq_along(NAMES)) {
[17:44:48.065]                   name <- removed[[kk]]
[17:44:48.065]                   NAME <- NAMES[[kk]]
[17:44:48.065]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.065]                     next
[17:44:48.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.065]                 }
[17:44:48.065]                 if (length(args) > 0) 
[17:44:48.065]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.065]             }
[17:44:48.065]             else {
[17:44:48.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.065]             }
[17:44:48.065]             {
[17:44:48.065]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.065]                   0L) {
[17:44:48.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.065]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.065]                   base::options(opts)
[17:44:48.065]                 }
[17:44:48.065]                 {
[17:44:48.065]                   {
[17:44:48.065]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.065]                     NULL
[17:44:48.065]                   }
[17:44:48.065]                   options(future.plan = NULL)
[17:44:48.065]                   if (is.na(NA_character_)) 
[17:44:48.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.065]                     .init = FALSE)
[17:44:48.065]                 }
[17:44:48.065]             }
[17:44:48.065]         }
[17:44:48.065]     })
[17:44:48.065]     if (TRUE) {
[17:44:48.065]         base::sink(type = "output", split = FALSE)
[17:44:48.065]         if (TRUE) {
[17:44:48.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.065]         }
[17:44:48.065]         else {
[17:44:48.065]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.065]         }
[17:44:48.065]         base::close(...future.stdout)
[17:44:48.065]         ...future.stdout <- NULL
[17:44:48.065]     }
[17:44:48.065]     ...future.result$conditions <- ...future.conditions
[17:44:48.065]     ...future.result$finished <- base::Sys.time()
[17:44:48.065]     ...future.result
[17:44:48.065] }
[17:44:48.068] assign_globals() ...
[17:44:48.068] List of 5
[17:44:48.068]  $ ...future.FUN            :function (x, y)  
[17:44:48.068]  $ MoreArgs                 :List of 1
[17:44:48.068]   ..$ y: int [1:2] 3 4
[17:44:48.068]  $ ...future.elements_ii    :List of 1
[17:44:48.068]   ..$ x:List of 1
[17:44:48.068]   .. ..$ : int 1
[17:44:48.068]  $ ...future.seeds_ii       : NULL
[17:44:48.068]  $ ...future.globals.maxSize: NULL
[17:44:48.068]  - attr(*, "where")=List of 5
[17:44:48.068]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.068]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.068]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.068]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.068]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.068]  - attr(*, "resolved")= logi FALSE
[17:44:48.068]  - attr(*, "total_size")= num 1816
[17:44:48.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.068]  - attr(*, "already-done")= logi TRUE
[17:44:48.073] - reassign environment for ‘...future.FUN’
[17:44:48.073] - copied ‘...future.FUN’ to environment
[17:44:48.073] - copied ‘MoreArgs’ to environment
[17:44:48.074] - copied ‘...future.elements_ii’ to environment
[17:44:48.074] - copied ‘...future.seeds_ii’ to environment
[17:44:48.074] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.074] assign_globals() ... done
[17:44:48.074] requestCore(): workers = 2
[17:44:48.076] MulticoreFuture started
[17:44:48.077] - Launch lazy future ... done
[17:44:48.077] run() for ‘MulticoreFuture’ ... done
[17:44:48.077] Created future:
[17:44:48.077] plan(): Setting new future strategy stack:
[17:44:48.078] List of future strategies:
[17:44:48.078] 1. sequential:
[17:44:48.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.078]    - tweaked: FALSE
[17:44:48.078]    - call: NULL
[17:44:48.079] plan(): nbrOfWorkers() = 1
[17:44:48.086] plan(): Setting new future strategy stack:
[17:44:48.087] List of future strategies:
[17:44:48.087] 1. multicore:
[17:44:48.087]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.087]    - tweaked: FALSE
[17:44:48.087]    - call: plan(strategy)
[17:44:48.077] MulticoreFuture:
[17:44:48.077] Label: ‘future_mapply-1’
[17:44:48.077] Expression:
[17:44:48.077] {
[17:44:48.077]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.077]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.077]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.077]         on.exit(options(oopts), add = TRUE)
[17:44:48.077]     }
[17:44:48.077]     {
[17:44:48.077]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.077]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.077]         do.call(mapply, args = args)
[17:44:48.077]     }
[17:44:48.077] }
[17:44:48.077] Lazy evaluation: FALSE
[17:44:48.077] Asynchronous evaluation: TRUE
[17:44:48.077] Local evaluation: TRUE
[17:44:48.077] Environment: R_GlobalEnv
[17:44:48.077] Capture standard output: TRUE
[17:44:48.077] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.077] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.077] Packages: <none>
[17:44:48.077] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.077] Resolved: FALSE
[17:44:48.077] Value: <not collected>
[17:44:48.077] Conditions captured: <none>
[17:44:48.077] Early signaling: FALSE
[17:44:48.077] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.077] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.093] Chunk #1 of 2 ... DONE
[17:44:48.094] Chunk #2 of 2 ...
[17:44:48.094] plan(): nbrOfWorkers() = 2
[17:44:48.094]  - Finding globals in '...' for chunk #2 ...
[17:44:48.094] getGlobalsAndPackages() ...
[17:44:48.095] Searching for globals...
[17:44:48.095] 
[17:44:48.096] Searching for globals ... DONE
[17:44:48.096] - globals: [0] <none>
[17:44:48.096] getGlobalsAndPackages() ... DONE
[17:44:48.096]    + additional globals found: [n=0] 
[17:44:48.096]    + additional namespaces needed: [n=0] 
[17:44:48.097]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.097]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.097]  - seeds: <none>
[17:44:48.097]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.097] getGlobalsAndPackages() ...
[17:44:48.098] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.098] Resolving globals: FALSE
[17:44:48.099] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:48.100] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:48.101] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.101] 
[17:44:48.101] getGlobalsAndPackages() ... DONE
[17:44:48.102] run() for ‘Future’ ...
[17:44:48.102] - state: ‘created’
[17:44:48.102] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.107] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.108]   - Field: ‘label’
[17:44:48.108]   - Field: ‘local’
[17:44:48.108]   - Field: ‘owner’
[17:44:48.108]   - Field: ‘envir’
[17:44:48.108]   - Field: ‘workers’
[17:44:48.108]   - Field: ‘packages’
[17:44:48.109]   - Field: ‘gc’
[17:44:48.109]   - Field: ‘job’
[17:44:48.109]   - Field: ‘conditions’
[17:44:48.109]   - Field: ‘expr’
[17:44:48.109]   - Field: ‘uuid’
[17:44:48.109]   - Field: ‘seed’
[17:44:48.109]   - Field: ‘version’
[17:44:48.110]   - Field: ‘result’
[17:44:48.110]   - Field: ‘asynchronous’
[17:44:48.110]   - Field: ‘calls’
[17:44:48.110]   - Field: ‘globals’
[17:44:48.110]   - Field: ‘stdout’
[17:44:48.110]   - Field: ‘earlySignal’
[17:44:48.110]   - Field: ‘lazy’
[17:44:48.111]   - Field: ‘state’
[17:44:48.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.111] - Launch lazy future ...
[17:44:48.111] Packages needed by the future expression (n = 0): <none>
[17:44:48.112] Packages needed by future strategies (n = 0): <none>
[17:44:48.112] {
[17:44:48.112]     {
[17:44:48.112]         {
[17:44:48.112]             ...future.startTime <- base::Sys.time()
[17:44:48.112]             {
[17:44:48.112]                 {
[17:44:48.112]                   {
[17:44:48.112]                     {
[17:44:48.112]                       base::local({
[17:44:48.112]                         has_future <- base::requireNamespace("future", 
[17:44:48.112]                           quietly = TRUE)
[17:44:48.112]                         if (has_future) {
[17:44:48.112]                           ns <- base::getNamespace("future")
[17:44:48.112]                           version <- ns[[".package"]][["version"]]
[17:44:48.112]                           if (is.null(version)) 
[17:44:48.112]                             version <- utils::packageVersion("future")
[17:44:48.112]                         }
[17:44:48.112]                         else {
[17:44:48.112]                           version <- NULL
[17:44:48.112]                         }
[17:44:48.112]                         if (!has_future || version < "1.8.0") {
[17:44:48.112]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.112]                             "", base::R.version$version.string), 
[17:44:48.112]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.112]                               "release", "version")], collapse = " "), 
[17:44:48.112]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.112]                             info)
[17:44:48.112]                           info <- base::paste(info, collapse = "; ")
[17:44:48.112]                           if (!has_future) {
[17:44:48.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.112]                               info)
[17:44:48.112]                           }
[17:44:48.112]                           else {
[17:44:48.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.112]                               info, version)
[17:44:48.112]                           }
[17:44:48.112]                           base::stop(msg)
[17:44:48.112]                         }
[17:44:48.112]                       })
[17:44:48.112]                     }
[17:44:48.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.112]                     base::options(mc.cores = 1L)
[17:44:48.112]                   }
[17:44:48.112]                   ...future.strategy.old <- future::plan("list")
[17:44:48.112]                   options(future.plan = NULL)
[17:44:48.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.112]                 }
[17:44:48.112]                 ...future.workdir <- getwd()
[17:44:48.112]             }
[17:44:48.112]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.112]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.112]         }
[17:44:48.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.112]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.112]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.112]             base::names(...future.oldOptions))
[17:44:48.112]     }
[17:44:48.112]     if (FALSE) {
[17:44:48.112]     }
[17:44:48.112]     else {
[17:44:48.112]         if (TRUE) {
[17:44:48.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.112]                 open = "w")
[17:44:48.112]         }
[17:44:48.112]         else {
[17:44:48.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.112]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.112]         }
[17:44:48.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.112]             base::sink(type = "output", split = FALSE)
[17:44:48.112]             base::close(...future.stdout)
[17:44:48.112]         }, add = TRUE)
[17:44:48.112]     }
[17:44:48.112]     ...future.frame <- base::sys.nframe()
[17:44:48.112]     ...future.conditions <- base::list()
[17:44:48.112]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.112]     if (FALSE) {
[17:44:48.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.112]     }
[17:44:48.112]     ...future.result <- base::tryCatch({
[17:44:48.112]         base::withCallingHandlers({
[17:44:48.112]             ...future.value <- base::withVisible(base::local({
[17:44:48.112]                 withCallingHandlers({
[17:44:48.112]                   {
[17:44:48.112]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.112]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.112]                       ...future.globals.maxSize)) {
[17:44:48.112]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.112]                       on.exit(options(oopts), add = TRUE)
[17:44:48.112]                     }
[17:44:48.112]                     {
[17:44:48.112]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.112]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.112]                         USE.NAMES = FALSE)
[17:44:48.112]                       do.call(mapply, args = args)
[17:44:48.112]                     }
[17:44:48.112]                   }
[17:44:48.112]                 }, immediateCondition = function(cond) {
[17:44:48.112]                   save_rds <- function (object, pathname, ...) 
[17:44:48.112]                   {
[17:44:48.112]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.112]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.112]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.112]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.112]                         fi_tmp[["mtime"]])
[17:44:48.112]                     }
[17:44:48.112]                     tryCatch({
[17:44:48.112]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.112]                     }, error = function(ex) {
[17:44:48.112]                       msg <- conditionMessage(ex)
[17:44:48.112]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.112]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.112]                         fi_tmp[["mtime"]], msg)
[17:44:48.112]                       ex$message <- msg
[17:44:48.112]                       stop(ex)
[17:44:48.112]                     })
[17:44:48.112]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.112]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.112]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.112]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.112]                       fi <- file.info(pathname)
[17:44:48.112]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.112]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.112]                         fi[["size"]], fi[["mtime"]])
[17:44:48.112]                       stop(msg)
[17:44:48.112]                     }
[17:44:48.112]                     invisible(pathname)
[17:44:48.112]                   }
[17:44:48.112]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.112]                     rootPath = tempdir()) 
[17:44:48.112]                   {
[17:44:48.112]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.112]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.112]                       tmpdir = path, fileext = ".rds")
[17:44:48.112]                     save_rds(obj, file)
[17:44:48.112]                   }
[17:44:48.112]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.112]                   {
[17:44:48.112]                     inherits <- base::inherits
[17:44:48.112]                     invokeRestart <- base::invokeRestart
[17:44:48.112]                     is.null <- base::is.null
[17:44:48.112]                     muffled <- FALSE
[17:44:48.112]                     if (inherits(cond, "message")) {
[17:44:48.112]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.112]                       if (muffled) 
[17:44:48.112]                         invokeRestart("muffleMessage")
[17:44:48.112]                     }
[17:44:48.112]                     else if (inherits(cond, "warning")) {
[17:44:48.112]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.112]                       if (muffled) 
[17:44:48.112]                         invokeRestart("muffleWarning")
[17:44:48.112]                     }
[17:44:48.112]                     else if (inherits(cond, "condition")) {
[17:44:48.112]                       if (!is.null(pattern)) {
[17:44:48.112]                         computeRestarts <- base::computeRestarts
[17:44:48.112]                         grepl <- base::grepl
[17:44:48.112]                         restarts <- computeRestarts(cond)
[17:44:48.112]                         for (restart in restarts) {
[17:44:48.112]                           name <- restart$name
[17:44:48.112]                           if (is.null(name)) 
[17:44:48.112]                             next
[17:44:48.112]                           if (!grepl(pattern, name)) 
[17:44:48.112]                             next
[17:44:48.112]                           invokeRestart(restart)
[17:44:48.112]                           muffled <- TRUE
[17:44:48.112]                           break
[17:44:48.112]                         }
[17:44:48.112]                       }
[17:44:48.112]                     }
[17:44:48.112]                     invisible(muffled)
[17:44:48.112]                   }
[17:44:48.112]                   muffleCondition(cond)
[17:44:48.112]                 })
[17:44:48.112]             }))
[17:44:48.112]             future::FutureResult(value = ...future.value$value, 
[17:44:48.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.112]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.112]                     ...future.globalenv.names))
[17:44:48.112]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.112]         }, condition = base::local({
[17:44:48.112]             c <- base::c
[17:44:48.112]             inherits <- base::inherits
[17:44:48.112]             invokeRestart <- base::invokeRestart
[17:44:48.112]             length <- base::length
[17:44:48.112]             list <- base::list
[17:44:48.112]             seq.int <- base::seq.int
[17:44:48.112]             signalCondition <- base::signalCondition
[17:44:48.112]             sys.calls <- base::sys.calls
[17:44:48.112]             `[[` <- base::`[[`
[17:44:48.112]             `+` <- base::`+`
[17:44:48.112]             `<<-` <- base::`<<-`
[17:44:48.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.112]                   3L)]
[17:44:48.112]             }
[17:44:48.112]             function(cond) {
[17:44:48.112]                 is_error <- inherits(cond, "error")
[17:44:48.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.112]                   NULL)
[17:44:48.112]                 if (is_error) {
[17:44:48.112]                   sessionInformation <- function() {
[17:44:48.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.112]                       search = base::search(), system = base::Sys.info())
[17:44:48.112]                   }
[17:44:48.112]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.112]                     cond$call), session = sessionInformation(), 
[17:44:48.112]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.112]                   signalCondition(cond)
[17:44:48.112]                 }
[17:44:48.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.112]                 "immediateCondition"))) {
[17:44:48.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.112]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.112]                   if (TRUE && !signal) {
[17:44:48.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.112]                     {
[17:44:48.112]                       inherits <- base::inherits
[17:44:48.112]                       invokeRestart <- base::invokeRestart
[17:44:48.112]                       is.null <- base::is.null
[17:44:48.112]                       muffled <- FALSE
[17:44:48.112]                       if (inherits(cond, "message")) {
[17:44:48.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.112]                         if (muffled) 
[17:44:48.112]                           invokeRestart("muffleMessage")
[17:44:48.112]                       }
[17:44:48.112]                       else if (inherits(cond, "warning")) {
[17:44:48.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.112]                         if (muffled) 
[17:44:48.112]                           invokeRestart("muffleWarning")
[17:44:48.112]                       }
[17:44:48.112]                       else if (inherits(cond, "condition")) {
[17:44:48.112]                         if (!is.null(pattern)) {
[17:44:48.112]                           computeRestarts <- base::computeRestarts
[17:44:48.112]                           grepl <- base::grepl
[17:44:48.112]                           restarts <- computeRestarts(cond)
[17:44:48.112]                           for (restart in restarts) {
[17:44:48.112]                             name <- restart$name
[17:44:48.112]                             if (is.null(name)) 
[17:44:48.112]                               next
[17:44:48.112]                             if (!grepl(pattern, name)) 
[17:44:48.112]                               next
[17:44:48.112]                             invokeRestart(restart)
[17:44:48.112]                             muffled <- TRUE
[17:44:48.112]                             break
[17:44:48.112]                           }
[17:44:48.112]                         }
[17:44:48.112]                       }
[17:44:48.112]                       invisible(muffled)
[17:44:48.112]                     }
[17:44:48.112]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.112]                   }
[17:44:48.112]                 }
[17:44:48.112]                 else {
[17:44:48.112]                   if (TRUE) {
[17:44:48.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.112]                     {
[17:44:48.112]                       inherits <- base::inherits
[17:44:48.112]                       invokeRestart <- base::invokeRestart
[17:44:48.112]                       is.null <- base::is.null
[17:44:48.112]                       muffled <- FALSE
[17:44:48.112]                       if (inherits(cond, "message")) {
[17:44:48.112]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.112]                         if (muffled) 
[17:44:48.112]                           invokeRestart("muffleMessage")
[17:44:48.112]                       }
[17:44:48.112]                       else if (inherits(cond, "warning")) {
[17:44:48.112]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.112]                         if (muffled) 
[17:44:48.112]                           invokeRestart("muffleWarning")
[17:44:48.112]                       }
[17:44:48.112]                       else if (inherits(cond, "condition")) {
[17:44:48.112]                         if (!is.null(pattern)) {
[17:44:48.112]                           computeRestarts <- base::computeRestarts
[17:44:48.112]                           grepl <- base::grepl
[17:44:48.112]                           restarts <- computeRestarts(cond)
[17:44:48.112]                           for (restart in restarts) {
[17:44:48.112]                             name <- restart$name
[17:44:48.112]                             if (is.null(name)) 
[17:44:48.112]                               next
[17:44:48.112]                             if (!grepl(pattern, name)) 
[17:44:48.112]                               next
[17:44:48.112]                             invokeRestart(restart)
[17:44:48.112]                             muffled <- TRUE
[17:44:48.112]                             break
[17:44:48.112]                           }
[17:44:48.112]                         }
[17:44:48.112]                       }
[17:44:48.112]                       invisible(muffled)
[17:44:48.112]                     }
[17:44:48.112]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.112]                   }
[17:44:48.112]                 }
[17:44:48.112]             }
[17:44:48.112]         }))
[17:44:48.112]     }, error = function(ex) {
[17:44:48.112]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.112]                 ...future.rng), started = ...future.startTime, 
[17:44:48.112]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.112]             version = "1.8"), class = "FutureResult")
[17:44:48.112]     }, finally = {
[17:44:48.112]         if (!identical(...future.workdir, getwd())) 
[17:44:48.112]             setwd(...future.workdir)
[17:44:48.112]         {
[17:44:48.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.112]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.112]             }
[17:44:48.112]             base::options(...future.oldOptions)
[17:44:48.112]             if (.Platform$OS.type == "windows") {
[17:44:48.112]                 old_names <- names(...future.oldEnvVars)
[17:44:48.112]                 envs <- base::Sys.getenv()
[17:44:48.112]                 names <- names(envs)
[17:44:48.112]                 common <- intersect(names, old_names)
[17:44:48.112]                 added <- setdiff(names, old_names)
[17:44:48.112]                 removed <- setdiff(old_names, names)
[17:44:48.112]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.112]                   envs[common]]
[17:44:48.112]                 NAMES <- toupper(changed)
[17:44:48.112]                 args <- list()
[17:44:48.112]                 for (kk in seq_along(NAMES)) {
[17:44:48.112]                   name <- changed[[kk]]
[17:44:48.112]                   NAME <- NAMES[[kk]]
[17:44:48.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.112]                     next
[17:44:48.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.112]                 }
[17:44:48.112]                 NAMES <- toupper(added)
[17:44:48.112]                 for (kk in seq_along(NAMES)) {
[17:44:48.112]                   name <- added[[kk]]
[17:44:48.112]                   NAME <- NAMES[[kk]]
[17:44:48.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.112]                     next
[17:44:48.112]                   args[[name]] <- ""
[17:44:48.112]                 }
[17:44:48.112]                 NAMES <- toupper(removed)
[17:44:48.112]                 for (kk in seq_along(NAMES)) {
[17:44:48.112]                   name <- removed[[kk]]
[17:44:48.112]                   NAME <- NAMES[[kk]]
[17:44:48.112]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.112]                     next
[17:44:48.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.112]                 }
[17:44:48.112]                 if (length(args) > 0) 
[17:44:48.112]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.112]             }
[17:44:48.112]             else {
[17:44:48.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.112]             }
[17:44:48.112]             {
[17:44:48.112]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.112]                   0L) {
[17:44:48.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.112]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.112]                   base::options(opts)
[17:44:48.112]                 }
[17:44:48.112]                 {
[17:44:48.112]                   {
[17:44:48.112]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.112]                     NULL
[17:44:48.112]                   }
[17:44:48.112]                   options(future.plan = NULL)
[17:44:48.112]                   if (is.na(NA_character_)) 
[17:44:48.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.112]                     .init = FALSE)
[17:44:48.112]                 }
[17:44:48.112]             }
[17:44:48.112]         }
[17:44:48.112]     })
[17:44:48.112]     if (TRUE) {
[17:44:48.112]         base::sink(type = "output", split = FALSE)
[17:44:48.112]         if (TRUE) {
[17:44:48.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.112]         }
[17:44:48.112]         else {
[17:44:48.112]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.112]         }
[17:44:48.112]         base::close(...future.stdout)
[17:44:48.112]         ...future.stdout <- NULL
[17:44:48.112]     }
[17:44:48.112]     ...future.result$conditions <- ...future.conditions
[17:44:48.112]     ...future.result$finished <- base::Sys.time()
[17:44:48.112]     ...future.result
[17:44:48.112] }
[17:44:48.115] assign_globals() ...
[17:44:48.115] List of 5
[17:44:48.115]  $ ...future.FUN            :function (x, y)  
[17:44:48.115]  $ MoreArgs                 :List of 1
[17:44:48.115]   ..$ y: int [1:2] 3 4
[17:44:48.115]  $ ...future.elements_ii    :List of 1
[17:44:48.115]   ..$ x:List of 1
[17:44:48.115]   .. ..$ : int 2
[17:44:48.115]  $ ...future.seeds_ii       : NULL
[17:44:48.115]  $ ...future.globals.maxSize: NULL
[17:44:48.115]  - attr(*, "where")=List of 5
[17:44:48.115]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.115]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.115]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.115]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.115]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.115]  - attr(*, "resolved")= logi FALSE
[17:44:48.115]  - attr(*, "total_size")= num 1816
[17:44:48.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.115]  - attr(*, "already-done")= logi TRUE
[17:44:48.121] - reassign environment for ‘...future.FUN’
[17:44:48.122] - copied ‘...future.FUN’ to environment
[17:44:48.122] - copied ‘MoreArgs’ to environment
[17:44:48.122] - copied ‘...future.elements_ii’ to environment
[17:44:48.122] - copied ‘...future.seeds_ii’ to environment
[17:44:48.122] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.122] assign_globals() ... done
[17:44:48.122] requestCore(): workers = 2
[17:44:48.125] MulticoreFuture started
[17:44:48.125] - Launch lazy future ... done
[17:44:48.125] run() for ‘MulticoreFuture’ ... done
[17:44:48.126] Created future:
[17:44:48.126] plan(): Setting new future strategy stack:
[17:44:48.126] List of future strategies:
[17:44:48.126] 1. sequential:
[17:44:48.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.126]    - tweaked: FALSE
[17:44:48.126]    - call: NULL
[17:44:48.127] plan(): nbrOfWorkers() = 1
[17:44:48.129] plan(): Setting new future strategy stack:
[17:44:48.129] List of future strategies:
[17:44:48.129] 1. multicore:
[17:44:48.129]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.129]    - tweaked: FALSE
[17:44:48.129]    - call: plan(strategy)
[17:44:48.134] plan(): nbrOfWorkers() = 2
[17:44:48.126] MulticoreFuture:
[17:44:48.126] Label: ‘future_mapply-2’
[17:44:48.126] Expression:
[17:44:48.126] {
[17:44:48.126]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.126]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.126]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.126]         on.exit(options(oopts), add = TRUE)
[17:44:48.126]     }
[17:44:48.126]     {
[17:44:48.126]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.126]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.126]         do.call(mapply, args = args)
[17:44:48.126]     }
[17:44:48.126] }
[17:44:48.126] Lazy evaluation: FALSE
[17:44:48.126] Asynchronous evaluation: TRUE
[17:44:48.126] Local evaluation: TRUE
[17:44:48.126] Environment: R_GlobalEnv
[17:44:48.126] Capture standard output: TRUE
[17:44:48.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.126] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.126] Packages: <none>
[17:44:48.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.126] Resolved: TRUE
[17:44:48.126] Value: <not collected>
[17:44:48.126] Conditions captured: <none>
[17:44:48.126] Early signaling: FALSE
[17:44:48.126] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.126] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.135] Chunk #2 of 2 ... DONE
[17:44:48.135] Launching 2 futures (chunks) ... DONE
[17:44:48.136] Resolving 2 futures (chunks) ...
[17:44:48.136] resolve() on list ...
[17:44:48.136]  recursive: 0
[17:44:48.136]  length: 2
[17:44:48.136] 
[17:44:48.137] Future #1
[17:44:48.137] result() for MulticoreFuture ...
[17:44:48.138] result() for MulticoreFuture ...
[17:44:48.138] result() for MulticoreFuture ... done
[17:44:48.138] result() for MulticoreFuture ... done
[17:44:48.138] result() for MulticoreFuture ...
[17:44:48.138] result() for MulticoreFuture ... done
[17:44:48.139] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.139] - nx: 2
[17:44:48.139] - relay: TRUE
[17:44:48.139] - stdout: TRUE
[17:44:48.139] - signal: TRUE
[17:44:48.148] - resignal: FALSE
[17:44:48.148] - force: TRUE
[17:44:48.148] - relayed: [n=2] FALSE, FALSE
[17:44:48.148] - queued futures: [n=2] FALSE, FALSE
[17:44:48.149]  - until=1
[17:44:48.149]  - relaying element #1
[17:44:48.149] result() for MulticoreFuture ...
[17:44:48.149] result() for MulticoreFuture ... done
[17:44:48.149] result() for MulticoreFuture ...
[17:44:48.149] result() for MulticoreFuture ... done
[17:44:48.149] result() for MulticoreFuture ...
[17:44:48.149] result() for MulticoreFuture ... done
[17:44:48.149] result() for MulticoreFuture ...
[17:44:48.150] result() for MulticoreFuture ... done
[17:44:48.150] - relayed: [n=2] TRUE, FALSE
[17:44:48.150] - queued futures: [n=2] TRUE, FALSE
[17:44:48.150] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.150]  length: 1 (resolved future 1)
[17:44:48.151] Future #2
[17:44:48.151] result() for MulticoreFuture ...
[17:44:48.152] result() for MulticoreFuture ...
[17:44:48.152] result() for MulticoreFuture ... done
[17:44:48.152] result() for MulticoreFuture ... done
[17:44:48.152] result() for MulticoreFuture ...
[17:44:48.153] result() for MulticoreFuture ... done
[17:44:48.153] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.153] - nx: 2
[17:44:48.153] - relay: TRUE
[17:44:48.153] - stdout: TRUE
[17:44:48.153] - signal: TRUE
[17:44:48.154] - resignal: FALSE
[17:44:48.154] - force: TRUE
[17:44:48.154] - relayed: [n=2] TRUE, FALSE
[17:44:48.154] - queued futures: [n=2] TRUE, FALSE
[17:44:48.154]  - until=2
[17:44:48.154]  - relaying element #2
[17:44:48.154] result() for MulticoreFuture ...
[17:44:48.155] result() for MulticoreFuture ... done
[17:44:48.155] result() for MulticoreFuture ...
[17:44:48.155] result() for MulticoreFuture ... done
[17:44:48.155] result() for MulticoreFuture ...
[17:44:48.155] result() for MulticoreFuture ... done
[17:44:48.155] result() for MulticoreFuture ...
[17:44:48.155] result() for MulticoreFuture ... done
[17:44:48.156] - relayed: [n=2] TRUE, TRUE
[17:44:48.156] - queued futures: [n=2] TRUE, TRUE
[17:44:48.156] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.156]  length: 0 (resolved future 2)
[17:44:48.156] Relaying remaining futures
[17:44:48.156] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.156] - nx: 2
[17:44:48.157] - relay: TRUE
[17:44:48.157] - stdout: TRUE
[17:44:48.157] - signal: TRUE
[17:44:48.157] - resignal: FALSE
[17:44:48.157] - force: TRUE
[17:44:48.157] - relayed: [n=2] TRUE, TRUE
[17:44:48.157] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.157] - relayed: [n=2] TRUE, TRUE
[17:44:48.158] - queued futures: [n=2] TRUE, TRUE
[17:44:48.158] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.158] resolve() on list ... DONE
[17:44:48.158] result() for MulticoreFuture ...
[17:44:48.158] result() for MulticoreFuture ... done
[17:44:48.158] result() for MulticoreFuture ...
[17:44:48.158] result() for MulticoreFuture ... done
[17:44:48.158] result() for MulticoreFuture ...
[17:44:48.158] result() for MulticoreFuture ... done
[17:44:48.158] result() for MulticoreFuture ...
[17:44:48.159] result() for MulticoreFuture ... done
[17:44:48.159]  - Number of value chunks collected: 2
[17:44:48.159] Resolving 2 futures (chunks) ... DONE
[17:44:48.159] Reducing values from 2 chunks ...
[17:44:48.159]  - Number of values collected after concatenation: 2
[17:44:48.159]  - Number of values expected: 2
[17:44:48.159] Reducing values from 2 chunks ... DONE
[17:44:48.159] future_mapply() ... DONE
[17:44:48.160] future_mapply() ...
[17:44:48.160] Generating random seeds ...
[17:44:48.160] Generating random seed streams for 2 elements ...
[17:44:48.160] Generating random seed streams for 2 elements ... DONE
[17:44:48.160] Generating random seeds ... DONE
[17:44:48.160] Will set RNG state on exit: 10407, 1739498560, 477920321, 1880373827, -1109387676, -1376856778, -98316031
[17:44:48.165] Number of chunks: 2
[17:44:48.165] getGlobalsAndPackagesXApply() ...
[17:44:48.165]  - future.globals: TRUE
[17:44:48.165] getGlobalsAndPackages() ...
[17:44:48.165] Searching for globals...
[17:44:48.166] - globals found: [1] ‘FUN’
[17:44:48.167] Searching for globals ... DONE
[17:44:48.167] Resolving globals: FALSE
[17:44:48.167] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:48.167] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:48.168] - globals: [1] ‘FUN’
[17:44:48.168] 
[17:44:48.168] getGlobalsAndPackages() ... DONE
[17:44:48.168]  - globals found/used: [n=1] ‘FUN’
[17:44:48.168]  - needed namespaces: [n=0] 
[17:44:48.168] Finding globals ... DONE
[17:44:48.168] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.168] List of 2
[17:44:48.168]  $ ...future.FUN:function (x, y)  
[17:44:48.168]  $ MoreArgs     :List of 1
[17:44:48.168]   ..$ y: int [1:2] 3 4
[17:44:48.168]  - attr(*, "where")=List of 2
[17:44:48.168]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.168]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.168]  - attr(*, "resolved")= logi FALSE
[17:44:48.168]  - attr(*, "total_size")= num NA
[17:44:48.172] Packages to be attached in all futures: [n=0] 
[17:44:48.172] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.172] Number of futures (= number of chunks): 2
[17:44:48.172] Launching 2 futures (chunks) ...
[17:44:48.172] Chunk #1 of 2 ...
[17:44:48.172]  - Finding globals in '...' for chunk #1 ...
[17:44:48.172] getGlobalsAndPackages() ...
[17:44:48.172] Searching for globals...
[17:44:48.173] 
[17:44:48.173] Searching for globals ... DONE
[17:44:48.173] - globals: [0] <none>
[17:44:48.173] getGlobalsAndPackages() ... DONE
[17:44:48.173]    + additional globals found: [n=0] 
[17:44:48.173]    + additional namespaces needed: [n=0] 
[17:44:48.173]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.173]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.174]  - seeds: [1] <seeds>
[17:44:48.174]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.174] getGlobalsAndPackages() ...
[17:44:48.174] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.174] Resolving globals: FALSE
[17:44:48.174] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:44:48.175] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:48.175] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.175] 
[17:44:48.175] getGlobalsAndPackages() ... DONE
[17:44:48.176] run() for ‘Future’ ...
[17:44:48.176] - state: ‘created’
[17:44:48.176] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.183] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.183]   - Field: ‘label’
[17:44:48.183]   - Field: ‘local’
[17:44:48.183]   - Field: ‘owner’
[17:44:48.183]   - Field: ‘envir’
[17:44:48.184]   - Field: ‘workers’
[17:44:48.184]   - Field: ‘packages’
[17:44:48.184]   - Field: ‘gc’
[17:44:48.184]   - Field: ‘job’
[17:44:48.184]   - Field: ‘conditions’
[17:44:48.184]   - Field: ‘expr’
[17:44:48.184]   - Field: ‘uuid’
[17:44:48.184]   - Field: ‘seed’
[17:44:48.185]   - Field: ‘version’
[17:44:48.185]   - Field: ‘result’
[17:44:48.185]   - Field: ‘asynchronous’
[17:44:48.185]   - Field: ‘calls’
[17:44:48.185]   - Field: ‘globals’
[17:44:48.185]   - Field: ‘stdout’
[17:44:48.185]   - Field: ‘earlySignal’
[17:44:48.185]   - Field: ‘lazy’
[17:44:48.186]   - Field: ‘state’
[17:44:48.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.186] - Launch lazy future ...
[17:44:48.186] Packages needed by the future expression (n = 0): <none>
[17:44:48.186] Packages needed by future strategies (n = 0): <none>
[17:44:48.187] {
[17:44:48.187]     {
[17:44:48.187]         {
[17:44:48.187]             ...future.startTime <- base::Sys.time()
[17:44:48.187]             {
[17:44:48.187]                 {
[17:44:48.187]                   {
[17:44:48.187]                     {
[17:44:48.187]                       base::local({
[17:44:48.187]                         has_future <- base::requireNamespace("future", 
[17:44:48.187]                           quietly = TRUE)
[17:44:48.187]                         if (has_future) {
[17:44:48.187]                           ns <- base::getNamespace("future")
[17:44:48.187]                           version <- ns[[".package"]][["version"]]
[17:44:48.187]                           if (is.null(version)) 
[17:44:48.187]                             version <- utils::packageVersion("future")
[17:44:48.187]                         }
[17:44:48.187]                         else {
[17:44:48.187]                           version <- NULL
[17:44:48.187]                         }
[17:44:48.187]                         if (!has_future || version < "1.8.0") {
[17:44:48.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.187]                             "", base::R.version$version.string), 
[17:44:48.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.187]                               "release", "version")], collapse = " "), 
[17:44:48.187]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.187]                             info)
[17:44:48.187]                           info <- base::paste(info, collapse = "; ")
[17:44:48.187]                           if (!has_future) {
[17:44:48.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.187]                               info)
[17:44:48.187]                           }
[17:44:48.187]                           else {
[17:44:48.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.187]                               info, version)
[17:44:48.187]                           }
[17:44:48.187]                           base::stop(msg)
[17:44:48.187]                         }
[17:44:48.187]                       })
[17:44:48.187]                     }
[17:44:48.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.187]                     base::options(mc.cores = 1L)
[17:44:48.187]                   }
[17:44:48.187]                   ...future.strategy.old <- future::plan("list")
[17:44:48.187]                   options(future.plan = NULL)
[17:44:48.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.187]                 }
[17:44:48.187]                 ...future.workdir <- getwd()
[17:44:48.187]             }
[17:44:48.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.187]         }
[17:44:48.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.187]             base::names(...future.oldOptions))
[17:44:48.187]     }
[17:44:48.187]     if (FALSE) {
[17:44:48.187]     }
[17:44:48.187]     else {
[17:44:48.187]         if (TRUE) {
[17:44:48.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.187]                 open = "w")
[17:44:48.187]         }
[17:44:48.187]         else {
[17:44:48.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.187]         }
[17:44:48.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.187]             base::sink(type = "output", split = FALSE)
[17:44:48.187]             base::close(...future.stdout)
[17:44:48.187]         }, add = TRUE)
[17:44:48.187]     }
[17:44:48.187]     ...future.frame <- base::sys.nframe()
[17:44:48.187]     ...future.conditions <- base::list()
[17:44:48.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.187]     if (FALSE) {
[17:44:48.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.187]     }
[17:44:48.187]     ...future.result <- base::tryCatch({
[17:44:48.187]         base::withCallingHandlers({
[17:44:48.187]             ...future.value <- base::withVisible(base::local({
[17:44:48.187]                 withCallingHandlers({
[17:44:48.187]                   {
[17:44:48.187]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.187]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.187]                       ...future.globals.maxSize)) {
[17:44:48.187]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.187]                       on.exit(options(oopts), add = TRUE)
[17:44:48.187]                     }
[17:44:48.187]                     {
[17:44:48.187]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.187]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:48.187]                           envir = globalenv(), inherits = FALSE)
[17:44:48.187]                         ...future.FUN(...)
[17:44:48.187]                       }
[17:44:48.187]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.187]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.187]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.187]                         USE.NAMES = FALSE)
[17:44:48.187]                       do.call(mapply, args = args)
[17:44:48.187]                     }
[17:44:48.187]                   }
[17:44:48.187]                 }, immediateCondition = function(cond) {
[17:44:48.187]                   save_rds <- function (object, pathname, ...) 
[17:44:48.187]                   {
[17:44:48.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.187]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.187]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.187]                         fi_tmp[["mtime"]])
[17:44:48.187]                     }
[17:44:48.187]                     tryCatch({
[17:44:48.187]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.187]                     }, error = function(ex) {
[17:44:48.187]                       msg <- conditionMessage(ex)
[17:44:48.187]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.187]                         fi_tmp[["mtime"]], msg)
[17:44:48.187]                       ex$message <- msg
[17:44:48.187]                       stop(ex)
[17:44:48.187]                     })
[17:44:48.187]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.187]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.187]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.187]                       fi <- file.info(pathname)
[17:44:48.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.187]                         fi[["size"]], fi[["mtime"]])
[17:44:48.187]                       stop(msg)
[17:44:48.187]                     }
[17:44:48.187]                     invisible(pathname)
[17:44:48.187]                   }
[17:44:48.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.187]                     rootPath = tempdir()) 
[17:44:48.187]                   {
[17:44:48.187]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.187]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.187]                       tmpdir = path, fileext = ".rds")
[17:44:48.187]                     save_rds(obj, file)
[17:44:48.187]                   }
[17:44:48.187]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.187]                   {
[17:44:48.187]                     inherits <- base::inherits
[17:44:48.187]                     invokeRestart <- base::invokeRestart
[17:44:48.187]                     is.null <- base::is.null
[17:44:48.187]                     muffled <- FALSE
[17:44:48.187]                     if (inherits(cond, "message")) {
[17:44:48.187]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.187]                       if (muffled) 
[17:44:48.187]                         invokeRestart("muffleMessage")
[17:44:48.187]                     }
[17:44:48.187]                     else if (inherits(cond, "warning")) {
[17:44:48.187]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.187]                       if (muffled) 
[17:44:48.187]                         invokeRestart("muffleWarning")
[17:44:48.187]                     }
[17:44:48.187]                     else if (inherits(cond, "condition")) {
[17:44:48.187]                       if (!is.null(pattern)) {
[17:44:48.187]                         computeRestarts <- base::computeRestarts
[17:44:48.187]                         grepl <- base::grepl
[17:44:48.187]                         restarts <- computeRestarts(cond)
[17:44:48.187]                         for (restart in restarts) {
[17:44:48.187]                           name <- restart$name
[17:44:48.187]                           if (is.null(name)) 
[17:44:48.187]                             next
[17:44:48.187]                           if (!grepl(pattern, name)) 
[17:44:48.187]                             next
[17:44:48.187]                           invokeRestart(restart)
[17:44:48.187]                           muffled <- TRUE
[17:44:48.187]                           break
[17:44:48.187]                         }
[17:44:48.187]                       }
[17:44:48.187]                     }
[17:44:48.187]                     invisible(muffled)
[17:44:48.187]                   }
[17:44:48.187]                   muffleCondition(cond)
[17:44:48.187]                 })
[17:44:48.187]             }))
[17:44:48.187]             future::FutureResult(value = ...future.value$value, 
[17:44:48.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.187]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.187]                     ...future.globalenv.names))
[17:44:48.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.187]         }, condition = base::local({
[17:44:48.187]             c <- base::c
[17:44:48.187]             inherits <- base::inherits
[17:44:48.187]             invokeRestart <- base::invokeRestart
[17:44:48.187]             length <- base::length
[17:44:48.187]             list <- base::list
[17:44:48.187]             seq.int <- base::seq.int
[17:44:48.187]             signalCondition <- base::signalCondition
[17:44:48.187]             sys.calls <- base::sys.calls
[17:44:48.187]             `[[` <- base::`[[`
[17:44:48.187]             `+` <- base::`+`
[17:44:48.187]             `<<-` <- base::`<<-`
[17:44:48.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.187]                   3L)]
[17:44:48.187]             }
[17:44:48.187]             function(cond) {
[17:44:48.187]                 is_error <- inherits(cond, "error")
[17:44:48.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.187]                   NULL)
[17:44:48.187]                 if (is_error) {
[17:44:48.187]                   sessionInformation <- function() {
[17:44:48.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.187]                       search = base::search(), system = base::Sys.info())
[17:44:48.187]                   }
[17:44:48.187]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.187]                     cond$call), session = sessionInformation(), 
[17:44:48.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.187]                   signalCondition(cond)
[17:44:48.187]                 }
[17:44:48.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.187]                 "immediateCondition"))) {
[17:44:48.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.187]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.187]                   if (TRUE && !signal) {
[17:44:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.187]                     {
[17:44:48.187]                       inherits <- base::inherits
[17:44:48.187]                       invokeRestart <- base::invokeRestart
[17:44:48.187]                       is.null <- base::is.null
[17:44:48.187]                       muffled <- FALSE
[17:44:48.187]                       if (inherits(cond, "message")) {
[17:44:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.187]                         if (muffled) 
[17:44:48.187]                           invokeRestart("muffleMessage")
[17:44:48.187]                       }
[17:44:48.187]                       else if (inherits(cond, "warning")) {
[17:44:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.187]                         if (muffled) 
[17:44:48.187]                           invokeRestart("muffleWarning")
[17:44:48.187]                       }
[17:44:48.187]                       else if (inherits(cond, "condition")) {
[17:44:48.187]                         if (!is.null(pattern)) {
[17:44:48.187]                           computeRestarts <- base::computeRestarts
[17:44:48.187]                           grepl <- base::grepl
[17:44:48.187]                           restarts <- computeRestarts(cond)
[17:44:48.187]                           for (restart in restarts) {
[17:44:48.187]                             name <- restart$name
[17:44:48.187]                             if (is.null(name)) 
[17:44:48.187]                               next
[17:44:48.187]                             if (!grepl(pattern, name)) 
[17:44:48.187]                               next
[17:44:48.187]                             invokeRestart(restart)
[17:44:48.187]                             muffled <- TRUE
[17:44:48.187]                             break
[17:44:48.187]                           }
[17:44:48.187]                         }
[17:44:48.187]                       }
[17:44:48.187]                       invisible(muffled)
[17:44:48.187]                     }
[17:44:48.187]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.187]                   }
[17:44:48.187]                 }
[17:44:48.187]                 else {
[17:44:48.187]                   if (TRUE) {
[17:44:48.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.187]                     {
[17:44:48.187]                       inherits <- base::inherits
[17:44:48.187]                       invokeRestart <- base::invokeRestart
[17:44:48.187]                       is.null <- base::is.null
[17:44:48.187]                       muffled <- FALSE
[17:44:48.187]                       if (inherits(cond, "message")) {
[17:44:48.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.187]                         if (muffled) 
[17:44:48.187]                           invokeRestart("muffleMessage")
[17:44:48.187]                       }
[17:44:48.187]                       else if (inherits(cond, "warning")) {
[17:44:48.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.187]                         if (muffled) 
[17:44:48.187]                           invokeRestart("muffleWarning")
[17:44:48.187]                       }
[17:44:48.187]                       else if (inherits(cond, "condition")) {
[17:44:48.187]                         if (!is.null(pattern)) {
[17:44:48.187]                           computeRestarts <- base::computeRestarts
[17:44:48.187]                           grepl <- base::grepl
[17:44:48.187]                           restarts <- computeRestarts(cond)
[17:44:48.187]                           for (restart in restarts) {
[17:44:48.187]                             name <- restart$name
[17:44:48.187]                             if (is.null(name)) 
[17:44:48.187]                               next
[17:44:48.187]                             if (!grepl(pattern, name)) 
[17:44:48.187]                               next
[17:44:48.187]                             invokeRestart(restart)
[17:44:48.187]                             muffled <- TRUE
[17:44:48.187]                             break
[17:44:48.187]                           }
[17:44:48.187]                         }
[17:44:48.187]                       }
[17:44:48.187]                       invisible(muffled)
[17:44:48.187]                     }
[17:44:48.187]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.187]                   }
[17:44:48.187]                 }
[17:44:48.187]             }
[17:44:48.187]         }))
[17:44:48.187]     }, error = function(ex) {
[17:44:48.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.187]                 ...future.rng), started = ...future.startTime, 
[17:44:48.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.187]             version = "1.8"), class = "FutureResult")
[17:44:48.187]     }, finally = {
[17:44:48.187]         if (!identical(...future.workdir, getwd())) 
[17:44:48.187]             setwd(...future.workdir)
[17:44:48.187]         {
[17:44:48.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.187]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.187]             }
[17:44:48.187]             base::options(...future.oldOptions)
[17:44:48.187]             if (.Platform$OS.type == "windows") {
[17:44:48.187]                 old_names <- names(...future.oldEnvVars)
[17:44:48.187]                 envs <- base::Sys.getenv()
[17:44:48.187]                 names <- names(envs)
[17:44:48.187]                 common <- intersect(names, old_names)
[17:44:48.187]                 added <- setdiff(names, old_names)
[17:44:48.187]                 removed <- setdiff(old_names, names)
[17:44:48.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.187]                   envs[common]]
[17:44:48.187]                 NAMES <- toupper(changed)
[17:44:48.187]                 args <- list()
[17:44:48.187]                 for (kk in seq_along(NAMES)) {
[17:44:48.187]                   name <- changed[[kk]]
[17:44:48.187]                   NAME <- NAMES[[kk]]
[17:44:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.187]                     next
[17:44:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.187]                 }
[17:44:48.187]                 NAMES <- toupper(added)
[17:44:48.187]                 for (kk in seq_along(NAMES)) {
[17:44:48.187]                   name <- added[[kk]]
[17:44:48.187]                   NAME <- NAMES[[kk]]
[17:44:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.187]                     next
[17:44:48.187]                   args[[name]] <- ""
[17:44:48.187]                 }
[17:44:48.187]                 NAMES <- toupper(removed)
[17:44:48.187]                 for (kk in seq_along(NAMES)) {
[17:44:48.187]                   name <- removed[[kk]]
[17:44:48.187]                   NAME <- NAMES[[kk]]
[17:44:48.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.187]                     next
[17:44:48.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.187]                 }
[17:44:48.187]                 if (length(args) > 0) 
[17:44:48.187]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.187]             }
[17:44:48.187]             else {
[17:44:48.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.187]             }
[17:44:48.187]             {
[17:44:48.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.187]                   0L) {
[17:44:48.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.187]                   base::options(opts)
[17:44:48.187]                 }
[17:44:48.187]                 {
[17:44:48.187]                   {
[17:44:48.187]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.187]                     NULL
[17:44:48.187]                   }
[17:44:48.187]                   options(future.plan = NULL)
[17:44:48.187]                   if (is.na(NA_character_)) 
[17:44:48.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.187]                     .init = FALSE)
[17:44:48.187]                 }
[17:44:48.187]             }
[17:44:48.187]         }
[17:44:48.187]     })
[17:44:48.187]     if (TRUE) {
[17:44:48.187]         base::sink(type = "output", split = FALSE)
[17:44:48.187]         if (TRUE) {
[17:44:48.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.187]         }
[17:44:48.187]         else {
[17:44:48.187]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.187]         }
[17:44:48.187]         base::close(...future.stdout)
[17:44:48.187]         ...future.stdout <- NULL
[17:44:48.187]     }
[17:44:48.187]     ...future.result$conditions <- ...future.conditions
[17:44:48.187]     ...future.result$finished <- base::Sys.time()
[17:44:48.187]     ...future.result
[17:44:48.187] }
[17:44:48.189] assign_globals() ...
[17:44:48.189] List of 5
[17:44:48.189]  $ ...future.FUN            :function (x, y)  
[17:44:48.189]  $ MoreArgs                 :List of 1
[17:44:48.189]   ..$ y: int [1:2] 3 4
[17:44:48.189]  $ ...future.elements_ii    :List of 1
[17:44:48.189]   ..$ x:List of 1
[17:44:48.189]   .. ..$ : int 1
[17:44:48.189]  $ ...future.seeds_ii       :List of 1
[17:44:48.189]   ..$ : int [1:7] 10407 -162244663 -375032581 -1166909799 902762259 1208788162 -228144200
[17:44:48.189]  $ ...future.globals.maxSize: NULL
[17:44:48.189]  - attr(*, "where")=List of 5
[17:44:48.189]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.189]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.189]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.189]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.189]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.189]  - attr(*, "resolved")= logi FALSE
[17:44:48.189]  - attr(*, "total_size")= num 1896
[17:44:48.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.189]  - attr(*, "already-done")= logi TRUE
[17:44:48.195] - reassign environment for ‘...future.FUN’
[17:44:48.195] - copied ‘...future.FUN’ to environment
[17:44:48.195] - copied ‘MoreArgs’ to environment
[17:44:48.195] - copied ‘...future.elements_ii’ to environment
[17:44:48.196] - copied ‘...future.seeds_ii’ to environment
[17:44:48.196] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.196] assign_globals() ... done
[17:44:48.196] requestCore(): workers = 2
[17:44:48.198] MulticoreFuture started
[17:44:48.199] - Launch lazy future ... done
[17:44:48.199] run() for ‘MulticoreFuture’ ... done
[17:44:48.199] Created future:
[17:44:48.199] plan(): Setting new future strategy stack:
[17:44:48.200] List of future strategies:
[17:44:48.200] 1. sequential:
[17:44:48.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.200]    - tweaked: FALSE
[17:44:48.200]    - call: NULL
[17:44:48.201] plan(): nbrOfWorkers() = 1
[17:44:48.203] plan(): Setting new future strategy stack:
[17:44:48.203] List of future strategies:
[17:44:48.203] 1. multicore:
[17:44:48.203]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.203]    - tweaked: FALSE
[17:44:48.203]    - call: plan(strategy)
[17:44:48.208] plan(): nbrOfWorkers() = 2
[17:44:48.199] MulticoreFuture:
[17:44:48.199] Label: ‘future_mapply-1’
[17:44:48.199] Expression:
[17:44:48.199] {
[17:44:48.199]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.199]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.199]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.199]         on.exit(options(oopts), add = TRUE)
[17:44:48.199]     }
[17:44:48.199]     {
[17:44:48.199]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.199]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:48.199]                 inherits = FALSE)
[17:44:48.199]             ...future.FUN(...)
[17:44:48.199]         }
[17:44:48.199]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.199]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.199]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.199]         do.call(mapply, args = args)
[17:44:48.199]     }
[17:44:48.199] }
[17:44:48.199] Lazy evaluation: FALSE
[17:44:48.199] Asynchronous evaluation: TRUE
[17:44:48.199] Local evaluation: TRUE
[17:44:48.199] Environment: R_GlobalEnv
[17:44:48.199] Capture standard output: TRUE
[17:44:48.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.199] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.199] Packages: <none>
[17:44:48.199] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:48.199] Resolved: TRUE
[17:44:48.199] Value: <not collected>
[17:44:48.199] Conditions captured: <none>
[17:44:48.199] Early signaling: FALSE
[17:44:48.199] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.199] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.209] Chunk #1 of 2 ... DONE
[17:44:48.210] Chunk #2 of 2 ...
[17:44:48.210]  - Finding globals in '...' for chunk #2 ...
[17:44:48.210] getGlobalsAndPackages() ...
[17:44:48.210] Searching for globals...
[17:44:48.211] 
[17:44:48.211] Searching for globals ... DONE
[17:44:48.211] - globals: [0] <none>
[17:44:48.211] getGlobalsAndPackages() ... DONE
[17:44:48.211]    + additional globals found: [n=0] 
[17:44:48.211]    + additional namespaces needed: [n=0] 
[17:44:48.211]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.212]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.212]  - seeds: [1] <seeds>
[17:44:48.212]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.212] getGlobalsAndPackages() ...
[17:44:48.212] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.213] Resolving globals: FALSE
[17:44:48.213] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:44:48.214] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:48.214] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.215] 
[17:44:48.215] getGlobalsAndPackages() ... DONE
[17:44:48.215] run() for ‘Future’ ...
[17:44:48.216] - state: ‘created’
[17:44:48.216] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.220] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.221]   - Field: ‘label’
[17:44:48.221]   - Field: ‘local’
[17:44:48.221]   - Field: ‘owner’
[17:44:48.221]   - Field: ‘envir’
[17:44:48.222]   - Field: ‘workers’
[17:44:48.222]   - Field: ‘packages’
[17:44:48.222]   - Field: ‘gc’
[17:44:48.222]   - Field: ‘job’
[17:44:48.222]   - Field: ‘conditions’
[17:44:48.222]   - Field: ‘expr’
[17:44:48.223]   - Field: ‘uuid’
[17:44:48.223]   - Field: ‘seed’
[17:44:48.223]   - Field: ‘version’
[17:44:48.223]   - Field: ‘result’
[17:44:48.223]   - Field: ‘asynchronous’
[17:44:48.223]   - Field: ‘calls’
[17:44:48.224]   - Field: ‘globals’
[17:44:48.224]   - Field: ‘stdout’
[17:44:48.224]   - Field: ‘earlySignal’
[17:44:48.224]   - Field: ‘lazy’
[17:44:48.228]   - Field: ‘state’
[17:44:48.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.229] - Launch lazy future ...
[17:44:48.229] Packages needed by the future expression (n = 0): <none>
[17:44:48.230] Packages needed by future strategies (n = 0): <none>
[17:44:48.231] {
[17:44:48.231]     {
[17:44:48.231]         {
[17:44:48.231]             ...future.startTime <- base::Sys.time()
[17:44:48.231]             {
[17:44:48.231]                 {
[17:44:48.231]                   {
[17:44:48.231]                     {
[17:44:48.231]                       base::local({
[17:44:48.231]                         has_future <- base::requireNamespace("future", 
[17:44:48.231]                           quietly = TRUE)
[17:44:48.231]                         if (has_future) {
[17:44:48.231]                           ns <- base::getNamespace("future")
[17:44:48.231]                           version <- ns[[".package"]][["version"]]
[17:44:48.231]                           if (is.null(version)) 
[17:44:48.231]                             version <- utils::packageVersion("future")
[17:44:48.231]                         }
[17:44:48.231]                         else {
[17:44:48.231]                           version <- NULL
[17:44:48.231]                         }
[17:44:48.231]                         if (!has_future || version < "1.8.0") {
[17:44:48.231]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.231]                             "", base::R.version$version.string), 
[17:44:48.231]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.231]                               "release", "version")], collapse = " "), 
[17:44:48.231]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.231]                             info)
[17:44:48.231]                           info <- base::paste(info, collapse = "; ")
[17:44:48.231]                           if (!has_future) {
[17:44:48.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.231]                               info)
[17:44:48.231]                           }
[17:44:48.231]                           else {
[17:44:48.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.231]                               info, version)
[17:44:48.231]                           }
[17:44:48.231]                           base::stop(msg)
[17:44:48.231]                         }
[17:44:48.231]                       })
[17:44:48.231]                     }
[17:44:48.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.231]                     base::options(mc.cores = 1L)
[17:44:48.231]                   }
[17:44:48.231]                   ...future.strategy.old <- future::plan("list")
[17:44:48.231]                   options(future.plan = NULL)
[17:44:48.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.231]                 }
[17:44:48.231]                 ...future.workdir <- getwd()
[17:44:48.231]             }
[17:44:48.231]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.231]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.231]         }
[17:44:48.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.231]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.231]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.231]             base::names(...future.oldOptions))
[17:44:48.231]     }
[17:44:48.231]     if (FALSE) {
[17:44:48.231]     }
[17:44:48.231]     else {
[17:44:48.231]         if (TRUE) {
[17:44:48.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.231]                 open = "w")
[17:44:48.231]         }
[17:44:48.231]         else {
[17:44:48.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.231]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.231]         }
[17:44:48.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.231]             base::sink(type = "output", split = FALSE)
[17:44:48.231]             base::close(...future.stdout)
[17:44:48.231]         }, add = TRUE)
[17:44:48.231]     }
[17:44:48.231]     ...future.frame <- base::sys.nframe()
[17:44:48.231]     ...future.conditions <- base::list()
[17:44:48.231]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.231]     if (FALSE) {
[17:44:48.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.231]     }
[17:44:48.231]     ...future.result <- base::tryCatch({
[17:44:48.231]         base::withCallingHandlers({
[17:44:48.231]             ...future.value <- base::withVisible(base::local({
[17:44:48.231]                 withCallingHandlers({
[17:44:48.231]                   {
[17:44:48.231]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.231]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.231]                       ...future.globals.maxSize)) {
[17:44:48.231]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.231]                       on.exit(options(oopts), add = TRUE)
[17:44:48.231]                     }
[17:44:48.231]                     {
[17:44:48.231]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.231]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:48.231]                           envir = globalenv(), inherits = FALSE)
[17:44:48.231]                         ...future.FUN(...)
[17:44:48.231]                       }
[17:44:48.231]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.231]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.231]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.231]                         USE.NAMES = FALSE)
[17:44:48.231]                       do.call(mapply, args = args)
[17:44:48.231]                     }
[17:44:48.231]                   }
[17:44:48.231]                 }, immediateCondition = function(cond) {
[17:44:48.231]                   save_rds <- function (object, pathname, ...) 
[17:44:48.231]                   {
[17:44:48.231]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.231]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.231]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.231]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.231]                         fi_tmp[["mtime"]])
[17:44:48.231]                     }
[17:44:48.231]                     tryCatch({
[17:44:48.231]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.231]                     }, error = function(ex) {
[17:44:48.231]                       msg <- conditionMessage(ex)
[17:44:48.231]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.231]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.231]                         fi_tmp[["mtime"]], msg)
[17:44:48.231]                       ex$message <- msg
[17:44:48.231]                       stop(ex)
[17:44:48.231]                     })
[17:44:48.231]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.231]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.231]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.231]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.231]                       fi <- file.info(pathname)
[17:44:48.231]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.231]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.231]                         fi[["size"]], fi[["mtime"]])
[17:44:48.231]                       stop(msg)
[17:44:48.231]                     }
[17:44:48.231]                     invisible(pathname)
[17:44:48.231]                   }
[17:44:48.231]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.231]                     rootPath = tempdir()) 
[17:44:48.231]                   {
[17:44:48.231]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.231]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.231]                       tmpdir = path, fileext = ".rds")
[17:44:48.231]                     save_rds(obj, file)
[17:44:48.231]                   }
[17:44:48.231]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.231]                   {
[17:44:48.231]                     inherits <- base::inherits
[17:44:48.231]                     invokeRestart <- base::invokeRestart
[17:44:48.231]                     is.null <- base::is.null
[17:44:48.231]                     muffled <- FALSE
[17:44:48.231]                     if (inherits(cond, "message")) {
[17:44:48.231]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.231]                       if (muffled) 
[17:44:48.231]                         invokeRestart("muffleMessage")
[17:44:48.231]                     }
[17:44:48.231]                     else if (inherits(cond, "warning")) {
[17:44:48.231]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.231]                       if (muffled) 
[17:44:48.231]                         invokeRestart("muffleWarning")
[17:44:48.231]                     }
[17:44:48.231]                     else if (inherits(cond, "condition")) {
[17:44:48.231]                       if (!is.null(pattern)) {
[17:44:48.231]                         computeRestarts <- base::computeRestarts
[17:44:48.231]                         grepl <- base::grepl
[17:44:48.231]                         restarts <- computeRestarts(cond)
[17:44:48.231]                         for (restart in restarts) {
[17:44:48.231]                           name <- restart$name
[17:44:48.231]                           if (is.null(name)) 
[17:44:48.231]                             next
[17:44:48.231]                           if (!grepl(pattern, name)) 
[17:44:48.231]                             next
[17:44:48.231]                           invokeRestart(restart)
[17:44:48.231]                           muffled <- TRUE
[17:44:48.231]                           break
[17:44:48.231]                         }
[17:44:48.231]                       }
[17:44:48.231]                     }
[17:44:48.231]                     invisible(muffled)
[17:44:48.231]                   }
[17:44:48.231]                   muffleCondition(cond)
[17:44:48.231]                 })
[17:44:48.231]             }))
[17:44:48.231]             future::FutureResult(value = ...future.value$value, 
[17:44:48.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.231]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.231]                     ...future.globalenv.names))
[17:44:48.231]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.231]         }, condition = base::local({
[17:44:48.231]             c <- base::c
[17:44:48.231]             inherits <- base::inherits
[17:44:48.231]             invokeRestart <- base::invokeRestart
[17:44:48.231]             length <- base::length
[17:44:48.231]             list <- base::list
[17:44:48.231]             seq.int <- base::seq.int
[17:44:48.231]             signalCondition <- base::signalCondition
[17:44:48.231]             sys.calls <- base::sys.calls
[17:44:48.231]             `[[` <- base::`[[`
[17:44:48.231]             `+` <- base::`+`
[17:44:48.231]             `<<-` <- base::`<<-`
[17:44:48.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.231]                   3L)]
[17:44:48.231]             }
[17:44:48.231]             function(cond) {
[17:44:48.231]                 is_error <- inherits(cond, "error")
[17:44:48.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.231]                   NULL)
[17:44:48.231]                 if (is_error) {
[17:44:48.231]                   sessionInformation <- function() {
[17:44:48.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.231]                       search = base::search(), system = base::Sys.info())
[17:44:48.231]                   }
[17:44:48.231]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.231]                     cond$call), session = sessionInformation(), 
[17:44:48.231]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.231]                   signalCondition(cond)
[17:44:48.231]                 }
[17:44:48.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.231]                 "immediateCondition"))) {
[17:44:48.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.231]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.231]                   if (TRUE && !signal) {
[17:44:48.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.231]                     {
[17:44:48.231]                       inherits <- base::inherits
[17:44:48.231]                       invokeRestart <- base::invokeRestart
[17:44:48.231]                       is.null <- base::is.null
[17:44:48.231]                       muffled <- FALSE
[17:44:48.231]                       if (inherits(cond, "message")) {
[17:44:48.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.231]                         if (muffled) 
[17:44:48.231]                           invokeRestart("muffleMessage")
[17:44:48.231]                       }
[17:44:48.231]                       else if (inherits(cond, "warning")) {
[17:44:48.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.231]                         if (muffled) 
[17:44:48.231]                           invokeRestart("muffleWarning")
[17:44:48.231]                       }
[17:44:48.231]                       else if (inherits(cond, "condition")) {
[17:44:48.231]                         if (!is.null(pattern)) {
[17:44:48.231]                           computeRestarts <- base::computeRestarts
[17:44:48.231]                           grepl <- base::grepl
[17:44:48.231]                           restarts <- computeRestarts(cond)
[17:44:48.231]                           for (restart in restarts) {
[17:44:48.231]                             name <- restart$name
[17:44:48.231]                             if (is.null(name)) 
[17:44:48.231]                               next
[17:44:48.231]                             if (!grepl(pattern, name)) 
[17:44:48.231]                               next
[17:44:48.231]                             invokeRestart(restart)
[17:44:48.231]                             muffled <- TRUE
[17:44:48.231]                             break
[17:44:48.231]                           }
[17:44:48.231]                         }
[17:44:48.231]                       }
[17:44:48.231]                       invisible(muffled)
[17:44:48.231]                     }
[17:44:48.231]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.231]                   }
[17:44:48.231]                 }
[17:44:48.231]                 else {
[17:44:48.231]                   if (TRUE) {
[17:44:48.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.231]                     {
[17:44:48.231]                       inherits <- base::inherits
[17:44:48.231]                       invokeRestart <- base::invokeRestart
[17:44:48.231]                       is.null <- base::is.null
[17:44:48.231]                       muffled <- FALSE
[17:44:48.231]                       if (inherits(cond, "message")) {
[17:44:48.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.231]                         if (muffled) 
[17:44:48.231]                           invokeRestart("muffleMessage")
[17:44:48.231]                       }
[17:44:48.231]                       else if (inherits(cond, "warning")) {
[17:44:48.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.231]                         if (muffled) 
[17:44:48.231]                           invokeRestart("muffleWarning")
[17:44:48.231]                       }
[17:44:48.231]                       else if (inherits(cond, "condition")) {
[17:44:48.231]                         if (!is.null(pattern)) {
[17:44:48.231]                           computeRestarts <- base::computeRestarts
[17:44:48.231]                           grepl <- base::grepl
[17:44:48.231]                           restarts <- computeRestarts(cond)
[17:44:48.231]                           for (restart in restarts) {
[17:44:48.231]                             name <- restart$name
[17:44:48.231]                             if (is.null(name)) 
[17:44:48.231]                               next
[17:44:48.231]                             if (!grepl(pattern, name)) 
[17:44:48.231]                               next
[17:44:48.231]                             invokeRestart(restart)
[17:44:48.231]                             muffled <- TRUE
[17:44:48.231]                             break
[17:44:48.231]                           }
[17:44:48.231]                         }
[17:44:48.231]                       }
[17:44:48.231]                       invisible(muffled)
[17:44:48.231]                     }
[17:44:48.231]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.231]                   }
[17:44:48.231]                 }
[17:44:48.231]             }
[17:44:48.231]         }))
[17:44:48.231]     }, error = function(ex) {
[17:44:48.231]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.231]                 ...future.rng), started = ...future.startTime, 
[17:44:48.231]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.231]             version = "1.8"), class = "FutureResult")
[17:44:48.231]     }, finally = {
[17:44:48.231]         if (!identical(...future.workdir, getwd())) 
[17:44:48.231]             setwd(...future.workdir)
[17:44:48.231]         {
[17:44:48.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.231]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.231]             }
[17:44:48.231]             base::options(...future.oldOptions)
[17:44:48.231]             if (.Platform$OS.type == "windows") {
[17:44:48.231]                 old_names <- names(...future.oldEnvVars)
[17:44:48.231]                 envs <- base::Sys.getenv()
[17:44:48.231]                 names <- names(envs)
[17:44:48.231]                 common <- intersect(names, old_names)
[17:44:48.231]                 added <- setdiff(names, old_names)
[17:44:48.231]                 removed <- setdiff(old_names, names)
[17:44:48.231]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.231]                   envs[common]]
[17:44:48.231]                 NAMES <- toupper(changed)
[17:44:48.231]                 args <- list()
[17:44:48.231]                 for (kk in seq_along(NAMES)) {
[17:44:48.231]                   name <- changed[[kk]]
[17:44:48.231]                   NAME <- NAMES[[kk]]
[17:44:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.231]                     next
[17:44:48.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.231]                 }
[17:44:48.231]                 NAMES <- toupper(added)
[17:44:48.231]                 for (kk in seq_along(NAMES)) {
[17:44:48.231]                   name <- added[[kk]]
[17:44:48.231]                   NAME <- NAMES[[kk]]
[17:44:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.231]                     next
[17:44:48.231]                   args[[name]] <- ""
[17:44:48.231]                 }
[17:44:48.231]                 NAMES <- toupper(removed)
[17:44:48.231]                 for (kk in seq_along(NAMES)) {
[17:44:48.231]                   name <- removed[[kk]]
[17:44:48.231]                   NAME <- NAMES[[kk]]
[17:44:48.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.231]                     next
[17:44:48.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.231]                 }
[17:44:48.231]                 if (length(args) > 0) 
[17:44:48.231]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.231]             }
[17:44:48.231]             else {
[17:44:48.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.231]             }
[17:44:48.231]             {
[17:44:48.231]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.231]                   0L) {
[17:44:48.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.231]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.231]                   base::options(opts)
[17:44:48.231]                 }
[17:44:48.231]                 {
[17:44:48.231]                   {
[17:44:48.231]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.231]                     NULL
[17:44:48.231]                   }
[17:44:48.231]                   options(future.plan = NULL)
[17:44:48.231]                   if (is.na(NA_character_)) 
[17:44:48.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.231]                     .init = FALSE)
[17:44:48.231]                 }
[17:44:48.231]             }
[17:44:48.231]         }
[17:44:48.231]     })
[17:44:48.231]     if (TRUE) {
[17:44:48.231]         base::sink(type = "output", split = FALSE)
[17:44:48.231]         if (TRUE) {
[17:44:48.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.231]         }
[17:44:48.231]         else {
[17:44:48.231]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.231]         }
[17:44:48.231]         base::close(...future.stdout)
[17:44:48.231]         ...future.stdout <- NULL
[17:44:48.231]     }
[17:44:48.231]     ...future.result$conditions <- ...future.conditions
[17:44:48.231]     ...future.result$finished <- base::Sys.time()
[17:44:48.231]     ...future.result
[17:44:48.231] }
[17:44:48.234] assign_globals() ...
[17:44:48.234] List of 5
[17:44:48.234]  $ ...future.FUN            :function (x, y)  
[17:44:48.234]  $ MoreArgs                 :List of 1
[17:44:48.234]   ..$ y: int [1:2] 3 4
[17:44:48.234]  $ ...future.elements_ii    :List of 1
[17:44:48.234]   ..$ x:List of 1
[17:44:48.234]   .. ..$ : int 2
[17:44:48.234]  $ ...future.seeds_ii       :List of 1
[17:44:48.234]   ..$ : int [1:7] 10407 -1822186665 1658120551 635310417 1913536974 -642103996 467800055
[17:44:48.234]  $ ...future.globals.maxSize: NULL
[17:44:48.234]  - attr(*, "where")=List of 5
[17:44:48.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.234]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.234]  - attr(*, "resolved")= logi FALSE
[17:44:48.234]  - attr(*, "total_size")= num 1896
[17:44:48.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.234]  - attr(*, "already-done")= logi TRUE
[17:44:48.244] - reassign environment for ‘...future.FUN’
[17:44:48.244] - copied ‘...future.FUN’ to environment
[17:44:48.244] - copied ‘MoreArgs’ to environment
[17:44:48.245] - copied ‘...future.elements_ii’ to environment
[17:44:48.245] - copied ‘...future.seeds_ii’ to environment
[17:44:48.245] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.245] assign_globals() ... done
[17:44:48.245] requestCore(): workers = 2
[17:44:48.247] MulticoreFuture started
[17:44:48.248] - Launch lazy future ... done
[17:44:48.248] run() for ‘MulticoreFuture’ ... done
[17:44:48.249] Created future:
[17:44:48.249] plan(): Setting new future strategy stack:
[17:44:48.249] List of future strategies:
[17:44:48.249] 1. sequential:
[17:44:48.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.249]    - tweaked: FALSE
[17:44:48.249]    - call: NULL
[17:44:48.250] plan(): nbrOfWorkers() = 1
[17:44:48.252] plan(): Setting new future strategy stack:
[17:44:48.253] List of future strategies:
[17:44:48.253] 1. multicore:
[17:44:48.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.253]    - tweaked: FALSE
[17:44:48.253]    - call: plan(strategy)
[17:44:48.258] plan(): nbrOfWorkers() = 2
[17:44:48.249] MulticoreFuture:
[17:44:48.249] Label: ‘future_mapply-2’
[17:44:48.249] Expression:
[17:44:48.249] {
[17:44:48.249]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.249]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.249]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.249]         on.exit(options(oopts), add = TRUE)
[17:44:48.249]     }
[17:44:48.249]     {
[17:44:48.249]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.249]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:48.249]                 inherits = FALSE)
[17:44:48.249]             ...future.FUN(...)
[17:44:48.249]         }
[17:44:48.249]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.249]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.249]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.249]         do.call(mapply, args = args)
[17:44:48.249]     }
[17:44:48.249] }
[17:44:48.249] Lazy evaluation: FALSE
[17:44:48.249] Asynchronous evaluation: TRUE
[17:44:48.249] Local evaluation: TRUE
[17:44:48.249] Environment: R_GlobalEnv
[17:44:48.249] Capture standard output: TRUE
[17:44:48.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.249] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.249] Packages: <none>
[17:44:48.249] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:48.249] Resolved: TRUE
[17:44:48.249] Value: <not collected>
[17:44:48.249] Conditions captured: <none>
[17:44:48.249] Early signaling: FALSE
[17:44:48.249] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.249] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.259] Chunk #2 of 2 ... DONE
[17:44:48.260] Launching 2 futures (chunks) ... DONE
[17:44:48.260] Resolving 2 futures (chunks) ...
[17:44:48.260] resolve() on list ...
[17:44:48.260]  recursive: 0
[17:44:48.261]  length: 2
[17:44:48.261] 
[17:44:48.261] Future #1
[17:44:48.261] result() for MulticoreFuture ...
[17:44:48.262] result() for MulticoreFuture ...
[17:44:48.262] result() for MulticoreFuture ... done
[17:44:48.263] result() for MulticoreFuture ... done
[17:44:48.263] result() for MulticoreFuture ...
[17:44:48.263] result() for MulticoreFuture ... done
[17:44:48.263] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.263] - nx: 2
[17:44:48.264] - relay: TRUE
[17:44:48.264] - stdout: TRUE
[17:44:48.264] - signal: TRUE
[17:44:48.264] - resignal: FALSE
[17:44:48.264] - force: TRUE
[17:44:48.265] - relayed: [n=2] FALSE, FALSE
[17:44:48.265] - queued futures: [n=2] FALSE, FALSE
[17:44:48.265]  - until=1
[17:44:48.265]  - relaying element #1
[17:44:48.265] result() for MulticoreFuture ...
[17:44:48.266] result() for MulticoreFuture ... done
[17:44:48.266] result() for MulticoreFuture ...
[17:44:48.266] result() for MulticoreFuture ... done
[17:44:48.266] result() for MulticoreFuture ...
[17:44:48.266] result() for MulticoreFuture ... done
[17:44:48.267] result() for MulticoreFuture ...
[17:44:48.267] result() for MulticoreFuture ... done
[17:44:48.267] - relayed: [n=2] TRUE, FALSE
[17:44:48.267] - queued futures: [n=2] TRUE, FALSE
[17:44:48.267] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.268]  length: 1 (resolved future 1)
[17:44:48.268] Future #2
[17:44:48.268] result() for MulticoreFuture ...
[17:44:48.269] result() for MulticoreFuture ...
[17:44:48.269] result() for MulticoreFuture ... done
[17:44:48.269] result() for MulticoreFuture ... done
[17:44:48.269] result() for MulticoreFuture ...
[17:44:48.269] result() for MulticoreFuture ... done
[17:44:48.270] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.270] - nx: 2
[17:44:48.270] - relay: TRUE
[17:44:48.270] - stdout: TRUE
[17:44:48.270] - signal: TRUE
[17:44:48.270] - resignal: FALSE
[17:44:48.270] - force: TRUE
[17:44:48.270] - relayed: [n=2] TRUE, FALSE
[17:44:48.271] - queued futures: [n=2] TRUE, FALSE
[17:44:48.271]  - until=2
[17:44:48.271]  - relaying element #2
[17:44:48.271] result() for MulticoreFuture ...
[17:44:48.271] result() for MulticoreFuture ... done
[17:44:48.271] result() for MulticoreFuture ...
[17:44:48.271] result() for MulticoreFuture ... done
[17:44:48.271] result() for MulticoreFuture ...
[17:44:48.272] result() for MulticoreFuture ... done
[17:44:48.272] result() for MulticoreFuture ...
[17:44:48.272] result() for MulticoreFuture ... done
[17:44:48.272] - relayed: [n=2] TRUE, TRUE
[17:44:48.272] - queued futures: [n=2] TRUE, TRUE
[17:44:48.272] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.272]  length: 0 (resolved future 2)
[17:44:48.272] Relaying remaining futures
[17:44:48.272] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.273] - nx: 2
[17:44:48.273] - relay: TRUE
[17:44:48.273] - stdout: TRUE
[17:44:48.273] - signal: TRUE
[17:44:48.273] - resignal: FALSE
[17:44:48.273] - force: TRUE
[17:44:48.273] - relayed: [n=2] TRUE, TRUE
[17:44:48.273] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.273] - relayed: [n=2] TRUE, TRUE
[17:44:48.274] - queued futures: [n=2] TRUE, TRUE
[17:44:48.274] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.274] resolve() on list ... DONE
[17:44:48.274] result() for MulticoreFuture ...
[17:44:48.274] result() for MulticoreFuture ... done
[17:44:48.274] result() for MulticoreFuture ...
[17:44:48.274] result() for MulticoreFuture ... done
[17:44:48.274] result() for MulticoreFuture ...
[17:44:48.275] result() for MulticoreFuture ... done
[17:44:48.275] result() for MulticoreFuture ...
[17:44:48.275] result() for MulticoreFuture ... done
[17:44:48.275]  - Number of value chunks collected: 2
[17:44:48.275] Resolving 2 futures (chunks) ... DONE
[17:44:48.275] Reducing values from 2 chunks ...
[17:44:48.275]  - Number of values collected after concatenation: 2
[17:44:48.275]  - Number of values expected: 2
[17:44:48.276] Reducing values from 2 chunks ... DONE
[17:44:48.276] future_mapply() ... DONE
[17:44:48.276] future_mapply() ...
[17:44:48.284] Number of chunks: 2
[17:44:48.284] getGlobalsAndPackagesXApply() ...
[17:44:48.284]  - future.globals: TRUE
[17:44:48.284] getGlobalsAndPackages() ...
[17:44:48.284] Searching for globals...
[17:44:48.286] - globals found: [1] ‘FUN’
[17:44:48.286] Searching for globals ... DONE
[17:44:48.286] Resolving globals: FALSE
[17:44:48.287] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:48.287] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:48.287] - globals: [1] ‘FUN’
[17:44:48.288] 
[17:44:48.288] getGlobalsAndPackages() ... DONE
[17:44:48.288]  - globals found/used: [n=1] ‘FUN’
[17:44:48.288]  - needed namespaces: [n=0] 
[17:44:48.288] Finding globals ... DONE
[17:44:48.288] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.289] List of 2
[17:44:48.289]  $ ...future.FUN:function (x, y)  
[17:44:48.289]  $ MoreArgs     :List of 1
[17:44:48.289]   ..$ y: int [1:2] 3 4
[17:44:48.289]  - attr(*, "where")=List of 2
[17:44:48.289]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.289]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.289]  - attr(*, "resolved")= logi FALSE
[17:44:48.289]  - attr(*, "total_size")= num NA
[17:44:48.292] Packages to be attached in all futures: [n=0] 
[17:44:48.292] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.293] Number of futures (= number of chunks): 2
[17:44:48.293] Launching 2 futures (chunks) ...
[17:44:48.293] Chunk #1 of 2 ...
[17:44:48.293]  - Finding globals in '...' for chunk #1 ...
[17:44:48.293] getGlobalsAndPackages() ...
[17:44:48.293] Searching for globals...
[17:44:48.294] 
[17:44:48.294] Searching for globals ... DONE
[17:44:48.294] - globals: [0] <none>
[17:44:48.294] getGlobalsAndPackages() ... DONE
[17:44:48.294]    + additional globals found: [n=0] 
[17:44:48.294]    + additional namespaces needed: [n=0] 
[17:44:48.294]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.294]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.294]  - seeds: <none>
[17:44:48.294]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.295] getGlobalsAndPackages() ...
[17:44:48.295] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.295] Resolving globals: FALSE
[17:44:48.295] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:48.296] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:48.296] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.296] 
[17:44:48.296] getGlobalsAndPackages() ... DONE
[17:44:48.296] run() for ‘Future’ ...
[17:44:48.297] - state: ‘created’
[17:44:48.297] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.300] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.301]   - Field: ‘label’
[17:44:48.301]   - Field: ‘local’
[17:44:48.301]   - Field: ‘owner’
[17:44:48.301]   - Field: ‘envir’
[17:44:48.301]   - Field: ‘workers’
[17:44:48.301]   - Field: ‘packages’
[17:44:48.301]   - Field: ‘gc’
[17:44:48.301]   - Field: ‘job’
[17:44:48.301]   - Field: ‘conditions’
[17:44:48.301]   - Field: ‘expr’
[17:44:48.302]   - Field: ‘uuid’
[17:44:48.302]   - Field: ‘seed’
[17:44:48.302]   - Field: ‘version’
[17:44:48.302]   - Field: ‘result’
[17:44:48.302]   - Field: ‘asynchronous’
[17:44:48.302]   - Field: ‘calls’
[17:44:48.302]   - Field: ‘globals’
[17:44:48.302]   - Field: ‘stdout’
[17:44:48.302]   - Field: ‘earlySignal’
[17:44:48.302]   - Field: ‘lazy’
[17:44:48.302]   - Field: ‘state’
[17:44:48.303] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.303] - Launch lazy future ...
[17:44:48.303] Packages needed by the future expression (n = 0): <none>
[17:44:48.303] Packages needed by future strategies (n = 0): <none>
[17:44:48.304] {
[17:44:48.304]     {
[17:44:48.304]         {
[17:44:48.304]             ...future.startTime <- base::Sys.time()
[17:44:48.304]             {
[17:44:48.304]                 {
[17:44:48.304]                   {
[17:44:48.304]                     {
[17:44:48.304]                       base::local({
[17:44:48.304]                         has_future <- base::requireNamespace("future", 
[17:44:48.304]                           quietly = TRUE)
[17:44:48.304]                         if (has_future) {
[17:44:48.304]                           ns <- base::getNamespace("future")
[17:44:48.304]                           version <- ns[[".package"]][["version"]]
[17:44:48.304]                           if (is.null(version)) 
[17:44:48.304]                             version <- utils::packageVersion("future")
[17:44:48.304]                         }
[17:44:48.304]                         else {
[17:44:48.304]                           version <- NULL
[17:44:48.304]                         }
[17:44:48.304]                         if (!has_future || version < "1.8.0") {
[17:44:48.304]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.304]                             "", base::R.version$version.string), 
[17:44:48.304]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.304]                               "release", "version")], collapse = " "), 
[17:44:48.304]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.304]                             info)
[17:44:48.304]                           info <- base::paste(info, collapse = "; ")
[17:44:48.304]                           if (!has_future) {
[17:44:48.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.304]                               info)
[17:44:48.304]                           }
[17:44:48.304]                           else {
[17:44:48.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.304]                               info, version)
[17:44:48.304]                           }
[17:44:48.304]                           base::stop(msg)
[17:44:48.304]                         }
[17:44:48.304]                       })
[17:44:48.304]                     }
[17:44:48.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.304]                     base::options(mc.cores = 1L)
[17:44:48.304]                   }
[17:44:48.304]                   ...future.strategy.old <- future::plan("list")
[17:44:48.304]                   options(future.plan = NULL)
[17:44:48.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.304]                 }
[17:44:48.304]                 ...future.workdir <- getwd()
[17:44:48.304]             }
[17:44:48.304]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.304]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.304]         }
[17:44:48.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.304]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.304]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.304]             base::names(...future.oldOptions))
[17:44:48.304]     }
[17:44:48.304]     if (FALSE) {
[17:44:48.304]     }
[17:44:48.304]     else {
[17:44:48.304]         if (TRUE) {
[17:44:48.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.304]                 open = "w")
[17:44:48.304]         }
[17:44:48.304]         else {
[17:44:48.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.304]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.304]         }
[17:44:48.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.304]             base::sink(type = "output", split = FALSE)
[17:44:48.304]             base::close(...future.stdout)
[17:44:48.304]         }, add = TRUE)
[17:44:48.304]     }
[17:44:48.304]     ...future.frame <- base::sys.nframe()
[17:44:48.304]     ...future.conditions <- base::list()
[17:44:48.304]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.304]     if (FALSE) {
[17:44:48.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.304]     }
[17:44:48.304]     ...future.result <- base::tryCatch({
[17:44:48.304]         base::withCallingHandlers({
[17:44:48.304]             ...future.value <- base::withVisible(base::local({
[17:44:48.304]                 withCallingHandlers({
[17:44:48.304]                   {
[17:44:48.304]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.304]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.304]                       ...future.globals.maxSize)) {
[17:44:48.304]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.304]                       on.exit(options(oopts), add = TRUE)
[17:44:48.304]                     }
[17:44:48.304]                     {
[17:44:48.304]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.304]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.304]                         USE.NAMES = FALSE)
[17:44:48.304]                       do.call(mapply, args = args)
[17:44:48.304]                     }
[17:44:48.304]                   }
[17:44:48.304]                 }, immediateCondition = function(cond) {
[17:44:48.304]                   save_rds <- function (object, pathname, ...) 
[17:44:48.304]                   {
[17:44:48.304]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.304]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.304]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.304]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.304]                         fi_tmp[["mtime"]])
[17:44:48.304]                     }
[17:44:48.304]                     tryCatch({
[17:44:48.304]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.304]                     }, error = function(ex) {
[17:44:48.304]                       msg <- conditionMessage(ex)
[17:44:48.304]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.304]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.304]                         fi_tmp[["mtime"]], msg)
[17:44:48.304]                       ex$message <- msg
[17:44:48.304]                       stop(ex)
[17:44:48.304]                     })
[17:44:48.304]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.304]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.304]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.304]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.304]                       fi <- file.info(pathname)
[17:44:48.304]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.304]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.304]                         fi[["size"]], fi[["mtime"]])
[17:44:48.304]                       stop(msg)
[17:44:48.304]                     }
[17:44:48.304]                     invisible(pathname)
[17:44:48.304]                   }
[17:44:48.304]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.304]                     rootPath = tempdir()) 
[17:44:48.304]                   {
[17:44:48.304]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.304]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.304]                       tmpdir = path, fileext = ".rds")
[17:44:48.304]                     save_rds(obj, file)
[17:44:48.304]                   }
[17:44:48.304]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.304]                   {
[17:44:48.304]                     inherits <- base::inherits
[17:44:48.304]                     invokeRestart <- base::invokeRestart
[17:44:48.304]                     is.null <- base::is.null
[17:44:48.304]                     muffled <- FALSE
[17:44:48.304]                     if (inherits(cond, "message")) {
[17:44:48.304]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.304]                       if (muffled) 
[17:44:48.304]                         invokeRestart("muffleMessage")
[17:44:48.304]                     }
[17:44:48.304]                     else if (inherits(cond, "warning")) {
[17:44:48.304]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.304]                       if (muffled) 
[17:44:48.304]                         invokeRestart("muffleWarning")
[17:44:48.304]                     }
[17:44:48.304]                     else if (inherits(cond, "condition")) {
[17:44:48.304]                       if (!is.null(pattern)) {
[17:44:48.304]                         computeRestarts <- base::computeRestarts
[17:44:48.304]                         grepl <- base::grepl
[17:44:48.304]                         restarts <- computeRestarts(cond)
[17:44:48.304]                         for (restart in restarts) {
[17:44:48.304]                           name <- restart$name
[17:44:48.304]                           if (is.null(name)) 
[17:44:48.304]                             next
[17:44:48.304]                           if (!grepl(pattern, name)) 
[17:44:48.304]                             next
[17:44:48.304]                           invokeRestart(restart)
[17:44:48.304]                           muffled <- TRUE
[17:44:48.304]                           break
[17:44:48.304]                         }
[17:44:48.304]                       }
[17:44:48.304]                     }
[17:44:48.304]                     invisible(muffled)
[17:44:48.304]                   }
[17:44:48.304]                   muffleCondition(cond)
[17:44:48.304]                 })
[17:44:48.304]             }))
[17:44:48.304]             future::FutureResult(value = ...future.value$value, 
[17:44:48.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.304]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.304]                     ...future.globalenv.names))
[17:44:48.304]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.304]         }, condition = base::local({
[17:44:48.304]             c <- base::c
[17:44:48.304]             inherits <- base::inherits
[17:44:48.304]             invokeRestart <- base::invokeRestart
[17:44:48.304]             length <- base::length
[17:44:48.304]             list <- base::list
[17:44:48.304]             seq.int <- base::seq.int
[17:44:48.304]             signalCondition <- base::signalCondition
[17:44:48.304]             sys.calls <- base::sys.calls
[17:44:48.304]             `[[` <- base::`[[`
[17:44:48.304]             `+` <- base::`+`
[17:44:48.304]             `<<-` <- base::`<<-`
[17:44:48.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.304]                   3L)]
[17:44:48.304]             }
[17:44:48.304]             function(cond) {
[17:44:48.304]                 is_error <- inherits(cond, "error")
[17:44:48.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.304]                   NULL)
[17:44:48.304]                 if (is_error) {
[17:44:48.304]                   sessionInformation <- function() {
[17:44:48.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.304]                       search = base::search(), system = base::Sys.info())
[17:44:48.304]                   }
[17:44:48.304]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.304]                     cond$call), session = sessionInformation(), 
[17:44:48.304]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.304]                   signalCondition(cond)
[17:44:48.304]                 }
[17:44:48.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.304]                 "immediateCondition"))) {
[17:44:48.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.304]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.304]                   if (TRUE && !signal) {
[17:44:48.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.304]                     {
[17:44:48.304]                       inherits <- base::inherits
[17:44:48.304]                       invokeRestart <- base::invokeRestart
[17:44:48.304]                       is.null <- base::is.null
[17:44:48.304]                       muffled <- FALSE
[17:44:48.304]                       if (inherits(cond, "message")) {
[17:44:48.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.304]                         if (muffled) 
[17:44:48.304]                           invokeRestart("muffleMessage")
[17:44:48.304]                       }
[17:44:48.304]                       else if (inherits(cond, "warning")) {
[17:44:48.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.304]                         if (muffled) 
[17:44:48.304]                           invokeRestart("muffleWarning")
[17:44:48.304]                       }
[17:44:48.304]                       else if (inherits(cond, "condition")) {
[17:44:48.304]                         if (!is.null(pattern)) {
[17:44:48.304]                           computeRestarts <- base::computeRestarts
[17:44:48.304]                           grepl <- base::grepl
[17:44:48.304]                           restarts <- computeRestarts(cond)
[17:44:48.304]                           for (restart in restarts) {
[17:44:48.304]                             name <- restart$name
[17:44:48.304]                             if (is.null(name)) 
[17:44:48.304]                               next
[17:44:48.304]                             if (!grepl(pattern, name)) 
[17:44:48.304]                               next
[17:44:48.304]                             invokeRestart(restart)
[17:44:48.304]                             muffled <- TRUE
[17:44:48.304]                             break
[17:44:48.304]                           }
[17:44:48.304]                         }
[17:44:48.304]                       }
[17:44:48.304]                       invisible(muffled)
[17:44:48.304]                     }
[17:44:48.304]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.304]                   }
[17:44:48.304]                 }
[17:44:48.304]                 else {
[17:44:48.304]                   if (TRUE) {
[17:44:48.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.304]                     {
[17:44:48.304]                       inherits <- base::inherits
[17:44:48.304]                       invokeRestart <- base::invokeRestart
[17:44:48.304]                       is.null <- base::is.null
[17:44:48.304]                       muffled <- FALSE
[17:44:48.304]                       if (inherits(cond, "message")) {
[17:44:48.304]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.304]                         if (muffled) 
[17:44:48.304]                           invokeRestart("muffleMessage")
[17:44:48.304]                       }
[17:44:48.304]                       else if (inherits(cond, "warning")) {
[17:44:48.304]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.304]                         if (muffled) 
[17:44:48.304]                           invokeRestart("muffleWarning")
[17:44:48.304]                       }
[17:44:48.304]                       else if (inherits(cond, "condition")) {
[17:44:48.304]                         if (!is.null(pattern)) {
[17:44:48.304]                           computeRestarts <- base::computeRestarts
[17:44:48.304]                           grepl <- base::grepl
[17:44:48.304]                           restarts <- computeRestarts(cond)
[17:44:48.304]                           for (restart in restarts) {
[17:44:48.304]                             name <- restart$name
[17:44:48.304]                             if (is.null(name)) 
[17:44:48.304]                               next
[17:44:48.304]                             if (!grepl(pattern, name)) 
[17:44:48.304]                               next
[17:44:48.304]                             invokeRestart(restart)
[17:44:48.304]                             muffled <- TRUE
[17:44:48.304]                             break
[17:44:48.304]                           }
[17:44:48.304]                         }
[17:44:48.304]                       }
[17:44:48.304]                       invisible(muffled)
[17:44:48.304]                     }
[17:44:48.304]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.304]                   }
[17:44:48.304]                 }
[17:44:48.304]             }
[17:44:48.304]         }))
[17:44:48.304]     }, error = function(ex) {
[17:44:48.304]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.304]                 ...future.rng), started = ...future.startTime, 
[17:44:48.304]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.304]             version = "1.8"), class = "FutureResult")
[17:44:48.304]     }, finally = {
[17:44:48.304]         if (!identical(...future.workdir, getwd())) 
[17:44:48.304]             setwd(...future.workdir)
[17:44:48.304]         {
[17:44:48.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.304]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.304]             }
[17:44:48.304]             base::options(...future.oldOptions)
[17:44:48.304]             if (.Platform$OS.type == "windows") {
[17:44:48.304]                 old_names <- names(...future.oldEnvVars)
[17:44:48.304]                 envs <- base::Sys.getenv()
[17:44:48.304]                 names <- names(envs)
[17:44:48.304]                 common <- intersect(names, old_names)
[17:44:48.304]                 added <- setdiff(names, old_names)
[17:44:48.304]                 removed <- setdiff(old_names, names)
[17:44:48.304]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.304]                   envs[common]]
[17:44:48.304]                 NAMES <- toupper(changed)
[17:44:48.304]                 args <- list()
[17:44:48.304]                 for (kk in seq_along(NAMES)) {
[17:44:48.304]                   name <- changed[[kk]]
[17:44:48.304]                   NAME <- NAMES[[kk]]
[17:44:48.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.304]                     next
[17:44:48.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.304]                 }
[17:44:48.304]                 NAMES <- toupper(added)
[17:44:48.304]                 for (kk in seq_along(NAMES)) {
[17:44:48.304]                   name <- added[[kk]]
[17:44:48.304]                   NAME <- NAMES[[kk]]
[17:44:48.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.304]                     next
[17:44:48.304]                   args[[name]] <- ""
[17:44:48.304]                 }
[17:44:48.304]                 NAMES <- toupper(removed)
[17:44:48.304]                 for (kk in seq_along(NAMES)) {
[17:44:48.304]                   name <- removed[[kk]]
[17:44:48.304]                   NAME <- NAMES[[kk]]
[17:44:48.304]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.304]                     next
[17:44:48.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.304]                 }
[17:44:48.304]                 if (length(args) > 0) 
[17:44:48.304]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.304]             }
[17:44:48.304]             else {
[17:44:48.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.304]             }
[17:44:48.304]             {
[17:44:48.304]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.304]                   0L) {
[17:44:48.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.304]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.304]                   base::options(opts)
[17:44:48.304]                 }
[17:44:48.304]                 {
[17:44:48.304]                   {
[17:44:48.304]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.304]                     NULL
[17:44:48.304]                   }
[17:44:48.304]                   options(future.plan = NULL)
[17:44:48.304]                   if (is.na(NA_character_)) 
[17:44:48.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.304]                     .init = FALSE)
[17:44:48.304]                 }
[17:44:48.304]             }
[17:44:48.304]         }
[17:44:48.304]     })
[17:44:48.304]     if (TRUE) {
[17:44:48.304]         base::sink(type = "output", split = FALSE)
[17:44:48.304]         if (TRUE) {
[17:44:48.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.304]         }
[17:44:48.304]         else {
[17:44:48.304]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.304]         }
[17:44:48.304]         base::close(...future.stdout)
[17:44:48.304]         ...future.stdout <- NULL
[17:44:48.304]     }
[17:44:48.304]     ...future.result$conditions <- ...future.conditions
[17:44:48.304]     ...future.result$finished <- base::Sys.time()
[17:44:48.304]     ...future.result
[17:44:48.304] }
[17:44:48.306] assign_globals() ...
[17:44:48.306] List of 5
[17:44:48.306]  $ ...future.FUN            :function (x, y)  
[17:44:48.306]  $ MoreArgs                 :List of 1
[17:44:48.306]   ..$ y: int [1:2] 3 4
[17:44:48.306]  $ ...future.elements_ii    :List of 1
[17:44:48.306]   ..$ x:List of 1
[17:44:48.306]   .. ..$ : int 1
[17:44:48.306]  $ ...future.seeds_ii       : NULL
[17:44:48.306]  $ ...future.globals.maxSize: NULL
[17:44:48.306]  - attr(*, "where")=List of 5
[17:44:48.306]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.306]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.306]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.306]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.306]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.306]  - attr(*, "resolved")= logi FALSE
[17:44:48.306]  - attr(*, "total_size")= num 1816
[17:44:48.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.306]  - attr(*, "already-done")= logi TRUE
[17:44:48.314] - reassign environment for ‘...future.FUN’
[17:44:48.314] - copied ‘...future.FUN’ to environment
[17:44:48.314] - copied ‘MoreArgs’ to environment
[17:44:48.314] - copied ‘...future.elements_ii’ to environment
[17:44:48.314] - copied ‘...future.seeds_ii’ to environment
[17:44:48.314] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.315] assign_globals() ... done
[17:44:48.315] requestCore(): workers = 2
[17:44:48.317] MulticoreFuture started
[17:44:48.318] - Launch lazy future ... done
[17:44:48.318] plan(): Setting new future strategy stack:
[17:44:48.318] run() for ‘MulticoreFuture’ ... done
[17:44:48.319] Created future:
[17:44:48.319] List of future strategies:
[17:44:48.319] 1. sequential:
[17:44:48.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.319]    - tweaked: FALSE
[17:44:48.319]    - call: NULL
[17:44:48.321] plan(): nbrOfWorkers() = 1
[17:44:48.324] plan(): Setting new future strategy stack:
[17:44:48.324] List of future strategies:
[17:44:48.324] 1. multicore:
[17:44:48.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.324]    - tweaked: FALSE
[17:44:48.324]    - call: plan(strategy)
[17:44:48.331] plan(): nbrOfWorkers() = 2
[17:44:48.320] MulticoreFuture:
[17:44:48.320] Label: ‘future_.mapply-1’
[17:44:48.320] Expression:
[17:44:48.320] {
[17:44:48.320]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.320]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.320]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.320]         on.exit(options(oopts), add = TRUE)
[17:44:48.320]     }
[17:44:48.320]     {
[17:44:48.320]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.320]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.320]         do.call(mapply, args = args)
[17:44:48.320]     }
[17:44:48.320] }
[17:44:48.320] Lazy evaluation: FALSE
[17:44:48.320] Asynchronous evaluation: TRUE
[17:44:48.320] Local evaluation: TRUE
[17:44:48.320] Environment: R_GlobalEnv
[17:44:48.320] Capture standard output: TRUE
[17:44:48.320] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.320] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.320] Packages: <none>
[17:44:48.320] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.320] Resolved: TRUE
[17:44:48.320] Value: <not collected>
[17:44:48.320] Conditions captured: <none>
[17:44:48.320] Early signaling: FALSE
[17:44:48.320] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.320] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.332] Chunk #1 of 2 ... DONE
[17:44:48.333] Chunk #2 of 2 ...
[17:44:48.333]  - Finding globals in '...' for chunk #2 ...
[17:44:48.333] getGlobalsAndPackages() ...
[17:44:48.333] Searching for globals...
[17:44:48.334] 
[17:44:48.334] Searching for globals ... DONE
[17:44:48.334] - globals: [0] <none>
[17:44:48.335] getGlobalsAndPackages() ... DONE
[17:44:48.335]    + additional globals found: [n=0] 
[17:44:48.335]    + additional namespaces needed: [n=0] 
[17:44:48.335]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.335]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.336]  - seeds: <none>
[17:44:48.336]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.336] getGlobalsAndPackages() ...
[17:44:48.336] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.337] Resolving globals: FALSE
[17:44:48.338] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:48.338] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:48.339] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.339] 
[17:44:48.339] getGlobalsAndPackages() ... DONE
[17:44:48.340] run() for ‘Future’ ...
[17:44:48.340] - state: ‘created’
[17:44:48.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.345]   - Field: ‘label’
[17:44:48.346]   - Field: ‘local’
[17:44:48.346]   - Field: ‘owner’
[17:44:48.346]   - Field: ‘envir’
[17:44:48.346]   - Field: ‘workers’
[17:44:48.346]   - Field: ‘packages’
[17:44:48.346]   - Field: ‘gc’
[17:44:48.346]   - Field: ‘job’
[17:44:48.347]   - Field: ‘conditions’
[17:44:48.347]   - Field: ‘expr’
[17:44:48.347]   - Field: ‘uuid’
[17:44:48.347]   - Field: ‘seed’
[17:44:48.347]   - Field: ‘version’
[17:44:48.347]   - Field: ‘result’
[17:44:48.347]   - Field: ‘asynchronous’
[17:44:48.348]   - Field: ‘calls’
[17:44:48.348]   - Field: ‘globals’
[17:44:48.348]   - Field: ‘stdout’
[17:44:48.348]   - Field: ‘earlySignal’
[17:44:48.348]   - Field: ‘lazy’
[17:44:48.348]   - Field: ‘state’
[17:44:48.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.348] - Launch lazy future ...
[17:44:48.349] Packages needed by the future expression (n = 0): <none>
[17:44:48.349] Packages needed by future strategies (n = 0): <none>
[17:44:48.350] {
[17:44:48.350]     {
[17:44:48.350]         {
[17:44:48.350]             ...future.startTime <- base::Sys.time()
[17:44:48.350]             {
[17:44:48.350]                 {
[17:44:48.350]                   {
[17:44:48.350]                     {
[17:44:48.350]                       base::local({
[17:44:48.350]                         has_future <- base::requireNamespace("future", 
[17:44:48.350]                           quietly = TRUE)
[17:44:48.350]                         if (has_future) {
[17:44:48.350]                           ns <- base::getNamespace("future")
[17:44:48.350]                           version <- ns[[".package"]][["version"]]
[17:44:48.350]                           if (is.null(version)) 
[17:44:48.350]                             version <- utils::packageVersion("future")
[17:44:48.350]                         }
[17:44:48.350]                         else {
[17:44:48.350]                           version <- NULL
[17:44:48.350]                         }
[17:44:48.350]                         if (!has_future || version < "1.8.0") {
[17:44:48.350]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.350]                             "", base::R.version$version.string), 
[17:44:48.350]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.350]                               "release", "version")], collapse = " "), 
[17:44:48.350]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.350]                             info)
[17:44:48.350]                           info <- base::paste(info, collapse = "; ")
[17:44:48.350]                           if (!has_future) {
[17:44:48.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.350]                               info)
[17:44:48.350]                           }
[17:44:48.350]                           else {
[17:44:48.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.350]                               info, version)
[17:44:48.350]                           }
[17:44:48.350]                           base::stop(msg)
[17:44:48.350]                         }
[17:44:48.350]                       })
[17:44:48.350]                     }
[17:44:48.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.350]                     base::options(mc.cores = 1L)
[17:44:48.350]                   }
[17:44:48.350]                   ...future.strategy.old <- future::plan("list")
[17:44:48.350]                   options(future.plan = NULL)
[17:44:48.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.350]                 }
[17:44:48.350]                 ...future.workdir <- getwd()
[17:44:48.350]             }
[17:44:48.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.350]         }
[17:44:48.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.350]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.350]             base::names(...future.oldOptions))
[17:44:48.350]     }
[17:44:48.350]     if (FALSE) {
[17:44:48.350]     }
[17:44:48.350]     else {
[17:44:48.350]         if (TRUE) {
[17:44:48.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.350]                 open = "w")
[17:44:48.350]         }
[17:44:48.350]         else {
[17:44:48.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.350]         }
[17:44:48.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.350]             base::sink(type = "output", split = FALSE)
[17:44:48.350]             base::close(...future.stdout)
[17:44:48.350]         }, add = TRUE)
[17:44:48.350]     }
[17:44:48.350]     ...future.frame <- base::sys.nframe()
[17:44:48.350]     ...future.conditions <- base::list()
[17:44:48.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.350]     if (FALSE) {
[17:44:48.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.350]     }
[17:44:48.350]     ...future.result <- base::tryCatch({
[17:44:48.350]         base::withCallingHandlers({
[17:44:48.350]             ...future.value <- base::withVisible(base::local({
[17:44:48.350]                 withCallingHandlers({
[17:44:48.350]                   {
[17:44:48.350]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.350]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.350]                       ...future.globals.maxSize)) {
[17:44:48.350]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.350]                       on.exit(options(oopts), add = TRUE)
[17:44:48.350]                     }
[17:44:48.350]                     {
[17:44:48.350]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.350]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.350]                         USE.NAMES = FALSE)
[17:44:48.350]                       do.call(mapply, args = args)
[17:44:48.350]                     }
[17:44:48.350]                   }
[17:44:48.350]                 }, immediateCondition = function(cond) {
[17:44:48.350]                   save_rds <- function (object, pathname, ...) 
[17:44:48.350]                   {
[17:44:48.350]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.350]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.350]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.350]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.350]                         fi_tmp[["mtime"]])
[17:44:48.350]                     }
[17:44:48.350]                     tryCatch({
[17:44:48.350]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.350]                     }, error = function(ex) {
[17:44:48.350]                       msg <- conditionMessage(ex)
[17:44:48.350]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.350]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.350]                         fi_tmp[["mtime"]], msg)
[17:44:48.350]                       ex$message <- msg
[17:44:48.350]                       stop(ex)
[17:44:48.350]                     })
[17:44:48.350]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.350]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.350]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.350]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.350]                       fi <- file.info(pathname)
[17:44:48.350]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.350]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.350]                         fi[["size"]], fi[["mtime"]])
[17:44:48.350]                       stop(msg)
[17:44:48.350]                     }
[17:44:48.350]                     invisible(pathname)
[17:44:48.350]                   }
[17:44:48.350]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.350]                     rootPath = tempdir()) 
[17:44:48.350]                   {
[17:44:48.350]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.350]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.350]                       tmpdir = path, fileext = ".rds")
[17:44:48.350]                     save_rds(obj, file)
[17:44:48.350]                   }
[17:44:48.350]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.350]                   {
[17:44:48.350]                     inherits <- base::inherits
[17:44:48.350]                     invokeRestart <- base::invokeRestart
[17:44:48.350]                     is.null <- base::is.null
[17:44:48.350]                     muffled <- FALSE
[17:44:48.350]                     if (inherits(cond, "message")) {
[17:44:48.350]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.350]                       if (muffled) 
[17:44:48.350]                         invokeRestart("muffleMessage")
[17:44:48.350]                     }
[17:44:48.350]                     else if (inherits(cond, "warning")) {
[17:44:48.350]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.350]                       if (muffled) 
[17:44:48.350]                         invokeRestart("muffleWarning")
[17:44:48.350]                     }
[17:44:48.350]                     else if (inherits(cond, "condition")) {
[17:44:48.350]                       if (!is.null(pattern)) {
[17:44:48.350]                         computeRestarts <- base::computeRestarts
[17:44:48.350]                         grepl <- base::grepl
[17:44:48.350]                         restarts <- computeRestarts(cond)
[17:44:48.350]                         for (restart in restarts) {
[17:44:48.350]                           name <- restart$name
[17:44:48.350]                           if (is.null(name)) 
[17:44:48.350]                             next
[17:44:48.350]                           if (!grepl(pattern, name)) 
[17:44:48.350]                             next
[17:44:48.350]                           invokeRestart(restart)
[17:44:48.350]                           muffled <- TRUE
[17:44:48.350]                           break
[17:44:48.350]                         }
[17:44:48.350]                       }
[17:44:48.350]                     }
[17:44:48.350]                     invisible(muffled)
[17:44:48.350]                   }
[17:44:48.350]                   muffleCondition(cond)
[17:44:48.350]                 })
[17:44:48.350]             }))
[17:44:48.350]             future::FutureResult(value = ...future.value$value, 
[17:44:48.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.350]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.350]                     ...future.globalenv.names))
[17:44:48.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.350]         }, condition = base::local({
[17:44:48.350]             c <- base::c
[17:44:48.350]             inherits <- base::inherits
[17:44:48.350]             invokeRestart <- base::invokeRestart
[17:44:48.350]             length <- base::length
[17:44:48.350]             list <- base::list
[17:44:48.350]             seq.int <- base::seq.int
[17:44:48.350]             signalCondition <- base::signalCondition
[17:44:48.350]             sys.calls <- base::sys.calls
[17:44:48.350]             `[[` <- base::`[[`
[17:44:48.350]             `+` <- base::`+`
[17:44:48.350]             `<<-` <- base::`<<-`
[17:44:48.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.350]                   3L)]
[17:44:48.350]             }
[17:44:48.350]             function(cond) {
[17:44:48.350]                 is_error <- inherits(cond, "error")
[17:44:48.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.350]                   NULL)
[17:44:48.350]                 if (is_error) {
[17:44:48.350]                   sessionInformation <- function() {
[17:44:48.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.350]                       search = base::search(), system = base::Sys.info())
[17:44:48.350]                   }
[17:44:48.350]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.350]                     cond$call), session = sessionInformation(), 
[17:44:48.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.350]                   signalCondition(cond)
[17:44:48.350]                 }
[17:44:48.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.350]                 "immediateCondition"))) {
[17:44:48.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.350]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.350]                   if (TRUE && !signal) {
[17:44:48.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.350]                     {
[17:44:48.350]                       inherits <- base::inherits
[17:44:48.350]                       invokeRestart <- base::invokeRestart
[17:44:48.350]                       is.null <- base::is.null
[17:44:48.350]                       muffled <- FALSE
[17:44:48.350]                       if (inherits(cond, "message")) {
[17:44:48.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.350]                         if (muffled) 
[17:44:48.350]                           invokeRestart("muffleMessage")
[17:44:48.350]                       }
[17:44:48.350]                       else if (inherits(cond, "warning")) {
[17:44:48.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.350]                         if (muffled) 
[17:44:48.350]                           invokeRestart("muffleWarning")
[17:44:48.350]                       }
[17:44:48.350]                       else if (inherits(cond, "condition")) {
[17:44:48.350]                         if (!is.null(pattern)) {
[17:44:48.350]                           computeRestarts <- base::computeRestarts
[17:44:48.350]                           grepl <- base::grepl
[17:44:48.350]                           restarts <- computeRestarts(cond)
[17:44:48.350]                           for (restart in restarts) {
[17:44:48.350]                             name <- restart$name
[17:44:48.350]                             if (is.null(name)) 
[17:44:48.350]                               next
[17:44:48.350]                             if (!grepl(pattern, name)) 
[17:44:48.350]                               next
[17:44:48.350]                             invokeRestart(restart)
[17:44:48.350]                             muffled <- TRUE
[17:44:48.350]                             break
[17:44:48.350]                           }
[17:44:48.350]                         }
[17:44:48.350]                       }
[17:44:48.350]                       invisible(muffled)
[17:44:48.350]                     }
[17:44:48.350]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.350]                   }
[17:44:48.350]                 }
[17:44:48.350]                 else {
[17:44:48.350]                   if (TRUE) {
[17:44:48.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.350]                     {
[17:44:48.350]                       inherits <- base::inherits
[17:44:48.350]                       invokeRestart <- base::invokeRestart
[17:44:48.350]                       is.null <- base::is.null
[17:44:48.350]                       muffled <- FALSE
[17:44:48.350]                       if (inherits(cond, "message")) {
[17:44:48.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.350]                         if (muffled) 
[17:44:48.350]                           invokeRestart("muffleMessage")
[17:44:48.350]                       }
[17:44:48.350]                       else if (inherits(cond, "warning")) {
[17:44:48.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.350]                         if (muffled) 
[17:44:48.350]                           invokeRestart("muffleWarning")
[17:44:48.350]                       }
[17:44:48.350]                       else if (inherits(cond, "condition")) {
[17:44:48.350]                         if (!is.null(pattern)) {
[17:44:48.350]                           computeRestarts <- base::computeRestarts
[17:44:48.350]                           grepl <- base::grepl
[17:44:48.350]                           restarts <- computeRestarts(cond)
[17:44:48.350]                           for (restart in restarts) {
[17:44:48.350]                             name <- restart$name
[17:44:48.350]                             if (is.null(name)) 
[17:44:48.350]                               next
[17:44:48.350]                             if (!grepl(pattern, name)) 
[17:44:48.350]                               next
[17:44:48.350]                             invokeRestart(restart)
[17:44:48.350]                             muffled <- TRUE
[17:44:48.350]                             break
[17:44:48.350]                           }
[17:44:48.350]                         }
[17:44:48.350]                       }
[17:44:48.350]                       invisible(muffled)
[17:44:48.350]                     }
[17:44:48.350]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.350]                   }
[17:44:48.350]                 }
[17:44:48.350]             }
[17:44:48.350]         }))
[17:44:48.350]     }, error = function(ex) {
[17:44:48.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.350]                 ...future.rng), started = ...future.startTime, 
[17:44:48.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.350]             version = "1.8"), class = "FutureResult")
[17:44:48.350]     }, finally = {
[17:44:48.350]         if (!identical(...future.workdir, getwd())) 
[17:44:48.350]             setwd(...future.workdir)
[17:44:48.350]         {
[17:44:48.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.350]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.350]             }
[17:44:48.350]             base::options(...future.oldOptions)
[17:44:48.350]             if (.Platform$OS.type == "windows") {
[17:44:48.350]                 old_names <- names(...future.oldEnvVars)
[17:44:48.350]                 envs <- base::Sys.getenv()
[17:44:48.350]                 names <- names(envs)
[17:44:48.350]                 common <- intersect(names, old_names)
[17:44:48.350]                 added <- setdiff(names, old_names)
[17:44:48.350]                 removed <- setdiff(old_names, names)
[17:44:48.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.350]                   envs[common]]
[17:44:48.350]                 NAMES <- toupper(changed)
[17:44:48.350]                 args <- list()
[17:44:48.350]                 for (kk in seq_along(NAMES)) {
[17:44:48.350]                   name <- changed[[kk]]
[17:44:48.350]                   NAME <- NAMES[[kk]]
[17:44:48.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.350]                     next
[17:44:48.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.350]                 }
[17:44:48.350]                 NAMES <- toupper(added)
[17:44:48.350]                 for (kk in seq_along(NAMES)) {
[17:44:48.350]                   name <- added[[kk]]
[17:44:48.350]                   NAME <- NAMES[[kk]]
[17:44:48.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.350]                     next
[17:44:48.350]                   args[[name]] <- ""
[17:44:48.350]                 }
[17:44:48.350]                 NAMES <- toupper(removed)
[17:44:48.350]                 for (kk in seq_along(NAMES)) {
[17:44:48.350]                   name <- removed[[kk]]
[17:44:48.350]                   NAME <- NAMES[[kk]]
[17:44:48.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.350]                     next
[17:44:48.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.350]                 }
[17:44:48.350]                 if (length(args) > 0) 
[17:44:48.350]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.350]             }
[17:44:48.350]             else {
[17:44:48.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.350]             }
[17:44:48.350]             {
[17:44:48.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.350]                   0L) {
[17:44:48.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.350]                   base::options(opts)
[17:44:48.350]                 }
[17:44:48.350]                 {
[17:44:48.350]                   {
[17:44:48.350]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.350]                     NULL
[17:44:48.350]                   }
[17:44:48.350]                   options(future.plan = NULL)
[17:44:48.350]                   if (is.na(NA_character_)) 
[17:44:48.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.350]                     .init = FALSE)
[17:44:48.350]                 }
[17:44:48.350]             }
[17:44:48.350]         }
[17:44:48.350]     })
[17:44:48.350]     if (TRUE) {
[17:44:48.350]         base::sink(type = "output", split = FALSE)
[17:44:48.350]         if (TRUE) {
[17:44:48.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.350]         }
[17:44:48.350]         else {
[17:44:48.350]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.350]         }
[17:44:48.350]         base::close(...future.stdout)
[17:44:48.350]         ...future.stdout <- NULL
[17:44:48.350]     }
[17:44:48.350]     ...future.result$conditions <- ...future.conditions
[17:44:48.350]     ...future.result$finished <- base::Sys.time()
[17:44:48.350]     ...future.result
[17:44:48.350] }
[17:44:48.353] assign_globals() ...
[17:44:48.353] List of 5
[17:44:48.353]  $ ...future.FUN            :function (x, y)  
[17:44:48.353]  $ MoreArgs                 :List of 1
[17:44:48.353]   ..$ y: int [1:2] 3 4
[17:44:48.353]  $ ...future.elements_ii    :List of 1
[17:44:48.353]   ..$ x:List of 1
[17:44:48.353]   .. ..$ : int 2
[17:44:48.353]  $ ...future.seeds_ii       : NULL
[17:44:48.353]  $ ...future.globals.maxSize: NULL
[17:44:48.353]  - attr(*, "where")=List of 5
[17:44:48.353]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.353]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.353]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.353]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.353]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.353]  - attr(*, "resolved")= logi FALSE
[17:44:48.353]  - attr(*, "total_size")= num 1816
[17:44:48.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.353]  - attr(*, "already-done")= logi TRUE
[17:44:48.360] - reassign environment for ‘...future.FUN’
[17:44:48.360] - copied ‘...future.FUN’ to environment
[17:44:48.360] - copied ‘MoreArgs’ to environment
[17:44:48.360] - copied ‘...future.elements_ii’ to environment
[17:44:48.360] - copied ‘...future.seeds_ii’ to environment
[17:44:48.360] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.360] assign_globals() ... done
[17:44:48.361] requestCore(): workers = 2
[17:44:48.363] MulticoreFuture started
[17:44:48.363] - Launch lazy future ... done
[17:44:48.363] run() for ‘MulticoreFuture’ ... done
[17:44:48.364] plan(): Setting new future strategy stack:
[17:44:48.364] Created future:
[17:44:48.364] List of future strategies:
[17:44:48.364] 1. sequential:
[17:44:48.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.364]    - tweaked: FALSE
[17:44:48.364]    - call: NULL
[17:44:48.370] plan(): nbrOfWorkers() = 1
[17:44:48.372] plan(): Setting new future strategy stack:
[17:44:48.373] List of future strategies:
[17:44:48.373] 1. multicore:
[17:44:48.373]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.373]    - tweaked: FALSE
[17:44:48.373]    - call: plan(strategy)
[17:44:48.379] plan(): nbrOfWorkers() = 2
[17:44:48.368] MulticoreFuture:
[17:44:48.368] Label: ‘future_.mapply-2’
[17:44:48.368] Expression:
[17:44:48.368] {
[17:44:48.368]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.368]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.368]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.368]         on.exit(options(oopts), add = TRUE)
[17:44:48.368]     }
[17:44:48.368]     {
[17:44:48.368]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.368]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.368]         do.call(mapply, args = args)
[17:44:48.368]     }
[17:44:48.368] }
[17:44:48.368] Lazy evaluation: FALSE
[17:44:48.368] Asynchronous evaluation: TRUE
[17:44:48.368] Local evaluation: TRUE
[17:44:48.368] Environment: R_GlobalEnv
[17:44:48.368] Capture standard output: TRUE
[17:44:48.368] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.368] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.368] Packages: <none>
[17:44:48.368] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.368] Resolved: TRUE
[17:44:48.368] Value: <not collected>
[17:44:48.368] Conditions captured: <none>
[17:44:48.368] Early signaling: FALSE
[17:44:48.368] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.368] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.381] Chunk #2 of 2 ... DONE
[17:44:48.381] Launching 2 futures (chunks) ... DONE
[17:44:48.381] Resolving 2 futures (chunks) ...
[17:44:48.381] resolve() on list ...
[17:44:48.382]  recursive: 0
[17:44:48.382]  length: 2
[17:44:48.382] 
[17:44:48.382] Future #1
[17:44:48.383] result() for MulticoreFuture ...
[17:44:48.384] result() for MulticoreFuture ...
[17:44:48.384] result() for MulticoreFuture ... done
[17:44:48.384] result() for MulticoreFuture ... done
[17:44:48.384] result() for MulticoreFuture ...
[17:44:48.385] result() for MulticoreFuture ... done
[17:44:48.385] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.385] - nx: 2
[17:44:48.386] - relay: TRUE
[17:44:48.386] - stdout: TRUE
[17:44:48.386] - signal: TRUE
[17:44:48.386] - resignal: FALSE
[17:44:48.387] - force: TRUE
[17:44:48.387] - relayed: [n=2] FALSE, FALSE
[17:44:48.387] - queued futures: [n=2] FALSE, FALSE
[17:44:48.387]  - until=1
[17:44:48.388]  - relaying element #1
[17:44:48.388] result() for MulticoreFuture ...
[17:44:48.388] result() for MulticoreFuture ... done
[17:44:48.388] result() for MulticoreFuture ...
[17:44:48.389] result() for MulticoreFuture ... done
[17:44:48.389] result() for MulticoreFuture ...
[17:44:48.389] result() for MulticoreFuture ... done
[17:44:48.389] result() for MulticoreFuture ...
[17:44:48.390] result() for MulticoreFuture ... done
[17:44:48.390] - relayed: [n=2] TRUE, FALSE
[17:44:48.390] - queued futures: [n=2] TRUE, FALSE
[17:44:48.390] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.391]  length: 1 (resolved future 1)
[17:44:48.391] Future #2
[17:44:48.391] result() for MulticoreFuture ...
[17:44:48.392] result() for MulticoreFuture ...
[17:44:48.393] result() for MulticoreFuture ... done
[17:44:48.393] result() for MulticoreFuture ... done
[17:44:48.393] result() for MulticoreFuture ...
[17:44:48.393] result() for MulticoreFuture ... done
[17:44:48.393] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.393] - nx: 2
[17:44:48.394] - relay: TRUE
[17:44:48.394] - stdout: TRUE
[17:44:48.394] - signal: TRUE
[17:44:48.394] - resignal: FALSE
[17:44:48.394] - force: TRUE
[17:44:48.394] - relayed: [n=2] TRUE, FALSE
[17:44:48.394] - queued futures: [n=2] TRUE, FALSE
[17:44:48.394]  - until=2
[17:44:48.395]  - relaying element #2
[17:44:48.395] result() for MulticoreFuture ...
[17:44:48.395] result() for MulticoreFuture ... done
[17:44:48.395] result() for MulticoreFuture ...
[17:44:48.395] result() for MulticoreFuture ... done
[17:44:48.395] result() for MulticoreFuture ...
[17:44:48.395] result() for MulticoreFuture ... done
[17:44:48.395] result() for MulticoreFuture ...
[17:44:48.395] result() for MulticoreFuture ... done
[17:44:48.396] - relayed: [n=2] TRUE, TRUE
[17:44:48.396] - queued futures: [n=2] TRUE, TRUE
[17:44:48.396] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.396]  length: 0 (resolved future 2)
[17:44:48.396] Relaying remaining futures
[17:44:48.396] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.396] - nx: 2
[17:44:48.396] - relay: TRUE
[17:44:48.396] - stdout: TRUE
[17:44:48.397] - signal: TRUE
[17:44:48.397] - resignal: FALSE
[17:44:48.397] - force: TRUE
[17:44:48.397] - relayed: [n=2] TRUE, TRUE
[17:44:48.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.397] - relayed: [n=2] TRUE, TRUE
[17:44:48.397] - queued futures: [n=2] TRUE, TRUE
[17:44:48.397] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.397] resolve() on list ... DONE
[17:44:48.398] result() for MulticoreFuture ...
[17:44:48.398] result() for MulticoreFuture ... done
[17:44:48.398] result() for MulticoreFuture ...
[17:44:48.398] result() for MulticoreFuture ... done
[17:44:48.398] result() for MulticoreFuture ...
[17:44:48.398] result() for MulticoreFuture ... done
[17:44:48.398] result() for MulticoreFuture ...
[17:44:48.398] result() for MulticoreFuture ... done
[17:44:48.398]  - Number of value chunks collected: 2
[17:44:48.399] Resolving 2 futures (chunks) ... DONE
[17:44:48.399] Reducing values from 2 chunks ...
[17:44:48.399]  - Number of values collected after concatenation: 2
[17:44:48.399]  - Number of values expected: 2
[17:44:48.399] Reducing values from 2 chunks ... DONE
[17:44:48.399] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:44:48.399] future_mapply() ...
[17:44:48.404] Number of chunks: 2
[17:44:48.404] getGlobalsAndPackagesXApply() ...
[17:44:48.404]  - future.globals: TRUE
[17:44:48.404] getGlobalsAndPackages() ...
[17:44:48.404] Searching for globals...
[17:44:48.405] - globals found: [1] ‘FUN’
[17:44:48.405] Searching for globals ... DONE
[17:44:48.405] Resolving globals: FALSE
[17:44:48.405] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:48.406] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:48.406] - globals: [1] ‘FUN’
[17:44:48.406] 
[17:44:48.406] getGlobalsAndPackages() ... DONE
[17:44:48.406]  - globals found/used: [n=1] ‘FUN’
[17:44:48.406]  - needed namespaces: [n=0] 
[17:44:48.406] Finding globals ... DONE
[17:44:48.406] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.407] List of 2
[17:44:48.407]  $ ...future.FUN:function (x, ...)  
[17:44:48.407]  $ MoreArgs     : NULL
[17:44:48.407]  - attr(*, "where")=List of 2
[17:44:48.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.407]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.407]  - attr(*, "resolved")= logi FALSE
[17:44:48.407]  - attr(*, "total_size")= num NA
[17:44:48.409] Packages to be attached in all futures: [n=0] 
[17:44:48.409] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.410] Number of futures (= number of chunks): 2
[17:44:48.410] Launching 2 futures (chunks) ...
[17:44:48.410] Chunk #1 of 2 ...
[17:44:48.410]  - Finding globals in '...' for chunk #1 ...
[17:44:48.410] getGlobalsAndPackages() ...
[17:44:48.410] Searching for globals...
[17:44:48.411] 
[17:44:48.411] Searching for globals ... DONE
[17:44:48.411] - globals: [0] <none>
[17:44:48.411] getGlobalsAndPackages() ... DONE
[17:44:48.411]    + additional globals found: [n=0] 
[17:44:48.414]    + additional namespaces needed: [n=0] 
[17:44:48.414]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.414]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.414]  - seeds: <none>
[17:44:48.414]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.414] getGlobalsAndPackages() ...
[17:44:48.414] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.415] Resolving globals: FALSE
[17:44:48.415] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:48.416] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.416] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.416] 
[17:44:48.416] getGlobalsAndPackages() ... DONE
[17:44:48.416] run() for ‘Future’ ...
[17:44:48.417] - state: ‘created’
[17:44:48.417] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.421]   - Field: ‘label’
[17:44:48.421]   - Field: ‘local’
[17:44:48.421]   - Field: ‘owner’
[17:44:48.421]   - Field: ‘envir’
[17:44:48.422]   - Field: ‘workers’
[17:44:48.422]   - Field: ‘packages’
[17:44:48.422]   - Field: ‘gc’
[17:44:48.422]   - Field: ‘job’
[17:44:48.422]   - Field: ‘conditions’
[17:44:48.422]   - Field: ‘expr’
[17:44:48.422]   - Field: ‘uuid’
[17:44:48.422]   - Field: ‘seed’
[17:44:48.423]   - Field: ‘version’
[17:44:48.423]   - Field: ‘result’
[17:44:48.423]   - Field: ‘asynchronous’
[17:44:48.423]   - Field: ‘calls’
[17:44:48.423]   - Field: ‘globals’
[17:44:48.423]   - Field: ‘stdout’
[17:44:48.423]   - Field: ‘earlySignal’
[17:44:48.423]   - Field: ‘lazy’
[17:44:48.423]   - Field: ‘state’
[17:44:48.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.424] - Launch lazy future ...
[17:44:48.424] Packages needed by the future expression (n = 0): <none>
[17:44:48.424] Packages needed by future strategies (n = 0): <none>
[17:44:48.425] {
[17:44:48.425]     {
[17:44:48.425]         {
[17:44:48.425]             ...future.startTime <- base::Sys.time()
[17:44:48.425]             {
[17:44:48.425]                 {
[17:44:48.425]                   {
[17:44:48.425]                     {
[17:44:48.425]                       base::local({
[17:44:48.425]                         has_future <- base::requireNamespace("future", 
[17:44:48.425]                           quietly = TRUE)
[17:44:48.425]                         if (has_future) {
[17:44:48.425]                           ns <- base::getNamespace("future")
[17:44:48.425]                           version <- ns[[".package"]][["version"]]
[17:44:48.425]                           if (is.null(version)) 
[17:44:48.425]                             version <- utils::packageVersion("future")
[17:44:48.425]                         }
[17:44:48.425]                         else {
[17:44:48.425]                           version <- NULL
[17:44:48.425]                         }
[17:44:48.425]                         if (!has_future || version < "1.8.0") {
[17:44:48.425]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.425]                             "", base::R.version$version.string), 
[17:44:48.425]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.425]                               "release", "version")], collapse = " "), 
[17:44:48.425]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.425]                             info)
[17:44:48.425]                           info <- base::paste(info, collapse = "; ")
[17:44:48.425]                           if (!has_future) {
[17:44:48.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.425]                               info)
[17:44:48.425]                           }
[17:44:48.425]                           else {
[17:44:48.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.425]                               info, version)
[17:44:48.425]                           }
[17:44:48.425]                           base::stop(msg)
[17:44:48.425]                         }
[17:44:48.425]                       })
[17:44:48.425]                     }
[17:44:48.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.425]                     base::options(mc.cores = 1L)
[17:44:48.425]                   }
[17:44:48.425]                   ...future.strategy.old <- future::plan("list")
[17:44:48.425]                   options(future.plan = NULL)
[17:44:48.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.425]                 }
[17:44:48.425]                 ...future.workdir <- getwd()
[17:44:48.425]             }
[17:44:48.425]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.425]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.425]         }
[17:44:48.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.425]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.425]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.425]             base::names(...future.oldOptions))
[17:44:48.425]     }
[17:44:48.425]     if (FALSE) {
[17:44:48.425]     }
[17:44:48.425]     else {
[17:44:48.425]         if (TRUE) {
[17:44:48.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.425]                 open = "w")
[17:44:48.425]         }
[17:44:48.425]         else {
[17:44:48.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.425]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.425]         }
[17:44:48.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.425]             base::sink(type = "output", split = FALSE)
[17:44:48.425]             base::close(...future.stdout)
[17:44:48.425]         }, add = TRUE)
[17:44:48.425]     }
[17:44:48.425]     ...future.frame <- base::sys.nframe()
[17:44:48.425]     ...future.conditions <- base::list()
[17:44:48.425]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.425]     if (FALSE) {
[17:44:48.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.425]     }
[17:44:48.425]     ...future.result <- base::tryCatch({
[17:44:48.425]         base::withCallingHandlers({
[17:44:48.425]             ...future.value <- base::withVisible(base::local({
[17:44:48.425]                 withCallingHandlers({
[17:44:48.425]                   {
[17:44:48.425]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.425]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.425]                       ...future.globals.maxSize)) {
[17:44:48.425]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.425]                       on.exit(options(oopts), add = TRUE)
[17:44:48.425]                     }
[17:44:48.425]                     {
[17:44:48.425]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.425]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.425]                         USE.NAMES = FALSE)
[17:44:48.425]                       do.call(mapply, args = args)
[17:44:48.425]                     }
[17:44:48.425]                   }
[17:44:48.425]                 }, immediateCondition = function(cond) {
[17:44:48.425]                   save_rds <- function (object, pathname, ...) 
[17:44:48.425]                   {
[17:44:48.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.425]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.425]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.425]                         fi_tmp[["mtime"]])
[17:44:48.425]                     }
[17:44:48.425]                     tryCatch({
[17:44:48.425]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.425]                     }, error = function(ex) {
[17:44:48.425]                       msg <- conditionMessage(ex)
[17:44:48.425]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.425]                         fi_tmp[["mtime"]], msg)
[17:44:48.425]                       ex$message <- msg
[17:44:48.425]                       stop(ex)
[17:44:48.425]                     })
[17:44:48.425]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.425]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.425]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.425]                       fi <- file.info(pathname)
[17:44:48.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.425]                         fi[["size"]], fi[["mtime"]])
[17:44:48.425]                       stop(msg)
[17:44:48.425]                     }
[17:44:48.425]                     invisible(pathname)
[17:44:48.425]                   }
[17:44:48.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.425]                     rootPath = tempdir()) 
[17:44:48.425]                   {
[17:44:48.425]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.425]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.425]                       tmpdir = path, fileext = ".rds")
[17:44:48.425]                     save_rds(obj, file)
[17:44:48.425]                   }
[17:44:48.425]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.425]                   {
[17:44:48.425]                     inherits <- base::inherits
[17:44:48.425]                     invokeRestart <- base::invokeRestart
[17:44:48.425]                     is.null <- base::is.null
[17:44:48.425]                     muffled <- FALSE
[17:44:48.425]                     if (inherits(cond, "message")) {
[17:44:48.425]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.425]                       if (muffled) 
[17:44:48.425]                         invokeRestart("muffleMessage")
[17:44:48.425]                     }
[17:44:48.425]                     else if (inherits(cond, "warning")) {
[17:44:48.425]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.425]                       if (muffled) 
[17:44:48.425]                         invokeRestart("muffleWarning")
[17:44:48.425]                     }
[17:44:48.425]                     else if (inherits(cond, "condition")) {
[17:44:48.425]                       if (!is.null(pattern)) {
[17:44:48.425]                         computeRestarts <- base::computeRestarts
[17:44:48.425]                         grepl <- base::grepl
[17:44:48.425]                         restarts <- computeRestarts(cond)
[17:44:48.425]                         for (restart in restarts) {
[17:44:48.425]                           name <- restart$name
[17:44:48.425]                           if (is.null(name)) 
[17:44:48.425]                             next
[17:44:48.425]                           if (!grepl(pattern, name)) 
[17:44:48.425]                             next
[17:44:48.425]                           invokeRestart(restart)
[17:44:48.425]                           muffled <- TRUE
[17:44:48.425]                           break
[17:44:48.425]                         }
[17:44:48.425]                       }
[17:44:48.425]                     }
[17:44:48.425]                     invisible(muffled)
[17:44:48.425]                   }
[17:44:48.425]                   muffleCondition(cond)
[17:44:48.425]                 })
[17:44:48.425]             }))
[17:44:48.425]             future::FutureResult(value = ...future.value$value, 
[17:44:48.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.425]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.425]                     ...future.globalenv.names))
[17:44:48.425]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.425]         }, condition = base::local({
[17:44:48.425]             c <- base::c
[17:44:48.425]             inherits <- base::inherits
[17:44:48.425]             invokeRestart <- base::invokeRestart
[17:44:48.425]             length <- base::length
[17:44:48.425]             list <- base::list
[17:44:48.425]             seq.int <- base::seq.int
[17:44:48.425]             signalCondition <- base::signalCondition
[17:44:48.425]             sys.calls <- base::sys.calls
[17:44:48.425]             `[[` <- base::`[[`
[17:44:48.425]             `+` <- base::`+`
[17:44:48.425]             `<<-` <- base::`<<-`
[17:44:48.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.425]                   3L)]
[17:44:48.425]             }
[17:44:48.425]             function(cond) {
[17:44:48.425]                 is_error <- inherits(cond, "error")
[17:44:48.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.425]                   NULL)
[17:44:48.425]                 if (is_error) {
[17:44:48.425]                   sessionInformation <- function() {
[17:44:48.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.425]                       search = base::search(), system = base::Sys.info())
[17:44:48.425]                   }
[17:44:48.425]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.425]                     cond$call), session = sessionInformation(), 
[17:44:48.425]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.425]                   signalCondition(cond)
[17:44:48.425]                 }
[17:44:48.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.425]                 "immediateCondition"))) {
[17:44:48.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.425]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.425]                   if (TRUE && !signal) {
[17:44:48.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.425]                     {
[17:44:48.425]                       inherits <- base::inherits
[17:44:48.425]                       invokeRestart <- base::invokeRestart
[17:44:48.425]                       is.null <- base::is.null
[17:44:48.425]                       muffled <- FALSE
[17:44:48.425]                       if (inherits(cond, "message")) {
[17:44:48.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.425]                         if (muffled) 
[17:44:48.425]                           invokeRestart("muffleMessage")
[17:44:48.425]                       }
[17:44:48.425]                       else if (inherits(cond, "warning")) {
[17:44:48.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.425]                         if (muffled) 
[17:44:48.425]                           invokeRestart("muffleWarning")
[17:44:48.425]                       }
[17:44:48.425]                       else if (inherits(cond, "condition")) {
[17:44:48.425]                         if (!is.null(pattern)) {
[17:44:48.425]                           computeRestarts <- base::computeRestarts
[17:44:48.425]                           grepl <- base::grepl
[17:44:48.425]                           restarts <- computeRestarts(cond)
[17:44:48.425]                           for (restart in restarts) {
[17:44:48.425]                             name <- restart$name
[17:44:48.425]                             if (is.null(name)) 
[17:44:48.425]                               next
[17:44:48.425]                             if (!grepl(pattern, name)) 
[17:44:48.425]                               next
[17:44:48.425]                             invokeRestart(restart)
[17:44:48.425]                             muffled <- TRUE
[17:44:48.425]                             break
[17:44:48.425]                           }
[17:44:48.425]                         }
[17:44:48.425]                       }
[17:44:48.425]                       invisible(muffled)
[17:44:48.425]                     }
[17:44:48.425]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.425]                   }
[17:44:48.425]                 }
[17:44:48.425]                 else {
[17:44:48.425]                   if (TRUE) {
[17:44:48.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.425]                     {
[17:44:48.425]                       inherits <- base::inherits
[17:44:48.425]                       invokeRestart <- base::invokeRestart
[17:44:48.425]                       is.null <- base::is.null
[17:44:48.425]                       muffled <- FALSE
[17:44:48.425]                       if (inherits(cond, "message")) {
[17:44:48.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.425]                         if (muffled) 
[17:44:48.425]                           invokeRestart("muffleMessage")
[17:44:48.425]                       }
[17:44:48.425]                       else if (inherits(cond, "warning")) {
[17:44:48.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.425]                         if (muffled) 
[17:44:48.425]                           invokeRestart("muffleWarning")
[17:44:48.425]                       }
[17:44:48.425]                       else if (inherits(cond, "condition")) {
[17:44:48.425]                         if (!is.null(pattern)) {
[17:44:48.425]                           computeRestarts <- base::computeRestarts
[17:44:48.425]                           grepl <- base::grepl
[17:44:48.425]                           restarts <- computeRestarts(cond)
[17:44:48.425]                           for (restart in restarts) {
[17:44:48.425]                             name <- restart$name
[17:44:48.425]                             if (is.null(name)) 
[17:44:48.425]                               next
[17:44:48.425]                             if (!grepl(pattern, name)) 
[17:44:48.425]                               next
[17:44:48.425]                             invokeRestart(restart)
[17:44:48.425]                             muffled <- TRUE
[17:44:48.425]                             break
[17:44:48.425]                           }
[17:44:48.425]                         }
[17:44:48.425]                       }
[17:44:48.425]                       invisible(muffled)
[17:44:48.425]                     }
[17:44:48.425]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.425]                   }
[17:44:48.425]                 }
[17:44:48.425]             }
[17:44:48.425]         }))
[17:44:48.425]     }, error = function(ex) {
[17:44:48.425]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.425]                 ...future.rng), started = ...future.startTime, 
[17:44:48.425]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.425]             version = "1.8"), class = "FutureResult")
[17:44:48.425]     }, finally = {
[17:44:48.425]         if (!identical(...future.workdir, getwd())) 
[17:44:48.425]             setwd(...future.workdir)
[17:44:48.425]         {
[17:44:48.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.425]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.425]             }
[17:44:48.425]             base::options(...future.oldOptions)
[17:44:48.425]             if (.Platform$OS.type == "windows") {
[17:44:48.425]                 old_names <- names(...future.oldEnvVars)
[17:44:48.425]                 envs <- base::Sys.getenv()
[17:44:48.425]                 names <- names(envs)
[17:44:48.425]                 common <- intersect(names, old_names)
[17:44:48.425]                 added <- setdiff(names, old_names)
[17:44:48.425]                 removed <- setdiff(old_names, names)
[17:44:48.425]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.425]                   envs[common]]
[17:44:48.425]                 NAMES <- toupper(changed)
[17:44:48.425]                 args <- list()
[17:44:48.425]                 for (kk in seq_along(NAMES)) {
[17:44:48.425]                   name <- changed[[kk]]
[17:44:48.425]                   NAME <- NAMES[[kk]]
[17:44:48.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.425]                     next
[17:44:48.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.425]                 }
[17:44:48.425]                 NAMES <- toupper(added)
[17:44:48.425]                 for (kk in seq_along(NAMES)) {
[17:44:48.425]                   name <- added[[kk]]
[17:44:48.425]                   NAME <- NAMES[[kk]]
[17:44:48.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.425]                     next
[17:44:48.425]                   args[[name]] <- ""
[17:44:48.425]                 }
[17:44:48.425]                 NAMES <- toupper(removed)
[17:44:48.425]                 for (kk in seq_along(NAMES)) {
[17:44:48.425]                   name <- removed[[kk]]
[17:44:48.425]                   NAME <- NAMES[[kk]]
[17:44:48.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.425]                     next
[17:44:48.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.425]                 }
[17:44:48.425]                 if (length(args) > 0) 
[17:44:48.425]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.425]             }
[17:44:48.425]             else {
[17:44:48.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.425]             }
[17:44:48.425]             {
[17:44:48.425]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.425]                   0L) {
[17:44:48.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.425]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.425]                   base::options(opts)
[17:44:48.425]                 }
[17:44:48.425]                 {
[17:44:48.425]                   {
[17:44:48.425]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.425]                     NULL
[17:44:48.425]                   }
[17:44:48.425]                   options(future.plan = NULL)
[17:44:48.425]                   if (is.na(NA_character_)) 
[17:44:48.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.425]                     .init = FALSE)
[17:44:48.425]                 }
[17:44:48.425]             }
[17:44:48.425]         }
[17:44:48.425]     })
[17:44:48.425]     if (TRUE) {
[17:44:48.425]         base::sink(type = "output", split = FALSE)
[17:44:48.425]         if (TRUE) {
[17:44:48.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.425]         }
[17:44:48.425]         else {
[17:44:48.425]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.425]         }
[17:44:48.425]         base::close(...future.stdout)
[17:44:48.425]         ...future.stdout <- NULL
[17:44:48.425]     }
[17:44:48.425]     ...future.result$conditions <- ...future.conditions
[17:44:48.425]     ...future.result$finished <- base::Sys.time()
[17:44:48.425]     ...future.result
[17:44:48.425] }
[17:44:48.427] assign_globals() ...
[17:44:48.427] List of 5
[17:44:48.427]  $ ...future.FUN            :function (x, ...)  
[17:44:48.427]  $ MoreArgs                 : NULL
[17:44:48.427]  $ ...future.elements_ii    :List of 2
[17:44:48.427]   ..$ :List of 2
[17:44:48.427]   .. ..$ : int 1
[17:44:48.427]   .. ..$ : int 2
[17:44:48.427]   ..$ :List of 2
[17:44:48.427]   .. ..$ : int 2
[17:44:48.427]   .. ..$ : int 1
[17:44:48.427]  $ ...future.seeds_ii       : NULL
[17:44:48.427]  $ ...future.globals.maxSize: NULL
[17:44:48.427]  - attr(*, "where")=List of 5
[17:44:48.427]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.427]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.427]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.427]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.427]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.427]  - attr(*, "resolved")= logi FALSE
[17:44:48.427]  - attr(*, "total_size")= num 280
[17:44:48.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.427]  - attr(*, "already-done")= logi TRUE
[17:44:48.433] - copied ‘...future.FUN’ to environment
[17:44:48.433] - copied ‘MoreArgs’ to environment
[17:44:48.433] - copied ‘...future.elements_ii’ to environment
[17:44:48.433] - copied ‘...future.seeds_ii’ to environment
[17:44:48.433] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.433] assign_globals() ... done
[17:44:48.433] requestCore(): workers = 2
[17:44:48.436] MulticoreFuture started
[17:44:48.436] - Launch lazy future ... done
[17:44:48.436] run() for ‘MulticoreFuture’ ... done
[17:44:48.436] Created future:
[17:44:48.437] plan(): Setting new future strategy stack:
[17:44:48.437] List of future strategies:
[17:44:48.437] 1. sequential:
[17:44:48.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.437]    - tweaked: FALSE
[17:44:48.437]    - call: NULL
[17:44:48.438] plan(): nbrOfWorkers() = 1
[17:44:48.440] plan(): Setting new future strategy stack:
[17:44:48.440] List of future strategies:
[17:44:48.440] 1. multicore:
[17:44:48.440]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.440]    - tweaked: FALSE
[17:44:48.440]    - call: plan(strategy)
[17:44:48.445] plan(): nbrOfWorkers() = 2
[17:44:48.437] MulticoreFuture:
[17:44:48.437] Label: ‘future_mapply-1’
[17:44:48.437] Expression:
[17:44:48.437] {
[17:44:48.437]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.437]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.437]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.437]         on.exit(options(oopts), add = TRUE)
[17:44:48.437]     }
[17:44:48.437]     {
[17:44:48.437]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.437]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.437]         do.call(mapply, args = args)
[17:44:48.437]     }
[17:44:48.437] }
[17:44:48.437] Lazy evaluation: FALSE
[17:44:48.437] Asynchronous evaluation: TRUE
[17:44:48.437] Local evaluation: TRUE
[17:44:48.437] Environment: R_GlobalEnv
[17:44:48.437] Capture standard output: TRUE
[17:44:48.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.437] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.437] Packages: <none>
[17:44:48.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.437] Resolved: TRUE
[17:44:48.437] Value: <not collected>
[17:44:48.437] Conditions captured: <none>
[17:44:48.437] Early signaling: FALSE
[17:44:48.437] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.437] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.446] Chunk #1 of 2 ... DONE
[17:44:48.446] Chunk #2 of 2 ...
[17:44:48.447]  - Finding globals in '...' for chunk #2 ...
[17:44:48.447] getGlobalsAndPackages() ...
[17:44:48.447] Searching for globals...
[17:44:48.448] 
[17:44:48.448] Searching for globals ... DONE
[17:44:48.448] - globals: [0] <none>
[17:44:48.448] getGlobalsAndPackages() ... DONE
[17:44:48.448]    + additional globals found: [n=0] 
[17:44:48.448]    + additional namespaces needed: [n=0] 
[17:44:48.448]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.448]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.449]  - seeds: <none>
[17:44:48.449]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.449] getGlobalsAndPackages() ...
[17:44:48.449] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.449] Resolving globals: FALSE
[17:44:48.450] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:48.451] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.451] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.451] 
[17:44:48.452] getGlobalsAndPackages() ... DONE
[17:44:48.452] run() for ‘Future’ ...
[17:44:48.452] - state: ‘created’
[17:44:48.456] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.463] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.464]   - Field: ‘label’
[17:44:48.464]   - Field: ‘local’
[17:44:48.465]   - Field: ‘owner’
[17:44:48.465]   - Field: ‘envir’
[17:44:48.465]   - Field: ‘workers’
[17:44:48.465]   - Field: ‘packages’
[17:44:48.466]   - Field: ‘gc’
[17:44:48.466]   - Field: ‘job’
[17:44:48.466]   - Field: ‘conditions’
[17:44:48.466]   - Field: ‘expr’
[17:44:48.466]   - Field: ‘uuid’
[17:44:48.467]   - Field: ‘seed’
[17:44:48.467]   - Field: ‘version’
[17:44:48.467]   - Field: ‘result’
[17:44:48.467]   - Field: ‘asynchronous’
[17:44:48.468]   - Field: ‘calls’
[17:44:48.468]   - Field: ‘globals’
[17:44:48.468]   - Field: ‘stdout’
[17:44:48.468]   - Field: ‘earlySignal’
[17:44:48.468]   - Field: ‘lazy’
[17:44:48.468]   - Field: ‘state’
[17:44:48.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.469] - Launch lazy future ...
[17:44:48.469] Packages needed by the future expression (n = 0): <none>
[17:44:48.470] Packages needed by future strategies (n = 0): <none>
[17:44:48.470] {
[17:44:48.470]     {
[17:44:48.470]         {
[17:44:48.470]             ...future.startTime <- base::Sys.time()
[17:44:48.470]             {
[17:44:48.470]                 {
[17:44:48.470]                   {
[17:44:48.470]                     {
[17:44:48.470]                       base::local({
[17:44:48.470]                         has_future <- base::requireNamespace("future", 
[17:44:48.470]                           quietly = TRUE)
[17:44:48.470]                         if (has_future) {
[17:44:48.470]                           ns <- base::getNamespace("future")
[17:44:48.470]                           version <- ns[[".package"]][["version"]]
[17:44:48.470]                           if (is.null(version)) 
[17:44:48.470]                             version <- utils::packageVersion("future")
[17:44:48.470]                         }
[17:44:48.470]                         else {
[17:44:48.470]                           version <- NULL
[17:44:48.470]                         }
[17:44:48.470]                         if (!has_future || version < "1.8.0") {
[17:44:48.470]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.470]                             "", base::R.version$version.string), 
[17:44:48.470]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.470]                               "release", "version")], collapse = " "), 
[17:44:48.470]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.470]                             info)
[17:44:48.470]                           info <- base::paste(info, collapse = "; ")
[17:44:48.470]                           if (!has_future) {
[17:44:48.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.470]                               info)
[17:44:48.470]                           }
[17:44:48.470]                           else {
[17:44:48.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.470]                               info, version)
[17:44:48.470]                           }
[17:44:48.470]                           base::stop(msg)
[17:44:48.470]                         }
[17:44:48.470]                       })
[17:44:48.470]                     }
[17:44:48.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.470]                     base::options(mc.cores = 1L)
[17:44:48.470]                   }
[17:44:48.470]                   ...future.strategy.old <- future::plan("list")
[17:44:48.470]                   options(future.plan = NULL)
[17:44:48.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.470]                 }
[17:44:48.470]                 ...future.workdir <- getwd()
[17:44:48.470]             }
[17:44:48.470]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.470]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.470]         }
[17:44:48.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.470]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.470]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.470]             base::names(...future.oldOptions))
[17:44:48.470]     }
[17:44:48.470]     if (FALSE) {
[17:44:48.470]     }
[17:44:48.470]     else {
[17:44:48.470]         if (TRUE) {
[17:44:48.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.470]                 open = "w")
[17:44:48.470]         }
[17:44:48.470]         else {
[17:44:48.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.470]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.470]         }
[17:44:48.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.470]             base::sink(type = "output", split = FALSE)
[17:44:48.470]             base::close(...future.stdout)
[17:44:48.470]         }, add = TRUE)
[17:44:48.470]     }
[17:44:48.470]     ...future.frame <- base::sys.nframe()
[17:44:48.470]     ...future.conditions <- base::list()
[17:44:48.470]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.470]     if (FALSE) {
[17:44:48.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.470]     }
[17:44:48.470]     ...future.result <- base::tryCatch({
[17:44:48.470]         base::withCallingHandlers({
[17:44:48.470]             ...future.value <- base::withVisible(base::local({
[17:44:48.470]                 withCallingHandlers({
[17:44:48.470]                   {
[17:44:48.470]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.470]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.470]                       ...future.globals.maxSize)) {
[17:44:48.470]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.470]                       on.exit(options(oopts), add = TRUE)
[17:44:48.470]                     }
[17:44:48.470]                     {
[17:44:48.470]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.470]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.470]                         USE.NAMES = FALSE)
[17:44:48.470]                       do.call(mapply, args = args)
[17:44:48.470]                     }
[17:44:48.470]                   }
[17:44:48.470]                 }, immediateCondition = function(cond) {
[17:44:48.470]                   save_rds <- function (object, pathname, ...) 
[17:44:48.470]                   {
[17:44:48.470]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.470]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.470]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.470]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.470]                         fi_tmp[["mtime"]])
[17:44:48.470]                     }
[17:44:48.470]                     tryCatch({
[17:44:48.470]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.470]                     }, error = function(ex) {
[17:44:48.470]                       msg <- conditionMessage(ex)
[17:44:48.470]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.470]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.470]                         fi_tmp[["mtime"]], msg)
[17:44:48.470]                       ex$message <- msg
[17:44:48.470]                       stop(ex)
[17:44:48.470]                     })
[17:44:48.470]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.470]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.470]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.470]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.470]                       fi <- file.info(pathname)
[17:44:48.470]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.470]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.470]                         fi[["size"]], fi[["mtime"]])
[17:44:48.470]                       stop(msg)
[17:44:48.470]                     }
[17:44:48.470]                     invisible(pathname)
[17:44:48.470]                   }
[17:44:48.470]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.470]                     rootPath = tempdir()) 
[17:44:48.470]                   {
[17:44:48.470]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.470]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.470]                       tmpdir = path, fileext = ".rds")
[17:44:48.470]                     save_rds(obj, file)
[17:44:48.470]                   }
[17:44:48.470]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.470]                   {
[17:44:48.470]                     inherits <- base::inherits
[17:44:48.470]                     invokeRestart <- base::invokeRestart
[17:44:48.470]                     is.null <- base::is.null
[17:44:48.470]                     muffled <- FALSE
[17:44:48.470]                     if (inherits(cond, "message")) {
[17:44:48.470]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.470]                       if (muffled) 
[17:44:48.470]                         invokeRestart("muffleMessage")
[17:44:48.470]                     }
[17:44:48.470]                     else if (inherits(cond, "warning")) {
[17:44:48.470]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.470]                       if (muffled) 
[17:44:48.470]                         invokeRestart("muffleWarning")
[17:44:48.470]                     }
[17:44:48.470]                     else if (inherits(cond, "condition")) {
[17:44:48.470]                       if (!is.null(pattern)) {
[17:44:48.470]                         computeRestarts <- base::computeRestarts
[17:44:48.470]                         grepl <- base::grepl
[17:44:48.470]                         restarts <- computeRestarts(cond)
[17:44:48.470]                         for (restart in restarts) {
[17:44:48.470]                           name <- restart$name
[17:44:48.470]                           if (is.null(name)) 
[17:44:48.470]                             next
[17:44:48.470]                           if (!grepl(pattern, name)) 
[17:44:48.470]                             next
[17:44:48.470]                           invokeRestart(restart)
[17:44:48.470]                           muffled <- TRUE
[17:44:48.470]                           break
[17:44:48.470]                         }
[17:44:48.470]                       }
[17:44:48.470]                     }
[17:44:48.470]                     invisible(muffled)
[17:44:48.470]                   }
[17:44:48.470]                   muffleCondition(cond)
[17:44:48.470]                 })
[17:44:48.470]             }))
[17:44:48.470]             future::FutureResult(value = ...future.value$value, 
[17:44:48.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.470]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.470]                     ...future.globalenv.names))
[17:44:48.470]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.470]         }, condition = base::local({
[17:44:48.470]             c <- base::c
[17:44:48.470]             inherits <- base::inherits
[17:44:48.470]             invokeRestart <- base::invokeRestart
[17:44:48.470]             length <- base::length
[17:44:48.470]             list <- base::list
[17:44:48.470]             seq.int <- base::seq.int
[17:44:48.470]             signalCondition <- base::signalCondition
[17:44:48.470]             sys.calls <- base::sys.calls
[17:44:48.470]             `[[` <- base::`[[`
[17:44:48.470]             `+` <- base::`+`
[17:44:48.470]             `<<-` <- base::`<<-`
[17:44:48.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.470]                   3L)]
[17:44:48.470]             }
[17:44:48.470]             function(cond) {
[17:44:48.470]                 is_error <- inherits(cond, "error")
[17:44:48.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.470]                   NULL)
[17:44:48.470]                 if (is_error) {
[17:44:48.470]                   sessionInformation <- function() {
[17:44:48.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.470]                       search = base::search(), system = base::Sys.info())
[17:44:48.470]                   }
[17:44:48.470]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.470]                     cond$call), session = sessionInformation(), 
[17:44:48.470]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.470]                   signalCondition(cond)
[17:44:48.470]                 }
[17:44:48.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.470]                 "immediateCondition"))) {
[17:44:48.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.470]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.470]                   if (TRUE && !signal) {
[17:44:48.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.470]                     {
[17:44:48.470]                       inherits <- base::inherits
[17:44:48.470]                       invokeRestart <- base::invokeRestart
[17:44:48.470]                       is.null <- base::is.null
[17:44:48.470]                       muffled <- FALSE
[17:44:48.470]                       if (inherits(cond, "message")) {
[17:44:48.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.470]                         if (muffled) 
[17:44:48.470]                           invokeRestart("muffleMessage")
[17:44:48.470]                       }
[17:44:48.470]                       else if (inherits(cond, "warning")) {
[17:44:48.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.470]                         if (muffled) 
[17:44:48.470]                           invokeRestart("muffleWarning")
[17:44:48.470]                       }
[17:44:48.470]                       else if (inherits(cond, "condition")) {
[17:44:48.470]                         if (!is.null(pattern)) {
[17:44:48.470]                           computeRestarts <- base::computeRestarts
[17:44:48.470]                           grepl <- base::grepl
[17:44:48.470]                           restarts <- computeRestarts(cond)
[17:44:48.470]                           for (restart in restarts) {
[17:44:48.470]                             name <- restart$name
[17:44:48.470]                             if (is.null(name)) 
[17:44:48.470]                               next
[17:44:48.470]                             if (!grepl(pattern, name)) 
[17:44:48.470]                               next
[17:44:48.470]                             invokeRestart(restart)
[17:44:48.470]                             muffled <- TRUE
[17:44:48.470]                             break
[17:44:48.470]                           }
[17:44:48.470]                         }
[17:44:48.470]                       }
[17:44:48.470]                       invisible(muffled)
[17:44:48.470]                     }
[17:44:48.470]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.470]                   }
[17:44:48.470]                 }
[17:44:48.470]                 else {
[17:44:48.470]                   if (TRUE) {
[17:44:48.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.470]                     {
[17:44:48.470]                       inherits <- base::inherits
[17:44:48.470]                       invokeRestart <- base::invokeRestart
[17:44:48.470]                       is.null <- base::is.null
[17:44:48.470]                       muffled <- FALSE
[17:44:48.470]                       if (inherits(cond, "message")) {
[17:44:48.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.470]                         if (muffled) 
[17:44:48.470]                           invokeRestart("muffleMessage")
[17:44:48.470]                       }
[17:44:48.470]                       else if (inherits(cond, "warning")) {
[17:44:48.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.470]                         if (muffled) 
[17:44:48.470]                           invokeRestart("muffleWarning")
[17:44:48.470]                       }
[17:44:48.470]                       else if (inherits(cond, "condition")) {
[17:44:48.470]                         if (!is.null(pattern)) {
[17:44:48.470]                           computeRestarts <- base::computeRestarts
[17:44:48.470]                           grepl <- base::grepl
[17:44:48.470]                           restarts <- computeRestarts(cond)
[17:44:48.470]                           for (restart in restarts) {
[17:44:48.470]                             name <- restart$name
[17:44:48.470]                             if (is.null(name)) 
[17:44:48.470]                               next
[17:44:48.470]                             if (!grepl(pattern, name)) 
[17:44:48.470]                               next
[17:44:48.470]                             invokeRestart(restart)
[17:44:48.470]                             muffled <- TRUE
[17:44:48.470]                             break
[17:44:48.470]                           }
[17:44:48.470]                         }
[17:44:48.470]                       }
[17:44:48.470]                       invisible(muffled)
[17:44:48.470]                     }
[17:44:48.470]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.470]                   }
[17:44:48.470]                 }
[17:44:48.470]             }
[17:44:48.470]         }))
[17:44:48.470]     }, error = function(ex) {
[17:44:48.470]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.470]                 ...future.rng), started = ...future.startTime, 
[17:44:48.470]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.470]             version = "1.8"), class = "FutureResult")
[17:44:48.470]     }, finally = {
[17:44:48.470]         if (!identical(...future.workdir, getwd())) 
[17:44:48.470]             setwd(...future.workdir)
[17:44:48.470]         {
[17:44:48.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.470]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.470]             }
[17:44:48.470]             base::options(...future.oldOptions)
[17:44:48.470]             if (.Platform$OS.type == "windows") {
[17:44:48.470]                 old_names <- names(...future.oldEnvVars)
[17:44:48.470]                 envs <- base::Sys.getenv()
[17:44:48.470]                 names <- names(envs)
[17:44:48.470]                 common <- intersect(names, old_names)
[17:44:48.470]                 added <- setdiff(names, old_names)
[17:44:48.470]                 removed <- setdiff(old_names, names)
[17:44:48.470]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.470]                   envs[common]]
[17:44:48.470]                 NAMES <- toupper(changed)
[17:44:48.470]                 args <- list()
[17:44:48.470]                 for (kk in seq_along(NAMES)) {
[17:44:48.470]                   name <- changed[[kk]]
[17:44:48.470]                   NAME <- NAMES[[kk]]
[17:44:48.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.470]                     next
[17:44:48.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.470]                 }
[17:44:48.470]                 NAMES <- toupper(added)
[17:44:48.470]                 for (kk in seq_along(NAMES)) {
[17:44:48.470]                   name <- added[[kk]]
[17:44:48.470]                   NAME <- NAMES[[kk]]
[17:44:48.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.470]                     next
[17:44:48.470]                   args[[name]] <- ""
[17:44:48.470]                 }
[17:44:48.470]                 NAMES <- toupper(removed)
[17:44:48.470]                 for (kk in seq_along(NAMES)) {
[17:44:48.470]                   name <- removed[[kk]]
[17:44:48.470]                   NAME <- NAMES[[kk]]
[17:44:48.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.470]                     next
[17:44:48.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.470]                 }
[17:44:48.470]                 if (length(args) > 0) 
[17:44:48.470]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.470]             }
[17:44:48.470]             else {
[17:44:48.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.470]             }
[17:44:48.470]             {
[17:44:48.470]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.470]                   0L) {
[17:44:48.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.470]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.470]                   base::options(opts)
[17:44:48.470]                 }
[17:44:48.470]                 {
[17:44:48.470]                   {
[17:44:48.470]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.470]                     NULL
[17:44:48.470]                   }
[17:44:48.470]                   options(future.plan = NULL)
[17:44:48.470]                   if (is.na(NA_character_)) 
[17:44:48.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.470]                     .init = FALSE)
[17:44:48.470]                 }
[17:44:48.470]             }
[17:44:48.470]         }
[17:44:48.470]     })
[17:44:48.470]     if (TRUE) {
[17:44:48.470]         base::sink(type = "output", split = FALSE)
[17:44:48.470]         if (TRUE) {
[17:44:48.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.470]         }
[17:44:48.470]         else {
[17:44:48.470]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.470]         }
[17:44:48.470]         base::close(...future.stdout)
[17:44:48.470]         ...future.stdout <- NULL
[17:44:48.470]     }
[17:44:48.470]     ...future.result$conditions <- ...future.conditions
[17:44:48.470]     ...future.result$finished <- base::Sys.time()
[17:44:48.470]     ...future.result
[17:44:48.470] }
[17:44:48.473] assign_globals() ...
[17:44:48.474] List of 5
[17:44:48.474]  $ ...future.FUN            :function (x, ...)  
[17:44:48.474]  $ MoreArgs                 : NULL
[17:44:48.474]  $ ...future.elements_ii    :List of 2
[17:44:48.474]   ..$ :List of 2
[17:44:48.474]   .. ..$ : int 3
[17:44:48.474]   .. ..$ : int 4
[17:44:48.474]   ..$ :List of 2
[17:44:48.474]   .. ..$ : int 2
[17:44:48.474]   .. ..$ : int 1
[17:44:48.474]  $ ...future.seeds_ii       : NULL
[17:44:48.474]  $ ...future.globals.maxSize: NULL
[17:44:48.474]  - attr(*, "where")=List of 5
[17:44:48.474]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.474]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.474]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.474]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.474]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.474]  - attr(*, "resolved")= logi FALSE
[17:44:48.474]  - attr(*, "total_size")= num 280
[17:44:48.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.474]  - attr(*, "already-done")= logi TRUE
[17:44:48.482] - copied ‘...future.FUN’ to environment
[17:44:48.482] - copied ‘MoreArgs’ to environment
[17:44:48.482] - copied ‘...future.elements_ii’ to environment
[17:44:48.482] - copied ‘...future.seeds_ii’ to environment
[17:44:48.483] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.483] assign_globals() ... done
[17:44:48.483] requestCore(): workers = 2
[17:44:48.485] MulticoreFuture started
[17:44:48.486] - Launch lazy future ... done
[17:44:48.486] run() for ‘MulticoreFuture’ ... done
[17:44:48.486] Created future:
[17:44:48.486] plan(): Setting new future strategy stack:
[17:44:48.486] List of future strategies:
[17:44:48.486] 1. sequential:
[17:44:48.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.486]    - tweaked: FALSE
[17:44:48.486]    - call: NULL
[17:44:48.487] plan(): nbrOfWorkers() = 1
[17:44:48.489] plan(): Setting new future strategy stack:
[17:44:48.490] List of future strategies:
[17:44:48.490] 1. multicore:
[17:44:48.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.490]    - tweaked: FALSE
[17:44:48.490]    - call: plan(strategy)
[17:44:48.495] plan(): nbrOfWorkers() = 2
[17:44:48.486] MulticoreFuture:
[17:44:48.486] Label: ‘future_mapply-2’
[17:44:48.486] Expression:
[17:44:48.486] {
[17:44:48.486]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.486]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.486]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.486]         on.exit(options(oopts), add = TRUE)
[17:44:48.486]     }
[17:44:48.486]     {
[17:44:48.486]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.486]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.486]         do.call(mapply, args = args)
[17:44:48.486]     }
[17:44:48.486] }
[17:44:48.486] Lazy evaluation: FALSE
[17:44:48.486] Asynchronous evaluation: TRUE
[17:44:48.486] Local evaluation: TRUE
[17:44:48.486] Environment: R_GlobalEnv
[17:44:48.486] Capture standard output: TRUE
[17:44:48.486] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.486] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.486] Packages: <none>
[17:44:48.486] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.486] Resolved: TRUE
[17:44:48.486] Value: <not collected>
[17:44:48.486] Conditions captured: <none>
[17:44:48.486] Early signaling: FALSE
[17:44:48.486] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.486] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.496] Chunk #2 of 2 ... DONE
[17:44:48.496] Launching 2 futures (chunks) ... DONE
[17:44:48.496] Resolving 2 futures (chunks) ...
[17:44:48.496] resolve() on list ...
[17:44:48.496]  recursive: 0
[17:44:48.497]  length: 2
[17:44:48.497] 
[17:44:48.497] Future #1
[17:44:48.497] result() for MulticoreFuture ...
[17:44:48.498] result() for MulticoreFuture ...
[17:44:48.498] result() for MulticoreFuture ... done
[17:44:48.498] result() for MulticoreFuture ... done
[17:44:48.499] result() for MulticoreFuture ...
[17:44:48.499] result() for MulticoreFuture ... done
[17:44:48.499] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.499] - nx: 2
[17:44:48.499] - relay: TRUE
[17:44:48.499] - stdout: TRUE
[17:44:48.500] - signal: TRUE
[17:44:48.500] - resignal: FALSE
[17:44:48.500] - force: TRUE
[17:44:48.500] - relayed: [n=2] FALSE, FALSE
[17:44:48.500] - queued futures: [n=2] FALSE, FALSE
[17:44:48.500]  - until=1
[17:44:48.500]  - relaying element #1
[17:44:48.501] result() for MulticoreFuture ...
[17:44:48.501] result() for MulticoreFuture ... done
[17:44:48.501] result() for MulticoreFuture ...
[17:44:48.501] result() for MulticoreFuture ... done
[17:44:48.501] result() for MulticoreFuture ...
[17:44:48.501] result() for MulticoreFuture ... done
[17:44:48.501] result() for MulticoreFuture ...
[17:44:48.502] result() for MulticoreFuture ... done
[17:44:48.502] - relayed: [n=2] TRUE, FALSE
[17:44:48.502] - queued futures: [n=2] TRUE, FALSE
[17:44:48.502] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.502]  length: 1 (resolved future 1)
[17:44:48.503] Future #2
[17:44:48.503] result() for MulticoreFuture ...
[17:44:48.504] result() for MulticoreFuture ...
[17:44:48.504] result() for MulticoreFuture ... done
[17:44:48.504] result() for MulticoreFuture ... done
[17:44:48.504] result() for MulticoreFuture ...
[17:44:48.504] result() for MulticoreFuture ... done
[17:44:48.504] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.504] - nx: 2
[17:44:48.505] - relay: TRUE
[17:44:48.505] - stdout: TRUE
[17:44:48.505] - signal: TRUE
[17:44:48.505] - resignal: FALSE
[17:44:48.505] - force: TRUE
[17:44:48.505] - relayed: [n=2] TRUE, FALSE
[17:44:48.508] - queued futures: [n=2] TRUE, FALSE
[17:44:48.509]  - until=2
[17:44:48.509]  - relaying element #2
[17:44:48.509] result() for MulticoreFuture ...
[17:44:48.509] result() for MulticoreFuture ... done
[17:44:48.509] result() for MulticoreFuture ...
[17:44:48.510] result() for MulticoreFuture ... done
[17:44:48.510] result() for MulticoreFuture ...
[17:44:48.510] result() for MulticoreFuture ... done
[17:44:48.510] result() for MulticoreFuture ...
[17:44:48.510] result() for MulticoreFuture ... done
[17:44:48.510] - relayed: [n=2] TRUE, TRUE
[17:44:48.511] - queued futures: [n=2] TRUE, TRUE
[17:44:48.511] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.511]  length: 0 (resolved future 2)
[17:44:48.511] Relaying remaining futures
[17:44:48.511] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.511] - nx: 2
[17:44:48.512] - relay: TRUE
[17:44:48.512] - stdout: TRUE
[17:44:48.512] - signal: TRUE
[17:44:48.512] - resignal: FALSE
[17:44:48.512] - force: TRUE
[17:44:48.512] - relayed: [n=2] TRUE, TRUE
[17:44:48.512] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.513] - relayed: [n=2] TRUE, TRUE
[17:44:48.513] - queued futures: [n=2] TRUE, TRUE
[17:44:48.513] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.513] resolve() on list ... DONE
[17:44:48.513] result() for MulticoreFuture ...
[17:44:48.513] result() for MulticoreFuture ... done
[17:44:48.514] result() for MulticoreFuture ...
[17:44:48.514] result() for MulticoreFuture ... done
[17:44:48.514] result() for MulticoreFuture ...
[17:44:48.514] result() for MulticoreFuture ... done
[17:44:48.514] result() for MulticoreFuture ...
[17:44:48.514] result() for MulticoreFuture ... done
[17:44:48.514]  - Number of value chunks collected: 2
[17:44:48.515] Resolving 2 futures (chunks) ... DONE
[17:44:48.515] Reducing values from 2 chunks ...
[17:44:48.515]  - Number of values collected after concatenation: 4
[17:44:48.515]  - Number of values expected: 4
[17:44:48.515] Reducing values from 2 chunks ... DONE
[17:44:48.515] future_mapply() ... DONE
- Parallel RNG ...
[17:44:48.516] future_mapply() ...
[17:44:48.516] Generating random seeds ...
[17:44:48.516] Generating random seed streams for 4 elements ...
[17:44:48.516] Generating random seed streams for 4 elements ... DONE
[17:44:48.516] Generating random seeds ... DONE
[17:44:48.516] Will set RNG state on exit: 10407, 1880373827, -596001006, 595922090, -98316031, 670431505, -224621358
[17:44:48.521] Number of chunks: 2
[17:44:48.521] getGlobalsAndPackagesXApply() ...
[17:44:48.521]  - future.globals: TRUE
[17:44:48.521] getGlobalsAndPackages() ...
[17:44:48.521] Searching for globals...
[17:44:48.523] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:44:48.523] Searching for globals ... DONE
[17:44:48.523] Resolving globals: FALSE
[17:44:48.524] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:44:48.524] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:44:48.524] - globals: [1] ‘FUN’
[17:44:48.524] - packages: [1] ‘stats’
[17:44:48.524] getGlobalsAndPackages() ... DONE
[17:44:48.525]  - globals found/used: [n=1] ‘FUN’
[17:44:48.525]  - needed namespaces: [n=1] ‘stats’
[17:44:48.525] Finding globals ... DONE
[17:44:48.525] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.525] List of 2
[17:44:48.525]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:44:48.525]  $ MoreArgs     :List of 1
[17:44:48.525]   ..$ min: num 1
[17:44:48.525]  - attr(*, "where")=List of 2
[17:44:48.525]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.525]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.525]  - attr(*, "resolved")= logi FALSE
[17:44:48.525]  - attr(*, "total_size")= num NA
[17:44:48.528] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:48.528] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.529] Number of futures (= number of chunks): 2
[17:44:48.529] Launching 2 futures (chunks) ...
[17:44:48.529] Chunk #1 of 2 ...
[17:44:48.529]  - Finding globals in '...' for chunk #1 ...
[17:44:48.529] getGlobalsAndPackages() ...
[17:44:48.529] Searching for globals...
[17:44:48.529] 
[17:44:48.530] Searching for globals ... DONE
[17:44:48.530] - globals: [0] <none>
[17:44:48.530] getGlobalsAndPackages() ... DONE
[17:44:48.530]    + additional globals found: [n=0] 
[17:44:48.530]    + additional namespaces needed: [n=0] 
[17:44:48.530]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.530]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.530]  - seeds: [2] <seeds>
[17:44:48.530]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.530] getGlobalsAndPackages() ...
[17:44:48.531] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.531] Resolving globals: FALSE
[17:44:48.531] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:44:48.532] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:44:48.532] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.532] - packages: [1] ‘stats’
[17:44:48.532] getGlobalsAndPackages() ... DONE
[17:44:48.532] run() for ‘Future’ ...
[17:44:48.533] - state: ‘created’
[17:44:48.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.537]   - Field: ‘label’
[17:44:48.537]   - Field: ‘local’
[17:44:48.537]   - Field: ‘owner’
[17:44:48.537]   - Field: ‘envir’
[17:44:48.537]   - Field: ‘workers’
[17:44:48.537]   - Field: ‘packages’
[17:44:48.540]   - Field: ‘gc’
[17:44:48.540]   - Field: ‘job’
[17:44:48.540]   - Field: ‘conditions’
[17:44:48.540]   - Field: ‘expr’
[17:44:48.540]   - Field: ‘uuid’
[17:44:48.540]   - Field: ‘seed’
[17:44:48.540]   - Field: ‘version’
[17:44:48.541]   - Field: ‘result’
[17:44:48.541]   - Field: ‘asynchronous’
[17:44:48.541]   - Field: ‘calls’
[17:44:48.541]   - Field: ‘globals’
[17:44:48.541]   - Field: ‘stdout’
[17:44:48.541]   - Field: ‘earlySignal’
[17:44:48.541]   - Field: ‘lazy’
[17:44:48.541]   - Field: ‘state’
[17:44:48.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.542] - Launch lazy future ...
[17:44:48.542] Packages needed by the future expression (n = 1): ‘stats’
[17:44:48.542] Packages needed by future strategies (n = 0): <none>
[17:44:48.543] {
[17:44:48.543]     {
[17:44:48.543]         {
[17:44:48.543]             ...future.startTime <- base::Sys.time()
[17:44:48.543]             {
[17:44:48.543]                 {
[17:44:48.543]                   {
[17:44:48.543]                     {
[17:44:48.543]                       {
[17:44:48.543]                         base::local({
[17:44:48.543]                           has_future <- base::requireNamespace("future", 
[17:44:48.543]                             quietly = TRUE)
[17:44:48.543]                           if (has_future) {
[17:44:48.543]                             ns <- base::getNamespace("future")
[17:44:48.543]                             version <- ns[[".package"]][["version"]]
[17:44:48.543]                             if (is.null(version)) 
[17:44:48.543]                               version <- utils::packageVersion("future")
[17:44:48.543]                           }
[17:44:48.543]                           else {
[17:44:48.543]                             version <- NULL
[17:44:48.543]                           }
[17:44:48.543]                           if (!has_future || version < "1.8.0") {
[17:44:48.543]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.543]                               "", base::R.version$version.string), 
[17:44:48.543]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:48.543]                                 base::R.version$platform, 8 * 
[17:44:48.543]                                   base::.Machine$sizeof.pointer), 
[17:44:48.543]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.543]                                 "release", "version")], collapse = " "), 
[17:44:48.543]                               hostname = base::Sys.info()[["nodename"]])
[17:44:48.543]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.543]                               info)
[17:44:48.543]                             info <- base::paste(info, collapse = "; ")
[17:44:48.543]                             if (!has_future) {
[17:44:48.543]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.543]                                 info)
[17:44:48.543]                             }
[17:44:48.543]                             else {
[17:44:48.543]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.543]                                 info, version)
[17:44:48.543]                             }
[17:44:48.543]                             base::stop(msg)
[17:44:48.543]                           }
[17:44:48.543]                         })
[17:44:48.543]                       }
[17:44:48.543]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.543]                       base::options(mc.cores = 1L)
[17:44:48.543]                     }
[17:44:48.543]                     base::local({
[17:44:48.543]                       for (pkg in "stats") {
[17:44:48.543]                         base::loadNamespace(pkg)
[17:44:48.543]                         base::library(pkg, character.only = TRUE)
[17:44:48.543]                       }
[17:44:48.543]                     })
[17:44:48.543]                   }
[17:44:48.543]                   ...future.strategy.old <- future::plan("list")
[17:44:48.543]                   options(future.plan = NULL)
[17:44:48.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.543]                 }
[17:44:48.543]                 ...future.workdir <- getwd()
[17:44:48.543]             }
[17:44:48.543]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.543]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.543]         }
[17:44:48.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.543]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.543]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.543]             base::names(...future.oldOptions))
[17:44:48.543]     }
[17:44:48.543]     if (FALSE) {
[17:44:48.543]     }
[17:44:48.543]     else {
[17:44:48.543]         if (TRUE) {
[17:44:48.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.543]                 open = "w")
[17:44:48.543]         }
[17:44:48.543]         else {
[17:44:48.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.543]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.543]         }
[17:44:48.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.543]             base::sink(type = "output", split = FALSE)
[17:44:48.543]             base::close(...future.stdout)
[17:44:48.543]         }, add = TRUE)
[17:44:48.543]     }
[17:44:48.543]     ...future.frame <- base::sys.nframe()
[17:44:48.543]     ...future.conditions <- base::list()
[17:44:48.543]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.543]     if (FALSE) {
[17:44:48.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.543]     }
[17:44:48.543]     ...future.result <- base::tryCatch({
[17:44:48.543]         base::withCallingHandlers({
[17:44:48.543]             ...future.value <- base::withVisible(base::local({
[17:44:48.543]                 withCallingHandlers({
[17:44:48.543]                   {
[17:44:48.543]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.543]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.543]                       ...future.globals.maxSize)) {
[17:44:48.543]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.543]                       on.exit(options(oopts), add = TRUE)
[17:44:48.543]                     }
[17:44:48.543]                     {
[17:44:48.543]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.543]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:48.543]                           envir = globalenv(), inherits = FALSE)
[17:44:48.543]                         ...future.FUN(...)
[17:44:48.543]                       }
[17:44:48.543]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.543]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.543]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.543]                         USE.NAMES = FALSE)
[17:44:48.543]                       do.call(mapply, args = args)
[17:44:48.543]                     }
[17:44:48.543]                   }
[17:44:48.543]                 }, immediateCondition = function(cond) {
[17:44:48.543]                   save_rds <- function (object, pathname, ...) 
[17:44:48.543]                   {
[17:44:48.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.543]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.543]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.543]                         fi_tmp[["mtime"]])
[17:44:48.543]                     }
[17:44:48.543]                     tryCatch({
[17:44:48.543]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.543]                     }, error = function(ex) {
[17:44:48.543]                       msg <- conditionMessage(ex)
[17:44:48.543]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.543]                         fi_tmp[["mtime"]], msg)
[17:44:48.543]                       ex$message <- msg
[17:44:48.543]                       stop(ex)
[17:44:48.543]                     })
[17:44:48.543]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.543]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.543]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.543]                       fi <- file.info(pathname)
[17:44:48.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.543]                         fi[["size"]], fi[["mtime"]])
[17:44:48.543]                       stop(msg)
[17:44:48.543]                     }
[17:44:48.543]                     invisible(pathname)
[17:44:48.543]                   }
[17:44:48.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.543]                     rootPath = tempdir()) 
[17:44:48.543]                   {
[17:44:48.543]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.543]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.543]                       tmpdir = path, fileext = ".rds")
[17:44:48.543]                     save_rds(obj, file)
[17:44:48.543]                   }
[17:44:48.543]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.543]                   {
[17:44:48.543]                     inherits <- base::inherits
[17:44:48.543]                     invokeRestart <- base::invokeRestart
[17:44:48.543]                     is.null <- base::is.null
[17:44:48.543]                     muffled <- FALSE
[17:44:48.543]                     if (inherits(cond, "message")) {
[17:44:48.543]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.543]                       if (muffled) 
[17:44:48.543]                         invokeRestart("muffleMessage")
[17:44:48.543]                     }
[17:44:48.543]                     else if (inherits(cond, "warning")) {
[17:44:48.543]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.543]                       if (muffled) 
[17:44:48.543]                         invokeRestart("muffleWarning")
[17:44:48.543]                     }
[17:44:48.543]                     else if (inherits(cond, "condition")) {
[17:44:48.543]                       if (!is.null(pattern)) {
[17:44:48.543]                         computeRestarts <- base::computeRestarts
[17:44:48.543]                         grepl <- base::grepl
[17:44:48.543]                         restarts <- computeRestarts(cond)
[17:44:48.543]                         for (restart in restarts) {
[17:44:48.543]                           name <- restart$name
[17:44:48.543]                           if (is.null(name)) 
[17:44:48.543]                             next
[17:44:48.543]                           if (!grepl(pattern, name)) 
[17:44:48.543]                             next
[17:44:48.543]                           invokeRestart(restart)
[17:44:48.543]                           muffled <- TRUE
[17:44:48.543]                           break
[17:44:48.543]                         }
[17:44:48.543]                       }
[17:44:48.543]                     }
[17:44:48.543]                     invisible(muffled)
[17:44:48.543]                   }
[17:44:48.543]                   muffleCondition(cond)
[17:44:48.543]                 })
[17:44:48.543]             }))
[17:44:48.543]             future::FutureResult(value = ...future.value$value, 
[17:44:48.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.543]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.543]                     ...future.globalenv.names))
[17:44:48.543]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.543]         }, condition = base::local({
[17:44:48.543]             c <- base::c
[17:44:48.543]             inherits <- base::inherits
[17:44:48.543]             invokeRestart <- base::invokeRestart
[17:44:48.543]             length <- base::length
[17:44:48.543]             list <- base::list
[17:44:48.543]             seq.int <- base::seq.int
[17:44:48.543]             signalCondition <- base::signalCondition
[17:44:48.543]             sys.calls <- base::sys.calls
[17:44:48.543]             `[[` <- base::`[[`
[17:44:48.543]             `+` <- base::`+`
[17:44:48.543]             `<<-` <- base::`<<-`
[17:44:48.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.543]                   3L)]
[17:44:48.543]             }
[17:44:48.543]             function(cond) {
[17:44:48.543]                 is_error <- inherits(cond, "error")
[17:44:48.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.543]                   NULL)
[17:44:48.543]                 if (is_error) {
[17:44:48.543]                   sessionInformation <- function() {
[17:44:48.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.543]                       search = base::search(), system = base::Sys.info())
[17:44:48.543]                   }
[17:44:48.543]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.543]                     cond$call), session = sessionInformation(), 
[17:44:48.543]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.543]                   signalCondition(cond)
[17:44:48.543]                 }
[17:44:48.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.543]                 "immediateCondition"))) {
[17:44:48.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.543]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.543]                   if (TRUE && !signal) {
[17:44:48.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.543]                     {
[17:44:48.543]                       inherits <- base::inherits
[17:44:48.543]                       invokeRestart <- base::invokeRestart
[17:44:48.543]                       is.null <- base::is.null
[17:44:48.543]                       muffled <- FALSE
[17:44:48.543]                       if (inherits(cond, "message")) {
[17:44:48.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.543]                         if (muffled) 
[17:44:48.543]                           invokeRestart("muffleMessage")
[17:44:48.543]                       }
[17:44:48.543]                       else if (inherits(cond, "warning")) {
[17:44:48.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.543]                         if (muffled) 
[17:44:48.543]                           invokeRestart("muffleWarning")
[17:44:48.543]                       }
[17:44:48.543]                       else if (inherits(cond, "condition")) {
[17:44:48.543]                         if (!is.null(pattern)) {
[17:44:48.543]                           computeRestarts <- base::computeRestarts
[17:44:48.543]                           grepl <- base::grepl
[17:44:48.543]                           restarts <- computeRestarts(cond)
[17:44:48.543]                           for (restart in restarts) {
[17:44:48.543]                             name <- restart$name
[17:44:48.543]                             if (is.null(name)) 
[17:44:48.543]                               next
[17:44:48.543]                             if (!grepl(pattern, name)) 
[17:44:48.543]                               next
[17:44:48.543]                             invokeRestart(restart)
[17:44:48.543]                             muffled <- TRUE
[17:44:48.543]                             break
[17:44:48.543]                           }
[17:44:48.543]                         }
[17:44:48.543]                       }
[17:44:48.543]                       invisible(muffled)
[17:44:48.543]                     }
[17:44:48.543]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.543]                   }
[17:44:48.543]                 }
[17:44:48.543]                 else {
[17:44:48.543]                   if (TRUE) {
[17:44:48.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.543]                     {
[17:44:48.543]                       inherits <- base::inherits
[17:44:48.543]                       invokeRestart <- base::invokeRestart
[17:44:48.543]                       is.null <- base::is.null
[17:44:48.543]                       muffled <- FALSE
[17:44:48.543]                       if (inherits(cond, "message")) {
[17:44:48.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.543]                         if (muffled) 
[17:44:48.543]                           invokeRestart("muffleMessage")
[17:44:48.543]                       }
[17:44:48.543]                       else if (inherits(cond, "warning")) {
[17:44:48.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.543]                         if (muffled) 
[17:44:48.543]                           invokeRestart("muffleWarning")
[17:44:48.543]                       }
[17:44:48.543]                       else if (inherits(cond, "condition")) {
[17:44:48.543]                         if (!is.null(pattern)) {
[17:44:48.543]                           computeRestarts <- base::computeRestarts
[17:44:48.543]                           grepl <- base::grepl
[17:44:48.543]                           restarts <- computeRestarts(cond)
[17:44:48.543]                           for (restart in restarts) {
[17:44:48.543]                             name <- restart$name
[17:44:48.543]                             if (is.null(name)) 
[17:44:48.543]                               next
[17:44:48.543]                             if (!grepl(pattern, name)) 
[17:44:48.543]                               next
[17:44:48.543]                             invokeRestart(restart)
[17:44:48.543]                             muffled <- TRUE
[17:44:48.543]                             break
[17:44:48.543]                           }
[17:44:48.543]                         }
[17:44:48.543]                       }
[17:44:48.543]                       invisible(muffled)
[17:44:48.543]                     }
[17:44:48.543]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.543]                   }
[17:44:48.543]                 }
[17:44:48.543]             }
[17:44:48.543]         }))
[17:44:48.543]     }, error = function(ex) {
[17:44:48.543]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.543]                 ...future.rng), started = ...future.startTime, 
[17:44:48.543]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.543]             version = "1.8"), class = "FutureResult")
[17:44:48.543]     }, finally = {
[17:44:48.543]         if (!identical(...future.workdir, getwd())) 
[17:44:48.543]             setwd(...future.workdir)
[17:44:48.543]         {
[17:44:48.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.543]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.543]             }
[17:44:48.543]             base::options(...future.oldOptions)
[17:44:48.543]             if (.Platform$OS.type == "windows") {
[17:44:48.543]                 old_names <- names(...future.oldEnvVars)
[17:44:48.543]                 envs <- base::Sys.getenv()
[17:44:48.543]                 names <- names(envs)
[17:44:48.543]                 common <- intersect(names, old_names)
[17:44:48.543]                 added <- setdiff(names, old_names)
[17:44:48.543]                 removed <- setdiff(old_names, names)
[17:44:48.543]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.543]                   envs[common]]
[17:44:48.543]                 NAMES <- toupper(changed)
[17:44:48.543]                 args <- list()
[17:44:48.543]                 for (kk in seq_along(NAMES)) {
[17:44:48.543]                   name <- changed[[kk]]
[17:44:48.543]                   NAME <- NAMES[[kk]]
[17:44:48.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.543]                     next
[17:44:48.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.543]                 }
[17:44:48.543]                 NAMES <- toupper(added)
[17:44:48.543]                 for (kk in seq_along(NAMES)) {
[17:44:48.543]                   name <- added[[kk]]
[17:44:48.543]                   NAME <- NAMES[[kk]]
[17:44:48.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.543]                     next
[17:44:48.543]                   args[[name]] <- ""
[17:44:48.543]                 }
[17:44:48.543]                 NAMES <- toupper(removed)
[17:44:48.543]                 for (kk in seq_along(NAMES)) {
[17:44:48.543]                   name <- removed[[kk]]
[17:44:48.543]                   NAME <- NAMES[[kk]]
[17:44:48.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.543]                     next
[17:44:48.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.543]                 }
[17:44:48.543]                 if (length(args) > 0) 
[17:44:48.543]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.543]             }
[17:44:48.543]             else {
[17:44:48.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.543]             }
[17:44:48.543]             {
[17:44:48.543]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.543]                   0L) {
[17:44:48.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.543]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.543]                   base::options(opts)
[17:44:48.543]                 }
[17:44:48.543]                 {
[17:44:48.543]                   {
[17:44:48.543]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.543]                     NULL
[17:44:48.543]                   }
[17:44:48.543]                   options(future.plan = NULL)
[17:44:48.543]                   if (is.na(NA_character_)) 
[17:44:48.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.543]                     .init = FALSE)
[17:44:48.543]                 }
[17:44:48.543]             }
[17:44:48.543]         }
[17:44:48.543]     })
[17:44:48.543]     if (TRUE) {
[17:44:48.543]         base::sink(type = "output", split = FALSE)
[17:44:48.543]         if (TRUE) {
[17:44:48.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.543]         }
[17:44:48.543]         else {
[17:44:48.543]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.543]         }
[17:44:48.543]         base::close(...future.stdout)
[17:44:48.543]         ...future.stdout <- NULL
[17:44:48.543]     }
[17:44:48.543]     ...future.result$conditions <- ...future.conditions
[17:44:48.543]     ...future.result$finished <- base::Sys.time()
[17:44:48.543]     ...future.result
[17:44:48.543] }
[17:44:48.545] assign_globals() ...
[17:44:48.545] List of 5
[17:44:48.545]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:44:48.545]  $ MoreArgs                 :List of 1
[17:44:48.545]   ..$ min: num 1
[17:44:48.545]  $ ...future.elements_ii    :List of 2
[17:44:48.545]   ..$ n  :List of 2
[17:44:48.545]   .. ..$ : int 1
[17:44:48.545]   .. ..$ : int 2
[17:44:48.545]   ..$ max:List of 2
[17:44:48.545]   .. ..$ : int 2
[17:44:48.545]   .. ..$ : int 3
[17:44:48.545]  $ ...future.seeds_ii       :List of 2
[17:44:48.545]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[17:44:48.545]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[17:44:48.545]  $ ...future.globals.maxSize: NULL
[17:44:48.545]  - attr(*, "where")=List of 5
[17:44:48.545]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.545]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.545]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.545]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.545]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.545]  - attr(*, "resolved")= logi FALSE
[17:44:48.545]  - attr(*, "total_size")= num 2528
[17:44:48.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.545]  - attr(*, "already-done")= logi TRUE
[17:44:48.553] - copied ‘...future.FUN’ to environment
[17:44:48.553] - copied ‘MoreArgs’ to environment
[17:44:48.553] - copied ‘...future.elements_ii’ to environment
[17:44:48.553] - copied ‘...future.seeds_ii’ to environment
[17:44:48.553] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.553] assign_globals() ... done
[17:44:48.554] requestCore(): workers = 2
[17:44:48.556] MulticoreFuture started
[17:44:48.556] - Launch lazy future ... done
[17:44:48.556] run() for ‘MulticoreFuture’ ... done
[17:44:48.557] Created future:
[17:44:48.557] plan(): Setting new future strategy stack:
[17:44:48.558] List of future strategies:
[17:44:48.558] 1. sequential:
[17:44:48.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.558]    - tweaked: FALSE
[17:44:48.558]    - call: NULL
[17:44:48.558] plan(): nbrOfWorkers() = 1
[17:44:48.561] plan(): Setting new future strategy stack:
[17:44:48.561] List of future strategies:
[17:44:48.561] 1. multicore:
[17:44:48.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.561]    - tweaked: FALSE
[17:44:48.561]    - call: plan(strategy)
[17:44:48.566] plan(): nbrOfWorkers() = 2
[17:44:48.557] MulticoreFuture:
[17:44:48.557] Label: ‘future_mapply-1’
[17:44:48.557] Expression:
[17:44:48.557] {
[17:44:48.557]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.557]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.557]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.557]         on.exit(options(oopts), add = TRUE)
[17:44:48.557]     }
[17:44:48.557]     {
[17:44:48.557]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.557]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:48.557]                 inherits = FALSE)
[17:44:48.557]             ...future.FUN(...)
[17:44:48.557]         }
[17:44:48.557]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.557]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.557]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.557]         do.call(mapply, args = args)
[17:44:48.557]     }
[17:44:48.557] }
[17:44:48.557] Lazy evaluation: FALSE
[17:44:48.557] Asynchronous evaluation: TRUE
[17:44:48.557] Local evaluation: TRUE
[17:44:48.557] Environment: R_GlobalEnv
[17:44:48.557] Capture standard output: TRUE
[17:44:48.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.557] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.557] Packages: 1 packages (‘stats’)
[17:44:48.557] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:48.557] Resolved: TRUE
[17:44:48.557] Value: <not collected>
[17:44:48.557] Conditions captured: <none>
[17:44:48.557] Early signaling: FALSE
[17:44:48.557] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.557] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.567] Chunk #1 of 2 ... DONE
[17:44:48.568] Chunk #2 of 2 ...
[17:44:48.568]  - Finding globals in '...' for chunk #2 ...
[17:44:48.568] getGlobalsAndPackages() ...
[17:44:48.568] Searching for globals...
[17:44:48.569] 
[17:44:48.569] Searching for globals ... DONE
[17:44:48.569] - globals: [0] <none>
[17:44:48.569] getGlobalsAndPackages() ... DONE
[17:44:48.569]    + additional globals found: [n=0] 
[17:44:48.569]    + additional namespaces needed: [n=0] 
[17:44:48.570]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.570]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.570]  - seeds: [2] <seeds>
[17:44:48.570]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.570] getGlobalsAndPackages() ...
[17:44:48.570] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.571] Resolving globals: FALSE
[17:44:48.572] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:44:48.572] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:44:48.573] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.573] - packages: [1] ‘stats’
[17:44:48.573] getGlobalsAndPackages() ... DONE
[17:44:48.574] run() for ‘Future’ ...
[17:44:48.574] - state: ‘created’
[17:44:48.574] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.579] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.579] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.579]   - Field: ‘label’
[17:44:48.579]   - Field: ‘local’
[17:44:48.580]   - Field: ‘owner’
[17:44:48.580]   - Field: ‘envir’
[17:44:48.580]   - Field: ‘workers’
[17:44:48.580]   - Field: ‘packages’
[17:44:48.580]   - Field: ‘gc’
[17:44:48.580]   - Field: ‘job’
[17:44:48.581]   - Field: ‘conditions’
[17:44:48.581]   - Field: ‘expr’
[17:44:48.581]   - Field: ‘uuid’
[17:44:48.581]   - Field: ‘seed’
[17:44:48.585]   - Field: ‘version’
[17:44:48.585]   - Field: ‘result’
[17:44:48.586]   - Field: ‘asynchronous’
[17:44:48.586]   - Field: ‘calls’
[17:44:48.586]   - Field: ‘globals’
[17:44:48.587]   - Field: ‘stdout’
[17:44:48.587]   - Field: ‘earlySignal’
[17:44:48.587]   - Field: ‘lazy’
[17:44:48.587]   - Field: ‘state’
[17:44:48.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.588] - Launch lazy future ...
[17:44:48.589] Packages needed by the future expression (n = 1): ‘stats’
[17:44:48.589] Packages needed by future strategies (n = 0): <none>
[17:44:48.590] {
[17:44:48.590]     {
[17:44:48.590]         {
[17:44:48.590]             ...future.startTime <- base::Sys.time()
[17:44:48.590]             {
[17:44:48.590]                 {
[17:44:48.590]                   {
[17:44:48.590]                     {
[17:44:48.590]                       {
[17:44:48.590]                         base::local({
[17:44:48.590]                           has_future <- base::requireNamespace("future", 
[17:44:48.590]                             quietly = TRUE)
[17:44:48.590]                           if (has_future) {
[17:44:48.590]                             ns <- base::getNamespace("future")
[17:44:48.590]                             version <- ns[[".package"]][["version"]]
[17:44:48.590]                             if (is.null(version)) 
[17:44:48.590]                               version <- utils::packageVersion("future")
[17:44:48.590]                           }
[17:44:48.590]                           else {
[17:44:48.590]                             version <- NULL
[17:44:48.590]                           }
[17:44:48.590]                           if (!has_future || version < "1.8.0") {
[17:44:48.590]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.590]                               "", base::R.version$version.string), 
[17:44:48.590]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:48.590]                                 base::R.version$platform, 8 * 
[17:44:48.590]                                   base::.Machine$sizeof.pointer), 
[17:44:48.590]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.590]                                 "release", "version")], collapse = " "), 
[17:44:48.590]                               hostname = base::Sys.info()[["nodename"]])
[17:44:48.590]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.590]                               info)
[17:44:48.590]                             info <- base::paste(info, collapse = "; ")
[17:44:48.590]                             if (!has_future) {
[17:44:48.590]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.590]                                 info)
[17:44:48.590]                             }
[17:44:48.590]                             else {
[17:44:48.590]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.590]                                 info, version)
[17:44:48.590]                             }
[17:44:48.590]                             base::stop(msg)
[17:44:48.590]                           }
[17:44:48.590]                         })
[17:44:48.590]                       }
[17:44:48.590]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.590]                       base::options(mc.cores = 1L)
[17:44:48.590]                     }
[17:44:48.590]                     base::local({
[17:44:48.590]                       for (pkg in "stats") {
[17:44:48.590]                         base::loadNamespace(pkg)
[17:44:48.590]                         base::library(pkg, character.only = TRUE)
[17:44:48.590]                       }
[17:44:48.590]                     })
[17:44:48.590]                   }
[17:44:48.590]                   ...future.strategy.old <- future::plan("list")
[17:44:48.590]                   options(future.plan = NULL)
[17:44:48.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.590]                 }
[17:44:48.590]                 ...future.workdir <- getwd()
[17:44:48.590]             }
[17:44:48.590]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.590]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.590]         }
[17:44:48.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.590]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.590]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.590]             base::names(...future.oldOptions))
[17:44:48.590]     }
[17:44:48.590]     if (FALSE) {
[17:44:48.590]     }
[17:44:48.590]     else {
[17:44:48.590]         if (TRUE) {
[17:44:48.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.590]                 open = "w")
[17:44:48.590]         }
[17:44:48.590]         else {
[17:44:48.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.590]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.590]         }
[17:44:48.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.590]             base::sink(type = "output", split = FALSE)
[17:44:48.590]             base::close(...future.stdout)
[17:44:48.590]         }, add = TRUE)
[17:44:48.590]     }
[17:44:48.590]     ...future.frame <- base::sys.nframe()
[17:44:48.590]     ...future.conditions <- base::list()
[17:44:48.590]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.590]     if (FALSE) {
[17:44:48.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.590]     }
[17:44:48.590]     ...future.result <- base::tryCatch({
[17:44:48.590]         base::withCallingHandlers({
[17:44:48.590]             ...future.value <- base::withVisible(base::local({
[17:44:48.590]                 withCallingHandlers({
[17:44:48.590]                   {
[17:44:48.590]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.590]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.590]                       ...future.globals.maxSize)) {
[17:44:48.590]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.590]                       on.exit(options(oopts), add = TRUE)
[17:44:48.590]                     }
[17:44:48.590]                     {
[17:44:48.590]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.590]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:48.590]                           envir = globalenv(), inherits = FALSE)
[17:44:48.590]                         ...future.FUN(...)
[17:44:48.590]                       }
[17:44:48.590]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.590]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.590]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.590]                         USE.NAMES = FALSE)
[17:44:48.590]                       do.call(mapply, args = args)
[17:44:48.590]                     }
[17:44:48.590]                   }
[17:44:48.590]                 }, immediateCondition = function(cond) {
[17:44:48.590]                   save_rds <- function (object, pathname, ...) 
[17:44:48.590]                   {
[17:44:48.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.590]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.590]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.590]                         fi_tmp[["mtime"]])
[17:44:48.590]                     }
[17:44:48.590]                     tryCatch({
[17:44:48.590]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.590]                     }, error = function(ex) {
[17:44:48.590]                       msg <- conditionMessage(ex)
[17:44:48.590]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.590]                         fi_tmp[["mtime"]], msg)
[17:44:48.590]                       ex$message <- msg
[17:44:48.590]                       stop(ex)
[17:44:48.590]                     })
[17:44:48.590]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.590]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.590]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.590]                       fi <- file.info(pathname)
[17:44:48.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.590]                         fi[["size"]], fi[["mtime"]])
[17:44:48.590]                       stop(msg)
[17:44:48.590]                     }
[17:44:48.590]                     invisible(pathname)
[17:44:48.590]                   }
[17:44:48.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.590]                     rootPath = tempdir()) 
[17:44:48.590]                   {
[17:44:48.590]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.590]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.590]                       tmpdir = path, fileext = ".rds")
[17:44:48.590]                     save_rds(obj, file)
[17:44:48.590]                   }
[17:44:48.590]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.590]                   {
[17:44:48.590]                     inherits <- base::inherits
[17:44:48.590]                     invokeRestart <- base::invokeRestart
[17:44:48.590]                     is.null <- base::is.null
[17:44:48.590]                     muffled <- FALSE
[17:44:48.590]                     if (inherits(cond, "message")) {
[17:44:48.590]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.590]                       if (muffled) 
[17:44:48.590]                         invokeRestart("muffleMessage")
[17:44:48.590]                     }
[17:44:48.590]                     else if (inherits(cond, "warning")) {
[17:44:48.590]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.590]                       if (muffled) 
[17:44:48.590]                         invokeRestart("muffleWarning")
[17:44:48.590]                     }
[17:44:48.590]                     else if (inherits(cond, "condition")) {
[17:44:48.590]                       if (!is.null(pattern)) {
[17:44:48.590]                         computeRestarts <- base::computeRestarts
[17:44:48.590]                         grepl <- base::grepl
[17:44:48.590]                         restarts <- computeRestarts(cond)
[17:44:48.590]                         for (restart in restarts) {
[17:44:48.590]                           name <- restart$name
[17:44:48.590]                           if (is.null(name)) 
[17:44:48.590]                             next
[17:44:48.590]                           if (!grepl(pattern, name)) 
[17:44:48.590]                             next
[17:44:48.590]                           invokeRestart(restart)
[17:44:48.590]                           muffled <- TRUE
[17:44:48.590]                           break
[17:44:48.590]                         }
[17:44:48.590]                       }
[17:44:48.590]                     }
[17:44:48.590]                     invisible(muffled)
[17:44:48.590]                   }
[17:44:48.590]                   muffleCondition(cond)
[17:44:48.590]                 })
[17:44:48.590]             }))
[17:44:48.590]             future::FutureResult(value = ...future.value$value, 
[17:44:48.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.590]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.590]                     ...future.globalenv.names))
[17:44:48.590]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.590]         }, condition = base::local({
[17:44:48.590]             c <- base::c
[17:44:48.590]             inherits <- base::inherits
[17:44:48.590]             invokeRestart <- base::invokeRestart
[17:44:48.590]             length <- base::length
[17:44:48.590]             list <- base::list
[17:44:48.590]             seq.int <- base::seq.int
[17:44:48.590]             signalCondition <- base::signalCondition
[17:44:48.590]             sys.calls <- base::sys.calls
[17:44:48.590]             `[[` <- base::`[[`
[17:44:48.590]             `+` <- base::`+`
[17:44:48.590]             `<<-` <- base::`<<-`
[17:44:48.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.590]                   3L)]
[17:44:48.590]             }
[17:44:48.590]             function(cond) {
[17:44:48.590]                 is_error <- inherits(cond, "error")
[17:44:48.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.590]                   NULL)
[17:44:48.590]                 if (is_error) {
[17:44:48.590]                   sessionInformation <- function() {
[17:44:48.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.590]                       search = base::search(), system = base::Sys.info())
[17:44:48.590]                   }
[17:44:48.590]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.590]                     cond$call), session = sessionInformation(), 
[17:44:48.590]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.590]                   signalCondition(cond)
[17:44:48.590]                 }
[17:44:48.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.590]                 "immediateCondition"))) {
[17:44:48.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.590]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.590]                   if (TRUE && !signal) {
[17:44:48.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.590]                     {
[17:44:48.590]                       inherits <- base::inherits
[17:44:48.590]                       invokeRestart <- base::invokeRestart
[17:44:48.590]                       is.null <- base::is.null
[17:44:48.590]                       muffled <- FALSE
[17:44:48.590]                       if (inherits(cond, "message")) {
[17:44:48.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.590]                         if (muffled) 
[17:44:48.590]                           invokeRestart("muffleMessage")
[17:44:48.590]                       }
[17:44:48.590]                       else if (inherits(cond, "warning")) {
[17:44:48.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.590]                         if (muffled) 
[17:44:48.590]                           invokeRestart("muffleWarning")
[17:44:48.590]                       }
[17:44:48.590]                       else if (inherits(cond, "condition")) {
[17:44:48.590]                         if (!is.null(pattern)) {
[17:44:48.590]                           computeRestarts <- base::computeRestarts
[17:44:48.590]                           grepl <- base::grepl
[17:44:48.590]                           restarts <- computeRestarts(cond)
[17:44:48.590]                           for (restart in restarts) {
[17:44:48.590]                             name <- restart$name
[17:44:48.590]                             if (is.null(name)) 
[17:44:48.590]                               next
[17:44:48.590]                             if (!grepl(pattern, name)) 
[17:44:48.590]                               next
[17:44:48.590]                             invokeRestart(restart)
[17:44:48.590]                             muffled <- TRUE
[17:44:48.590]                             break
[17:44:48.590]                           }
[17:44:48.590]                         }
[17:44:48.590]                       }
[17:44:48.590]                       invisible(muffled)
[17:44:48.590]                     }
[17:44:48.590]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.590]                   }
[17:44:48.590]                 }
[17:44:48.590]                 else {
[17:44:48.590]                   if (TRUE) {
[17:44:48.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.590]                     {
[17:44:48.590]                       inherits <- base::inherits
[17:44:48.590]                       invokeRestart <- base::invokeRestart
[17:44:48.590]                       is.null <- base::is.null
[17:44:48.590]                       muffled <- FALSE
[17:44:48.590]                       if (inherits(cond, "message")) {
[17:44:48.590]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.590]                         if (muffled) 
[17:44:48.590]                           invokeRestart("muffleMessage")
[17:44:48.590]                       }
[17:44:48.590]                       else if (inherits(cond, "warning")) {
[17:44:48.590]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.590]                         if (muffled) 
[17:44:48.590]                           invokeRestart("muffleWarning")
[17:44:48.590]                       }
[17:44:48.590]                       else if (inherits(cond, "condition")) {
[17:44:48.590]                         if (!is.null(pattern)) {
[17:44:48.590]                           computeRestarts <- base::computeRestarts
[17:44:48.590]                           grepl <- base::grepl
[17:44:48.590]                           restarts <- computeRestarts(cond)
[17:44:48.590]                           for (restart in restarts) {
[17:44:48.590]                             name <- restart$name
[17:44:48.590]                             if (is.null(name)) 
[17:44:48.590]                               next
[17:44:48.590]                             if (!grepl(pattern, name)) 
[17:44:48.590]                               next
[17:44:48.590]                             invokeRestart(restart)
[17:44:48.590]                             muffled <- TRUE
[17:44:48.590]                             break
[17:44:48.590]                           }
[17:44:48.590]                         }
[17:44:48.590]                       }
[17:44:48.590]                       invisible(muffled)
[17:44:48.590]                     }
[17:44:48.590]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.590]                   }
[17:44:48.590]                 }
[17:44:48.590]             }
[17:44:48.590]         }))
[17:44:48.590]     }, error = function(ex) {
[17:44:48.590]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.590]                 ...future.rng), started = ...future.startTime, 
[17:44:48.590]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.590]             version = "1.8"), class = "FutureResult")
[17:44:48.590]     }, finally = {
[17:44:48.590]         if (!identical(...future.workdir, getwd())) 
[17:44:48.590]             setwd(...future.workdir)
[17:44:48.590]         {
[17:44:48.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.590]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.590]             }
[17:44:48.590]             base::options(...future.oldOptions)
[17:44:48.590]             if (.Platform$OS.type == "windows") {
[17:44:48.590]                 old_names <- names(...future.oldEnvVars)
[17:44:48.590]                 envs <- base::Sys.getenv()
[17:44:48.590]                 names <- names(envs)
[17:44:48.590]                 common <- intersect(names, old_names)
[17:44:48.590]                 added <- setdiff(names, old_names)
[17:44:48.590]                 removed <- setdiff(old_names, names)
[17:44:48.590]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.590]                   envs[common]]
[17:44:48.590]                 NAMES <- toupper(changed)
[17:44:48.590]                 args <- list()
[17:44:48.590]                 for (kk in seq_along(NAMES)) {
[17:44:48.590]                   name <- changed[[kk]]
[17:44:48.590]                   NAME <- NAMES[[kk]]
[17:44:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.590]                     next
[17:44:48.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.590]                 }
[17:44:48.590]                 NAMES <- toupper(added)
[17:44:48.590]                 for (kk in seq_along(NAMES)) {
[17:44:48.590]                   name <- added[[kk]]
[17:44:48.590]                   NAME <- NAMES[[kk]]
[17:44:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.590]                     next
[17:44:48.590]                   args[[name]] <- ""
[17:44:48.590]                 }
[17:44:48.590]                 NAMES <- toupper(removed)
[17:44:48.590]                 for (kk in seq_along(NAMES)) {
[17:44:48.590]                   name <- removed[[kk]]
[17:44:48.590]                   NAME <- NAMES[[kk]]
[17:44:48.590]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.590]                     next
[17:44:48.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.590]                 }
[17:44:48.590]                 if (length(args) > 0) 
[17:44:48.590]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.590]             }
[17:44:48.590]             else {
[17:44:48.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.590]             }
[17:44:48.590]             {
[17:44:48.590]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.590]                   0L) {
[17:44:48.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.590]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.590]                   base::options(opts)
[17:44:48.590]                 }
[17:44:48.590]                 {
[17:44:48.590]                   {
[17:44:48.590]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.590]                     NULL
[17:44:48.590]                   }
[17:44:48.590]                   options(future.plan = NULL)
[17:44:48.590]                   if (is.na(NA_character_)) 
[17:44:48.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.590]                     .init = FALSE)
[17:44:48.590]                 }
[17:44:48.590]             }
[17:44:48.590]         }
[17:44:48.590]     })
[17:44:48.590]     if (TRUE) {
[17:44:48.590]         base::sink(type = "output", split = FALSE)
[17:44:48.590]         if (TRUE) {
[17:44:48.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.590]         }
[17:44:48.590]         else {
[17:44:48.590]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.590]         }
[17:44:48.590]         base::close(...future.stdout)
[17:44:48.590]         ...future.stdout <- NULL
[17:44:48.590]     }
[17:44:48.590]     ...future.result$conditions <- ...future.conditions
[17:44:48.590]     ...future.result$finished <- base::Sys.time()
[17:44:48.590]     ...future.result
[17:44:48.590] }
[17:44:48.593] assign_globals() ...
[17:44:48.593] List of 5
[17:44:48.593]  $ ...future.FUN            :function (n, min = 0, max = 1)  
[17:44:48.593]  $ MoreArgs                 :List of 1
[17:44:48.593]   ..$ min: num 1
[17:44:48.593]  $ ...future.elements_ii    :List of 2
[17:44:48.593]   ..$ n  :List of 2
[17:44:48.593]   .. ..$ : int 3
[17:44:48.593]   .. ..$ : int 4
[17:44:48.593]   ..$ max:List of 2
[17:44:48.593]   .. ..$ : int 4
[17:44:48.593]   .. ..$ : int 5
[17:44:48.593]  $ ...future.seeds_ii       :List of 2
[17:44:48.593]   ..$ : int [1:7] 10407 -1977952646 362645338 -1927542548 -742448269 -2030870718 1472975712
[17:44:48.593]   ..$ : int [1:7] 10407 -781199300 -1470244364 -1435938985 -1154922760 795337516 2089908040
[17:44:48.593]  $ ...future.globals.maxSize: NULL
[17:44:48.593]  - attr(*, "where")=List of 5
[17:44:48.593]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.593]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.593]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.593]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.593]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.593]  - attr(*, "resolved")= logi FALSE
[17:44:48.593]  - attr(*, "total_size")= num 2528
[17:44:48.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.593]  - attr(*, "already-done")= logi TRUE
[17:44:48.604] - copied ‘...future.FUN’ to environment
[17:44:48.604] - copied ‘MoreArgs’ to environment
[17:44:48.604] - copied ‘...future.elements_ii’ to environment
[17:44:48.605] - copied ‘...future.seeds_ii’ to environment
[17:44:48.605] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.605] assign_globals() ... done
[17:44:48.605] requestCore(): workers = 2
[17:44:48.607] MulticoreFuture started
[17:44:48.608] - Launch lazy future ... done
[17:44:48.608] run() for ‘MulticoreFuture’ ... done
[17:44:48.608] Created future:
[17:44:48.609] plan(): Setting new future strategy stack:
[17:44:48.609] List of future strategies:
[17:44:48.609] 1. sequential:
[17:44:48.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.609]    - tweaked: FALSE
[17:44:48.609]    - call: NULL
[17:44:48.610] plan(): nbrOfWorkers() = 1
[17:44:48.612] plan(): Setting new future strategy stack:
[17:44:48.612] List of future strategies:
[17:44:48.612] 1. multicore:
[17:44:48.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.612]    - tweaked: FALSE
[17:44:48.612]    - call: plan(strategy)
[17:44:48.617] plan(): nbrOfWorkers() = 2
[17:44:48.609] MulticoreFuture:
[17:44:48.609] Label: ‘future_mapply-2’
[17:44:48.609] Expression:
[17:44:48.609] {
[17:44:48.609]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.609]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.609]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.609]         on.exit(options(oopts), add = TRUE)
[17:44:48.609]     }
[17:44:48.609]     {
[17:44:48.609]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:48.609]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:48.609]                 inherits = FALSE)
[17:44:48.609]             ...future.FUN(...)
[17:44:48.609]         }
[17:44:48.609]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:48.609]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:48.609]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.609]         do.call(mapply, args = args)
[17:44:48.609]     }
[17:44:48.609] }
[17:44:48.609] Lazy evaluation: FALSE
[17:44:48.609] Asynchronous evaluation: TRUE
[17:44:48.609] Local evaluation: TRUE
[17:44:48.609] Environment: R_GlobalEnv
[17:44:48.609] Capture standard output: TRUE
[17:44:48.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.609] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.609] Packages: 1 packages (‘stats’)
[17:44:48.609] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:48.609] Resolved: TRUE
[17:44:48.609] Value: <not collected>
[17:44:48.609] Conditions captured: <none>
[17:44:48.609] Early signaling: FALSE
[17:44:48.609] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.609] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.618] Chunk #2 of 2 ... DONE
[17:44:48.619] Launching 2 futures (chunks) ... DONE
[17:44:48.619] Resolving 2 futures (chunks) ...
[17:44:48.619] resolve() on list ...
[17:44:48.619]  recursive: 0
[17:44:48.619]  length: 2
[17:44:48.619] 
[17:44:48.620] Future #1
[17:44:48.620] result() for MulticoreFuture ...
[17:44:48.621] result() for MulticoreFuture ...
[17:44:48.621] result() for MulticoreFuture ... done
[17:44:48.621] result() for MulticoreFuture ... done
[17:44:48.621] result() for MulticoreFuture ...
[17:44:48.621] result() for MulticoreFuture ... done
[17:44:48.621] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.622] - nx: 2
[17:44:48.622] - relay: TRUE
[17:44:48.622] - stdout: TRUE
[17:44:48.622] - signal: TRUE
[17:44:48.622] - resignal: FALSE
[17:44:48.622] - force: TRUE
[17:44:48.622] - relayed: [n=2] FALSE, FALSE
[17:44:48.623] - queued futures: [n=2] FALSE, FALSE
[17:44:48.623]  - until=1
[17:44:48.623]  - relaying element #1
[17:44:48.623] result() for MulticoreFuture ...
[17:44:48.623] result() for MulticoreFuture ... done
[17:44:48.623] result() for MulticoreFuture ...
[17:44:48.624] result() for MulticoreFuture ... done
[17:44:48.624] result() for MulticoreFuture ...
[17:44:48.624] result() for MulticoreFuture ... done
[17:44:48.624] result() for MulticoreFuture ...
[17:44:48.624] result() for MulticoreFuture ... done
[17:44:48.624] - relayed: [n=2] TRUE, FALSE
[17:44:48.625] - queued futures: [n=2] TRUE, FALSE
[17:44:48.625] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.625]  length: 1 (resolved future 1)
[17:44:48.625] Future #2
[17:44:48.625] result() for MulticoreFuture ...
[17:44:48.626] result() for MulticoreFuture ...
[17:44:48.626] result() for MulticoreFuture ... done
[17:44:48.626] result() for MulticoreFuture ... done
[17:44:48.626] result() for MulticoreFuture ...
[17:44:48.627] result() for MulticoreFuture ... done
[17:44:48.627] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.627] - nx: 2
[17:44:48.627] - relay: TRUE
[17:44:48.627] - stdout: TRUE
[17:44:48.627] - signal: TRUE
[17:44:48.627] - resignal: FALSE
[17:44:48.628] - force: TRUE
[17:44:48.628] - relayed: [n=2] TRUE, FALSE
[17:44:48.628] - queued futures: [n=2] TRUE, FALSE
[17:44:48.628]  - until=2
[17:44:48.628]  - relaying element #2
[17:44:48.628] result() for MulticoreFuture ...
[17:44:48.628] result() for MulticoreFuture ... done
[17:44:48.628] result() for MulticoreFuture ...
[17:44:48.629] result() for MulticoreFuture ... done
[17:44:48.629] result() for MulticoreFuture ...
[17:44:48.629] result() for MulticoreFuture ... done
[17:44:48.629] result() for MulticoreFuture ...
[17:44:48.632] result() for MulticoreFuture ... done
[17:44:48.632] - relayed: [n=2] TRUE, TRUE
[17:44:48.632] - queued futures: [n=2] TRUE, TRUE
[17:44:48.633] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.633]  length: 0 (resolved future 2)
[17:44:48.633] Relaying remaining futures
[17:44:48.633] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.633] - nx: 2
[17:44:48.634] - relay: TRUE
[17:44:48.634] - stdout: TRUE
[17:44:48.634] - signal: TRUE
[17:44:48.634] - resignal: FALSE
[17:44:48.634] - force: TRUE
[17:44:48.634] - relayed: [n=2] TRUE, TRUE
[17:44:48.634] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.635] - relayed: [n=2] TRUE, TRUE
[17:44:48.635] - queued futures: [n=2] TRUE, TRUE
[17:44:48.635] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.635] resolve() on list ... DONE
[17:44:48.635] result() for MulticoreFuture ...
[17:44:48.636] result() for MulticoreFuture ... done
[17:44:48.636] result() for MulticoreFuture ...
[17:44:48.636] result() for MulticoreFuture ... done
[17:44:48.636] result() for MulticoreFuture ...
[17:44:48.636] result() for MulticoreFuture ... done
[17:44:48.636] result() for MulticoreFuture ...
[17:44:48.636] result() for MulticoreFuture ... done
[17:44:48.637]  - Number of value chunks collected: 2
[17:44:48.637] Resolving 2 futures (chunks) ... DONE
[17:44:48.637] Reducing values from 2 chunks ...
[17:44:48.637]  - Number of values collected after concatenation: 4
[17:44:48.637]  - Number of values expected: 4
[17:44:48.637] Reducing values from 2 chunks ... DONE
[17:44:48.637] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:44:48.638] future_mapply() ...
[17:44:48.643] Number of chunks: 2
[17:44:48.643] getGlobalsAndPackagesXApply() ...
[17:44:48.644]  - future.globals: TRUE
[17:44:48.644] getGlobalsAndPackages() ...
[17:44:48.644] Searching for globals...
[17:44:48.645] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:44:48.646] Searching for globals ... DONE
[17:44:48.646] Resolving globals: FALSE
[17:44:48.646] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:44:48.647] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:44:48.647] - globals: [1] ‘FUN’
[17:44:48.647] - packages: [1] ‘stats’
[17:44:48.647] getGlobalsAndPackages() ... DONE
[17:44:48.647]  - globals found/used: [n=1] ‘FUN’
[17:44:48.647]  - needed namespaces: [n=1] ‘stats’
[17:44:48.647] Finding globals ... DONE
[17:44:48.648] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.648] List of 2
[17:44:48.648]  $ ...future.FUN:function (x, w, ...)  
[17:44:48.648]  $ MoreArgs     : NULL
[17:44:48.648]  - attr(*, "where")=List of 2
[17:44:48.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.648]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.648]  - attr(*, "resolved")= logi FALSE
[17:44:48.648]  - attr(*, "total_size")= num NA
[17:44:48.651] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:48.651] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.651] Number of futures (= number of chunks): 2
[17:44:48.651] Launching 2 futures (chunks) ...
[17:44:48.651] Chunk #1 of 2 ...
[17:44:48.651]  - Finding globals in '...' for chunk #1 ...
[17:44:48.651] getGlobalsAndPackages() ...
[17:44:48.652] Searching for globals...
[17:44:48.652] 
[17:44:48.652] Searching for globals ... DONE
[17:44:48.652] - globals: [0] <none>
[17:44:48.652] getGlobalsAndPackages() ... DONE
[17:44:48.652]    + additional globals found: [n=0] 
[17:44:48.652]    + additional namespaces needed: [n=0] 
[17:44:48.652]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.653]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.653]  - seeds: <none>
[17:44:48.653]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.653] getGlobalsAndPackages() ...
[17:44:48.653] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.653] Resolving globals: FALSE
[17:44:48.654] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:44:48.654] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.654] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.654] - packages: [1] ‘stats’
[17:44:48.654] getGlobalsAndPackages() ... DONE
[17:44:48.655] run() for ‘Future’ ...
[17:44:48.655] - state: ‘created’
[17:44:48.655] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.659] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.659]   - Field: ‘label’
[17:44:48.659]   - Field: ‘local’
[17:44:48.659]   - Field: ‘owner’
[17:44:48.659]   - Field: ‘envir’
[17:44:48.659]   - Field: ‘workers’
[17:44:48.659]   - Field: ‘packages’
[17:44:48.660]   - Field: ‘gc’
[17:44:48.660]   - Field: ‘job’
[17:44:48.660]   - Field: ‘conditions’
[17:44:48.660]   - Field: ‘expr’
[17:44:48.660]   - Field: ‘uuid’
[17:44:48.660]   - Field: ‘seed’
[17:44:48.660]   - Field: ‘version’
[17:44:48.660]   - Field: ‘result’
[17:44:48.660]   - Field: ‘asynchronous’
[17:44:48.660]   - Field: ‘calls’
[17:44:48.660]   - Field: ‘globals’
[17:44:48.661]   - Field: ‘stdout’
[17:44:48.661]   - Field: ‘earlySignal’
[17:44:48.661]   - Field: ‘lazy’
[17:44:48.661]   - Field: ‘state’
[17:44:48.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.664] - Launch lazy future ...
[17:44:48.664] Packages needed by the future expression (n = 1): ‘stats’
[17:44:48.664] Packages needed by future strategies (n = 0): <none>
[17:44:48.665] {
[17:44:48.665]     {
[17:44:48.665]         {
[17:44:48.665]             ...future.startTime <- base::Sys.time()
[17:44:48.665]             {
[17:44:48.665]                 {
[17:44:48.665]                   {
[17:44:48.665]                     {
[17:44:48.665]                       {
[17:44:48.665]                         base::local({
[17:44:48.665]                           has_future <- base::requireNamespace("future", 
[17:44:48.665]                             quietly = TRUE)
[17:44:48.665]                           if (has_future) {
[17:44:48.665]                             ns <- base::getNamespace("future")
[17:44:48.665]                             version <- ns[[".package"]][["version"]]
[17:44:48.665]                             if (is.null(version)) 
[17:44:48.665]                               version <- utils::packageVersion("future")
[17:44:48.665]                           }
[17:44:48.665]                           else {
[17:44:48.665]                             version <- NULL
[17:44:48.665]                           }
[17:44:48.665]                           if (!has_future || version < "1.8.0") {
[17:44:48.665]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.665]                               "", base::R.version$version.string), 
[17:44:48.665]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:48.665]                                 base::R.version$platform, 8 * 
[17:44:48.665]                                   base::.Machine$sizeof.pointer), 
[17:44:48.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.665]                                 "release", "version")], collapse = " "), 
[17:44:48.665]                               hostname = base::Sys.info()[["nodename"]])
[17:44:48.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.665]                               info)
[17:44:48.665]                             info <- base::paste(info, collapse = "; ")
[17:44:48.665]                             if (!has_future) {
[17:44:48.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.665]                                 info)
[17:44:48.665]                             }
[17:44:48.665]                             else {
[17:44:48.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.665]                                 info, version)
[17:44:48.665]                             }
[17:44:48.665]                             base::stop(msg)
[17:44:48.665]                           }
[17:44:48.665]                         })
[17:44:48.665]                       }
[17:44:48.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.665]                       base::options(mc.cores = 1L)
[17:44:48.665]                     }
[17:44:48.665]                     base::local({
[17:44:48.665]                       for (pkg in "stats") {
[17:44:48.665]                         base::loadNamespace(pkg)
[17:44:48.665]                         base::library(pkg, character.only = TRUE)
[17:44:48.665]                       }
[17:44:48.665]                     })
[17:44:48.665]                   }
[17:44:48.665]                   ...future.strategy.old <- future::plan("list")
[17:44:48.665]                   options(future.plan = NULL)
[17:44:48.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.665]                 }
[17:44:48.665]                 ...future.workdir <- getwd()
[17:44:48.665]             }
[17:44:48.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.665]         }
[17:44:48.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.665]             base::names(...future.oldOptions))
[17:44:48.665]     }
[17:44:48.665]     if (FALSE) {
[17:44:48.665]     }
[17:44:48.665]     else {
[17:44:48.665]         if (TRUE) {
[17:44:48.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.665]                 open = "w")
[17:44:48.665]         }
[17:44:48.665]         else {
[17:44:48.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.665]         }
[17:44:48.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.665]             base::sink(type = "output", split = FALSE)
[17:44:48.665]             base::close(...future.stdout)
[17:44:48.665]         }, add = TRUE)
[17:44:48.665]     }
[17:44:48.665]     ...future.frame <- base::sys.nframe()
[17:44:48.665]     ...future.conditions <- base::list()
[17:44:48.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.665]     if (FALSE) {
[17:44:48.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.665]     }
[17:44:48.665]     ...future.result <- base::tryCatch({
[17:44:48.665]         base::withCallingHandlers({
[17:44:48.665]             ...future.value <- base::withVisible(base::local({
[17:44:48.665]                 withCallingHandlers({
[17:44:48.665]                   {
[17:44:48.665]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.665]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.665]                       ...future.globals.maxSize)) {
[17:44:48.665]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.665]                       on.exit(options(oopts), add = TRUE)
[17:44:48.665]                     }
[17:44:48.665]                     {
[17:44:48.665]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.665]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.665]                         USE.NAMES = FALSE)
[17:44:48.665]                       do.call(mapply, args = args)
[17:44:48.665]                     }
[17:44:48.665]                   }
[17:44:48.665]                 }, immediateCondition = function(cond) {
[17:44:48.665]                   save_rds <- function (object, pathname, ...) 
[17:44:48.665]                   {
[17:44:48.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.665]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.665]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.665]                         fi_tmp[["mtime"]])
[17:44:48.665]                     }
[17:44:48.665]                     tryCatch({
[17:44:48.665]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.665]                     }, error = function(ex) {
[17:44:48.665]                       msg <- conditionMessage(ex)
[17:44:48.665]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.665]                         fi_tmp[["mtime"]], msg)
[17:44:48.665]                       ex$message <- msg
[17:44:48.665]                       stop(ex)
[17:44:48.665]                     })
[17:44:48.665]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.665]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.665]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.665]                       fi <- file.info(pathname)
[17:44:48.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.665]                         fi[["size"]], fi[["mtime"]])
[17:44:48.665]                       stop(msg)
[17:44:48.665]                     }
[17:44:48.665]                     invisible(pathname)
[17:44:48.665]                   }
[17:44:48.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.665]                     rootPath = tempdir()) 
[17:44:48.665]                   {
[17:44:48.665]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.665]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.665]                       tmpdir = path, fileext = ".rds")
[17:44:48.665]                     save_rds(obj, file)
[17:44:48.665]                   }
[17:44:48.665]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.665]                   {
[17:44:48.665]                     inherits <- base::inherits
[17:44:48.665]                     invokeRestart <- base::invokeRestart
[17:44:48.665]                     is.null <- base::is.null
[17:44:48.665]                     muffled <- FALSE
[17:44:48.665]                     if (inherits(cond, "message")) {
[17:44:48.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.665]                       if (muffled) 
[17:44:48.665]                         invokeRestart("muffleMessage")
[17:44:48.665]                     }
[17:44:48.665]                     else if (inherits(cond, "warning")) {
[17:44:48.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.665]                       if (muffled) 
[17:44:48.665]                         invokeRestart("muffleWarning")
[17:44:48.665]                     }
[17:44:48.665]                     else if (inherits(cond, "condition")) {
[17:44:48.665]                       if (!is.null(pattern)) {
[17:44:48.665]                         computeRestarts <- base::computeRestarts
[17:44:48.665]                         grepl <- base::grepl
[17:44:48.665]                         restarts <- computeRestarts(cond)
[17:44:48.665]                         for (restart in restarts) {
[17:44:48.665]                           name <- restart$name
[17:44:48.665]                           if (is.null(name)) 
[17:44:48.665]                             next
[17:44:48.665]                           if (!grepl(pattern, name)) 
[17:44:48.665]                             next
[17:44:48.665]                           invokeRestart(restart)
[17:44:48.665]                           muffled <- TRUE
[17:44:48.665]                           break
[17:44:48.665]                         }
[17:44:48.665]                       }
[17:44:48.665]                     }
[17:44:48.665]                     invisible(muffled)
[17:44:48.665]                   }
[17:44:48.665]                   muffleCondition(cond)
[17:44:48.665]                 })
[17:44:48.665]             }))
[17:44:48.665]             future::FutureResult(value = ...future.value$value, 
[17:44:48.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.665]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.665]                     ...future.globalenv.names))
[17:44:48.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.665]         }, condition = base::local({
[17:44:48.665]             c <- base::c
[17:44:48.665]             inherits <- base::inherits
[17:44:48.665]             invokeRestart <- base::invokeRestart
[17:44:48.665]             length <- base::length
[17:44:48.665]             list <- base::list
[17:44:48.665]             seq.int <- base::seq.int
[17:44:48.665]             signalCondition <- base::signalCondition
[17:44:48.665]             sys.calls <- base::sys.calls
[17:44:48.665]             `[[` <- base::`[[`
[17:44:48.665]             `+` <- base::`+`
[17:44:48.665]             `<<-` <- base::`<<-`
[17:44:48.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.665]                   3L)]
[17:44:48.665]             }
[17:44:48.665]             function(cond) {
[17:44:48.665]                 is_error <- inherits(cond, "error")
[17:44:48.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.665]                   NULL)
[17:44:48.665]                 if (is_error) {
[17:44:48.665]                   sessionInformation <- function() {
[17:44:48.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.665]                       search = base::search(), system = base::Sys.info())
[17:44:48.665]                   }
[17:44:48.665]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.665]                     cond$call), session = sessionInformation(), 
[17:44:48.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.665]                   signalCondition(cond)
[17:44:48.665]                 }
[17:44:48.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.665]                 "immediateCondition"))) {
[17:44:48.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.665]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.665]                   if (TRUE && !signal) {
[17:44:48.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.665]                     {
[17:44:48.665]                       inherits <- base::inherits
[17:44:48.665]                       invokeRestart <- base::invokeRestart
[17:44:48.665]                       is.null <- base::is.null
[17:44:48.665]                       muffled <- FALSE
[17:44:48.665]                       if (inherits(cond, "message")) {
[17:44:48.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.665]                         if (muffled) 
[17:44:48.665]                           invokeRestart("muffleMessage")
[17:44:48.665]                       }
[17:44:48.665]                       else if (inherits(cond, "warning")) {
[17:44:48.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.665]                         if (muffled) 
[17:44:48.665]                           invokeRestart("muffleWarning")
[17:44:48.665]                       }
[17:44:48.665]                       else if (inherits(cond, "condition")) {
[17:44:48.665]                         if (!is.null(pattern)) {
[17:44:48.665]                           computeRestarts <- base::computeRestarts
[17:44:48.665]                           grepl <- base::grepl
[17:44:48.665]                           restarts <- computeRestarts(cond)
[17:44:48.665]                           for (restart in restarts) {
[17:44:48.665]                             name <- restart$name
[17:44:48.665]                             if (is.null(name)) 
[17:44:48.665]                               next
[17:44:48.665]                             if (!grepl(pattern, name)) 
[17:44:48.665]                               next
[17:44:48.665]                             invokeRestart(restart)
[17:44:48.665]                             muffled <- TRUE
[17:44:48.665]                             break
[17:44:48.665]                           }
[17:44:48.665]                         }
[17:44:48.665]                       }
[17:44:48.665]                       invisible(muffled)
[17:44:48.665]                     }
[17:44:48.665]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.665]                   }
[17:44:48.665]                 }
[17:44:48.665]                 else {
[17:44:48.665]                   if (TRUE) {
[17:44:48.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.665]                     {
[17:44:48.665]                       inherits <- base::inherits
[17:44:48.665]                       invokeRestart <- base::invokeRestart
[17:44:48.665]                       is.null <- base::is.null
[17:44:48.665]                       muffled <- FALSE
[17:44:48.665]                       if (inherits(cond, "message")) {
[17:44:48.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.665]                         if (muffled) 
[17:44:48.665]                           invokeRestart("muffleMessage")
[17:44:48.665]                       }
[17:44:48.665]                       else if (inherits(cond, "warning")) {
[17:44:48.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.665]                         if (muffled) 
[17:44:48.665]                           invokeRestart("muffleWarning")
[17:44:48.665]                       }
[17:44:48.665]                       else if (inherits(cond, "condition")) {
[17:44:48.665]                         if (!is.null(pattern)) {
[17:44:48.665]                           computeRestarts <- base::computeRestarts
[17:44:48.665]                           grepl <- base::grepl
[17:44:48.665]                           restarts <- computeRestarts(cond)
[17:44:48.665]                           for (restart in restarts) {
[17:44:48.665]                             name <- restart$name
[17:44:48.665]                             if (is.null(name)) 
[17:44:48.665]                               next
[17:44:48.665]                             if (!grepl(pattern, name)) 
[17:44:48.665]                               next
[17:44:48.665]                             invokeRestart(restart)
[17:44:48.665]                             muffled <- TRUE
[17:44:48.665]                             break
[17:44:48.665]                           }
[17:44:48.665]                         }
[17:44:48.665]                       }
[17:44:48.665]                       invisible(muffled)
[17:44:48.665]                     }
[17:44:48.665]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.665]                   }
[17:44:48.665]                 }
[17:44:48.665]             }
[17:44:48.665]         }))
[17:44:48.665]     }, error = function(ex) {
[17:44:48.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.665]                 ...future.rng), started = ...future.startTime, 
[17:44:48.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.665]             version = "1.8"), class = "FutureResult")
[17:44:48.665]     }, finally = {
[17:44:48.665]         if (!identical(...future.workdir, getwd())) 
[17:44:48.665]             setwd(...future.workdir)
[17:44:48.665]         {
[17:44:48.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.665]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.665]             }
[17:44:48.665]             base::options(...future.oldOptions)
[17:44:48.665]             if (.Platform$OS.type == "windows") {
[17:44:48.665]                 old_names <- names(...future.oldEnvVars)
[17:44:48.665]                 envs <- base::Sys.getenv()
[17:44:48.665]                 names <- names(envs)
[17:44:48.665]                 common <- intersect(names, old_names)
[17:44:48.665]                 added <- setdiff(names, old_names)
[17:44:48.665]                 removed <- setdiff(old_names, names)
[17:44:48.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.665]                   envs[common]]
[17:44:48.665]                 NAMES <- toupper(changed)
[17:44:48.665]                 args <- list()
[17:44:48.665]                 for (kk in seq_along(NAMES)) {
[17:44:48.665]                   name <- changed[[kk]]
[17:44:48.665]                   NAME <- NAMES[[kk]]
[17:44:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.665]                     next
[17:44:48.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.665]                 }
[17:44:48.665]                 NAMES <- toupper(added)
[17:44:48.665]                 for (kk in seq_along(NAMES)) {
[17:44:48.665]                   name <- added[[kk]]
[17:44:48.665]                   NAME <- NAMES[[kk]]
[17:44:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.665]                     next
[17:44:48.665]                   args[[name]] <- ""
[17:44:48.665]                 }
[17:44:48.665]                 NAMES <- toupper(removed)
[17:44:48.665]                 for (kk in seq_along(NAMES)) {
[17:44:48.665]                   name <- removed[[kk]]
[17:44:48.665]                   NAME <- NAMES[[kk]]
[17:44:48.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.665]                     next
[17:44:48.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.665]                 }
[17:44:48.665]                 if (length(args) > 0) 
[17:44:48.665]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.665]             }
[17:44:48.665]             else {
[17:44:48.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.665]             }
[17:44:48.665]             {
[17:44:48.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.665]                   0L) {
[17:44:48.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.665]                   base::options(opts)
[17:44:48.665]                 }
[17:44:48.665]                 {
[17:44:48.665]                   {
[17:44:48.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.665]                     NULL
[17:44:48.665]                   }
[17:44:48.665]                   options(future.plan = NULL)
[17:44:48.665]                   if (is.na(NA_character_)) 
[17:44:48.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.665]                     .init = FALSE)
[17:44:48.665]                 }
[17:44:48.665]             }
[17:44:48.665]         }
[17:44:48.665]     })
[17:44:48.665]     if (TRUE) {
[17:44:48.665]         base::sink(type = "output", split = FALSE)
[17:44:48.665]         if (TRUE) {
[17:44:48.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.665]         }
[17:44:48.665]         else {
[17:44:48.665]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.665]         }
[17:44:48.665]         base::close(...future.stdout)
[17:44:48.665]         ...future.stdout <- NULL
[17:44:48.665]     }
[17:44:48.665]     ...future.result$conditions <- ...future.conditions
[17:44:48.665]     ...future.result$finished <- base::Sys.time()
[17:44:48.665]     ...future.result
[17:44:48.665] }
[17:44:48.667] assign_globals() ...
[17:44:48.667] List of 5
[17:44:48.667]  $ ...future.FUN            :function (x, w, ...)  
[17:44:48.667]  $ MoreArgs                 : NULL
[17:44:48.667]  $ ...future.elements_ii    :List of 2
[17:44:48.667]   ..$ :List of 2
[17:44:48.667]   .. ..$ : num [1:10] 0.0814 0.1221 0.8509 0.9581 0.9499 ...
[17:44:48.667]   .. ..$ : num [1:10] 0.0654 0.1503 0.3632 0.0556 0.015 ...
[17:44:48.667]   ..$ :List of 2
[17:44:48.667]   .. ..$ : num [1:10] 5 8 11 4 6 8 7 5 5 9
[17:44:48.667]   .. ..$ : num [1:10] 6 8 5 6 8 6 7 5 8 8
[17:44:48.667]  $ ...future.seeds_ii       : NULL
[17:44:48.667]  $ ...future.globals.maxSize: NULL
[17:44:48.667]  - attr(*, "where")=List of 5
[17:44:48.667]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.667]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.667]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.667]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.667]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.667]  - attr(*, "resolved")= logi FALSE
[17:44:48.667]  - attr(*, "total_size")= num 2120
[17:44:48.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.667]  - attr(*, "already-done")= logi TRUE
[17:44:48.674] - copied ‘...future.FUN’ to environment
[17:44:48.674] - copied ‘MoreArgs’ to environment
[17:44:48.675] - copied ‘...future.elements_ii’ to environment
[17:44:48.675] - copied ‘...future.seeds_ii’ to environment
[17:44:48.675] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.675] assign_globals() ... done
[17:44:48.675] requestCore(): workers = 2
[17:44:48.677] MulticoreFuture started
[17:44:48.678] - Launch lazy future ... done
[17:44:48.678] run() for ‘MulticoreFuture’ ... done
[17:44:48.678] Created future:
[17:44:48.679] plan(): Setting new future strategy stack:
[17:44:48.679] List of future strategies:
[17:44:48.679] 1. sequential:
[17:44:48.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.679]    - tweaked: FALSE
[17:44:48.679]    - call: NULL
[17:44:48.680] plan(): nbrOfWorkers() = 1
[17:44:48.682] plan(): Setting new future strategy stack:
[17:44:48.683] List of future strategies:
[17:44:48.683] 1. multicore:
[17:44:48.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.683]    - tweaked: FALSE
[17:44:48.683]    - call: plan(strategy)
[17:44:48.688] plan(): nbrOfWorkers() = 2
[17:44:48.679] MulticoreFuture:
[17:44:48.679] Label: ‘future_Map-1’
[17:44:48.679] Expression:
[17:44:48.679] {
[17:44:48.679]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.679]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.679]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.679]         on.exit(options(oopts), add = TRUE)
[17:44:48.679]     }
[17:44:48.679]     {
[17:44:48.679]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.679]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.679]         do.call(mapply, args = args)
[17:44:48.679]     }
[17:44:48.679] }
[17:44:48.679] Lazy evaluation: FALSE
[17:44:48.679] Asynchronous evaluation: TRUE
[17:44:48.679] Local evaluation: TRUE
[17:44:48.679] Environment: R_GlobalEnv
[17:44:48.679] Capture standard output: TRUE
[17:44:48.679] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.679] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.679] Packages: 1 packages (‘stats’)
[17:44:48.679] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.679] Resolved: TRUE
[17:44:48.679] Value: <not collected>
[17:44:48.679] Conditions captured: <none>
[17:44:48.679] Early signaling: FALSE
[17:44:48.679] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.679] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.689] Chunk #1 of 2 ... DONE
[17:44:48.689] Chunk #2 of 2 ...
[17:44:48.689]  - Finding globals in '...' for chunk #2 ...
[17:44:48.690] getGlobalsAndPackages() ...
[17:44:48.690] Searching for globals...
[17:44:48.690] 
[17:44:48.690] Searching for globals ... DONE
[17:44:48.691] - globals: [0] <none>
[17:44:48.691] getGlobalsAndPackages() ... DONE
[17:44:48.691]    + additional globals found: [n=0] 
[17:44:48.691]    + additional namespaces needed: [n=0] 
[17:44:48.691]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.692]  - seeds: <none>
[17:44:48.692]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.692] getGlobalsAndPackages() ...
[17:44:48.692] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.692] Resolving globals: FALSE
[17:44:48.693] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:44:48.694] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.694] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.694] - packages: [1] ‘stats’
[17:44:48.695] getGlobalsAndPackages() ... DONE
[17:44:48.695] run() for ‘Future’ ...
[17:44:48.695] - state: ‘created’
[17:44:48.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.700] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.701]   - Field: ‘label’
[17:44:48.701]   - Field: ‘local’
[17:44:48.701]   - Field: ‘owner’
[17:44:48.701]   - Field: ‘envir’
[17:44:48.701]   - Field: ‘workers’
[17:44:48.701]   - Field: ‘packages’
[17:44:48.702]   - Field: ‘gc’
[17:44:48.702]   - Field: ‘job’
[17:44:48.702]   - Field: ‘conditions’
[17:44:48.702]   - Field: ‘expr’
[17:44:48.702]   - Field: ‘uuid’
[17:44:48.702]   - Field: ‘seed’
[17:44:48.702]   - Field: ‘version’
[17:44:48.703]   - Field: ‘result’
[17:44:48.703]   - Field: ‘asynchronous’
[17:44:48.703]   - Field: ‘calls’
[17:44:48.703]   - Field: ‘globals’
[17:44:48.703]   - Field: ‘stdout’
[17:44:48.703]   - Field: ‘earlySignal’
[17:44:48.703]   - Field: ‘lazy’
[17:44:48.704]   - Field: ‘state’
[17:44:48.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.704] - Launch lazy future ...
[17:44:48.704] Packages needed by the future expression (n = 1): ‘stats’
[17:44:48.705] Packages needed by future strategies (n = 0): <none>
[17:44:48.706] {
[17:44:48.706]     {
[17:44:48.706]         {
[17:44:48.706]             ...future.startTime <- base::Sys.time()
[17:44:48.706]             {
[17:44:48.706]                 {
[17:44:48.706]                   {
[17:44:48.706]                     {
[17:44:48.706]                       {
[17:44:48.706]                         base::local({
[17:44:48.706]                           has_future <- base::requireNamespace("future", 
[17:44:48.706]                             quietly = TRUE)
[17:44:48.706]                           if (has_future) {
[17:44:48.706]                             ns <- base::getNamespace("future")
[17:44:48.706]                             version <- ns[[".package"]][["version"]]
[17:44:48.706]                             if (is.null(version)) 
[17:44:48.706]                               version <- utils::packageVersion("future")
[17:44:48.706]                           }
[17:44:48.706]                           else {
[17:44:48.706]                             version <- NULL
[17:44:48.706]                           }
[17:44:48.706]                           if (!has_future || version < "1.8.0") {
[17:44:48.706]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.706]                               "", base::R.version$version.string), 
[17:44:48.706]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:48.706]                                 base::R.version$platform, 8 * 
[17:44:48.706]                                   base::.Machine$sizeof.pointer), 
[17:44:48.706]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.706]                                 "release", "version")], collapse = " "), 
[17:44:48.706]                               hostname = base::Sys.info()[["nodename"]])
[17:44:48.706]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.706]                               info)
[17:44:48.706]                             info <- base::paste(info, collapse = "; ")
[17:44:48.706]                             if (!has_future) {
[17:44:48.706]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.706]                                 info)
[17:44:48.706]                             }
[17:44:48.706]                             else {
[17:44:48.706]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.706]                                 info, version)
[17:44:48.706]                             }
[17:44:48.706]                             base::stop(msg)
[17:44:48.706]                           }
[17:44:48.706]                         })
[17:44:48.706]                       }
[17:44:48.706]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.706]                       base::options(mc.cores = 1L)
[17:44:48.706]                     }
[17:44:48.706]                     base::local({
[17:44:48.706]                       for (pkg in "stats") {
[17:44:48.706]                         base::loadNamespace(pkg)
[17:44:48.706]                         base::library(pkg, character.only = TRUE)
[17:44:48.706]                       }
[17:44:48.706]                     })
[17:44:48.706]                   }
[17:44:48.706]                   ...future.strategy.old <- future::plan("list")
[17:44:48.706]                   options(future.plan = NULL)
[17:44:48.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.706]                 }
[17:44:48.706]                 ...future.workdir <- getwd()
[17:44:48.706]             }
[17:44:48.706]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.706]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.706]         }
[17:44:48.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.706]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.706]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.706]             base::names(...future.oldOptions))
[17:44:48.706]     }
[17:44:48.706]     if (FALSE) {
[17:44:48.706]     }
[17:44:48.706]     else {
[17:44:48.706]         if (TRUE) {
[17:44:48.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.706]                 open = "w")
[17:44:48.706]         }
[17:44:48.706]         else {
[17:44:48.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.706]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.706]         }
[17:44:48.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.706]             base::sink(type = "output", split = FALSE)
[17:44:48.706]             base::close(...future.stdout)
[17:44:48.706]         }, add = TRUE)
[17:44:48.706]     }
[17:44:48.706]     ...future.frame <- base::sys.nframe()
[17:44:48.706]     ...future.conditions <- base::list()
[17:44:48.706]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.706]     if (FALSE) {
[17:44:48.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.706]     }
[17:44:48.706]     ...future.result <- base::tryCatch({
[17:44:48.706]         base::withCallingHandlers({
[17:44:48.706]             ...future.value <- base::withVisible(base::local({
[17:44:48.706]                 withCallingHandlers({
[17:44:48.706]                   {
[17:44:48.706]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.706]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.706]                       ...future.globals.maxSize)) {
[17:44:48.706]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.706]                       on.exit(options(oopts), add = TRUE)
[17:44:48.706]                     }
[17:44:48.706]                     {
[17:44:48.706]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.706]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.706]                         USE.NAMES = FALSE)
[17:44:48.706]                       do.call(mapply, args = args)
[17:44:48.706]                     }
[17:44:48.706]                   }
[17:44:48.706]                 }, immediateCondition = function(cond) {
[17:44:48.706]                   save_rds <- function (object, pathname, ...) 
[17:44:48.706]                   {
[17:44:48.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.706]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.706]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.706]                         fi_tmp[["mtime"]])
[17:44:48.706]                     }
[17:44:48.706]                     tryCatch({
[17:44:48.706]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.706]                     }, error = function(ex) {
[17:44:48.706]                       msg <- conditionMessage(ex)
[17:44:48.706]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.706]                         fi_tmp[["mtime"]], msg)
[17:44:48.706]                       ex$message <- msg
[17:44:48.706]                       stop(ex)
[17:44:48.706]                     })
[17:44:48.706]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.706]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.706]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.706]                       fi <- file.info(pathname)
[17:44:48.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.706]                         fi[["size"]], fi[["mtime"]])
[17:44:48.706]                       stop(msg)
[17:44:48.706]                     }
[17:44:48.706]                     invisible(pathname)
[17:44:48.706]                   }
[17:44:48.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.706]                     rootPath = tempdir()) 
[17:44:48.706]                   {
[17:44:48.706]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.706]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.706]                       tmpdir = path, fileext = ".rds")
[17:44:48.706]                     save_rds(obj, file)
[17:44:48.706]                   }
[17:44:48.706]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.706]                   {
[17:44:48.706]                     inherits <- base::inherits
[17:44:48.706]                     invokeRestart <- base::invokeRestart
[17:44:48.706]                     is.null <- base::is.null
[17:44:48.706]                     muffled <- FALSE
[17:44:48.706]                     if (inherits(cond, "message")) {
[17:44:48.706]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.706]                       if (muffled) 
[17:44:48.706]                         invokeRestart("muffleMessage")
[17:44:48.706]                     }
[17:44:48.706]                     else if (inherits(cond, "warning")) {
[17:44:48.706]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.706]                       if (muffled) 
[17:44:48.706]                         invokeRestart("muffleWarning")
[17:44:48.706]                     }
[17:44:48.706]                     else if (inherits(cond, "condition")) {
[17:44:48.706]                       if (!is.null(pattern)) {
[17:44:48.706]                         computeRestarts <- base::computeRestarts
[17:44:48.706]                         grepl <- base::grepl
[17:44:48.706]                         restarts <- computeRestarts(cond)
[17:44:48.706]                         for (restart in restarts) {
[17:44:48.706]                           name <- restart$name
[17:44:48.706]                           if (is.null(name)) 
[17:44:48.706]                             next
[17:44:48.706]                           if (!grepl(pattern, name)) 
[17:44:48.706]                             next
[17:44:48.706]                           invokeRestart(restart)
[17:44:48.706]                           muffled <- TRUE
[17:44:48.706]                           break
[17:44:48.706]                         }
[17:44:48.706]                       }
[17:44:48.706]                     }
[17:44:48.706]                     invisible(muffled)
[17:44:48.706]                   }
[17:44:48.706]                   muffleCondition(cond)
[17:44:48.706]                 })
[17:44:48.706]             }))
[17:44:48.706]             future::FutureResult(value = ...future.value$value, 
[17:44:48.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.706]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.706]                     ...future.globalenv.names))
[17:44:48.706]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.706]         }, condition = base::local({
[17:44:48.706]             c <- base::c
[17:44:48.706]             inherits <- base::inherits
[17:44:48.706]             invokeRestart <- base::invokeRestart
[17:44:48.706]             length <- base::length
[17:44:48.706]             list <- base::list
[17:44:48.706]             seq.int <- base::seq.int
[17:44:48.706]             signalCondition <- base::signalCondition
[17:44:48.706]             sys.calls <- base::sys.calls
[17:44:48.706]             `[[` <- base::`[[`
[17:44:48.706]             `+` <- base::`+`
[17:44:48.706]             `<<-` <- base::`<<-`
[17:44:48.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.706]                   3L)]
[17:44:48.706]             }
[17:44:48.706]             function(cond) {
[17:44:48.706]                 is_error <- inherits(cond, "error")
[17:44:48.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.706]                   NULL)
[17:44:48.706]                 if (is_error) {
[17:44:48.706]                   sessionInformation <- function() {
[17:44:48.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.706]                       search = base::search(), system = base::Sys.info())
[17:44:48.706]                   }
[17:44:48.706]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.706]                     cond$call), session = sessionInformation(), 
[17:44:48.706]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.706]                   signalCondition(cond)
[17:44:48.706]                 }
[17:44:48.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.706]                 "immediateCondition"))) {
[17:44:48.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.706]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.706]                   if (TRUE && !signal) {
[17:44:48.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.706]                     {
[17:44:48.706]                       inherits <- base::inherits
[17:44:48.706]                       invokeRestart <- base::invokeRestart
[17:44:48.706]                       is.null <- base::is.null
[17:44:48.706]                       muffled <- FALSE
[17:44:48.706]                       if (inherits(cond, "message")) {
[17:44:48.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.706]                         if (muffled) 
[17:44:48.706]                           invokeRestart("muffleMessage")
[17:44:48.706]                       }
[17:44:48.706]                       else if (inherits(cond, "warning")) {
[17:44:48.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.706]                         if (muffled) 
[17:44:48.706]                           invokeRestart("muffleWarning")
[17:44:48.706]                       }
[17:44:48.706]                       else if (inherits(cond, "condition")) {
[17:44:48.706]                         if (!is.null(pattern)) {
[17:44:48.706]                           computeRestarts <- base::computeRestarts
[17:44:48.706]                           grepl <- base::grepl
[17:44:48.706]                           restarts <- computeRestarts(cond)
[17:44:48.706]                           for (restart in restarts) {
[17:44:48.706]                             name <- restart$name
[17:44:48.706]                             if (is.null(name)) 
[17:44:48.706]                               next
[17:44:48.706]                             if (!grepl(pattern, name)) 
[17:44:48.706]                               next
[17:44:48.706]                             invokeRestart(restart)
[17:44:48.706]                             muffled <- TRUE
[17:44:48.706]                             break
[17:44:48.706]                           }
[17:44:48.706]                         }
[17:44:48.706]                       }
[17:44:48.706]                       invisible(muffled)
[17:44:48.706]                     }
[17:44:48.706]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.706]                   }
[17:44:48.706]                 }
[17:44:48.706]                 else {
[17:44:48.706]                   if (TRUE) {
[17:44:48.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.706]                     {
[17:44:48.706]                       inherits <- base::inherits
[17:44:48.706]                       invokeRestart <- base::invokeRestart
[17:44:48.706]                       is.null <- base::is.null
[17:44:48.706]                       muffled <- FALSE
[17:44:48.706]                       if (inherits(cond, "message")) {
[17:44:48.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.706]                         if (muffled) 
[17:44:48.706]                           invokeRestart("muffleMessage")
[17:44:48.706]                       }
[17:44:48.706]                       else if (inherits(cond, "warning")) {
[17:44:48.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.706]                         if (muffled) 
[17:44:48.706]                           invokeRestart("muffleWarning")
[17:44:48.706]                       }
[17:44:48.706]                       else if (inherits(cond, "condition")) {
[17:44:48.706]                         if (!is.null(pattern)) {
[17:44:48.706]                           computeRestarts <- base::computeRestarts
[17:44:48.706]                           grepl <- base::grepl
[17:44:48.706]                           restarts <- computeRestarts(cond)
[17:44:48.706]                           for (restart in restarts) {
[17:44:48.706]                             name <- restart$name
[17:44:48.706]                             if (is.null(name)) 
[17:44:48.706]                               next
[17:44:48.706]                             if (!grepl(pattern, name)) 
[17:44:48.706]                               next
[17:44:48.706]                             invokeRestart(restart)
[17:44:48.706]                             muffled <- TRUE
[17:44:48.706]                             break
[17:44:48.706]                           }
[17:44:48.706]                         }
[17:44:48.706]                       }
[17:44:48.706]                       invisible(muffled)
[17:44:48.706]                     }
[17:44:48.706]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.706]                   }
[17:44:48.706]                 }
[17:44:48.706]             }
[17:44:48.706]         }))
[17:44:48.706]     }, error = function(ex) {
[17:44:48.706]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.706]                 ...future.rng), started = ...future.startTime, 
[17:44:48.706]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.706]             version = "1.8"), class = "FutureResult")
[17:44:48.706]     }, finally = {
[17:44:48.706]         if (!identical(...future.workdir, getwd())) 
[17:44:48.706]             setwd(...future.workdir)
[17:44:48.706]         {
[17:44:48.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.706]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.706]             }
[17:44:48.706]             base::options(...future.oldOptions)
[17:44:48.706]             if (.Platform$OS.type == "windows") {
[17:44:48.706]                 old_names <- names(...future.oldEnvVars)
[17:44:48.706]                 envs <- base::Sys.getenv()
[17:44:48.706]                 names <- names(envs)
[17:44:48.706]                 common <- intersect(names, old_names)
[17:44:48.706]                 added <- setdiff(names, old_names)
[17:44:48.706]                 removed <- setdiff(old_names, names)
[17:44:48.706]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.706]                   envs[common]]
[17:44:48.706]                 NAMES <- toupper(changed)
[17:44:48.706]                 args <- list()
[17:44:48.706]                 for (kk in seq_along(NAMES)) {
[17:44:48.706]                   name <- changed[[kk]]
[17:44:48.706]                   NAME <- NAMES[[kk]]
[17:44:48.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.706]                     next
[17:44:48.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.706]                 }
[17:44:48.706]                 NAMES <- toupper(added)
[17:44:48.706]                 for (kk in seq_along(NAMES)) {
[17:44:48.706]                   name <- added[[kk]]
[17:44:48.706]                   NAME <- NAMES[[kk]]
[17:44:48.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.706]                     next
[17:44:48.706]                   args[[name]] <- ""
[17:44:48.706]                 }
[17:44:48.706]                 NAMES <- toupper(removed)
[17:44:48.706]                 for (kk in seq_along(NAMES)) {
[17:44:48.706]                   name <- removed[[kk]]
[17:44:48.706]                   NAME <- NAMES[[kk]]
[17:44:48.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.706]                     next
[17:44:48.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.706]                 }
[17:44:48.706]                 if (length(args) > 0) 
[17:44:48.706]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.706]             }
[17:44:48.706]             else {
[17:44:48.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.706]             }
[17:44:48.706]             {
[17:44:48.706]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.706]                   0L) {
[17:44:48.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.706]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.706]                   base::options(opts)
[17:44:48.706]                 }
[17:44:48.706]                 {
[17:44:48.706]                   {
[17:44:48.706]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.706]                     NULL
[17:44:48.706]                   }
[17:44:48.706]                   options(future.plan = NULL)
[17:44:48.706]                   if (is.na(NA_character_)) 
[17:44:48.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.706]                     .init = FALSE)
[17:44:48.706]                 }
[17:44:48.706]             }
[17:44:48.706]         }
[17:44:48.706]     })
[17:44:48.706]     if (TRUE) {
[17:44:48.706]         base::sink(type = "output", split = FALSE)
[17:44:48.706]         if (TRUE) {
[17:44:48.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.706]         }
[17:44:48.706]         else {
[17:44:48.706]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.706]         }
[17:44:48.706]         base::close(...future.stdout)
[17:44:48.706]         ...future.stdout <- NULL
[17:44:48.706]     }
[17:44:48.706]     ...future.result$conditions <- ...future.conditions
[17:44:48.706]     ...future.result$finished <- base::Sys.time()
[17:44:48.706]     ...future.result
[17:44:48.706] }
[17:44:48.709] assign_globals() ...
[17:44:48.709] List of 5
[17:44:48.709]  $ ...future.FUN            :function (x, w, ...)  
[17:44:48.709]  $ MoreArgs                 : NULL
[17:44:48.709]  $ ...future.elements_ii    :List of 2
[17:44:48.709]   ..$ :List of 3
[17:44:48.709]   .. ..$ : num [1:10] 0.0294 0.4772 0.7511 0.654 0.3059 ...
[17:44:48.709]   .. ..$ : num [1:10] 0.547 0.883 0.985 0.48 0.494 ...
[17:44:48.709]   .. ..$ : num [1:10] 0.9607 0.1793 0.0301 0.9954 0.455 ...
[17:44:48.709]   ..$ :List of 3
[17:44:48.709]   .. ..$ : num [1:10] 6 4 5 7 7 4 8 8 3 6
[17:44:48.709]   .. ..$ : num [1:10] 8 6 6 6 5 7 5 6 7 8
[17:44:48.709]   .. ..$ : num [1:10] 5 3 3 5 3 4 8 6 7 5
[17:44:48.709]  $ ...future.seeds_ii       : NULL
[17:44:48.709]  $ ...future.globals.maxSize: NULL
[17:44:48.709]  - attr(*, "where")=List of 5
[17:44:48.709]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.709]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.709]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.709]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.709]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.709]  - attr(*, "resolved")= logi FALSE
[17:44:48.709]  - attr(*, "total_size")= num 2472
[17:44:48.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.709]  - attr(*, "already-done")= logi TRUE
[17:44:48.725] - copied ‘...future.FUN’ to environment
[17:44:48.725] - copied ‘MoreArgs’ to environment
[17:44:48.726] - copied ‘...future.elements_ii’ to environment
[17:44:48.726] - copied ‘...future.seeds_ii’ to environment
[17:44:48.726] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.726] assign_globals() ... done
[17:44:48.726] requestCore(): workers = 2
[17:44:48.729] MulticoreFuture started
[17:44:48.729] - Launch lazy future ... done
[17:44:48.730] run() for ‘MulticoreFuture’ ... done
[17:44:48.730] Created future:
[17:44:48.731] plan(): Setting new future strategy stack:
[17:44:48.731] List of future strategies:
[17:44:48.731] 1. sequential:
[17:44:48.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.731]    - tweaked: FALSE
[17:44:48.731]    - call: NULL
[17:44:48.733] plan(): nbrOfWorkers() = 1
[17:44:48.735] plan(): Setting new future strategy stack:
[17:44:48.735] List of future strategies:
[17:44:48.735] 1. multicore:
[17:44:48.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.735]    - tweaked: FALSE
[17:44:48.735]    - call: plan(strategy)
[17:44:48.742] plan(): nbrOfWorkers() = 2
[17:44:48.731] MulticoreFuture:
[17:44:48.731] Label: ‘future_Map-2’
[17:44:48.731] Expression:
[17:44:48.731] {
[17:44:48.731]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.731]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.731]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.731]         on.exit(options(oopts), add = TRUE)
[17:44:48.731]     }
[17:44:48.731]     {
[17:44:48.731]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.731]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.731]         do.call(mapply, args = args)
[17:44:48.731]     }
[17:44:48.731] }
[17:44:48.731] Lazy evaluation: FALSE
[17:44:48.731] Asynchronous evaluation: TRUE
[17:44:48.731] Local evaluation: TRUE
[17:44:48.731] Environment: R_GlobalEnv
[17:44:48.731] Capture standard output: TRUE
[17:44:48.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.731] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.731] Packages: 1 packages (‘stats’)
[17:44:48.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.731] Resolved: TRUE
[17:44:48.731] Value: <not collected>
[17:44:48.731] Conditions captured: <none>
[17:44:48.731] Early signaling: FALSE
[17:44:48.731] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.731] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.743] Chunk #2 of 2 ... DONE
[17:44:48.743] Launching 2 futures (chunks) ... DONE
[17:44:48.744] Resolving 2 futures (chunks) ...
[17:44:48.744] resolve() on list ...
[17:44:48.744]  recursive: 0
[17:44:48.744]  length: 2
[17:44:48.745] 
[17:44:48.745] Future #1
[17:44:48.745] result() for MulticoreFuture ...
[17:44:48.747] result() for MulticoreFuture ...
[17:44:48.747] result() for MulticoreFuture ... done
[17:44:48.747] result() for MulticoreFuture ... done
[17:44:48.748] result() for MulticoreFuture ...
[17:44:48.748] result() for MulticoreFuture ... done
[17:44:48.748] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.748] - nx: 2
[17:44:48.749] - relay: TRUE
[17:44:48.749] - stdout: TRUE
[17:44:48.749] - signal: TRUE
[17:44:48.750] - resignal: FALSE
[17:44:48.750] - force: TRUE
[17:44:48.750] - relayed: [n=2] FALSE, FALSE
[17:44:48.750] - queued futures: [n=2] FALSE, FALSE
[17:44:48.751]  - until=1
[17:44:48.751]  - relaying element #1
[17:44:48.751] result() for MulticoreFuture ...
[17:44:48.752] result() for MulticoreFuture ... done
[17:44:48.752] result() for MulticoreFuture ...
[17:44:48.752] result() for MulticoreFuture ... done
[17:44:48.753] result() for MulticoreFuture ...
[17:44:48.753] result() for MulticoreFuture ... done
[17:44:48.753] result() for MulticoreFuture ...
[17:44:48.753] result() for MulticoreFuture ... done
[17:44:48.754] - relayed: [n=2] TRUE, FALSE
[17:44:48.754] - queued futures: [n=2] TRUE, FALSE
[17:44:48.754] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.755]  length: 1 (resolved future 1)
[17:44:48.755] Future #2
[17:44:48.755] result() for MulticoreFuture ...
[17:44:48.756] result() for MulticoreFuture ...
[17:44:48.757] result() for MulticoreFuture ... done
[17:44:48.757] result() for MulticoreFuture ... done
[17:44:48.757] result() for MulticoreFuture ...
[17:44:48.757] result() for MulticoreFuture ... done
[17:44:48.758] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.758] - nx: 2
[17:44:48.758] - relay: TRUE
[17:44:48.758] - stdout: TRUE
[17:44:48.759] - signal: TRUE
[17:44:48.759] - resignal: FALSE
[17:44:48.759] - force: TRUE
[17:44:48.759] - relayed: [n=2] TRUE, FALSE
[17:44:48.759] - queued futures: [n=2] TRUE, FALSE
[17:44:48.760]  - until=2
[17:44:48.760]  - relaying element #2
[17:44:48.760] result() for MulticoreFuture ...
[17:44:48.760] result() for MulticoreFuture ... done
[17:44:48.760] result() for MulticoreFuture ...
[17:44:48.761] result() for MulticoreFuture ... done
[17:44:48.761] result() for MulticoreFuture ...
[17:44:48.761] result() for MulticoreFuture ... done
[17:44:48.761] result() for MulticoreFuture ...
[17:44:48.762] result() for MulticoreFuture ... done
[17:44:48.762] - relayed: [n=2] TRUE, TRUE
[17:44:48.762] - queued futures: [n=2] TRUE, TRUE
[17:44:48.762] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.762]  length: 0 (resolved future 2)
[17:44:48.763] Relaying remaining futures
[17:44:48.763] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.763] - nx: 2
[17:44:48.763] - relay: TRUE
[17:44:48.763] - stdout: TRUE
[17:44:48.764] - signal: TRUE
[17:44:48.764] - resignal: FALSE
[17:44:48.764] - force: TRUE
[17:44:48.764] - relayed: [n=2] TRUE, TRUE
[17:44:48.764] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.765] - relayed: [n=2] TRUE, TRUE
[17:44:48.765] - queued futures: [n=2] TRUE, TRUE
[17:44:48.765] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.765] resolve() on list ... DONE
[17:44:48.766] result() for MulticoreFuture ...
[17:44:48.766] result() for MulticoreFuture ... done
[17:44:48.766] result() for MulticoreFuture ...
[17:44:48.766] result() for MulticoreFuture ... done
[17:44:48.771] result() for MulticoreFuture ...
[17:44:48.771] result() for MulticoreFuture ... done
[17:44:48.771] result() for MulticoreFuture ...
[17:44:48.772] result() for MulticoreFuture ... done
[17:44:48.772]  - Number of value chunks collected: 2
[17:44:48.772] Resolving 2 futures (chunks) ... DONE
[17:44:48.773] Reducing values from 2 chunks ...
[17:44:48.773]  - Number of values collected after concatenation: 5
[17:44:48.773]  - Number of values expected: 5
[17:44:48.773] Reducing values from 2 chunks ... DONE
[17:44:48.774] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:44:48.778] future_mapply() ...
[17:44:48.783] Number of chunks: 2
[17:44:48.783] getGlobalsAndPackagesXApply() ...
[17:44:48.784]  - future.globals: TRUE
[17:44:48.784] getGlobalsAndPackages() ...
[17:44:48.784] Searching for globals...
[17:44:48.785] - globals found: [1] ‘FUN’
[17:44:48.785] Searching for globals ... DONE
[17:44:48.785] Resolving globals: FALSE
[17:44:48.785] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:48.786] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:48.786] - globals: [1] ‘FUN’
[17:44:48.786] 
[17:44:48.786] getGlobalsAndPackages() ... DONE
[17:44:48.786]  - globals found/used: [n=1] ‘FUN’
[17:44:48.786]  - needed namespaces: [n=0] 
[17:44:48.787] Finding globals ... DONE
[17:44:48.787] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.787] List of 2
[17:44:48.787]  $ ...future.FUN:function (e1, e2)  
[17:44:48.787]  $ MoreArgs     : NULL
[17:44:48.787]  - attr(*, "where")=List of 2
[17:44:48.787]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.787]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.787]  - attr(*, "resolved")= logi FALSE
[17:44:48.787]  - attr(*, "total_size")= num NA
[17:44:48.790] Packages to be attached in all futures: [n=0] 
[17:44:48.790] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.790] Number of futures (= number of chunks): 2
[17:44:48.790] Launching 2 futures (chunks) ...
[17:44:48.790] Chunk #1 of 2 ...
[17:44:48.790]  - Finding globals in '...' for chunk #1 ...
[17:44:48.791] getGlobalsAndPackages() ...
[17:44:48.791] Searching for globals...
[17:44:48.791] 
[17:44:48.791] Searching for globals ... DONE
[17:44:48.791] - globals: [0] <none>
[17:44:48.791] getGlobalsAndPackages() ... DONE
[17:44:48.791]    + additional globals found: [n=0] 
[17:44:48.791]    + additional namespaces needed: [n=0] 
[17:44:48.792]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.792]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.792]  - seeds: <none>
[17:44:48.792]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.792] getGlobalsAndPackages() ...
[17:44:48.792] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.792] Resolving globals: FALSE
[17:44:48.793] The total size of the 5 globals is 168 bytes (168 bytes)
[17:44:48.793] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.793] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.793] 
[17:44:48.793] getGlobalsAndPackages() ... DONE
[17:44:48.794] run() for ‘Future’ ...
[17:44:48.794] - state: ‘created’
[17:44:48.794] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.798] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.798]   - Field: ‘label’
[17:44:48.798]   - Field: ‘local’
[17:44:48.798]   - Field: ‘owner’
[17:44:48.798]   - Field: ‘envir’
[17:44:48.798]   - Field: ‘workers’
[17:44:48.798]   - Field: ‘packages’
[17:44:48.799]   - Field: ‘gc’
[17:44:48.799]   - Field: ‘job’
[17:44:48.799]   - Field: ‘conditions’
[17:44:48.799]   - Field: ‘expr’
[17:44:48.799]   - Field: ‘uuid’
[17:44:48.799]   - Field: ‘seed’
[17:44:48.799]   - Field: ‘version’
[17:44:48.799]   - Field: ‘result’
[17:44:48.799]   - Field: ‘asynchronous’
[17:44:48.799]   - Field: ‘calls’
[17:44:48.800]   - Field: ‘globals’
[17:44:48.800]   - Field: ‘stdout’
[17:44:48.800]   - Field: ‘earlySignal’
[17:44:48.800]   - Field: ‘lazy’
[17:44:48.800]   - Field: ‘state’
[17:44:48.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.800] - Launch lazy future ...
[17:44:48.800] Packages needed by the future expression (n = 0): <none>
[17:44:48.801] Packages needed by future strategies (n = 0): <none>
[17:44:48.801] {
[17:44:48.801]     {
[17:44:48.801]         {
[17:44:48.801]             ...future.startTime <- base::Sys.time()
[17:44:48.801]             {
[17:44:48.801]                 {
[17:44:48.801]                   {
[17:44:48.801]                     {
[17:44:48.801]                       base::local({
[17:44:48.801]                         has_future <- base::requireNamespace("future", 
[17:44:48.801]                           quietly = TRUE)
[17:44:48.801]                         if (has_future) {
[17:44:48.801]                           ns <- base::getNamespace("future")
[17:44:48.801]                           version <- ns[[".package"]][["version"]]
[17:44:48.801]                           if (is.null(version)) 
[17:44:48.801]                             version <- utils::packageVersion("future")
[17:44:48.801]                         }
[17:44:48.801]                         else {
[17:44:48.801]                           version <- NULL
[17:44:48.801]                         }
[17:44:48.801]                         if (!has_future || version < "1.8.0") {
[17:44:48.801]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.801]                             "", base::R.version$version.string), 
[17:44:48.801]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.801]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.801]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.801]                               "release", "version")], collapse = " "), 
[17:44:48.801]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.801]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.801]                             info)
[17:44:48.801]                           info <- base::paste(info, collapse = "; ")
[17:44:48.801]                           if (!has_future) {
[17:44:48.801]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.801]                               info)
[17:44:48.801]                           }
[17:44:48.801]                           else {
[17:44:48.801]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.801]                               info, version)
[17:44:48.801]                           }
[17:44:48.801]                           base::stop(msg)
[17:44:48.801]                         }
[17:44:48.801]                       })
[17:44:48.801]                     }
[17:44:48.801]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.801]                     base::options(mc.cores = 1L)
[17:44:48.801]                   }
[17:44:48.801]                   ...future.strategy.old <- future::plan("list")
[17:44:48.801]                   options(future.plan = NULL)
[17:44:48.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.801]                 }
[17:44:48.801]                 ...future.workdir <- getwd()
[17:44:48.801]             }
[17:44:48.801]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.801]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.801]         }
[17:44:48.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.801]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.801]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.801]             base::names(...future.oldOptions))
[17:44:48.801]     }
[17:44:48.801]     if (FALSE) {
[17:44:48.801]     }
[17:44:48.801]     else {
[17:44:48.801]         if (TRUE) {
[17:44:48.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.801]                 open = "w")
[17:44:48.801]         }
[17:44:48.801]         else {
[17:44:48.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.801]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.801]         }
[17:44:48.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.801]             base::sink(type = "output", split = FALSE)
[17:44:48.801]             base::close(...future.stdout)
[17:44:48.801]         }, add = TRUE)
[17:44:48.801]     }
[17:44:48.801]     ...future.frame <- base::sys.nframe()
[17:44:48.801]     ...future.conditions <- base::list()
[17:44:48.801]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.801]     if (FALSE) {
[17:44:48.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.801]     }
[17:44:48.801]     ...future.result <- base::tryCatch({
[17:44:48.801]         base::withCallingHandlers({
[17:44:48.801]             ...future.value <- base::withVisible(base::local({
[17:44:48.801]                 withCallingHandlers({
[17:44:48.801]                   {
[17:44:48.801]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.801]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.801]                       ...future.globals.maxSize)) {
[17:44:48.801]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.801]                       on.exit(options(oopts), add = TRUE)
[17:44:48.801]                     }
[17:44:48.801]                     {
[17:44:48.801]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.801]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.801]                         USE.NAMES = FALSE)
[17:44:48.801]                       do.call(mapply, args = args)
[17:44:48.801]                     }
[17:44:48.801]                   }
[17:44:48.801]                 }, immediateCondition = function(cond) {
[17:44:48.801]                   save_rds <- function (object, pathname, ...) 
[17:44:48.801]                   {
[17:44:48.801]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.801]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.801]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.801]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.801]                         fi_tmp[["mtime"]])
[17:44:48.801]                     }
[17:44:48.801]                     tryCatch({
[17:44:48.801]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.801]                     }, error = function(ex) {
[17:44:48.801]                       msg <- conditionMessage(ex)
[17:44:48.801]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.801]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.801]                         fi_tmp[["mtime"]], msg)
[17:44:48.801]                       ex$message <- msg
[17:44:48.801]                       stop(ex)
[17:44:48.801]                     })
[17:44:48.801]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.801]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.801]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.801]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.801]                       fi <- file.info(pathname)
[17:44:48.801]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.801]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.801]                         fi[["size"]], fi[["mtime"]])
[17:44:48.801]                       stop(msg)
[17:44:48.801]                     }
[17:44:48.801]                     invisible(pathname)
[17:44:48.801]                   }
[17:44:48.801]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.801]                     rootPath = tempdir()) 
[17:44:48.801]                   {
[17:44:48.801]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.801]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.801]                       tmpdir = path, fileext = ".rds")
[17:44:48.801]                     save_rds(obj, file)
[17:44:48.801]                   }
[17:44:48.801]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.801]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.801]                   {
[17:44:48.801]                     inherits <- base::inherits
[17:44:48.801]                     invokeRestart <- base::invokeRestart
[17:44:48.801]                     is.null <- base::is.null
[17:44:48.801]                     muffled <- FALSE
[17:44:48.801]                     if (inherits(cond, "message")) {
[17:44:48.801]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.801]                       if (muffled) 
[17:44:48.801]                         invokeRestart("muffleMessage")
[17:44:48.801]                     }
[17:44:48.801]                     else if (inherits(cond, "warning")) {
[17:44:48.801]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.801]                       if (muffled) 
[17:44:48.801]                         invokeRestart("muffleWarning")
[17:44:48.801]                     }
[17:44:48.801]                     else if (inherits(cond, "condition")) {
[17:44:48.801]                       if (!is.null(pattern)) {
[17:44:48.801]                         computeRestarts <- base::computeRestarts
[17:44:48.801]                         grepl <- base::grepl
[17:44:48.801]                         restarts <- computeRestarts(cond)
[17:44:48.801]                         for (restart in restarts) {
[17:44:48.801]                           name <- restart$name
[17:44:48.801]                           if (is.null(name)) 
[17:44:48.801]                             next
[17:44:48.801]                           if (!grepl(pattern, name)) 
[17:44:48.801]                             next
[17:44:48.801]                           invokeRestart(restart)
[17:44:48.801]                           muffled <- TRUE
[17:44:48.801]                           break
[17:44:48.801]                         }
[17:44:48.801]                       }
[17:44:48.801]                     }
[17:44:48.801]                     invisible(muffled)
[17:44:48.801]                   }
[17:44:48.801]                   muffleCondition(cond)
[17:44:48.801]                 })
[17:44:48.801]             }))
[17:44:48.801]             future::FutureResult(value = ...future.value$value, 
[17:44:48.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.801]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.801]                     ...future.globalenv.names))
[17:44:48.801]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.801]         }, condition = base::local({
[17:44:48.801]             c <- base::c
[17:44:48.801]             inherits <- base::inherits
[17:44:48.801]             invokeRestart <- base::invokeRestart
[17:44:48.801]             length <- base::length
[17:44:48.801]             list <- base::list
[17:44:48.801]             seq.int <- base::seq.int
[17:44:48.801]             signalCondition <- base::signalCondition
[17:44:48.801]             sys.calls <- base::sys.calls
[17:44:48.801]             `[[` <- base::`[[`
[17:44:48.801]             `+` <- base::`+`
[17:44:48.801]             `<<-` <- base::`<<-`
[17:44:48.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.801]                   3L)]
[17:44:48.801]             }
[17:44:48.801]             function(cond) {
[17:44:48.801]                 is_error <- inherits(cond, "error")
[17:44:48.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.801]                   NULL)
[17:44:48.801]                 if (is_error) {
[17:44:48.801]                   sessionInformation <- function() {
[17:44:48.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.801]                       search = base::search(), system = base::Sys.info())
[17:44:48.801]                   }
[17:44:48.801]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.801]                     cond$call), session = sessionInformation(), 
[17:44:48.801]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.801]                   signalCondition(cond)
[17:44:48.801]                 }
[17:44:48.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.801]                 "immediateCondition"))) {
[17:44:48.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.801]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.801]                   if (TRUE && !signal) {
[17:44:48.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.801]                     {
[17:44:48.801]                       inherits <- base::inherits
[17:44:48.801]                       invokeRestart <- base::invokeRestart
[17:44:48.801]                       is.null <- base::is.null
[17:44:48.801]                       muffled <- FALSE
[17:44:48.801]                       if (inherits(cond, "message")) {
[17:44:48.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.801]                         if (muffled) 
[17:44:48.801]                           invokeRestart("muffleMessage")
[17:44:48.801]                       }
[17:44:48.801]                       else if (inherits(cond, "warning")) {
[17:44:48.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.801]                         if (muffled) 
[17:44:48.801]                           invokeRestart("muffleWarning")
[17:44:48.801]                       }
[17:44:48.801]                       else if (inherits(cond, "condition")) {
[17:44:48.801]                         if (!is.null(pattern)) {
[17:44:48.801]                           computeRestarts <- base::computeRestarts
[17:44:48.801]                           grepl <- base::grepl
[17:44:48.801]                           restarts <- computeRestarts(cond)
[17:44:48.801]                           for (restart in restarts) {
[17:44:48.801]                             name <- restart$name
[17:44:48.801]                             if (is.null(name)) 
[17:44:48.801]                               next
[17:44:48.801]                             if (!grepl(pattern, name)) 
[17:44:48.801]                               next
[17:44:48.801]                             invokeRestart(restart)
[17:44:48.801]                             muffled <- TRUE
[17:44:48.801]                             break
[17:44:48.801]                           }
[17:44:48.801]                         }
[17:44:48.801]                       }
[17:44:48.801]                       invisible(muffled)
[17:44:48.801]                     }
[17:44:48.801]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.801]                   }
[17:44:48.801]                 }
[17:44:48.801]                 else {
[17:44:48.801]                   if (TRUE) {
[17:44:48.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.801]                     {
[17:44:48.801]                       inherits <- base::inherits
[17:44:48.801]                       invokeRestart <- base::invokeRestart
[17:44:48.801]                       is.null <- base::is.null
[17:44:48.801]                       muffled <- FALSE
[17:44:48.801]                       if (inherits(cond, "message")) {
[17:44:48.801]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.801]                         if (muffled) 
[17:44:48.801]                           invokeRestart("muffleMessage")
[17:44:48.801]                       }
[17:44:48.801]                       else if (inherits(cond, "warning")) {
[17:44:48.801]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.801]                         if (muffled) 
[17:44:48.801]                           invokeRestart("muffleWarning")
[17:44:48.801]                       }
[17:44:48.801]                       else if (inherits(cond, "condition")) {
[17:44:48.801]                         if (!is.null(pattern)) {
[17:44:48.801]                           computeRestarts <- base::computeRestarts
[17:44:48.801]                           grepl <- base::grepl
[17:44:48.801]                           restarts <- computeRestarts(cond)
[17:44:48.801]                           for (restart in restarts) {
[17:44:48.801]                             name <- restart$name
[17:44:48.801]                             if (is.null(name)) 
[17:44:48.801]                               next
[17:44:48.801]                             if (!grepl(pattern, name)) 
[17:44:48.801]                               next
[17:44:48.801]                             invokeRestart(restart)
[17:44:48.801]                             muffled <- TRUE
[17:44:48.801]                             break
[17:44:48.801]                           }
[17:44:48.801]                         }
[17:44:48.801]                       }
[17:44:48.801]                       invisible(muffled)
[17:44:48.801]                     }
[17:44:48.801]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.801]                   }
[17:44:48.801]                 }
[17:44:48.801]             }
[17:44:48.801]         }))
[17:44:48.801]     }, error = function(ex) {
[17:44:48.801]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.801]                 ...future.rng), started = ...future.startTime, 
[17:44:48.801]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.801]             version = "1.8"), class = "FutureResult")
[17:44:48.801]     }, finally = {
[17:44:48.801]         if (!identical(...future.workdir, getwd())) 
[17:44:48.801]             setwd(...future.workdir)
[17:44:48.801]         {
[17:44:48.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.801]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.801]             }
[17:44:48.801]             base::options(...future.oldOptions)
[17:44:48.801]             if (.Platform$OS.type == "windows") {
[17:44:48.801]                 old_names <- names(...future.oldEnvVars)
[17:44:48.801]                 envs <- base::Sys.getenv()
[17:44:48.801]                 names <- names(envs)
[17:44:48.801]                 common <- intersect(names, old_names)
[17:44:48.801]                 added <- setdiff(names, old_names)
[17:44:48.801]                 removed <- setdiff(old_names, names)
[17:44:48.801]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.801]                   envs[common]]
[17:44:48.801]                 NAMES <- toupper(changed)
[17:44:48.801]                 args <- list()
[17:44:48.801]                 for (kk in seq_along(NAMES)) {
[17:44:48.801]                   name <- changed[[kk]]
[17:44:48.801]                   NAME <- NAMES[[kk]]
[17:44:48.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.801]                     next
[17:44:48.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.801]                 }
[17:44:48.801]                 NAMES <- toupper(added)
[17:44:48.801]                 for (kk in seq_along(NAMES)) {
[17:44:48.801]                   name <- added[[kk]]
[17:44:48.801]                   NAME <- NAMES[[kk]]
[17:44:48.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.801]                     next
[17:44:48.801]                   args[[name]] <- ""
[17:44:48.801]                 }
[17:44:48.801]                 NAMES <- toupper(removed)
[17:44:48.801]                 for (kk in seq_along(NAMES)) {
[17:44:48.801]                   name <- removed[[kk]]
[17:44:48.801]                   NAME <- NAMES[[kk]]
[17:44:48.801]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.801]                     next
[17:44:48.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.801]                 }
[17:44:48.801]                 if (length(args) > 0) 
[17:44:48.801]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.801]             }
[17:44:48.801]             else {
[17:44:48.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.801]             }
[17:44:48.801]             {
[17:44:48.801]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.801]                   0L) {
[17:44:48.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.801]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.801]                   base::options(opts)
[17:44:48.801]                 }
[17:44:48.801]                 {
[17:44:48.801]                   {
[17:44:48.801]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.801]                     NULL
[17:44:48.801]                   }
[17:44:48.801]                   options(future.plan = NULL)
[17:44:48.801]                   if (is.na(NA_character_)) 
[17:44:48.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.801]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.801]                     .init = FALSE)
[17:44:48.801]                 }
[17:44:48.801]             }
[17:44:48.801]         }
[17:44:48.801]     })
[17:44:48.801]     if (TRUE) {
[17:44:48.801]         base::sink(type = "output", split = FALSE)
[17:44:48.801]         if (TRUE) {
[17:44:48.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.801]         }
[17:44:48.801]         else {
[17:44:48.801]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.801]         }
[17:44:48.801]         base::close(...future.stdout)
[17:44:48.801]         ...future.stdout <- NULL
[17:44:48.801]     }
[17:44:48.801]     ...future.result$conditions <- ...future.conditions
[17:44:48.801]     ...future.result$finished <- base::Sys.time()
[17:44:48.801]     ...future.result
[17:44:48.801] }
[17:44:48.804] assign_globals() ...
[17:44:48.804] List of 5
[17:44:48.804]  $ ...future.FUN            :function (e1, e2)  
[17:44:48.804]  $ MoreArgs                 : NULL
[17:44:48.804]  $ ...future.elements_ii    :List of 2
[17:44:48.804]   ..$ :List of 1
[17:44:48.804]   .. ..$ : num 1
[17:44:48.804]   ..$ :List of 1
[17:44:48.804]   .. ..$ : int 1
[17:44:48.804]  $ ...future.seeds_ii       : NULL
[17:44:48.804]  $ ...future.globals.maxSize: NULL
[17:44:48.804]  - attr(*, "where")=List of 5
[17:44:48.804]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.804]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.804]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.804]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.804]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.804]  - attr(*, "resolved")= logi FALSE
[17:44:48.804]  - attr(*, "total_size")= num 168
[17:44:48.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.804]  - attr(*, "already-done")= logi TRUE
[17:44:48.812] - copied ‘...future.FUN’ to environment
[17:44:48.813] - copied ‘MoreArgs’ to environment
[17:44:48.813] - copied ‘...future.elements_ii’ to environment
[17:44:48.813] - copied ‘...future.seeds_ii’ to environment
[17:44:48.813] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.813] assign_globals() ... done
[17:44:48.813] requestCore(): workers = 2
[17:44:48.816] MulticoreFuture started
[17:44:48.816] - Launch lazy future ... done
[17:44:48.816] run() for ‘MulticoreFuture’ ... done
[17:44:48.817] Created future:
[17:44:48.817] plan(): Setting new future strategy stack:
[17:44:48.817] List of future strategies:
[17:44:48.817] 1. sequential:
[17:44:48.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.817]    - tweaked: FALSE
[17:44:48.817]    - call: NULL
[17:44:48.818] plan(): nbrOfWorkers() = 1
[17:44:48.821] plan(): Setting new future strategy stack:
[17:44:48.821] List of future strategies:
[17:44:48.821] 1. multicore:
[17:44:48.821]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.821]    - tweaked: FALSE
[17:44:48.821]    - call: plan(strategy)
[17:44:48.827] plan(): nbrOfWorkers() = 2
[17:44:48.817] MulticoreFuture:
[17:44:48.817] Label: ‘future_Map-1’
[17:44:48.817] Expression:
[17:44:48.817] {
[17:44:48.817]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.817]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.817]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.817]         on.exit(options(oopts), add = TRUE)
[17:44:48.817]     }
[17:44:48.817]     {
[17:44:48.817]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.817]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.817]         do.call(mapply, args = args)
[17:44:48.817]     }
[17:44:48.817] }
[17:44:48.817] Lazy evaluation: FALSE
[17:44:48.817] Asynchronous evaluation: TRUE
[17:44:48.817] Local evaluation: TRUE
[17:44:48.817] Environment: R_GlobalEnv
[17:44:48.817] Capture standard output: TRUE
[17:44:48.817] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.817] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.817] Packages: <none>
[17:44:48.817] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.817] Resolved: TRUE
[17:44:48.817] Value: <not collected>
[17:44:48.817] Conditions captured: <none>
[17:44:48.817] Early signaling: FALSE
[17:44:48.817] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.817] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.828] Chunk #1 of 2 ... DONE
[17:44:48.828] Chunk #2 of 2 ...
[17:44:48.828]  - Finding globals in '...' for chunk #2 ...
[17:44:48.828] getGlobalsAndPackages() ...
[17:44:48.828] Searching for globals...
[17:44:48.829] 
[17:44:48.829] Searching for globals ... DONE
[17:44:48.829] - globals: [0] <none>
[17:44:48.829] getGlobalsAndPackages() ... DONE
[17:44:48.830]    + additional globals found: [n=0] 
[17:44:48.830]    + additional namespaces needed: [n=0] 
[17:44:48.830]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.830]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.830]  - seeds: <none>
[17:44:48.830]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.830] getGlobalsAndPackages() ...
[17:44:48.831] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.831] Resolving globals: FALSE
[17:44:48.832] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:48.833] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.833] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.833] 
[17:44:48.833] getGlobalsAndPackages() ... DONE
[17:44:48.834] run() for ‘Future’ ...
[17:44:48.834] - state: ‘created’
[17:44:48.834] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.839] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.839] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.839]   - Field: ‘label’
[17:44:48.839]   - Field: ‘local’
[17:44:48.839]   - Field: ‘owner’
[17:44:48.840]   - Field: ‘envir’
[17:44:48.840]   - Field: ‘workers’
[17:44:48.840]   - Field: ‘packages’
[17:44:48.840]   - Field: ‘gc’
[17:44:48.840]   - Field: ‘job’
[17:44:48.840]   - Field: ‘conditions’
[17:44:48.841]   - Field: ‘expr’
[17:44:48.841]   - Field: ‘uuid’
[17:44:48.841]   - Field: ‘seed’
[17:44:48.841]   - Field: ‘version’
[17:44:48.841]   - Field: ‘result’
[17:44:48.841]   - Field: ‘asynchronous’
[17:44:48.841]   - Field: ‘calls’
[17:44:48.842]   - Field: ‘globals’
[17:44:48.842]   - Field: ‘stdout’
[17:44:48.842]   - Field: ‘earlySignal’
[17:44:48.842]   - Field: ‘lazy’
[17:44:48.842]   - Field: ‘state’
[17:44:48.842] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.842] - Launch lazy future ...
[17:44:48.843] Packages needed by the future expression (n = 0): <none>
[17:44:48.843] Packages needed by future strategies (n = 0): <none>
[17:44:48.844] {
[17:44:48.844]     {
[17:44:48.844]         {
[17:44:48.844]             ...future.startTime <- base::Sys.time()
[17:44:48.844]             {
[17:44:48.844]                 {
[17:44:48.844]                   {
[17:44:48.844]                     {
[17:44:48.844]                       base::local({
[17:44:48.844]                         has_future <- base::requireNamespace("future", 
[17:44:48.844]                           quietly = TRUE)
[17:44:48.844]                         if (has_future) {
[17:44:48.844]                           ns <- base::getNamespace("future")
[17:44:48.844]                           version <- ns[[".package"]][["version"]]
[17:44:48.844]                           if (is.null(version)) 
[17:44:48.844]                             version <- utils::packageVersion("future")
[17:44:48.844]                         }
[17:44:48.844]                         else {
[17:44:48.844]                           version <- NULL
[17:44:48.844]                         }
[17:44:48.844]                         if (!has_future || version < "1.8.0") {
[17:44:48.844]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.844]                             "", base::R.version$version.string), 
[17:44:48.844]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.844]                               "release", "version")], collapse = " "), 
[17:44:48.844]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.844]                             info)
[17:44:48.844]                           info <- base::paste(info, collapse = "; ")
[17:44:48.844]                           if (!has_future) {
[17:44:48.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.844]                               info)
[17:44:48.844]                           }
[17:44:48.844]                           else {
[17:44:48.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.844]                               info, version)
[17:44:48.844]                           }
[17:44:48.844]                           base::stop(msg)
[17:44:48.844]                         }
[17:44:48.844]                       })
[17:44:48.844]                     }
[17:44:48.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.844]                     base::options(mc.cores = 1L)
[17:44:48.844]                   }
[17:44:48.844]                   ...future.strategy.old <- future::plan("list")
[17:44:48.844]                   options(future.plan = NULL)
[17:44:48.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.844]                 }
[17:44:48.844]                 ...future.workdir <- getwd()
[17:44:48.844]             }
[17:44:48.844]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.844]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.844]         }
[17:44:48.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.844]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.844]             base::names(...future.oldOptions))
[17:44:48.844]     }
[17:44:48.844]     if (FALSE) {
[17:44:48.844]     }
[17:44:48.844]     else {
[17:44:48.844]         if (TRUE) {
[17:44:48.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.844]                 open = "w")
[17:44:48.844]         }
[17:44:48.844]         else {
[17:44:48.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.844]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.844]         }
[17:44:48.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.844]             base::sink(type = "output", split = FALSE)
[17:44:48.844]             base::close(...future.stdout)
[17:44:48.844]         }, add = TRUE)
[17:44:48.844]     }
[17:44:48.844]     ...future.frame <- base::sys.nframe()
[17:44:48.844]     ...future.conditions <- base::list()
[17:44:48.844]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.844]     if (FALSE) {
[17:44:48.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.844]     }
[17:44:48.844]     ...future.result <- base::tryCatch({
[17:44:48.844]         base::withCallingHandlers({
[17:44:48.844]             ...future.value <- base::withVisible(base::local({
[17:44:48.844]                 withCallingHandlers({
[17:44:48.844]                   {
[17:44:48.844]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.844]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.844]                       ...future.globals.maxSize)) {
[17:44:48.844]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.844]                       on.exit(options(oopts), add = TRUE)
[17:44:48.844]                     }
[17:44:48.844]                     {
[17:44:48.844]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.844]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.844]                         USE.NAMES = FALSE)
[17:44:48.844]                       do.call(mapply, args = args)
[17:44:48.844]                     }
[17:44:48.844]                   }
[17:44:48.844]                 }, immediateCondition = function(cond) {
[17:44:48.844]                   save_rds <- function (object, pathname, ...) 
[17:44:48.844]                   {
[17:44:48.844]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.844]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.844]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.844]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.844]                         fi_tmp[["mtime"]])
[17:44:48.844]                     }
[17:44:48.844]                     tryCatch({
[17:44:48.844]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.844]                     }, error = function(ex) {
[17:44:48.844]                       msg <- conditionMessage(ex)
[17:44:48.844]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.844]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.844]                         fi_tmp[["mtime"]], msg)
[17:44:48.844]                       ex$message <- msg
[17:44:48.844]                       stop(ex)
[17:44:48.844]                     })
[17:44:48.844]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.844]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.844]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.844]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.844]                       fi <- file.info(pathname)
[17:44:48.844]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.844]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.844]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.844]                         fi[["size"]], fi[["mtime"]])
[17:44:48.844]                       stop(msg)
[17:44:48.844]                     }
[17:44:48.844]                     invisible(pathname)
[17:44:48.844]                   }
[17:44:48.844]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.844]                     rootPath = tempdir()) 
[17:44:48.844]                   {
[17:44:48.844]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.844]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.844]                       tmpdir = path, fileext = ".rds")
[17:44:48.844]                     save_rds(obj, file)
[17:44:48.844]                   }
[17:44:48.844]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.844]                   {
[17:44:48.844]                     inherits <- base::inherits
[17:44:48.844]                     invokeRestart <- base::invokeRestart
[17:44:48.844]                     is.null <- base::is.null
[17:44:48.844]                     muffled <- FALSE
[17:44:48.844]                     if (inherits(cond, "message")) {
[17:44:48.844]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.844]                       if (muffled) 
[17:44:48.844]                         invokeRestart("muffleMessage")
[17:44:48.844]                     }
[17:44:48.844]                     else if (inherits(cond, "warning")) {
[17:44:48.844]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.844]                       if (muffled) 
[17:44:48.844]                         invokeRestart("muffleWarning")
[17:44:48.844]                     }
[17:44:48.844]                     else if (inherits(cond, "condition")) {
[17:44:48.844]                       if (!is.null(pattern)) {
[17:44:48.844]                         computeRestarts <- base::computeRestarts
[17:44:48.844]                         grepl <- base::grepl
[17:44:48.844]                         restarts <- computeRestarts(cond)
[17:44:48.844]                         for (restart in restarts) {
[17:44:48.844]                           name <- restart$name
[17:44:48.844]                           if (is.null(name)) 
[17:44:48.844]                             next
[17:44:48.844]                           if (!grepl(pattern, name)) 
[17:44:48.844]                             next
[17:44:48.844]                           invokeRestart(restart)
[17:44:48.844]                           muffled <- TRUE
[17:44:48.844]                           break
[17:44:48.844]                         }
[17:44:48.844]                       }
[17:44:48.844]                     }
[17:44:48.844]                     invisible(muffled)
[17:44:48.844]                   }
[17:44:48.844]                   muffleCondition(cond)
[17:44:48.844]                 })
[17:44:48.844]             }))
[17:44:48.844]             future::FutureResult(value = ...future.value$value, 
[17:44:48.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.844]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.844]                     ...future.globalenv.names))
[17:44:48.844]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.844]         }, condition = base::local({
[17:44:48.844]             c <- base::c
[17:44:48.844]             inherits <- base::inherits
[17:44:48.844]             invokeRestart <- base::invokeRestart
[17:44:48.844]             length <- base::length
[17:44:48.844]             list <- base::list
[17:44:48.844]             seq.int <- base::seq.int
[17:44:48.844]             signalCondition <- base::signalCondition
[17:44:48.844]             sys.calls <- base::sys.calls
[17:44:48.844]             `[[` <- base::`[[`
[17:44:48.844]             `+` <- base::`+`
[17:44:48.844]             `<<-` <- base::`<<-`
[17:44:48.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.844]                   3L)]
[17:44:48.844]             }
[17:44:48.844]             function(cond) {
[17:44:48.844]                 is_error <- inherits(cond, "error")
[17:44:48.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.844]                   NULL)
[17:44:48.844]                 if (is_error) {
[17:44:48.844]                   sessionInformation <- function() {
[17:44:48.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.844]                       search = base::search(), system = base::Sys.info())
[17:44:48.844]                   }
[17:44:48.844]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.844]                     cond$call), session = sessionInformation(), 
[17:44:48.844]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.844]                   signalCondition(cond)
[17:44:48.844]                 }
[17:44:48.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.844]                 "immediateCondition"))) {
[17:44:48.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.844]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.844]                   if (TRUE && !signal) {
[17:44:48.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.844]                     {
[17:44:48.844]                       inherits <- base::inherits
[17:44:48.844]                       invokeRestart <- base::invokeRestart
[17:44:48.844]                       is.null <- base::is.null
[17:44:48.844]                       muffled <- FALSE
[17:44:48.844]                       if (inherits(cond, "message")) {
[17:44:48.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.844]                         if (muffled) 
[17:44:48.844]                           invokeRestart("muffleMessage")
[17:44:48.844]                       }
[17:44:48.844]                       else if (inherits(cond, "warning")) {
[17:44:48.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.844]                         if (muffled) 
[17:44:48.844]                           invokeRestart("muffleWarning")
[17:44:48.844]                       }
[17:44:48.844]                       else if (inherits(cond, "condition")) {
[17:44:48.844]                         if (!is.null(pattern)) {
[17:44:48.844]                           computeRestarts <- base::computeRestarts
[17:44:48.844]                           grepl <- base::grepl
[17:44:48.844]                           restarts <- computeRestarts(cond)
[17:44:48.844]                           for (restart in restarts) {
[17:44:48.844]                             name <- restart$name
[17:44:48.844]                             if (is.null(name)) 
[17:44:48.844]                               next
[17:44:48.844]                             if (!grepl(pattern, name)) 
[17:44:48.844]                               next
[17:44:48.844]                             invokeRestart(restart)
[17:44:48.844]                             muffled <- TRUE
[17:44:48.844]                             break
[17:44:48.844]                           }
[17:44:48.844]                         }
[17:44:48.844]                       }
[17:44:48.844]                       invisible(muffled)
[17:44:48.844]                     }
[17:44:48.844]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.844]                   }
[17:44:48.844]                 }
[17:44:48.844]                 else {
[17:44:48.844]                   if (TRUE) {
[17:44:48.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.844]                     {
[17:44:48.844]                       inherits <- base::inherits
[17:44:48.844]                       invokeRestart <- base::invokeRestart
[17:44:48.844]                       is.null <- base::is.null
[17:44:48.844]                       muffled <- FALSE
[17:44:48.844]                       if (inherits(cond, "message")) {
[17:44:48.844]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.844]                         if (muffled) 
[17:44:48.844]                           invokeRestart("muffleMessage")
[17:44:48.844]                       }
[17:44:48.844]                       else if (inherits(cond, "warning")) {
[17:44:48.844]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.844]                         if (muffled) 
[17:44:48.844]                           invokeRestart("muffleWarning")
[17:44:48.844]                       }
[17:44:48.844]                       else if (inherits(cond, "condition")) {
[17:44:48.844]                         if (!is.null(pattern)) {
[17:44:48.844]                           computeRestarts <- base::computeRestarts
[17:44:48.844]                           grepl <- base::grepl
[17:44:48.844]                           restarts <- computeRestarts(cond)
[17:44:48.844]                           for (restart in restarts) {
[17:44:48.844]                             name <- restart$name
[17:44:48.844]                             if (is.null(name)) 
[17:44:48.844]                               next
[17:44:48.844]                             if (!grepl(pattern, name)) 
[17:44:48.844]                               next
[17:44:48.844]                             invokeRestart(restart)
[17:44:48.844]                             muffled <- TRUE
[17:44:48.844]                             break
[17:44:48.844]                           }
[17:44:48.844]                         }
[17:44:48.844]                       }
[17:44:48.844]                       invisible(muffled)
[17:44:48.844]                     }
[17:44:48.844]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.844]                   }
[17:44:48.844]                 }
[17:44:48.844]             }
[17:44:48.844]         }))
[17:44:48.844]     }, error = function(ex) {
[17:44:48.844]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.844]                 ...future.rng), started = ...future.startTime, 
[17:44:48.844]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.844]             version = "1.8"), class = "FutureResult")
[17:44:48.844]     }, finally = {
[17:44:48.844]         if (!identical(...future.workdir, getwd())) 
[17:44:48.844]             setwd(...future.workdir)
[17:44:48.844]         {
[17:44:48.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.844]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.844]             }
[17:44:48.844]             base::options(...future.oldOptions)
[17:44:48.844]             if (.Platform$OS.type == "windows") {
[17:44:48.844]                 old_names <- names(...future.oldEnvVars)
[17:44:48.844]                 envs <- base::Sys.getenv()
[17:44:48.844]                 names <- names(envs)
[17:44:48.844]                 common <- intersect(names, old_names)
[17:44:48.844]                 added <- setdiff(names, old_names)
[17:44:48.844]                 removed <- setdiff(old_names, names)
[17:44:48.844]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.844]                   envs[common]]
[17:44:48.844]                 NAMES <- toupper(changed)
[17:44:48.844]                 args <- list()
[17:44:48.844]                 for (kk in seq_along(NAMES)) {
[17:44:48.844]                   name <- changed[[kk]]
[17:44:48.844]                   NAME <- NAMES[[kk]]
[17:44:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.844]                     next
[17:44:48.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.844]                 }
[17:44:48.844]                 NAMES <- toupper(added)
[17:44:48.844]                 for (kk in seq_along(NAMES)) {
[17:44:48.844]                   name <- added[[kk]]
[17:44:48.844]                   NAME <- NAMES[[kk]]
[17:44:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.844]                     next
[17:44:48.844]                   args[[name]] <- ""
[17:44:48.844]                 }
[17:44:48.844]                 NAMES <- toupper(removed)
[17:44:48.844]                 for (kk in seq_along(NAMES)) {
[17:44:48.844]                   name <- removed[[kk]]
[17:44:48.844]                   NAME <- NAMES[[kk]]
[17:44:48.844]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.844]                     next
[17:44:48.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.844]                 }
[17:44:48.844]                 if (length(args) > 0) 
[17:44:48.844]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.844]             }
[17:44:48.844]             else {
[17:44:48.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.844]             }
[17:44:48.844]             {
[17:44:48.844]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.844]                   0L) {
[17:44:48.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.844]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.844]                   base::options(opts)
[17:44:48.844]                 }
[17:44:48.844]                 {
[17:44:48.844]                   {
[17:44:48.844]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.844]                     NULL
[17:44:48.844]                   }
[17:44:48.844]                   options(future.plan = NULL)
[17:44:48.844]                   if (is.na(NA_character_)) 
[17:44:48.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.844]                     .init = FALSE)
[17:44:48.844]                 }
[17:44:48.844]             }
[17:44:48.844]         }
[17:44:48.844]     })
[17:44:48.844]     if (TRUE) {
[17:44:48.844]         base::sink(type = "output", split = FALSE)
[17:44:48.844]         if (TRUE) {
[17:44:48.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.844]         }
[17:44:48.844]         else {
[17:44:48.844]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.844]         }
[17:44:48.844]         base::close(...future.stdout)
[17:44:48.844]         ...future.stdout <- NULL
[17:44:48.844]     }
[17:44:48.844]     ...future.result$conditions <- ...future.conditions
[17:44:48.844]     ...future.result$finished <- base::Sys.time()
[17:44:48.844]     ...future.result
[17:44:48.844] }
[17:44:48.847] assign_globals() ...
[17:44:48.847] List of 5
[17:44:48.847]  $ ...future.FUN            :function (e1, e2)  
[17:44:48.847]  $ MoreArgs                 : NULL
[17:44:48.847]  $ ...future.elements_ii    :List of 2
[17:44:48.847]   ..$ :List of 2
[17:44:48.847]   .. ..$ : num 1
[17:44:48.847]   .. ..$ : num 1
[17:44:48.847]   ..$ :List of 2
[17:44:48.847]   .. ..$ : int 2
[17:44:48.847]   .. ..$ : int 3
[17:44:48.847]  $ ...future.seeds_ii       : NULL
[17:44:48.847]  $ ...future.globals.maxSize: NULL
[17:44:48.847]  - attr(*, "where")=List of 5
[17:44:48.847]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.847]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.847]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.847]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.847]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.847]  - attr(*, "resolved")= logi FALSE
[17:44:48.847]  - attr(*, "total_size")= num 280
[17:44:48.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.847]  - attr(*, "already-done")= logi TRUE
[17:44:48.861] - copied ‘...future.FUN’ to environment
[17:44:48.861] - copied ‘MoreArgs’ to environment
[17:44:48.861] - copied ‘...future.elements_ii’ to environment
[17:44:48.861] - copied ‘...future.seeds_ii’ to environment
[17:44:48.861] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.861] assign_globals() ... done
[17:44:48.862] requestCore(): workers = 2
[17:44:48.864] MulticoreFuture started
[17:44:48.865] - Launch lazy future ... done
[17:44:48.865] run() for ‘MulticoreFuture’ ... done
[17:44:48.865] plan(): Setting new future strategy stack:
[17:44:48.866] Created future:
[17:44:48.866] List of future strategies:
[17:44:48.866] 1. sequential:
[17:44:48.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.866]    - tweaked: FALSE
[17:44:48.866]    - call: NULL
[17:44:48.867] plan(): nbrOfWorkers() = 1
[17:44:48.870] plan(): Setting new future strategy stack:
[17:44:48.870] List of future strategies:
[17:44:48.870] 1. multicore:
[17:44:48.870]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.870]    - tweaked: FALSE
[17:44:48.870]    - call: plan(strategy)
[17:44:48.876] plan(): nbrOfWorkers() = 2
[17:44:48.866] MulticoreFuture:
[17:44:48.866] Label: ‘future_Map-2’
[17:44:48.866] Expression:
[17:44:48.866] {
[17:44:48.866]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.866]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.866]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.866]         on.exit(options(oopts), add = TRUE)
[17:44:48.866]     }
[17:44:48.866]     {
[17:44:48.866]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.866]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.866]         do.call(mapply, args = args)
[17:44:48.866]     }
[17:44:48.866] }
[17:44:48.866] Lazy evaluation: FALSE
[17:44:48.866] Asynchronous evaluation: TRUE
[17:44:48.866] Local evaluation: TRUE
[17:44:48.866] Environment: R_GlobalEnv
[17:44:48.866] Capture standard output: TRUE
[17:44:48.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.866] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.866] Packages: <none>
[17:44:48.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.866] Resolved: TRUE
[17:44:48.866] Value: <not collected>
[17:44:48.866] Conditions captured: <none>
[17:44:48.866] Early signaling: FALSE
[17:44:48.866] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.866] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.877] Chunk #2 of 2 ... DONE
[17:44:48.877] Launching 2 futures (chunks) ... DONE
[17:44:48.877] Resolving 2 futures (chunks) ...
[17:44:48.877] resolve() on list ...
[17:44:48.877]  recursive: 0
[17:44:48.877]  length: 2
[17:44:48.877] 
[17:44:48.878] Future #1
[17:44:48.878] result() for MulticoreFuture ...
[17:44:48.879] result() for MulticoreFuture ...
[17:44:48.879] result() for MulticoreFuture ... done
[17:44:48.879] result() for MulticoreFuture ... done
[17:44:48.879] result() for MulticoreFuture ...
[17:44:48.880] result() for MulticoreFuture ... done
[17:44:48.880] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.880] - nx: 2
[17:44:48.880] - relay: TRUE
[17:44:48.880] - stdout: TRUE
[17:44:48.880] - signal: TRUE
[17:44:48.880] - resignal: FALSE
[17:44:48.881] - force: TRUE
[17:44:48.881] - relayed: [n=2] FALSE, FALSE
[17:44:48.881] - queued futures: [n=2] FALSE, FALSE
[17:44:48.881]  - until=1
[17:44:48.881]  - relaying element #1
[17:44:48.882] result() for MulticoreFuture ...
[17:44:48.882] result() for MulticoreFuture ... done
[17:44:48.882] result() for MulticoreFuture ...
[17:44:48.882] result() for MulticoreFuture ... done
[17:44:48.882] result() for MulticoreFuture ...
[17:44:48.883] result() for MulticoreFuture ... done
[17:44:48.883] result() for MulticoreFuture ...
[17:44:48.883] result() for MulticoreFuture ... done
[17:44:48.883] - relayed: [n=2] TRUE, FALSE
[17:44:48.883] - queued futures: [n=2] TRUE, FALSE
[17:44:48.883] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:48.884]  length: 1 (resolved future 1)
[17:44:48.884] Future #2
[17:44:48.884] result() for MulticoreFuture ...
[17:44:48.885] result() for MulticoreFuture ...
[17:44:48.885] result() for MulticoreFuture ... done
[17:44:48.885] result() for MulticoreFuture ... done
[17:44:48.885] result() for MulticoreFuture ...
[17:44:48.885] result() for MulticoreFuture ... done
[17:44:48.886] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:48.886] - nx: 2
[17:44:48.886] - relay: TRUE
[17:44:48.886] - stdout: TRUE
[17:44:48.886] - signal: TRUE
[17:44:48.886] - resignal: FALSE
[17:44:48.886] - force: TRUE
[17:44:48.886] - relayed: [n=2] TRUE, FALSE
[17:44:48.886] - queued futures: [n=2] TRUE, FALSE
[17:44:48.887]  - until=2
[17:44:48.887]  - relaying element #2
[17:44:48.887] result() for MulticoreFuture ...
[17:44:48.887] result() for MulticoreFuture ... done
[17:44:48.887] result() for MulticoreFuture ...
[17:44:48.887] result() for MulticoreFuture ... done
[17:44:48.887] result() for MulticoreFuture ...
[17:44:48.887] result() for MulticoreFuture ... done
[17:44:48.888] result() for MulticoreFuture ...
[17:44:48.888] result() for MulticoreFuture ... done
[17:44:48.888] - relayed: [n=2] TRUE, TRUE
[17:44:48.888] - queued futures: [n=2] TRUE, TRUE
[17:44:48.888] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:48.888]  length: 0 (resolved future 2)
[17:44:48.888] Relaying remaining futures
[17:44:48.888] signalConditionsASAP(NULL, pos=0) ...
[17:44:48.889] - nx: 2
[17:44:48.889] - relay: TRUE
[17:44:48.889] - stdout: TRUE
[17:44:48.889] - signal: TRUE
[17:44:48.889] - resignal: FALSE
[17:44:48.889] - force: TRUE
[17:44:48.889] - relayed: [n=2] TRUE, TRUE
[17:44:48.889] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:48.889] - relayed: [n=2] TRUE, TRUE
[17:44:48.890] - queued futures: [n=2] TRUE, TRUE
[17:44:48.890] signalConditionsASAP(NULL, pos=0) ... done
[17:44:48.890] resolve() on list ... DONE
[17:44:48.890] result() for MulticoreFuture ...
[17:44:48.890] result() for MulticoreFuture ... done
[17:44:48.890] result() for MulticoreFuture ...
[17:44:48.890] result() for MulticoreFuture ... done
[17:44:48.890] result() for MulticoreFuture ...
[17:44:48.890] result() for MulticoreFuture ... done
[17:44:48.891] result() for MulticoreFuture ...
[17:44:48.891] result() for MulticoreFuture ... done
[17:44:48.891]  - Number of value chunks collected: 2
[17:44:48.891] Resolving 2 futures (chunks) ... DONE
[17:44:48.891] Reducing values from 2 chunks ...
[17:44:48.891]  - Number of values collected after concatenation: 3
[17:44:48.891]  - Number of values expected: 3
[17:44:48.891] Reducing values from 2 chunks ... DONE
[17:44:48.891] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:44:48.892] future_mapply() ...
[17:44:48.899] Number of chunks: 2
[17:44:48.899] getGlobalsAndPackagesXApply() ...
[17:44:48.900]  - future.globals: TRUE
[17:44:48.900] getGlobalsAndPackages() ...
[17:44:48.900] Searching for globals...
[17:44:48.901] - globals found: [1] ‘FUN’
[17:44:48.902] Searching for globals ... DONE
[17:44:48.902] Resolving globals: FALSE
[17:44:48.902] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:48.902] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:48.903] - globals: [1] ‘FUN’
[17:44:48.903] 
[17:44:48.903] getGlobalsAndPackages() ... DONE
[17:44:48.903]  - globals found/used: [n=1] ‘FUN’
[17:44:48.903]  - needed namespaces: [n=0] 
[17:44:48.903] Finding globals ... DONE
[17:44:48.904] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:48.904] List of 2
[17:44:48.904]  $ ...future.FUN:function (x)  
[17:44:48.904]  $ MoreArgs     : NULL
[17:44:48.904]  - attr(*, "where")=List of 2
[17:44:48.904]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:48.904]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:48.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.904]  - attr(*, "resolved")= logi FALSE
[17:44:48.904]  - attr(*, "total_size")= num NA
[17:44:48.907] Packages to be attached in all futures: [n=0] 
[17:44:48.907] getGlobalsAndPackagesXApply() ... DONE
[17:44:48.907] Number of futures (= number of chunks): 2
[17:44:48.908] Launching 2 futures (chunks) ...
[17:44:48.908] Chunk #1 of 2 ...
[17:44:48.908]  - Finding globals in '...' for chunk #1 ...
[17:44:48.908] getGlobalsAndPackages() ...
[17:44:48.908] Searching for globals...
[17:44:48.908] 
[17:44:48.908] Searching for globals ... DONE
[17:44:48.908] - globals: [0] <none>
[17:44:48.909] getGlobalsAndPackages() ... DONE
[17:44:48.909]    + additional globals found: [n=0] 
[17:44:48.909]    + additional namespaces needed: [n=0] 
[17:44:48.909]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:48.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.909]  - seeds: <none>
[17:44:48.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.909] getGlobalsAndPackages() ...
[17:44:48.909] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.909] Resolving globals: FALSE
[17:44:48.910] The total size of the 5 globals is 904 bytes (904 bytes)
[17:44:48.910] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.911] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.911] 
[17:44:48.911] getGlobalsAndPackages() ... DONE
[17:44:48.911] run() for ‘Future’ ...
[17:44:48.911] - state: ‘created’
[17:44:48.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.915]   - Field: ‘label’
[17:44:48.915]   - Field: ‘local’
[17:44:48.916]   - Field: ‘owner’
[17:44:48.916]   - Field: ‘envir’
[17:44:48.916]   - Field: ‘workers’
[17:44:48.916]   - Field: ‘packages’
[17:44:48.916]   - Field: ‘gc’
[17:44:48.916]   - Field: ‘job’
[17:44:48.916]   - Field: ‘conditions’
[17:44:48.916]   - Field: ‘expr’
[17:44:48.916]   - Field: ‘uuid’
[17:44:48.916]   - Field: ‘seed’
[17:44:48.917]   - Field: ‘version’
[17:44:48.917]   - Field: ‘result’
[17:44:48.917]   - Field: ‘asynchronous’
[17:44:48.917]   - Field: ‘calls’
[17:44:48.917]   - Field: ‘globals’
[17:44:48.917]   - Field: ‘stdout’
[17:44:48.917]   - Field: ‘earlySignal’
[17:44:48.917]   - Field: ‘lazy’
[17:44:48.917]   - Field: ‘state’
[17:44:48.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.917] - Launch lazy future ...
[17:44:48.918] Packages needed by the future expression (n = 0): <none>
[17:44:48.918] Packages needed by future strategies (n = 0): <none>
[17:44:48.918] {
[17:44:48.918]     {
[17:44:48.918]         {
[17:44:48.918]             ...future.startTime <- base::Sys.time()
[17:44:48.918]             {
[17:44:48.918]                 {
[17:44:48.918]                   {
[17:44:48.918]                     {
[17:44:48.918]                       base::local({
[17:44:48.918]                         has_future <- base::requireNamespace("future", 
[17:44:48.918]                           quietly = TRUE)
[17:44:48.918]                         if (has_future) {
[17:44:48.918]                           ns <- base::getNamespace("future")
[17:44:48.918]                           version <- ns[[".package"]][["version"]]
[17:44:48.918]                           if (is.null(version)) 
[17:44:48.918]                             version <- utils::packageVersion("future")
[17:44:48.918]                         }
[17:44:48.918]                         else {
[17:44:48.918]                           version <- NULL
[17:44:48.918]                         }
[17:44:48.918]                         if (!has_future || version < "1.8.0") {
[17:44:48.918]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.918]                             "", base::R.version$version.string), 
[17:44:48.918]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.918]                               "release", "version")], collapse = " "), 
[17:44:48.918]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.918]                             info)
[17:44:48.918]                           info <- base::paste(info, collapse = "; ")
[17:44:48.918]                           if (!has_future) {
[17:44:48.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.918]                               info)
[17:44:48.918]                           }
[17:44:48.918]                           else {
[17:44:48.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.918]                               info, version)
[17:44:48.918]                           }
[17:44:48.918]                           base::stop(msg)
[17:44:48.918]                         }
[17:44:48.918]                       })
[17:44:48.918]                     }
[17:44:48.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.918]                     base::options(mc.cores = 1L)
[17:44:48.918]                   }
[17:44:48.918]                   ...future.strategy.old <- future::plan("list")
[17:44:48.918]                   options(future.plan = NULL)
[17:44:48.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.918]                 }
[17:44:48.918]                 ...future.workdir <- getwd()
[17:44:48.918]             }
[17:44:48.918]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.918]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.918]         }
[17:44:48.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.918]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.918]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.918]             base::names(...future.oldOptions))
[17:44:48.918]     }
[17:44:48.918]     if (FALSE) {
[17:44:48.918]     }
[17:44:48.918]     else {
[17:44:48.918]         if (TRUE) {
[17:44:48.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.918]                 open = "w")
[17:44:48.918]         }
[17:44:48.918]         else {
[17:44:48.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.918]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.918]         }
[17:44:48.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.918]             base::sink(type = "output", split = FALSE)
[17:44:48.918]             base::close(...future.stdout)
[17:44:48.918]         }, add = TRUE)
[17:44:48.918]     }
[17:44:48.918]     ...future.frame <- base::sys.nframe()
[17:44:48.918]     ...future.conditions <- base::list()
[17:44:48.918]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.918]     if (FALSE) {
[17:44:48.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.918]     }
[17:44:48.918]     ...future.result <- base::tryCatch({
[17:44:48.918]         base::withCallingHandlers({
[17:44:48.918]             ...future.value <- base::withVisible(base::local({
[17:44:48.918]                 withCallingHandlers({
[17:44:48.918]                   {
[17:44:48.918]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.918]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.918]                       ...future.globals.maxSize)) {
[17:44:48.918]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.918]                       on.exit(options(oopts), add = TRUE)
[17:44:48.918]                     }
[17:44:48.918]                     {
[17:44:48.918]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.918]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.918]                         USE.NAMES = FALSE)
[17:44:48.918]                       do.call(mapply, args = args)
[17:44:48.918]                     }
[17:44:48.918]                   }
[17:44:48.918]                 }, immediateCondition = function(cond) {
[17:44:48.918]                   save_rds <- function (object, pathname, ...) 
[17:44:48.918]                   {
[17:44:48.918]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.918]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.918]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.918]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.918]                         fi_tmp[["mtime"]])
[17:44:48.918]                     }
[17:44:48.918]                     tryCatch({
[17:44:48.918]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.918]                     }, error = function(ex) {
[17:44:48.918]                       msg <- conditionMessage(ex)
[17:44:48.918]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.918]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.918]                         fi_tmp[["mtime"]], msg)
[17:44:48.918]                       ex$message <- msg
[17:44:48.918]                       stop(ex)
[17:44:48.918]                     })
[17:44:48.918]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.918]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.918]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.918]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.918]                       fi <- file.info(pathname)
[17:44:48.918]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.918]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.918]                         fi[["size"]], fi[["mtime"]])
[17:44:48.918]                       stop(msg)
[17:44:48.918]                     }
[17:44:48.918]                     invisible(pathname)
[17:44:48.918]                   }
[17:44:48.918]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.918]                     rootPath = tempdir()) 
[17:44:48.918]                   {
[17:44:48.918]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.918]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.918]                       tmpdir = path, fileext = ".rds")
[17:44:48.918]                     save_rds(obj, file)
[17:44:48.918]                   }
[17:44:48.918]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.918]                   {
[17:44:48.918]                     inherits <- base::inherits
[17:44:48.918]                     invokeRestart <- base::invokeRestart
[17:44:48.918]                     is.null <- base::is.null
[17:44:48.918]                     muffled <- FALSE
[17:44:48.918]                     if (inherits(cond, "message")) {
[17:44:48.918]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.918]                       if (muffled) 
[17:44:48.918]                         invokeRestart("muffleMessage")
[17:44:48.918]                     }
[17:44:48.918]                     else if (inherits(cond, "warning")) {
[17:44:48.918]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.918]                       if (muffled) 
[17:44:48.918]                         invokeRestart("muffleWarning")
[17:44:48.918]                     }
[17:44:48.918]                     else if (inherits(cond, "condition")) {
[17:44:48.918]                       if (!is.null(pattern)) {
[17:44:48.918]                         computeRestarts <- base::computeRestarts
[17:44:48.918]                         grepl <- base::grepl
[17:44:48.918]                         restarts <- computeRestarts(cond)
[17:44:48.918]                         for (restart in restarts) {
[17:44:48.918]                           name <- restart$name
[17:44:48.918]                           if (is.null(name)) 
[17:44:48.918]                             next
[17:44:48.918]                           if (!grepl(pattern, name)) 
[17:44:48.918]                             next
[17:44:48.918]                           invokeRestart(restart)
[17:44:48.918]                           muffled <- TRUE
[17:44:48.918]                           break
[17:44:48.918]                         }
[17:44:48.918]                       }
[17:44:48.918]                     }
[17:44:48.918]                     invisible(muffled)
[17:44:48.918]                   }
[17:44:48.918]                   muffleCondition(cond)
[17:44:48.918]                 })
[17:44:48.918]             }))
[17:44:48.918]             future::FutureResult(value = ...future.value$value, 
[17:44:48.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.918]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.918]                     ...future.globalenv.names))
[17:44:48.918]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.918]         }, condition = base::local({
[17:44:48.918]             c <- base::c
[17:44:48.918]             inherits <- base::inherits
[17:44:48.918]             invokeRestart <- base::invokeRestart
[17:44:48.918]             length <- base::length
[17:44:48.918]             list <- base::list
[17:44:48.918]             seq.int <- base::seq.int
[17:44:48.918]             signalCondition <- base::signalCondition
[17:44:48.918]             sys.calls <- base::sys.calls
[17:44:48.918]             `[[` <- base::`[[`
[17:44:48.918]             `+` <- base::`+`
[17:44:48.918]             `<<-` <- base::`<<-`
[17:44:48.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.918]                   3L)]
[17:44:48.918]             }
[17:44:48.918]             function(cond) {
[17:44:48.918]                 is_error <- inherits(cond, "error")
[17:44:48.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.918]                   NULL)
[17:44:48.918]                 if (is_error) {
[17:44:48.918]                   sessionInformation <- function() {
[17:44:48.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.918]                       search = base::search(), system = base::Sys.info())
[17:44:48.918]                   }
[17:44:48.918]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.918]                     cond$call), session = sessionInformation(), 
[17:44:48.918]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.918]                   signalCondition(cond)
[17:44:48.918]                 }
[17:44:48.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.918]                 "immediateCondition"))) {
[17:44:48.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.918]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.918]                   if (TRUE && !signal) {
[17:44:48.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.918]                     {
[17:44:48.918]                       inherits <- base::inherits
[17:44:48.918]                       invokeRestart <- base::invokeRestart
[17:44:48.918]                       is.null <- base::is.null
[17:44:48.918]                       muffled <- FALSE
[17:44:48.918]                       if (inherits(cond, "message")) {
[17:44:48.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.918]                         if (muffled) 
[17:44:48.918]                           invokeRestart("muffleMessage")
[17:44:48.918]                       }
[17:44:48.918]                       else if (inherits(cond, "warning")) {
[17:44:48.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.918]                         if (muffled) 
[17:44:48.918]                           invokeRestart("muffleWarning")
[17:44:48.918]                       }
[17:44:48.918]                       else if (inherits(cond, "condition")) {
[17:44:48.918]                         if (!is.null(pattern)) {
[17:44:48.918]                           computeRestarts <- base::computeRestarts
[17:44:48.918]                           grepl <- base::grepl
[17:44:48.918]                           restarts <- computeRestarts(cond)
[17:44:48.918]                           for (restart in restarts) {
[17:44:48.918]                             name <- restart$name
[17:44:48.918]                             if (is.null(name)) 
[17:44:48.918]                               next
[17:44:48.918]                             if (!grepl(pattern, name)) 
[17:44:48.918]                               next
[17:44:48.918]                             invokeRestart(restart)
[17:44:48.918]                             muffled <- TRUE
[17:44:48.918]                             break
[17:44:48.918]                           }
[17:44:48.918]                         }
[17:44:48.918]                       }
[17:44:48.918]                       invisible(muffled)
[17:44:48.918]                     }
[17:44:48.918]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.918]                   }
[17:44:48.918]                 }
[17:44:48.918]                 else {
[17:44:48.918]                   if (TRUE) {
[17:44:48.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.918]                     {
[17:44:48.918]                       inherits <- base::inherits
[17:44:48.918]                       invokeRestart <- base::invokeRestart
[17:44:48.918]                       is.null <- base::is.null
[17:44:48.918]                       muffled <- FALSE
[17:44:48.918]                       if (inherits(cond, "message")) {
[17:44:48.918]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.918]                         if (muffled) 
[17:44:48.918]                           invokeRestart("muffleMessage")
[17:44:48.918]                       }
[17:44:48.918]                       else if (inherits(cond, "warning")) {
[17:44:48.918]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.918]                         if (muffled) 
[17:44:48.918]                           invokeRestart("muffleWarning")
[17:44:48.918]                       }
[17:44:48.918]                       else if (inherits(cond, "condition")) {
[17:44:48.918]                         if (!is.null(pattern)) {
[17:44:48.918]                           computeRestarts <- base::computeRestarts
[17:44:48.918]                           grepl <- base::grepl
[17:44:48.918]                           restarts <- computeRestarts(cond)
[17:44:48.918]                           for (restart in restarts) {
[17:44:48.918]                             name <- restart$name
[17:44:48.918]                             if (is.null(name)) 
[17:44:48.918]                               next
[17:44:48.918]                             if (!grepl(pattern, name)) 
[17:44:48.918]                               next
[17:44:48.918]                             invokeRestart(restart)
[17:44:48.918]                             muffled <- TRUE
[17:44:48.918]                             break
[17:44:48.918]                           }
[17:44:48.918]                         }
[17:44:48.918]                       }
[17:44:48.918]                       invisible(muffled)
[17:44:48.918]                     }
[17:44:48.918]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.918]                   }
[17:44:48.918]                 }
[17:44:48.918]             }
[17:44:48.918]         }))
[17:44:48.918]     }, error = function(ex) {
[17:44:48.918]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.918]                 ...future.rng), started = ...future.startTime, 
[17:44:48.918]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.918]             version = "1.8"), class = "FutureResult")
[17:44:48.918]     }, finally = {
[17:44:48.918]         if (!identical(...future.workdir, getwd())) 
[17:44:48.918]             setwd(...future.workdir)
[17:44:48.918]         {
[17:44:48.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.918]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.918]             }
[17:44:48.918]             base::options(...future.oldOptions)
[17:44:48.918]             if (.Platform$OS.type == "windows") {
[17:44:48.918]                 old_names <- names(...future.oldEnvVars)
[17:44:48.918]                 envs <- base::Sys.getenv()
[17:44:48.918]                 names <- names(envs)
[17:44:48.918]                 common <- intersect(names, old_names)
[17:44:48.918]                 added <- setdiff(names, old_names)
[17:44:48.918]                 removed <- setdiff(old_names, names)
[17:44:48.918]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.918]                   envs[common]]
[17:44:48.918]                 NAMES <- toupper(changed)
[17:44:48.918]                 args <- list()
[17:44:48.918]                 for (kk in seq_along(NAMES)) {
[17:44:48.918]                   name <- changed[[kk]]
[17:44:48.918]                   NAME <- NAMES[[kk]]
[17:44:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.918]                     next
[17:44:48.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.918]                 }
[17:44:48.918]                 NAMES <- toupper(added)
[17:44:48.918]                 for (kk in seq_along(NAMES)) {
[17:44:48.918]                   name <- added[[kk]]
[17:44:48.918]                   NAME <- NAMES[[kk]]
[17:44:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.918]                     next
[17:44:48.918]                   args[[name]] <- ""
[17:44:48.918]                 }
[17:44:48.918]                 NAMES <- toupper(removed)
[17:44:48.918]                 for (kk in seq_along(NAMES)) {
[17:44:48.918]                   name <- removed[[kk]]
[17:44:48.918]                   NAME <- NAMES[[kk]]
[17:44:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.918]                     next
[17:44:48.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.918]                 }
[17:44:48.918]                 if (length(args) > 0) 
[17:44:48.918]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.918]             }
[17:44:48.918]             else {
[17:44:48.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.918]             }
[17:44:48.918]             {
[17:44:48.918]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.918]                   0L) {
[17:44:48.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.918]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.918]                   base::options(opts)
[17:44:48.918]                 }
[17:44:48.918]                 {
[17:44:48.918]                   {
[17:44:48.918]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.918]                     NULL
[17:44:48.918]                   }
[17:44:48.918]                   options(future.plan = NULL)
[17:44:48.918]                   if (is.na(NA_character_)) 
[17:44:48.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.918]                     .init = FALSE)
[17:44:48.918]                 }
[17:44:48.918]             }
[17:44:48.918]         }
[17:44:48.918]     })
[17:44:48.918]     if (TRUE) {
[17:44:48.918]         base::sink(type = "output", split = FALSE)
[17:44:48.918]         if (TRUE) {
[17:44:48.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.918]         }
[17:44:48.918]         else {
[17:44:48.918]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.918]         }
[17:44:48.918]         base::close(...future.stdout)
[17:44:48.918]         ...future.stdout <- NULL
[17:44:48.918]     }
[17:44:48.918]     ...future.result$conditions <- ...future.conditions
[17:44:48.918]     ...future.result$finished <- base::Sys.time()
[17:44:48.918]     ...future.result
[17:44:48.918] }
[17:44:48.921] assign_globals() ...
[17:44:48.921] List of 5
[17:44:48.921]  $ ...future.FUN            :function (x)  
[17:44:48.921]  $ MoreArgs                 : NULL
[17:44:48.921]  $ ...future.elements_ii    :List of 1
[17:44:48.921]   ..$ :List of 1
[17:44:48.921]   .. ..$ a: num 0
[17:44:48.921]  $ ...future.seeds_ii       : NULL
[17:44:48.921]  $ ...future.globals.maxSize: NULL
[17:44:48.921]  - attr(*, "where")=List of 5
[17:44:48.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.921]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.921]  - attr(*, "resolved")= logi FALSE
[17:44:48.921]  - attr(*, "total_size")= num 904
[17:44:48.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.921]  - attr(*, "already-done")= logi TRUE
[17:44:48.929] - copied ‘...future.FUN’ to environment
[17:44:48.929] - copied ‘MoreArgs’ to environment
[17:44:48.929] - copied ‘...future.elements_ii’ to environment
[17:44:48.930] - copied ‘...future.seeds_ii’ to environment
[17:44:48.930] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.930] assign_globals() ... done
[17:44:48.930] requestCore(): workers = 2
[17:44:48.933] MulticoreFuture started
[17:44:48.933] - Launch lazy future ... done
[17:44:48.934] plan(): Setting new future strategy stack:
[17:44:48.934] run() for ‘MulticoreFuture’ ... done
[17:44:48.935] Created future:
[17:44:48.934] List of future strategies:
[17:44:48.934] 1. sequential:
[17:44:48.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.934]    - tweaked: FALSE
[17:44:48.934]    - call: NULL
[17:44:48.936] plan(): nbrOfWorkers() = 1
[17:44:48.939] plan(): Setting new future strategy stack:
[17:44:48.939] List of future strategies:
[17:44:48.939] 1. multicore:
[17:44:48.939]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.939]    - tweaked: FALSE
[17:44:48.939]    - call: plan(strategy)
[17:44:48.946] plan(): nbrOfWorkers() = 2
[17:44:48.935] MulticoreFuture:
[17:44:48.935] Label: ‘future_mapply-1’
[17:44:48.935] Expression:
[17:44:48.935] {
[17:44:48.935]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.935]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.935]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.935]         on.exit(options(oopts), add = TRUE)
[17:44:48.935]     }
[17:44:48.935]     {
[17:44:48.935]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.935]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.935]         do.call(mapply, args = args)
[17:44:48.935]     }
[17:44:48.935] }
[17:44:48.935] Lazy evaluation: FALSE
[17:44:48.935] Asynchronous evaluation: TRUE
[17:44:48.935] Local evaluation: TRUE
[17:44:48.935] Environment: R_GlobalEnv
[17:44:48.935] Capture standard output: TRUE
[17:44:48.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.935] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.935] Packages: <none>
[17:44:48.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.935] Resolved: TRUE
[17:44:48.935] Value: <not collected>
[17:44:48.935] Conditions captured: <none>
[17:44:48.935] Early signaling: FALSE
[17:44:48.935] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.935] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.947] Chunk #1 of 2 ... DONE
[17:44:48.948] Chunk #2 of 2 ...
[17:44:48.948]  - Finding globals in '...' for chunk #2 ...
[17:44:48.948] getGlobalsAndPackages() ...
[17:44:48.948] Searching for globals...
[17:44:48.949] 
[17:44:48.949] Searching for globals ... DONE
[17:44:48.949] - globals: [0] <none>
[17:44:48.950] getGlobalsAndPackages() ... DONE
[17:44:48.950]    + additional globals found: [n=0] 
[17:44:48.950]    + additional namespaces needed: [n=0] 
[17:44:48.950]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:48.950]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:48.950]  - seeds: <none>
[17:44:48.951]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.951] getGlobalsAndPackages() ...
[17:44:48.951] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.951] Resolving globals: FALSE
[17:44:48.952] The total size of the 5 globals is 904 bytes (904 bytes)
[17:44:48.953] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:48.953] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:48.953] 
[17:44:48.953] getGlobalsAndPackages() ... DONE
[17:44:48.954] run() for ‘Future’ ...
[17:44:48.954] - state: ‘created’
[17:44:48.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:44:48.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:44:48.959]   - Field: ‘label’
[17:44:48.960]   - Field: ‘local’
[17:44:48.960]   - Field: ‘owner’
[17:44:48.960]   - Field: ‘envir’
[17:44:48.960]   - Field: ‘workers’
[17:44:48.960]   - Field: ‘packages’
[17:44:48.960]   - Field: ‘gc’
[17:44:48.960]   - Field: ‘job’
[17:44:48.961]   - Field: ‘conditions’
[17:44:48.961]   - Field: ‘expr’
[17:44:48.961]   - Field: ‘uuid’
[17:44:48.961]   - Field: ‘seed’
[17:44:48.961]   - Field: ‘version’
[17:44:48.961]   - Field: ‘result’
[17:44:48.961]   - Field: ‘asynchronous’
[17:44:48.962]   - Field: ‘calls’
[17:44:48.962]   - Field: ‘globals’
[17:44:48.962]   - Field: ‘stdout’
[17:44:48.962]   - Field: ‘earlySignal’
[17:44:48.962]   - Field: ‘lazy’
[17:44:48.962]   - Field: ‘state’
[17:44:48.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:44:48.963] - Launch lazy future ...
[17:44:48.963] Packages needed by the future expression (n = 0): <none>
[17:44:48.963] Packages needed by future strategies (n = 0): <none>
[17:44:48.964] {
[17:44:48.964]     {
[17:44:48.964]         {
[17:44:48.964]             ...future.startTime <- base::Sys.time()
[17:44:48.964]             {
[17:44:48.964]                 {
[17:44:48.964]                   {
[17:44:48.964]                     {
[17:44:48.964]                       base::local({
[17:44:48.964]                         has_future <- base::requireNamespace("future", 
[17:44:48.964]                           quietly = TRUE)
[17:44:48.964]                         if (has_future) {
[17:44:48.964]                           ns <- base::getNamespace("future")
[17:44:48.964]                           version <- ns[[".package"]][["version"]]
[17:44:48.964]                           if (is.null(version)) 
[17:44:48.964]                             version <- utils::packageVersion("future")
[17:44:48.964]                         }
[17:44:48.964]                         else {
[17:44:48.964]                           version <- NULL
[17:44:48.964]                         }
[17:44:48.964]                         if (!has_future || version < "1.8.0") {
[17:44:48.964]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:48.964]                             "", base::R.version$version.string), 
[17:44:48.964]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:48.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:48.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:48.964]                               "release", "version")], collapse = " "), 
[17:44:48.964]                             hostname = base::Sys.info()[["nodename"]])
[17:44:48.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:48.964]                             info)
[17:44:48.964]                           info <- base::paste(info, collapse = "; ")
[17:44:48.964]                           if (!has_future) {
[17:44:48.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:48.964]                               info)
[17:44:48.964]                           }
[17:44:48.964]                           else {
[17:44:48.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:48.964]                               info, version)
[17:44:48.964]                           }
[17:44:48.964]                           base::stop(msg)
[17:44:48.964]                         }
[17:44:48.964]                       })
[17:44:48.964]                     }
[17:44:48.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:48.964]                     base::options(mc.cores = 1L)
[17:44:48.964]                   }
[17:44:48.964]                   ...future.strategy.old <- future::plan("list")
[17:44:48.964]                   options(future.plan = NULL)
[17:44:48.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:48.964]                 }
[17:44:48.964]                 ...future.workdir <- getwd()
[17:44:48.964]             }
[17:44:48.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:48.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:48.964]         }
[17:44:48.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:48.964]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:48.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:48.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:48.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:48.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:48.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:48.964]             base::names(...future.oldOptions))
[17:44:48.964]     }
[17:44:48.964]     if (FALSE) {
[17:44:48.964]     }
[17:44:48.964]     else {
[17:44:48.964]         if (TRUE) {
[17:44:48.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:48.964]                 open = "w")
[17:44:48.964]         }
[17:44:48.964]         else {
[17:44:48.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:48.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:48.964]         }
[17:44:48.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:48.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:48.964]             base::sink(type = "output", split = FALSE)
[17:44:48.964]             base::close(...future.stdout)
[17:44:48.964]         }, add = TRUE)
[17:44:48.964]     }
[17:44:48.964]     ...future.frame <- base::sys.nframe()
[17:44:48.964]     ...future.conditions <- base::list()
[17:44:48.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:48.964]     if (FALSE) {
[17:44:48.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:48.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:48.964]     }
[17:44:48.964]     ...future.result <- base::tryCatch({
[17:44:48.964]         base::withCallingHandlers({
[17:44:48.964]             ...future.value <- base::withVisible(base::local({
[17:44:48.964]                 withCallingHandlers({
[17:44:48.964]                   {
[17:44:48.964]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.964]                     if (!identical(...future.globals.maxSize.org, 
[17:44:48.964]                       ...future.globals.maxSize)) {
[17:44:48.964]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.964]                       on.exit(options(oopts), add = TRUE)
[17:44:48.964]                     }
[17:44:48.964]                     {
[17:44:48.964]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.964]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:48.964]                         USE.NAMES = FALSE)
[17:44:48.964]                       do.call(mapply, args = args)
[17:44:48.964]                     }
[17:44:48.964]                   }
[17:44:48.964]                 }, immediateCondition = function(cond) {
[17:44:48.964]                   save_rds <- function (object, pathname, ...) 
[17:44:48.964]                   {
[17:44:48.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:44:48.964]                     if (file_test("-f", pathname_tmp)) {
[17:44:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:44:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.964]                         fi_tmp[["mtime"]])
[17:44:48.964]                     }
[17:44:48.964]                     tryCatch({
[17:44:48.964]                       saveRDS(object, file = pathname_tmp, ...)
[17:44:48.964]                     }, error = function(ex) {
[17:44:48.964]                       msg <- conditionMessage(ex)
[17:44:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:44:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.964]                         fi_tmp[["mtime"]], msg)
[17:44:48.964]                       ex$message <- msg
[17:44:48.964]                       stop(ex)
[17:44:48.964]                     })
[17:44:48.964]                     stopifnot(file_test("-f", pathname_tmp))
[17:44:48.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:44:48.964]                     if (!res || file_test("-f", pathname_tmp)) {
[17:44:48.964]                       fi_tmp <- file.info(pathname_tmp)
[17:44:48.964]                       fi <- file.info(pathname)
[17:44:48.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:44:48.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:44:48.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:44:48.964]                         fi[["size"]], fi[["mtime"]])
[17:44:48.964]                       stop(msg)
[17:44:48.964]                     }
[17:44:48.964]                     invisible(pathname)
[17:44:48.964]                   }
[17:44:48.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:44:48.964]                     rootPath = tempdir()) 
[17:44:48.964]                   {
[17:44:48.964]                     obj <- list(time = Sys.time(), condition = cond)
[17:44:48.964]                     file <- tempfile(pattern = class(cond)[1], 
[17:44:48.964]                       tmpdir = path, fileext = ".rds")
[17:44:48.964]                     save_rds(obj, file)
[17:44:48.964]                   }
[17:44:48.964]                   saveImmediateCondition(cond, path = "/tmp/Rtmp2mUjD6/.future/immediateConditions")
[17:44:48.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.964]                   {
[17:44:48.964]                     inherits <- base::inherits
[17:44:48.964]                     invokeRestart <- base::invokeRestart
[17:44:48.964]                     is.null <- base::is.null
[17:44:48.964]                     muffled <- FALSE
[17:44:48.964]                     if (inherits(cond, "message")) {
[17:44:48.964]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:48.964]                       if (muffled) 
[17:44:48.964]                         invokeRestart("muffleMessage")
[17:44:48.964]                     }
[17:44:48.964]                     else if (inherits(cond, "warning")) {
[17:44:48.964]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:48.964]                       if (muffled) 
[17:44:48.964]                         invokeRestart("muffleWarning")
[17:44:48.964]                     }
[17:44:48.964]                     else if (inherits(cond, "condition")) {
[17:44:48.964]                       if (!is.null(pattern)) {
[17:44:48.964]                         computeRestarts <- base::computeRestarts
[17:44:48.964]                         grepl <- base::grepl
[17:44:48.964]                         restarts <- computeRestarts(cond)
[17:44:48.964]                         for (restart in restarts) {
[17:44:48.964]                           name <- restart$name
[17:44:48.964]                           if (is.null(name)) 
[17:44:48.964]                             next
[17:44:48.964]                           if (!grepl(pattern, name)) 
[17:44:48.964]                             next
[17:44:48.964]                           invokeRestart(restart)
[17:44:48.964]                           muffled <- TRUE
[17:44:48.964]                           break
[17:44:48.964]                         }
[17:44:48.964]                       }
[17:44:48.964]                     }
[17:44:48.964]                     invisible(muffled)
[17:44:48.964]                   }
[17:44:48.964]                   muffleCondition(cond)
[17:44:48.964]                 })
[17:44:48.964]             }))
[17:44:48.964]             future::FutureResult(value = ...future.value$value, 
[17:44:48.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.964]                   ...future.rng), globalenv = if (FALSE) 
[17:44:48.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:48.964]                     ...future.globalenv.names))
[17:44:48.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:48.964]         }, condition = base::local({
[17:44:48.964]             c <- base::c
[17:44:48.964]             inherits <- base::inherits
[17:44:48.964]             invokeRestart <- base::invokeRestart
[17:44:48.964]             length <- base::length
[17:44:48.964]             list <- base::list
[17:44:48.964]             seq.int <- base::seq.int
[17:44:48.964]             signalCondition <- base::signalCondition
[17:44:48.964]             sys.calls <- base::sys.calls
[17:44:48.964]             `[[` <- base::`[[`
[17:44:48.964]             `+` <- base::`+`
[17:44:48.964]             `<<-` <- base::`<<-`
[17:44:48.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:48.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:48.964]                   3L)]
[17:44:48.964]             }
[17:44:48.964]             function(cond) {
[17:44:48.964]                 is_error <- inherits(cond, "error")
[17:44:48.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:48.964]                   NULL)
[17:44:48.964]                 if (is_error) {
[17:44:48.964]                   sessionInformation <- function() {
[17:44:48.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:48.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:48.964]                       search = base::search(), system = base::Sys.info())
[17:44:48.964]                   }
[17:44:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:48.964]                     cond$call), session = sessionInformation(), 
[17:44:48.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:48.964]                   signalCondition(cond)
[17:44:48.964]                 }
[17:44:48.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:48.964]                 "immediateCondition"))) {
[17:44:48.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:48.964]                   ...future.conditions[[length(...future.conditions) + 
[17:44:48.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:48.964]                   if (TRUE && !signal) {
[17:44:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.964]                     {
[17:44:48.964]                       inherits <- base::inherits
[17:44:48.964]                       invokeRestart <- base::invokeRestart
[17:44:48.964]                       is.null <- base::is.null
[17:44:48.964]                       muffled <- FALSE
[17:44:48.964]                       if (inherits(cond, "message")) {
[17:44:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.964]                         if (muffled) 
[17:44:48.964]                           invokeRestart("muffleMessage")
[17:44:48.964]                       }
[17:44:48.964]                       else if (inherits(cond, "warning")) {
[17:44:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.964]                         if (muffled) 
[17:44:48.964]                           invokeRestart("muffleWarning")
[17:44:48.964]                       }
[17:44:48.964]                       else if (inherits(cond, "condition")) {
[17:44:48.964]                         if (!is.null(pattern)) {
[17:44:48.964]                           computeRestarts <- base::computeRestarts
[17:44:48.964]                           grepl <- base::grepl
[17:44:48.964]                           restarts <- computeRestarts(cond)
[17:44:48.964]                           for (restart in restarts) {
[17:44:48.964]                             name <- restart$name
[17:44:48.964]                             if (is.null(name)) 
[17:44:48.964]                               next
[17:44:48.964]                             if (!grepl(pattern, name)) 
[17:44:48.964]                               next
[17:44:48.964]                             invokeRestart(restart)
[17:44:48.964]                             muffled <- TRUE
[17:44:48.964]                             break
[17:44:48.964]                           }
[17:44:48.964]                         }
[17:44:48.964]                       }
[17:44:48.964]                       invisible(muffled)
[17:44:48.964]                     }
[17:44:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.964]                   }
[17:44:48.964]                 }
[17:44:48.964]                 else {
[17:44:48.964]                   if (TRUE) {
[17:44:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:48.964]                     {
[17:44:48.964]                       inherits <- base::inherits
[17:44:48.964]                       invokeRestart <- base::invokeRestart
[17:44:48.964]                       is.null <- base::is.null
[17:44:48.964]                       muffled <- FALSE
[17:44:48.964]                       if (inherits(cond, "message")) {
[17:44:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:48.964]                         if (muffled) 
[17:44:48.964]                           invokeRestart("muffleMessage")
[17:44:48.964]                       }
[17:44:48.964]                       else if (inherits(cond, "warning")) {
[17:44:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:48.964]                         if (muffled) 
[17:44:48.964]                           invokeRestart("muffleWarning")
[17:44:48.964]                       }
[17:44:48.964]                       else if (inherits(cond, "condition")) {
[17:44:48.964]                         if (!is.null(pattern)) {
[17:44:48.964]                           computeRestarts <- base::computeRestarts
[17:44:48.964]                           grepl <- base::grepl
[17:44:48.964]                           restarts <- computeRestarts(cond)
[17:44:48.964]                           for (restart in restarts) {
[17:44:48.964]                             name <- restart$name
[17:44:48.964]                             if (is.null(name)) 
[17:44:48.964]                               next
[17:44:48.964]                             if (!grepl(pattern, name)) 
[17:44:48.964]                               next
[17:44:48.964]                             invokeRestart(restart)
[17:44:48.964]                             muffled <- TRUE
[17:44:48.964]                             break
[17:44:48.964]                           }
[17:44:48.964]                         }
[17:44:48.964]                       }
[17:44:48.964]                       invisible(muffled)
[17:44:48.964]                     }
[17:44:48.964]                     muffleCondition(cond, pattern = "^muffle")
[17:44:48.964]                   }
[17:44:48.964]                 }
[17:44:48.964]             }
[17:44:48.964]         }))
[17:44:48.964]     }, error = function(ex) {
[17:44:48.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:48.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:48.964]                 ...future.rng), started = ...future.startTime, 
[17:44:48.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:48.964]             version = "1.8"), class = "FutureResult")
[17:44:48.964]     }, finally = {
[17:44:48.964]         if (!identical(...future.workdir, getwd())) 
[17:44:48.964]             setwd(...future.workdir)
[17:44:48.964]         {
[17:44:48.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:48.964]                 ...future.oldOptions$nwarnings <- NULL
[17:44:48.964]             }
[17:44:48.964]             base::options(...future.oldOptions)
[17:44:48.964]             if (.Platform$OS.type == "windows") {
[17:44:48.964]                 old_names <- names(...future.oldEnvVars)
[17:44:48.964]                 envs <- base::Sys.getenv()
[17:44:48.964]                 names <- names(envs)
[17:44:48.964]                 common <- intersect(names, old_names)
[17:44:48.964]                 added <- setdiff(names, old_names)
[17:44:48.964]                 removed <- setdiff(old_names, names)
[17:44:48.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:48.964]                   envs[common]]
[17:44:48.964]                 NAMES <- toupper(changed)
[17:44:48.964]                 args <- list()
[17:44:48.964]                 for (kk in seq_along(NAMES)) {
[17:44:48.964]                   name <- changed[[kk]]
[17:44:48.964]                   NAME <- NAMES[[kk]]
[17:44:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.964]                     next
[17:44:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.964]                 }
[17:44:48.964]                 NAMES <- toupper(added)
[17:44:48.964]                 for (kk in seq_along(NAMES)) {
[17:44:48.964]                   name <- added[[kk]]
[17:44:48.964]                   NAME <- NAMES[[kk]]
[17:44:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.964]                     next
[17:44:48.964]                   args[[name]] <- ""
[17:44:48.964]                 }
[17:44:48.964]                 NAMES <- toupper(removed)
[17:44:48.964]                 for (kk in seq_along(NAMES)) {
[17:44:48.964]                   name <- removed[[kk]]
[17:44:48.964]                   NAME <- NAMES[[kk]]
[17:44:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:48.964]                     next
[17:44:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:48.964]                 }
[17:44:48.964]                 if (length(args) > 0) 
[17:44:48.964]                   base::do.call(base::Sys.setenv, args = args)
[17:44:48.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:48.964]             }
[17:44:48.964]             else {
[17:44:48.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:48.964]             }
[17:44:48.964]             {
[17:44:48.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:48.964]                   0L) {
[17:44:48.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:48.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:48.964]                   base::options(opts)
[17:44:48.964]                 }
[17:44:48.964]                 {
[17:44:48.964]                   {
[17:44:48.964]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:48.964]                     NULL
[17:44:48.964]                   }
[17:44:48.964]                   options(future.plan = NULL)
[17:44:48.964]                   if (is.na(NA_character_)) 
[17:44:48.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:48.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:48.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:48.964]                     .init = FALSE)
[17:44:48.964]                 }
[17:44:48.964]             }
[17:44:48.964]         }
[17:44:48.964]     })
[17:44:48.964]     if (TRUE) {
[17:44:48.964]         base::sink(type = "output", split = FALSE)
[17:44:48.964]         if (TRUE) {
[17:44:48.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:48.964]         }
[17:44:48.964]         else {
[17:44:48.964]             ...future.result["stdout"] <- base::list(NULL)
[17:44:48.964]         }
[17:44:48.964]         base::close(...future.stdout)
[17:44:48.964]         ...future.stdout <- NULL
[17:44:48.964]     }
[17:44:48.964]     ...future.result$conditions <- ...future.conditions
[17:44:48.964]     ...future.result$finished <- base::Sys.time()
[17:44:48.964]     ...future.result
[17:44:48.964] }
[17:44:48.967] assign_globals() ...
[17:44:48.967] List of 5
[17:44:48.967]  $ ...future.FUN            :function (x)  
[17:44:48.967]  $ MoreArgs                 : NULL
[17:44:48.967]  $ ...future.elements_ii    :List of 1
[17:44:48.967]   ..$ :List of 1
[17:44:48.967]   .. ..$ b: num 0
[17:44:48.967]  $ ...future.seeds_ii       : NULL
[17:44:48.967]  $ ...future.globals.maxSize: NULL
[17:44:48.967]  - attr(*, "where")=List of 5
[17:44:48.967]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:44:48.967]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[17:44:48.967]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:44:48.967]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:44:48.967]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:44:48.967]  - attr(*, "resolved")= logi FALSE
[17:44:48.967]  - attr(*, "total_size")= num 904
[17:44:48.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:48.967]  - attr(*, "already-done")= logi TRUE
[17:44:48.976] - copied ‘...future.FUN’ to environment
[17:44:48.976] - copied ‘MoreArgs’ to environment
[17:44:48.976] - copied ‘...future.elements_ii’ to environment
[17:44:48.977] - copied ‘...future.seeds_ii’ to environment
[17:44:48.977] - copied ‘...future.globals.maxSize’ to environment
[17:44:48.977] assign_globals() ... done
[17:44:48.977] requestCore(): workers = 2
[17:44:48.980] MulticoreFuture started
[17:44:48.980] - Launch lazy future ... done
[17:44:48.981] plan(): Setting new future strategy stack:
[17:44:48.981] run() for ‘MulticoreFuture’ ... done
[17:44:48.982] Created future:
[17:44:48.981] List of future strategies:
[17:44:48.981] 1. sequential:
[17:44:48.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:48.981]    - tweaked: FALSE
[17:44:48.981]    - call: NULL
[17:44:48.983] plan(): nbrOfWorkers() = 1
[17:44:48.986] plan(): Setting new future strategy stack:
[17:44:48.986] List of future strategies:
[17:44:48.986] 1. multicore:
[17:44:48.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:44:48.986]    - tweaked: FALSE
[17:44:48.986]    - call: plan(strategy)
[17:44:48.993] plan(): nbrOfWorkers() = 2
[17:44:48.982] MulticoreFuture:
[17:44:48.982] Label: ‘future_mapply-2’
[17:44:48.982] Expression:
[17:44:48.982] {
[17:44:48.982]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:48.982]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:48.982]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:48.982]         on.exit(options(oopts), add = TRUE)
[17:44:48.982]     }
[17:44:48.982]     {
[17:44:48.982]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:48.982]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:48.982]         do.call(mapply, args = args)
[17:44:48.982]     }
[17:44:48.982] }
[17:44:48.982] Lazy evaluation: FALSE
[17:44:48.982] Asynchronous evaluation: TRUE
[17:44:48.982] Local evaluation: TRUE
[17:44:48.982] Environment: R_GlobalEnv
[17:44:48.982] Capture standard output: TRUE
[17:44:48.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:48.982] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:48.982] Packages: <none>
[17:44:48.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:48.982] Resolved: TRUE
[17:44:48.982] Value: <not collected>
[17:44:48.982] Conditions captured: <none>
[17:44:48.982] Early signaling: FALSE
[17:44:48.982] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:48.982] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:48.995] Chunk #2 of 2 ... DONE
[17:44:48.995] Launching 2 futures (chunks) ... DONE
[17:44:48.995] Resolving 2 futures (chunks) ...
[17:44:48.995] resolve() on list ...
[17:44:48.995]  recursive: 0
[17:44:48.996]  length: 2
[17:44:48.996] 
[17:44:48.996] Future #1
[17:44:48.996] result() for MulticoreFuture ...
[17:44:48.997] result() for MulticoreFuture ...
[17:44:48.998] result() for MulticoreFuture ... done
[17:44:48.998] result() for MulticoreFuture ... done
[17:44:48.998] result() for MulticoreFuture ...
[17:44:48.998] result() for MulticoreFuture ... done
[17:44:48.998] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:44:48.999] - nx: 2
[17:44:48.999] - relay: TRUE
[17:44:48.999] - stdout: TRUE
[17:44:48.999] - signal: TRUE
[17:44:49.000] - resignal: FALSE
[17:44:49.000] - force: TRUE
[17:44:49.000] - relayed: [n=2] FALSE, FALSE
[17:44:49.000] - queued futures: [n=2] FALSE, FALSE
[17:44:49.000]  - until=1
[17:44:49.001]  - relaying element #1
[17:44:49.001] result() for MulticoreFuture ...
[17:44:49.001] result() for MulticoreFuture ... done
[17:44:49.001] result() for MulticoreFuture ...
[17:44:49.002] result() for MulticoreFuture ... done
[17:44:49.002] result() for MulticoreFuture ...
[17:44:49.002] result() for MulticoreFuture ... done
[17:44:49.002] result() for MulticoreFuture ...
[17:44:49.002] result() for MulticoreFuture ... done
[17:44:49.002] - relayed: [n=2] TRUE, FALSE
[17:44:49.003] - queued futures: [n=2] TRUE, FALSE
[17:44:49.003] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:44:49.003]  length: 1 (resolved future 1)
[17:44:49.003] Future #2
[17:44:49.004] result() for MulticoreFuture ...
[17:44:49.004] result() for MulticoreFuture ...
[17:44:49.004] result() for MulticoreFuture ... done
[17:44:49.004] result() for MulticoreFuture ... done
[17:44:49.005] result() for MulticoreFuture ...
[17:44:49.005] result() for MulticoreFuture ... done
[17:44:49.005] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:44:49.005] - nx: 2
[17:44:49.005] - relay: TRUE
[17:44:49.005] - stdout: TRUE
[17:44:49.005] - signal: TRUE
[17:44:49.005] - resignal: FALSE
[17:44:49.006] - force: TRUE
[17:44:49.006] - relayed: [n=2] TRUE, FALSE
[17:44:49.006] - queued futures: [n=2] TRUE, FALSE
[17:44:49.006]  - until=2
[17:44:49.006]  - relaying element #2
[17:44:49.006] result() for MulticoreFuture ...
[17:44:49.006] result() for MulticoreFuture ... done
[17:44:49.006] result() for MulticoreFuture ...
[17:44:49.007] result() for MulticoreFuture ... done
[17:44:49.007] result() for MulticoreFuture ...
[17:44:49.007] result() for MulticoreFuture ... done
[17:44:49.007] result() for MulticoreFuture ...
[17:44:49.007] result() for MulticoreFuture ... done
[17:44:49.007] - relayed: [n=2] TRUE, TRUE
[17:44:49.007] - queued futures: [n=2] TRUE, TRUE
[17:44:49.007] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:44:49.008]  length: 0 (resolved future 2)
[17:44:49.008] Relaying remaining futures
[17:44:49.008] signalConditionsASAP(NULL, pos=0) ...
[17:44:49.008] - nx: 2
[17:44:49.008] - relay: TRUE
[17:44:49.008] - stdout: TRUE
[17:44:49.008] - signal: TRUE
[17:44:49.008] - resignal: FALSE
[17:44:49.008] - force: TRUE
[17:44:49.008] - relayed: [n=2] TRUE, TRUE
[17:44:49.009] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:49.009] - relayed: [n=2] TRUE, TRUE
[17:44:49.009] - queued futures: [n=2] TRUE, TRUE
[17:44:49.009] signalConditionsASAP(NULL, pos=0) ... done
[17:44:49.009] resolve() on list ... DONE
[17:44:49.009] result() for MulticoreFuture ...
[17:44:49.009] result() for MulticoreFuture ... done
[17:44:49.009] result() for MulticoreFuture ...
[17:44:49.009] result() for MulticoreFuture ... done
[17:44:49.010] result() for MulticoreFuture ...
[17:44:49.010] result() for MulticoreFuture ... done
[17:44:49.010] result() for MulticoreFuture ...
[17:44:49.010] result() for MulticoreFuture ... done
[17:44:49.010]  - Number of value chunks collected: 2
[17:44:49.010] Resolving 2 futures (chunks) ... DONE
[17:44:49.010] Reducing values from 2 chunks ...
[17:44:49.010]  - Number of values collected after concatenation: 2
[17:44:49.010]  - Number of values expected: 2
[17:44:49.011] Reducing values from 2 chunks ... DONE
[17:44:49.011] future_mapply() ... DONE
[17:44:49.011] plan(): Setting new future strategy stack:
[17:44:49.011] List of future strategies:
[17:44:49.011] 1. sequential:
[17:44:49.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:49.011]    - tweaked: FALSE
[17:44:49.011]    - call: plan(sequential)
[17:44:49.012] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:44:49.012] plan(): Setting new future strategy stack:
[17:44:49.012] List of future strategies:
[17:44:49.012] 1. multisession:
[17:44:49.012]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:44:49.012]    - tweaked: FALSE
[17:44:49.012]    - call: plan(strategy)
[17:44:49.012] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:44:49.013] multisession:
[17:44:49.013] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:44:49.013] - tweaked: FALSE
[17:44:49.013] - call: plan(strategy)
[17:44:49.019] getGlobalsAndPackages() ...
[17:44:49.019] Not searching for globals
[17:44:49.019] - globals: [0] <none>
[17:44:49.019] getGlobalsAndPackages() ... DONE
[17:44:49.020] [local output] makeClusterPSOCK() ...
[17:44:49.073] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:44:49.074] [local output] Base port: 11822
[17:44:49.074] [local output] Getting setup options for 2 cluster nodes ...
[17:44:49.074] [local output]  - Node 1 of 2 ...
[17:44:49.074] [local output] localMachine=TRUE => revtunnel=FALSE

[17:44:49.075] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp2mUjD6/worker.rank=1.parallelly.parent=34424.8678431d2afa.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp2mUjD6/worker.rank=1.parallelly.parent=34424.8678431d2afa.pid")'’
[17:44:49.263] - Possible to infer worker's PID: TRUE
[17:44:49.264] [local output] Rscript port: 11822

[17:44:49.264] [local output]  - Node 2 of 2 ...
[17:44:49.265] [local output] localMachine=TRUE => revtunnel=FALSE

[17:44:49.265] [local output] Rscript port: 11822

[17:44:49.265] [local output] Getting setup options for 2 cluster nodes ... done
[17:44:49.266] [local output]  - Parallel setup requested for some PSOCK nodes
[17:44:49.266] [local output] Setting up PSOCK nodes in parallel
[17:44:49.266] List of 36
[17:44:49.266]  $ worker          : chr "localhost"
[17:44:49.266]   ..- attr(*, "localhost")= logi TRUE
[17:44:49.266]  $ master          : chr "localhost"
[17:44:49.266]  $ port            : int 11822
[17:44:49.266]  $ connectTimeout  : num 120
[17:44:49.266]  $ timeout         : num 2592000
[17:44:49.266]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:44:49.266]  $ homogeneous     : logi TRUE
[17:44:49.266]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:44:49.266]  $ rscript_envs    : NULL
[17:44:49.266]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:44:49.266]  $ rscript_startup : NULL
[17:44:49.266]  $ rscript_sh      : chr "sh"
[17:44:49.266]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:44:49.266]  $ methods         : logi TRUE
[17:44:49.266]  $ socketOptions   : chr "no-delay"
[17:44:49.266]  $ useXDR          : logi FALSE
[17:44:49.266]  $ outfile         : chr "/dev/null"
[17:44:49.266]  $ renice          : int NA
[17:44:49.266]  $ rshcmd          : NULL
[17:44:49.266]  $ user            : chr(0) 
[17:44:49.266]  $ revtunnel       : logi FALSE
[17:44:49.266]  $ rshlogfile      : NULL
[17:44:49.266]  $ rshopts         : chr(0) 
[17:44:49.266]  $ rank            : int 1
[17:44:49.266]  $ manual          : logi FALSE
[17:44:49.266]  $ dryrun          : logi FALSE
[17:44:49.266]  $ quiet           : logi FALSE
[17:44:49.266]  $ setup_strategy  : chr "parallel"
[17:44:49.266]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:44:49.266]  $ pidfile         : chr "/tmp/Rtmp2mUjD6/worker.rank=1.parallelly.parent=34424.8678431d2afa.pid"
[17:44:49.266]  $ rshcmd_label    : NULL
[17:44:49.266]  $ rsh_call        : NULL
[17:44:49.266]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:44:49.266]  $ localMachine    : logi TRUE
[17:44:49.266]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:44:49.266]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:44:49.266]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:44:49.266]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:44:49.266]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:44:49.266]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:44:49.266]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:44:49.266]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:44:49.266]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:44:49.266]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:44:49.266]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:44:49.266]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:44:49.266]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:44:49.266]  $ arguments       :List of 28
[17:44:49.266]   ..$ worker          : chr "localhost"
[17:44:49.266]   ..$ master          : NULL
[17:44:49.266]   ..$ port            : int 11822
[17:44:49.266]   ..$ connectTimeout  : num 120
[17:44:49.266]   ..$ timeout         : num 2592000
[17:44:49.266]   ..$ rscript         : NULL
[17:44:49.266]   ..$ homogeneous     : NULL
[17:44:49.266]   ..$ rscript_args    : NULL
[17:44:49.266]   ..$ rscript_envs    : NULL
[17:44:49.266]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:44:49.266]   ..$ rscript_startup : NULL
[17:44:49.266]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:44:49.266]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:44:49.266]   ..$ methods         : logi TRUE
[17:44:49.266]   ..$ socketOptions   : chr "no-delay"
[17:44:49.266]   ..$ useXDR          : logi FALSE
[17:44:49.266]   ..$ outfile         : chr "/dev/null"
[17:44:49.266]   ..$ renice          : int NA
[17:44:49.266]   ..$ rshcmd          : NULL
[17:44:49.266]   ..$ user            : NULL
[17:44:49.266]   ..$ revtunnel       : logi NA
[17:44:49.266]   ..$ rshlogfile      : NULL
[17:44:49.266]   ..$ rshopts         : NULL
[17:44:49.266]   ..$ rank            : int 1
[17:44:49.266]   ..$ manual          : logi FALSE
[17:44:49.266]   ..$ dryrun          : logi FALSE
[17:44:49.266]   ..$ quiet           : logi FALSE
[17:44:49.266]   ..$ setup_strategy  : chr "parallel"
[17:44:49.266]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:44:49.283] [local output] System call to launch all workers:
[17:44:49.283] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp2mUjD6/worker.rank=1.parallelly.parent=34424.8678431d2afa.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11822 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:44:49.283] [local output] Starting PSOCK main server
[17:44:49.289] [local output] Workers launched
[17:44:49.289] [local output] Waiting for workers to connect back
[17:44:49.289]  - [local output] 0 workers out of 2 ready
[17:44:49.533]  - [local output] 0 workers out of 2 ready
[17:44:49.534]  - [local output] 1 workers out of 2 ready
[17:44:49.534]  - [local output] 2 workers out of 2 ready
[17:44:49.534] [local output] Launching of workers completed
[17:44:49.534] [local output] Collecting session information from workers
[17:44:49.535] [local output]  - Worker #1 of 2
[17:44:49.535] [local output]  - Worker #2 of 2
[17:44:49.536] [local output] makeClusterPSOCK() ... done
[17:44:49.547] Packages needed by the future expression (n = 0): <none>
[17:44:49.547] Packages needed by future strategies (n = 0): <none>
[17:44:49.547] {
[17:44:49.547]     {
[17:44:49.547]         {
[17:44:49.547]             ...future.startTime <- base::Sys.time()
[17:44:49.547]             {
[17:44:49.547]                 {
[17:44:49.547]                   {
[17:44:49.547]                     {
[17:44:49.547]                       base::local({
[17:44:49.547]                         has_future <- base::requireNamespace("future", 
[17:44:49.547]                           quietly = TRUE)
[17:44:49.547]                         if (has_future) {
[17:44:49.547]                           ns <- base::getNamespace("future")
[17:44:49.547]                           version <- ns[[".package"]][["version"]]
[17:44:49.547]                           if (is.null(version)) 
[17:44:49.547]                             version <- utils::packageVersion("future")
[17:44:49.547]                         }
[17:44:49.547]                         else {
[17:44:49.547]                           version <- NULL
[17:44:49.547]                         }
[17:44:49.547]                         if (!has_future || version < "1.8.0") {
[17:44:49.547]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:49.547]                             "", base::R.version$version.string), 
[17:44:49.547]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:49.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:49.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:49.547]                               "release", "version")], collapse = " "), 
[17:44:49.547]                             hostname = base::Sys.info()[["nodename"]])
[17:44:49.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:49.547]                             info)
[17:44:49.547]                           info <- base::paste(info, collapse = "; ")
[17:44:49.547]                           if (!has_future) {
[17:44:49.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:49.547]                               info)
[17:44:49.547]                           }
[17:44:49.547]                           else {
[17:44:49.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:49.547]                               info, version)
[17:44:49.547]                           }
[17:44:49.547]                           base::stop(msg)
[17:44:49.547]                         }
[17:44:49.547]                       })
[17:44:49.547]                     }
[17:44:49.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:49.547]                     base::options(mc.cores = 1L)
[17:44:49.547]                   }
[17:44:49.547]                   ...future.strategy.old <- future::plan("list")
[17:44:49.547]                   options(future.plan = NULL)
[17:44:49.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:49.547]                 }
[17:44:49.547]                 ...future.workdir <- getwd()
[17:44:49.547]             }
[17:44:49.547]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:49.547]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:49.547]         }
[17:44:49.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:49.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:49.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:49.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:49.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:49.547]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:49.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:49.547]             base::names(...future.oldOptions))
[17:44:49.547]     }
[17:44:49.547]     if (FALSE) {
[17:44:49.547]     }
[17:44:49.547]     else {
[17:44:49.547]         if (TRUE) {
[17:44:49.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:49.547]                 open = "w")
[17:44:49.547]         }
[17:44:49.547]         else {
[17:44:49.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:49.547]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:49.547]         }
[17:44:49.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:49.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:49.547]             base::sink(type = "output", split = FALSE)
[17:44:49.547]             base::close(...future.stdout)
[17:44:49.547]         }, add = TRUE)
[17:44:49.547]     }
[17:44:49.547]     ...future.frame <- base::sys.nframe()
[17:44:49.547]     ...future.conditions <- base::list()
[17:44:49.547]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:49.547]     if (FALSE) {
[17:44:49.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:49.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:49.547]     }
[17:44:49.547]     ...future.result <- base::tryCatch({
[17:44:49.547]         base::withCallingHandlers({
[17:44:49.547]             ...future.value <- base::withVisible(base::local({
[17:44:49.547]                 ...future.makeSendCondition <- base::local({
[17:44:49.547]                   sendCondition <- NULL
[17:44:49.547]                   function(frame = 1L) {
[17:44:49.547]                     if (is.function(sendCondition)) 
[17:44:49.547]                       return(sendCondition)
[17:44:49.547]                     ns <- getNamespace("parallel")
[17:44:49.547]                     if (exists("sendData", mode = "function", 
[17:44:49.547]                       envir = ns)) {
[17:44:49.547]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:49.547]                         envir = ns)
[17:44:49.547]                       envir <- sys.frame(frame)
[17:44:49.547]                       master <- NULL
[17:44:49.547]                       while (!identical(envir, .GlobalEnv) && 
[17:44:49.547]                         !identical(envir, emptyenv())) {
[17:44:49.547]                         if (exists("master", mode = "list", envir = envir, 
[17:44:49.547]                           inherits = FALSE)) {
[17:44:49.547]                           master <- get("master", mode = "list", 
[17:44:49.547]                             envir = envir, inherits = FALSE)
[17:44:49.547]                           if (inherits(master, c("SOCKnode", 
[17:44:49.547]                             "SOCK0node"))) {
[17:44:49.547]                             sendCondition <<- function(cond) {
[17:44:49.547]                               data <- list(type = "VALUE", value = cond, 
[17:44:49.547]                                 success = TRUE)
[17:44:49.547]                               parallel_sendData(master, data)
[17:44:49.547]                             }
[17:44:49.547]                             return(sendCondition)
[17:44:49.547]                           }
[17:44:49.547]                         }
[17:44:49.547]                         frame <- frame + 1L
[17:44:49.547]                         envir <- sys.frame(frame)
[17:44:49.547]                       }
[17:44:49.547]                     }
[17:44:49.547]                     sendCondition <<- function(cond) NULL
[17:44:49.547]                   }
[17:44:49.547]                 })
[17:44:49.547]                 withCallingHandlers({
[17:44:49.547]                   NA
[17:44:49.547]                 }, immediateCondition = function(cond) {
[17:44:49.547]                   sendCondition <- ...future.makeSendCondition()
[17:44:49.547]                   sendCondition(cond)
[17:44:49.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.547]                   {
[17:44:49.547]                     inherits <- base::inherits
[17:44:49.547]                     invokeRestart <- base::invokeRestart
[17:44:49.547]                     is.null <- base::is.null
[17:44:49.547]                     muffled <- FALSE
[17:44:49.547]                     if (inherits(cond, "message")) {
[17:44:49.547]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:49.547]                       if (muffled) 
[17:44:49.547]                         invokeRestart("muffleMessage")
[17:44:49.547]                     }
[17:44:49.547]                     else if (inherits(cond, "warning")) {
[17:44:49.547]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:49.547]                       if (muffled) 
[17:44:49.547]                         invokeRestart("muffleWarning")
[17:44:49.547]                     }
[17:44:49.547]                     else if (inherits(cond, "condition")) {
[17:44:49.547]                       if (!is.null(pattern)) {
[17:44:49.547]                         computeRestarts <- base::computeRestarts
[17:44:49.547]                         grepl <- base::grepl
[17:44:49.547]                         restarts <- computeRestarts(cond)
[17:44:49.547]                         for (restart in restarts) {
[17:44:49.547]                           name <- restart$name
[17:44:49.547]                           if (is.null(name)) 
[17:44:49.547]                             next
[17:44:49.547]                           if (!grepl(pattern, name)) 
[17:44:49.547]                             next
[17:44:49.547]                           invokeRestart(restart)
[17:44:49.547]                           muffled <- TRUE
[17:44:49.547]                           break
[17:44:49.547]                         }
[17:44:49.547]                       }
[17:44:49.547]                     }
[17:44:49.547]                     invisible(muffled)
[17:44:49.547]                   }
[17:44:49.547]                   muffleCondition(cond)
[17:44:49.547]                 })
[17:44:49.547]             }))
[17:44:49.547]             future::FutureResult(value = ...future.value$value, 
[17:44:49.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.547]                   ...future.rng), globalenv = if (FALSE) 
[17:44:49.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:49.547]                     ...future.globalenv.names))
[17:44:49.547]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:49.547]         }, condition = base::local({
[17:44:49.547]             c <- base::c
[17:44:49.547]             inherits <- base::inherits
[17:44:49.547]             invokeRestart <- base::invokeRestart
[17:44:49.547]             length <- base::length
[17:44:49.547]             list <- base::list
[17:44:49.547]             seq.int <- base::seq.int
[17:44:49.547]             signalCondition <- base::signalCondition
[17:44:49.547]             sys.calls <- base::sys.calls
[17:44:49.547]             `[[` <- base::`[[`
[17:44:49.547]             `+` <- base::`+`
[17:44:49.547]             `<<-` <- base::`<<-`
[17:44:49.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:49.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:49.547]                   3L)]
[17:44:49.547]             }
[17:44:49.547]             function(cond) {
[17:44:49.547]                 is_error <- inherits(cond, "error")
[17:44:49.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:49.547]                   NULL)
[17:44:49.547]                 if (is_error) {
[17:44:49.547]                   sessionInformation <- function() {
[17:44:49.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:49.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:49.547]                       search = base::search(), system = base::Sys.info())
[17:44:49.547]                   }
[17:44:49.547]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:49.547]                     cond$call), session = sessionInformation(), 
[17:44:49.547]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:49.547]                   signalCondition(cond)
[17:44:49.547]                 }
[17:44:49.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:49.547]                 "immediateCondition"))) {
[17:44:49.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:49.547]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:49.547]                   if (TRUE && !signal) {
[17:44:49.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.547]                     {
[17:44:49.547]                       inherits <- base::inherits
[17:44:49.547]                       invokeRestart <- base::invokeRestart
[17:44:49.547]                       is.null <- base::is.null
[17:44:49.547]                       muffled <- FALSE
[17:44:49.547]                       if (inherits(cond, "message")) {
[17:44:49.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.547]                         if (muffled) 
[17:44:49.547]                           invokeRestart("muffleMessage")
[17:44:49.547]                       }
[17:44:49.547]                       else if (inherits(cond, "warning")) {
[17:44:49.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.547]                         if (muffled) 
[17:44:49.547]                           invokeRestart("muffleWarning")
[17:44:49.547]                       }
[17:44:49.547]                       else if (inherits(cond, "condition")) {
[17:44:49.547]                         if (!is.null(pattern)) {
[17:44:49.547]                           computeRestarts <- base::computeRestarts
[17:44:49.547]                           grepl <- base::grepl
[17:44:49.547]                           restarts <- computeRestarts(cond)
[17:44:49.547]                           for (restart in restarts) {
[17:44:49.547]                             name <- restart$name
[17:44:49.547]                             if (is.null(name)) 
[17:44:49.547]                               next
[17:44:49.547]                             if (!grepl(pattern, name)) 
[17:44:49.547]                               next
[17:44:49.547]                             invokeRestart(restart)
[17:44:49.547]                             muffled <- TRUE
[17:44:49.547]                             break
[17:44:49.547]                           }
[17:44:49.547]                         }
[17:44:49.547]                       }
[17:44:49.547]                       invisible(muffled)
[17:44:49.547]                     }
[17:44:49.547]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.547]                   }
[17:44:49.547]                 }
[17:44:49.547]                 else {
[17:44:49.547]                   if (TRUE) {
[17:44:49.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.547]                     {
[17:44:49.547]                       inherits <- base::inherits
[17:44:49.547]                       invokeRestart <- base::invokeRestart
[17:44:49.547]                       is.null <- base::is.null
[17:44:49.547]                       muffled <- FALSE
[17:44:49.547]                       if (inherits(cond, "message")) {
[17:44:49.547]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.547]                         if (muffled) 
[17:44:49.547]                           invokeRestart("muffleMessage")
[17:44:49.547]                       }
[17:44:49.547]                       else if (inherits(cond, "warning")) {
[17:44:49.547]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.547]                         if (muffled) 
[17:44:49.547]                           invokeRestart("muffleWarning")
[17:44:49.547]                       }
[17:44:49.547]                       else if (inherits(cond, "condition")) {
[17:44:49.547]                         if (!is.null(pattern)) {
[17:44:49.547]                           computeRestarts <- base::computeRestarts
[17:44:49.547]                           grepl <- base::grepl
[17:44:49.547]                           restarts <- computeRestarts(cond)
[17:44:49.547]                           for (restart in restarts) {
[17:44:49.547]                             name <- restart$name
[17:44:49.547]                             if (is.null(name)) 
[17:44:49.547]                               next
[17:44:49.547]                             if (!grepl(pattern, name)) 
[17:44:49.547]                               next
[17:44:49.547]                             invokeRestart(restart)
[17:44:49.547]                             muffled <- TRUE
[17:44:49.547]                             break
[17:44:49.547]                           }
[17:44:49.547]                         }
[17:44:49.547]                       }
[17:44:49.547]                       invisible(muffled)
[17:44:49.547]                     }
[17:44:49.547]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.547]                   }
[17:44:49.547]                 }
[17:44:49.547]             }
[17:44:49.547]         }))
[17:44:49.547]     }, error = function(ex) {
[17:44:49.547]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:49.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.547]                 ...future.rng), started = ...future.startTime, 
[17:44:49.547]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:49.547]             version = "1.8"), class = "FutureResult")
[17:44:49.547]     }, finally = {
[17:44:49.547]         if (!identical(...future.workdir, getwd())) 
[17:44:49.547]             setwd(...future.workdir)
[17:44:49.547]         {
[17:44:49.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:49.547]                 ...future.oldOptions$nwarnings <- NULL
[17:44:49.547]             }
[17:44:49.547]             base::options(...future.oldOptions)
[17:44:49.547]             if (.Platform$OS.type == "windows") {
[17:44:49.547]                 old_names <- names(...future.oldEnvVars)
[17:44:49.547]                 envs <- base::Sys.getenv()
[17:44:49.547]                 names <- names(envs)
[17:44:49.547]                 common <- intersect(names, old_names)
[17:44:49.547]                 added <- setdiff(names, old_names)
[17:44:49.547]                 removed <- setdiff(old_names, names)
[17:44:49.547]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:49.547]                   envs[common]]
[17:44:49.547]                 NAMES <- toupper(changed)
[17:44:49.547]                 args <- list()
[17:44:49.547]                 for (kk in seq_along(NAMES)) {
[17:44:49.547]                   name <- changed[[kk]]
[17:44:49.547]                   NAME <- NAMES[[kk]]
[17:44:49.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.547]                     next
[17:44:49.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.547]                 }
[17:44:49.547]                 NAMES <- toupper(added)
[17:44:49.547]                 for (kk in seq_along(NAMES)) {
[17:44:49.547]                   name <- added[[kk]]
[17:44:49.547]                   NAME <- NAMES[[kk]]
[17:44:49.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.547]                     next
[17:44:49.547]                   args[[name]] <- ""
[17:44:49.547]                 }
[17:44:49.547]                 NAMES <- toupper(removed)
[17:44:49.547]                 for (kk in seq_along(NAMES)) {
[17:44:49.547]                   name <- removed[[kk]]
[17:44:49.547]                   NAME <- NAMES[[kk]]
[17:44:49.547]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.547]                     next
[17:44:49.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.547]                 }
[17:44:49.547]                 if (length(args) > 0) 
[17:44:49.547]                   base::do.call(base::Sys.setenv, args = args)
[17:44:49.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:49.547]             }
[17:44:49.547]             else {
[17:44:49.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:49.547]             }
[17:44:49.547]             {
[17:44:49.547]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:49.547]                   0L) {
[17:44:49.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:49.547]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:49.547]                   base::options(opts)
[17:44:49.547]                 }
[17:44:49.547]                 {
[17:44:49.547]                   {
[17:44:49.547]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:49.547]                     NULL
[17:44:49.547]                   }
[17:44:49.547]                   options(future.plan = NULL)
[17:44:49.547]                   if (is.na(NA_character_)) 
[17:44:49.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:49.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:49.547]                     .init = FALSE)
[17:44:49.547]                 }
[17:44:49.547]             }
[17:44:49.547]         }
[17:44:49.547]     })
[17:44:49.547]     if (TRUE) {
[17:44:49.547]         base::sink(type = "output", split = FALSE)
[17:44:49.547]         if (TRUE) {
[17:44:49.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:49.547]         }
[17:44:49.547]         else {
[17:44:49.547]             ...future.result["stdout"] <- base::list(NULL)
[17:44:49.547]         }
[17:44:49.547]         base::close(...future.stdout)
[17:44:49.547]         ...future.stdout <- NULL
[17:44:49.547]     }
[17:44:49.547]     ...future.result$conditions <- ...future.conditions
[17:44:49.547]     ...future.result$finished <- base::Sys.time()
[17:44:49.547]     ...future.result
[17:44:49.547] }
[17:44:49.599] MultisessionFuture started
[17:44:49.600] result() for ClusterFuture ...
[17:44:49.600] receiveMessageFromWorker() for ClusterFuture ...
[17:44:49.601] - Validating connection of MultisessionFuture
[17:44:49.632] - received message: FutureResult
[17:44:49.632] - Received FutureResult
[17:44:49.632] - Erased future from FutureRegistry
[17:44:49.632] result() for ClusterFuture ...
[17:44:49.633] - result already collected: FutureResult
[17:44:49.633] result() for ClusterFuture ... done
[17:44:49.633] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:49.633] result() for ClusterFuture ... done
[17:44:49.633] result() for ClusterFuture ...
[17:44:49.633] - result already collected: FutureResult
[17:44:49.633] result() for ClusterFuture ... done
[17:44:49.633] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:44:49.637] plan(): nbrOfWorkers() = 2
- From example(mapply) ...
[17:44:49.638] future_mapply() ...
[17:44:49.641] Number of chunks: 2
[17:44:49.641] getGlobalsAndPackagesXApply() ...
[17:44:49.641]  - future.globals: TRUE
[17:44:49.642] getGlobalsAndPackages() ...
[17:44:49.642] Searching for globals...
[17:44:49.642] - globals found: [1] ‘FUN’
[17:44:49.642] Searching for globals ... DONE
[17:44:49.643] Resolving globals: FALSE
[17:44:49.643] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:49.643] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:49.643] - globals: [1] ‘FUN’
[17:44:49.644] 
[17:44:49.644] getGlobalsAndPackages() ... DONE
[17:44:49.644]  - globals found/used: [n=1] ‘FUN’
[17:44:49.644]  - needed namespaces: [n=0] 
[17:44:49.644] Finding globals ... DONE
[17:44:49.644] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:49.644] List of 2
[17:44:49.644]  $ ...future.FUN:function (x, ...)  
[17:44:49.644]  $ MoreArgs     : NULL
[17:44:49.644]  - attr(*, "where")=List of 2
[17:44:49.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:49.644]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:49.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:49.644]  - attr(*, "resolved")= logi FALSE
[17:44:49.644]  - attr(*, "total_size")= num NA
[17:44:49.647] Packages to be attached in all futures: [n=0] 
[17:44:49.647] getGlobalsAndPackagesXApply() ... DONE
[17:44:49.648] Number of futures (= number of chunks): 2
[17:44:49.648] Launching 2 futures (chunks) ...
[17:44:49.648] Chunk #1 of 2 ...
[17:44:49.648]  - Finding globals in '...' for chunk #1 ...
[17:44:49.648] getGlobalsAndPackages() ...
[17:44:49.648] Searching for globals...
[17:44:49.649] 
[17:44:49.649] Searching for globals ... DONE
[17:44:49.649] - globals: [0] <none>
[17:44:49.649] getGlobalsAndPackages() ... DONE
[17:44:49.649]    + additional globals found: [n=0] 
[17:44:49.649]    + additional namespaces needed: [n=0] 
[17:44:49.649]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:49.650]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:49.650]  - seeds: <none>
[17:44:49.650]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.650] getGlobalsAndPackages() ...
[17:44:49.650] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.650] Resolving globals: FALSE
[17:44:49.651] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:49.651] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:49.651] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.652] 
[17:44:49.652] getGlobalsAndPackages() ... DONE
[17:44:49.652] run() for ‘Future’ ...
[17:44:49.652] - state: ‘created’
[17:44:49.652] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:49.666] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.667] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:49.667]   - Field: ‘node’
[17:44:49.667]   - Field: ‘label’
[17:44:49.667]   - Field: ‘local’
[17:44:49.667]   - Field: ‘owner’
[17:44:49.667]   - Field: ‘envir’
[17:44:49.667]   - Field: ‘workers’
[17:44:49.667]   - Field: ‘packages’
[17:44:49.667]   - Field: ‘gc’
[17:44:49.668]   - Field: ‘conditions’
[17:44:49.668]   - Field: ‘persistent’
[17:44:49.668]   - Field: ‘expr’
[17:44:49.668]   - Field: ‘uuid’
[17:44:49.668]   - Field: ‘seed’
[17:44:49.668]   - Field: ‘version’
[17:44:49.668]   - Field: ‘result’
[17:44:49.668]   - Field: ‘asynchronous’
[17:44:49.668]   - Field: ‘calls’
[17:44:49.669]   - Field: ‘globals’
[17:44:49.669]   - Field: ‘stdout’
[17:44:49.669]   - Field: ‘earlySignal’
[17:44:49.669]   - Field: ‘lazy’
[17:44:49.669]   - Field: ‘state’
[17:44:49.669] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:49.669] - Launch lazy future ...
[17:44:49.670] Packages needed by the future expression (n = 0): <none>
[17:44:49.670] Packages needed by future strategies (n = 0): <none>
[17:44:49.670] {
[17:44:49.670]     {
[17:44:49.670]         {
[17:44:49.670]             ...future.startTime <- base::Sys.time()
[17:44:49.670]             {
[17:44:49.670]                 {
[17:44:49.670]                   {
[17:44:49.670]                     {
[17:44:49.670]                       base::local({
[17:44:49.670]                         has_future <- base::requireNamespace("future", 
[17:44:49.670]                           quietly = TRUE)
[17:44:49.670]                         if (has_future) {
[17:44:49.670]                           ns <- base::getNamespace("future")
[17:44:49.670]                           version <- ns[[".package"]][["version"]]
[17:44:49.670]                           if (is.null(version)) 
[17:44:49.670]                             version <- utils::packageVersion("future")
[17:44:49.670]                         }
[17:44:49.670]                         else {
[17:44:49.670]                           version <- NULL
[17:44:49.670]                         }
[17:44:49.670]                         if (!has_future || version < "1.8.0") {
[17:44:49.670]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:49.670]                             "", base::R.version$version.string), 
[17:44:49.670]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:49.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:49.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:49.670]                               "release", "version")], collapse = " "), 
[17:44:49.670]                             hostname = base::Sys.info()[["nodename"]])
[17:44:49.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:49.670]                             info)
[17:44:49.670]                           info <- base::paste(info, collapse = "; ")
[17:44:49.670]                           if (!has_future) {
[17:44:49.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:49.670]                               info)
[17:44:49.670]                           }
[17:44:49.670]                           else {
[17:44:49.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:49.670]                               info, version)
[17:44:49.670]                           }
[17:44:49.670]                           base::stop(msg)
[17:44:49.670]                         }
[17:44:49.670]                       })
[17:44:49.670]                     }
[17:44:49.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:49.670]                     base::options(mc.cores = 1L)
[17:44:49.670]                   }
[17:44:49.670]                   ...future.strategy.old <- future::plan("list")
[17:44:49.670]                   options(future.plan = NULL)
[17:44:49.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:49.670]                 }
[17:44:49.670]                 ...future.workdir <- getwd()
[17:44:49.670]             }
[17:44:49.670]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:49.670]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:49.670]         }
[17:44:49.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:49.670]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:49.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:49.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:49.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:49.670]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:49.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:49.670]             base::names(...future.oldOptions))
[17:44:49.670]     }
[17:44:49.670]     if (FALSE) {
[17:44:49.670]     }
[17:44:49.670]     else {
[17:44:49.670]         if (TRUE) {
[17:44:49.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:49.670]                 open = "w")
[17:44:49.670]         }
[17:44:49.670]         else {
[17:44:49.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:49.670]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:49.670]         }
[17:44:49.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:49.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:49.670]             base::sink(type = "output", split = FALSE)
[17:44:49.670]             base::close(...future.stdout)
[17:44:49.670]         }, add = TRUE)
[17:44:49.670]     }
[17:44:49.670]     ...future.frame <- base::sys.nframe()
[17:44:49.670]     ...future.conditions <- base::list()
[17:44:49.670]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:49.670]     if (FALSE) {
[17:44:49.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:49.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:49.670]     }
[17:44:49.670]     ...future.result <- base::tryCatch({
[17:44:49.670]         base::withCallingHandlers({
[17:44:49.670]             ...future.value <- base::withVisible(base::local({
[17:44:49.670]                 ...future.makeSendCondition <- base::local({
[17:44:49.670]                   sendCondition <- NULL
[17:44:49.670]                   function(frame = 1L) {
[17:44:49.670]                     if (is.function(sendCondition)) 
[17:44:49.670]                       return(sendCondition)
[17:44:49.670]                     ns <- getNamespace("parallel")
[17:44:49.670]                     if (exists("sendData", mode = "function", 
[17:44:49.670]                       envir = ns)) {
[17:44:49.670]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:49.670]                         envir = ns)
[17:44:49.670]                       envir <- sys.frame(frame)
[17:44:49.670]                       master <- NULL
[17:44:49.670]                       while (!identical(envir, .GlobalEnv) && 
[17:44:49.670]                         !identical(envir, emptyenv())) {
[17:44:49.670]                         if (exists("master", mode = "list", envir = envir, 
[17:44:49.670]                           inherits = FALSE)) {
[17:44:49.670]                           master <- get("master", mode = "list", 
[17:44:49.670]                             envir = envir, inherits = FALSE)
[17:44:49.670]                           if (inherits(master, c("SOCKnode", 
[17:44:49.670]                             "SOCK0node"))) {
[17:44:49.670]                             sendCondition <<- function(cond) {
[17:44:49.670]                               data <- list(type = "VALUE", value = cond, 
[17:44:49.670]                                 success = TRUE)
[17:44:49.670]                               parallel_sendData(master, data)
[17:44:49.670]                             }
[17:44:49.670]                             return(sendCondition)
[17:44:49.670]                           }
[17:44:49.670]                         }
[17:44:49.670]                         frame <- frame + 1L
[17:44:49.670]                         envir <- sys.frame(frame)
[17:44:49.670]                       }
[17:44:49.670]                     }
[17:44:49.670]                     sendCondition <<- function(cond) NULL
[17:44:49.670]                   }
[17:44:49.670]                 })
[17:44:49.670]                 withCallingHandlers({
[17:44:49.670]                   {
[17:44:49.670]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.670]                     if (!identical(...future.globals.maxSize.org, 
[17:44:49.670]                       ...future.globals.maxSize)) {
[17:44:49.670]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.670]                       on.exit(options(oopts), add = TRUE)
[17:44:49.670]                     }
[17:44:49.670]                     {
[17:44:49.670]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.670]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:49.670]                         USE.NAMES = FALSE)
[17:44:49.670]                       do.call(mapply, args = args)
[17:44:49.670]                     }
[17:44:49.670]                   }
[17:44:49.670]                 }, immediateCondition = function(cond) {
[17:44:49.670]                   sendCondition <- ...future.makeSendCondition()
[17:44:49.670]                   sendCondition(cond)
[17:44:49.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.670]                   {
[17:44:49.670]                     inherits <- base::inherits
[17:44:49.670]                     invokeRestart <- base::invokeRestart
[17:44:49.670]                     is.null <- base::is.null
[17:44:49.670]                     muffled <- FALSE
[17:44:49.670]                     if (inherits(cond, "message")) {
[17:44:49.670]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:49.670]                       if (muffled) 
[17:44:49.670]                         invokeRestart("muffleMessage")
[17:44:49.670]                     }
[17:44:49.670]                     else if (inherits(cond, "warning")) {
[17:44:49.670]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:49.670]                       if (muffled) 
[17:44:49.670]                         invokeRestart("muffleWarning")
[17:44:49.670]                     }
[17:44:49.670]                     else if (inherits(cond, "condition")) {
[17:44:49.670]                       if (!is.null(pattern)) {
[17:44:49.670]                         computeRestarts <- base::computeRestarts
[17:44:49.670]                         grepl <- base::grepl
[17:44:49.670]                         restarts <- computeRestarts(cond)
[17:44:49.670]                         for (restart in restarts) {
[17:44:49.670]                           name <- restart$name
[17:44:49.670]                           if (is.null(name)) 
[17:44:49.670]                             next
[17:44:49.670]                           if (!grepl(pattern, name)) 
[17:44:49.670]                             next
[17:44:49.670]                           invokeRestart(restart)
[17:44:49.670]                           muffled <- TRUE
[17:44:49.670]                           break
[17:44:49.670]                         }
[17:44:49.670]                       }
[17:44:49.670]                     }
[17:44:49.670]                     invisible(muffled)
[17:44:49.670]                   }
[17:44:49.670]                   muffleCondition(cond)
[17:44:49.670]                 })
[17:44:49.670]             }))
[17:44:49.670]             future::FutureResult(value = ...future.value$value, 
[17:44:49.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.670]                   ...future.rng), globalenv = if (FALSE) 
[17:44:49.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:49.670]                     ...future.globalenv.names))
[17:44:49.670]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:49.670]         }, condition = base::local({
[17:44:49.670]             c <- base::c
[17:44:49.670]             inherits <- base::inherits
[17:44:49.670]             invokeRestart <- base::invokeRestart
[17:44:49.670]             length <- base::length
[17:44:49.670]             list <- base::list
[17:44:49.670]             seq.int <- base::seq.int
[17:44:49.670]             signalCondition <- base::signalCondition
[17:44:49.670]             sys.calls <- base::sys.calls
[17:44:49.670]             `[[` <- base::`[[`
[17:44:49.670]             `+` <- base::`+`
[17:44:49.670]             `<<-` <- base::`<<-`
[17:44:49.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:49.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:49.670]                   3L)]
[17:44:49.670]             }
[17:44:49.670]             function(cond) {
[17:44:49.670]                 is_error <- inherits(cond, "error")
[17:44:49.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:49.670]                   NULL)
[17:44:49.670]                 if (is_error) {
[17:44:49.670]                   sessionInformation <- function() {
[17:44:49.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:49.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:49.670]                       search = base::search(), system = base::Sys.info())
[17:44:49.670]                   }
[17:44:49.670]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:49.670]                     cond$call), session = sessionInformation(), 
[17:44:49.670]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:49.670]                   signalCondition(cond)
[17:44:49.670]                 }
[17:44:49.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:49.670]                 "immediateCondition"))) {
[17:44:49.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:49.670]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:49.670]                   if (TRUE && !signal) {
[17:44:49.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.670]                     {
[17:44:49.670]                       inherits <- base::inherits
[17:44:49.670]                       invokeRestart <- base::invokeRestart
[17:44:49.670]                       is.null <- base::is.null
[17:44:49.670]                       muffled <- FALSE
[17:44:49.670]                       if (inherits(cond, "message")) {
[17:44:49.670]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.670]                         if (muffled) 
[17:44:49.670]                           invokeRestart("muffleMessage")
[17:44:49.670]                       }
[17:44:49.670]                       else if (inherits(cond, "warning")) {
[17:44:49.670]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.670]                         if (muffled) 
[17:44:49.670]                           invokeRestart("muffleWarning")
[17:44:49.670]                       }
[17:44:49.670]                       else if (inherits(cond, "condition")) {
[17:44:49.670]                         if (!is.null(pattern)) {
[17:44:49.670]                           computeRestarts <- base::computeRestarts
[17:44:49.670]                           grepl <- base::grepl
[17:44:49.670]                           restarts <- computeRestarts(cond)
[17:44:49.670]                           for (restart in restarts) {
[17:44:49.670]                             name <- restart$name
[17:44:49.670]                             if (is.null(name)) 
[17:44:49.670]                               next
[17:44:49.670]                             if (!grepl(pattern, name)) 
[17:44:49.670]                               next
[17:44:49.670]                             invokeRestart(restart)
[17:44:49.670]                             muffled <- TRUE
[17:44:49.670]                             break
[17:44:49.670]                           }
[17:44:49.670]                         }
[17:44:49.670]                       }
[17:44:49.670]                       invisible(muffled)
[17:44:49.670]                     }
[17:44:49.670]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.670]                   }
[17:44:49.670]                 }
[17:44:49.670]                 else {
[17:44:49.670]                   if (TRUE) {
[17:44:49.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.670]                     {
[17:44:49.670]                       inherits <- base::inherits
[17:44:49.670]                       invokeRestart <- base::invokeRestart
[17:44:49.670]                       is.null <- base::is.null
[17:44:49.670]                       muffled <- FALSE
[17:44:49.670]                       if (inherits(cond, "message")) {
[17:44:49.670]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.670]                         if (muffled) 
[17:44:49.670]                           invokeRestart("muffleMessage")
[17:44:49.670]                       }
[17:44:49.670]                       else if (inherits(cond, "warning")) {
[17:44:49.670]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.670]                         if (muffled) 
[17:44:49.670]                           invokeRestart("muffleWarning")
[17:44:49.670]                       }
[17:44:49.670]                       else if (inherits(cond, "condition")) {
[17:44:49.670]                         if (!is.null(pattern)) {
[17:44:49.670]                           computeRestarts <- base::computeRestarts
[17:44:49.670]                           grepl <- base::grepl
[17:44:49.670]                           restarts <- computeRestarts(cond)
[17:44:49.670]                           for (restart in restarts) {
[17:44:49.670]                             name <- restart$name
[17:44:49.670]                             if (is.null(name)) 
[17:44:49.670]                               next
[17:44:49.670]                             if (!grepl(pattern, name)) 
[17:44:49.670]                               next
[17:44:49.670]                             invokeRestart(restart)
[17:44:49.670]                             muffled <- TRUE
[17:44:49.670]                             break
[17:44:49.670]                           }
[17:44:49.670]                         }
[17:44:49.670]                       }
[17:44:49.670]                       invisible(muffled)
[17:44:49.670]                     }
[17:44:49.670]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.670]                   }
[17:44:49.670]                 }
[17:44:49.670]             }
[17:44:49.670]         }))
[17:44:49.670]     }, error = function(ex) {
[17:44:49.670]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:49.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.670]                 ...future.rng), started = ...future.startTime, 
[17:44:49.670]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:49.670]             version = "1.8"), class = "FutureResult")
[17:44:49.670]     }, finally = {
[17:44:49.670]         if (!identical(...future.workdir, getwd())) 
[17:44:49.670]             setwd(...future.workdir)
[17:44:49.670]         {
[17:44:49.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:49.670]                 ...future.oldOptions$nwarnings <- NULL
[17:44:49.670]             }
[17:44:49.670]             base::options(...future.oldOptions)
[17:44:49.670]             if (.Platform$OS.type == "windows") {
[17:44:49.670]                 old_names <- names(...future.oldEnvVars)
[17:44:49.670]                 envs <- base::Sys.getenv()
[17:44:49.670]                 names <- names(envs)
[17:44:49.670]                 common <- intersect(names, old_names)
[17:44:49.670]                 added <- setdiff(names, old_names)
[17:44:49.670]                 removed <- setdiff(old_names, names)
[17:44:49.670]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:49.670]                   envs[common]]
[17:44:49.670]                 NAMES <- toupper(changed)
[17:44:49.670]                 args <- list()
[17:44:49.670]                 for (kk in seq_along(NAMES)) {
[17:44:49.670]                   name <- changed[[kk]]
[17:44:49.670]                   NAME <- NAMES[[kk]]
[17:44:49.670]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.670]                     next
[17:44:49.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.670]                 }
[17:44:49.670]                 NAMES <- toupper(added)
[17:44:49.670]                 for (kk in seq_along(NAMES)) {
[17:44:49.670]                   name <- added[[kk]]
[17:44:49.670]                   NAME <- NAMES[[kk]]
[17:44:49.670]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.670]                     next
[17:44:49.670]                   args[[name]] <- ""
[17:44:49.670]                 }
[17:44:49.670]                 NAMES <- toupper(removed)
[17:44:49.670]                 for (kk in seq_along(NAMES)) {
[17:44:49.670]                   name <- removed[[kk]]
[17:44:49.670]                   NAME <- NAMES[[kk]]
[17:44:49.670]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.670]                     next
[17:44:49.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.670]                 }
[17:44:49.670]                 if (length(args) > 0) 
[17:44:49.670]                   base::do.call(base::Sys.setenv, args = args)
[17:44:49.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:49.670]             }
[17:44:49.670]             else {
[17:44:49.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:49.670]             }
[17:44:49.670]             {
[17:44:49.670]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:49.670]                   0L) {
[17:44:49.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:49.670]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:49.670]                   base::options(opts)
[17:44:49.670]                 }
[17:44:49.670]                 {
[17:44:49.670]                   {
[17:44:49.670]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:49.670]                     NULL
[17:44:49.670]                   }
[17:44:49.670]                   options(future.plan = NULL)
[17:44:49.670]                   if (is.na(NA_character_)) 
[17:44:49.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:49.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:49.670]                     .init = FALSE)
[17:44:49.670]                 }
[17:44:49.670]             }
[17:44:49.670]         }
[17:44:49.670]     })
[17:44:49.670]     if (TRUE) {
[17:44:49.670]         base::sink(type = "output", split = FALSE)
[17:44:49.670]         if (TRUE) {
[17:44:49.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:49.670]         }
[17:44:49.670]         else {
[17:44:49.670]             ...future.result["stdout"] <- base::list(NULL)
[17:44:49.670]         }
[17:44:49.670]         base::close(...future.stdout)
[17:44:49.670]         ...future.stdout <- NULL
[17:44:49.670]     }
[17:44:49.670]     ...future.result$conditions <- ...future.conditions
[17:44:49.670]     ...future.result$finished <- base::Sys.time()
[17:44:49.670]     ...future.result
[17:44:49.670] }
[17:44:49.673] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:44:49.673] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:49.674] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:49.674] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:49.675] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.675] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:44:49.675] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:44:49.675] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:49.676] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:49.676] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.676] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:44:49.677] MultisessionFuture started
[17:44:49.677] - Launch lazy future ... done
[17:44:49.677] run() for ‘MultisessionFuture’ ... done
[17:44:49.678] Created future:
[17:44:49.678] MultisessionFuture:
[17:44:49.678] Label: ‘future_mapply-1’
[17:44:49.678] Expression:
[17:44:49.678] {
[17:44:49.678]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.678]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:49.678]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.678]         on.exit(options(oopts), add = TRUE)
[17:44:49.678]     }
[17:44:49.678]     {
[17:44:49.678]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.678]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:49.678]         do.call(mapply, args = args)
[17:44:49.678]     }
[17:44:49.678] }
[17:44:49.678] Lazy evaluation: FALSE
[17:44:49.678] Asynchronous evaluation: TRUE
[17:44:49.678] Local evaluation: TRUE
[17:44:49.678] Environment: R_GlobalEnv
[17:44:49.678] Capture standard output: TRUE
[17:44:49.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:49.678] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:49.678] Packages: <none>
[17:44:49.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:49.678] Resolved: FALSE
[17:44:49.678] Value: <not collected>
[17:44:49.678] Conditions captured: <none>
[17:44:49.678] Early signaling: FALSE
[17:44:49.678] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:49.678] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.690] Chunk #1 of 2 ... DONE
[17:44:49.690] Chunk #2 of 2 ...
[17:44:49.690]  - Finding globals in '...' for chunk #2 ...
[17:44:49.690] getGlobalsAndPackages() ...
[17:44:49.690] Searching for globals...
[17:44:49.690] 
[17:44:49.691] Searching for globals ... DONE
[17:44:49.691] - globals: [0] <none>
[17:44:49.691] getGlobalsAndPackages() ... DONE
[17:44:49.691]    + additional globals found: [n=0] 
[17:44:49.691]    + additional namespaces needed: [n=0] 
[17:44:49.691]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:49.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:49.691]  - seeds: <none>
[17:44:49.692]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.692] getGlobalsAndPackages() ...
[17:44:49.692] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.692] Resolving globals: FALSE
[17:44:49.693] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:49.693] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:49.693] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.693] 
[17:44:49.693] getGlobalsAndPackages() ... DONE
[17:44:49.694] run() for ‘Future’ ...
[17:44:49.694] - state: ‘created’
[17:44:49.694] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:49.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:49.708]   - Field: ‘node’
[17:44:49.709]   - Field: ‘label’
[17:44:49.709]   - Field: ‘local’
[17:44:49.709]   - Field: ‘owner’
[17:44:49.709]   - Field: ‘envir’
[17:44:49.709]   - Field: ‘workers’
[17:44:49.709]   - Field: ‘packages’
[17:44:49.709]   - Field: ‘gc’
[17:44:49.709]   - Field: ‘conditions’
[17:44:49.709]   - Field: ‘persistent’
[17:44:49.709]   - Field: ‘expr’
[17:44:49.710]   - Field: ‘uuid’
[17:44:49.710]   - Field: ‘seed’
[17:44:49.710]   - Field: ‘version’
[17:44:49.710]   - Field: ‘result’
[17:44:49.710]   - Field: ‘asynchronous’
[17:44:49.710]   - Field: ‘calls’
[17:44:49.710]   - Field: ‘globals’
[17:44:49.710]   - Field: ‘stdout’
[17:44:49.711]   - Field: ‘earlySignal’
[17:44:49.711]   - Field: ‘lazy’
[17:44:49.711]   - Field: ‘state’
[17:44:49.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:49.711] - Launch lazy future ...
[17:44:49.711] Packages needed by the future expression (n = 0): <none>
[17:44:49.711] Packages needed by future strategies (n = 0): <none>
[17:44:49.712] {
[17:44:49.712]     {
[17:44:49.712]         {
[17:44:49.712]             ...future.startTime <- base::Sys.time()
[17:44:49.712]             {
[17:44:49.712]                 {
[17:44:49.712]                   {
[17:44:49.712]                     {
[17:44:49.712]                       base::local({
[17:44:49.712]                         has_future <- base::requireNamespace("future", 
[17:44:49.712]                           quietly = TRUE)
[17:44:49.712]                         if (has_future) {
[17:44:49.712]                           ns <- base::getNamespace("future")
[17:44:49.712]                           version <- ns[[".package"]][["version"]]
[17:44:49.712]                           if (is.null(version)) 
[17:44:49.712]                             version <- utils::packageVersion("future")
[17:44:49.712]                         }
[17:44:49.712]                         else {
[17:44:49.712]                           version <- NULL
[17:44:49.712]                         }
[17:44:49.712]                         if (!has_future || version < "1.8.0") {
[17:44:49.712]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:49.712]                             "", base::R.version$version.string), 
[17:44:49.712]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:49.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:49.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:49.712]                               "release", "version")], collapse = " "), 
[17:44:49.712]                             hostname = base::Sys.info()[["nodename"]])
[17:44:49.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:49.712]                             info)
[17:44:49.712]                           info <- base::paste(info, collapse = "; ")
[17:44:49.712]                           if (!has_future) {
[17:44:49.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:49.712]                               info)
[17:44:49.712]                           }
[17:44:49.712]                           else {
[17:44:49.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:49.712]                               info, version)
[17:44:49.712]                           }
[17:44:49.712]                           base::stop(msg)
[17:44:49.712]                         }
[17:44:49.712]                       })
[17:44:49.712]                     }
[17:44:49.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:49.712]                     base::options(mc.cores = 1L)
[17:44:49.712]                   }
[17:44:49.712]                   ...future.strategy.old <- future::plan("list")
[17:44:49.712]                   options(future.plan = NULL)
[17:44:49.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:49.712]                 }
[17:44:49.712]                 ...future.workdir <- getwd()
[17:44:49.712]             }
[17:44:49.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:49.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:49.712]         }
[17:44:49.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:49.712]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:49.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:49.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:49.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:49.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:49.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:49.712]             base::names(...future.oldOptions))
[17:44:49.712]     }
[17:44:49.712]     if (FALSE) {
[17:44:49.712]     }
[17:44:49.712]     else {
[17:44:49.712]         if (TRUE) {
[17:44:49.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:49.712]                 open = "w")
[17:44:49.712]         }
[17:44:49.712]         else {
[17:44:49.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:49.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:49.712]         }
[17:44:49.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:49.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:49.712]             base::sink(type = "output", split = FALSE)
[17:44:49.712]             base::close(...future.stdout)
[17:44:49.712]         }, add = TRUE)
[17:44:49.712]     }
[17:44:49.712]     ...future.frame <- base::sys.nframe()
[17:44:49.712]     ...future.conditions <- base::list()
[17:44:49.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:49.712]     if (FALSE) {
[17:44:49.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:49.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:49.712]     }
[17:44:49.712]     ...future.result <- base::tryCatch({
[17:44:49.712]         base::withCallingHandlers({
[17:44:49.712]             ...future.value <- base::withVisible(base::local({
[17:44:49.712]                 ...future.makeSendCondition <- base::local({
[17:44:49.712]                   sendCondition <- NULL
[17:44:49.712]                   function(frame = 1L) {
[17:44:49.712]                     if (is.function(sendCondition)) 
[17:44:49.712]                       return(sendCondition)
[17:44:49.712]                     ns <- getNamespace("parallel")
[17:44:49.712]                     if (exists("sendData", mode = "function", 
[17:44:49.712]                       envir = ns)) {
[17:44:49.712]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:49.712]                         envir = ns)
[17:44:49.712]                       envir <- sys.frame(frame)
[17:44:49.712]                       master <- NULL
[17:44:49.712]                       while (!identical(envir, .GlobalEnv) && 
[17:44:49.712]                         !identical(envir, emptyenv())) {
[17:44:49.712]                         if (exists("master", mode = "list", envir = envir, 
[17:44:49.712]                           inherits = FALSE)) {
[17:44:49.712]                           master <- get("master", mode = "list", 
[17:44:49.712]                             envir = envir, inherits = FALSE)
[17:44:49.712]                           if (inherits(master, c("SOCKnode", 
[17:44:49.712]                             "SOCK0node"))) {
[17:44:49.712]                             sendCondition <<- function(cond) {
[17:44:49.712]                               data <- list(type = "VALUE", value = cond, 
[17:44:49.712]                                 success = TRUE)
[17:44:49.712]                               parallel_sendData(master, data)
[17:44:49.712]                             }
[17:44:49.712]                             return(sendCondition)
[17:44:49.712]                           }
[17:44:49.712]                         }
[17:44:49.712]                         frame <- frame + 1L
[17:44:49.712]                         envir <- sys.frame(frame)
[17:44:49.712]                       }
[17:44:49.712]                     }
[17:44:49.712]                     sendCondition <<- function(cond) NULL
[17:44:49.712]                   }
[17:44:49.712]                 })
[17:44:49.712]                 withCallingHandlers({
[17:44:49.712]                   {
[17:44:49.712]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.712]                     if (!identical(...future.globals.maxSize.org, 
[17:44:49.712]                       ...future.globals.maxSize)) {
[17:44:49.712]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.712]                       on.exit(options(oopts), add = TRUE)
[17:44:49.712]                     }
[17:44:49.712]                     {
[17:44:49.712]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.712]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:49.712]                         USE.NAMES = FALSE)
[17:44:49.712]                       do.call(mapply, args = args)
[17:44:49.712]                     }
[17:44:49.712]                   }
[17:44:49.712]                 }, immediateCondition = function(cond) {
[17:44:49.712]                   sendCondition <- ...future.makeSendCondition()
[17:44:49.712]                   sendCondition(cond)
[17:44:49.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.712]                   {
[17:44:49.712]                     inherits <- base::inherits
[17:44:49.712]                     invokeRestart <- base::invokeRestart
[17:44:49.712]                     is.null <- base::is.null
[17:44:49.712]                     muffled <- FALSE
[17:44:49.712]                     if (inherits(cond, "message")) {
[17:44:49.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:49.712]                       if (muffled) 
[17:44:49.712]                         invokeRestart("muffleMessage")
[17:44:49.712]                     }
[17:44:49.712]                     else if (inherits(cond, "warning")) {
[17:44:49.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:49.712]                       if (muffled) 
[17:44:49.712]                         invokeRestart("muffleWarning")
[17:44:49.712]                     }
[17:44:49.712]                     else if (inherits(cond, "condition")) {
[17:44:49.712]                       if (!is.null(pattern)) {
[17:44:49.712]                         computeRestarts <- base::computeRestarts
[17:44:49.712]                         grepl <- base::grepl
[17:44:49.712]                         restarts <- computeRestarts(cond)
[17:44:49.712]                         for (restart in restarts) {
[17:44:49.712]                           name <- restart$name
[17:44:49.712]                           if (is.null(name)) 
[17:44:49.712]                             next
[17:44:49.712]                           if (!grepl(pattern, name)) 
[17:44:49.712]                             next
[17:44:49.712]                           invokeRestart(restart)
[17:44:49.712]                           muffled <- TRUE
[17:44:49.712]                           break
[17:44:49.712]                         }
[17:44:49.712]                       }
[17:44:49.712]                     }
[17:44:49.712]                     invisible(muffled)
[17:44:49.712]                   }
[17:44:49.712]                   muffleCondition(cond)
[17:44:49.712]                 })
[17:44:49.712]             }))
[17:44:49.712]             future::FutureResult(value = ...future.value$value, 
[17:44:49.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.712]                   ...future.rng), globalenv = if (FALSE) 
[17:44:49.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:49.712]                     ...future.globalenv.names))
[17:44:49.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:49.712]         }, condition = base::local({
[17:44:49.712]             c <- base::c
[17:44:49.712]             inherits <- base::inherits
[17:44:49.712]             invokeRestart <- base::invokeRestart
[17:44:49.712]             length <- base::length
[17:44:49.712]             list <- base::list
[17:44:49.712]             seq.int <- base::seq.int
[17:44:49.712]             signalCondition <- base::signalCondition
[17:44:49.712]             sys.calls <- base::sys.calls
[17:44:49.712]             `[[` <- base::`[[`
[17:44:49.712]             `+` <- base::`+`
[17:44:49.712]             `<<-` <- base::`<<-`
[17:44:49.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:49.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:49.712]                   3L)]
[17:44:49.712]             }
[17:44:49.712]             function(cond) {
[17:44:49.712]                 is_error <- inherits(cond, "error")
[17:44:49.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:49.712]                   NULL)
[17:44:49.712]                 if (is_error) {
[17:44:49.712]                   sessionInformation <- function() {
[17:44:49.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:49.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:49.712]                       search = base::search(), system = base::Sys.info())
[17:44:49.712]                   }
[17:44:49.712]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:49.712]                     cond$call), session = sessionInformation(), 
[17:44:49.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:49.712]                   signalCondition(cond)
[17:44:49.712]                 }
[17:44:49.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:49.712]                 "immediateCondition"))) {
[17:44:49.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:49.712]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:49.712]                   if (TRUE && !signal) {
[17:44:49.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.712]                     {
[17:44:49.712]                       inherits <- base::inherits
[17:44:49.712]                       invokeRestart <- base::invokeRestart
[17:44:49.712]                       is.null <- base::is.null
[17:44:49.712]                       muffled <- FALSE
[17:44:49.712]                       if (inherits(cond, "message")) {
[17:44:49.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.712]                         if (muffled) 
[17:44:49.712]                           invokeRestart("muffleMessage")
[17:44:49.712]                       }
[17:44:49.712]                       else if (inherits(cond, "warning")) {
[17:44:49.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.712]                         if (muffled) 
[17:44:49.712]                           invokeRestart("muffleWarning")
[17:44:49.712]                       }
[17:44:49.712]                       else if (inherits(cond, "condition")) {
[17:44:49.712]                         if (!is.null(pattern)) {
[17:44:49.712]                           computeRestarts <- base::computeRestarts
[17:44:49.712]                           grepl <- base::grepl
[17:44:49.712]                           restarts <- computeRestarts(cond)
[17:44:49.712]                           for (restart in restarts) {
[17:44:49.712]                             name <- restart$name
[17:44:49.712]                             if (is.null(name)) 
[17:44:49.712]                               next
[17:44:49.712]                             if (!grepl(pattern, name)) 
[17:44:49.712]                               next
[17:44:49.712]                             invokeRestart(restart)
[17:44:49.712]                             muffled <- TRUE
[17:44:49.712]                             break
[17:44:49.712]                           }
[17:44:49.712]                         }
[17:44:49.712]                       }
[17:44:49.712]                       invisible(muffled)
[17:44:49.712]                     }
[17:44:49.712]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.712]                   }
[17:44:49.712]                 }
[17:44:49.712]                 else {
[17:44:49.712]                   if (TRUE) {
[17:44:49.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.712]                     {
[17:44:49.712]                       inherits <- base::inherits
[17:44:49.712]                       invokeRestart <- base::invokeRestart
[17:44:49.712]                       is.null <- base::is.null
[17:44:49.712]                       muffled <- FALSE
[17:44:49.712]                       if (inherits(cond, "message")) {
[17:44:49.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.712]                         if (muffled) 
[17:44:49.712]                           invokeRestart("muffleMessage")
[17:44:49.712]                       }
[17:44:49.712]                       else if (inherits(cond, "warning")) {
[17:44:49.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.712]                         if (muffled) 
[17:44:49.712]                           invokeRestart("muffleWarning")
[17:44:49.712]                       }
[17:44:49.712]                       else if (inherits(cond, "condition")) {
[17:44:49.712]                         if (!is.null(pattern)) {
[17:44:49.712]                           computeRestarts <- base::computeRestarts
[17:44:49.712]                           grepl <- base::grepl
[17:44:49.712]                           restarts <- computeRestarts(cond)
[17:44:49.712]                           for (restart in restarts) {
[17:44:49.712]                             name <- restart$name
[17:44:49.712]                             if (is.null(name)) 
[17:44:49.712]                               next
[17:44:49.712]                             if (!grepl(pattern, name)) 
[17:44:49.712]                               next
[17:44:49.712]                             invokeRestart(restart)
[17:44:49.712]                             muffled <- TRUE
[17:44:49.712]                             break
[17:44:49.712]                           }
[17:44:49.712]                         }
[17:44:49.712]                       }
[17:44:49.712]                       invisible(muffled)
[17:44:49.712]                     }
[17:44:49.712]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.712]                   }
[17:44:49.712]                 }
[17:44:49.712]             }
[17:44:49.712]         }))
[17:44:49.712]     }, error = function(ex) {
[17:44:49.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:49.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.712]                 ...future.rng), started = ...future.startTime, 
[17:44:49.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:49.712]             version = "1.8"), class = "FutureResult")
[17:44:49.712]     }, finally = {
[17:44:49.712]         if (!identical(...future.workdir, getwd())) 
[17:44:49.712]             setwd(...future.workdir)
[17:44:49.712]         {
[17:44:49.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:49.712]                 ...future.oldOptions$nwarnings <- NULL
[17:44:49.712]             }
[17:44:49.712]             base::options(...future.oldOptions)
[17:44:49.712]             if (.Platform$OS.type == "windows") {
[17:44:49.712]                 old_names <- names(...future.oldEnvVars)
[17:44:49.712]                 envs <- base::Sys.getenv()
[17:44:49.712]                 names <- names(envs)
[17:44:49.712]                 common <- intersect(names, old_names)
[17:44:49.712]                 added <- setdiff(names, old_names)
[17:44:49.712]                 removed <- setdiff(old_names, names)
[17:44:49.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:49.712]                   envs[common]]
[17:44:49.712]                 NAMES <- toupper(changed)
[17:44:49.712]                 args <- list()
[17:44:49.712]                 for (kk in seq_along(NAMES)) {
[17:44:49.712]                   name <- changed[[kk]]
[17:44:49.712]                   NAME <- NAMES[[kk]]
[17:44:49.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.712]                     next
[17:44:49.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.712]                 }
[17:44:49.712]                 NAMES <- toupper(added)
[17:44:49.712]                 for (kk in seq_along(NAMES)) {
[17:44:49.712]                   name <- added[[kk]]
[17:44:49.712]                   NAME <- NAMES[[kk]]
[17:44:49.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.712]                     next
[17:44:49.712]                   args[[name]] <- ""
[17:44:49.712]                 }
[17:44:49.712]                 NAMES <- toupper(removed)
[17:44:49.712]                 for (kk in seq_along(NAMES)) {
[17:44:49.712]                   name <- removed[[kk]]
[17:44:49.712]                   NAME <- NAMES[[kk]]
[17:44:49.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.712]                     next
[17:44:49.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.712]                 }
[17:44:49.712]                 if (length(args) > 0) 
[17:44:49.712]                   base::do.call(base::Sys.setenv, args = args)
[17:44:49.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:49.712]             }
[17:44:49.712]             else {
[17:44:49.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:49.712]             }
[17:44:49.712]             {
[17:44:49.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:49.712]                   0L) {
[17:44:49.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:49.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:49.712]                   base::options(opts)
[17:44:49.712]                 }
[17:44:49.712]                 {
[17:44:49.712]                   {
[17:44:49.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:49.712]                     NULL
[17:44:49.712]                   }
[17:44:49.712]                   options(future.plan = NULL)
[17:44:49.712]                   if (is.na(NA_character_)) 
[17:44:49.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:49.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:49.712]                     .init = FALSE)
[17:44:49.712]                 }
[17:44:49.712]             }
[17:44:49.712]         }
[17:44:49.712]     })
[17:44:49.712]     if (TRUE) {
[17:44:49.712]         base::sink(type = "output", split = FALSE)
[17:44:49.712]         if (TRUE) {
[17:44:49.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:49.712]         }
[17:44:49.712]         else {
[17:44:49.712]             ...future.result["stdout"] <- base::list(NULL)
[17:44:49.712]         }
[17:44:49.712]         base::close(...future.stdout)
[17:44:49.712]         ...future.stdout <- NULL
[17:44:49.712]     }
[17:44:49.712]     ...future.result$conditions <- ...future.conditions
[17:44:49.712]     ...future.result$finished <- base::Sys.time()
[17:44:49.712]     ...future.result
[17:44:49.712] }
[17:44:49.763] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:44:49.764] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:49.764] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:49.764] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:49.765] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.765] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:49.766] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:49.766] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:49.766] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.766] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:49.767] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.767] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:44:49.768] MultisessionFuture started
[17:44:49.768] - Launch lazy future ... done
[17:44:49.768] run() for ‘MultisessionFuture’ ... done
[17:44:49.768] Created future:
[17:44:49.768] MultisessionFuture:
[17:44:49.768] Label: ‘future_mapply-2’
[17:44:49.768] Expression:
[17:44:49.768] {
[17:44:49.768]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.768]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:49.768]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.768]         on.exit(options(oopts), add = TRUE)
[17:44:49.768]     }
[17:44:49.768]     {
[17:44:49.768]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.768]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:49.768]         do.call(mapply, args = args)
[17:44:49.768]     }
[17:44:49.768] }
[17:44:49.768] Lazy evaluation: FALSE
[17:44:49.768] Asynchronous evaluation: TRUE
[17:44:49.768] Local evaluation: TRUE
[17:44:49.768] Environment: R_GlobalEnv
[17:44:49.768] Capture standard output: TRUE
[17:44:49.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:49.768] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:49.768] Packages: <none>
[17:44:49.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:49.768] Resolved: FALSE
[17:44:49.768] Value: <not collected>
[17:44:49.768] Conditions captured: <none>
[17:44:49.768] Early signaling: FALSE
[17:44:49.768] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:49.768] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.780] Chunk #2 of 2 ... DONE
[17:44:49.780] Launching 2 futures (chunks) ... DONE
[17:44:49.780] Resolving 2 futures (chunks) ...
[17:44:49.780] resolve() on list ...
[17:44:49.780]  recursive: 0
[17:44:49.781]  length: 2
[17:44:49.781] 
[17:44:49.781] receiveMessageFromWorker() for ClusterFuture ...
[17:44:49.781] - Validating connection of MultisessionFuture
[17:44:49.782] - received message: FutureResult
[17:44:49.782] - Received FutureResult
[17:44:49.782] - Erased future from FutureRegistry
[17:44:49.782] result() for ClusterFuture ...
[17:44:49.782] - result already collected: FutureResult
[17:44:49.782] result() for ClusterFuture ... done
[17:44:49.782] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:49.782] Future #1
[17:44:49.783] result() for ClusterFuture ...
[17:44:49.783] - result already collected: FutureResult
[17:44:49.783] result() for ClusterFuture ... done
[17:44:49.783] result() for ClusterFuture ...
[17:44:49.783] - result already collected: FutureResult
[17:44:49.783] result() for ClusterFuture ... done
[17:44:49.783] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:49.783] - nx: 2
[17:44:49.784] - relay: TRUE
[17:44:49.784] - stdout: TRUE
[17:44:49.784] - signal: TRUE
[17:44:49.784] - resignal: FALSE
[17:44:49.784] - force: TRUE
[17:44:49.784] - relayed: [n=2] FALSE, FALSE
[17:44:49.784] - queued futures: [n=2] FALSE, FALSE
[17:44:49.784]  - until=1
[17:44:49.784]  - relaying element #1
[17:44:49.784] result() for ClusterFuture ...
[17:44:49.785] - result already collected: FutureResult
[17:44:49.785] result() for ClusterFuture ... done
[17:44:49.785] result() for ClusterFuture ...
[17:44:49.785] - result already collected: FutureResult
[17:44:49.785] result() for ClusterFuture ... done
[17:44:49.785] result() for ClusterFuture ...
[17:44:49.785] - result already collected: FutureResult
[17:44:49.785] result() for ClusterFuture ... done
[17:44:49.786] result() for ClusterFuture ...
[17:44:49.786] - result already collected: FutureResult
[17:44:49.786] result() for ClusterFuture ... done
[17:44:49.786] - relayed: [n=2] TRUE, FALSE
[17:44:49.786] - queued futures: [n=2] TRUE, FALSE
[17:44:49.786] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:49.786]  length: 1 (resolved future 1)
[17:44:49.849] receiveMessageFromWorker() for ClusterFuture ...
[17:44:49.849] - Validating connection of MultisessionFuture
[17:44:49.849] - received message: FutureResult
[17:44:49.849] - Received FutureResult
[17:44:49.850] - Erased future from FutureRegistry
[17:44:49.850] result() for ClusterFuture ...
[17:44:49.850] - result already collected: FutureResult
[17:44:49.850] result() for ClusterFuture ... done
[17:44:49.850] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:49.850] Future #2
[17:44:49.850] result() for ClusterFuture ...
[17:44:49.850] - result already collected: FutureResult
[17:44:49.850] result() for ClusterFuture ... done
[17:44:49.851] result() for ClusterFuture ...
[17:44:49.851] - result already collected: FutureResult
[17:44:49.851] result() for ClusterFuture ... done
[17:44:49.851] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:49.851] - nx: 2
[17:44:49.851] - relay: TRUE
[17:44:49.851] - stdout: TRUE
[17:44:49.851] - signal: TRUE
[17:44:49.852] - resignal: FALSE
[17:44:49.852] - force: TRUE
[17:44:49.852] - relayed: [n=2] TRUE, FALSE
[17:44:49.852] - queued futures: [n=2] TRUE, FALSE
[17:44:49.854]  - until=2
[17:44:49.854]  - relaying element #2
[17:44:49.854] result() for ClusterFuture ...
[17:44:49.854] - result already collected: FutureResult
[17:44:49.854] result() for ClusterFuture ... done
[17:44:49.855] result() for ClusterFuture ...
[17:44:49.855] - result already collected: FutureResult
[17:44:49.855] result() for ClusterFuture ... done
[17:44:49.855] result() for ClusterFuture ...
[17:44:49.855] - result already collected: FutureResult
[17:44:49.855] result() for ClusterFuture ... done
[17:44:49.855] result() for ClusterFuture ...
[17:44:49.855] - result already collected: FutureResult
[17:44:49.855] result() for ClusterFuture ... done
[17:44:49.855] - relayed: [n=2] TRUE, TRUE
[17:44:49.855] - queued futures: [n=2] TRUE, TRUE
[17:44:49.856] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:49.856]  length: 0 (resolved future 2)
[17:44:49.856] Relaying remaining futures
[17:44:49.856] signalConditionsASAP(NULL, pos=0) ...
[17:44:49.856] - nx: 2
[17:44:49.856] - relay: TRUE
[17:44:49.856] - stdout: TRUE
[17:44:49.856] - signal: TRUE
[17:44:49.856] - resignal: FALSE
[17:44:49.856] - force: TRUE
[17:44:49.856] - relayed: [n=2] TRUE, TRUE
[17:44:49.856] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:49.857] - relayed: [n=2] TRUE, TRUE
[17:44:49.857] - queued futures: [n=2] TRUE, TRUE
[17:44:49.857] signalConditionsASAP(NULL, pos=0) ... done
[17:44:49.857] resolve() on list ... DONE
[17:44:49.857] result() for ClusterFuture ...
[17:44:49.857] - result already collected: FutureResult
[17:44:49.857] result() for ClusterFuture ... done
[17:44:49.857] result() for ClusterFuture ...
[17:44:49.857] - result already collected: FutureResult
[17:44:49.857] result() for ClusterFuture ... done
[17:44:49.857] result() for ClusterFuture ...
[17:44:49.858] - result already collected: FutureResult
[17:44:49.858] result() for ClusterFuture ... done
[17:44:49.858] result() for ClusterFuture ...
[17:44:49.858] - result already collected: FutureResult
[17:44:49.858] result() for ClusterFuture ... done
[17:44:49.858]  - Number of value chunks collected: 2
[17:44:49.858] Resolving 2 futures (chunks) ... DONE
[17:44:49.858] Reducing values from 2 chunks ...
[17:44:49.858]  - Number of values collected after concatenation: 4
[17:44:49.858]  - Number of values expected: 4
[17:44:49.858] Reducing values from 2 chunks ... DONE
[17:44:49.859] future_mapply() ... DONE
[17:44:49.859] future_mapply() ...
[17:44:49.863] Number of chunks: 2
[17:44:49.863] getGlobalsAndPackagesXApply() ...
[17:44:49.863]  - future.globals: TRUE
[17:44:49.863] getGlobalsAndPackages() ...
[17:44:49.863] Searching for globals...
[17:44:49.864] - globals found: [1] ‘FUN’
[17:44:49.864] Searching for globals ... DONE
[17:44:49.864] Resolving globals: FALSE
[17:44:49.865] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:49.865] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:49.865] - globals: [1] ‘FUN’
[17:44:49.865] 
[17:44:49.865] getGlobalsAndPackages() ... DONE
[17:44:49.865]  - globals found/used: [n=1] ‘FUN’
[17:44:49.866]  - needed namespaces: [n=0] 
[17:44:49.866] Finding globals ... DONE
[17:44:49.866] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:49.866] List of 2
[17:44:49.866]  $ ...future.FUN:function (x, ...)  
[17:44:49.866]  $ MoreArgs     : NULL
[17:44:49.866]  - attr(*, "where")=List of 2
[17:44:49.866]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:49.866]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:49.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:49.866]  - attr(*, "resolved")= logi FALSE
[17:44:49.866]  - attr(*, "total_size")= num NA
[17:44:49.868] Packages to be attached in all futures: [n=0] 
[17:44:49.869] getGlobalsAndPackagesXApply() ... DONE
[17:44:49.869] Number of futures (= number of chunks): 2
[17:44:49.869] Launching 2 futures (chunks) ...
[17:44:49.869] Chunk #1 of 2 ...
[17:44:49.869]  - Finding globals in '...' for chunk #1 ...
[17:44:49.869] getGlobalsAndPackages() ...
[17:44:49.869] Searching for globals...
[17:44:49.870] 
[17:44:49.870] Searching for globals ... DONE
[17:44:49.870] - globals: [0] <none>
[17:44:49.870] getGlobalsAndPackages() ... DONE
[17:44:49.870]    + additional globals found: [n=0] 
[17:44:49.870]    + additional namespaces needed: [n=0] 
[17:44:49.870]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:49.870]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:49.870]  - seeds: <none>
[17:44:49.871]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.871] getGlobalsAndPackages() ...
[17:44:49.871] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.871] Resolving globals: FALSE
[17:44:49.871] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:49.872] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:49.872] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.872] 
[17:44:49.872] getGlobalsAndPackages() ... DONE
[17:44:49.872] run() for ‘Future’ ...
[17:44:49.873] - state: ‘created’
[17:44:49.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:49.887] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:49.887]   - Field: ‘node’
[17:44:49.887]   - Field: ‘label’
[17:44:49.887]   - Field: ‘local’
[17:44:49.887]   - Field: ‘owner’
[17:44:49.887]   - Field: ‘envir’
[17:44:49.888]   - Field: ‘workers’
[17:44:49.888]   - Field: ‘packages’
[17:44:49.888]   - Field: ‘gc’
[17:44:49.888]   - Field: ‘conditions’
[17:44:49.888]   - Field: ‘persistent’
[17:44:49.888]   - Field: ‘expr’
[17:44:49.888]   - Field: ‘uuid’
[17:44:49.888]   - Field: ‘seed’
[17:44:49.888]   - Field: ‘version’
[17:44:49.888]   - Field: ‘result’
[17:44:49.888]   - Field: ‘asynchronous’
[17:44:49.889]   - Field: ‘calls’
[17:44:49.889]   - Field: ‘globals’
[17:44:49.889]   - Field: ‘stdout’
[17:44:49.889]   - Field: ‘earlySignal’
[17:44:49.889]   - Field: ‘lazy’
[17:44:49.889]   - Field: ‘state’
[17:44:49.889] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:49.889] - Launch lazy future ...
[17:44:49.889] Packages needed by the future expression (n = 0): <none>
[17:44:49.890] Packages needed by future strategies (n = 0): <none>
[17:44:49.890] {
[17:44:49.890]     {
[17:44:49.890]         {
[17:44:49.890]             ...future.startTime <- base::Sys.time()
[17:44:49.890]             {
[17:44:49.890]                 {
[17:44:49.890]                   {
[17:44:49.890]                     {
[17:44:49.890]                       base::local({
[17:44:49.890]                         has_future <- base::requireNamespace("future", 
[17:44:49.890]                           quietly = TRUE)
[17:44:49.890]                         if (has_future) {
[17:44:49.890]                           ns <- base::getNamespace("future")
[17:44:49.890]                           version <- ns[[".package"]][["version"]]
[17:44:49.890]                           if (is.null(version)) 
[17:44:49.890]                             version <- utils::packageVersion("future")
[17:44:49.890]                         }
[17:44:49.890]                         else {
[17:44:49.890]                           version <- NULL
[17:44:49.890]                         }
[17:44:49.890]                         if (!has_future || version < "1.8.0") {
[17:44:49.890]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:49.890]                             "", base::R.version$version.string), 
[17:44:49.890]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:49.890]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:49.890]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:49.890]                               "release", "version")], collapse = " "), 
[17:44:49.890]                             hostname = base::Sys.info()[["nodename"]])
[17:44:49.890]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:49.890]                             info)
[17:44:49.890]                           info <- base::paste(info, collapse = "; ")
[17:44:49.890]                           if (!has_future) {
[17:44:49.890]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:49.890]                               info)
[17:44:49.890]                           }
[17:44:49.890]                           else {
[17:44:49.890]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:49.890]                               info, version)
[17:44:49.890]                           }
[17:44:49.890]                           base::stop(msg)
[17:44:49.890]                         }
[17:44:49.890]                       })
[17:44:49.890]                     }
[17:44:49.890]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:49.890]                     base::options(mc.cores = 1L)
[17:44:49.890]                   }
[17:44:49.890]                   ...future.strategy.old <- future::plan("list")
[17:44:49.890]                   options(future.plan = NULL)
[17:44:49.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:49.890]                 }
[17:44:49.890]                 ...future.workdir <- getwd()
[17:44:49.890]             }
[17:44:49.890]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:49.890]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:49.890]         }
[17:44:49.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:49.890]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:49.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:49.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:49.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:49.890]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:49.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:49.890]             base::names(...future.oldOptions))
[17:44:49.890]     }
[17:44:49.890]     if (FALSE) {
[17:44:49.890]     }
[17:44:49.890]     else {
[17:44:49.890]         if (TRUE) {
[17:44:49.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:49.890]                 open = "w")
[17:44:49.890]         }
[17:44:49.890]         else {
[17:44:49.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:49.890]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:49.890]         }
[17:44:49.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:49.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:49.890]             base::sink(type = "output", split = FALSE)
[17:44:49.890]             base::close(...future.stdout)
[17:44:49.890]         }, add = TRUE)
[17:44:49.890]     }
[17:44:49.890]     ...future.frame <- base::sys.nframe()
[17:44:49.890]     ...future.conditions <- base::list()
[17:44:49.890]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:49.890]     if (FALSE) {
[17:44:49.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:49.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:49.890]     }
[17:44:49.890]     ...future.result <- base::tryCatch({
[17:44:49.890]         base::withCallingHandlers({
[17:44:49.890]             ...future.value <- base::withVisible(base::local({
[17:44:49.890]                 ...future.makeSendCondition <- base::local({
[17:44:49.890]                   sendCondition <- NULL
[17:44:49.890]                   function(frame = 1L) {
[17:44:49.890]                     if (is.function(sendCondition)) 
[17:44:49.890]                       return(sendCondition)
[17:44:49.890]                     ns <- getNamespace("parallel")
[17:44:49.890]                     if (exists("sendData", mode = "function", 
[17:44:49.890]                       envir = ns)) {
[17:44:49.890]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:49.890]                         envir = ns)
[17:44:49.890]                       envir <- sys.frame(frame)
[17:44:49.890]                       master <- NULL
[17:44:49.890]                       while (!identical(envir, .GlobalEnv) && 
[17:44:49.890]                         !identical(envir, emptyenv())) {
[17:44:49.890]                         if (exists("master", mode = "list", envir = envir, 
[17:44:49.890]                           inherits = FALSE)) {
[17:44:49.890]                           master <- get("master", mode = "list", 
[17:44:49.890]                             envir = envir, inherits = FALSE)
[17:44:49.890]                           if (inherits(master, c("SOCKnode", 
[17:44:49.890]                             "SOCK0node"))) {
[17:44:49.890]                             sendCondition <<- function(cond) {
[17:44:49.890]                               data <- list(type = "VALUE", value = cond, 
[17:44:49.890]                                 success = TRUE)
[17:44:49.890]                               parallel_sendData(master, data)
[17:44:49.890]                             }
[17:44:49.890]                             return(sendCondition)
[17:44:49.890]                           }
[17:44:49.890]                         }
[17:44:49.890]                         frame <- frame + 1L
[17:44:49.890]                         envir <- sys.frame(frame)
[17:44:49.890]                       }
[17:44:49.890]                     }
[17:44:49.890]                     sendCondition <<- function(cond) NULL
[17:44:49.890]                   }
[17:44:49.890]                 })
[17:44:49.890]                 withCallingHandlers({
[17:44:49.890]                   {
[17:44:49.890]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.890]                     if (!identical(...future.globals.maxSize.org, 
[17:44:49.890]                       ...future.globals.maxSize)) {
[17:44:49.890]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.890]                       on.exit(options(oopts), add = TRUE)
[17:44:49.890]                     }
[17:44:49.890]                     {
[17:44:49.890]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.890]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:49.890]                         USE.NAMES = FALSE)
[17:44:49.890]                       do.call(mapply, args = args)
[17:44:49.890]                     }
[17:44:49.890]                   }
[17:44:49.890]                 }, immediateCondition = function(cond) {
[17:44:49.890]                   sendCondition <- ...future.makeSendCondition()
[17:44:49.890]                   sendCondition(cond)
[17:44:49.890]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.890]                   {
[17:44:49.890]                     inherits <- base::inherits
[17:44:49.890]                     invokeRestart <- base::invokeRestart
[17:44:49.890]                     is.null <- base::is.null
[17:44:49.890]                     muffled <- FALSE
[17:44:49.890]                     if (inherits(cond, "message")) {
[17:44:49.890]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:49.890]                       if (muffled) 
[17:44:49.890]                         invokeRestart("muffleMessage")
[17:44:49.890]                     }
[17:44:49.890]                     else if (inherits(cond, "warning")) {
[17:44:49.890]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:49.890]                       if (muffled) 
[17:44:49.890]                         invokeRestart("muffleWarning")
[17:44:49.890]                     }
[17:44:49.890]                     else if (inherits(cond, "condition")) {
[17:44:49.890]                       if (!is.null(pattern)) {
[17:44:49.890]                         computeRestarts <- base::computeRestarts
[17:44:49.890]                         grepl <- base::grepl
[17:44:49.890]                         restarts <- computeRestarts(cond)
[17:44:49.890]                         for (restart in restarts) {
[17:44:49.890]                           name <- restart$name
[17:44:49.890]                           if (is.null(name)) 
[17:44:49.890]                             next
[17:44:49.890]                           if (!grepl(pattern, name)) 
[17:44:49.890]                             next
[17:44:49.890]                           invokeRestart(restart)
[17:44:49.890]                           muffled <- TRUE
[17:44:49.890]                           break
[17:44:49.890]                         }
[17:44:49.890]                       }
[17:44:49.890]                     }
[17:44:49.890]                     invisible(muffled)
[17:44:49.890]                   }
[17:44:49.890]                   muffleCondition(cond)
[17:44:49.890]                 })
[17:44:49.890]             }))
[17:44:49.890]             future::FutureResult(value = ...future.value$value, 
[17:44:49.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.890]                   ...future.rng), globalenv = if (FALSE) 
[17:44:49.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:49.890]                     ...future.globalenv.names))
[17:44:49.890]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:49.890]         }, condition = base::local({
[17:44:49.890]             c <- base::c
[17:44:49.890]             inherits <- base::inherits
[17:44:49.890]             invokeRestart <- base::invokeRestart
[17:44:49.890]             length <- base::length
[17:44:49.890]             list <- base::list
[17:44:49.890]             seq.int <- base::seq.int
[17:44:49.890]             signalCondition <- base::signalCondition
[17:44:49.890]             sys.calls <- base::sys.calls
[17:44:49.890]             `[[` <- base::`[[`
[17:44:49.890]             `+` <- base::`+`
[17:44:49.890]             `<<-` <- base::`<<-`
[17:44:49.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:49.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:49.890]                   3L)]
[17:44:49.890]             }
[17:44:49.890]             function(cond) {
[17:44:49.890]                 is_error <- inherits(cond, "error")
[17:44:49.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:49.890]                   NULL)
[17:44:49.890]                 if (is_error) {
[17:44:49.890]                   sessionInformation <- function() {
[17:44:49.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:49.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:49.890]                       search = base::search(), system = base::Sys.info())
[17:44:49.890]                   }
[17:44:49.890]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:49.890]                     cond$call), session = sessionInformation(), 
[17:44:49.890]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:49.890]                   signalCondition(cond)
[17:44:49.890]                 }
[17:44:49.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:49.890]                 "immediateCondition"))) {
[17:44:49.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:49.890]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:49.890]                   if (TRUE && !signal) {
[17:44:49.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.890]                     {
[17:44:49.890]                       inherits <- base::inherits
[17:44:49.890]                       invokeRestart <- base::invokeRestart
[17:44:49.890]                       is.null <- base::is.null
[17:44:49.890]                       muffled <- FALSE
[17:44:49.890]                       if (inherits(cond, "message")) {
[17:44:49.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.890]                         if (muffled) 
[17:44:49.890]                           invokeRestart("muffleMessage")
[17:44:49.890]                       }
[17:44:49.890]                       else if (inherits(cond, "warning")) {
[17:44:49.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.890]                         if (muffled) 
[17:44:49.890]                           invokeRestart("muffleWarning")
[17:44:49.890]                       }
[17:44:49.890]                       else if (inherits(cond, "condition")) {
[17:44:49.890]                         if (!is.null(pattern)) {
[17:44:49.890]                           computeRestarts <- base::computeRestarts
[17:44:49.890]                           grepl <- base::grepl
[17:44:49.890]                           restarts <- computeRestarts(cond)
[17:44:49.890]                           for (restart in restarts) {
[17:44:49.890]                             name <- restart$name
[17:44:49.890]                             if (is.null(name)) 
[17:44:49.890]                               next
[17:44:49.890]                             if (!grepl(pattern, name)) 
[17:44:49.890]                               next
[17:44:49.890]                             invokeRestart(restart)
[17:44:49.890]                             muffled <- TRUE
[17:44:49.890]                             break
[17:44:49.890]                           }
[17:44:49.890]                         }
[17:44:49.890]                       }
[17:44:49.890]                       invisible(muffled)
[17:44:49.890]                     }
[17:44:49.890]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.890]                   }
[17:44:49.890]                 }
[17:44:49.890]                 else {
[17:44:49.890]                   if (TRUE) {
[17:44:49.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.890]                     {
[17:44:49.890]                       inherits <- base::inherits
[17:44:49.890]                       invokeRestart <- base::invokeRestart
[17:44:49.890]                       is.null <- base::is.null
[17:44:49.890]                       muffled <- FALSE
[17:44:49.890]                       if (inherits(cond, "message")) {
[17:44:49.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.890]                         if (muffled) 
[17:44:49.890]                           invokeRestart("muffleMessage")
[17:44:49.890]                       }
[17:44:49.890]                       else if (inherits(cond, "warning")) {
[17:44:49.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.890]                         if (muffled) 
[17:44:49.890]                           invokeRestart("muffleWarning")
[17:44:49.890]                       }
[17:44:49.890]                       else if (inherits(cond, "condition")) {
[17:44:49.890]                         if (!is.null(pattern)) {
[17:44:49.890]                           computeRestarts <- base::computeRestarts
[17:44:49.890]                           grepl <- base::grepl
[17:44:49.890]                           restarts <- computeRestarts(cond)
[17:44:49.890]                           for (restart in restarts) {
[17:44:49.890]                             name <- restart$name
[17:44:49.890]                             if (is.null(name)) 
[17:44:49.890]                               next
[17:44:49.890]                             if (!grepl(pattern, name)) 
[17:44:49.890]                               next
[17:44:49.890]                             invokeRestart(restart)
[17:44:49.890]                             muffled <- TRUE
[17:44:49.890]                             break
[17:44:49.890]                           }
[17:44:49.890]                         }
[17:44:49.890]                       }
[17:44:49.890]                       invisible(muffled)
[17:44:49.890]                     }
[17:44:49.890]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.890]                   }
[17:44:49.890]                 }
[17:44:49.890]             }
[17:44:49.890]         }))
[17:44:49.890]     }, error = function(ex) {
[17:44:49.890]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:49.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.890]                 ...future.rng), started = ...future.startTime, 
[17:44:49.890]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:49.890]             version = "1.8"), class = "FutureResult")
[17:44:49.890]     }, finally = {
[17:44:49.890]         if (!identical(...future.workdir, getwd())) 
[17:44:49.890]             setwd(...future.workdir)
[17:44:49.890]         {
[17:44:49.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:49.890]                 ...future.oldOptions$nwarnings <- NULL
[17:44:49.890]             }
[17:44:49.890]             base::options(...future.oldOptions)
[17:44:49.890]             if (.Platform$OS.type == "windows") {
[17:44:49.890]                 old_names <- names(...future.oldEnvVars)
[17:44:49.890]                 envs <- base::Sys.getenv()
[17:44:49.890]                 names <- names(envs)
[17:44:49.890]                 common <- intersect(names, old_names)
[17:44:49.890]                 added <- setdiff(names, old_names)
[17:44:49.890]                 removed <- setdiff(old_names, names)
[17:44:49.890]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:49.890]                   envs[common]]
[17:44:49.890]                 NAMES <- toupper(changed)
[17:44:49.890]                 args <- list()
[17:44:49.890]                 for (kk in seq_along(NAMES)) {
[17:44:49.890]                   name <- changed[[kk]]
[17:44:49.890]                   NAME <- NAMES[[kk]]
[17:44:49.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.890]                     next
[17:44:49.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.890]                 }
[17:44:49.890]                 NAMES <- toupper(added)
[17:44:49.890]                 for (kk in seq_along(NAMES)) {
[17:44:49.890]                   name <- added[[kk]]
[17:44:49.890]                   NAME <- NAMES[[kk]]
[17:44:49.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.890]                     next
[17:44:49.890]                   args[[name]] <- ""
[17:44:49.890]                 }
[17:44:49.890]                 NAMES <- toupper(removed)
[17:44:49.890]                 for (kk in seq_along(NAMES)) {
[17:44:49.890]                   name <- removed[[kk]]
[17:44:49.890]                   NAME <- NAMES[[kk]]
[17:44:49.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.890]                     next
[17:44:49.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.890]                 }
[17:44:49.890]                 if (length(args) > 0) 
[17:44:49.890]                   base::do.call(base::Sys.setenv, args = args)
[17:44:49.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:49.890]             }
[17:44:49.890]             else {
[17:44:49.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:49.890]             }
[17:44:49.890]             {
[17:44:49.890]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:49.890]                   0L) {
[17:44:49.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:49.890]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:49.890]                   base::options(opts)
[17:44:49.890]                 }
[17:44:49.890]                 {
[17:44:49.890]                   {
[17:44:49.890]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:49.890]                     NULL
[17:44:49.890]                   }
[17:44:49.890]                   options(future.plan = NULL)
[17:44:49.890]                   if (is.na(NA_character_)) 
[17:44:49.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:49.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:49.890]                     .init = FALSE)
[17:44:49.890]                 }
[17:44:49.890]             }
[17:44:49.890]         }
[17:44:49.890]     })
[17:44:49.890]     if (TRUE) {
[17:44:49.890]         base::sink(type = "output", split = FALSE)
[17:44:49.890]         if (TRUE) {
[17:44:49.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:49.890]         }
[17:44:49.890]         else {
[17:44:49.890]             ...future.result["stdout"] <- base::list(NULL)
[17:44:49.890]         }
[17:44:49.890]         base::close(...future.stdout)
[17:44:49.890]         ...future.stdout <- NULL
[17:44:49.890]     }
[17:44:49.890]     ...future.result$conditions <- ...future.conditions
[17:44:49.890]     ...future.result$finished <- base::Sys.time()
[17:44:49.890]     ...future.result
[17:44:49.890] }
[17:44:49.893] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:44:49.893] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:49.893] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:49.893] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:49.893] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.894] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:44:49.894] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:44:49.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:49.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.894] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:49.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:49.895] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:44:49.895] MultisessionFuture started
[17:44:49.895] - Launch lazy future ... done
[17:44:49.896] run() for ‘MultisessionFuture’ ... done
[17:44:49.896] Created future:
[17:44:49.896] MultisessionFuture:
[17:44:49.896] Label: ‘future_mapply-1’
[17:44:49.896] Expression:
[17:44:49.896] {
[17:44:49.896]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.896]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:49.896]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.896]         on.exit(options(oopts), add = TRUE)
[17:44:49.896]     }
[17:44:49.896]     {
[17:44:49.896]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.896]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:49.896]         do.call(mapply, args = args)
[17:44:49.896]     }
[17:44:49.896] }
[17:44:49.896] Lazy evaluation: FALSE
[17:44:49.896] Asynchronous evaluation: TRUE
[17:44:49.896] Local evaluation: TRUE
[17:44:49.896] Environment: R_GlobalEnv
[17:44:49.896] Capture standard output: TRUE
[17:44:49.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:49.896] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:49.896] Packages: <none>
[17:44:49.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:49.896] Resolved: FALSE
[17:44:49.896] Value: <not collected>
[17:44:49.896] Conditions captured: <none>
[17:44:49.896] Early signaling: FALSE
[17:44:49.896] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:49.896] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.907] Chunk #1 of 2 ... DONE
[17:44:49.907] Chunk #2 of 2 ...
[17:44:49.907]  - Finding globals in '...' for chunk #2 ...
[17:44:49.908] getGlobalsAndPackages() ...
[17:44:49.908] Searching for globals...
[17:44:49.908] 
[17:44:49.908] Searching for globals ... DONE
[17:44:49.908] - globals: [0] <none>
[17:44:49.908] getGlobalsAndPackages() ... DONE
[17:44:49.908]    + additional globals found: [n=0] 
[17:44:49.908]    + additional namespaces needed: [n=0] 
[17:44:49.908]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:49.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:49.909]  - seeds: <none>
[17:44:49.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.909] getGlobalsAndPackages() ...
[17:44:49.909] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.909] Resolving globals: FALSE
[17:44:49.910] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:49.910] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:49.910] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.910] 
[17:44:49.910] getGlobalsAndPackages() ... DONE
[17:44:49.911] run() for ‘Future’ ...
[17:44:49.911] - state: ‘created’
[17:44:49.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:49.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:49.925]   - Field: ‘node’
[17:44:49.925]   - Field: ‘label’
[17:44:49.925]   - Field: ‘local’
[17:44:49.925]   - Field: ‘owner’
[17:44:49.925]   - Field: ‘envir’
[17:44:49.925]   - Field: ‘workers’
[17:44:49.926]   - Field: ‘packages’
[17:44:49.926]   - Field: ‘gc’
[17:44:49.926]   - Field: ‘conditions’
[17:44:49.926]   - Field: ‘persistent’
[17:44:49.926]   - Field: ‘expr’
[17:44:49.926]   - Field: ‘uuid’
[17:44:49.926]   - Field: ‘seed’
[17:44:49.926]   - Field: ‘version’
[17:44:49.926]   - Field: ‘result’
[17:44:49.926]   - Field: ‘asynchronous’
[17:44:49.926]   - Field: ‘calls’
[17:44:49.927]   - Field: ‘globals’
[17:44:49.927]   - Field: ‘stdout’
[17:44:49.927]   - Field: ‘earlySignal’
[17:44:49.927]   - Field: ‘lazy’
[17:44:49.927]   - Field: ‘state’
[17:44:49.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:49.927] - Launch lazy future ...
[17:44:49.927] Packages needed by the future expression (n = 0): <none>
[17:44:49.928] Packages needed by future strategies (n = 0): <none>
[17:44:49.928] {
[17:44:49.928]     {
[17:44:49.928]         {
[17:44:49.928]             ...future.startTime <- base::Sys.time()
[17:44:49.928]             {
[17:44:49.928]                 {
[17:44:49.928]                   {
[17:44:49.928]                     {
[17:44:49.928]                       base::local({
[17:44:49.928]                         has_future <- base::requireNamespace("future", 
[17:44:49.928]                           quietly = TRUE)
[17:44:49.928]                         if (has_future) {
[17:44:49.928]                           ns <- base::getNamespace("future")
[17:44:49.928]                           version <- ns[[".package"]][["version"]]
[17:44:49.928]                           if (is.null(version)) 
[17:44:49.928]                             version <- utils::packageVersion("future")
[17:44:49.928]                         }
[17:44:49.928]                         else {
[17:44:49.928]                           version <- NULL
[17:44:49.928]                         }
[17:44:49.928]                         if (!has_future || version < "1.8.0") {
[17:44:49.928]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:49.928]                             "", base::R.version$version.string), 
[17:44:49.928]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:49.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:49.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:49.928]                               "release", "version")], collapse = " "), 
[17:44:49.928]                             hostname = base::Sys.info()[["nodename"]])
[17:44:49.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:49.928]                             info)
[17:44:49.928]                           info <- base::paste(info, collapse = "; ")
[17:44:49.928]                           if (!has_future) {
[17:44:49.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:49.928]                               info)
[17:44:49.928]                           }
[17:44:49.928]                           else {
[17:44:49.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:49.928]                               info, version)
[17:44:49.928]                           }
[17:44:49.928]                           base::stop(msg)
[17:44:49.928]                         }
[17:44:49.928]                       })
[17:44:49.928]                     }
[17:44:49.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:49.928]                     base::options(mc.cores = 1L)
[17:44:49.928]                   }
[17:44:49.928]                   ...future.strategy.old <- future::plan("list")
[17:44:49.928]                   options(future.plan = NULL)
[17:44:49.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:49.928]                 }
[17:44:49.928]                 ...future.workdir <- getwd()
[17:44:49.928]             }
[17:44:49.928]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:49.928]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:49.928]         }
[17:44:49.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:49.928]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:49.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:49.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:49.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:49.928]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:49.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:49.928]             base::names(...future.oldOptions))
[17:44:49.928]     }
[17:44:49.928]     if (FALSE) {
[17:44:49.928]     }
[17:44:49.928]     else {
[17:44:49.928]         if (TRUE) {
[17:44:49.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:49.928]                 open = "w")
[17:44:49.928]         }
[17:44:49.928]         else {
[17:44:49.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:49.928]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:49.928]         }
[17:44:49.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:49.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:49.928]             base::sink(type = "output", split = FALSE)
[17:44:49.928]             base::close(...future.stdout)
[17:44:49.928]         }, add = TRUE)
[17:44:49.928]     }
[17:44:49.928]     ...future.frame <- base::sys.nframe()
[17:44:49.928]     ...future.conditions <- base::list()
[17:44:49.928]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:49.928]     if (FALSE) {
[17:44:49.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:49.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:49.928]     }
[17:44:49.928]     ...future.result <- base::tryCatch({
[17:44:49.928]         base::withCallingHandlers({
[17:44:49.928]             ...future.value <- base::withVisible(base::local({
[17:44:49.928]                 ...future.makeSendCondition <- base::local({
[17:44:49.928]                   sendCondition <- NULL
[17:44:49.928]                   function(frame = 1L) {
[17:44:49.928]                     if (is.function(sendCondition)) 
[17:44:49.928]                       return(sendCondition)
[17:44:49.928]                     ns <- getNamespace("parallel")
[17:44:49.928]                     if (exists("sendData", mode = "function", 
[17:44:49.928]                       envir = ns)) {
[17:44:49.928]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:49.928]                         envir = ns)
[17:44:49.928]                       envir <- sys.frame(frame)
[17:44:49.928]                       master <- NULL
[17:44:49.928]                       while (!identical(envir, .GlobalEnv) && 
[17:44:49.928]                         !identical(envir, emptyenv())) {
[17:44:49.928]                         if (exists("master", mode = "list", envir = envir, 
[17:44:49.928]                           inherits = FALSE)) {
[17:44:49.928]                           master <- get("master", mode = "list", 
[17:44:49.928]                             envir = envir, inherits = FALSE)
[17:44:49.928]                           if (inherits(master, c("SOCKnode", 
[17:44:49.928]                             "SOCK0node"))) {
[17:44:49.928]                             sendCondition <<- function(cond) {
[17:44:49.928]                               data <- list(type = "VALUE", value = cond, 
[17:44:49.928]                                 success = TRUE)
[17:44:49.928]                               parallel_sendData(master, data)
[17:44:49.928]                             }
[17:44:49.928]                             return(sendCondition)
[17:44:49.928]                           }
[17:44:49.928]                         }
[17:44:49.928]                         frame <- frame + 1L
[17:44:49.928]                         envir <- sys.frame(frame)
[17:44:49.928]                       }
[17:44:49.928]                     }
[17:44:49.928]                     sendCondition <<- function(cond) NULL
[17:44:49.928]                   }
[17:44:49.928]                 })
[17:44:49.928]                 withCallingHandlers({
[17:44:49.928]                   {
[17:44:49.928]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.928]                     if (!identical(...future.globals.maxSize.org, 
[17:44:49.928]                       ...future.globals.maxSize)) {
[17:44:49.928]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.928]                       on.exit(options(oopts), add = TRUE)
[17:44:49.928]                     }
[17:44:49.928]                     {
[17:44:49.928]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.928]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:49.928]                         USE.NAMES = FALSE)
[17:44:49.928]                       do.call(mapply, args = args)
[17:44:49.928]                     }
[17:44:49.928]                   }
[17:44:49.928]                 }, immediateCondition = function(cond) {
[17:44:49.928]                   sendCondition <- ...future.makeSendCondition()
[17:44:49.928]                   sendCondition(cond)
[17:44:49.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.928]                   {
[17:44:49.928]                     inherits <- base::inherits
[17:44:49.928]                     invokeRestart <- base::invokeRestart
[17:44:49.928]                     is.null <- base::is.null
[17:44:49.928]                     muffled <- FALSE
[17:44:49.928]                     if (inherits(cond, "message")) {
[17:44:49.928]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:49.928]                       if (muffled) 
[17:44:49.928]                         invokeRestart("muffleMessage")
[17:44:49.928]                     }
[17:44:49.928]                     else if (inherits(cond, "warning")) {
[17:44:49.928]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:49.928]                       if (muffled) 
[17:44:49.928]                         invokeRestart("muffleWarning")
[17:44:49.928]                     }
[17:44:49.928]                     else if (inherits(cond, "condition")) {
[17:44:49.928]                       if (!is.null(pattern)) {
[17:44:49.928]                         computeRestarts <- base::computeRestarts
[17:44:49.928]                         grepl <- base::grepl
[17:44:49.928]                         restarts <- computeRestarts(cond)
[17:44:49.928]                         for (restart in restarts) {
[17:44:49.928]                           name <- restart$name
[17:44:49.928]                           if (is.null(name)) 
[17:44:49.928]                             next
[17:44:49.928]                           if (!grepl(pattern, name)) 
[17:44:49.928]                             next
[17:44:49.928]                           invokeRestart(restart)
[17:44:49.928]                           muffled <- TRUE
[17:44:49.928]                           break
[17:44:49.928]                         }
[17:44:49.928]                       }
[17:44:49.928]                     }
[17:44:49.928]                     invisible(muffled)
[17:44:49.928]                   }
[17:44:49.928]                   muffleCondition(cond)
[17:44:49.928]                 })
[17:44:49.928]             }))
[17:44:49.928]             future::FutureResult(value = ...future.value$value, 
[17:44:49.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.928]                   ...future.rng), globalenv = if (FALSE) 
[17:44:49.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:49.928]                     ...future.globalenv.names))
[17:44:49.928]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:49.928]         }, condition = base::local({
[17:44:49.928]             c <- base::c
[17:44:49.928]             inherits <- base::inherits
[17:44:49.928]             invokeRestart <- base::invokeRestart
[17:44:49.928]             length <- base::length
[17:44:49.928]             list <- base::list
[17:44:49.928]             seq.int <- base::seq.int
[17:44:49.928]             signalCondition <- base::signalCondition
[17:44:49.928]             sys.calls <- base::sys.calls
[17:44:49.928]             `[[` <- base::`[[`
[17:44:49.928]             `+` <- base::`+`
[17:44:49.928]             `<<-` <- base::`<<-`
[17:44:49.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:49.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:49.928]                   3L)]
[17:44:49.928]             }
[17:44:49.928]             function(cond) {
[17:44:49.928]                 is_error <- inherits(cond, "error")
[17:44:49.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:49.928]                   NULL)
[17:44:49.928]                 if (is_error) {
[17:44:49.928]                   sessionInformation <- function() {
[17:44:49.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:49.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:49.928]                       search = base::search(), system = base::Sys.info())
[17:44:49.928]                   }
[17:44:49.928]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:49.928]                     cond$call), session = sessionInformation(), 
[17:44:49.928]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:49.928]                   signalCondition(cond)
[17:44:49.928]                 }
[17:44:49.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:49.928]                 "immediateCondition"))) {
[17:44:49.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:49.928]                   ...future.conditions[[length(...future.conditions) + 
[17:44:49.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:49.928]                   if (TRUE && !signal) {
[17:44:49.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.928]                     {
[17:44:49.928]                       inherits <- base::inherits
[17:44:49.928]                       invokeRestart <- base::invokeRestart
[17:44:49.928]                       is.null <- base::is.null
[17:44:49.928]                       muffled <- FALSE
[17:44:49.928]                       if (inherits(cond, "message")) {
[17:44:49.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.928]                         if (muffled) 
[17:44:49.928]                           invokeRestart("muffleMessage")
[17:44:49.928]                       }
[17:44:49.928]                       else if (inherits(cond, "warning")) {
[17:44:49.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.928]                         if (muffled) 
[17:44:49.928]                           invokeRestart("muffleWarning")
[17:44:49.928]                       }
[17:44:49.928]                       else if (inherits(cond, "condition")) {
[17:44:49.928]                         if (!is.null(pattern)) {
[17:44:49.928]                           computeRestarts <- base::computeRestarts
[17:44:49.928]                           grepl <- base::grepl
[17:44:49.928]                           restarts <- computeRestarts(cond)
[17:44:49.928]                           for (restart in restarts) {
[17:44:49.928]                             name <- restart$name
[17:44:49.928]                             if (is.null(name)) 
[17:44:49.928]                               next
[17:44:49.928]                             if (!grepl(pattern, name)) 
[17:44:49.928]                               next
[17:44:49.928]                             invokeRestart(restart)
[17:44:49.928]                             muffled <- TRUE
[17:44:49.928]                             break
[17:44:49.928]                           }
[17:44:49.928]                         }
[17:44:49.928]                       }
[17:44:49.928]                       invisible(muffled)
[17:44:49.928]                     }
[17:44:49.928]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.928]                   }
[17:44:49.928]                 }
[17:44:49.928]                 else {
[17:44:49.928]                   if (TRUE) {
[17:44:49.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:49.928]                     {
[17:44:49.928]                       inherits <- base::inherits
[17:44:49.928]                       invokeRestart <- base::invokeRestart
[17:44:49.928]                       is.null <- base::is.null
[17:44:49.928]                       muffled <- FALSE
[17:44:49.928]                       if (inherits(cond, "message")) {
[17:44:49.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:49.928]                         if (muffled) 
[17:44:49.928]                           invokeRestart("muffleMessage")
[17:44:49.928]                       }
[17:44:49.928]                       else if (inherits(cond, "warning")) {
[17:44:49.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:49.928]                         if (muffled) 
[17:44:49.928]                           invokeRestart("muffleWarning")
[17:44:49.928]                       }
[17:44:49.928]                       else if (inherits(cond, "condition")) {
[17:44:49.928]                         if (!is.null(pattern)) {
[17:44:49.928]                           computeRestarts <- base::computeRestarts
[17:44:49.928]                           grepl <- base::grepl
[17:44:49.928]                           restarts <- computeRestarts(cond)
[17:44:49.928]                           for (restart in restarts) {
[17:44:49.928]                             name <- restart$name
[17:44:49.928]                             if (is.null(name)) 
[17:44:49.928]                               next
[17:44:49.928]                             if (!grepl(pattern, name)) 
[17:44:49.928]                               next
[17:44:49.928]                             invokeRestart(restart)
[17:44:49.928]                             muffled <- TRUE
[17:44:49.928]                             break
[17:44:49.928]                           }
[17:44:49.928]                         }
[17:44:49.928]                       }
[17:44:49.928]                       invisible(muffled)
[17:44:49.928]                     }
[17:44:49.928]                     muffleCondition(cond, pattern = "^muffle")
[17:44:49.928]                   }
[17:44:49.928]                 }
[17:44:49.928]             }
[17:44:49.928]         }))
[17:44:49.928]     }, error = function(ex) {
[17:44:49.928]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:49.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:49.928]                 ...future.rng), started = ...future.startTime, 
[17:44:49.928]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:49.928]             version = "1.8"), class = "FutureResult")
[17:44:49.928]     }, finally = {
[17:44:49.928]         if (!identical(...future.workdir, getwd())) 
[17:44:49.928]             setwd(...future.workdir)
[17:44:49.928]         {
[17:44:49.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:49.928]                 ...future.oldOptions$nwarnings <- NULL
[17:44:49.928]             }
[17:44:49.928]             base::options(...future.oldOptions)
[17:44:49.928]             if (.Platform$OS.type == "windows") {
[17:44:49.928]                 old_names <- names(...future.oldEnvVars)
[17:44:49.928]                 envs <- base::Sys.getenv()
[17:44:49.928]                 names <- names(envs)
[17:44:49.928]                 common <- intersect(names, old_names)
[17:44:49.928]                 added <- setdiff(names, old_names)
[17:44:49.928]                 removed <- setdiff(old_names, names)
[17:44:49.928]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:49.928]                   envs[common]]
[17:44:49.928]                 NAMES <- toupper(changed)
[17:44:49.928]                 args <- list()
[17:44:49.928]                 for (kk in seq_along(NAMES)) {
[17:44:49.928]                   name <- changed[[kk]]
[17:44:49.928]                   NAME <- NAMES[[kk]]
[17:44:49.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.928]                     next
[17:44:49.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.928]                 }
[17:44:49.928]                 NAMES <- toupper(added)
[17:44:49.928]                 for (kk in seq_along(NAMES)) {
[17:44:49.928]                   name <- added[[kk]]
[17:44:49.928]                   NAME <- NAMES[[kk]]
[17:44:49.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.928]                     next
[17:44:49.928]                   args[[name]] <- ""
[17:44:49.928]                 }
[17:44:49.928]                 NAMES <- toupper(removed)
[17:44:49.928]                 for (kk in seq_along(NAMES)) {
[17:44:49.928]                   name <- removed[[kk]]
[17:44:49.928]                   NAME <- NAMES[[kk]]
[17:44:49.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:49.928]                     next
[17:44:49.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:49.928]                 }
[17:44:49.928]                 if (length(args) > 0) 
[17:44:49.928]                   base::do.call(base::Sys.setenv, args = args)
[17:44:49.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:49.928]             }
[17:44:49.928]             else {
[17:44:49.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:49.928]             }
[17:44:49.928]             {
[17:44:49.928]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:49.928]                   0L) {
[17:44:49.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:49.928]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:49.928]                   base::options(opts)
[17:44:49.928]                 }
[17:44:49.928]                 {
[17:44:49.928]                   {
[17:44:49.928]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:49.928]                     NULL
[17:44:49.928]                   }
[17:44:49.928]                   options(future.plan = NULL)
[17:44:49.928]                   if (is.na(NA_character_)) 
[17:44:49.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:49.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:49.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:49.928]                     .init = FALSE)
[17:44:49.928]                 }
[17:44:49.928]             }
[17:44:49.928]         }
[17:44:49.928]     })
[17:44:49.928]     if (TRUE) {
[17:44:49.928]         base::sink(type = "output", split = FALSE)
[17:44:49.928]         if (TRUE) {
[17:44:49.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:49.928]         }
[17:44:49.928]         else {
[17:44:49.928]             ...future.result["stdout"] <- base::list(NULL)
[17:44:49.928]         }
[17:44:49.928]         base::close(...future.stdout)
[17:44:49.928]         ...future.stdout <- NULL
[17:44:49.928]     }
[17:44:49.928]     ...future.result$conditions <- ...future.conditions
[17:44:49.928]     ...future.result$finished <- base::Sys.time()
[17:44:49.928]     ...future.result
[17:44:49.928] }
[17:44:49.931] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:44:49.931] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:49.931] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:49.931] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:49.932] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.932] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:49.932] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:49.932] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:49.932] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.933] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:49.933] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:49.933] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:44:49.933] MultisessionFuture started
[17:44:49.934] - Launch lazy future ... done
[17:44:49.934] run() for ‘MultisessionFuture’ ... done
[17:44:49.934] Created future:
[17:44:49.934] MultisessionFuture:
[17:44:49.934] Label: ‘future_mapply-2’
[17:44:49.934] Expression:
[17:44:49.934] {
[17:44:49.934]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:49.934]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:49.934]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:49.934]         on.exit(options(oopts), add = TRUE)
[17:44:49.934]     }
[17:44:49.934]     {
[17:44:49.934]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:49.934]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:49.934]         do.call(mapply, args = args)
[17:44:49.934]     }
[17:44:49.934] }
[17:44:49.934] Lazy evaluation: FALSE
[17:44:49.934] Asynchronous evaluation: TRUE
[17:44:49.934] Local evaluation: TRUE
[17:44:49.934] Environment: R_GlobalEnv
[17:44:49.934] Capture standard output: TRUE
[17:44:49.934] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:49.934] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:49.934] Packages: <none>
[17:44:49.934] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:49.934] Resolved: FALSE
[17:44:49.934] Value: <not collected>
[17:44:49.934] Conditions captured: <none>
[17:44:49.934] Early signaling: FALSE
[17:44:49.934] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:49.934] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:49.945] Chunk #2 of 2 ... DONE
[17:44:49.945] Launching 2 futures (chunks) ... DONE
[17:44:49.945] Resolving 2 futures (chunks) ...
[17:44:49.946] resolve() on list ...
[17:44:49.946]  recursive: 0
[17:44:49.946]  length: 2
[17:44:49.946] 
[17:44:49.946] receiveMessageFromWorker() for ClusterFuture ...
[17:44:49.946] - Validating connection of MultisessionFuture
[17:44:49.947] - received message: FutureResult
[17:44:49.947] - Received FutureResult
[17:44:49.947] - Erased future from FutureRegistry
[17:44:49.947] result() for ClusterFuture ...
[17:44:49.947] - result already collected: FutureResult
[17:44:49.947] result() for ClusterFuture ... done
[17:44:49.947] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:49.947] Future #1
[17:44:49.947] result() for ClusterFuture ...
[17:44:49.948] - result already collected: FutureResult
[17:44:49.948] result() for ClusterFuture ... done
[17:44:49.948] result() for ClusterFuture ...
[17:44:49.948] - result already collected: FutureResult
[17:44:49.948] result() for ClusterFuture ... done
[17:44:49.948] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:49.948] - nx: 2
[17:44:49.948] - relay: TRUE
[17:44:49.948] - stdout: TRUE
[17:44:49.948] - signal: TRUE
[17:44:49.948] - resignal: FALSE
[17:44:49.948] - force: TRUE
[17:44:49.949] - relayed: [n=2] FALSE, FALSE
[17:44:49.949] - queued futures: [n=2] FALSE, FALSE
[17:44:49.949]  - until=1
[17:44:49.949]  - relaying element #1
[17:44:49.949] result() for ClusterFuture ...
[17:44:49.949] - result already collected: FutureResult
[17:44:49.949] result() for ClusterFuture ... done
[17:44:49.949] result() for ClusterFuture ...
[17:44:49.949] - result already collected: FutureResult
[17:44:49.949] result() for ClusterFuture ... done
[17:44:49.949] result() for ClusterFuture ...
[17:44:49.950] - result already collected: FutureResult
[17:44:49.950] result() for ClusterFuture ... done
[17:44:49.950] result() for ClusterFuture ...
[17:44:49.950] - result already collected: FutureResult
[17:44:49.950] result() for ClusterFuture ... done
[17:44:49.950] - relayed: [n=2] TRUE, FALSE
[17:44:49.950] - queued futures: [n=2] TRUE, FALSE
[17:44:49.950] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:49.950]  length: 1 (resolved future 1)
[17:44:49.977] receiveMessageFromWorker() for ClusterFuture ...
[17:44:49.977] - Validating connection of MultisessionFuture
[17:44:49.977] - received message: FutureResult
[17:44:49.977] - Received FutureResult
[17:44:49.977] - Erased future from FutureRegistry
[17:44:49.977] result() for ClusterFuture ...
[17:44:49.978] - result already collected: FutureResult
[17:44:49.978] result() for ClusterFuture ... done
[17:44:49.978] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:49.978] Future #2
[17:44:49.978] result() for ClusterFuture ...
[17:44:49.978] - result already collected: FutureResult
[17:44:49.978] result() for ClusterFuture ... done
[17:44:49.978] result() for ClusterFuture ...
[17:44:49.978] - result already collected: FutureResult
[17:44:49.978] result() for ClusterFuture ... done
[17:44:49.978] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:49.978] - nx: 2
[17:44:49.979] - relay: TRUE
[17:44:49.979] - stdout: TRUE
[17:44:49.979] - signal: TRUE
[17:44:49.979] - resignal: FALSE
[17:44:49.979] - force: TRUE
[17:44:49.979] - relayed: [n=2] TRUE, FALSE
[17:44:49.979] - queued futures: [n=2] TRUE, FALSE
[17:44:49.979]  - until=2
[17:44:49.979]  - relaying element #2
[17:44:49.979] result() for ClusterFuture ...
[17:44:49.979] - result already collected: FutureResult
[17:44:49.980] result() for ClusterFuture ... done
[17:44:49.980] result() for ClusterFuture ...
[17:44:49.980] - result already collected: FutureResult
[17:44:49.980] result() for ClusterFuture ... done
[17:44:49.980] result() for ClusterFuture ...
[17:44:49.980] - result already collected: FutureResult
[17:44:49.980] result() for ClusterFuture ... done
[17:44:49.980] result() for ClusterFuture ...
[17:44:49.980] - result already collected: FutureResult
[17:44:49.980] result() for ClusterFuture ... done
[17:44:49.980] - relayed: [n=2] TRUE, TRUE
[17:44:49.981] - queued futures: [n=2] TRUE, TRUE
[17:44:49.981] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:49.981]  length: 0 (resolved future 2)
[17:44:49.981] Relaying remaining futures
[17:44:49.981] signalConditionsASAP(NULL, pos=0) ...
[17:44:49.981] - nx: 2
[17:44:49.981] - relay: TRUE
[17:44:49.981] - stdout: TRUE
[17:44:49.981] - signal: TRUE
[17:44:49.981] - resignal: FALSE
[17:44:49.981] - force: TRUE
[17:44:49.981] - relayed: [n=2] TRUE, TRUE
[17:44:49.982] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:49.982] - relayed: [n=2] TRUE, TRUE
[17:44:49.982] - queued futures: [n=2] TRUE, TRUE
[17:44:49.982] signalConditionsASAP(NULL, pos=0) ... done
[17:44:49.982] resolve() on list ... DONE
[17:44:49.982] result() for ClusterFuture ...
[17:44:49.982] - result already collected: FutureResult
[17:44:49.982] result() for ClusterFuture ... done
[17:44:49.982] result() for ClusterFuture ...
[17:44:49.982] - result already collected: FutureResult
[17:44:49.982] result() for ClusterFuture ... done
[17:44:49.983] result() for ClusterFuture ...
[17:44:49.983] - result already collected: FutureResult
[17:44:49.983] result() for ClusterFuture ... done
[17:44:49.983] result() for ClusterFuture ...
[17:44:49.983] - result already collected: FutureResult
[17:44:49.983] result() for ClusterFuture ... done
[17:44:49.983]  - Number of value chunks collected: 2
[17:44:49.983] Resolving 2 futures (chunks) ... DONE
[17:44:49.983] Reducing values from 2 chunks ...
[17:44:49.983]  - Number of values collected after concatenation: 4
[17:44:49.983]  - Number of values expected: 4
[17:44:49.984] Reducing values from 2 chunks ... DONE
[17:44:49.984] future_mapply() ... DONE
[17:44:49.984] future_mapply() ...
[17:44:49.987] Number of chunks: 2
[17:44:49.988] getGlobalsAndPackagesXApply() ...
[17:44:49.988]  - future.globals: TRUE
[17:44:49.988] getGlobalsAndPackages() ...
[17:44:49.988] Searching for globals...
[17:44:49.988] - globals found: [1] ‘FUN’
[17:44:49.989] Searching for globals ... DONE
[17:44:49.989] Resolving globals: FALSE
[17:44:49.989] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:49.989] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:49.989] - globals: [1] ‘FUN’
[17:44:49.989] 
[17:44:49.990] getGlobalsAndPackages() ... DONE
[17:44:49.990]  - globals found/used: [n=1] ‘FUN’
[17:44:49.990]  - needed namespaces: [n=0] 
[17:44:49.990] Finding globals ... DONE
[17:44:49.990] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:49.990] List of 2
[17:44:49.990]  $ ...future.FUN:function (x, ...)  
[17:44:49.990]  $ MoreArgs     : NULL
[17:44:49.990]  - attr(*, "where")=List of 2
[17:44:49.990]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:49.990]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:49.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:49.990]  - attr(*, "resolved")= logi FALSE
[17:44:49.990]  - attr(*, "total_size")= num NA
[17:44:49.993] Packages to be attached in all futures: [n=0] 
[17:44:49.993] getGlobalsAndPackagesXApply() ... DONE
[17:44:49.993] Number of futures (= number of chunks): 2
[17:44:49.993] Launching 2 futures (chunks) ...
[17:44:49.993] Chunk #1 of 2 ...
[17:44:49.993]  - Finding globals in '...' for chunk #1 ...
[17:44:49.993] getGlobalsAndPackages() ...
[17:44:49.993] Searching for globals...
[17:44:49.994] 
[17:44:49.994] Searching for globals ... DONE
[17:44:49.994] - globals: [0] <none>
[17:44:49.994] getGlobalsAndPackages() ... DONE
[17:44:49.994]    + additional globals found: [n=0] 
[17:44:49.994]    + additional namespaces needed: [n=0] 
[17:44:49.994]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:49.994]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:49.994]  - seeds: <none>
[17:44:49.994]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.995] getGlobalsAndPackages() ...
[17:44:49.995] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.995] Resolving globals: FALSE
[17:44:49.995] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:49.996] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:49.996] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:49.996] 
[17:44:49.996] getGlobalsAndPackages() ... DONE
[17:44:49.996] run() for ‘Future’ ...
[17:44:49.996] - state: ‘created’
[17:44:49.996] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.010] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.010] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.010]   - Field: ‘node’
[17:44:50.010]   - Field: ‘label’
[17:44:50.010]   - Field: ‘local’
[17:44:50.011]   - Field: ‘owner’
[17:44:50.011]   - Field: ‘envir’
[17:44:50.011]   - Field: ‘workers’
[17:44:50.011]   - Field: ‘packages’
[17:44:50.011]   - Field: ‘gc’
[17:44:50.011]   - Field: ‘conditions’
[17:44:50.011]   - Field: ‘persistent’
[17:44:50.011]   - Field: ‘expr’
[17:44:50.011]   - Field: ‘uuid’
[17:44:50.011]   - Field: ‘seed’
[17:44:50.011]   - Field: ‘version’
[17:44:50.012]   - Field: ‘result’
[17:44:50.012]   - Field: ‘asynchronous’
[17:44:50.012]   - Field: ‘calls’
[17:44:50.012]   - Field: ‘globals’
[17:44:50.012]   - Field: ‘stdout’
[17:44:50.012]   - Field: ‘earlySignal’
[17:44:50.012]   - Field: ‘lazy’
[17:44:50.012]   - Field: ‘state’
[17:44:50.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.012] - Launch lazy future ...
[17:44:50.013] Packages needed by the future expression (n = 0): <none>
[17:44:50.013] Packages needed by future strategies (n = 0): <none>
[17:44:50.013] {
[17:44:50.013]     {
[17:44:50.013]         {
[17:44:50.013]             ...future.startTime <- base::Sys.time()
[17:44:50.013]             {
[17:44:50.013]                 {
[17:44:50.013]                   {
[17:44:50.013]                     {
[17:44:50.013]                       base::local({
[17:44:50.013]                         has_future <- base::requireNamespace("future", 
[17:44:50.013]                           quietly = TRUE)
[17:44:50.013]                         if (has_future) {
[17:44:50.013]                           ns <- base::getNamespace("future")
[17:44:50.013]                           version <- ns[[".package"]][["version"]]
[17:44:50.013]                           if (is.null(version)) 
[17:44:50.013]                             version <- utils::packageVersion("future")
[17:44:50.013]                         }
[17:44:50.013]                         else {
[17:44:50.013]                           version <- NULL
[17:44:50.013]                         }
[17:44:50.013]                         if (!has_future || version < "1.8.0") {
[17:44:50.013]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.013]                             "", base::R.version$version.string), 
[17:44:50.013]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.013]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.013]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.013]                               "release", "version")], collapse = " "), 
[17:44:50.013]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.013]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.013]                             info)
[17:44:50.013]                           info <- base::paste(info, collapse = "; ")
[17:44:50.013]                           if (!has_future) {
[17:44:50.013]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.013]                               info)
[17:44:50.013]                           }
[17:44:50.013]                           else {
[17:44:50.013]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.013]                               info, version)
[17:44:50.013]                           }
[17:44:50.013]                           base::stop(msg)
[17:44:50.013]                         }
[17:44:50.013]                       })
[17:44:50.013]                     }
[17:44:50.013]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.013]                     base::options(mc.cores = 1L)
[17:44:50.013]                   }
[17:44:50.013]                   ...future.strategy.old <- future::plan("list")
[17:44:50.013]                   options(future.plan = NULL)
[17:44:50.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.013]                 }
[17:44:50.013]                 ...future.workdir <- getwd()
[17:44:50.013]             }
[17:44:50.013]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.013]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.013]         }
[17:44:50.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.013]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.013]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.013]             base::names(...future.oldOptions))
[17:44:50.013]     }
[17:44:50.013]     if (FALSE) {
[17:44:50.013]     }
[17:44:50.013]     else {
[17:44:50.013]         if (TRUE) {
[17:44:50.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.013]                 open = "w")
[17:44:50.013]         }
[17:44:50.013]         else {
[17:44:50.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.013]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.013]         }
[17:44:50.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.013]             base::sink(type = "output", split = FALSE)
[17:44:50.013]             base::close(...future.stdout)
[17:44:50.013]         }, add = TRUE)
[17:44:50.013]     }
[17:44:50.013]     ...future.frame <- base::sys.nframe()
[17:44:50.013]     ...future.conditions <- base::list()
[17:44:50.013]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.013]     if (FALSE) {
[17:44:50.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.013]     }
[17:44:50.013]     ...future.result <- base::tryCatch({
[17:44:50.013]         base::withCallingHandlers({
[17:44:50.013]             ...future.value <- base::withVisible(base::local({
[17:44:50.013]                 ...future.makeSendCondition <- base::local({
[17:44:50.013]                   sendCondition <- NULL
[17:44:50.013]                   function(frame = 1L) {
[17:44:50.013]                     if (is.function(sendCondition)) 
[17:44:50.013]                       return(sendCondition)
[17:44:50.013]                     ns <- getNamespace("parallel")
[17:44:50.013]                     if (exists("sendData", mode = "function", 
[17:44:50.013]                       envir = ns)) {
[17:44:50.013]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.013]                         envir = ns)
[17:44:50.013]                       envir <- sys.frame(frame)
[17:44:50.013]                       master <- NULL
[17:44:50.013]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.013]                         !identical(envir, emptyenv())) {
[17:44:50.013]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.013]                           inherits = FALSE)) {
[17:44:50.013]                           master <- get("master", mode = "list", 
[17:44:50.013]                             envir = envir, inherits = FALSE)
[17:44:50.013]                           if (inherits(master, c("SOCKnode", 
[17:44:50.013]                             "SOCK0node"))) {
[17:44:50.013]                             sendCondition <<- function(cond) {
[17:44:50.013]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.013]                                 success = TRUE)
[17:44:50.013]                               parallel_sendData(master, data)
[17:44:50.013]                             }
[17:44:50.013]                             return(sendCondition)
[17:44:50.013]                           }
[17:44:50.013]                         }
[17:44:50.013]                         frame <- frame + 1L
[17:44:50.013]                         envir <- sys.frame(frame)
[17:44:50.013]                       }
[17:44:50.013]                     }
[17:44:50.013]                     sendCondition <<- function(cond) NULL
[17:44:50.013]                   }
[17:44:50.013]                 })
[17:44:50.013]                 withCallingHandlers({
[17:44:50.013]                   {
[17:44:50.013]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.013]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.013]                       ...future.globals.maxSize)) {
[17:44:50.013]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.013]                       on.exit(options(oopts), add = TRUE)
[17:44:50.013]                     }
[17:44:50.013]                     {
[17:44:50.013]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.013]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.013]                         USE.NAMES = FALSE)
[17:44:50.013]                       do.call(mapply, args = args)
[17:44:50.013]                     }
[17:44:50.013]                   }
[17:44:50.013]                 }, immediateCondition = function(cond) {
[17:44:50.013]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.013]                   sendCondition(cond)
[17:44:50.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.013]                   {
[17:44:50.013]                     inherits <- base::inherits
[17:44:50.013]                     invokeRestart <- base::invokeRestart
[17:44:50.013]                     is.null <- base::is.null
[17:44:50.013]                     muffled <- FALSE
[17:44:50.013]                     if (inherits(cond, "message")) {
[17:44:50.013]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.013]                       if (muffled) 
[17:44:50.013]                         invokeRestart("muffleMessage")
[17:44:50.013]                     }
[17:44:50.013]                     else if (inherits(cond, "warning")) {
[17:44:50.013]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.013]                       if (muffled) 
[17:44:50.013]                         invokeRestart("muffleWarning")
[17:44:50.013]                     }
[17:44:50.013]                     else if (inherits(cond, "condition")) {
[17:44:50.013]                       if (!is.null(pattern)) {
[17:44:50.013]                         computeRestarts <- base::computeRestarts
[17:44:50.013]                         grepl <- base::grepl
[17:44:50.013]                         restarts <- computeRestarts(cond)
[17:44:50.013]                         for (restart in restarts) {
[17:44:50.013]                           name <- restart$name
[17:44:50.013]                           if (is.null(name)) 
[17:44:50.013]                             next
[17:44:50.013]                           if (!grepl(pattern, name)) 
[17:44:50.013]                             next
[17:44:50.013]                           invokeRestart(restart)
[17:44:50.013]                           muffled <- TRUE
[17:44:50.013]                           break
[17:44:50.013]                         }
[17:44:50.013]                       }
[17:44:50.013]                     }
[17:44:50.013]                     invisible(muffled)
[17:44:50.013]                   }
[17:44:50.013]                   muffleCondition(cond)
[17:44:50.013]                 })
[17:44:50.013]             }))
[17:44:50.013]             future::FutureResult(value = ...future.value$value, 
[17:44:50.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.013]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.013]                     ...future.globalenv.names))
[17:44:50.013]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.013]         }, condition = base::local({
[17:44:50.013]             c <- base::c
[17:44:50.013]             inherits <- base::inherits
[17:44:50.013]             invokeRestart <- base::invokeRestart
[17:44:50.013]             length <- base::length
[17:44:50.013]             list <- base::list
[17:44:50.013]             seq.int <- base::seq.int
[17:44:50.013]             signalCondition <- base::signalCondition
[17:44:50.013]             sys.calls <- base::sys.calls
[17:44:50.013]             `[[` <- base::`[[`
[17:44:50.013]             `+` <- base::`+`
[17:44:50.013]             `<<-` <- base::`<<-`
[17:44:50.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.013]                   3L)]
[17:44:50.013]             }
[17:44:50.013]             function(cond) {
[17:44:50.013]                 is_error <- inherits(cond, "error")
[17:44:50.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.013]                   NULL)
[17:44:50.013]                 if (is_error) {
[17:44:50.013]                   sessionInformation <- function() {
[17:44:50.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.013]                       search = base::search(), system = base::Sys.info())
[17:44:50.013]                   }
[17:44:50.013]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.013]                     cond$call), session = sessionInformation(), 
[17:44:50.013]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.013]                   signalCondition(cond)
[17:44:50.013]                 }
[17:44:50.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.013]                 "immediateCondition"))) {
[17:44:50.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.013]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.013]                   if (TRUE && !signal) {
[17:44:50.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.013]                     {
[17:44:50.013]                       inherits <- base::inherits
[17:44:50.013]                       invokeRestart <- base::invokeRestart
[17:44:50.013]                       is.null <- base::is.null
[17:44:50.013]                       muffled <- FALSE
[17:44:50.013]                       if (inherits(cond, "message")) {
[17:44:50.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.013]                         if (muffled) 
[17:44:50.013]                           invokeRestart("muffleMessage")
[17:44:50.013]                       }
[17:44:50.013]                       else if (inherits(cond, "warning")) {
[17:44:50.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.013]                         if (muffled) 
[17:44:50.013]                           invokeRestart("muffleWarning")
[17:44:50.013]                       }
[17:44:50.013]                       else if (inherits(cond, "condition")) {
[17:44:50.013]                         if (!is.null(pattern)) {
[17:44:50.013]                           computeRestarts <- base::computeRestarts
[17:44:50.013]                           grepl <- base::grepl
[17:44:50.013]                           restarts <- computeRestarts(cond)
[17:44:50.013]                           for (restart in restarts) {
[17:44:50.013]                             name <- restart$name
[17:44:50.013]                             if (is.null(name)) 
[17:44:50.013]                               next
[17:44:50.013]                             if (!grepl(pattern, name)) 
[17:44:50.013]                               next
[17:44:50.013]                             invokeRestart(restart)
[17:44:50.013]                             muffled <- TRUE
[17:44:50.013]                             break
[17:44:50.013]                           }
[17:44:50.013]                         }
[17:44:50.013]                       }
[17:44:50.013]                       invisible(muffled)
[17:44:50.013]                     }
[17:44:50.013]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.013]                   }
[17:44:50.013]                 }
[17:44:50.013]                 else {
[17:44:50.013]                   if (TRUE) {
[17:44:50.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.013]                     {
[17:44:50.013]                       inherits <- base::inherits
[17:44:50.013]                       invokeRestart <- base::invokeRestart
[17:44:50.013]                       is.null <- base::is.null
[17:44:50.013]                       muffled <- FALSE
[17:44:50.013]                       if (inherits(cond, "message")) {
[17:44:50.013]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.013]                         if (muffled) 
[17:44:50.013]                           invokeRestart("muffleMessage")
[17:44:50.013]                       }
[17:44:50.013]                       else if (inherits(cond, "warning")) {
[17:44:50.013]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.013]                         if (muffled) 
[17:44:50.013]                           invokeRestart("muffleWarning")
[17:44:50.013]                       }
[17:44:50.013]                       else if (inherits(cond, "condition")) {
[17:44:50.013]                         if (!is.null(pattern)) {
[17:44:50.013]                           computeRestarts <- base::computeRestarts
[17:44:50.013]                           grepl <- base::grepl
[17:44:50.013]                           restarts <- computeRestarts(cond)
[17:44:50.013]                           for (restart in restarts) {
[17:44:50.013]                             name <- restart$name
[17:44:50.013]                             if (is.null(name)) 
[17:44:50.013]                               next
[17:44:50.013]                             if (!grepl(pattern, name)) 
[17:44:50.013]                               next
[17:44:50.013]                             invokeRestart(restart)
[17:44:50.013]                             muffled <- TRUE
[17:44:50.013]                             break
[17:44:50.013]                           }
[17:44:50.013]                         }
[17:44:50.013]                       }
[17:44:50.013]                       invisible(muffled)
[17:44:50.013]                     }
[17:44:50.013]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.013]                   }
[17:44:50.013]                 }
[17:44:50.013]             }
[17:44:50.013]         }))
[17:44:50.013]     }, error = function(ex) {
[17:44:50.013]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.013]                 ...future.rng), started = ...future.startTime, 
[17:44:50.013]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.013]             version = "1.8"), class = "FutureResult")
[17:44:50.013]     }, finally = {
[17:44:50.013]         if (!identical(...future.workdir, getwd())) 
[17:44:50.013]             setwd(...future.workdir)
[17:44:50.013]         {
[17:44:50.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.013]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.013]             }
[17:44:50.013]             base::options(...future.oldOptions)
[17:44:50.013]             if (.Platform$OS.type == "windows") {
[17:44:50.013]                 old_names <- names(...future.oldEnvVars)
[17:44:50.013]                 envs <- base::Sys.getenv()
[17:44:50.013]                 names <- names(envs)
[17:44:50.013]                 common <- intersect(names, old_names)
[17:44:50.013]                 added <- setdiff(names, old_names)
[17:44:50.013]                 removed <- setdiff(old_names, names)
[17:44:50.013]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.013]                   envs[common]]
[17:44:50.013]                 NAMES <- toupper(changed)
[17:44:50.013]                 args <- list()
[17:44:50.013]                 for (kk in seq_along(NAMES)) {
[17:44:50.013]                   name <- changed[[kk]]
[17:44:50.013]                   NAME <- NAMES[[kk]]
[17:44:50.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.013]                     next
[17:44:50.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.013]                 }
[17:44:50.013]                 NAMES <- toupper(added)
[17:44:50.013]                 for (kk in seq_along(NAMES)) {
[17:44:50.013]                   name <- added[[kk]]
[17:44:50.013]                   NAME <- NAMES[[kk]]
[17:44:50.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.013]                     next
[17:44:50.013]                   args[[name]] <- ""
[17:44:50.013]                 }
[17:44:50.013]                 NAMES <- toupper(removed)
[17:44:50.013]                 for (kk in seq_along(NAMES)) {
[17:44:50.013]                   name <- removed[[kk]]
[17:44:50.013]                   NAME <- NAMES[[kk]]
[17:44:50.013]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.013]                     next
[17:44:50.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.013]                 }
[17:44:50.013]                 if (length(args) > 0) 
[17:44:50.013]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.013]             }
[17:44:50.013]             else {
[17:44:50.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.013]             }
[17:44:50.013]             {
[17:44:50.013]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.013]                   0L) {
[17:44:50.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.013]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.013]                   base::options(opts)
[17:44:50.013]                 }
[17:44:50.013]                 {
[17:44:50.013]                   {
[17:44:50.013]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.013]                     NULL
[17:44:50.013]                   }
[17:44:50.013]                   options(future.plan = NULL)
[17:44:50.013]                   if (is.na(NA_character_)) 
[17:44:50.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.013]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.013]                     .init = FALSE)
[17:44:50.013]                 }
[17:44:50.013]             }
[17:44:50.013]         }
[17:44:50.013]     })
[17:44:50.013]     if (TRUE) {
[17:44:50.013]         base::sink(type = "output", split = FALSE)
[17:44:50.013]         if (TRUE) {
[17:44:50.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.013]         }
[17:44:50.013]         else {
[17:44:50.013]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.013]         }
[17:44:50.013]         base::close(...future.stdout)
[17:44:50.013]         ...future.stdout <- NULL
[17:44:50.013]     }
[17:44:50.013]     ...future.result$conditions <- ...future.conditions
[17:44:50.013]     ...future.result$finished <- base::Sys.time()
[17:44:50.013]     ...future.result
[17:44:50.013] }
[17:44:50.016] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:44:50.016] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:50.016] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:50.016] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.017] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.017] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:44:50.017] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:44:50.017] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.018] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.018] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:44:50.018] MultisessionFuture started
[17:44:50.019] - Launch lazy future ... done
[17:44:50.019] run() for ‘MultisessionFuture’ ... done
[17:44:50.019] Created future:
[17:44:50.019] MultisessionFuture:
[17:44:50.019] Label: ‘future_mapply-1’
[17:44:50.019] Expression:
[17:44:50.019] {
[17:44:50.019]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.019]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.019]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.019]         on.exit(options(oopts), add = TRUE)
[17:44:50.019]     }
[17:44:50.019]     {
[17:44:50.019]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.019]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.019]         do.call(mapply, args = args)
[17:44:50.019]     }
[17:44:50.019] }
[17:44:50.019] Lazy evaluation: FALSE
[17:44:50.019] Asynchronous evaluation: TRUE
[17:44:50.019] Local evaluation: TRUE
[17:44:50.019] Environment: R_GlobalEnv
[17:44:50.019] Capture standard output: TRUE
[17:44:50.019] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.019] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.019] Packages: <none>
[17:44:50.019] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.019] Resolved: FALSE
[17:44:50.019] Value: <not collected>
[17:44:50.019] Conditions captured: <none>
[17:44:50.019] Early signaling: FALSE
[17:44:50.019] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.019] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.030] Chunk #1 of 2 ... DONE
[17:44:50.030] Chunk #2 of 2 ...
[17:44:50.031]  - Finding globals in '...' for chunk #2 ...
[17:44:50.031] getGlobalsAndPackages() ...
[17:44:50.031] Searching for globals...
[17:44:50.031] 
[17:44:50.031] Searching for globals ... DONE
[17:44:50.031] - globals: [0] <none>
[17:44:50.032] getGlobalsAndPackages() ... DONE
[17:44:50.032]    + additional globals found: [n=0] 
[17:44:50.032]    + additional namespaces needed: [n=0] 
[17:44:50.032]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.032]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.032]  - seeds: <none>
[17:44:50.032]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.032] getGlobalsAndPackages() ...
[17:44:50.032] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.032] Resolving globals: FALSE
[17:44:50.033] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:50.033] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.067] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.067] 
[17:44:50.067] getGlobalsAndPackages() ... DONE
[17:44:50.068] run() for ‘Future’ ...
[17:44:50.068] - state: ‘created’
[17:44:50.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.082]   - Field: ‘node’
[17:44:50.082]   - Field: ‘label’
[17:44:50.082]   - Field: ‘local’
[17:44:50.082]   - Field: ‘owner’
[17:44:50.083]   - Field: ‘envir’
[17:44:50.083]   - Field: ‘workers’
[17:44:50.083]   - Field: ‘packages’
[17:44:50.083]   - Field: ‘gc’
[17:44:50.083]   - Field: ‘conditions’
[17:44:50.083]   - Field: ‘persistent’
[17:44:50.083]   - Field: ‘expr’
[17:44:50.083]   - Field: ‘uuid’
[17:44:50.083]   - Field: ‘seed’
[17:44:50.083]   - Field: ‘version’
[17:44:50.084]   - Field: ‘result’
[17:44:50.084]   - Field: ‘asynchronous’
[17:44:50.084]   - Field: ‘calls’
[17:44:50.084]   - Field: ‘globals’
[17:44:50.084]   - Field: ‘stdout’
[17:44:50.084]   - Field: ‘earlySignal’
[17:44:50.084]   - Field: ‘lazy’
[17:44:50.084]   - Field: ‘state’
[17:44:50.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.084] - Launch lazy future ...
[17:44:50.085] Packages needed by the future expression (n = 0): <none>
[17:44:50.085] Packages needed by future strategies (n = 0): <none>
[17:44:50.085] {
[17:44:50.085]     {
[17:44:50.085]         {
[17:44:50.085]             ...future.startTime <- base::Sys.time()
[17:44:50.085]             {
[17:44:50.085]                 {
[17:44:50.085]                   {
[17:44:50.085]                     {
[17:44:50.085]                       base::local({
[17:44:50.085]                         has_future <- base::requireNamespace("future", 
[17:44:50.085]                           quietly = TRUE)
[17:44:50.085]                         if (has_future) {
[17:44:50.085]                           ns <- base::getNamespace("future")
[17:44:50.085]                           version <- ns[[".package"]][["version"]]
[17:44:50.085]                           if (is.null(version)) 
[17:44:50.085]                             version <- utils::packageVersion("future")
[17:44:50.085]                         }
[17:44:50.085]                         else {
[17:44:50.085]                           version <- NULL
[17:44:50.085]                         }
[17:44:50.085]                         if (!has_future || version < "1.8.0") {
[17:44:50.085]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.085]                             "", base::R.version$version.string), 
[17:44:50.085]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.085]                               "release", "version")], collapse = " "), 
[17:44:50.085]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.085]                             info)
[17:44:50.085]                           info <- base::paste(info, collapse = "; ")
[17:44:50.085]                           if (!has_future) {
[17:44:50.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.085]                               info)
[17:44:50.085]                           }
[17:44:50.085]                           else {
[17:44:50.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.085]                               info, version)
[17:44:50.085]                           }
[17:44:50.085]                           base::stop(msg)
[17:44:50.085]                         }
[17:44:50.085]                       })
[17:44:50.085]                     }
[17:44:50.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.085]                     base::options(mc.cores = 1L)
[17:44:50.085]                   }
[17:44:50.085]                   ...future.strategy.old <- future::plan("list")
[17:44:50.085]                   options(future.plan = NULL)
[17:44:50.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.085]                 }
[17:44:50.085]                 ...future.workdir <- getwd()
[17:44:50.085]             }
[17:44:50.085]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.085]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.085]         }
[17:44:50.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.085]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.085]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.085]             base::names(...future.oldOptions))
[17:44:50.085]     }
[17:44:50.085]     if (FALSE) {
[17:44:50.085]     }
[17:44:50.085]     else {
[17:44:50.085]         if (TRUE) {
[17:44:50.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.085]                 open = "w")
[17:44:50.085]         }
[17:44:50.085]         else {
[17:44:50.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.085]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.085]         }
[17:44:50.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.085]             base::sink(type = "output", split = FALSE)
[17:44:50.085]             base::close(...future.stdout)
[17:44:50.085]         }, add = TRUE)
[17:44:50.085]     }
[17:44:50.085]     ...future.frame <- base::sys.nframe()
[17:44:50.085]     ...future.conditions <- base::list()
[17:44:50.085]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.085]     if (FALSE) {
[17:44:50.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.085]     }
[17:44:50.085]     ...future.result <- base::tryCatch({
[17:44:50.085]         base::withCallingHandlers({
[17:44:50.085]             ...future.value <- base::withVisible(base::local({
[17:44:50.085]                 ...future.makeSendCondition <- base::local({
[17:44:50.085]                   sendCondition <- NULL
[17:44:50.085]                   function(frame = 1L) {
[17:44:50.085]                     if (is.function(sendCondition)) 
[17:44:50.085]                       return(sendCondition)
[17:44:50.085]                     ns <- getNamespace("parallel")
[17:44:50.085]                     if (exists("sendData", mode = "function", 
[17:44:50.085]                       envir = ns)) {
[17:44:50.085]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.085]                         envir = ns)
[17:44:50.085]                       envir <- sys.frame(frame)
[17:44:50.085]                       master <- NULL
[17:44:50.085]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.085]                         !identical(envir, emptyenv())) {
[17:44:50.085]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.085]                           inherits = FALSE)) {
[17:44:50.085]                           master <- get("master", mode = "list", 
[17:44:50.085]                             envir = envir, inherits = FALSE)
[17:44:50.085]                           if (inherits(master, c("SOCKnode", 
[17:44:50.085]                             "SOCK0node"))) {
[17:44:50.085]                             sendCondition <<- function(cond) {
[17:44:50.085]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.085]                                 success = TRUE)
[17:44:50.085]                               parallel_sendData(master, data)
[17:44:50.085]                             }
[17:44:50.085]                             return(sendCondition)
[17:44:50.085]                           }
[17:44:50.085]                         }
[17:44:50.085]                         frame <- frame + 1L
[17:44:50.085]                         envir <- sys.frame(frame)
[17:44:50.085]                       }
[17:44:50.085]                     }
[17:44:50.085]                     sendCondition <<- function(cond) NULL
[17:44:50.085]                   }
[17:44:50.085]                 })
[17:44:50.085]                 withCallingHandlers({
[17:44:50.085]                   {
[17:44:50.085]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.085]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.085]                       ...future.globals.maxSize)) {
[17:44:50.085]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.085]                       on.exit(options(oopts), add = TRUE)
[17:44:50.085]                     }
[17:44:50.085]                     {
[17:44:50.085]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.085]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.085]                         USE.NAMES = FALSE)
[17:44:50.085]                       do.call(mapply, args = args)
[17:44:50.085]                     }
[17:44:50.085]                   }
[17:44:50.085]                 }, immediateCondition = function(cond) {
[17:44:50.085]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.085]                   sendCondition(cond)
[17:44:50.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.085]                   {
[17:44:50.085]                     inherits <- base::inherits
[17:44:50.085]                     invokeRestart <- base::invokeRestart
[17:44:50.085]                     is.null <- base::is.null
[17:44:50.085]                     muffled <- FALSE
[17:44:50.085]                     if (inherits(cond, "message")) {
[17:44:50.085]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.085]                       if (muffled) 
[17:44:50.085]                         invokeRestart("muffleMessage")
[17:44:50.085]                     }
[17:44:50.085]                     else if (inherits(cond, "warning")) {
[17:44:50.085]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.085]                       if (muffled) 
[17:44:50.085]                         invokeRestart("muffleWarning")
[17:44:50.085]                     }
[17:44:50.085]                     else if (inherits(cond, "condition")) {
[17:44:50.085]                       if (!is.null(pattern)) {
[17:44:50.085]                         computeRestarts <- base::computeRestarts
[17:44:50.085]                         grepl <- base::grepl
[17:44:50.085]                         restarts <- computeRestarts(cond)
[17:44:50.085]                         for (restart in restarts) {
[17:44:50.085]                           name <- restart$name
[17:44:50.085]                           if (is.null(name)) 
[17:44:50.085]                             next
[17:44:50.085]                           if (!grepl(pattern, name)) 
[17:44:50.085]                             next
[17:44:50.085]                           invokeRestart(restart)
[17:44:50.085]                           muffled <- TRUE
[17:44:50.085]                           break
[17:44:50.085]                         }
[17:44:50.085]                       }
[17:44:50.085]                     }
[17:44:50.085]                     invisible(muffled)
[17:44:50.085]                   }
[17:44:50.085]                   muffleCondition(cond)
[17:44:50.085]                 })
[17:44:50.085]             }))
[17:44:50.085]             future::FutureResult(value = ...future.value$value, 
[17:44:50.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.085]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.085]                     ...future.globalenv.names))
[17:44:50.085]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.085]         }, condition = base::local({
[17:44:50.085]             c <- base::c
[17:44:50.085]             inherits <- base::inherits
[17:44:50.085]             invokeRestart <- base::invokeRestart
[17:44:50.085]             length <- base::length
[17:44:50.085]             list <- base::list
[17:44:50.085]             seq.int <- base::seq.int
[17:44:50.085]             signalCondition <- base::signalCondition
[17:44:50.085]             sys.calls <- base::sys.calls
[17:44:50.085]             `[[` <- base::`[[`
[17:44:50.085]             `+` <- base::`+`
[17:44:50.085]             `<<-` <- base::`<<-`
[17:44:50.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.085]                   3L)]
[17:44:50.085]             }
[17:44:50.085]             function(cond) {
[17:44:50.085]                 is_error <- inherits(cond, "error")
[17:44:50.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.085]                   NULL)
[17:44:50.085]                 if (is_error) {
[17:44:50.085]                   sessionInformation <- function() {
[17:44:50.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.085]                       search = base::search(), system = base::Sys.info())
[17:44:50.085]                   }
[17:44:50.085]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.085]                     cond$call), session = sessionInformation(), 
[17:44:50.085]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.085]                   signalCondition(cond)
[17:44:50.085]                 }
[17:44:50.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.085]                 "immediateCondition"))) {
[17:44:50.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.085]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.085]                   if (TRUE && !signal) {
[17:44:50.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.085]                     {
[17:44:50.085]                       inherits <- base::inherits
[17:44:50.085]                       invokeRestart <- base::invokeRestart
[17:44:50.085]                       is.null <- base::is.null
[17:44:50.085]                       muffled <- FALSE
[17:44:50.085]                       if (inherits(cond, "message")) {
[17:44:50.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.085]                         if (muffled) 
[17:44:50.085]                           invokeRestart("muffleMessage")
[17:44:50.085]                       }
[17:44:50.085]                       else if (inherits(cond, "warning")) {
[17:44:50.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.085]                         if (muffled) 
[17:44:50.085]                           invokeRestart("muffleWarning")
[17:44:50.085]                       }
[17:44:50.085]                       else if (inherits(cond, "condition")) {
[17:44:50.085]                         if (!is.null(pattern)) {
[17:44:50.085]                           computeRestarts <- base::computeRestarts
[17:44:50.085]                           grepl <- base::grepl
[17:44:50.085]                           restarts <- computeRestarts(cond)
[17:44:50.085]                           for (restart in restarts) {
[17:44:50.085]                             name <- restart$name
[17:44:50.085]                             if (is.null(name)) 
[17:44:50.085]                               next
[17:44:50.085]                             if (!grepl(pattern, name)) 
[17:44:50.085]                               next
[17:44:50.085]                             invokeRestart(restart)
[17:44:50.085]                             muffled <- TRUE
[17:44:50.085]                             break
[17:44:50.085]                           }
[17:44:50.085]                         }
[17:44:50.085]                       }
[17:44:50.085]                       invisible(muffled)
[17:44:50.085]                     }
[17:44:50.085]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.085]                   }
[17:44:50.085]                 }
[17:44:50.085]                 else {
[17:44:50.085]                   if (TRUE) {
[17:44:50.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.085]                     {
[17:44:50.085]                       inherits <- base::inherits
[17:44:50.085]                       invokeRestart <- base::invokeRestart
[17:44:50.085]                       is.null <- base::is.null
[17:44:50.085]                       muffled <- FALSE
[17:44:50.085]                       if (inherits(cond, "message")) {
[17:44:50.085]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.085]                         if (muffled) 
[17:44:50.085]                           invokeRestart("muffleMessage")
[17:44:50.085]                       }
[17:44:50.085]                       else if (inherits(cond, "warning")) {
[17:44:50.085]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.085]                         if (muffled) 
[17:44:50.085]                           invokeRestart("muffleWarning")
[17:44:50.085]                       }
[17:44:50.085]                       else if (inherits(cond, "condition")) {
[17:44:50.085]                         if (!is.null(pattern)) {
[17:44:50.085]                           computeRestarts <- base::computeRestarts
[17:44:50.085]                           grepl <- base::grepl
[17:44:50.085]                           restarts <- computeRestarts(cond)
[17:44:50.085]                           for (restart in restarts) {
[17:44:50.085]                             name <- restart$name
[17:44:50.085]                             if (is.null(name)) 
[17:44:50.085]                               next
[17:44:50.085]                             if (!grepl(pattern, name)) 
[17:44:50.085]                               next
[17:44:50.085]                             invokeRestart(restart)
[17:44:50.085]                             muffled <- TRUE
[17:44:50.085]                             break
[17:44:50.085]                           }
[17:44:50.085]                         }
[17:44:50.085]                       }
[17:44:50.085]                       invisible(muffled)
[17:44:50.085]                     }
[17:44:50.085]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.085]                   }
[17:44:50.085]                 }
[17:44:50.085]             }
[17:44:50.085]         }))
[17:44:50.085]     }, error = function(ex) {
[17:44:50.085]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.085]                 ...future.rng), started = ...future.startTime, 
[17:44:50.085]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.085]             version = "1.8"), class = "FutureResult")
[17:44:50.085]     }, finally = {
[17:44:50.085]         if (!identical(...future.workdir, getwd())) 
[17:44:50.085]             setwd(...future.workdir)
[17:44:50.085]         {
[17:44:50.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.085]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.085]             }
[17:44:50.085]             base::options(...future.oldOptions)
[17:44:50.085]             if (.Platform$OS.type == "windows") {
[17:44:50.085]                 old_names <- names(...future.oldEnvVars)
[17:44:50.085]                 envs <- base::Sys.getenv()
[17:44:50.085]                 names <- names(envs)
[17:44:50.085]                 common <- intersect(names, old_names)
[17:44:50.085]                 added <- setdiff(names, old_names)
[17:44:50.085]                 removed <- setdiff(old_names, names)
[17:44:50.085]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.085]                   envs[common]]
[17:44:50.085]                 NAMES <- toupper(changed)
[17:44:50.085]                 args <- list()
[17:44:50.085]                 for (kk in seq_along(NAMES)) {
[17:44:50.085]                   name <- changed[[kk]]
[17:44:50.085]                   NAME <- NAMES[[kk]]
[17:44:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.085]                     next
[17:44:50.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.085]                 }
[17:44:50.085]                 NAMES <- toupper(added)
[17:44:50.085]                 for (kk in seq_along(NAMES)) {
[17:44:50.085]                   name <- added[[kk]]
[17:44:50.085]                   NAME <- NAMES[[kk]]
[17:44:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.085]                     next
[17:44:50.085]                   args[[name]] <- ""
[17:44:50.085]                 }
[17:44:50.085]                 NAMES <- toupper(removed)
[17:44:50.085]                 for (kk in seq_along(NAMES)) {
[17:44:50.085]                   name <- removed[[kk]]
[17:44:50.085]                   NAME <- NAMES[[kk]]
[17:44:50.085]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.085]                     next
[17:44:50.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.085]                 }
[17:44:50.085]                 if (length(args) > 0) 
[17:44:50.085]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.085]             }
[17:44:50.085]             else {
[17:44:50.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.085]             }
[17:44:50.085]             {
[17:44:50.085]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.085]                   0L) {
[17:44:50.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.085]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.085]                   base::options(opts)
[17:44:50.085]                 }
[17:44:50.085]                 {
[17:44:50.085]                   {
[17:44:50.085]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.085]                     NULL
[17:44:50.085]                   }
[17:44:50.085]                   options(future.plan = NULL)
[17:44:50.085]                   if (is.na(NA_character_)) 
[17:44:50.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.085]                     .init = FALSE)
[17:44:50.085]                 }
[17:44:50.085]             }
[17:44:50.085]         }
[17:44:50.085]     })
[17:44:50.085]     if (TRUE) {
[17:44:50.085]         base::sink(type = "output", split = FALSE)
[17:44:50.085]         if (TRUE) {
[17:44:50.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.085]         }
[17:44:50.085]         else {
[17:44:50.085]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.085]         }
[17:44:50.085]         base::close(...future.stdout)
[17:44:50.085]         ...future.stdout <- NULL
[17:44:50.085]     }
[17:44:50.085]     ...future.result$conditions <- ...future.conditions
[17:44:50.085]     ...future.result$finished <- base::Sys.time()
[17:44:50.085]     ...future.result
[17:44:50.085] }
[17:44:50.088] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:44:50.088] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:50.088] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:50.088] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.092] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.092] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:50.092] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:50.092] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.093] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.093] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.093] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.093] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:44:50.094] MultisessionFuture started
[17:44:50.094] - Launch lazy future ... done
[17:44:50.094] run() for ‘MultisessionFuture’ ... done
[17:44:50.094] Created future:
[17:44:50.094] MultisessionFuture:
[17:44:50.094] Label: ‘future_mapply-2’
[17:44:50.094] Expression:
[17:44:50.094] {
[17:44:50.094]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.094]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.094]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.094]         on.exit(options(oopts), add = TRUE)
[17:44:50.094]     }
[17:44:50.094]     {
[17:44:50.094]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.094]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.094]         do.call(mapply, args = args)
[17:44:50.094]     }
[17:44:50.094] }
[17:44:50.094] Lazy evaluation: FALSE
[17:44:50.094] Asynchronous evaluation: TRUE
[17:44:50.094] Local evaluation: TRUE
[17:44:50.094] Environment: R_GlobalEnv
[17:44:50.094] Capture standard output: TRUE
[17:44:50.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.094] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.094] Packages: <none>
[17:44:50.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.094] Resolved: FALSE
[17:44:50.094] Value: <not collected>
[17:44:50.094] Conditions captured: <none>
[17:44:50.094] Early signaling: FALSE
[17:44:50.094] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.094] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.106] Chunk #2 of 2 ... DONE
[17:44:50.106] Launching 2 futures (chunks) ... DONE
[17:44:50.106] Resolving 2 futures (chunks) ...
[17:44:50.106] resolve() on list ...
[17:44:50.106]  recursive: 0
[17:44:50.106]  length: 2
[17:44:50.106] 
[17:44:50.107] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.107] - Validating connection of MultisessionFuture
[17:44:50.107] - received message: FutureResult
[17:44:50.107] - Received FutureResult
[17:44:50.107] - Erased future from FutureRegistry
[17:44:50.107] result() for ClusterFuture ...
[17:44:50.107] - result already collected: FutureResult
[17:44:50.107] result() for ClusterFuture ... done
[17:44:50.108] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.108] Future #1
[17:44:50.108] result() for ClusterFuture ...
[17:44:50.108] - result already collected: FutureResult
[17:44:50.108] result() for ClusterFuture ... done
[17:44:50.108] result() for ClusterFuture ...
[17:44:50.108] - result already collected: FutureResult
[17:44:50.108] result() for ClusterFuture ... done
[17:44:50.108] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.108] - nx: 2
[17:44:50.108] - relay: TRUE
[17:44:50.108] - stdout: TRUE
[17:44:50.109] - signal: TRUE
[17:44:50.109] - resignal: FALSE
[17:44:50.109] - force: TRUE
[17:44:50.109] - relayed: [n=2] FALSE, FALSE
[17:44:50.109] - queued futures: [n=2] FALSE, FALSE
[17:44:50.109]  - until=1
[17:44:50.109]  - relaying element #1
[17:44:50.109] result() for ClusterFuture ...
[17:44:50.109] - result already collected: FutureResult
[17:44:50.109] result() for ClusterFuture ... done
[17:44:50.109] result() for ClusterFuture ...
[17:44:50.109] - result already collected: FutureResult
[17:44:50.110] result() for ClusterFuture ... done
[17:44:50.110] result() for ClusterFuture ...
[17:44:50.110] - result already collected: FutureResult
[17:44:50.110] result() for ClusterFuture ... done
[17:44:50.110] result() for ClusterFuture ...
[17:44:50.110] - result already collected: FutureResult
[17:44:50.110] result() for ClusterFuture ... done
[17:44:50.110] - relayed: [n=2] TRUE, FALSE
[17:44:50.110] - queued futures: [n=2] TRUE, FALSE
[17:44:50.110] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.110]  length: 1 (resolved future 1)
[17:44:50.137] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.137] - Validating connection of MultisessionFuture
[17:44:50.137] - received message: FutureResult
[17:44:50.137] - Received FutureResult
[17:44:50.137] - Erased future from FutureRegistry
[17:44:50.137] result() for ClusterFuture ...
[17:44:50.137] - result already collected: FutureResult
[17:44:50.138] result() for ClusterFuture ... done
[17:44:50.138] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.138] Future #2
[17:44:50.138] result() for ClusterFuture ...
[17:44:50.138] - result already collected: FutureResult
[17:44:50.138] result() for ClusterFuture ... done
[17:44:50.138] result() for ClusterFuture ...
[17:44:50.138] - result already collected: FutureResult
[17:44:50.138] result() for ClusterFuture ... done
[17:44:50.138] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.138] - nx: 2
[17:44:50.138] - relay: TRUE
[17:44:50.139] - stdout: TRUE
[17:44:50.139] - signal: TRUE
[17:44:50.139] - resignal: FALSE
[17:44:50.139] - force: TRUE
[17:44:50.139] - relayed: [n=2] TRUE, FALSE
[17:44:50.139] - queued futures: [n=2] TRUE, FALSE
[17:44:50.139]  - until=2
[17:44:50.139]  - relaying element #2
[17:44:50.139] result() for ClusterFuture ...
[17:44:50.139] - result already collected: FutureResult
[17:44:50.139] result() for ClusterFuture ... done
[17:44:50.139] result() for ClusterFuture ...
[17:44:50.140] - result already collected: FutureResult
[17:44:50.140] result() for ClusterFuture ... done
[17:44:50.140] result() for ClusterFuture ...
[17:44:50.140] - result already collected: FutureResult
[17:44:50.140] result() for ClusterFuture ... done
[17:44:50.140] result() for ClusterFuture ...
[17:44:50.140] - result already collected: FutureResult
[17:44:50.140] result() for ClusterFuture ... done
[17:44:50.140] - relayed: [n=2] TRUE, TRUE
[17:44:50.140] - queued futures: [n=2] TRUE, TRUE
[17:44:50.140] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.141]  length: 0 (resolved future 2)
[17:44:50.141] Relaying remaining futures
[17:44:50.141] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.141] - nx: 2
[17:44:50.141] - relay: TRUE
[17:44:50.141] - stdout: TRUE
[17:44:50.141] - signal: TRUE
[17:44:50.141] - resignal: FALSE
[17:44:50.141] - force: TRUE
[17:44:50.141] - relayed: [n=2] TRUE, TRUE
[17:44:50.141] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:50.141] - relayed: [n=2] TRUE, TRUE
[17:44:50.142] - queued futures: [n=2] TRUE, TRUE
[17:44:50.142] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.142] resolve() on list ... DONE
[17:44:50.142] result() for ClusterFuture ...
[17:44:50.142] - result already collected: FutureResult
[17:44:50.142] result() for ClusterFuture ... done
[17:44:50.142] result() for ClusterFuture ...
[17:44:50.142] - result already collected: FutureResult
[17:44:50.142] result() for ClusterFuture ... done
[17:44:50.142] result() for ClusterFuture ...
[17:44:50.142] - result already collected: FutureResult
[17:44:50.142] result() for ClusterFuture ... done
[17:44:50.143] result() for ClusterFuture ...
[17:44:50.143] - result already collected: FutureResult
[17:44:50.143] result() for ClusterFuture ... done
[17:44:50.143]  - Number of value chunks collected: 2
[17:44:50.143] Resolving 2 futures (chunks) ... DONE
[17:44:50.143] Reducing values from 2 chunks ...
[17:44:50.143]  - Number of values collected after concatenation: 4
[17:44:50.143]  - Number of values expected: 4
[17:44:50.143] Reducing values from 2 chunks ... DONE
[17:44:50.143] future_mapply() ... DONE
[17:44:50.144] future_mapply() ...
[17:44:50.147] Number of chunks: 2
[17:44:50.147] getGlobalsAndPackagesXApply() ...
[17:44:50.147]  - future.globals: TRUE
[17:44:50.148] getGlobalsAndPackages() ...
[17:44:50.148] Searching for globals...
[17:44:50.148] - globals found: [1] ‘FUN’
[17:44:50.148] Searching for globals ... DONE
[17:44:50.148] Resolving globals: FALSE
[17:44:50.149] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:50.149] The total size of the 1 globals exported for future expression (‘FUN(x = 42)’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:50.149] - globals: [1] ‘FUN’
[17:44:50.149] 
[17:44:50.149] getGlobalsAndPackages() ... DONE
[17:44:50.150]  - globals found/used: [n=1] ‘FUN’
[17:44:50.150]  - needed namespaces: [n=0] 
[17:44:50.150] Finding globals ... DONE
[17:44:50.150] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.150] List of 2
[17:44:50.150]  $ ...future.FUN:function (x, ...)  
[17:44:50.150]  $ MoreArgs     :List of 1
[17:44:50.150]   ..$ x: num 42
[17:44:50.150]  - attr(*, "where")=List of 2
[17:44:50.150]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.150]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.150]  - attr(*, "resolved")= logi FALSE
[17:44:50.150]  - attr(*, "total_size")= num NA
[17:44:50.153] Packages to be attached in all futures: [n=0] 
[17:44:50.153] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.153] Number of futures (= number of chunks): 2
[17:44:50.153] Launching 2 futures (chunks) ...
[17:44:50.153] Chunk #1 of 2 ...
[17:44:50.153]  - Finding globals in '...' for chunk #1 ...
[17:44:50.153] getGlobalsAndPackages() ...
[17:44:50.154] Searching for globals...
[17:44:50.154] 
[17:44:50.154] Searching for globals ... DONE
[17:44:50.154] - globals: [0] <none>
[17:44:50.154] getGlobalsAndPackages() ... DONE
[17:44:50.154]    + additional globals found: [n=0] 
[17:44:50.154]    + additional namespaces needed: [n=0] 
[17:44:50.154]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.155]  - seeds: <none>
[17:44:50.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.155] getGlobalsAndPackages() ...
[17:44:50.155] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.155] Resolving globals: FALSE
[17:44:50.155] The total size of the 5 globals is 224 bytes (224 bytes)
[17:44:50.156] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:50.156] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.156] 
[17:44:50.156] getGlobalsAndPackages() ... DONE
[17:44:50.157] run() for ‘Future’ ...
[17:44:50.157] - state: ‘created’
[17:44:50.157] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.171]   - Field: ‘node’
[17:44:50.171]   - Field: ‘label’
[17:44:50.171]   - Field: ‘local’
[17:44:50.171]   - Field: ‘owner’
[17:44:50.171]   - Field: ‘envir’
[17:44:50.171]   - Field: ‘workers’
[17:44:50.171]   - Field: ‘packages’
[17:44:50.171]   - Field: ‘gc’
[17:44:50.171]   - Field: ‘conditions’
[17:44:50.171]   - Field: ‘persistent’
[17:44:50.172]   - Field: ‘expr’
[17:44:50.172]   - Field: ‘uuid’
[17:44:50.172]   - Field: ‘seed’
[17:44:50.172]   - Field: ‘version’
[17:44:50.172]   - Field: ‘result’
[17:44:50.172]   - Field: ‘asynchronous’
[17:44:50.172]   - Field: ‘calls’
[17:44:50.172]   - Field: ‘globals’
[17:44:50.172]   - Field: ‘stdout’
[17:44:50.172]   - Field: ‘earlySignal’
[17:44:50.172]   - Field: ‘lazy’
[17:44:50.172]   - Field: ‘state’
[17:44:50.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.173] - Launch lazy future ...
[17:44:50.173] Packages needed by the future expression (n = 0): <none>
[17:44:50.173] Packages needed by future strategies (n = 0): <none>
[17:44:50.173] {
[17:44:50.173]     {
[17:44:50.173]         {
[17:44:50.173]             ...future.startTime <- base::Sys.time()
[17:44:50.173]             {
[17:44:50.173]                 {
[17:44:50.173]                   {
[17:44:50.173]                     {
[17:44:50.173]                       base::local({
[17:44:50.173]                         has_future <- base::requireNamespace("future", 
[17:44:50.173]                           quietly = TRUE)
[17:44:50.173]                         if (has_future) {
[17:44:50.173]                           ns <- base::getNamespace("future")
[17:44:50.173]                           version <- ns[[".package"]][["version"]]
[17:44:50.173]                           if (is.null(version)) 
[17:44:50.173]                             version <- utils::packageVersion("future")
[17:44:50.173]                         }
[17:44:50.173]                         else {
[17:44:50.173]                           version <- NULL
[17:44:50.173]                         }
[17:44:50.173]                         if (!has_future || version < "1.8.0") {
[17:44:50.173]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.173]                             "", base::R.version$version.string), 
[17:44:50.173]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.173]                               "release", "version")], collapse = " "), 
[17:44:50.173]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.173]                             info)
[17:44:50.173]                           info <- base::paste(info, collapse = "; ")
[17:44:50.173]                           if (!has_future) {
[17:44:50.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.173]                               info)
[17:44:50.173]                           }
[17:44:50.173]                           else {
[17:44:50.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.173]                               info, version)
[17:44:50.173]                           }
[17:44:50.173]                           base::stop(msg)
[17:44:50.173]                         }
[17:44:50.173]                       })
[17:44:50.173]                     }
[17:44:50.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.173]                     base::options(mc.cores = 1L)
[17:44:50.173]                   }
[17:44:50.173]                   ...future.strategy.old <- future::plan("list")
[17:44:50.173]                   options(future.plan = NULL)
[17:44:50.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.173]                 }
[17:44:50.173]                 ...future.workdir <- getwd()
[17:44:50.173]             }
[17:44:50.173]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.173]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.173]         }
[17:44:50.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.173]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.173]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.173]             base::names(...future.oldOptions))
[17:44:50.173]     }
[17:44:50.173]     if (FALSE) {
[17:44:50.173]     }
[17:44:50.173]     else {
[17:44:50.173]         if (TRUE) {
[17:44:50.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.173]                 open = "w")
[17:44:50.173]         }
[17:44:50.173]         else {
[17:44:50.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.173]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.173]         }
[17:44:50.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.173]             base::sink(type = "output", split = FALSE)
[17:44:50.173]             base::close(...future.stdout)
[17:44:50.173]         }, add = TRUE)
[17:44:50.173]     }
[17:44:50.173]     ...future.frame <- base::sys.nframe()
[17:44:50.173]     ...future.conditions <- base::list()
[17:44:50.173]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.173]     if (FALSE) {
[17:44:50.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.173]     }
[17:44:50.173]     ...future.result <- base::tryCatch({
[17:44:50.173]         base::withCallingHandlers({
[17:44:50.173]             ...future.value <- base::withVisible(base::local({
[17:44:50.173]                 ...future.makeSendCondition <- base::local({
[17:44:50.173]                   sendCondition <- NULL
[17:44:50.173]                   function(frame = 1L) {
[17:44:50.173]                     if (is.function(sendCondition)) 
[17:44:50.173]                       return(sendCondition)
[17:44:50.173]                     ns <- getNamespace("parallel")
[17:44:50.173]                     if (exists("sendData", mode = "function", 
[17:44:50.173]                       envir = ns)) {
[17:44:50.173]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.173]                         envir = ns)
[17:44:50.173]                       envir <- sys.frame(frame)
[17:44:50.173]                       master <- NULL
[17:44:50.173]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.173]                         !identical(envir, emptyenv())) {
[17:44:50.173]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.173]                           inherits = FALSE)) {
[17:44:50.173]                           master <- get("master", mode = "list", 
[17:44:50.173]                             envir = envir, inherits = FALSE)
[17:44:50.173]                           if (inherits(master, c("SOCKnode", 
[17:44:50.173]                             "SOCK0node"))) {
[17:44:50.173]                             sendCondition <<- function(cond) {
[17:44:50.173]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.173]                                 success = TRUE)
[17:44:50.173]                               parallel_sendData(master, data)
[17:44:50.173]                             }
[17:44:50.173]                             return(sendCondition)
[17:44:50.173]                           }
[17:44:50.173]                         }
[17:44:50.173]                         frame <- frame + 1L
[17:44:50.173]                         envir <- sys.frame(frame)
[17:44:50.173]                       }
[17:44:50.173]                     }
[17:44:50.173]                     sendCondition <<- function(cond) NULL
[17:44:50.173]                   }
[17:44:50.173]                 })
[17:44:50.173]                 withCallingHandlers({
[17:44:50.173]                   {
[17:44:50.173]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.173]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.173]                       ...future.globals.maxSize)) {
[17:44:50.173]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.173]                       on.exit(options(oopts), add = TRUE)
[17:44:50.173]                     }
[17:44:50.173]                     {
[17:44:50.173]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.173]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.173]                         USE.NAMES = FALSE)
[17:44:50.173]                       do.call(mapply, args = args)
[17:44:50.173]                     }
[17:44:50.173]                   }
[17:44:50.173]                 }, immediateCondition = function(cond) {
[17:44:50.173]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.173]                   sendCondition(cond)
[17:44:50.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.173]                   {
[17:44:50.173]                     inherits <- base::inherits
[17:44:50.173]                     invokeRestart <- base::invokeRestart
[17:44:50.173]                     is.null <- base::is.null
[17:44:50.173]                     muffled <- FALSE
[17:44:50.173]                     if (inherits(cond, "message")) {
[17:44:50.173]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.173]                       if (muffled) 
[17:44:50.173]                         invokeRestart("muffleMessage")
[17:44:50.173]                     }
[17:44:50.173]                     else if (inherits(cond, "warning")) {
[17:44:50.173]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.173]                       if (muffled) 
[17:44:50.173]                         invokeRestart("muffleWarning")
[17:44:50.173]                     }
[17:44:50.173]                     else if (inherits(cond, "condition")) {
[17:44:50.173]                       if (!is.null(pattern)) {
[17:44:50.173]                         computeRestarts <- base::computeRestarts
[17:44:50.173]                         grepl <- base::grepl
[17:44:50.173]                         restarts <- computeRestarts(cond)
[17:44:50.173]                         for (restart in restarts) {
[17:44:50.173]                           name <- restart$name
[17:44:50.173]                           if (is.null(name)) 
[17:44:50.173]                             next
[17:44:50.173]                           if (!grepl(pattern, name)) 
[17:44:50.173]                             next
[17:44:50.173]                           invokeRestart(restart)
[17:44:50.173]                           muffled <- TRUE
[17:44:50.173]                           break
[17:44:50.173]                         }
[17:44:50.173]                       }
[17:44:50.173]                     }
[17:44:50.173]                     invisible(muffled)
[17:44:50.173]                   }
[17:44:50.173]                   muffleCondition(cond)
[17:44:50.173]                 })
[17:44:50.173]             }))
[17:44:50.173]             future::FutureResult(value = ...future.value$value, 
[17:44:50.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.173]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.173]                     ...future.globalenv.names))
[17:44:50.173]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.173]         }, condition = base::local({
[17:44:50.173]             c <- base::c
[17:44:50.173]             inherits <- base::inherits
[17:44:50.173]             invokeRestart <- base::invokeRestart
[17:44:50.173]             length <- base::length
[17:44:50.173]             list <- base::list
[17:44:50.173]             seq.int <- base::seq.int
[17:44:50.173]             signalCondition <- base::signalCondition
[17:44:50.173]             sys.calls <- base::sys.calls
[17:44:50.173]             `[[` <- base::`[[`
[17:44:50.173]             `+` <- base::`+`
[17:44:50.173]             `<<-` <- base::`<<-`
[17:44:50.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.173]                   3L)]
[17:44:50.173]             }
[17:44:50.173]             function(cond) {
[17:44:50.173]                 is_error <- inherits(cond, "error")
[17:44:50.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.173]                   NULL)
[17:44:50.173]                 if (is_error) {
[17:44:50.173]                   sessionInformation <- function() {
[17:44:50.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.173]                       search = base::search(), system = base::Sys.info())
[17:44:50.173]                   }
[17:44:50.173]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.173]                     cond$call), session = sessionInformation(), 
[17:44:50.173]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.173]                   signalCondition(cond)
[17:44:50.173]                 }
[17:44:50.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.173]                 "immediateCondition"))) {
[17:44:50.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.173]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.173]                   if (TRUE && !signal) {
[17:44:50.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.173]                     {
[17:44:50.173]                       inherits <- base::inherits
[17:44:50.173]                       invokeRestart <- base::invokeRestart
[17:44:50.173]                       is.null <- base::is.null
[17:44:50.173]                       muffled <- FALSE
[17:44:50.173]                       if (inherits(cond, "message")) {
[17:44:50.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.173]                         if (muffled) 
[17:44:50.173]                           invokeRestart("muffleMessage")
[17:44:50.173]                       }
[17:44:50.173]                       else if (inherits(cond, "warning")) {
[17:44:50.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.173]                         if (muffled) 
[17:44:50.173]                           invokeRestart("muffleWarning")
[17:44:50.173]                       }
[17:44:50.173]                       else if (inherits(cond, "condition")) {
[17:44:50.173]                         if (!is.null(pattern)) {
[17:44:50.173]                           computeRestarts <- base::computeRestarts
[17:44:50.173]                           grepl <- base::grepl
[17:44:50.173]                           restarts <- computeRestarts(cond)
[17:44:50.173]                           for (restart in restarts) {
[17:44:50.173]                             name <- restart$name
[17:44:50.173]                             if (is.null(name)) 
[17:44:50.173]                               next
[17:44:50.173]                             if (!grepl(pattern, name)) 
[17:44:50.173]                               next
[17:44:50.173]                             invokeRestart(restart)
[17:44:50.173]                             muffled <- TRUE
[17:44:50.173]                             break
[17:44:50.173]                           }
[17:44:50.173]                         }
[17:44:50.173]                       }
[17:44:50.173]                       invisible(muffled)
[17:44:50.173]                     }
[17:44:50.173]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.173]                   }
[17:44:50.173]                 }
[17:44:50.173]                 else {
[17:44:50.173]                   if (TRUE) {
[17:44:50.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.173]                     {
[17:44:50.173]                       inherits <- base::inherits
[17:44:50.173]                       invokeRestart <- base::invokeRestart
[17:44:50.173]                       is.null <- base::is.null
[17:44:50.173]                       muffled <- FALSE
[17:44:50.173]                       if (inherits(cond, "message")) {
[17:44:50.173]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.173]                         if (muffled) 
[17:44:50.173]                           invokeRestart("muffleMessage")
[17:44:50.173]                       }
[17:44:50.173]                       else if (inherits(cond, "warning")) {
[17:44:50.173]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.173]                         if (muffled) 
[17:44:50.173]                           invokeRestart("muffleWarning")
[17:44:50.173]                       }
[17:44:50.173]                       else if (inherits(cond, "condition")) {
[17:44:50.173]                         if (!is.null(pattern)) {
[17:44:50.173]                           computeRestarts <- base::computeRestarts
[17:44:50.173]                           grepl <- base::grepl
[17:44:50.173]                           restarts <- computeRestarts(cond)
[17:44:50.173]                           for (restart in restarts) {
[17:44:50.173]                             name <- restart$name
[17:44:50.173]                             if (is.null(name)) 
[17:44:50.173]                               next
[17:44:50.173]                             if (!grepl(pattern, name)) 
[17:44:50.173]                               next
[17:44:50.173]                             invokeRestart(restart)
[17:44:50.173]                             muffled <- TRUE
[17:44:50.173]                             break
[17:44:50.173]                           }
[17:44:50.173]                         }
[17:44:50.173]                       }
[17:44:50.173]                       invisible(muffled)
[17:44:50.173]                     }
[17:44:50.173]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.173]                   }
[17:44:50.173]                 }
[17:44:50.173]             }
[17:44:50.173]         }))
[17:44:50.173]     }, error = function(ex) {
[17:44:50.173]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.173]                 ...future.rng), started = ...future.startTime, 
[17:44:50.173]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.173]             version = "1.8"), class = "FutureResult")
[17:44:50.173]     }, finally = {
[17:44:50.173]         if (!identical(...future.workdir, getwd())) 
[17:44:50.173]             setwd(...future.workdir)
[17:44:50.173]         {
[17:44:50.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.173]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.173]             }
[17:44:50.173]             base::options(...future.oldOptions)
[17:44:50.173]             if (.Platform$OS.type == "windows") {
[17:44:50.173]                 old_names <- names(...future.oldEnvVars)
[17:44:50.173]                 envs <- base::Sys.getenv()
[17:44:50.173]                 names <- names(envs)
[17:44:50.173]                 common <- intersect(names, old_names)
[17:44:50.173]                 added <- setdiff(names, old_names)
[17:44:50.173]                 removed <- setdiff(old_names, names)
[17:44:50.173]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.173]                   envs[common]]
[17:44:50.173]                 NAMES <- toupper(changed)
[17:44:50.173]                 args <- list()
[17:44:50.173]                 for (kk in seq_along(NAMES)) {
[17:44:50.173]                   name <- changed[[kk]]
[17:44:50.173]                   NAME <- NAMES[[kk]]
[17:44:50.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.173]                     next
[17:44:50.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.173]                 }
[17:44:50.173]                 NAMES <- toupper(added)
[17:44:50.173]                 for (kk in seq_along(NAMES)) {
[17:44:50.173]                   name <- added[[kk]]
[17:44:50.173]                   NAME <- NAMES[[kk]]
[17:44:50.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.173]                     next
[17:44:50.173]                   args[[name]] <- ""
[17:44:50.173]                 }
[17:44:50.173]                 NAMES <- toupper(removed)
[17:44:50.173]                 for (kk in seq_along(NAMES)) {
[17:44:50.173]                   name <- removed[[kk]]
[17:44:50.173]                   NAME <- NAMES[[kk]]
[17:44:50.173]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.173]                     next
[17:44:50.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.173]                 }
[17:44:50.173]                 if (length(args) > 0) 
[17:44:50.173]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.173]             }
[17:44:50.173]             else {
[17:44:50.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.173]             }
[17:44:50.173]             {
[17:44:50.173]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.173]                   0L) {
[17:44:50.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.173]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.173]                   base::options(opts)
[17:44:50.173]                 }
[17:44:50.173]                 {
[17:44:50.173]                   {
[17:44:50.173]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.173]                     NULL
[17:44:50.173]                   }
[17:44:50.173]                   options(future.plan = NULL)
[17:44:50.173]                   if (is.na(NA_character_)) 
[17:44:50.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.173]                     .init = FALSE)
[17:44:50.173]                 }
[17:44:50.173]             }
[17:44:50.173]         }
[17:44:50.173]     })
[17:44:50.173]     if (TRUE) {
[17:44:50.173]         base::sink(type = "output", split = FALSE)
[17:44:50.173]         if (TRUE) {
[17:44:50.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.173]         }
[17:44:50.173]         else {
[17:44:50.173]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.173]         }
[17:44:50.173]         base::close(...future.stdout)
[17:44:50.173]         ...future.stdout <- NULL
[17:44:50.173]     }
[17:44:50.173]     ...future.result$conditions <- ...future.conditions
[17:44:50.173]     ...future.result$finished <- base::Sys.time()
[17:44:50.173]     ...future.result
[17:44:50.173] }
[17:44:50.176] Exporting 5 global objects (224 bytes) to cluster node #1 ...
[17:44:50.176] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:50.177] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:50.177] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:44:50.177] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:44:50.177] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:44:50.177] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:44:50.178] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.178] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.178] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.178] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.178] Exporting 5 global objects (224 bytes) to cluster node #1 ... DONE
[17:44:50.179] MultisessionFuture started
[17:44:50.179] - Launch lazy future ... done
[17:44:50.179] run() for ‘MultisessionFuture’ ... done
[17:44:50.179] Created future:
[17:44:50.179] MultisessionFuture:
[17:44:50.179] Label: ‘future_mapply-1’
[17:44:50.179] Expression:
[17:44:50.179] {
[17:44:50.179]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.179]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.179]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.179]         on.exit(options(oopts), add = TRUE)
[17:44:50.179]     }
[17:44:50.179]     {
[17:44:50.179]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.179]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.179]         do.call(mapply, args = args)
[17:44:50.179]     }
[17:44:50.179] }
[17:44:50.179] Lazy evaluation: FALSE
[17:44:50.179] Asynchronous evaluation: TRUE
[17:44:50.179] Local evaluation: TRUE
[17:44:50.179] Environment: R_GlobalEnv
[17:44:50.179] Capture standard output: TRUE
[17:44:50.179] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.179] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.179] Packages: <none>
[17:44:50.179] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.179] Resolved: FALSE
[17:44:50.179] Value: <not collected>
[17:44:50.179] Conditions captured: <none>
[17:44:50.179] Early signaling: FALSE
[17:44:50.179] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.179] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.191] Chunk #1 of 2 ... DONE
[17:44:50.191] Chunk #2 of 2 ...
[17:44:50.191]  - Finding globals in '...' for chunk #2 ...
[17:44:50.191] getGlobalsAndPackages() ...
[17:44:50.191] Searching for globals...
[17:44:50.191] 
[17:44:50.191] Searching for globals ... DONE
[17:44:50.191] - globals: [0] <none>
[17:44:50.192] getGlobalsAndPackages() ... DONE
[17:44:50.192]    + additional globals found: [n=0] 
[17:44:50.192]    + additional namespaces needed: [n=0] 
[17:44:50.192]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.192]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.192]  - seeds: <none>
[17:44:50.192]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.192] getGlobalsAndPackages() ...
[17:44:50.192] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.192] Resolving globals: FALSE
[17:44:50.193] The total size of the 5 globals is 224 bytes (224 bytes)
[17:44:50.193] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 224 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:50.193] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.193] 
[17:44:50.194] getGlobalsAndPackages() ... DONE
[17:44:50.194] run() for ‘Future’ ...
[17:44:50.194] - state: ‘created’
[17:44:50.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.208]   - Field: ‘node’
[17:44:50.208]   - Field: ‘label’
[17:44:50.208]   - Field: ‘local’
[17:44:50.208]   - Field: ‘owner’
[17:44:50.208]   - Field: ‘envir’
[17:44:50.208]   - Field: ‘workers’
[17:44:50.208]   - Field: ‘packages’
[17:44:50.208]   - Field: ‘gc’
[17:44:50.208]   - Field: ‘conditions’
[17:44:50.209]   - Field: ‘persistent’
[17:44:50.209]   - Field: ‘expr’
[17:44:50.209]   - Field: ‘uuid’
[17:44:50.209]   - Field: ‘seed’
[17:44:50.209]   - Field: ‘version’
[17:44:50.209]   - Field: ‘result’
[17:44:50.209]   - Field: ‘asynchronous’
[17:44:50.209]   - Field: ‘calls’
[17:44:50.209]   - Field: ‘globals’
[17:44:50.209]   - Field: ‘stdout’
[17:44:50.209]   - Field: ‘earlySignal’
[17:44:50.210]   - Field: ‘lazy’
[17:44:50.210]   - Field: ‘state’
[17:44:50.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.210] - Launch lazy future ...
[17:44:50.210] Packages needed by the future expression (n = 0): <none>
[17:44:50.210] Packages needed by future strategies (n = 0): <none>
[17:44:50.211] {
[17:44:50.211]     {
[17:44:50.211]         {
[17:44:50.211]             ...future.startTime <- base::Sys.time()
[17:44:50.211]             {
[17:44:50.211]                 {
[17:44:50.211]                   {
[17:44:50.211]                     {
[17:44:50.211]                       base::local({
[17:44:50.211]                         has_future <- base::requireNamespace("future", 
[17:44:50.211]                           quietly = TRUE)
[17:44:50.211]                         if (has_future) {
[17:44:50.211]                           ns <- base::getNamespace("future")
[17:44:50.211]                           version <- ns[[".package"]][["version"]]
[17:44:50.211]                           if (is.null(version)) 
[17:44:50.211]                             version <- utils::packageVersion("future")
[17:44:50.211]                         }
[17:44:50.211]                         else {
[17:44:50.211]                           version <- NULL
[17:44:50.211]                         }
[17:44:50.211]                         if (!has_future || version < "1.8.0") {
[17:44:50.211]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.211]                             "", base::R.version$version.string), 
[17:44:50.211]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.211]                               "release", "version")], collapse = " "), 
[17:44:50.211]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.211]                             info)
[17:44:50.211]                           info <- base::paste(info, collapse = "; ")
[17:44:50.211]                           if (!has_future) {
[17:44:50.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.211]                               info)
[17:44:50.211]                           }
[17:44:50.211]                           else {
[17:44:50.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.211]                               info, version)
[17:44:50.211]                           }
[17:44:50.211]                           base::stop(msg)
[17:44:50.211]                         }
[17:44:50.211]                       })
[17:44:50.211]                     }
[17:44:50.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.211]                     base::options(mc.cores = 1L)
[17:44:50.211]                   }
[17:44:50.211]                   ...future.strategy.old <- future::plan("list")
[17:44:50.211]                   options(future.plan = NULL)
[17:44:50.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.211]                 }
[17:44:50.211]                 ...future.workdir <- getwd()
[17:44:50.211]             }
[17:44:50.211]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.211]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.211]         }
[17:44:50.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.211]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.211]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.211]             base::names(...future.oldOptions))
[17:44:50.211]     }
[17:44:50.211]     if (FALSE) {
[17:44:50.211]     }
[17:44:50.211]     else {
[17:44:50.211]         if (TRUE) {
[17:44:50.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.211]                 open = "w")
[17:44:50.211]         }
[17:44:50.211]         else {
[17:44:50.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.211]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.211]         }
[17:44:50.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.211]             base::sink(type = "output", split = FALSE)
[17:44:50.211]             base::close(...future.stdout)
[17:44:50.211]         }, add = TRUE)
[17:44:50.211]     }
[17:44:50.211]     ...future.frame <- base::sys.nframe()
[17:44:50.211]     ...future.conditions <- base::list()
[17:44:50.211]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.211]     if (FALSE) {
[17:44:50.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.211]     }
[17:44:50.211]     ...future.result <- base::tryCatch({
[17:44:50.211]         base::withCallingHandlers({
[17:44:50.211]             ...future.value <- base::withVisible(base::local({
[17:44:50.211]                 ...future.makeSendCondition <- base::local({
[17:44:50.211]                   sendCondition <- NULL
[17:44:50.211]                   function(frame = 1L) {
[17:44:50.211]                     if (is.function(sendCondition)) 
[17:44:50.211]                       return(sendCondition)
[17:44:50.211]                     ns <- getNamespace("parallel")
[17:44:50.211]                     if (exists("sendData", mode = "function", 
[17:44:50.211]                       envir = ns)) {
[17:44:50.211]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.211]                         envir = ns)
[17:44:50.211]                       envir <- sys.frame(frame)
[17:44:50.211]                       master <- NULL
[17:44:50.211]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.211]                         !identical(envir, emptyenv())) {
[17:44:50.211]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.211]                           inherits = FALSE)) {
[17:44:50.211]                           master <- get("master", mode = "list", 
[17:44:50.211]                             envir = envir, inherits = FALSE)
[17:44:50.211]                           if (inherits(master, c("SOCKnode", 
[17:44:50.211]                             "SOCK0node"))) {
[17:44:50.211]                             sendCondition <<- function(cond) {
[17:44:50.211]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.211]                                 success = TRUE)
[17:44:50.211]                               parallel_sendData(master, data)
[17:44:50.211]                             }
[17:44:50.211]                             return(sendCondition)
[17:44:50.211]                           }
[17:44:50.211]                         }
[17:44:50.211]                         frame <- frame + 1L
[17:44:50.211]                         envir <- sys.frame(frame)
[17:44:50.211]                       }
[17:44:50.211]                     }
[17:44:50.211]                     sendCondition <<- function(cond) NULL
[17:44:50.211]                   }
[17:44:50.211]                 })
[17:44:50.211]                 withCallingHandlers({
[17:44:50.211]                   {
[17:44:50.211]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.211]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.211]                       ...future.globals.maxSize)) {
[17:44:50.211]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.211]                       on.exit(options(oopts), add = TRUE)
[17:44:50.211]                     }
[17:44:50.211]                     {
[17:44:50.211]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.211]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.211]                         USE.NAMES = FALSE)
[17:44:50.211]                       do.call(mapply, args = args)
[17:44:50.211]                     }
[17:44:50.211]                   }
[17:44:50.211]                 }, immediateCondition = function(cond) {
[17:44:50.211]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.211]                   sendCondition(cond)
[17:44:50.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.211]                   {
[17:44:50.211]                     inherits <- base::inherits
[17:44:50.211]                     invokeRestart <- base::invokeRestart
[17:44:50.211]                     is.null <- base::is.null
[17:44:50.211]                     muffled <- FALSE
[17:44:50.211]                     if (inherits(cond, "message")) {
[17:44:50.211]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.211]                       if (muffled) 
[17:44:50.211]                         invokeRestart("muffleMessage")
[17:44:50.211]                     }
[17:44:50.211]                     else if (inherits(cond, "warning")) {
[17:44:50.211]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.211]                       if (muffled) 
[17:44:50.211]                         invokeRestart("muffleWarning")
[17:44:50.211]                     }
[17:44:50.211]                     else if (inherits(cond, "condition")) {
[17:44:50.211]                       if (!is.null(pattern)) {
[17:44:50.211]                         computeRestarts <- base::computeRestarts
[17:44:50.211]                         grepl <- base::grepl
[17:44:50.211]                         restarts <- computeRestarts(cond)
[17:44:50.211]                         for (restart in restarts) {
[17:44:50.211]                           name <- restart$name
[17:44:50.211]                           if (is.null(name)) 
[17:44:50.211]                             next
[17:44:50.211]                           if (!grepl(pattern, name)) 
[17:44:50.211]                             next
[17:44:50.211]                           invokeRestart(restart)
[17:44:50.211]                           muffled <- TRUE
[17:44:50.211]                           break
[17:44:50.211]                         }
[17:44:50.211]                       }
[17:44:50.211]                     }
[17:44:50.211]                     invisible(muffled)
[17:44:50.211]                   }
[17:44:50.211]                   muffleCondition(cond)
[17:44:50.211]                 })
[17:44:50.211]             }))
[17:44:50.211]             future::FutureResult(value = ...future.value$value, 
[17:44:50.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.211]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.211]                     ...future.globalenv.names))
[17:44:50.211]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.211]         }, condition = base::local({
[17:44:50.211]             c <- base::c
[17:44:50.211]             inherits <- base::inherits
[17:44:50.211]             invokeRestart <- base::invokeRestart
[17:44:50.211]             length <- base::length
[17:44:50.211]             list <- base::list
[17:44:50.211]             seq.int <- base::seq.int
[17:44:50.211]             signalCondition <- base::signalCondition
[17:44:50.211]             sys.calls <- base::sys.calls
[17:44:50.211]             `[[` <- base::`[[`
[17:44:50.211]             `+` <- base::`+`
[17:44:50.211]             `<<-` <- base::`<<-`
[17:44:50.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.211]                   3L)]
[17:44:50.211]             }
[17:44:50.211]             function(cond) {
[17:44:50.211]                 is_error <- inherits(cond, "error")
[17:44:50.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.211]                   NULL)
[17:44:50.211]                 if (is_error) {
[17:44:50.211]                   sessionInformation <- function() {
[17:44:50.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.211]                       search = base::search(), system = base::Sys.info())
[17:44:50.211]                   }
[17:44:50.211]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.211]                     cond$call), session = sessionInformation(), 
[17:44:50.211]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.211]                   signalCondition(cond)
[17:44:50.211]                 }
[17:44:50.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.211]                 "immediateCondition"))) {
[17:44:50.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.211]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.211]                   if (TRUE && !signal) {
[17:44:50.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.211]                     {
[17:44:50.211]                       inherits <- base::inherits
[17:44:50.211]                       invokeRestart <- base::invokeRestart
[17:44:50.211]                       is.null <- base::is.null
[17:44:50.211]                       muffled <- FALSE
[17:44:50.211]                       if (inherits(cond, "message")) {
[17:44:50.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.211]                         if (muffled) 
[17:44:50.211]                           invokeRestart("muffleMessage")
[17:44:50.211]                       }
[17:44:50.211]                       else if (inherits(cond, "warning")) {
[17:44:50.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.211]                         if (muffled) 
[17:44:50.211]                           invokeRestart("muffleWarning")
[17:44:50.211]                       }
[17:44:50.211]                       else if (inherits(cond, "condition")) {
[17:44:50.211]                         if (!is.null(pattern)) {
[17:44:50.211]                           computeRestarts <- base::computeRestarts
[17:44:50.211]                           grepl <- base::grepl
[17:44:50.211]                           restarts <- computeRestarts(cond)
[17:44:50.211]                           for (restart in restarts) {
[17:44:50.211]                             name <- restart$name
[17:44:50.211]                             if (is.null(name)) 
[17:44:50.211]                               next
[17:44:50.211]                             if (!grepl(pattern, name)) 
[17:44:50.211]                               next
[17:44:50.211]                             invokeRestart(restart)
[17:44:50.211]                             muffled <- TRUE
[17:44:50.211]                             break
[17:44:50.211]                           }
[17:44:50.211]                         }
[17:44:50.211]                       }
[17:44:50.211]                       invisible(muffled)
[17:44:50.211]                     }
[17:44:50.211]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.211]                   }
[17:44:50.211]                 }
[17:44:50.211]                 else {
[17:44:50.211]                   if (TRUE) {
[17:44:50.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.211]                     {
[17:44:50.211]                       inherits <- base::inherits
[17:44:50.211]                       invokeRestart <- base::invokeRestart
[17:44:50.211]                       is.null <- base::is.null
[17:44:50.211]                       muffled <- FALSE
[17:44:50.211]                       if (inherits(cond, "message")) {
[17:44:50.211]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.211]                         if (muffled) 
[17:44:50.211]                           invokeRestart("muffleMessage")
[17:44:50.211]                       }
[17:44:50.211]                       else if (inherits(cond, "warning")) {
[17:44:50.211]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.211]                         if (muffled) 
[17:44:50.211]                           invokeRestart("muffleWarning")
[17:44:50.211]                       }
[17:44:50.211]                       else if (inherits(cond, "condition")) {
[17:44:50.211]                         if (!is.null(pattern)) {
[17:44:50.211]                           computeRestarts <- base::computeRestarts
[17:44:50.211]                           grepl <- base::grepl
[17:44:50.211]                           restarts <- computeRestarts(cond)
[17:44:50.211]                           for (restart in restarts) {
[17:44:50.211]                             name <- restart$name
[17:44:50.211]                             if (is.null(name)) 
[17:44:50.211]                               next
[17:44:50.211]                             if (!grepl(pattern, name)) 
[17:44:50.211]                               next
[17:44:50.211]                             invokeRestart(restart)
[17:44:50.211]                             muffled <- TRUE
[17:44:50.211]                             break
[17:44:50.211]                           }
[17:44:50.211]                         }
[17:44:50.211]                       }
[17:44:50.211]                       invisible(muffled)
[17:44:50.211]                     }
[17:44:50.211]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.211]                   }
[17:44:50.211]                 }
[17:44:50.211]             }
[17:44:50.211]         }))
[17:44:50.211]     }, error = function(ex) {
[17:44:50.211]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.211]                 ...future.rng), started = ...future.startTime, 
[17:44:50.211]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.211]             version = "1.8"), class = "FutureResult")
[17:44:50.211]     }, finally = {
[17:44:50.211]         if (!identical(...future.workdir, getwd())) 
[17:44:50.211]             setwd(...future.workdir)
[17:44:50.211]         {
[17:44:50.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.211]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.211]             }
[17:44:50.211]             base::options(...future.oldOptions)
[17:44:50.211]             if (.Platform$OS.type == "windows") {
[17:44:50.211]                 old_names <- names(...future.oldEnvVars)
[17:44:50.211]                 envs <- base::Sys.getenv()
[17:44:50.211]                 names <- names(envs)
[17:44:50.211]                 common <- intersect(names, old_names)
[17:44:50.211]                 added <- setdiff(names, old_names)
[17:44:50.211]                 removed <- setdiff(old_names, names)
[17:44:50.211]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.211]                   envs[common]]
[17:44:50.211]                 NAMES <- toupper(changed)
[17:44:50.211]                 args <- list()
[17:44:50.211]                 for (kk in seq_along(NAMES)) {
[17:44:50.211]                   name <- changed[[kk]]
[17:44:50.211]                   NAME <- NAMES[[kk]]
[17:44:50.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.211]                     next
[17:44:50.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.211]                 }
[17:44:50.211]                 NAMES <- toupper(added)
[17:44:50.211]                 for (kk in seq_along(NAMES)) {
[17:44:50.211]                   name <- added[[kk]]
[17:44:50.211]                   NAME <- NAMES[[kk]]
[17:44:50.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.211]                     next
[17:44:50.211]                   args[[name]] <- ""
[17:44:50.211]                 }
[17:44:50.211]                 NAMES <- toupper(removed)
[17:44:50.211]                 for (kk in seq_along(NAMES)) {
[17:44:50.211]                   name <- removed[[kk]]
[17:44:50.211]                   NAME <- NAMES[[kk]]
[17:44:50.211]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.211]                     next
[17:44:50.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.211]                 }
[17:44:50.211]                 if (length(args) > 0) 
[17:44:50.211]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.211]             }
[17:44:50.211]             else {
[17:44:50.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.211]             }
[17:44:50.211]             {
[17:44:50.211]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.211]                   0L) {
[17:44:50.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.211]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.211]                   base::options(opts)
[17:44:50.211]                 }
[17:44:50.211]                 {
[17:44:50.211]                   {
[17:44:50.211]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.211]                     NULL
[17:44:50.211]                   }
[17:44:50.211]                   options(future.plan = NULL)
[17:44:50.211]                   if (is.na(NA_character_)) 
[17:44:50.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.211]                     .init = FALSE)
[17:44:50.211]                 }
[17:44:50.211]             }
[17:44:50.211]         }
[17:44:50.211]     })
[17:44:50.211]     if (TRUE) {
[17:44:50.211]         base::sink(type = "output", split = FALSE)
[17:44:50.211]         if (TRUE) {
[17:44:50.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.211]         }
[17:44:50.211]         else {
[17:44:50.211]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.211]         }
[17:44:50.211]         base::close(...future.stdout)
[17:44:50.211]         ...future.stdout <- NULL
[17:44:50.211]     }
[17:44:50.211]     ...future.result$conditions <- ...future.conditions
[17:44:50.211]     ...future.result$finished <- base::Sys.time()
[17:44:50.211]     ...future.result
[17:44:50.211] }
[17:44:50.213] Exporting 5 global objects (224 bytes) to cluster node #2 ...
[17:44:50.213] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:50.214] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:50.214] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:44:50.214] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:44:50.214] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:44:50.214] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:44:50.215] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.215] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.215] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.215] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.215] Exporting 5 global objects (224 bytes) to cluster node #2 ... DONE
[17:44:50.216] MultisessionFuture started
[17:44:50.216] - Launch lazy future ... done
[17:44:50.216] run() for ‘MultisessionFuture’ ... done
[17:44:50.216] Created future:
[17:44:50.216] MultisessionFuture:
[17:44:50.216] Label: ‘future_mapply-2’
[17:44:50.216] Expression:
[17:44:50.216] {
[17:44:50.216]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.216]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.216]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.216]         on.exit(options(oopts), add = TRUE)
[17:44:50.216]     }
[17:44:50.216]     {
[17:44:50.216]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.216]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.216]         do.call(mapply, args = args)
[17:44:50.216]     }
[17:44:50.216] }
[17:44:50.216] Lazy evaluation: FALSE
[17:44:50.216] Asynchronous evaluation: TRUE
[17:44:50.216] Local evaluation: TRUE
[17:44:50.216] Environment: R_GlobalEnv
[17:44:50.216] Capture standard output: TRUE
[17:44:50.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.216] Globals: 5 objects totaling 224 bytes (function ‘...future.FUN’ of 56 bytes, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.216] Packages: <none>
[17:44:50.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.216] Resolved: FALSE
[17:44:50.216] Value: <not collected>
[17:44:50.216] Conditions captured: <none>
[17:44:50.216] Early signaling: FALSE
[17:44:50.216] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.216] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.228] Chunk #2 of 2 ... DONE
[17:44:50.228] Launching 2 futures (chunks) ... DONE
[17:44:50.228] Resolving 2 futures (chunks) ...
[17:44:50.228] resolve() on list ...
[17:44:50.228]  recursive: 0
[17:44:50.228]  length: 2
[17:44:50.228] 
[17:44:50.229] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.229] - Validating connection of MultisessionFuture
[17:44:50.229] - received message: FutureResult
[17:44:50.229] - Received FutureResult
[17:44:50.229] - Erased future from FutureRegistry
[17:44:50.229] result() for ClusterFuture ...
[17:44:50.229] - result already collected: FutureResult
[17:44:50.229] result() for ClusterFuture ... done
[17:44:50.230] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.230] Future #1
[17:44:50.230] result() for ClusterFuture ...
[17:44:50.230] - result already collected: FutureResult
[17:44:50.230] result() for ClusterFuture ... done
[17:44:50.230] result() for ClusterFuture ...
[17:44:50.230] - result already collected: FutureResult
[17:44:50.230] result() for ClusterFuture ... done
[17:44:50.230] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.230] - nx: 2
[17:44:50.230] - relay: TRUE
[17:44:50.231] - stdout: TRUE
[17:44:50.231] - signal: TRUE
[17:44:50.231] - resignal: FALSE
[17:44:50.231] - force: TRUE
[17:44:50.231] - relayed: [n=2] FALSE, FALSE
[17:44:50.231] - queued futures: [n=2] FALSE, FALSE
[17:44:50.231]  - until=1
[17:44:50.231]  - relaying element #1
[17:44:50.231] result() for ClusterFuture ...
[17:44:50.231] - result already collected: FutureResult
[17:44:50.231] result() for ClusterFuture ... done
[17:44:50.232] result() for ClusterFuture ...
[17:44:50.232] - result already collected: FutureResult
[17:44:50.232] result() for ClusterFuture ... done
[17:44:50.232] result() for ClusterFuture ...
[17:44:50.232] - result already collected: FutureResult
[17:44:50.232] result() for ClusterFuture ... done
[17:44:50.232] result() for ClusterFuture ...
[17:44:50.232] - result already collected: FutureResult
[17:44:50.232] result() for ClusterFuture ... done
[17:44:50.232] - relayed: [n=2] TRUE, FALSE
[17:44:50.232] - queued futures: [n=2] TRUE, FALSE
[17:44:50.232] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.233]  length: 1 (resolved future 1)
[17:44:50.261] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.261] - Validating connection of MultisessionFuture
[17:44:50.261] - received message: FutureResult
[17:44:50.261] - Received FutureResult
[17:44:50.261] - Erased future from FutureRegistry
[17:44:50.262] result() for ClusterFuture ...
[17:44:50.262] - result already collected: FutureResult
[17:44:50.262] result() for ClusterFuture ... done
[17:44:50.262] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.262] Future #2
[17:44:50.262] result() for ClusterFuture ...
[17:44:50.262] - result already collected: FutureResult
[17:44:50.262] result() for ClusterFuture ... done
[17:44:50.262] result() for ClusterFuture ...
[17:44:50.262] - result already collected: FutureResult
[17:44:50.262] result() for ClusterFuture ... done
[17:44:50.263] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.263] - nx: 2
[17:44:50.263] - relay: TRUE
[17:44:50.263] - stdout: TRUE
[17:44:50.263] - signal: TRUE
[17:44:50.263] - resignal: FALSE
[17:44:50.263] - force: TRUE
[17:44:50.263] - relayed: [n=2] TRUE, FALSE
[17:44:50.263] - queued futures: [n=2] TRUE, FALSE
[17:44:50.263]  - until=2
[17:44:50.263]  - relaying element #2
[17:44:50.264] result() for ClusterFuture ...
[17:44:50.264] - result already collected: FutureResult
[17:44:50.264] result() for ClusterFuture ... done
[17:44:50.264] result() for ClusterFuture ...
[17:44:50.264] - result already collected: FutureResult
[17:44:50.264] result() for ClusterFuture ... done
[17:44:50.264] result() for ClusterFuture ...
[17:44:50.264] - result already collected: FutureResult
[17:44:50.264] result() for ClusterFuture ... done
[17:44:50.264] result() for ClusterFuture ...
[17:44:50.264] - result already collected: FutureResult
[17:44:50.265] result() for ClusterFuture ... done
[17:44:50.265] - relayed: [n=2] TRUE, TRUE
[17:44:50.265] - queued futures: [n=2] TRUE, TRUE
[17:44:50.265] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.265]  length: 0 (resolved future 2)
[17:44:50.265] Relaying remaining futures
[17:44:50.265] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.265] - nx: 2
[17:44:50.265] - relay: TRUE
[17:44:50.265] - stdout: TRUE
[17:44:50.265] - signal: TRUE
[17:44:50.266] - resignal: FALSE
[17:44:50.266] - force: TRUE
[17:44:50.266] - relayed: [n=2] TRUE, TRUE
[17:44:50.266] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:50.266] - relayed: [n=2] TRUE, TRUE
[17:44:50.266] - queued futures: [n=2] TRUE, TRUE
[17:44:50.266] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.266] resolve() on list ... DONE
[17:44:50.266] result() for ClusterFuture ...
[17:44:50.266] - result already collected: FutureResult
[17:44:50.266] result() for ClusterFuture ... done
[17:44:50.267] result() for ClusterFuture ...
[17:44:50.267] - result already collected: FutureResult
[17:44:50.267] result() for ClusterFuture ... done
[17:44:50.267] result() for ClusterFuture ...
[17:44:50.267] - result already collected: FutureResult
[17:44:50.267] result() for ClusterFuture ... done
[17:44:50.267] result() for ClusterFuture ...
[17:44:50.267] - result already collected: FutureResult
[17:44:50.267] result() for ClusterFuture ... done
[17:44:50.267]  - Number of value chunks collected: 2
[17:44:50.268] Resolving 2 futures (chunks) ... DONE
[17:44:50.268] Reducing values from 2 chunks ...
[17:44:50.268]  - Number of values collected after concatenation: 4
[17:44:50.268]  - Number of values expected: 4
[17:44:50.268] Reducing values from 2 chunks ... DONE
[17:44:50.268] future_mapply() ... DONE
[17:44:50.268] future_mapply() ...
[17:44:50.272] Number of chunks: 2
[17:44:50.272] getGlobalsAndPackagesXApply() ...
[17:44:50.272]  - future.globals: TRUE
[17:44:50.272] getGlobalsAndPackages() ...
[17:44:50.273] Searching for globals...
[17:44:50.274] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:50.274] Searching for globals ... DONE
[17:44:50.274] Resolving globals: FALSE
[17:44:50.275] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:50.275] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:50.275] - globals: [1] ‘FUN’
[17:44:50.275] 
[17:44:50.275] getGlobalsAndPackages() ... DONE
[17:44:50.276]  - globals found/used: [n=1] ‘FUN’
[17:44:50.276]  - needed namespaces: [n=0] 
[17:44:50.276] Finding globals ... DONE
[17:44:50.278] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.278] List of 2
[17:44:50.278]  $ ...future.FUN:function (x, y)  
[17:44:50.278]  $ MoreArgs     : NULL
[17:44:50.278]  - attr(*, "where")=List of 2
[17:44:50.278]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.278]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.278]  - attr(*, "resolved")= logi FALSE
[17:44:50.278]  - attr(*, "total_size")= num NA
[17:44:50.280] Packages to be attached in all futures: [n=0] 
[17:44:50.281] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.281] Number of futures (= number of chunks): 2
[17:44:50.281] Launching 2 futures (chunks) ...
[17:44:50.281] Chunk #1 of 2 ...
[17:44:50.281]  - Finding globals in '...' for chunk #1 ...
[17:44:50.281] getGlobalsAndPackages() ...
[17:44:50.281] Searching for globals...
[17:44:50.282] 
[17:44:50.282] Searching for globals ... DONE
[17:44:50.282] - globals: [0] <none>
[17:44:50.282] getGlobalsAndPackages() ... DONE
[17:44:50.282]    + additional globals found: [n=0] 
[17:44:50.282]    + additional namespaces needed: [n=0] 
[17:44:50.282]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.282]  - seeds: <none>
[17:44:50.282]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.282] getGlobalsAndPackages() ...
[17:44:50.283] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.283] Resolving globals: FALSE
[17:44:50.283] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:44:50.284] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.284] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.284] 
[17:44:50.284] getGlobalsAndPackages() ... DONE
[17:44:50.284] run() for ‘Future’ ...
[17:44:50.284] - state: ‘created’
[17:44:50.284] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.298]   - Field: ‘node’
[17:44:50.298]   - Field: ‘label’
[17:44:50.298]   - Field: ‘local’
[17:44:50.298]   - Field: ‘owner’
[17:44:50.298]   - Field: ‘envir’
[17:44:50.299]   - Field: ‘workers’
[17:44:50.299]   - Field: ‘packages’
[17:44:50.299]   - Field: ‘gc’
[17:44:50.299]   - Field: ‘conditions’
[17:44:50.299]   - Field: ‘persistent’
[17:44:50.299]   - Field: ‘expr’
[17:44:50.299]   - Field: ‘uuid’
[17:44:50.299]   - Field: ‘seed’
[17:44:50.299]   - Field: ‘version’
[17:44:50.299]   - Field: ‘result’
[17:44:50.299]   - Field: ‘asynchronous’
[17:44:50.300]   - Field: ‘calls’
[17:44:50.300]   - Field: ‘globals’
[17:44:50.300]   - Field: ‘stdout’
[17:44:50.300]   - Field: ‘earlySignal’
[17:44:50.300]   - Field: ‘lazy’
[17:44:50.300]   - Field: ‘state’
[17:44:50.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.300] - Launch lazy future ...
[17:44:50.300] Packages needed by the future expression (n = 0): <none>
[17:44:50.301] Packages needed by future strategies (n = 0): <none>
[17:44:50.301] {
[17:44:50.301]     {
[17:44:50.301]         {
[17:44:50.301]             ...future.startTime <- base::Sys.time()
[17:44:50.301]             {
[17:44:50.301]                 {
[17:44:50.301]                   {
[17:44:50.301]                     {
[17:44:50.301]                       base::local({
[17:44:50.301]                         has_future <- base::requireNamespace("future", 
[17:44:50.301]                           quietly = TRUE)
[17:44:50.301]                         if (has_future) {
[17:44:50.301]                           ns <- base::getNamespace("future")
[17:44:50.301]                           version <- ns[[".package"]][["version"]]
[17:44:50.301]                           if (is.null(version)) 
[17:44:50.301]                             version <- utils::packageVersion("future")
[17:44:50.301]                         }
[17:44:50.301]                         else {
[17:44:50.301]                           version <- NULL
[17:44:50.301]                         }
[17:44:50.301]                         if (!has_future || version < "1.8.0") {
[17:44:50.301]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.301]                             "", base::R.version$version.string), 
[17:44:50.301]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.301]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.301]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.301]                               "release", "version")], collapse = " "), 
[17:44:50.301]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.301]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.301]                             info)
[17:44:50.301]                           info <- base::paste(info, collapse = "; ")
[17:44:50.301]                           if (!has_future) {
[17:44:50.301]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.301]                               info)
[17:44:50.301]                           }
[17:44:50.301]                           else {
[17:44:50.301]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.301]                               info, version)
[17:44:50.301]                           }
[17:44:50.301]                           base::stop(msg)
[17:44:50.301]                         }
[17:44:50.301]                       })
[17:44:50.301]                     }
[17:44:50.301]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.301]                     base::options(mc.cores = 1L)
[17:44:50.301]                   }
[17:44:50.301]                   ...future.strategy.old <- future::plan("list")
[17:44:50.301]                   options(future.plan = NULL)
[17:44:50.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.301]                 }
[17:44:50.301]                 ...future.workdir <- getwd()
[17:44:50.301]             }
[17:44:50.301]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.301]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.301]         }
[17:44:50.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.301]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.301]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.301]             base::names(...future.oldOptions))
[17:44:50.301]     }
[17:44:50.301]     if (FALSE) {
[17:44:50.301]     }
[17:44:50.301]     else {
[17:44:50.301]         if (TRUE) {
[17:44:50.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.301]                 open = "w")
[17:44:50.301]         }
[17:44:50.301]         else {
[17:44:50.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.301]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.301]         }
[17:44:50.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.301]             base::sink(type = "output", split = FALSE)
[17:44:50.301]             base::close(...future.stdout)
[17:44:50.301]         }, add = TRUE)
[17:44:50.301]     }
[17:44:50.301]     ...future.frame <- base::sys.nframe()
[17:44:50.301]     ...future.conditions <- base::list()
[17:44:50.301]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.301]     if (FALSE) {
[17:44:50.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.301]     }
[17:44:50.301]     ...future.result <- base::tryCatch({
[17:44:50.301]         base::withCallingHandlers({
[17:44:50.301]             ...future.value <- base::withVisible(base::local({
[17:44:50.301]                 ...future.makeSendCondition <- base::local({
[17:44:50.301]                   sendCondition <- NULL
[17:44:50.301]                   function(frame = 1L) {
[17:44:50.301]                     if (is.function(sendCondition)) 
[17:44:50.301]                       return(sendCondition)
[17:44:50.301]                     ns <- getNamespace("parallel")
[17:44:50.301]                     if (exists("sendData", mode = "function", 
[17:44:50.301]                       envir = ns)) {
[17:44:50.301]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.301]                         envir = ns)
[17:44:50.301]                       envir <- sys.frame(frame)
[17:44:50.301]                       master <- NULL
[17:44:50.301]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.301]                         !identical(envir, emptyenv())) {
[17:44:50.301]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.301]                           inherits = FALSE)) {
[17:44:50.301]                           master <- get("master", mode = "list", 
[17:44:50.301]                             envir = envir, inherits = FALSE)
[17:44:50.301]                           if (inherits(master, c("SOCKnode", 
[17:44:50.301]                             "SOCK0node"))) {
[17:44:50.301]                             sendCondition <<- function(cond) {
[17:44:50.301]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.301]                                 success = TRUE)
[17:44:50.301]                               parallel_sendData(master, data)
[17:44:50.301]                             }
[17:44:50.301]                             return(sendCondition)
[17:44:50.301]                           }
[17:44:50.301]                         }
[17:44:50.301]                         frame <- frame + 1L
[17:44:50.301]                         envir <- sys.frame(frame)
[17:44:50.301]                       }
[17:44:50.301]                     }
[17:44:50.301]                     sendCondition <<- function(cond) NULL
[17:44:50.301]                   }
[17:44:50.301]                 })
[17:44:50.301]                 withCallingHandlers({
[17:44:50.301]                   {
[17:44:50.301]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.301]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.301]                       ...future.globals.maxSize)) {
[17:44:50.301]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.301]                       on.exit(options(oopts), add = TRUE)
[17:44:50.301]                     }
[17:44:50.301]                     {
[17:44:50.301]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.301]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.301]                         USE.NAMES = FALSE)
[17:44:50.301]                       do.call(mapply, args = args)
[17:44:50.301]                     }
[17:44:50.301]                   }
[17:44:50.301]                 }, immediateCondition = function(cond) {
[17:44:50.301]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.301]                   sendCondition(cond)
[17:44:50.301]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.301]                   {
[17:44:50.301]                     inherits <- base::inherits
[17:44:50.301]                     invokeRestart <- base::invokeRestart
[17:44:50.301]                     is.null <- base::is.null
[17:44:50.301]                     muffled <- FALSE
[17:44:50.301]                     if (inherits(cond, "message")) {
[17:44:50.301]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.301]                       if (muffled) 
[17:44:50.301]                         invokeRestart("muffleMessage")
[17:44:50.301]                     }
[17:44:50.301]                     else if (inherits(cond, "warning")) {
[17:44:50.301]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.301]                       if (muffled) 
[17:44:50.301]                         invokeRestart("muffleWarning")
[17:44:50.301]                     }
[17:44:50.301]                     else if (inherits(cond, "condition")) {
[17:44:50.301]                       if (!is.null(pattern)) {
[17:44:50.301]                         computeRestarts <- base::computeRestarts
[17:44:50.301]                         grepl <- base::grepl
[17:44:50.301]                         restarts <- computeRestarts(cond)
[17:44:50.301]                         for (restart in restarts) {
[17:44:50.301]                           name <- restart$name
[17:44:50.301]                           if (is.null(name)) 
[17:44:50.301]                             next
[17:44:50.301]                           if (!grepl(pattern, name)) 
[17:44:50.301]                             next
[17:44:50.301]                           invokeRestart(restart)
[17:44:50.301]                           muffled <- TRUE
[17:44:50.301]                           break
[17:44:50.301]                         }
[17:44:50.301]                       }
[17:44:50.301]                     }
[17:44:50.301]                     invisible(muffled)
[17:44:50.301]                   }
[17:44:50.301]                   muffleCondition(cond)
[17:44:50.301]                 })
[17:44:50.301]             }))
[17:44:50.301]             future::FutureResult(value = ...future.value$value, 
[17:44:50.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.301]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.301]                     ...future.globalenv.names))
[17:44:50.301]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.301]         }, condition = base::local({
[17:44:50.301]             c <- base::c
[17:44:50.301]             inherits <- base::inherits
[17:44:50.301]             invokeRestart <- base::invokeRestart
[17:44:50.301]             length <- base::length
[17:44:50.301]             list <- base::list
[17:44:50.301]             seq.int <- base::seq.int
[17:44:50.301]             signalCondition <- base::signalCondition
[17:44:50.301]             sys.calls <- base::sys.calls
[17:44:50.301]             `[[` <- base::`[[`
[17:44:50.301]             `+` <- base::`+`
[17:44:50.301]             `<<-` <- base::`<<-`
[17:44:50.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.301]                   3L)]
[17:44:50.301]             }
[17:44:50.301]             function(cond) {
[17:44:50.301]                 is_error <- inherits(cond, "error")
[17:44:50.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.301]                   NULL)
[17:44:50.301]                 if (is_error) {
[17:44:50.301]                   sessionInformation <- function() {
[17:44:50.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.301]                       search = base::search(), system = base::Sys.info())
[17:44:50.301]                   }
[17:44:50.301]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.301]                     cond$call), session = sessionInformation(), 
[17:44:50.301]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.301]                   signalCondition(cond)
[17:44:50.301]                 }
[17:44:50.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.301]                 "immediateCondition"))) {
[17:44:50.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.301]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.301]                   if (TRUE && !signal) {
[17:44:50.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.301]                     {
[17:44:50.301]                       inherits <- base::inherits
[17:44:50.301]                       invokeRestart <- base::invokeRestart
[17:44:50.301]                       is.null <- base::is.null
[17:44:50.301]                       muffled <- FALSE
[17:44:50.301]                       if (inherits(cond, "message")) {
[17:44:50.301]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.301]                         if (muffled) 
[17:44:50.301]                           invokeRestart("muffleMessage")
[17:44:50.301]                       }
[17:44:50.301]                       else if (inherits(cond, "warning")) {
[17:44:50.301]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.301]                         if (muffled) 
[17:44:50.301]                           invokeRestart("muffleWarning")
[17:44:50.301]                       }
[17:44:50.301]                       else if (inherits(cond, "condition")) {
[17:44:50.301]                         if (!is.null(pattern)) {
[17:44:50.301]                           computeRestarts <- base::computeRestarts
[17:44:50.301]                           grepl <- base::grepl
[17:44:50.301]                           restarts <- computeRestarts(cond)
[17:44:50.301]                           for (restart in restarts) {
[17:44:50.301]                             name <- restart$name
[17:44:50.301]                             if (is.null(name)) 
[17:44:50.301]                               next
[17:44:50.301]                             if (!grepl(pattern, name)) 
[17:44:50.301]                               next
[17:44:50.301]                             invokeRestart(restart)
[17:44:50.301]                             muffled <- TRUE
[17:44:50.301]                             break
[17:44:50.301]                           }
[17:44:50.301]                         }
[17:44:50.301]                       }
[17:44:50.301]                       invisible(muffled)
[17:44:50.301]                     }
[17:44:50.301]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.301]                   }
[17:44:50.301]                 }
[17:44:50.301]                 else {
[17:44:50.301]                   if (TRUE) {
[17:44:50.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.301]                     {
[17:44:50.301]                       inherits <- base::inherits
[17:44:50.301]                       invokeRestart <- base::invokeRestart
[17:44:50.301]                       is.null <- base::is.null
[17:44:50.301]                       muffled <- FALSE
[17:44:50.301]                       if (inherits(cond, "message")) {
[17:44:50.301]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.301]                         if (muffled) 
[17:44:50.301]                           invokeRestart("muffleMessage")
[17:44:50.301]                       }
[17:44:50.301]                       else if (inherits(cond, "warning")) {
[17:44:50.301]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.301]                         if (muffled) 
[17:44:50.301]                           invokeRestart("muffleWarning")
[17:44:50.301]                       }
[17:44:50.301]                       else if (inherits(cond, "condition")) {
[17:44:50.301]                         if (!is.null(pattern)) {
[17:44:50.301]                           computeRestarts <- base::computeRestarts
[17:44:50.301]                           grepl <- base::grepl
[17:44:50.301]                           restarts <- computeRestarts(cond)
[17:44:50.301]                           for (restart in restarts) {
[17:44:50.301]                             name <- restart$name
[17:44:50.301]                             if (is.null(name)) 
[17:44:50.301]                               next
[17:44:50.301]                             if (!grepl(pattern, name)) 
[17:44:50.301]                               next
[17:44:50.301]                             invokeRestart(restart)
[17:44:50.301]                             muffled <- TRUE
[17:44:50.301]                             break
[17:44:50.301]                           }
[17:44:50.301]                         }
[17:44:50.301]                       }
[17:44:50.301]                       invisible(muffled)
[17:44:50.301]                     }
[17:44:50.301]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.301]                   }
[17:44:50.301]                 }
[17:44:50.301]             }
[17:44:50.301]         }))
[17:44:50.301]     }, error = function(ex) {
[17:44:50.301]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.301]                 ...future.rng), started = ...future.startTime, 
[17:44:50.301]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.301]             version = "1.8"), class = "FutureResult")
[17:44:50.301]     }, finally = {
[17:44:50.301]         if (!identical(...future.workdir, getwd())) 
[17:44:50.301]             setwd(...future.workdir)
[17:44:50.301]         {
[17:44:50.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.301]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.301]             }
[17:44:50.301]             base::options(...future.oldOptions)
[17:44:50.301]             if (.Platform$OS.type == "windows") {
[17:44:50.301]                 old_names <- names(...future.oldEnvVars)
[17:44:50.301]                 envs <- base::Sys.getenv()
[17:44:50.301]                 names <- names(envs)
[17:44:50.301]                 common <- intersect(names, old_names)
[17:44:50.301]                 added <- setdiff(names, old_names)
[17:44:50.301]                 removed <- setdiff(old_names, names)
[17:44:50.301]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.301]                   envs[common]]
[17:44:50.301]                 NAMES <- toupper(changed)
[17:44:50.301]                 args <- list()
[17:44:50.301]                 for (kk in seq_along(NAMES)) {
[17:44:50.301]                   name <- changed[[kk]]
[17:44:50.301]                   NAME <- NAMES[[kk]]
[17:44:50.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.301]                     next
[17:44:50.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.301]                 }
[17:44:50.301]                 NAMES <- toupper(added)
[17:44:50.301]                 for (kk in seq_along(NAMES)) {
[17:44:50.301]                   name <- added[[kk]]
[17:44:50.301]                   NAME <- NAMES[[kk]]
[17:44:50.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.301]                     next
[17:44:50.301]                   args[[name]] <- ""
[17:44:50.301]                 }
[17:44:50.301]                 NAMES <- toupper(removed)
[17:44:50.301]                 for (kk in seq_along(NAMES)) {
[17:44:50.301]                   name <- removed[[kk]]
[17:44:50.301]                   NAME <- NAMES[[kk]]
[17:44:50.301]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.301]                     next
[17:44:50.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.301]                 }
[17:44:50.301]                 if (length(args) > 0) 
[17:44:50.301]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.301]             }
[17:44:50.301]             else {
[17:44:50.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.301]             }
[17:44:50.301]             {
[17:44:50.301]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.301]                   0L) {
[17:44:50.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.301]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.301]                   base::options(opts)
[17:44:50.301]                 }
[17:44:50.301]                 {
[17:44:50.301]                   {
[17:44:50.301]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.301]                     NULL
[17:44:50.301]                   }
[17:44:50.301]                   options(future.plan = NULL)
[17:44:50.301]                   if (is.na(NA_character_)) 
[17:44:50.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.301]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.301]                     .init = FALSE)
[17:44:50.301]                 }
[17:44:50.301]             }
[17:44:50.301]         }
[17:44:50.301]     })
[17:44:50.301]     if (TRUE) {
[17:44:50.301]         base::sink(type = "output", split = FALSE)
[17:44:50.301]         if (TRUE) {
[17:44:50.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.301]         }
[17:44:50.301]         else {
[17:44:50.301]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.301]         }
[17:44:50.301]         base::close(...future.stdout)
[17:44:50.301]         ...future.stdout <- NULL
[17:44:50.301]     }
[17:44:50.301]     ...future.result$conditions <- ...future.conditions
[17:44:50.301]     ...future.result$finished <- base::Sys.time()
[17:44:50.301]     ...future.result
[17:44:50.301] }
[17:44:50.304] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:44:50.304] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:44:50.304] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:44:50.304] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.305] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.305] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:44:50.305] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:44:50.305] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.305] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.306] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.306] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.306] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:44:50.306] MultisessionFuture started
[17:44:50.306] - Launch lazy future ... done
[17:44:50.307] run() for ‘MultisessionFuture’ ... done
[17:44:50.307] Created future:
[17:44:50.307] MultisessionFuture:
[17:44:50.307] Label: ‘future_mapply-1’
[17:44:50.307] Expression:
[17:44:50.307] {
[17:44:50.307]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.307]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.307]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.307]         on.exit(options(oopts), add = TRUE)
[17:44:50.307]     }
[17:44:50.307]     {
[17:44:50.307]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.307]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.307]         do.call(mapply, args = args)
[17:44:50.307]     }
[17:44:50.307] }
[17:44:50.307] Lazy evaluation: FALSE
[17:44:50.307] Asynchronous evaluation: TRUE
[17:44:50.307] Local evaluation: TRUE
[17:44:50.307] Environment: R_GlobalEnv
[17:44:50.307] Capture standard output: TRUE
[17:44:50.307] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.307] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.307] Packages: <none>
[17:44:50.307] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.307] Resolved: FALSE
[17:44:50.307] Value: <not collected>
[17:44:50.307] Conditions captured: <none>
[17:44:50.307] Early signaling: FALSE
[17:44:50.307] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.307] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.318] Chunk #1 of 2 ... DONE
[17:44:50.318] Chunk #2 of 2 ...
[17:44:50.318]  - Finding globals in '...' for chunk #2 ...
[17:44:50.319] getGlobalsAndPackages() ...
[17:44:50.319] Searching for globals...
[17:44:50.319] 
[17:44:50.319] Searching for globals ... DONE
[17:44:50.319] - globals: [0] <none>
[17:44:50.319] getGlobalsAndPackages() ... DONE
[17:44:50.319]    + additional globals found: [n=0] 
[17:44:50.320]    + additional namespaces needed: [n=0] 
[17:44:50.320]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.320]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.320]  - seeds: <none>
[17:44:50.320]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.320] getGlobalsAndPackages() ...
[17:44:50.320] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.320] Resolving globals: FALSE
[17:44:50.321] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:44:50.321] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.321] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.321] 
[17:44:50.321] getGlobalsAndPackages() ... DONE
[17:44:50.322] run() for ‘Future’ ...
[17:44:50.322] - state: ‘created’
[17:44:50.322] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.335] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.335] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.335]   - Field: ‘node’
[17:44:50.335]   - Field: ‘label’
[17:44:50.336]   - Field: ‘local’
[17:44:50.336]   - Field: ‘owner’
[17:44:50.336]   - Field: ‘envir’
[17:44:50.336]   - Field: ‘workers’
[17:44:50.336]   - Field: ‘packages’
[17:44:50.336]   - Field: ‘gc’
[17:44:50.336]   - Field: ‘conditions’
[17:44:50.336]   - Field: ‘persistent’
[17:44:50.336]   - Field: ‘expr’
[17:44:50.336]   - Field: ‘uuid’
[17:44:50.336]   - Field: ‘seed’
[17:44:50.337]   - Field: ‘version’
[17:44:50.337]   - Field: ‘result’
[17:44:50.337]   - Field: ‘asynchronous’
[17:44:50.337]   - Field: ‘calls’
[17:44:50.337]   - Field: ‘globals’
[17:44:50.337]   - Field: ‘stdout’
[17:44:50.337]   - Field: ‘earlySignal’
[17:44:50.337]   - Field: ‘lazy’
[17:44:50.337]   - Field: ‘state’
[17:44:50.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.337] - Launch lazy future ...
[17:44:50.338] Packages needed by the future expression (n = 0): <none>
[17:44:50.338] Packages needed by future strategies (n = 0): <none>
[17:44:50.338] {
[17:44:50.338]     {
[17:44:50.338]         {
[17:44:50.338]             ...future.startTime <- base::Sys.time()
[17:44:50.338]             {
[17:44:50.338]                 {
[17:44:50.338]                   {
[17:44:50.338]                     {
[17:44:50.338]                       base::local({
[17:44:50.338]                         has_future <- base::requireNamespace("future", 
[17:44:50.338]                           quietly = TRUE)
[17:44:50.338]                         if (has_future) {
[17:44:50.338]                           ns <- base::getNamespace("future")
[17:44:50.338]                           version <- ns[[".package"]][["version"]]
[17:44:50.338]                           if (is.null(version)) 
[17:44:50.338]                             version <- utils::packageVersion("future")
[17:44:50.338]                         }
[17:44:50.338]                         else {
[17:44:50.338]                           version <- NULL
[17:44:50.338]                         }
[17:44:50.338]                         if (!has_future || version < "1.8.0") {
[17:44:50.338]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.338]                             "", base::R.version$version.string), 
[17:44:50.338]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.338]                               "release", "version")], collapse = " "), 
[17:44:50.338]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.338]                             info)
[17:44:50.338]                           info <- base::paste(info, collapse = "; ")
[17:44:50.338]                           if (!has_future) {
[17:44:50.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.338]                               info)
[17:44:50.338]                           }
[17:44:50.338]                           else {
[17:44:50.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.338]                               info, version)
[17:44:50.338]                           }
[17:44:50.338]                           base::stop(msg)
[17:44:50.338]                         }
[17:44:50.338]                       })
[17:44:50.338]                     }
[17:44:50.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.338]                     base::options(mc.cores = 1L)
[17:44:50.338]                   }
[17:44:50.338]                   ...future.strategy.old <- future::plan("list")
[17:44:50.338]                   options(future.plan = NULL)
[17:44:50.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.338]                 }
[17:44:50.338]                 ...future.workdir <- getwd()
[17:44:50.338]             }
[17:44:50.338]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.338]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.338]         }
[17:44:50.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.338]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.338]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.338]             base::names(...future.oldOptions))
[17:44:50.338]     }
[17:44:50.338]     if (FALSE) {
[17:44:50.338]     }
[17:44:50.338]     else {
[17:44:50.338]         if (TRUE) {
[17:44:50.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.338]                 open = "w")
[17:44:50.338]         }
[17:44:50.338]         else {
[17:44:50.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.338]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.338]         }
[17:44:50.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.338]             base::sink(type = "output", split = FALSE)
[17:44:50.338]             base::close(...future.stdout)
[17:44:50.338]         }, add = TRUE)
[17:44:50.338]     }
[17:44:50.338]     ...future.frame <- base::sys.nframe()
[17:44:50.338]     ...future.conditions <- base::list()
[17:44:50.338]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.338]     if (FALSE) {
[17:44:50.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.338]     }
[17:44:50.338]     ...future.result <- base::tryCatch({
[17:44:50.338]         base::withCallingHandlers({
[17:44:50.338]             ...future.value <- base::withVisible(base::local({
[17:44:50.338]                 ...future.makeSendCondition <- base::local({
[17:44:50.338]                   sendCondition <- NULL
[17:44:50.338]                   function(frame = 1L) {
[17:44:50.338]                     if (is.function(sendCondition)) 
[17:44:50.338]                       return(sendCondition)
[17:44:50.338]                     ns <- getNamespace("parallel")
[17:44:50.338]                     if (exists("sendData", mode = "function", 
[17:44:50.338]                       envir = ns)) {
[17:44:50.338]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.338]                         envir = ns)
[17:44:50.338]                       envir <- sys.frame(frame)
[17:44:50.338]                       master <- NULL
[17:44:50.338]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.338]                         !identical(envir, emptyenv())) {
[17:44:50.338]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.338]                           inherits = FALSE)) {
[17:44:50.338]                           master <- get("master", mode = "list", 
[17:44:50.338]                             envir = envir, inherits = FALSE)
[17:44:50.338]                           if (inherits(master, c("SOCKnode", 
[17:44:50.338]                             "SOCK0node"))) {
[17:44:50.338]                             sendCondition <<- function(cond) {
[17:44:50.338]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.338]                                 success = TRUE)
[17:44:50.338]                               parallel_sendData(master, data)
[17:44:50.338]                             }
[17:44:50.338]                             return(sendCondition)
[17:44:50.338]                           }
[17:44:50.338]                         }
[17:44:50.338]                         frame <- frame + 1L
[17:44:50.338]                         envir <- sys.frame(frame)
[17:44:50.338]                       }
[17:44:50.338]                     }
[17:44:50.338]                     sendCondition <<- function(cond) NULL
[17:44:50.338]                   }
[17:44:50.338]                 })
[17:44:50.338]                 withCallingHandlers({
[17:44:50.338]                   {
[17:44:50.338]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.338]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.338]                       ...future.globals.maxSize)) {
[17:44:50.338]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.338]                       on.exit(options(oopts), add = TRUE)
[17:44:50.338]                     }
[17:44:50.338]                     {
[17:44:50.338]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.338]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.338]                         USE.NAMES = FALSE)
[17:44:50.338]                       do.call(mapply, args = args)
[17:44:50.338]                     }
[17:44:50.338]                   }
[17:44:50.338]                 }, immediateCondition = function(cond) {
[17:44:50.338]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.338]                   sendCondition(cond)
[17:44:50.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.338]                   {
[17:44:50.338]                     inherits <- base::inherits
[17:44:50.338]                     invokeRestart <- base::invokeRestart
[17:44:50.338]                     is.null <- base::is.null
[17:44:50.338]                     muffled <- FALSE
[17:44:50.338]                     if (inherits(cond, "message")) {
[17:44:50.338]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.338]                       if (muffled) 
[17:44:50.338]                         invokeRestart("muffleMessage")
[17:44:50.338]                     }
[17:44:50.338]                     else if (inherits(cond, "warning")) {
[17:44:50.338]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.338]                       if (muffled) 
[17:44:50.338]                         invokeRestart("muffleWarning")
[17:44:50.338]                     }
[17:44:50.338]                     else if (inherits(cond, "condition")) {
[17:44:50.338]                       if (!is.null(pattern)) {
[17:44:50.338]                         computeRestarts <- base::computeRestarts
[17:44:50.338]                         grepl <- base::grepl
[17:44:50.338]                         restarts <- computeRestarts(cond)
[17:44:50.338]                         for (restart in restarts) {
[17:44:50.338]                           name <- restart$name
[17:44:50.338]                           if (is.null(name)) 
[17:44:50.338]                             next
[17:44:50.338]                           if (!grepl(pattern, name)) 
[17:44:50.338]                             next
[17:44:50.338]                           invokeRestart(restart)
[17:44:50.338]                           muffled <- TRUE
[17:44:50.338]                           break
[17:44:50.338]                         }
[17:44:50.338]                       }
[17:44:50.338]                     }
[17:44:50.338]                     invisible(muffled)
[17:44:50.338]                   }
[17:44:50.338]                   muffleCondition(cond)
[17:44:50.338]                 })
[17:44:50.338]             }))
[17:44:50.338]             future::FutureResult(value = ...future.value$value, 
[17:44:50.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.338]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.338]                     ...future.globalenv.names))
[17:44:50.338]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.338]         }, condition = base::local({
[17:44:50.338]             c <- base::c
[17:44:50.338]             inherits <- base::inherits
[17:44:50.338]             invokeRestart <- base::invokeRestart
[17:44:50.338]             length <- base::length
[17:44:50.338]             list <- base::list
[17:44:50.338]             seq.int <- base::seq.int
[17:44:50.338]             signalCondition <- base::signalCondition
[17:44:50.338]             sys.calls <- base::sys.calls
[17:44:50.338]             `[[` <- base::`[[`
[17:44:50.338]             `+` <- base::`+`
[17:44:50.338]             `<<-` <- base::`<<-`
[17:44:50.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.338]                   3L)]
[17:44:50.338]             }
[17:44:50.338]             function(cond) {
[17:44:50.338]                 is_error <- inherits(cond, "error")
[17:44:50.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.338]                   NULL)
[17:44:50.338]                 if (is_error) {
[17:44:50.338]                   sessionInformation <- function() {
[17:44:50.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.338]                       search = base::search(), system = base::Sys.info())
[17:44:50.338]                   }
[17:44:50.338]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.338]                     cond$call), session = sessionInformation(), 
[17:44:50.338]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.338]                   signalCondition(cond)
[17:44:50.338]                 }
[17:44:50.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.338]                 "immediateCondition"))) {
[17:44:50.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.338]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.338]                   if (TRUE && !signal) {
[17:44:50.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.338]                     {
[17:44:50.338]                       inherits <- base::inherits
[17:44:50.338]                       invokeRestart <- base::invokeRestart
[17:44:50.338]                       is.null <- base::is.null
[17:44:50.338]                       muffled <- FALSE
[17:44:50.338]                       if (inherits(cond, "message")) {
[17:44:50.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.338]                         if (muffled) 
[17:44:50.338]                           invokeRestart("muffleMessage")
[17:44:50.338]                       }
[17:44:50.338]                       else if (inherits(cond, "warning")) {
[17:44:50.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.338]                         if (muffled) 
[17:44:50.338]                           invokeRestart("muffleWarning")
[17:44:50.338]                       }
[17:44:50.338]                       else if (inherits(cond, "condition")) {
[17:44:50.338]                         if (!is.null(pattern)) {
[17:44:50.338]                           computeRestarts <- base::computeRestarts
[17:44:50.338]                           grepl <- base::grepl
[17:44:50.338]                           restarts <- computeRestarts(cond)
[17:44:50.338]                           for (restart in restarts) {
[17:44:50.338]                             name <- restart$name
[17:44:50.338]                             if (is.null(name)) 
[17:44:50.338]                               next
[17:44:50.338]                             if (!grepl(pattern, name)) 
[17:44:50.338]                               next
[17:44:50.338]                             invokeRestart(restart)
[17:44:50.338]                             muffled <- TRUE
[17:44:50.338]                             break
[17:44:50.338]                           }
[17:44:50.338]                         }
[17:44:50.338]                       }
[17:44:50.338]                       invisible(muffled)
[17:44:50.338]                     }
[17:44:50.338]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.338]                   }
[17:44:50.338]                 }
[17:44:50.338]                 else {
[17:44:50.338]                   if (TRUE) {
[17:44:50.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.338]                     {
[17:44:50.338]                       inherits <- base::inherits
[17:44:50.338]                       invokeRestart <- base::invokeRestart
[17:44:50.338]                       is.null <- base::is.null
[17:44:50.338]                       muffled <- FALSE
[17:44:50.338]                       if (inherits(cond, "message")) {
[17:44:50.338]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.338]                         if (muffled) 
[17:44:50.338]                           invokeRestart("muffleMessage")
[17:44:50.338]                       }
[17:44:50.338]                       else if (inherits(cond, "warning")) {
[17:44:50.338]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.338]                         if (muffled) 
[17:44:50.338]                           invokeRestart("muffleWarning")
[17:44:50.338]                       }
[17:44:50.338]                       else if (inherits(cond, "condition")) {
[17:44:50.338]                         if (!is.null(pattern)) {
[17:44:50.338]                           computeRestarts <- base::computeRestarts
[17:44:50.338]                           grepl <- base::grepl
[17:44:50.338]                           restarts <- computeRestarts(cond)
[17:44:50.338]                           for (restart in restarts) {
[17:44:50.338]                             name <- restart$name
[17:44:50.338]                             if (is.null(name)) 
[17:44:50.338]                               next
[17:44:50.338]                             if (!grepl(pattern, name)) 
[17:44:50.338]                               next
[17:44:50.338]                             invokeRestart(restart)
[17:44:50.338]                             muffled <- TRUE
[17:44:50.338]                             break
[17:44:50.338]                           }
[17:44:50.338]                         }
[17:44:50.338]                       }
[17:44:50.338]                       invisible(muffled)
[17:44:50.338]                     }
[17:44:50.338]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.338]                   }
[17:44:50.338]                 }
[17:44:50.338]             }
[17:44:50.338]         }))
[17:44:50.338]     }, error = function(ex) {
[17:44:50.338]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.338]                 ...future.rng), started = ...future.startTime, 
[17:44:50.338]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.338]             version = "1.8"), class = "FutureResult")
[17:44:50.338]     }, finally = {
[17:44:50.338]         if (!identical(...future.workdir, getwd())) 
[17:44:50.338]             setwd(...future.workdir)
[17:44:50.338]         {
[17:44:50.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.338]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.338]             }
[17:44:50.338]             base::options(...future.oldOptions)
[17:44:50.338]             if (.Platform$OS.type == "windows") {
[17:44:50.338]                 old_names <- names(...future.oldEnvVars)
[17:44:50.338]                 envs <- base::Sys.getenv()
[17:44:50.338]                 names <- names(envs)
[17:44:50.338]                 common <- intersect(names, old_names)
[17:44:50.338]                 added <- setdiff(names, old_names)
[17:44:50.338]                 removed <- setdiff(old_names, names)
[17:44:50.338]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.338]                   envs[common]]
[17:44:50.338]                 NAMES <- toupper(changed)
[17:44:50.338]                 args <- list()
[17:44:50.338]                 for (kk in seq_along(NAMES)) {
[17:44:50.338]                   name <- changed[[kk]]
[17:44:50.338]                   NAME <- NAMES[[kk]]
[17:44:50.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.338]                     next
[17:44:50.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.338]                 }
[17:44:50.338]                 NAMES <- toupper(added)
[17:44:50.338]                 for (kk in seq_along(NAMES)) {
[17:44:50.338]                   name <- added[[kk]]
[17:44:50.338]                   NAME <- NAMES[[kk]]
[17:44:50.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.338]                     next
[17:44:50.338]                   args[[name]] <- ""
[17:44:50.338]                 }
[17:44:50.338]                 NAMES <- toupper(removed)
[17:44:50.338]                 for (kk in seq_along(NAMES)) {
[17:44:50.338]                   name <- removed[[kk]]
[17:44:50.338]                   NAME <- NAMES[[kk]]
[17:44:50.338]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.338]                     next
[17:44:50.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.338]                 }
[17:44:50.338]                 if (length(args) > 0) 
[17:44:50.338]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.338]             }
[17:44:50.338]             else {
[17:44:50.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.338]             }
[17:44:50.338]             {
[17:44:50.338]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.338]                   0L) {
[17:44:50.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.338]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.338]                   base::options(opts)
[17:44:50.338]                 }
[17:44:50.338]                 {
[17:44:50.338]                   {
[17:44:50.338]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.338]                     NULL
[17:44:50.338]                   }
[17:44:50.338]                   options(future.plan = NULL)
[17:44:50.338]                   if (is.na(NA_character_)) 
[17:44:50.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.338]                     .init = FALSE)
[17:44:50.338]                 }
[17:44:50.338]             }
[17:44:50.338]         }
[17:44:50.338]     })
[17:44:50.338]     if (TRUE) {
[17:44:50.338]         base::sink(type = "output", split = FALSE)
[17:44:50.338]         if (TRUE) {
[17:44:50.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.338]         }
[17:44:50.338]         else {
[17:44:50.338]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.338]         }
[17:44:50.338]         base::close(...future.stdout)
[17:44:50.338]         ...future.stdout <- NULL
[17:44:50.338]     }
[17:44:50.338]     ...future.result$conditions <- ...future.conditions
[17:44:50.338]     ...future.result$finished <- base::Sys.time()
[17:44:50.338]     ...future.result
[17:44:50.338] }
[17:44:50.341] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:44:50.341] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:44:50.341] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:44:50.341] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.342] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.342] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:50.342] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:50.342] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.342] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.343] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.343] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.343] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:44:50.343] MultisessionFuture started
[17:44:50.344] - Launch lazy future ... done
[17:44:50.344] run() for ‘MultisessionFuture’ ... done
[17:44:50.344] Created future:
[17:44:50.344] MultisessionFuture:
[17:44:50.344] Label: ‘future_mapply-2’
[17:44:50.344] Expression:
[17:44:50.344] {
[17:44:50.344]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.344]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.344]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.344]         on.exit(options(oopts), add = TRUE)
[17:44:50.344]     }
[17:44:50.344]     {
[17:44:50.344]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.344]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.344]         do.call(mapply, args = args)
[17:44:50.344]     }
[17:44:50.344] }
[17:44:50.344] Lazy evaluation: FALSE
[17:44:50.344] Asynchronous evaluation: TRUE
[17:44:50.344] Local evaluation: TRUE
[17:44:50.344] Environment: R_GlobalEnv
[17:44:50.344] Capture standard output: TRUE
[17:44:50.344] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.344] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.344] Packages: <none>
[17:44:50.344] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.344] Resolved: FALSE
[17:44:50.344] Value: <not collected>
[17:44:50.344] Conditions captured: <none>
[17:44:50.344] Early signaling: FALSE
[17:44:50.344] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.344] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.355] Chunk #2 of 2 ... DONE
[17:44:50.355] Launching 2 futures (chunks) ... DONE
[17:44:50.356] Resolving 2 futures (chunks) ...
[17:44:50.356] resolve() on list ...
[17:44:50.356]  recursive: 0
[17:44:50.356]  length: 2
[17:44:50.356] 
[17:44:50.356] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.357] - Validating connection of MultisessionFuture
[17:44:50.357] - received message: FutureResult
[17:44:50.357] - Received FutureResult
[17:44:50.357] - Erased future from FutureRegistry
[17:44:50.357] result() for ClusterFuture ...
[17:44:50.357] - result already collected: FutureResult
[17:44:50.357] result() for ClusterFuture ... done
[17:44:50.357] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.357] Future #1
[17:44:50.357] result() for ClusterFuture ...
[17:44:50.358] - result already collected: FutureResult
[17:44:50.358] result() for ClusterFuture ... done
[17:44:50.358] result() for ClusterFuture ...
[17:44:50.358] - result already collected: FutureResult
[17:44:50.358] result() for ClusterFuture ... done
[17:44:50.358] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.358] - nx: 2
[17:44:50.358] - relay: TRUE
[17:44:50.358] - stdout: TRUE
[17:44:50.358] - signal: TRUE
[17:44:50.358] - resignal: FALSE
[17:44:50.358] - force: TRUE
[17:44:50.359] - relayed: [n=2] FALSE, FALSE
[17:44:50.359] - queued futures: [n=2] FALSE, FALSE
[17:44:50.359]  - until=1
[17:44:50.359]  - relaying element #1
[17:44:50.359] result() for ClusterFuture ...
[17:44:50.359] - result already collected: FutureResult
[17:44:50.359] result() for ClusterFuture ... done
[17:44:50.359] result() for ClusterFuture ...
[17:44:50.359] - result already collected: FutureResult
[17:44:50.359] result() for ClusterFuture ... done
[17:44:50.359] result() for ClusterFuture ...
[17:44:50.360] - result already collected: FutureResult
[17:44:50.360] result() for ClusterFuture ... done
[17:44:50.360] result() for ClusterFuture ...
[17:44:50.360] - result already collected: FutureResult
[17:44:50.360] result() for ClusterFuture ... done
[17:44:50.360] - relayed: [n=2] TRUE, FALSE
[17:44:50.360] - queued futures: [n=2] TRUE, FALSE
[17:44:50.360] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.360]  length: 1 (resolved future 1)
[17:44:50.402] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.402] - Validating connection of MultisessionFuture
[17:44:50.402] - received message: FutureResult
[17:44:50.403] - Received FutureResult
[17:44:50.403] - Erased future from FutureRegistry
[17:44:50.403] result() for ClusterFuture ...
[17:44:50.403] - result already collected: FutureResult
[17:44:50.403] result() for ClusterFuture ... done
[17:44:50.403] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.403] Future #2
[17:44:50.403] result() for ClusterFuture ...
[17:44:50.403] - result already collected: FutureResult
[17:44:50.403] result() for ClusterFuture ... done
[17:44:50.404] result() for ClusterFuture ...
[17:44:50.404] - result already collected: FutureResult
[17:44:50.404] result() for ClusterFuture ... done
[17:44:50.404] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.404] - nx: 2
[17:44:50.404] - relay: TRUE
[17:44:50.404] - stdout: TRUE
[17:44:50.404] - signal: TRUE
[17:44:50.404] - resignal: FALSE
[17:44:50.404] - force: TRUE
[17:44:50.404] - relayed: [n=2] TRUE, FALSE
[17:44:50.404] - queued futures: [n=2] TRUE, FALSE
[17:44:50.405]  - until=2
[17:44:50.405]  - relaying element #2
[17:44:50.405] result() for ClusterFuture ...
[17:44:50.405] - result already collected: FutureResult
[17:44:50.405] result() for ClusterFuture ... done
[17:44:50.405] result() for ClusterFuture ...
[17:44:50.405] - result already collected: FutureResult
[17:44:50.405] result() for ClusterFuture ... done
[17:44:50.405] result() for ClusterFuture ...
[17:44:50.405] - result already collected: FutureResult
[17:44:50.405] result() for ClusterFuture ... done
[17:44:50.406] result() for ClusterFuture ...
[17:44:50.406] - result already collected: FutureResult
[17:44:50.406] result() for ClusterFuture ... done
[17:44:50.406] - relayed: [n=2] TRUE, TRUE
[17:44:50.406] - queued futures: [n=2] TRUE, TRUE
[17:44:50.406] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.406]  length: 0 (resolved future 2)
[17:44:50.406] Relaying remaining futures
[17:44:50.406] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.406] - nx: 2
[17:44:50.406] - relay: TRUE
[17:44:50.406] - stdout: TRUE
[17:44:50.407] - signal: TRUE
[17:44:50.407] - resignal: FALSE
[17:44:50.407] - force: TRUE
[17:44:50.407] - relayed: [n=2] TRUE, TRUE
[17:44:50.407] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:50.407] - relayed: [n=2] TRUE, TRUE
[17:44:50.407] - queued futures: [n=2] TRUE, TRUE
[17:44:50.407] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.407] resolve() on list ... DONE
[17:44:50.407] result() for ClusterFuture ...
[17:44:50.407] - result already collected: FutureResult
[17:44:50.408] result() for ClusterFuture ... done
[17:44:50.408] result() for ClusterFuture ...
[17:44:50.408] - result already collected: FutureResult
[17:44:50.408] result() for ClusterFuture ... done
[17:44:50.408] result() for ClusterFuture ...
[17:44:50.408] - result already collected: FutureResult
[17:44:50.408] result() for ClusterFuture ... done
[17:44:50.408] result() for ClusterFuture ...
[17:44:50.408] - result already collected: FutureResult
[17:44:50.408] result() for ClusterFuture ... done
[17:44:50.408]  - Number of value chunks collected: 2
[17:44:50.409] Resolving 2 futures (chunks) ... DONE
[17:44:50.409] Reducing values from 2 chunks ...
[17:44:50.409]  - Number of values collected after concatenation: 3
[17:44:50.409]  - Number of values expected: 3
[17:44:50.409] Reducing values from 2 chunks ... DONE
[17:44:50.409] future_mapply() ... DONE
- future_.mapply()
[17:44:50.409] future_mapply() ...
[17:44:50.413] Number of chunks: 2
[17:44:50.413] getGlobalsAndPackagesXApply() ...
[17:44:50.413]  - future.globals: TRUE
[17:44:50.413] getGlobalsAndPackages() ...
[17:44:50.413] Searching for globals...
[17:44:50.415] - globals found: [3] ‘FUN’, ‘+’, ‘seq_len’
[17:44:50.415] Searching for globals ... DONE
[17:44:50.415] Resolving globals: FALSE
[17:44:50.415] The total size of the 1 globals is 1.93 KiB (1976 bytes)
[17:44:50.416] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.93 KiB of class ‘function’)
[17:44:50.416] - globals: [1] ‘FUN’
[17:44:50.416] 
[17:44:50.416] getGlobalsAndPackages() ... DONE
[17:44:50.416]  - globals found/used: [n=1] ‘FUN’
[17:44:50.416]  - needed namespaces: [n=0] 
[17:44:50.416] Finding globals ... DONE
[17:44:50.416] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.417] List of 2
[17:44:50.417]  $ ...future.FUN:function (x, y)  
[17:44:50.417]  $ MoreArgs     : list()
[17:44:50.417]  - attr(*, "where")=List of 2
[17:44:50.417]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.417]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.417]  - attr(*, "resolved")= logi FALSE
[17:44:50.417]  - attr(*, "total_size")= num NA
[17:44:50.419] Packages to be attached in all futures: [n=0] 
[17:44:50.419] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.419] Number of futures (= number of chunks): 2
[17:44:50.419] Launching 2 futures (chunks) ...
[17:44:50.420] Chunk #1 of 2 ...
[17:44:50.420]  - Finding globals in '...' for chunk #1 ...
[17:44:50.420] getGlobalsAndPackages() ...
[17:44:50.420] Searching for globals...
[17:44:50.420] 
[17:44:50.420] Searching for globals ... DONE
[17:44:50.420] - globals: [0] <none>
[17:44:50.420] getGlobalsAndPackages() ... DONE
[17:44:50.421]    + additional globals found: [n=0] 
[17:44:50.421]    + additional namespaces needed: [n=0] 
[17:44:50.421]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.421]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.421]  - seeds: <none>
[17:44:50.421]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.421] getGlobalsAndPackages() ...
[17:44:50.421] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.421] Resolving globals: FALSE
[17:44:50.422] The total size of the 5 globals is 2.04 KiB (2088 bytes)
[17:44:50.422] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.04 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:50.422] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.422] 
[17:44:50.422] getGlobalsAndPackages() ... DONE
[17:44:50.423] run() for ‘Future’ ...
[17:44:50.423] - state: ‘created’
[17:44:50.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.437] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.437]   - Field: ‘node’
[17:44:50.437]   - Field: ‘label’
[17:44:50.437]   - Field: ‘local’
[17:44:50.438]   - Field: ‘owner’
[17:44:50.438]   - Field: ‘envir’
[17:44:50.438]   - Field: ‘workers’
[17:44:50.438]   - Field: ‘packages’
[17:44:50.438]   - Field: ‘gc’
[17:44:50.438]   - Field: ‘conditions’
[17:44:50.438]   - Field: ‘persistent’
[17:44:50.438]   - Field: ‘expr’
[17:44:50.438]   - Field: ‘uuid’
[17:44:50.438]   - Field: ‘seed’
[17:44:50.438]   - Field: ‘version’
[17:44:50.439]   - Field: ‘result’
[17:44:50.439]   - Field: ‘asynchronous’
[17:44:50.439]   - Field: ‘calls’
[17:44:50.439]   - Field: ‘globals’
[17:44:50.439]   - Field: ‘stdout’
[17:44:50.439]   - Field: ‘earlySignal’
[17:44:50.439]   - Field: ‘lazy’
[17:44:50.439]   - Field: ‘state’
[17:44:50.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.439] - Launch lazy future ...
[17:44:50.440] Packages needed by the future expression (n = 0): <none>
[17:44:50.440] Packages needed by future strategies (n = 0): <none>
[17:44:50.440] {
[17:44:50.440]     {
[17:44:50.440]         {
[17:44:50.440]             ...future.startTime <- base::Sys.time()
[17:44:50.440]             {
[17:44:50.440]                 {
[17:44:50.440]                   {
[17:44:50.440]                     {
[17:44:50.440]                       base::local({
[17:44:50.440]                         has_future <- base::requireNamespace("future", 
[17:44:50.440]                           quietly = TRUE)
[17:44:50.440]                         if (has_future) {
[17:44:50.440]                           ns <- base::getNamespace("future")
[17:44:50.440]                           version <- ns[[".package"]][["version"]]
[17:44:50.440]                           if (is.null(version)) 
[17:44:50.440]                             version <- utils::packageVersion("future")
[17:44:50.440]                         }
[17:44:50.440]                         else {
[17:44:50.440]                           version <- NULL
[17:44:50.440]                         }
[17:44:50.440]                         if (!has_future || version < "1.8.0") {
[17:44:50.440]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.440]                             "", base::R.version$version.string), 
[17:44:50.440]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.440]                               "release", "version")], collapse = " "), 
[17:44:50.440]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.440]                             info)
[17:44:50.440]                           info <- base::paste(info, collapse = "; ")
[17:44:50.440]                           if (!has_future) {
[17:44:50.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.440]                               info)
[17:44:50.440]                           }
[17:44:50.440]                           else {
[17:44:50.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.440]                               info, version)
[17:44:50.440]                           }
[17:44:50.440]                           base::stop(msg)
[17:44:50.440]                         }
[17:44:50.440]                       })
[17:44:50.440]                     }
[17:44:50.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.440]                     base::options(mc.cores = 1L)
[17:44:50.440]                   }
[17:44:50.440]                   ...future.strategy.old <- future::plan("list")
[17:44:50.440]                   options(future.plan = NULL)
[17:44:50.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.440]                 }
[17:44:50.440]                 ...future.workdir <- getwd()
[17:44:50.440]             }
[17:44:50.440]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.440]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.440]         }
[17:44:50.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.440]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.440]             base::names(...future.oldOptions))
[17:44:50.440]     }
[17:44:50.440]     if (FALSE) {
[17:44:50.440]     }
[17:44:50.440]     else {
[17:44:50.440]         if (TRUE) {
[17:44:50.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.440]                 open = "w")
[17:44:50.440]         }
[17:44:50.440]         else {
[17:44:50.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.440]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.440]         }
[17:44:50.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.440]             base::sink(type = "output", split = FALSE)
[17:44:50.440]             base::close(...future.stdout)
[17:44:50.440]         }, add = TRUE)
[17:44:50.440]     }
[17:44:50.440]     ...future.frame <- base::sys.nframe()
[17:44:50.440]     ...future.conditions <- base::list()
[17:44:50.440]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.440]     if (FALSE) {
[17:44:50.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.440]     }
[17:44:50.440]     ...future.result <- base::tryCatch({
[17:44:50.440]         base::withCallingHandlers({
[17:44:50.440]             ...future.value <- base::withVisible(base::local({
[17:44:50.440]                 ...future.makeSendCondition <- base::local({
[17:44:50.440]                   sendCondition <- NULL
[17:44:50.440]                   function(frame = 1L) {
[17:44:50.440]                     if (is.function(sendCondition)) 
[17:44:50.440]                       return(sendCondition)
[17:44:50.440]                     ns <- getNamespace("parallel")
[17:44:50.440]                     if (exists("sendData", mode = "function", 
[17:44:50.440]                       envir = ns)) {
[17:44:50.440]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.440]                         envir = ns)
[17:44:50.440]                       envir <- sys.frame(frame)
[17:44:50.440]                       master <- NULL
[17:44:50.440]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.440]                         !identical(envir, emptyenv())) {
[17:44:50.440]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.440]                           inherits = FALSE)) {
[17:44:50.440]                           master <- get("master", mode = "list", 
[17:44:50.440]                             envir = envir, inherits = FALSE)
[17:44:50.440]                           if (inherits(master, c("SOCKnode", 
[17:44:50.440]                             "SOCK0node"))) {
[17:44:50.440]                             sendCondition <<- function(cond) {
[17:44:50.440]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.440]                                 success = TRUE)
[17:44:50.440]                               parallel_sendData(master, data)
[17:44:50.440]                             }
[17:44:50.440]                             return(sendCondition)
[17:44:50.440]                           }
[17:44:50.440]                         }
[17:44:50.440]                         frame <- frame + 1L
[17:44:50.440]                         envir <- sys.frame(frame)
[17:44:50.440]                       }
[17:44:50.440]                     }
[17:44:50.440]                     sendCondition <<- function(cond) NULL
[17:44:50.440]                   }
[17:44:50.440]                 })
[17:44:50.440]                 withCallingHandlers({
[17:44:50.440]                   {
[17:44:50.440]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.440]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.440]                       ...future.globals.maxSize)) {
[17:44:50.440]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.440]                       on.exit(options(oopts), add = TRUE)
[17:44:50.440]                     }
[17:44:50.440]                     {
[17:44:50.440]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.440]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.440]                         USE.NAMES = FALSE)
[17:44:50.440]                       do.call(mapply, args = args)
[17:44:50.440]                     }
[17:44:50.440]                   }
[17:44:50.440]                 }, immediateCondition = function(cond) {
[17:44:50.440]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.440]                   sendCondition(cond)
[17:44:50.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.440]                   {
[17:44:50.440]                     inherits <- base::inherits
[17:44:50.440]                     invokeRestart <- base::invokeRestart
[17:44:50.440]                     is.null <- base::is.null
[17:44:50.440]                     muffled <- FALSE
[17:44:50.440]                     if (inherits(cond, "message")) {
[17:44:50.440]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.440]                       if (muffled) 
[17:44:50.440]                         invokeRestart("muffleMessage")
[17:44:50.440]                     }
[17:44:50.440]                     else if (inherits(cond, "warning")) {
[17:44:50.440]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.440]                       if (muffled) 
[17:44:50.440]                         invokeRestart("muffleWarning")
[17:44:50.440]                     }
[17:44:50.440]                     else if (inherits(cond, "condition")) {
[17:44:50.440]                       if (!is.null(pattern)) {
[17:44:50.440]                         computeRestarts <- base::computeRestarts
[17:44:50.440]                         grepl <- base::grepl
[17:44:50.440]                         restarts <- computeRestarts(cond)
[17:44:50.440]                         for (restart in restarts) {
[17:44:50.440]                           name <- restart$name
[17:44:50.440]                           if (is.null(name)) 
[17:44:50.440]                             next
[17:44:50.440]                           if (!grepl(pattern, name)) 
[17:44:50.440]                             next
[17:44:50.440]                           invokeRestart(restart)
[17:44:50.440]                           muffled <- TRUE
[17:44:50.440]                           break
[17:44:50.440]                         }
[17:44:50.440]                       }
[17:44:50.440]                     }
[17:44:50.440]                     invisible(muffled)
[17:44:50.440]                   }
[17:44:50.440]                   muffleCondition(cond)
[17:44:50.440]                 })
[17:44:50.440]             }))
[17:44:50.440]             future::FutureResult(value = ...future.value$value, 
[17:44:50.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.440]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.440]                     ...future.globalenv.names))
[17:44:50.440]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.440]         }, condition = base::local({
[17:44:50.440]             c <- base::c
[17:44:50.440]             inherits <- base::inherits
[17:44:50.440]             invokeRestart <- base::invokeRestart
[17:44:50.440]             length <- base::length
[17:44:50.440]             list <- base::list
[17:44:50.440]             seq.int <- base::seq.int
[17:44:50.440]             signalCondition <- base::signalCondition
[17:44:50.440]             sys.calls <- base::sys.calls
[17:44:50.440]             `[[` <- base::`[[`
[17:44:50.440]             `+` <- base::`+`
[17:44:50.440]             `<<-` <- base::`<<-`
[17:44:50.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.440]                   3L)]
[17:44:50.440]             }
[17:44:50.440]             function(cond) {
[17:44:50.440]                 is_error <- inherits(cond, "error")
[17:44:50.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.440]                   NULL)
[17:44:50.440]                 if (is_error) {
[17:44:50.440]                   sessionInformation <- function() {
[17:44:50.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.440]                       search = base::search(), system = base::Sys.info())
[17:44:50.440]                   }
[17:44:50.440]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.440]                     cond$call), session = sessionInformation(), 
[17:44:50.440]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.440]                   signalCondition(cond)
[17:44:50.440]                 }
[17:44:50.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.440]                 "immediateCondition"))) {
[17:44:50.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.440]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.440]                   if (TRUE && !signal) {
[17:44:50.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.440]                     {
[17:44:50.440]                       inherits <- base::inherits
[17:44:50.440]                       invokeRestart <- base::invokeRestart
[17:44:50.440]                       is.null <- base::is.null
[17:44:50.440]                       muffled <- FALSE
[17:44:50.440]                       if (inherits(cond, "message")) {
[17:44:50.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.440]                         if (muffled) 
[17:44:50.440]                           invokeRestart("muffleMessage")
[17:44:50.440]                       }
[17:44:50.440]                       else if (inherits(cond, "warning")) {
[17:44:50.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.440]                         if (muffled) 
[17:44:50.440]                           invokeRestart("muffleWarning")
[17:44:50.440]                       }
[17:44:50.440]                       else if (inherits(cond, "condition")) {
[17:44:50.440]                         if (!is.null(pattern)) {
[17:44:50.440]                           computeRestarts <- base::computeRestarts
[17:44:50.440]                           grepl <- base::grepl
[17:44:50.440]                           restarts <- computeRestarts(cond)
[17:44:50.440]                           for (restart in restarts) {
[17:44:50.440]                             name <- restart$name
[17:44:50.440]                             if (is.null(name)) 
[17:44:50.440]                               next
[17:44:50.440]                             if (!grepl(pattern, name)) 
[17:44:50.440]                               next
[17:44:50.440]                             invokeRestart(restart)
[17:44:50.440]                             muffled <- TRUE
[17:44:50.440]                             break
[17:44:50.440]                           }
[17:44:50.440]                         }
[17:44:50.440]                       }
[17:44:50.440]                       invisible(muffled)
[17:44:50.440]                     }
[17:44:50.440]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.440]                   }
[17:44:50.440]                 }
[17:44:50.440]                 else {
[17:44:50.440]                   if (TRUE) {
[17:44:50.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.440]                     {
[17:44:50.440]                       inherits <- base::inherits
[17:44:50.440]                       invokeRestart <- base::invokeRestart
[17:44:50.440]                       is.null <- base::is.null
[17:44:50.440]                       muffled <- FALSE
[17:44:50.440]                       if (inherits(cond, "message")) {
[17:44:50.440]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.440]                         if (muffled) 
[17:44:50.440]                           invokeRestart("muffleMessage")
[17:44:50.440]                       }
[17:44:50.440]                       else if (inherits(cond, "warning")) {
[17:44:50.440]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.440]                         if (muffled) 
[17:44:50.440]                           invokeRestart("muffleWarning")
[17:44:50.440]                       }
[17:44:50.440]                       else if (inherits(cond, "condition")) {
[17:44:50.440]                         if (!is.null(pattern)) {
[17:44:50.440]                           computeRestarts <- base::computeRestarts
[17:44:50.440]                           grepl <- base::grepl
[17:44:50.440]                           restarts <- computeRestarts(cond)
[17:44:50.440]                           for (restart in restarts) {
[17:44:50.440]                             name <- restart$name
[17:44:50.440]                             if (is.null(name)) 
[17:44:50.440]                               next
[17:44:50.440]                             if (!grepl(pattern, name)) 
[17:44:50.440]                               next
[17:44:50.440]                             invokeRestart(restart)
[17:44:50.440]                             muffled <- TRUE
[17:44:50.440]                             break
[17:44:50.440]                           }
[17:44:50.440]                         }
[17:44:50.440]                       }
[17:44:50.440]                       invisible(muffled)
[17:44:50.440]                     }
[17:44:50.440]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.440]                   }
[17:44:50.440]                 }
[17:44:50.440]             }
[17:44:50.440]         }))
[17:44:50.440]     }, error = function(ex) {
[17:44:50.440]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.440]                 ...future.rng), started = ...future.startTime, 
[17:44:50.440]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.440]             version = "1.8"), class = "FutureResult")
[17:44:50.440]     }, finally = {
[17:44:50.440]         if (!identical(...future.workdir, getwd())) 
[17:44:50.440]             setwd(...future.workdir)
[17:44:50.440]         {
[17:44:50.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.440]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.440]             }
[17:44:50.440]             base::options(...future.oldOptions)
[17:44:50.440]             if (.Platform$OS.type == "windows") {
[17:44:50.440]                 old_names <- names(...future.oldEnvVars)
[17:44:50.440]                 envs <- base::Sys.getenv()
[17:44:50.440]                 names <- names(envs)
[17:44:50.440]                 common <- intersect(names, old_names)
[17:44:50.440]                 added <- setdiff(names, old_names)
[17:44:50.440]                 removed <- setdiff(old_names, names)
[17:44:50.440]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.440]                   envs[common]]
[17:44:50.440]                 NAMES <- toupper(changed)
[17:44:50.440]                 args <- list()
[17:44:50.440]                 for (kk in seq_along(NAMES)) {
[17:44:50.440]                   name <- changed[[kk]]
[17:44:50.440]                   NAME <- NAMES[[kk]]
[17:44:50.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.440]                     next
[17:44:50.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.440]                 }
[17:44:50.440]                 NAMES <- toupper(added)
[17:44:50.440]                 for (kk in seq_along(NAMES)) {
[17:44:50.440]                   name <- added[[kk]]
[17:44:50.440]                   NAME <- NAMES[[kk]]
[17:44:50.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.440]                     next
[17:44:50.440]                   args[[name]] <- ""
[17:44:50.440]                 }
[17:44:50.440]                 NAMES <- toupper(removed)
[17:44:50.440]                 for (kk in seq_along(NAMES)) {
[17:44:50.440]                   name <- removed[[kk]]
[17:44:50.440]                   NAME <- NAMES[[kk]]
[17:44:50.440]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.440]                     next
[17:44:50.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.440]                 }
[17:44:50.440]                 if (length(args) > 0) 
[17:44:50.440]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.440]             }
[17:44:50.440]             else {
[17:44:50.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.440]             }
[17:44:50.440]             {
[17:44:50.440]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.440]                   0L) {
[17:44:50.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.440]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.440]                   base::options(opts)
[17:44:50.440]                 }
[17:44:50.440]                 {
[17:44:50.440]                   {
[17:44:50.440]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.440]                     NULL
[17:44:50.440]                   }
[17:44:50.440]                   options(future.plan = NULL)
[17:44:50.440]                   if (is.na(NA_character_)) 
[17:44:50.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.440]                     .init = FALSE)
[17:44:50.440]                 }
[17:44:50.440]             }
[17:44:50.440]         }
[17:44:50.440]     })
[17:44:50.440]     if (TRUE) {
[17:44:50.440]         base::sink(type = "output", split = FALSE)
[17:44:50.440]         if (TRUE) {
[17:44:50.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.440]         }
[17:44:50.440]         else {
[17:44:50.440]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.440]         }
[17:44:50.440]         base::close(...future.stdout)
[17:44:50.440]         ...future.stdout <- NULL
[17:44:50.440]     }
[17:44:50.440]     ...future.result$conditions <- ...future.conditions
[17:44:50.440]     ...future.result$finished <- base::Sys.time()
[17:44:50.440]     ...future.result
[17:44:50.440] }
[17:44:50.443] Exporting 5 global objects (2.04 KiB) to cluster node #1 ...
[17:44:50.443] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ...
[17:44:50.443] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #1 ... DONE
[17:44:50.444] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.444] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.444] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:44:50.444] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:44:50.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.445] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.445] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.445] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.445] Exporting 5 global objects (2.04 KiB) to cluster node #1 ... DONE
[17:44:50.446] MultisessionFuture started
[17:44:50.446] - Launch lazy future ... done
[17:44:50.446] run() for ‘MultisessionFuture’ ... done
[17:44:50.446] Created future:
[17:44:50.446] MultisessionFuture:
[17:44:50.446] Label: ‘future_.mapply-1’
[17:44:50.446] Expression:
[17:44:50.446] {
[17:44:50.446]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.446]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.446]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.446]         on.exit(options(oopts), add = TRUE)
[17:44:50.446]     }
[17:44:50.446]     {
[17:44:50.446]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.446]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.446]         do.call(mapply, args = args)
[17:44:50.446]     }
[17:44:50.446] }
[17:44:50.446] Lazy evaluation: FALSE
[17:44:50.446] Asynchronous evaluation: TRUE
[17:44:50.446] Local evaluation: TRUE
[17:44:50.446] Environment: R_GlobalEnv
[17:44:50.446] Capture standard output: TRUE
[17:44:50.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.446] Globals: 5 objects totaling 2.04 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.446] Packages: <none>
[17:44:50.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.446] Resolved: FALSE
[17:44:50.446] Value: <not collected>
[17:44:50.446] Conditions captured: <none>
[17:44:50.446] Early signaling: FALSE
[17:44:50.446] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.458] Chunk #1 of 2 ... DONE
[17:44:50.458] Chunk #2 of 2 ...
[17:44:50.458]  - Finding globals in '...' for chunk #2 ...
[17:44:50.458] getGlobalsAndPackages() ...
[17:44:50.458] Searching for globals...
[17:44:50.458] 
[17:44:50.459] Searching for globals ... DONE
[17:44:50.459] - globals: [0] <none>
[17:44:50.459] getGlobalsAndPackages() ... DONE
[17:44:50.459]    + additional globals found: [n=0] 
[17:44:50.459]    + additional namespaces needed: [n=0] 
[17:44:50.459]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.459]  - seeds: <none>
[17:44:50.459]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.459] getGlobalsAndPackages() ...
[17:44:50.459] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.460] Resolving globals: FALSE
[17:44:50.460] The total size of the 5 globals is 2.15 KiB (2200 bytes)
[17:44:50.461] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.15 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.93 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:50.461] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.461] 
[17:44:50.461] getGlobalsAndPackages() ... DONE
[17:44:50.461] run() for ‘Future’ ...
[17:44:50.461] - state: ‘created’
[17:44:50.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.476]   - Field: ‘node’
[17:44:50.477]   - Field: ‘label’
[17:44:50.477]   - Field: ‘local’
[17:44:50.477]   - Field: ‘owner’
[17:44:50.477]   - Field: ‘envir’
[17:44:50.477]   - Field: ‘workers’
[17:44:50.477]   - Field: ‘packages’
[17:44:50.477]   - Field: ‘gc’
[17:44:50.477]   - Field: ‘conditions’
[17:44:50.477]   - Field: ‘persistent’
[17:44:50.477]   - Field: ‘expr’
[17:44:50.478]   - Field: ‘uuid’
[17:44:50.478]   - Field: ‘seed’
[17:44:50.478]   - Field: ‘version’
[17:44:50.478]   - Field: ‘result’
[17:44:50.478]   - Field: ‘asynchronous’
[17:44:50.478]   - Field: ‘calls’
[17:44:50.478]   - Field: ‘globals’
[17:44:50.478]   - Field: ‘stdout’
[17:44:50.478]   - Field: ‘earlySignal’
[17:44:50.478]   - Field: ‘lazy’
[17:44:50.478]   - Field: ‘state’
[17:44:50.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.479] - Launch lazy future ...
[17:44:50.479] Packages needed by the future expression (n = 0): <none>
[17:44:50.479] Packages needed by future strategies (n = 0): <none>
[17:44:50.480] {
[17:44:50.480]     {
[17:44:50.480]         {
[17:44:50.480]             ...future.startTime <- base::Sys.time()
[17:44:50.480]             {
[17:44:50.480]                 {
[17:44:50.480]                   {
[17:44:50.480]                     {
[17:44:50.480]                       base::local({
[17:44:50.480]                         has_future <- base::requireNamespace("future", 
[17:44:50.480]                           quietly = TRUE)
[17:44:50.480]                         if (has_future) {
[17:44:50.480]                           ns <- base::getNamespace("future")
[17:44:50.480]                           version <- ns[[".package"]][["version"]]
[17:44:50.480]                           if (is.null(version)) 
[17:44:50.480]                             version <- utils::packageVersion("future")
[17:44:50.480]                         }
[17:44:50.480]                         else {
[17:44:50.480]                           version <- NULL
[17:44:50.480]                         }
[17:44:50.480]                         if (!has_future || version < "1.8.0") {
[17:44:50.480]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.480]                             "", base::R.version$version.string), 
[17:44:50.480]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.480]                               "release", "version")], collapse = " "), 
[17:44:50.480]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.480]                             info)
[17:44:50.480]                           info <- base::paste(info, collapse = "; ")
[17:44:50.480]                           if (!has_future) {
[17:44:50.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.480]                               info)
[17:44:50.480]                           }
[17:44:50.480]                           else {
[17:44:50.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.480]                               info, version)
[17:44:50.480]                           }
[17:44:50.480]                           base::stop(msg)
[17:44:50.480]                         }
[17:44:50.480]                       })
[17:44:50.480]                     }
[17:44:50.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.480]                     base::options(mc.cores = 1L)
[17:44:50.480]                   }
[17:44:50.480]                   ...future.strategy.old <- future::plan("list")
[17:44:50.480]                   options(future.plan = NULL)
[17:44:50.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.480]                 }
[17:44:50.480]                 ...future.workdir <- getwd()
[17:44:50.480]             }
[17:44:50.480]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.480]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.480]         }
[17:44:50.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.480]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.480]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.480]             base::names(...future.oldOptions))
[17:44:50.480]     }
[17:44:50.480]     if (FALSE) {
[17:44:50.480]     }
[17:44:50.480]     else {
[17:44:50.480]         if (TRUE) {
[17:44:50.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.480]                 open = "w")
[17:44:50.480]         }
[17:44:50.480]         else {
[17:44:50.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.480]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.480]         }
[17:44:50.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.480]             base::sink(type = "output", split = FALSE)
[17:44:50.480]             base::close(...future.stdout)
[17:44:50.480]         }, add = TRUE)
[17:44:50.480]     }
[17:44:50.480]     ...future.frame <- base::sys.nframe()
[17:44:50.480]     ...future.conditions <- base::list()
[17:44:50.480]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.480]     if (FALSE) {
[17:44:50.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.480]     }
[17:44:50.480]     ...future.result <- base::tryCatch({
[17:44:50.480]         base::withCallingHandlers({
[17:44:50.480]             ...future.value <- base::withVisible(base::local({
[17:44:50.480]                 ...future.makeSendCondition <- base::local({
[17:44:50.480]                   sendCondition <- NULL
[17:44:50.480]                   function(frame = 1L) {
[17:44:50.480]                     if (is.function(sendCondition)) 
[17:44:50.480]                       return(sendCondition)
[17:44:50.480]                     ns <- getNamespace("parallel")
[17:44:50.480]                     if (exists("sendData", mode = "function", 
[17:44:50.480]                       envir = ns)) {
[17:44:50.480]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.480]                         envir = ns)
[17:44:50.480]                       envir <- sys.frame(frame)
[17:44:50.480]                       master <- NULL
[17:44:50.480]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.480]                         !identical(envir, emptyenv())) {
[17:44:50.480]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.480]                           inherits = FALSE)) {
[17:44:50.480]                           master <- get("master", mode = "list", 
[17:44:50.480]                             envir = envir, inherits = FALSE)
[17:44:50.480]                           if (inherits(master, c("SOCKnode", 
[17:44:50.480]                             "SOCK0node"))) {
[17:44:50.480]                             sendCondition <<- function(cond) {
[17:44:50.480]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.480]                                 success = TRUE)
[17:44:50.480]                               parallel_sendData(master, data)
[17:44:50.480]                             }
[17:44:50.480]                             return(sendCondition)
[17:44:50.480]                           }
[17:44:50.480]                         }
[17:44:50.480]                         frame <- frame + 1L
[17:44:50.480]                         envir <- sys.frame(frame)
[17:44:50.480]                       }
[17:44:50.480]                     }
[17:44:50.480]                     sendCondition <<- function(cond) NULL
[17:44:50.480]                   }
[17:44:50.480]                 })
[17:44:50.480]                 withCallingHandlers({
[17:44:50.480]                   {
[17:44:50.480]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.480]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.480]                       ...future.globals.maxSize)) {
[17:44:50.480]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.480]                       on.exit(options(oopts), add = TRUE)
[17:44:50.480]                     }
[17:44:50.480]                     {
[17:44:50.480]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.480]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.480]                         USE.NAMES = FALSE)
[17:44:50.480]                       do.call(mapply, args = args)
[17:44:50.480]                     }
[17:44:50.480]                   }
[17:44:50.480]                 }, immediateCondition = function(cond) {
[17:44:50.480]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.480]                   sendCondition(cond)
[17:44:50.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.480]                   {
[17:44:50.480]                     inherits <- base::inherits
[17:44:50.480]                     invokeRestart <- base::invokeRestart
[17:44:50.480]                     is.null <- base::is.null
[17:44:50.480]                     muffled <- FALSE
[17:44:50.480]                     if (inherits(cond, "message")) {
[17:44:50.480]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.480]                       if (muffled) 
[17:44:50.480]                         invokeRestart("muffleMessage")
[17:44:50.480]                     }
[17:44:50.480]                     else if (inherits(cond, "warning")) {
[17:44:50.480]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.480]                       if (muffled) 
[17:44:50.480]                         invokeRestart("muffleWarning")
[17:44:50.480]                     }
[17:44:50.480]                     else if (inherits(cond, "condition")) {
[17:44:50.480]                       if (!is.null(pattern)) {
[17:44:50.480]                         computeRestarts <- base::computeRestarts
[17:44:50.480]                         grepl <- base::grepl
[17:44:50.480]                         restarts <- computeRestarts(cond)
[17:44:50.480]                         for (restart in restarts) {
[17:44:50.480]                           name <- restart$name
[17:44:50.480]                           if (is.null(name)) 
[17:44:50.480]                             next
[17:44:50.480]                           if (!grepl(pattern, name)) 
[17:44:50.480]                             next
[17:44:50.480]                           invokeRestart(restart)
[17:44:50.480]                           muffled <- TRUE
[17:44:50.480]                           break
[17:44:50.480]                         }
[17:44:50.480]                       }
[17:44:50.480]                     }
[17:44:50.480]                     invisible(muffled)
[17:44:50.480]                   }
[17:44:50.480]                   muffleCondition(cond)
[17:44:50.480]                 })
[17:44:50.480]             }))
[17:44:50.480]             future::FutureResult(value = ...future.value$value, 
[17:44:50.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.480]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.480]                     ...future.globalenv.names))
[17:44:50.480]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.480]         }, condition = base::local({
[17:44:50.480]             c <- base::c
[17:44:50.480]             inherits <- base::inherits
[17:44:50.480]             invokeRestart <- base::invokeRestart
[17:44:50.480]             length <- base::length
[17:44:50.480]             list <- base::list
[17:44:50.480]             seq.int <- base::seq.int
[17:44:50.480]             signalCondition <- base::signalCondition
[17:44:50.480]             sys.calls <- base::sys.calls
[17:44:50.480]             `[[` <- base::`[[`
[17:44:50.480]             `+` <- base::`+`
[17:44:50.480]             `<<-` <- base::`<<-`
[17:44:50.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.480]                   3L)]
[17:44:50.480]             }
[17:44:50.480]             function(cond) {
[17:44:50.480]                 is_error <- inherits(cond, "error")
[17:44:50.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.480]                   NULL)
[17:44:50.480]                 if (is_error) {
[17:44:50.480]                   sessionInformation <- function() {
[17:44:50.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.480]                       search = base::search(), system = base::Sys.info())
[17:44:50.480]                   }
[17:44:50.480]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.480]                     cond$call), session = sessionInformation(), 
[17:44:50.480]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.480]                   signalCondition(cond)
[17:44:50.480]                 }
[17:44:50.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.480]                 "immediateCondition"))) {
[17:44:50.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.480]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.480]                   if (TRUE && !signal) {
[17:44:50.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.480]                     {
[17:44:50.480]                       inherits <- base::inherits
[17:44:50.480]                       invokeRestart <- base::invokeRestart
[17:44:50.480]                       is.null <- base::is.null
[17:44:50.480]                       muffled <- FALSE
[17:44:50.480]                       if (inherits(cond, "message")) {
[17:44:50.480]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.480]                         if (muffled) 
[17:44:50.480]                           invokeRestart("muffleMessage")
[17:44:50.480]                       }
[17:44:50.480]                       else if (inherits(cond, "warning")) {
[17:44:50.480]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.480]                         if (muffled) 
[17:44:50.480]                           invokeRestart("muffleWarning")
[17:44:50.480]                       }
[17:44:50.480]                       else if (inherits(cond, "condition")) {
[17:44:50.480]                         if (!is.null(pattern)) {
[17:44:50.480]                           computeRestarts <- base::computeRestarts
[17:44:50.480]                           grepl <- base::grepl
[17:44:50.480]                           restarts <- computeRestarts(cond)
[17:44:50.480]                           for (restart in restarts) {
[17:44:50.480]                             name <- restart$name
[17:44:50.480]                             if (is.null(name)) 
[17:44:50.480]                               next
[17:44:50.480]                             if (!grepl(pattern, name)) 
[17:44:50.480]                               next
[17:44:50.480]                             invokeRestart(restart)
[17:44:50.480]                             muffled <- TRUE
[17:44:50.480]                             break
[17:44:50.480]                           }
[17:44:50.480]                         }
[17:44:50.480]                       }
[17:44:50.480]                       invisible(muffled)
[17:44:50.480]                     }
[17:44:50.480]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.480]                   }
[17:44:50.480]                 }
[17:44:50.480]                 else {
[17:44:50.480]                   if (TRUE) {
[17:44:50.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.480]                     {
[17:44:50.480]                       inherits <- base::inherits
[17:44:50.480]                       invokeRestart <- base::invokeRestart
[17:44:50.480]                       is.null <- base::is.null
[17:44:50.480]                       muffled <- FALSE
[17:44:50.480]                       if (inherits(cond, "message")) {
[17:44:50.480]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.480]                         if (muffled) 
[17:44:50.480]                           invokeRestart("muffleMessage")
[17:44:50.480]                       }
[17:44:50.480]                       else if (inherits(cond, "warning")) {
[17:44:50.480]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.480]                         if (muffled) 
[17:44:50.480]                           invokeRestart("muffleWarning")
[17:44:50.480]                       }
[17:44:50.480]                       else if (inherits(cond, "condition")) {
[17:44:50.480]                         if (!is.null(pattern)) {
[17:44:50.480]                           computeRestarts <- base::computeRestarts
[17:44:50.480]                           grepl <- base::grepl
[17:44:50.480]                           restarts <- computeRestarts(cond)
[17:44:50.480]                           for (restart in restarts) {
[17:44:50.480]                             name <- restart$name
[17:44:50.480]                             if (is.null(name)) 
[17:44:50.480]                               next
[17:44:50.480]                             if (!grepl(pattern, name)) 
[17:44:50.480]                               next
[17:44:50.480]                             invokeRestart(restart)
[17:44:50.480]                             muffled <- TRUE
[17:44:50.480]                             break
[17:44:50.480]                           }
[17:44:50.480]                         }
[17:44:50.480]                       }
[17:44:50.480]                       invisible(muffled)
[17:44:50.480]                     }
[17:44:50.480]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.480]                   }
[17:44:50.480]                 }
[17:44:50.480]             }
[17:44:50.480]         }))
[17:44:50.480]     }, error = function(ex) {
[17:44:50.480]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.480]                 ...future.rng), started = ...future.startTime, 
[17:44:50.480]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.480]             version = "1.8"), class = "FutureResult")
[17:44:50.480]     }, finally = {
[17:44:50.480]         if (!identical(...future.workdir, getwd())) 
[17:44:50.480]             setwd(...future.workdir)
[17:44:50.480]         {
[17:44:50.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.480]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.480]             }
[17:44:50.480]             base::options(...future.oldOptions)
[17:44:50.480]             if (.Platform$OS.type == "windows") {
[17:44:50.480]                 old_names <- names(...future.oldEnvVars)
[17:44:50.480]                 envs <- base::Sys.getenv()
[17:44:50.480]                 names <- names(envs)
[17:44:50.480]                 common <- intersect(names, old_names)
[17:44:50.480]                 added <- setdiff(names, old_names)
[17:44:50.480]                 removed <- setdiff(old_names, names)
[17:44:50.480]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.480]                   envs[common]]
[17:44:50.480]                 NAMES <- toupper(changed)
[17:44:50.480]                 args <- list()
[17:44:50.480]                 for (kk in seq_along(NAMES)) {
[17:44:50.480]                   name <- changed[[kk]]
[17:44:50.480]                   NAME <- NAMES[[kk]]
[17:44:50.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.480]                     next
[17:44:50.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.480]                 }
[17:44:50.480]                 NAMES <- toupper(added)
[17:44:50.480]                 for (kk in seq_along(NAMES)) {
[17:44:50.480]                   name <- added[[kk]]
[17:44:50.480]                   NAME <- NAMES[[kk]]
[17:44:50.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.480]                     next
[17:44:50.480]                   args[[name]] <- ""
[17:44:50.480]                 }
[17:44:50.480]                 NAMES <- toupper(removed)
[17:44:50.480]                 for (kk in seq_along(NAMES)) {
[17:44:50.480]                   name <- removed[[kk]]
[17:44:50.480]                   NAME <- NAMES[[kk]]
[17:44:50.480]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.480]                     next
[17:44:50.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.480]                 }
[17:44:50.480]                 if (length(args) > 0) 
[17:44:50.480]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.480]             }
[17:44:50.480]             else {
[17:44:50.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.480]             }
[17:44:50.480]             {
[17:44:50.480]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.480]                   0L) {
[17:44:50.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.480]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.480]                   base::options(opts)
[17:44:50.480]                 }
[17:44:50.480]                 {
[17:44:50.480]                   {
[17:44:50.480]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.480]                     NULL
[17:44:50.480]                   }
[17:44:50.480]                   options(future.plan = NULL)
[17:44:50.480]                   if (is.na(NA_character_)) 
[17:44:50.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.480]                     .init = FALSE)
[17:44:50.480]                 }
[17:44:50.480]             }
[17:44:50.480]         }
[17:44:50.480]     })
[17:44:50.480]     if (TRUE) {
[17:44:50.480]         base::sink(type = "output", split = FALSE)
[17:44:50.480]         if (TRUE) {
[17:44:50.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.480]         }
[17:44:50.480]         else {
[17:44:50.480]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.480]         }
[17:44:50.480]         base::close(...future.stdout)
[17:44:50.480]         ...future.stdout <- NULL
[17:44:50.480]     }
[17:44:50.480]     ...future.result$conditions <- ...future.conditions
[17:44:50.480]     ...future.result$finished <- base::Sys.time()
[17:44:50.480]     ...future.result
[17:44:50.480] }
[17:44:50.482] Exporting 5 global objects (2.15 KiB) to cluster node #2 ...
[17:44:50.483] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ...
[17:44:50.483] Exporting ‘...future.FUN’ (1.93 KiB) to cluster node #2 ... DONE
[17:44:50.485] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.486] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.486] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:50.486] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:50.486] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.486] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.487] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.487] Exporting 5 global objects (2.15 KiB) to cluster node #2 ... DONE
[17:44:50.488] MultisessionFuture started
[17:44:50.488] - Launch lazy future ... done
[17:44:50.488] run() for ‘MultisessionFuture’ ... done
[17:44:50.488] Created future:
[17:44:50.490] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.490] - Validating connection of MultisessionFuture
[17:44:50.490] - received message: FutureResult
[17:44:50.490] - Received FutureResult
[17:44:50.490] - Erased future from FutureRegistry
[17:44:50.490] result() for ClusterFuture ...
[17:44:50.490] - result already collected: FutureResult
[17:44:50.490] result() for ClusterFuture ... done
[17:44:50.491] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.488] MultisessionFuture:
[17:44:50.488] Label: ‘future_.mapply-2’
[17:44:50.488] Expression:
[17:44:50.488] {
[17:44:50.488]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.488]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.488]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.488]         on.exit(options(oopts), add = TRUE)
[17:44:50.488]     }
[17:44:50.488]     {
[17:44:50.488]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.488]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.488]         do.call(mapply, args = args)
[17:44:50.488]     }
[17:44:50.488] }
[17:44:50.488] Lazy evaluation: FALSE
[17:44:50.488] Asynchronous evaluation: TRUE
[17:44:50.488] Local evaluation: TRUE
[17:44:50.488] Environment: R_GlobalEnv
[17:44:50.488] Capture standard output: TRUE
[17:44:50.488] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.488] Globals: 5 objects totaling 2.15 KiB (function ‘...future.FUN’ of 1.93 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.488] Packages: <none>
[17:44:50.488] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.488] Resolved: TRUE
[17:44:50.488] Value: <not collected>
[17:44:50.488] Conditions captured: <none>
[17:44:50.488] Early signaling: FALSE
[17:44:50.488] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.488] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.491] Chunk #2 of 2 ... DONE
[17:44:50.491] Launching 2 futures (chunks) ... DONE
[17:44:50.491] Resolving 2 futures (chunks) ...
[17:44:50.491] resolve() on list ...
[17:44:50.491]  recursive: 0
[17:44:50.491]  length: 2
[17:44:50.491] 
[17:44:50.492] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.492] - Validating connection of MultisessionFuture
[17:44:50.492] - received message: FutureResult
[17:44:50.492] - Received FutureResult
[17:44:50.492] - Erased future from FutureRegistry
[17:44:50.492] result() for ClusterFuture ...
[17:44:50.493] - result already collected: FutureResult
[17:44:50.493] result() for ClusterFuture ... done
[17:44:50.493] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.493] Future #1
[17:44:50.493] result() for ClusterFuture ...
[17:44:50.493] - result already collected: FutureResult
[17:44:50.493] result() for ClusterFuture ... done
[17:44:50.493] result() for ClusterFuture ...
[17:44:50.493] - result already collected: FutureResult
[17:44:50.493] result() for ClusterFuture ... done
[17:44:50.493] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.494] - nx: 2
[17:44:50.494] - relay: TRUE
[17:44:50.494] - stdout: TRUE
[17:44:50.494] - signal: TRUE
[17:44:50.494] - resignal: FALSE
[17:44:50.494] - force: TRUE
[17:44:50.494] - relayed: [n=2] FALSE, FALSE
[17:44:50.494] - queued futures: [n=2] FALSE, FALSE
[17:44:50.494]  - until=1
[17:44:50.494]  - relaying element #1
[17:44:50.494] result() for ClusterFuture ...
[17:44:50.494] - result already collected: FutureResult
[17:44:50.495] result() for ClusterFuture ... done
[17:44:50.495] result() for ClusterFuture ...
[17:44:50.495] - result already collected: FutureResult
[17:44:50.495] result() for ClusterFuture ... done
[17:44:50.495] result() for ClusterFuture ...
[17:44:50.495] - result already collected: FutureResult
[17:44:50.495] result() for ClusterFuture ... done
[17:44:50.495] result() for ClusterFuture ...
[17:44:50.495] - result already collected: FutureResult
[17:44:50.495] result() for ClusterFuture ... done
[17:44:50.495] - relayed: [n=2] TRUE, FALSE
[17:44:50.496] - queued futures: [n=2] TRUE, FALSE
[17:44:50.496] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.496]  length: 1 (resolved future 1)
[17:44:50.496] Future #2
[17:44:50.496] result() for ClusterFuture ...
[17:44:50.496] - result already collected: FutureResult
[17:44:50.496] result() for ClusterFuture ... done
[17:44:50.496] result() for ClusterFuture ...
[17:44:50.496] - result already collected: FutureResult
[17:44:50.496] result() for ClusterFuture ... done
[17:44:50.496] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.497] - nx: 2
[17:44:50.497] - relay: TRUE
[17:44:50.497] - stdout: TRUE
[17:44:50.497] - signal: TRUE
[17:44:50.497] - resignal: FALSE
[17:44:50.497] - force: TRUE
[17:44:50.497] - relayed: [n=2] TRUE, FALSE
[17:44:50.497] - queued futures: [n=2] TRUE, FALSE
[17:44:50.497]  - until=2
[17:44:50.497]  - relaying element #2
[17:44:50.497] result() for ClusterFuture ...
[17:44:50.498] - result already collected: FutureResult
[17:44:50.498] result() for ClusterFuture ... done
[17:44:50.498] result() for ClusterFuture ...
[17:44:50.498] - result already collected: FutureResult
[17:44:50.498] result() for ClusterFuture ... done
[17:44:50.498] result() for ClusterFuture ...
[17:44:50.498] - result already collected: FutureResult
[17:44:50.498] result() for ClusterFuture ... done
[17:44:50.498] result() for ClusterFuture ...
[17:44:50.498] - result already collected: FutureResult
[17:44:50.498] result() for ClusterFuture ... done
[17:44:50.498] - relayed: [n=2] TRUE, TRUE
[17:44:50.499] - queued futures: [n=2] TRUE, TRUE
[17:44:50.499] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.499]  length: 0 (resolved future 2)
[17:44:50.499] Relaying remaining futures
[17:44:50.499] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.499] - nx: 2
[17:44:50.499] - relay: TRUE
[17:44:50.499] - stdout: TRUE
[17:44:50.499] - signal: TRUE
[17:44:50.499] - resignal: FALSE
[17:44:50.499] - force: TRUE
[17:44:50.500] - relayed: [n=2] TRUE, TRUE
[17:44:50.500] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:50.500] - relayed: [n=2] TRUE, TRUE
[17:44:50.500] - queued futures: [n=2] TRUE, TRUE
[17:44:50.500] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.500] resolve() on list ... DONE
[17:44:50.500] result() for ClusterFuture ...
[17:44:50.500] - result already collected: FutureResult
[17:44:50.500] result() for ClusterFuture ... done
[17:44:50.500] result() for ClusterFuture ...
[17:44:50.500] - result already collected: FutureResult
[17:44:50.501] result() for ClusterFuture ... done
[17:44:50.501] result() for ClusterFuture ...
[17:44:50.501] - result already collected: FutureResult
[17:44:50.501] result() for ClusterFuture ... done
[17:44:50.501] result() for ClusterFuture ...
[17:44:50.501] - result already collected: FutureResult
[17:44:50.501] result() for ClusterFuture ... done
[17:44:50.501]  - Number of value chunks collected: 2
[17:44:50.501] Resolving 2 futures (chunks) ... DONE
[17:44:50.501] Reducing values from 2 chunks ...
[17:44:50.501]  - Number of values collected after concatenation: 3
[17:44:50.501]  - Number of values expected: 3
[17:44:50.502] Reducing values from 2 chunks ... DONE
[17:44:50.502] future_mapply() ... DONE
[17:44:50.502] future_mapply() ...
[17:44:50.506] Number of chunks: 5
[17:44:50.506] getGlobalsAndPackagesXApply() ...
[17:44:50.506]  - future.globals: TRUE
[17:44:50.506] getGlobalsAndPackages() ...
[17:44:50.506] Searching for globals...
[17:44:50.508] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:50.508] Searching for globals ... DONE
[17:44:50.508] Resolving globals: FALSE
[17:44:50.509] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:50.509] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:50.509] - globals: [1] ‘FUN’
[17:44:50.509] 
[17:44:50.509] getGlobalsAndPackages() ... DONE
[17:44:50.509]  - globals found/used: [n=1] ‘FUN’
[17:44:50.509]  - needed namespaces: [n=0] 
[17:44:50.509] Finding globals ... DONE
[17:44:50.510] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.510] List of 2
[17:44:50.510]  $ ...future.FUN:function (C, k)  
[17:44:50.510]  $ MoreArgs     : NULL
[17:44:50.510]  - attr(*, "where")=List of 2
[17:44:50.510]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.510]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.510]  - attr(*, "resolved")= logi FALSE
[17:44:50.510]  - attr(*, "total_size")= num NA
[17:44:50.512] Packages to be attached in all futures: [n=0] 
[17:44:50.512] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.512] Number of futures (= number of chunks): 5
[17:44:50.513] Launching 5 futures (chunks) ...
[17:44:50.513] Chunk #1 of 5 ...
[17:44:50.513]  - Finding globals in '...' for chunk #1 ...
[17:44:50.513] getGlobalsAndPackages() ...
[17:44:50.513] Searching for globals...
[17:44:50.513] 
[17:44:50.513] Searching for globals ... DONE
[17:44:50.513] - globals: [0] <none>
[17:44:50.514] getGlobalsAndPackages() ... DONE
[17:44:50.514]    + additional globals found: [n=0] 
[17:44:50.514]    + additional namespaces needed: [n=0] 
[17:44:50.514]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.514]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:50.514]  - seeds: <none>
[17:44:50.514]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.514] getGlobalsAndPackages() ...
[17:44:50.514] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.514] Resolving globals: FALSE
[17:44:50.515] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.515] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.515] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.516] 
[17:44:50.516] getGlobalsAndPackages() ... DONE
[17:44:50.516] run() for ‘Future’ ...
[17:44:50.516] - state: ‘created’
[17:44:50.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.530]   - Field: ‘node’
[17:44:50.530]   - Field: ‘label’
[17:44:50.530]   - Field: ‘local’
[17:44:50.530]   - Field: ‘owner’
[17:44:50.530]   - Field: ‘envir’
[17:44:50.530]   - Field: ‘workers’
[17:44:50.530]   - Field: ‘packages’
[17:44:50.530]   - Field: ‘gc’
[17:44:50.531]   - Field: ‘conditions’
[17:44:50.531]   - Field: ‘persistent’
[17:44:50.531]   - Field: ‘expr’
[17:44:50.531]   - Field: ‘uuid’
[17:44:50.531]   - Field: ‘seed’
[17:44:50.531]   - Field: ‘version’
[17:44:50.531]   - Field: ‘result’
[17:44:50.531]   - Field: ‘asynchronous’
[17:44:50.531]   - Field: ‘calls’
[17:44:50.531]   - Field: ‘globals’
[17:44:50.531]   - Field: ‘stdout’
[17:44:50.532]   - Field: ‘earlySignal’
[17:44:50.532]   - Field: ‘lazy’
[17:44:50.532]   - Field: ‘state’
[17:44:50.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.532] - Launch lazy future ...
[17:44:50.532] Packages needed by the future expression (n = 0): <none>
[17:44:50.532] Packages needed by future strategies (n = 0): <none>
[17:44:50.533] {
[17:44:50.533]     {
[17:44:50.533]         {
[17:44:50.533]             ...future.startTime <- base::Sys.time()
[17:44:50.533]             {
[17:44:50.533]                 {
[17:44:50.533]                   {
[17:44:50.533]                     {
[17:44:50.533]                       base::local({
[17:44:50.533]                         has_future <- base::requireNamespace("future", 
[17:44:50.533]                           quietly = TRUE)
[17:44:50.533]                         if (has_future) {
[17:44:50.533]                           ns <- base::getNamespace("future")
[17:44:50.533]                           version <- ns[[".package"]][["version"]]
[17:44:50.533]                           if (is.null(version)) 
[17:44:50.533]                             version <- utils::packageVersion("future")
[17:44:50.533]                         }
[17:44:50.533]                         else {
[17:44:50.533]                           version <- NULL
[17:44:50.533]                         }
[17:44:50.533]                         if (!has_future || version < "1.8.0") {
[17:44:50.533]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.533]                             "", base::R.version$version.string), 
[17:44:50.533]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.533]                               "release", "version")], collapse = " "), 
[17:44:50.533]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.533]                             info)
[17:44:50.533]                           info <- base::paste(info, collapse = "; ")
[17:44:50.533]                           if (!has_future) {
[17:44:50.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.533]                               info)
[17:44:50.533]                           }
[17:44:50.533]                           else {
[17:44:50.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.533]                               info, version)
[17:44:50.533]                           }
[17:44:50.533]                           base::stop(msg)
[17:44:50.533]                         }
[17:44:50.533]                       })
[17:44:50.533]                     }
[17:44:50.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.533]                     base::options(mc.cores = 1L)
[17:44:50.533]                   }
[17:44:50.533]                   ...future.strategy.old <- future::plan("list")
[17:44:50.533]                   options(future.plan = NULL)
[17:44:50.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.533]                 }
[17:44:50.533]                 ...future.workdir <- getwd()
[17:44:50.533]             }
[17:44:50.533]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.533]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.533]         }
[17:44:50.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.533]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:50.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.533]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.533]             base::names(...future.oldOptions))
[17:44:50.533]     }
[17:44:50.533]     if (FALSE) {
[17:44:50.533]     }
[17:44:50.533]     else {
[17:44:50.533]         if (TRUE) {
[17:44:50.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.533]                 open = "w")
[17:44:50.533]         }
[17:44:50.533]         else {
[17:44:50.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.533]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.533]         }
[17:44:50.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.533]             base::sink(type = "output", split = FALSE)
[17:44:50.533]             base::close(...future.stdout)
[17:44:50.533]         }, add = TRUE)
[17:44:50.533]     }
[17:44:50.533]     ...future.frame <- base::sys.nframe()
[17:44:50.533]     ...future.conditions <- base::list()
[17:44:50.533]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.533]     if (FALSE) {
[17:44:50.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.533]     }
[17:44:50.533]     ...future.result <- base::tryCatch({
[17:44:50.533]         base::withCallingHandlers({
[17:44:50.533]             ...future.value <- base::withVisible(base::local({
[17:44:50.533]                 ...future.makeSendCondition <- base::local({
[17:44:50.533]                   sendCondition <- NULL
[17:44:50.533]                   function(frame = 1L) {
[17:44:50.533]                     if (is.function(sendCondition)) 
[17:44:50.533]                       return(sendCondition)
[17:44:50.533]                     ns <- getNamespace("parallel")
[17:44:50.533]                     if (exists("sendData", mode = "function", 
[17:44:50.533]                       envir = ns)) {
[17:44:50.533]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.533]                         envir = ns)
[17:44:50.533]                       envir <- sys.frame(frame)
[17:44:50.533]                       master <- NULL
[17:44:50.533]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.533]                         !identical(envir, emptyenv())) {
[17:44:50.533]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.533]                           inherits = FALSE)) {
[17:44:50.533]                           master <- get("master", mode = "list", 
[17:44:50.533]                             envir = envir, inherits = FALSE)
[17:44:50.533]                           if (inherits(master, c("SOCKnode", 
[17:44:50.533]                             "SOCK0node"))) {
[17:44:50.533]                             sendCondition <<- function(cond) {
[17:44:50.533]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.533]                                 success = TRUE)
[17:44:50.533]                               parallel_sendData(master, data)
[17:44:50.533]                             }
[17:44:50.533]                             return(sendCondition)
[17:44:50.533]                           }
[17:44:50.533]                         }
[17:44:50.533]                         frame <- frame + 1L
[17:44:50.533]                         envir <- sys.frame(frame)
[17:44:50.533]                       }
[17:44:50.533]                     }
[17:44:50.533]                     sendCondition <<- function(cond) NULL
[17:44:50.533]                   }
[17:44:50.533]                 })
[17:44:50.533]                 withCallingHandlers({
[17:44:50.533]                   {
[17:44:50.533]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.533]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.533]                       ...future.globals.maxSize)) {
[17:44:50.533]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.533]                       on.exit(options(oopts), add = TRUE)
[17:44:50.533]                     }
[17:44:50.533]                     {
[17:44:50.533]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.533]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.533]                         USE.NAMES = FALSE)
[17:44:50.533]                       do.call(mapply, args = args)
[17:44:50.533]                     }
[17:44:50.533]                   }
[17:44:50.533]                 }, immediateCondition = function(cond) {
[17:44:50.533]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.533]                   sendCondition(cond)
[17:44:50.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.533]                   {
[17:44:50.533]                     inherits <- base::inherits
[17:44:50.533]                     invokeRestart <- base::invokeRestart
[17:44:50.533]                     is.null <- base::is.null
[17:44:50.533]                     muffled <- FALSE
[17:44:50.533]                     if (inherits(cond, "message")) {
[17:44:50.533]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.533]                       if (muffled) 
[17:44:50.533]                         invokeRestart("muffleMessage")
[17:44:50.533]                     }
[17:44:50.533]                     else if (inherits(cond, "warning")) {
[17:44:50.533]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.533]                       if (muffled) 
[17:44:50.533]                         invokeRestart("muffleWarning")
[17:44:50.533]                     }
[17:44:50.533]                     else if (inherits(cond, "condition")) {
[17:44:50.533]                       if (!is.null(pattern)) {
[17:44:50.533]                         computeRestarts <- base::computeRestarts
[17:44:50.533]                         grepl <- base::grepl
[17:44:50.533]                         restarts <- computeRestarts(cond)
[17:44:50.533]                         for (restart in restarts) {
[17:44:50.533]                           name <- restart$name
[17:44:50.533]                           if (is.null(name)) 
[17:44:50.533]                             next
[17:44:50.533]                           if (!grepl(pattern, name)) 
[17:44:50.533]                             next
[17:44:50.533]                           invokeRestart(restart)
[17:44:50.533]                           muffled <- TRUE
[17:44:50.533]                           break
[17:44:50.533]                         }
[17:44:50.533]                       }
[17:44:50.533]                     }
[17:44:50.533]                     invisible(muffled)
[17:44:50.533]                   }
[17:44:50.533]                   muffleCondition(cond)
[17:44:50.533]                 })
[17:44:50.533]             }))
[17:44:50.533]             future::FutureResult(value = ...future.value$value, 
[17:44:50.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.533]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.533]                     ...future.globalenv.names))
[17:44:50.533]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.533]         }, condition = base::local({
[17:44:50.533]             c <- base::c
[17:44:50.533]             inherits <- base::inherits
[17:44:50.533]             invokeRestart <- base::invokeRestart
[17:44:50.533]             length <- base::length
[17:44:50.533]             list <- base::list
[17:44:50.533]             seq.int <- base::seq.int
[17:44:50.533]             signalCondition <- base::signalCondition
[17:44:50.533]             sys.calls <- base::sys.calls
[17:44:50.533]             `[[` <- base::`[[`
[17:44:50.533]             `+` <- base::`+`
[17:44:50.533]             `<<-` <- base::`<<-`
[17:44:50.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.533]                   3L)]
[17:44:50.533]             }
[17:44:50.533]             function(cond) {
[17:44:50.533]                 is_error <- inherits(cond, "error")
[17:44:50.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.533]                   NULL)
[17:44:50.533]                 if (is_error) {
[17:44:50.533]                   sessionInformation <- function() {
[17:44:50.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.533]                       search = base::search(), system = base::Sys.info())
[17:44:50.533]                   }
[17:44:50.533]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.533]                     cond$call), session = sessionInformation(), 
[17:44:50.533]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.533]                   signalCondition(cond)
[17:44:50.533]                 }
[17:44:50.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.533]                 "immediateCondition"))) {
[17:44:50.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.533]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.533]                   if (TRUE && !signal) {
[17:44:50.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.533]                     {
[17:44:50.533]                       inherits <- base::inherits
[17:44:50.533]                       invokeRestart <- base::invokeRestart
[17:44:50.533]                       is.null <- base::is.null
[17:44:50.533]                       muffled <- FALSE
[17:44:50.533]                       if (inherits(cond, "message")) {
[17:44:50.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.533]                         if (muffled) 
[17:44:50.533]                           invokeRestart("muffleMessage")
[17:44:50.533]                       }
[17:44:50.533]                       else if (inherits(cond, "warning")) {
[17:44:50.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.533]                         if (muffled) 
[17:44:50.533]                           invokeRestart("muffleWarning")
[17:44:50.533]                       }
[17:44:50.533]                       else if (inherits(cond, "condition")) {
[17:44:50.533]                         if (!is.null(pattern)) {
[17:44:50.533]                           computeRestarts <- base::computeRestarts
[17:44:50.533]                           grepl <- base::grepl
[17:44:50.533]                           restarts <- computeRestarts(cond)
[17:44:50.533]                           for (restart in restarts) {
[17:44:50.533]                             name <- restart$name
[17:44:50.533]                             if (is.null(name)) 
[17:44:50.533]                               next
[17:44:50.533]                             if (!grepl(pattern, name)) 
[17:44:50.533]                               next
[17:44:50.533]                             invokeRestart(restart)
[17:44:50.533]                             muffled <- TRUE
[17:44:50.533]                             break
[17:44:50.533]                           }
[17:44:50.533]                         }
[17:44:50.533]                       }
[17:44:50.533]                       invisible(muffled)
[17:44:50.533]                     }
[17:44:50.533]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.533]                   }
[17:44:50.533]                 }
[17:44:50.533]                 else {
[17:44:50.533]                   if (TRUE) {
[17:44:50.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.533]                     {
[17:44:50.533]                       inherits <- base::inherits
[17:44:50.533]                       invokeRestart <- base::invokeRestart
[17:44:50.533]                       is.null <- base::is.null
[17:44:50.533]                       muffled <- FALSE
[17:44:50.533]                       if (inherits(cond, "message")) {
[17:44:50.533]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.533]                         if (muffled) 
[17:44:50.533]                           invokeRestart("muffleMessage")
[17:44:50.533]                       }
[17:44:50.533]                       else if (inherits(cond, "warning")) {
[17:44:50.533]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.533]                         if (muffled) 
[17:44:50.533]                           invokeRestart("muffleWarning")
[17:44:50.533]                       }
[17:44:50.533]                       else if (inherits(cond, "condition")) {
[17:44:50.533]                         if (!is.null(pattern)) {
[17:44:50.533]                           computeRestarts <- base::computeRestarts
[17:44:50.533]                           grepl <- base::grepl
[17:44:50.533]                           restarts <- computeRestarts(cond)
[17:44:50.533]                           for (restart in restarts) {
[17:44:50.533]                             name <- restart$name
[17:44:50.533]                             if (is.null(name)) 
[17:44:50.533]                               next
[17:44:50.533]                             if (!grepl(pattern, name)) 
[17:44:50.533]                               next
[17:44:50.533]                             invokeRestart(restart)
[17:44:50.533]                             muffled <- TRUE
[17:44:50.533]                             break
[17:44:50.533]                           }
[17:44:50.533]                         }
[17:44:50.533]                       }
[17:44:50.533]                       invisible(muffled)
[17:44:50.533]                     }
[17:44:50.533]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.533]                   }
[17:44:50.533]                 }
[17:44:50.533]             }
[17:44:50.533]         }))
[17:44:50.533]     }, error = function(ex) {
[17:44:50.533]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.533]                 ...future.rng), started = ...future.startTime, 
[17:44:50.533]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.533]             version = "1.8"), class = "FutureResult")
[17:44:50.533]     }, finally = {
[17:44:50.533]         if (!identical(...future.workdir, getwd())) 
[17:44:50.533]             setwd(...future.workdir)
[17:44:50.533]         {
[17:44:50.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.533]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.533]             }
[17:44:50.533]             base::options(...future.oldOptions)
[17:44:50.533]             if (.Platform$OS.type == "windows") {
[17:44:50.533]                 old_names <- names(...future.oldEnvVars)
[17:44:50.533]                 envs <- base::Sys.getenv()
[17:44:50.533]                 names <- names(envs)
[17:44:50.533]                 common <- intersect(names, old_names)
[17:44:50.533]                 added <- setdiff(names, old_names)
[17:44:50.533]                 removed <- setdiff(old_names, names)
[17:44:50.533]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.533]                   envs[common]]
[17:44:50.533]                 NAMES <- toupper(changed)
[17:44:50.533]                 args <- list()
[17:44:50.533]                 for (kk in seq_along(NAMES)) {
[17:44:50.533]                   name <- changed[[kk]]
[17:44:50.533]                   NAME <- NAMES[[kk]]
[17:44:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.533]                     next
[17:44:50.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.533]                 }
[17:44:50.533]                 NAMES <- toupper(added)
[17:44:50.533]                 for (kk in seq_along(NAMES)) {
[17:44:50.533]                   name <- added[[kk]]
[17:44:50.533]                   NAME <- NAMES[[kk]]
[17:44:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.533]                     next
[17:44:50.533]                   args[[name]] <- ""
[17:44:50.533]                 }
[17:44:50.533]                 NAMES <- toupper(removed)
[17:44:50.533]                 for (kk in seq_along(NAMES)) {
[17:44:50.533]                   name <- removed[[kk]]
[17:44:50.533]                   NAME <- NAMES[[kk]]
[17:44:50.533]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.533]                     next
[17:44:50.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.533]                 }
[17:44:50.533]                 if (length(args) > 0) 
[17:44:50.533]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.533]             }
[17:44:50.533]             else {
[17:44:50.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.533]             }
[17:44:50.533]             {
[17:44:50.533]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.533]                   0L) {
[17:44:50.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.533]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.533]                   base::options(opts)
[17:44:50.533]                 }
[17:44:50.533]                 {
[17:44:50.533]                   {
[17:44:50.533]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.533]                     NULL
[17:44:50.533]                   }
[17:44:50.533]                   options(future.plan = NULL)
[17:44:50.533]                   if (is.na(NA_character_)) 
[17:44:50.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.533]                     .init = FALSE)
[17:44:50.533]                 }
[17:44:50.533]             }
[17:44:50.533]         }
[17:44:50.533]     })
[17:44:50.533]     if (TRUE) {
[17:44:50.533]         base::sink(type = "output", split = FALSE)
[17:44:50.533]         if (TRUE) {
[17:44:50.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.533]         }
[17:44:50.533]         else {
[17:44:50.533]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.533]         }
[17:44:50.533]         base::close(...future.stdout)
[17:44:50.533]         ...future.stdout <- NULL
[17:44:50.533]     }
[17:44:50.533]     ...future.result$conditions <- ...future.conditions
[17:44:50.533]     ...future.result$finished <- base::Sys.time()
[17:44:50.533]     ...future.result
[17:44:50.533] }
[17:44:50.535] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:44:50.536] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.536] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.536] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.536] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.536] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:44:50.537] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:44:50.537] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.537] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.537] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.538] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.538] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:44:50.538] MultisessionFuture started
[17:44:50.538] - Launch lazy future ... done
[17:44:50.538] run() for ‘MultisessionFuture’ ... done
[17:44:50.538] Created future:
[17:44:50.538] MultisessionFuture:
[17:44:50.538] Label: ‘future_mapply-1’
[17:44:50.538] Expression:
[17:44:50.538] {
[17:44:50.538]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.538]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.538]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.538]         on.exit(options(oopts), add = TRUE)
[17:44:50.538]     }
[17:44:50.538]     {
[17:44:50.538]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.538]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.538]         do.call(mapply, args = args)
[17:44:50.538]     }
[17:44:50.538] }
[17:44:50.538] Lazy evaluation: FALSE
[17:44:50.538] Asynchronous evaluation: TRUE
[17:44:50.538] Local evaluation: TRUE
[17:44:50.538] Environment: R_GlobalEnv
[17:44:50.538] Capture standard output: TRUE
[17:44:50.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.538] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.538] Packages: <none>
[17:44:50.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.538] Resolved: FALSE
[17:44:50.538] Value: <not collected>
[17:44:50.538] Conditions captured: <none>
[17:44:50.538] Early signaling: FALSE
[17:44:50.538] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.538] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.550] Chunk #1 of 5 ... DONE
[17:44:50.550] Chunk #2 of 5 ...
[17:44:50.550]  - Finding globals in '...' for chunk #2 ...
[17:44:50.550] getGlobalsAndPackages() ...
[17:44:50.550] Searching for globals...
[17:44:50.551] 
[17:44:50.551] Searching for globals ... DONE
[17:44:50.551] - globals: [0] <none>
[17:44:50.551] getGlobalsAndPackages() ... DONE
[17:44:50.551]    + additional globals found: [n=0] 
[17:44:50.551]    + additional namespaces needed: [n=0] 
[17:44:50.551]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:50.551]  - seeds: <none>
[17:44:50.552]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.552] getGlobalsAndPackages() ...
[17:44:50.552] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.552] Resolving globals: FALSE
[17:44:50.552] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.553] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.553] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.553] 
[17:44:50.553] getGlobalsAndPackages() ... DONE
[17:44:50.553] run() for ‘Future’ ...
[17:44:50.553] - state: ‘created’
[17:44:50.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.567]   - Field: ‘node’
[17:44:50.568]   - Field: ‘label’
[17:44:50.568]   - Field: ‘local’
[17:44:50.568]   - Field: ‘owner’
[17:44:50.568]   - Field: ‘envir’
[17:44:50.568]   - Field: ‘workers’
[17:44:50.568]   - Field: ‘packages’
[17:44:50.568]   - Field: ‘gc’
[17:44:50.568]   - Field: ‘conditions’
[17:44:50.568]   - Field: ‘persistent’
[17:44:50.568]   - Field: ‘expr’
[17:44:50.569]   - Field: ‘uuid’
[17:44:50.569]   - Field: ‘seed’
[17:44:50.569]   - Field: ‘version’
[17:44:50.569]   - Field: ‘result’
[17:44:50.569]   - Field: ‘asynchronous’
[17:44:50.569]   - Field: ‘calls’
[17:44:50.569]   - Field: ‘globals’
[17:44:50.569]   - Field: ‘stdout’
[17:44:50.569]   - Field: ‘earlySignal’
[17:44:50.569]   - Field: ‘lazy’
[17:44:50.569]   - Field: ‘state’
[17:44:50.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.570] - Launch lazy future ...
[17:44:50.570] Packages needed by the future expression (n = 0): <none>
[17:44:50.570] Packages needed by future strategies (n = 0): <none>
[17:44:50.570] {
[17:44:50.570]     {
[17:44:50.570]         {
[17:44:50.570]             ...future.startTime <- base::Sys.time()
[17:44:50.570]             {
[17:44:50.570]                 {
[17:44:50.570]                   {
[17:44:50.570]                     {
[17:44:50.570]                       base::local({
[17:44:50.570]                         has_future <- base::requireNamespace("future", 
[17:44:50.570]                           quietly = TRUE)
[17:44:50.570]                         if (has_future) {
[17:44:50.570]                           ns <- base::getNamespace("future")
[17:44:50.570]                           version <- ns[[".package"]][["version"]]
[17:44:50.570]                           if (is.null(version)) 
[17:44:50.570]                             version <- utils::packageVersion("future")
[17:44:50.570]                         }
[17:44:50.570]                         else {
[17:44:50.570]                           version <- NULL
[17:44:50.570]                         }
[17:44:50.570]                         if (!has_future || version < "1.8.0") {
[17:44:50.570]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.570]                             "", base::R.version$version.string), 
[17:44:50.570]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.570]                               "release", "version")], collapse = " "), 
[17:44:50.570]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.570]                             info)
[17:44:50.570]                           info <- base::paste(info, collapse = "; ")
[17:44:50.570]                           if (!has_future) {
[17:44:50.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.570]                               info)
[17:44:50.570]                           }
[17:44:50.570]                           else {
[17:44:50.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.570]                               info, version)
[17:44:50.570]                           }
[17:44:50.570]                           base::stop(msg)
[17:44:50.570]                         }
[17:44:50.570]                       })
[17:44:50.570]                     }
[17:44:50.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.570]                     base::options(mc.cores = 1L)
[17:44:50.570]                   }
[17:44:50.570]                   ...future.strategy.old <- future::plan("list")
[17:44:50.570]                   options(future.plan = NULL)
[17:44:50.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.570]                 }
[17:44:50.570]                 ...future.workdir <- getwd()
[17:44:50.570]             }
[17:44:50.570]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.570]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.570]         }
[17:44:50.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.570]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:50.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.570]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.570]             base::names(...future.oldOptions))
[17:44:50.570]     }
[17:44:50.570]     if (FALSE) {
[17:44:50.570]     }
[17:44:50.570]     else {
[17:44:50.570]         if (TRUE) {
[17:44:50.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.570]                 open = "w")
[17:44:50.570]         }
[17:44:50.570]         else {
[17:44:50.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.570]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.570]         }
[17:44:50.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.570]             base::sink(type = "output", split = FALSE)
[17:44:50.570]             base::close(...future.stdout)
[17:44:50.570]         }, add = TRUE)
[17:44:50.570]     }
[17:44:50.570]     ...future.frame <- base::sys.nframe()
[17:44:50.570]     ...future.conditions <- base::list()
[17:44:50.570]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.570]     if (FALSE) {
[17:44:50.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.570]     }
[17:44:50.570]     ...future.result <- base::tryCatch({
[17:44:50.570]         base::withCallingHandlers({
[17:44:50.570]             ...future.value <- base::withVisible(base::local({
[17:44:50.570]                 ...future.makeSendCondition <- base::local({
[17:44:50.570]                   sendCondition <- NULL
[17:44:50.570]                   function(frame = 1L) {
[17:44:50.570]                     if (is.function(sendCondition)) 
[17:44:50.570]                       return(sendCondition)
[17:44:50.570]                     ns <- getNamespace("parallel")
[17:44:50.570]                     if (exists("sendData", mode = "function", 
[17:44:50.570]                       envir = ns)) {
[17:44:50.570]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.570]                         envir = ns)
[17:44:50.570]                       envir <- sys.frame(frame)
[17:44:50.570]                       master <- NULL
[17:44:50.570]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.570]                         !identical(envir, emptyenv())) {
[17:44:50.570]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.570]                           inherits = FALSE)) {
[17:44:50.570]                           master <- get("master", mode = "list", 
[17:44:50.570]                             envir = envir, inherits = FALSE)
[17:44:50.570]                           if (inherits(master, c("SOCKnode", 
[17:44:50.570]                             "SOCK0node"))) {
[17:44:50.570]                             sendCondition <<- function(cond) {
[17:44:50.570]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.570]                                 success = TRUE)
[17:44:50.570]                               parallel_sendData(master, data)
[17:44:50.570]                             }
[17:44:50.570]                             return(sendCondition)
[17:44:50.570]                           }
[17:44:50.570]                         }
[17:44:50.570]                         frame <- frame + 1L
[17:44:50.570]                         envir <- sys.frame(frame)
[17:44:50.570]                       }
[17:44:50.570]                     }
[17:44:50.570]                     sendCondition <<- function(cond) NULL
[17:44:50.570]                   }
[17:44:50.570]                 })
[17:44:50.570]                 withCallingHandlers({
[17:44:50.570]                   {
[17:44:50.570]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.570]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.570]                       ...future.globals.maxSize)) {
[17:44:50.570]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.570]                       on.exit(options(oopts), add = TRUE)
[17:44:50.570]                     }
[17:44:50.570]                     {
[17:44:50.570]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.570]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.570]                         USE.NAMES = FALSE)
[17:44:50.570]                       do.call(mapply, args = args)
[17:44:50.570]                     }
[17:44:50.570]                   }
[17:44:50.570]                 }, immediateCondition = function(cond) {
[17:44:50.570]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.570]                   sendCondition(cond)
[17:44:50.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.570]                   {
[17:44:50.570]                     inherits <- base::inherits
[17:44:50.570]                     invokeRestart <- base::invokeRestart
[17:44:50.570]                     is.null <- base::is.null
[17:44:50.570]                     muffled <- FALSE
[17:44:50.570]                     if (inherits(cond, "message")) {
[17:44:50.570]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.570]                       if (muffled) 
[17:44:50.570]                         invokeRestart("muffleMessage")
[17:44:50.570]                     }
[17:44:50.570]                     else if (inherits(cond, "warning")) {
[17:44:50.570]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.570]                       if (muffled) 
[17:44:50.570]                         invokeRestart("muffleWarning")
[17:44:50.570]                     }
[17:44:50.570]                     else if (inherits(cond, "condition")) {
[17:44:50.570]                       if (!is.null(pattern)) {
[17:44:50.570]                         computeRestarts <- base::computeRestarts
[17:44:50.570]                         grepl <- base::grepl
[17:44:50.570]                         restarts <- computeRestarts(cond)
[17:44:50.570]                         for (restart in restarts) {
[17:44:50.570]                           name <- restart$name
[17:44:50.570]                           if (is.null(name)) 
[17:44:50.570]                             next
[17:44:50.570]                           if (!grepl(pattern, name)) 
[17:44:50.570]                             next
[17:44:50.570]                           invokeRestart(restart)
[17:44:50.570]                           muffled <- TRUE
[17:44:50.570]                           break
[17:44:50.570]                         }
[17:44:50.570]                       }
[17:44:50.570]                     }
[17:44:50.570]                     invisible(muffled)
[17:44:50.570]                   }
[17:44:50.570]                   muffleCondition(cond)
[17:44:50.570]                 })
[17:44:50.570]             }))
[17:44:50.570]             future::FutureResult(value = ...future.value$value, 
[17:44:50.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.570]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.570]                     ...future.globalenv.names))
[17:44:50.570]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.570]         }, condition = base::local({
[17:44:50.570]             c <- base::c
[17:44:50.570]             inherits <- base::inherits
[17:44:50.570]             invokeRestart <- base::invokeRestart
[17:44:50.570]             length <- base::length
[17:44:50.570]             list <- base::list
[17:44:50.570]             seq.int <- base::seq.int
[17:44:50.570]             signalCondition <- base::signalCondition
[17:44:50.570]             sys.calls <- base::sys.calls
[17:44:50.570]             `[[` <- base::`[[`
[17:44:50.570]             `+` <- base::`+`
[17:44:50.570]             `<<-` <- base::`<<-`
[17:44:50.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.570]                   3L)]
[17:44:50.570]             }
[17:44:50.570]             function(cond) {
[17:44:50.570]                 is_error <- inherits(cond, "error")
[17:44:50.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.570]                   NULL)
[17:44:50.570]                 if (is_error) {
[17:44:50.570]                   sessionInformation <- function() {
[17:44:50.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.570]                       search = base::search(), system = base::Sys.info())
[17:44:50.570]                   }
[17:44:50.570]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.570]                     cond$call), session = sessionInformation(), 
[17:44:50.570]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.570]                   signalCondition(cond)
[17:44:50.570]                 }
[17:44:50.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.570]                 "immediateCondition"))) {
[17:44:50.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.570]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.570]                   if (TRUE && !signal) {
[17:44:50.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.570]                     {
[17:44:50.570]                       inherits <- base::inherits
[17:44:50.570]                       invokeRestart <- base::invokeRestart
[17:44:50.570]                       is.null <- base::is.null
[17:44:50.570]                       muffled <- FALSE
[17:44:50.570]                       if (inherits(cond, "message")) {
[17:44:50.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.570]                         if (muffled) 
[17:44:50.570]                           invokeRestart("muffleMessage")
[17:44:50.570]                       }
[17:44:50.570]                       else if (inherits(cond, "warning")) {
[17:44:50.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.570]                         if (muffled) 
[17:44:50.570]                           invokeRestart("muffleWarning")
[17:44:50.570]                       }
[17:44:50.570]                       else if (inherits(cond, "condition")) {
[17:44:50.570]                         if (!is.null(pattern)) {
[17:44:50.570]                           computeRestarts <- base::computeRestarts
[17:44:50.570]                           grepl <- base::grepl
[17:44:50.570]                           restarts <- computeRestarts(cond)
[17:44:50.570]                           for (restart in restarts) {
[17:44:50.570]                             name <- restart$name
[17:44:50.570]                             if (is.null(name)) 
[17:44:50.570]                               next
[17:44:50.570]                             if (!grepl(pattern, name)) 
[17:44:50.570]                               next
[17:44:50.570]                             invokeRestart(restart)
[17:44:50.570]                             muffled <- TRUE
[17:44:50.570]                             break
[17:44:50.570]                           }
[17:44:50.570]                         }
[17:44:50.570]                       }
[17:44:50.570]                       invisible(muffled)
[17:44:50.570]                     }
[17:44:50.570]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.570]                   }
[17:44:50.570]                 }
[17:44:50.570]                 else {
[17:44:50.570]                   if (TRUE) {
[17:44:50.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.570]                     {
[17:44:50.570]                       inherits <- base::inherits
[17:44:50.570]                       invokeRestart <- base::invokeRestart
[17:44:50.570]                       is.null <- base::is.null
[17:44:50.570]                       muffled <- FALSE
[17:44:50.570]                       if (inherits(cond, "message")) {
[17:44:50.570]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.570]                         if (muffled) 
[17:44:50.570]                           invokeRestart("muffleMessage")
[17:44:50.570]                       }
[17:44:50.570]                       else if (inherits(cond, "warning")) {
[17:44:50.570]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.570]                         if (muffled) 
[17:44:50.570]                           invokeRestart("muffleWarning")
[17:44:50.570]                       }
[17:44:50.570]                       else if (inherits(cond, "condition")) {
[17:44:50.570]                         if (!is.null(pattern)) {
[17:44:50.570]                           computeRestarts <- base::computeRestarts
[17:44:50.570]                           grepl <- base::grepl
[17:44:50.570]                           restarts <- computeRestarts(cond)
[17:44:50.570]                           for (restart in restarts) {
[17:44:50.570]                             name <- restart$name
[17:44:50.570]                             if (is.null(name)) 
[17:44:50.570]                               next
[17:44:50.570]                             if (!grepl(pattern, name)) 
[17:44:50.570]                               next
[17:44:50.570]                             invokeRestart(restart)
[17:44:50.570]                             muffled <- TRUE
[17:44:50.570]                             break
[17:44:50.570]                           }
[17:44:50.570]                         }
[17:44:50.570]                       }
[17:44:50.570]                       invisible(muffled)
[17:44:50.570]                     }
[17:44:50.570]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.570]                   }
[17:44:50.570]                 }
[17:44:50.570]             }
[17:44:50.570]         }))
[17:44:50.570]     }, error = function(ex) {
[17:44:50.570]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.570]                 ...future.rng), started = ...future.startTime, 
[17:44:50.570]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.570]             version = "1.8"), class = "FutureResult")
[17:44:50.570]     }, finally = {
[17:44:50.570]         if (!identical(...future.workdir, getwd())) 
[17:44:50.570]             setwd(...future.workdir)
[17:44:50.570]         {
[17:44:50.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.570]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.570]             }
[17:44:50.570]             base::options(...future.oldOptions)
[17:44:50.570]             if (.Platform$OS.type == "windows") {
[17:44:50.570]                 old_names <- names(...future.oldEnvVars)
[17:44:50.570]                 envs <- base::Sys.getenv()
[17:44:50.570]                 names <- names(envs)
[17:44:50.570]                 common <- intersect(names, old_names)
[17:44:50.570]                 added <- setdiff(names, old_names)
[17:44:50.570]                 removed <- setdiff(old_names, names)
[17:44:50.570]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.570]                   envs[common]]
[17:44:50.570]                 NAMES <- toupper(changed)
[17:44:50.570]                 args <- list()
[17:44:50.570]                 for (kk in seq_along(NAMES)) {
[17:44:50.570]                   name <- changed[[kk]]
[17:44:50.570]                   NAME <- NAMES[[kk]]
[17:44:50.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.570]                     next
[17:44:50.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.570]                 }
[17:44:50.570]                 NAMES <- toupper(added)
[17:44:50.570]                 for (kk in seq_along(NAMES)) {
[17:44:50.570]                   name <- added[[kk]]
[17:44:50.570]                   NAME <- NAMES[[kk]]
[17:44:50.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.570]                     next
[17:44:50.570]                   args[[name]] <- ""
[17:44:50.570]                 }
[17:44:50.570]                 NAMES <- toupper(removed)
[17:44:50.570]                 for (kk in seq_along(NAMES)) {
[17:44:50.570]                   name <- removed[[kk]]
[17:44:50.570]                   NAME <- NAMES[[kk]]
[17:44:50.570]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.570]                     next
[17:44:50.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.570]                 }
[17:44:50.570]                 if (length(args) > 0) 
[17:44:50.570]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.570]             }
[17:44:50.570]             else {
[17:44:50.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.570]             }
[17:44:50.570]             {
[17:44:50.570]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.570]                   0L) {
[17:44:50.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.570]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.570]                   base::options(opts)
[17:44:50.570]                 }
[17:44:50.570]                 {
[17:44:50.570]                   {
[17:44:50.570]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.570]                     NULL
[17:44:50.570]                   }
[17:44:50.570]                   options(future.plan = NULL)
[17:44:50.570]                   if (is.na(NA_character_)) 
[17:44:50.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.570]                     .init = FALSE)
[17:44:50.570]                 }
[17:44:50.570]             }
[17:44:50.570]         }
[17:44:50.570]     })
[17:44:50.570]     if (TRUE) {
[17:44:50.570]         base::sink(type = "output", split = FALSE)
[17:44:50.570]         if (TRUE) {
[17:44:50.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.570]         }
[17:44:50.570]         else {
[17:44:50.570]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.570]         }
[17:44:50.570]         base::close(...future.stdout)
[17:44:50.570]         ...future.stdout <- NULL
[17:44:50.570]     }
[17:44:50.570]     ...future.result$conditions <- ...future.conditions
[17:44:50.570]     ...future.result$finished <- base::Sys.time()
[17:44:50.570]     ...future.result
[17:44:50.570] }
[17:44:50.573] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:44:50.573] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:50.573] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:50.573] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.574] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.574] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:44:50.574] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:44:50.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.575] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.575] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.575] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.575] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:44:50.576] MultisessionFuture started
[17:44:50.576] - Launch lazy future ... done
[17:44:50.576] run() for ‘MultisessionFuture’ ... done
[17:44:50.576] Created future:
[17:44:50.576] MultisessionFuture:
[17:44:50.576] Label: ‘future_mapply-2’
[17:44:50.576] Expression:
[17:44:50.576] {
[17:44:50.576]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.576]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.576]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.576]         on.exit(options(oopts), add = TRUE)
[17:44:50.576]     }
[17:44:50.576]     {
[17:44:50.576]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.576]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.576]         do.call(mapply, args = args)
[17:44:50.576]     }
[17:44:50.576] }
[17:44:50.576] Lazy evaluation: FALSE
[17:44:50.576] Asynchronous evaluation: TRUE
[17:44:50.576] Local evaluation: TRUE
[17:44:50.576] Environment: R_GlobalEnv
[17:44:50.576] Capture standard output: TRUE
[17:44:50.576] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.576] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.576] Packages: <none>
[17:44:50.576] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.576] Resolved: FALSE
[17:44:50.576] Value: <not collected>
[17:44:50.576] Conditions captured: <none>
[17:44:50.576] Early signaling: FALSE
[17:44:50.576] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.576] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.587] Chunk #2 of 5 ... DONE
[17:44:50.587] Chunk #3 of 5 ...
[17:44:50.588]  - Finding globals in '...' for chunk #3 ...
[17:44:50.588] getGlobalsAndPackages() ...
[17:44:50.588] Searching for globals...
[17:44:50.588] 
[17:44:50.588] Searching for globals ... DONE
[17:44:50.588] - globals: [0] <none>
[17:44:50.589] getGlobalsAndPackages() ... DONE
[17:44:50.589]    + additional globals found: [n=0] 
[17:44:50.589]    + additional namespaces needed: [n=0] 
[17:44:50.589]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:50.589]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:50.589]  - seeds: <none>
[17:44:50.589]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.589] getGlobalsAndPackages() ...
[17:44:50.589] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.589] Resolving globals: FALSE
[17:44:50.590] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.590] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.590] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.590] 
[17:44:50.591] getGlobalsAndPackages() ... DONE
[17:44:50.591] run() for ‘Future’ ...
[17:44:50.591] - state: ‘created’
[17:44:50.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.605] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.605]   - Field: ‘node’
[17:44:50.605]   - Field: ‘label’
[17:44:50.605]   - Field: ‘local’
[17:44:50.605]   - Field: ‘owner’
[17:44:50.605]   - Field: ‘envir’
[17:44:50.605]   - Field: ‘workers’
[17:44:50.606]   - Field: ‘packages’
[17:44:50.606]   - Field: ‘gc’
[17:44:50.606]   - Field: ‘conditions’
[17:44:50.606]   - Field: ‘persistent’
[17:44:50.606]   - Field: ‘expr’
[17:44:50.606]   - Field: ‘uuid’
[17:44:50.606]   - Field: ‘seed’
[17:44:50.606]   - Field: ‘version’
[17:44:50.606]   - Field: ‘result’
[17:44:50.606]   - Field: ‘asynchronous’
[17:44:50.606]   - Field: ‘calls’
[17:44:50.607]   - Field: ‘globals’
[17:44:50.607]   - Field: ‘stdout’
[17:44:50.607]   - Field: ‘earlySignal’
[17:44:50.607]   - Field: ‘lazy’
[17:44:50.607]   - Field: ‘state’
[17:44:50.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.607] - Launch lazy future ...
[17:44:50.607] Packages needed by the future expression (n = 0): <none>
[17:44:50.607] Packages needed by future strategies (n = 0): <none>
[17:44:50.608] {
[17:44:50.608]     {
[17:44:50.608]         {
[17:44:50.608]             ...future.startTime <- base::Sys.time()
[17:44:50.608]             {
[17:44:50.608]                 {
[17:44:50.608]                   {
[17:44:50.608]                     {
[17:44:50.608]                       base::local({
[17:44:50.608]                         has_future <- base::requireNamespace("future", 
[17:44:50.608]                           quietly = TRUE)
[17:44:50.608]                         if (has_future) {
[17:44:50.608]                           ns <- base::getNamespace("future")
[17:44:50.608]                           version <- ns[[".package"]][["version"]]
[17:44:50.608]                           if (is.null(version)) 
[17:44:50.608]                             version <- utils::packageVersion("future")
[17:44:50.608]                         }
[17:44:50.608]                         else {
[17:44:50.608]                           version <- NULL
[17:44:50.608]                         }
[17:44:50.608]                         if (!has_future || version < "1.8.0") {
[17:44:50.608]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.608]                             "", base::R.version$version.string), 
[17:44:50.608]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.608]                               "release", "version")], collapse = " "), 
[17:44:50.608]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.608]                             info)
[17:44:50.608]                           info <- base::paste(info, collapse = "; ")
[17:44:50.608]                           if (!has_future) {
[17:44:50.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.608]                               info)
[17:44:50.608]                           }
[17:44:50.608]                           else {
[17:44:50.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.608]                               info, version)
[17:44:50.608]                           }
[17:44:50.608]                           base::stop(msg)
[17:44:50.608]                         }
[17:44:50.608]                       })
[17:44:50.608]                     }
[17:44:50.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.608]                     base::options(mc.cores = 1L)
[17:44:50.608]                   }
[17:44:50.608]                   ...future.strategy.old <- future::plan("list")
[17:44:50.608]                   options(future.plan = NULL)
[17:44:50.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.608]                 }
[17:44:50.608]                 ...future.workdir <- getwd()
[17:44:50.608]             }
[17:44:50.608]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.608]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.608]         }
[17:44:50.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.608]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:50.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.608]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.608]             base::names(...future.oldOptions))
[17:44:50.608]     }
[17:44:50.608]     if (FALSE) {
[17:44:50.608]     }
[17:44:50.608]     else {
[17:44:50.608]         if (TRUE) {
[17:44:50.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.608]                 open = "w")
[17:44:50.608]         }
[17:44:50.608]         else {
[17:44:50.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.608]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.608]         }
[17:44:50.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.608]             base::sink(type = "output", split = FALSE)
[17:44:50.608]             base::close(...future.stdout)
[17:44:50.608]         }, add = TRUE)
[17:44:50.608]     }
[17:44:50.608]     ...future.frame <- base::sys.nframe()
[17:44:50.608]     ...future.conditions <- base::list()
[17:44:50.608]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.608]     if (FALSE) {
[17:44:50.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.608]     }
[17:44:50.608]     ...future.result <- base::tryCatch({
[17:44:50.608]         base::withCallingHandlers({
[17:44:50.608]             ...future.value <- base::withVisible(base::local({
[17:44:50.608]                 ...future.makeSendCondition <- base::local({
[17:44:50.608]                   sendCondition <- NULL
[17:44:50.608]                   function(frame = 1L) {
[17:44:50.608]                     if (is.function(sendCondition)) 
[17:44:50.608]                       return(sendCondition)
[17:44:50.608]                     ns <- getNamespace("parallel")
[17:44:50.608]                     if (exists("sendData", mode = "function", 
[17:44:50.608]                       envir = ns)) {
[17:44:50.608]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.608]                         envir = ns)
[17:44:50.608]                       envir <- sys.frame(frame)
[17:44:50.608]                       master <- NULL
[17:44:50.608]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.608]                         !identical(envir, emptyenv())) {
[17:44:50.608]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.608]                           inherits = FALSE)) {
[17:44:50.608]                           master <- get("master", mode = "list", 
[17:44:50.608]                             envir = envir, inherits = FALSE)
[17:44:50.608]                           if (inherits(master, c("SOCKnode", 
[17:44:50.608]                             "SOCK0node"))) {
[17:44:50.608]                             sendCondition <<- function(cond) {
[17:44:50.608]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.608]                                 success = TRUE)
[17:44:50.608]                               parallel_sendData(master, data)
[17:44:50.608]                             }
[17:44:50.608]                             return(sendCondition)
[17:44:50.608]                           }
[17:44:50.608]                         }
[17:44:50.608]                         frame <- frame + 1L
[17:44:50.608]                         envir <- sys.frame(frame)
[17:44:50.608]                       }
[17:44:50.608]                     }
[17:44:50.608]                     sendCondition <<- function(cond) NULL
[17:44:50.608]                   }
[17:44:50.608]                 })
[17:44:50.608]                 withCallingHandlers({
[17:44:50.608]                   {
[17:44:50.608]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.608]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.608]                       ...future.globals.maxSize)) {
[17:44:50.608]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.608]                       on.exit(options(oopts), add = TRUE)
[17:44:50.608]                     }
[17:44:50.608]                     {
[17:44:50.608]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.608]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.608]                         USE.NAMES = FALSE)
[17:44:50.608]                       do.call(mapply, args = args)
[17:44:50.608]                     }
[17:44:50.608]                   }
[17:44:50.608]                 }, immediateCondition = function(cond) {
[17:44:50.608]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.608]                   sendCondition(cond)
[17:44:50.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.608]                   {
[17:44:50.608]                     inherits <- base::inherits
[17:44:50.608]                     invokeRestart <- base::invokeRestart
[17:44:50.608]                     is.null <- base::is.null
[17:44:50.608]                     muffled <- FALSE
[17:44:50.608]                     if (inherits(cond, "message")) {
[17:44:50.608]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.608]                       if (muffled) 
[17:44:50.608]                         invokeRestart("muffleMessage")
[17:44:50.608]                     }
[17:44:50.608]                     else if (inherits(cond, "warning")) {
[17:44:50.608]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.608]                       if (muffled) 
[17:44:50.608]                         invokeRestart("muffleWarning")
[17:44:50.608]                     }
[17:44:50.608]                     else if (inherits(cond, "condition")) {
[17:44:50.608]                       if (!is.null(pattern)) {
[17:44:50.608]                         computeRestarts <- base::computeRestarts
[17:44:50.608]                         grepl <- base::grepl
[17:44:50.608]                         restarts <- computeRestarts(cond)
[17:44:50.608]                         for (restart in restarts) {
[17:44:50.608]                           name <- restart$name
[17:44:50.608]                           if (is.null(name)) 
[17:44:50.608]                             next
[17:44:50.608]                           if (!grepl(pattern, name)) 
[17:44:50.608]                             next
[17:44:50.608]                           invokeRestart(restart)
[17:44:50.608]                           muffled <- TRUE
[17:44:50.608]                           break
[17:44:50.608]                         }
[17:44:50.608]                       }
[17:44:50.608]                     }
[17:44:50.608]                     invisible(muffled)
[17:44:50.608]                   }
[17:44:50.608]                   muffleCondition(cond)
[17:44:50.608]                 })
[17:44:50.608]             }))
[17:44:50.608]             future::FutureResult(value = ...future.value$value, 
[17:44:50.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.608]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.608]                     ...future.globalenv.names))
[17:44:50.608]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.608]         }, condition = base::local({
[17:44:50.608]             c <- base::c
[17:44:50.608]             inherits <- base::inherits
[17:44:50.608]             invokeRestart <- base::invokeRestart
[17:44:50.608]             length <- base::length
[17:44:50.608]             list <- base::list
[17:44:50.608]             seq.int <- base::seq.int
[17:44:50.608]             signalCondition <- base::signalCondition
[17:44:50.608]             sys.calls <- base::sys.calls
[17:44:50.608]             `[[` <- base::`[[`
[17:44:50.608]             `+` <- base::`+`
[17:44:50.608]             `<<-` <- base::`<<-`
[17:44:50.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.608]                   3L)]
[17:44:50.608]             }
[17:44:50.608]             function(cond) {
[17:44:50.608]                 is_error <- inherits(cond, "error")
[17:44:50.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.608]                   NULL)
[17:44:50.608]                 if (is_error) {
[17:44:50.608]                   sessionInformation <- function() {
[17:44:50.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.608]                       search = base::search(), system = base::Sys.info())
[17:44:50.608]                   }
[17:44:50.608]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.608]                     cond$call), session = sessionInformation(), 
[17:44:50.608]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.608]                   signalCondition(cond)
[17:44:50.608]                 }
[17:44:50.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.608]                 "immediateCondition"))) {
[17:44:50.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.608]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.608]                   if (TRUE && !signal) {
[17:44:50.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.608]                     {
[17:44:50.608]                       inherits <- base::inherits
[17:44:50.608]                       invokeRestart <- base::invokeRestart
[17:44:50.608]                       is.null <- base::is.null
[17:44:50.608]                       muffled <- FALSE
[17:44:50.608]                       if (inherits(cond, "message")) {
[17:44:50.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.608]                         if (muffled) 
[17:44:50.608]                           invokeRestart("muffleMessage")
[17:44:50.608]                       }
[17:44:50.608]                       else if (inherits(cond, "warning")) {
[17:44:50.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.608]                         if (muffled) 
[17:44:50.608]                           invokeRestart("muffleWarning")
[17:44:50.608]                       }
[17:44:50.608]                       else if (inherits(cond, "condition")) {
[17:44:50.608]                         if (!is.null(pattern)) {
[17:44:50.608]                           computeRestarts <- base::computeRestarts
[17:44:50.608]                           grepl <- base::grepl
[17:44:50.608]                           restarts <- computeRestarts(cond)
[17:44:50.608]                           for (restart in restarts) {
[17:44:50.608]                             name <- restart$name
[17:44:50.608]                             if (is.null(name)) 
[17:44:50.608]                               next
[17:44:50.608]                             if (!grepl(pattern, name)) 
[17:44:50.608]                               next
[17:44:50.608]                             invokeRestart(restart)
[17:44:50.608]                             muffled <- TRUE
[17:44:50.608]                             break
[17:44:50.608]                           }
[17:44:50.608]                         }
[17:44:50.608]                       }
[17:44:50.608]                       invisible(muffled)
[17:44:50.608]                     }
[17:44:50.608]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.608]                   }
[17:44:50.608]                 }
[17:44:50.608]                 else {
[17:44:50.608]                   if (TRUE) {
[17:44:50.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.608]                     {
[17:44:50.608]                       inherits <- base::inherits
[17:44:50.608]                       invokeRestart <- base::invokeRestart
[17:44:50.608]                       is.null <- base::is.null
[17:44:50.608]                       muffled <- FALSE
[17:44:50.608]                       if (inherits(cond, "message")) {
[17:44:50.608]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.608]                         if (muffled) 
[17:44:50.608]                           invokeRestart("muffleMessage")
[17:44:50.608]                       }
[17:44:50.608]                       else if (inherits(cond, "warning")) {
[17:44:50.608]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.608]                         if (muffled) 
[17:44:50.608]                           invokeRestart("muffleWarning")
[17:44:50.608]                       }
[17:44:50.608]                       else if (inherits(cond, "condition")) {
[17:44:50.608]                         if (!is.null(pattern)) {
[17:44:50.608]                           computeRestarts <- base::computeRestarts
[17:44:50.608]                           grepl <- base::grepl
[17:44:50.608]                           restarts <- computeRestarts(cond)
[17:44:50.608]                           for (restart in restarts) {
[17:44:50.608]                             name <- restart$name
[17:44:50.608]                             if (is.null(name)) 
[17:44:50.608]                               next
[17:44:50.608]                             if (!grepl(pattern, name)) 
[17:44:50.608]                               next
[17:44:50.608]                             invokeRestart(restart)
[17:44:50.608]                             muffled <- TRUE
[17:44:50.608]                             break
[17:44:50.608]                           }
[17:44:50.608]                         }
[17:44:50.608]                       }
[17:44:50.608]                       invisible(muffled)
[17:44:50.608]                     }
[17:44:50.608]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.608]                   }
[17:44:50.608]                 }
[17:44:50.608]             }
[17:44:50.608]         }))
[17:44:50.608]     }, error = function(ex) {
[17:44:50.608]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.608]                 ...future.rng), started = ...future.startTime, 
[17:44:50.608]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.608]             version = "1.8"), class = "FutureResult")
[17:44:50.608]     }, finally = {
[17:44:50.608]         if (!identical(...future.workdir, getwd())) 
[17:44:50.608]             setwd(...future.workdir)
[17:44:50.608]         {
[17:44:50.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.608]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.608]             }
[17:44:50.608]             base::options(...future.oldOptions)
[17:44:50.608]             if (.Platform$OS.type == "windows") {
[17:44:50.608]                 old_names <- names(...future.oldEnvVars)
[17:44:50.608]                 envs <- base::Sys.getenv()
[17:44:50.608]                 names <- names(envs)
[17:44:50.608]                 common <- intersect(names, old_names)
[17:44:50.608]                 added <- setdiff(names, old_names)
[17:44:50.608]                 removed <- setdiff(old_names, names)
[17:44:50.608]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.608]                   envs[common]]
[17:44:50.608]                 NAMES <- toupper(changed)
[17:44:50.608]                 args <- list()
[17:44:50.608]                 for (kk in seq_along(NAMES)) {
[17:44:50.608]                   name <- changed[[kk]]
[17:44:50.608]                   NAME <- NAMES[[kk]]
[17:44:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.608]                     next
[17:44:50.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.608]                 }
[17:44:50.608]                 NAMES <- toupper(added)
[17:44:50.608]                 for (kk in seq_along(NAMES)) {
[17:44:50.608]                   name <- added[[kk]]
[17:44:50.608]                   NAME <- NAMES[[kk]]
[17:44:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.608]                     next
[17:44:50.608]                   args[[name]] <- ""
[17:44:50.608]                 }
[17:44:50.608]                 NAMES <- toupper(removed)
[17:44:50.608]                 for (kk in seq_along(NAMES)) {
[17:44:50.608]                   name <- removed[[kk]]
[17:44:50.608]                   NAME <- NAMES[[kk]]
[17:44:50.608]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.608]                     next
[17:44:50.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.608]                 }
[17:44:50.608]                 if (length(args) > 0) 
[17:44:50.608]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.608]             }
[17:44:50.608]             else {
[17:44:50.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.608]             }
[17:44:50.608]             {
[17:44:50.608]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.608]                   0L) {
[17:44:50.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.608]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.608]                   base::options(opts)
[17:44:50.608]                 }
[17:44:50.608]                 {
[17:44:50.608]                   {
[17:44:50.608]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.608]                     NULL
[17:44:50.608]                   }
[17:44:50.608]                   options(future.plan = NULL)
[17:44:50.608]                   if (is.na(NA_character_)) 
[17:44:50.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.608]                     .init = FALSE)
[17:44:50.608]                 }
[17:44:50.608]             }
[17:44:50.608]         }
[17:44:50.608]     })
[17:44:50.608]     if (TRUE) {
[17:44:50.608]         base::sink(type = "output", split = FALSE)
[17:44:50.608]         if (TRUE) {
[17:44:50.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.608]         }
[17:44:50.608]         else {
[17:44:50.608]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.608]         }
[17:44:50.608]         base::close(...future.stdout)
[17:44:50.608]         ...future.stdout <- NULL
[17:44:50.608]     }
[17:44:50.608]     ...future.result$conditions <- ...future.conditions
[17:44:50.608]     ...future.result$finished <- base::Sys.time()
[17:44:50.608]     ...future.result
[17:44:50.608] }
[17:44:50.610] Poll #1 (0): usedNodes() = 2, workers = 2
[17:44:50.621] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.621] - Validating connection of MultisessionFuture
[17:44:50.621] - received message: FutureResult
[17:44:50.621] - Received FutureResult
[17:44:50.621] - Erased future from FutureRegistry
[17:44:50.621] result() for ClusterFuture ...
[17:44:50.621] - result already collected: FutureResult
[17:44:50.621] result() for ClusterFuture ... done
[17:44:50.621] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.622] result() for ClusterFuture ...
[17:44:50.622] - result already collected: FutureResult
[17:44:50.622] result() for ClusterFuture ... done
[17:44:50.622] result() for ClusterFuture ...
[17:44:50.622] - result already collected: FutureResult
[17:44:50.622] result() for ClusterFuture ... done
[17:44:50.623] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:44:50.623] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.623] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.623] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.624] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.624] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:44:50.624] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:44:50.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.625] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:44:50.625] MultisessionFuture started
[17:44:50.626] - Launch lazy future ... done
[17:44:50.626] run() for ‘MultisessionFuture’ ... done
[17:44:50.626] Created future:
[17:44:50.626] MultisessionFuture:
[17:44:50.626] Label: ‘future_mapply-3’
[17:44:50.626] Expression:
[17:44:50.626] {
[17:44:50.626]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.626]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.626]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.626]         on.exit(options(oopts), add = TRUE)
[17:44:50.626]     }
[17:44:50.626]     {
[17:44:50.626]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.626]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.626]         do.call(mapply, args = args)
[17:44:50.626]     }
[17:44:50.626] }
[17:44:50.626] Lazy evaluation: FALSE
[17:44:50.626] Asynchronous evaluation: TRUE
[17:44:50.626] Local evaluation: TRUE
[17:44:50.626] Environment: R_GlobalEnv
[17:44:50.626] Capture standard output: TRUE
[17:44:50.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.626] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.626] Packages: <none>
[17:44:50.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.626] Resolved: FALSE
[17:44:50.626] Value: <not collected>
[17:44:50.626] Conditions captured: <none>
[17:44:50.626] Early signaling: FALSE
[17:44:50.626] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.637] Chunk #3 of 5 ... DONE
[17:44:50.637] Chunk #4 of 5 ...
[17:44:50.637]  - Finding globals in '...' for chunk #4 ...
[17:44:50.637] getGlobalsAndPackages() ...
[17:44:50.637] Searching for globals...
[17:44:50.638] 
[17:44:50.638] Searching for globals ... DONE
[17:44:50.638] - globals: [0] <none>
[17:44:50.638] getGlobalsAndPackages() ... DONE
[17:44:50.638]    + additional globals found: [n=0] 
[17:44:50.638]    + additional namespaces needed: [n=0] 
[17:44:50.638]  - Finding globals in '...' for chunk #4 ... DONE
[17:44:50.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:50.638]  - seeds: <none>
[17:44:50.639]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.639] getGlobalsAndPackages() ...
[17:44:50.639] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.639] Resolving globals: FALSE
[17:44:50.639] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.640] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.640] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.640] 
[17:44:50.640] getGlobalsAndPackages() ... DONE
[17:44:50.640] run() for ‘Future’ ...
[17:44:50.640] - state: ‘created’
[17:44:50.641] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.655] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.655]   - Field: ‘node’
[17:44:50.655]   - Field: ‘label’
[17:44:50.655]   - Field: ‘local’
[17:44:50.655]   - Field: ‘owner’
[17:44:50.656]   - Field: ‘envir’
[17:44:50.656]   - Field: ‘workers’
[17:44:50.656]   - Field: ‘packages’
[17:44:50.656]   - Field: ‘gc’
[17:44:50.656]   - Field: ‘conditions’
[17:44:50.656]   - Field: ‘persistent’
[17:44:50.656]   - Field: ‘expr’
[17:44:50.656]   - Field: ‘uuid’
[17:44:50.656]   - Field: ‘seed’
[17:44:50.656]   - Field: ‘version’
[17:44:50.657]   - Field: ‘result’
[17:44:50.657]   - Field: ‘asynchronous’
[17:44:50.657]   - Field: ‘calls’
[17:44:50.657]   - Field: ‘globals’
[17:44:50.657]   - Field: ‘stdout’
[17:44:50.657]   - Field: ‘earlySignal’
[17:44:50.657]   - Field: ‘lazy’
[17:44:50.657]   - Field: ‘state’
[17:44:50.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.657] - Launch lazy future ...
[17:44:50.658] Packages needed by the future expression (n = 0): <none>
[17:44:50.660] Packages needed by future strategies (n = 0): <none>
[17:44:50.660] {
[17:44:50.660]     {
[17:44:50.660]         {
[17:44:50.660]             ...future.startTime <- base::Sys.time()
[17:44:50.660]             {
[17:44:50.660]                 {
[17:44:50.660]                   {
[17:44:50.660]                     {
[17:44:50.660]                       base::local({
[17:44:50.660]                         has_future <- base::requireNamespace("future", 
[17:44:50.660]                           quietly = TRUE)
[17:44:50.660]                         if (has_future) {
[17:44:50.660]                           ns <- base::getNamespace("future")
[17:44:50.660]                           version <- ns[[".package"]][["version"]]
[17:44:50.660]                           if (is.null(version)) 
[17:44:50.660]                             version <- utils::packageVersion("future")
[17:44:50.660]                         }
[17:44:50.660]                         else {
[17:44:50.660]                           version <- NULL
[17:44:50.660]                         }
[17:44:50.660]                         if (!has_future || version < "1.8.0") {
[17:44:50.660]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.660]                             "", base::R.version$version.string), 
[17:44:50.660]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.660]                               "release", "version")], collapse = " "), 
[17:44:50.660]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.660]                             info)
[17:44:50.660]                           info <- base::paste(info, collapse = "; ")
[17:44:50.660]                           if (!has_future) {
[17:44:50.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.660]                               info)
[17:44:50.660]                           }
[17:44:50.660]                           else {
[17:44:50.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.660]                               info, version)
[17:44:50.660]                           }
[17:44:50.660]                           base::stop(msg)
[17:44:50.660]                         }
[17:44:50.660]                       })
[17:44:50.660]                     }
[17:44:50.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.660]                     base::options(mc.cores = 1L)
[17:44:50.660]                   }
[17:44:50.660]                   ...future.strategy.old <- future::plan("list")
[17:44:50.660]                   options(future.plan = NULL)
[17:44:50.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.660]                 }
[17:44:50.660]                 ...future.workdir <- getwd()
[17:44:50.660]             }
[17:44:50.660]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.660]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.660]         }
[17:44:50.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.660]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:50.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.660]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.660]             base::names(...future.oldOptions))
[17:44:50.660]     }
[17:44:50.660]     if (FALSE) {
[17:44:50.660]     }
[17:44:50.660]     else {
[17:44:50.660]         if (TRUE) {
[17:44:50.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.660]                 open = "w")
[17:44:50.660]         }
[17:44:50.660]         else {
[17:44:50.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.660]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.660]         }
[17:44:50.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.660]             base::sink(type = "output", split = FALSE)
[17:44:50.660]             base::close(...future.stdout)
[17:44:50.660]         }, add = TRUE)
[17:44:50.660]     }
[17:44:50.660]     ...future.frame <- base::sys.nframe()
[17:44:50.660]     ...future.conditions <- base::list()
[17:44:50.660]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.660]     if (FALSE) {
[17:44:50.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.660]     }
[17:44:50.660]     ...future.result <- base::tryCatch({
[17:44:50.660]         base::withCallingHandlers({
[17:44:50.660]             ...future.value <- base::withVisible(base::local({
[17:44:50.660]                 ...future.makeSendCondition <- base::local({
[17:44:50.660]                   sendCondition <- NULL
[17:44:50.660]                   function(frame = 1L) {
[17:44:50.660]                     if (is.function(sendCondition)) 
[17:44:50.660]                       return(sendCondition)
[17:44:50.660]                     ns <- getNamespace("parallel")
[17:44:50.660]                     if (exists("sendData", mode = "function", 
[17:44:50.660]                       envir = ns)) {
[17:44:50.660]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.660]                         envir = ns)
[17:44:50.660]                       envir <- sys.frame(frame)
[17:44:50.660]                       master <- NULL
[17:44:50.660]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.660]                         !identical(envir, emptyenv())) {
[17:44:50.660]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.660]                           inherits = FALSE)) {
[17:44:50.660]                           master <- get("master", mode = "list", 
[17:44:50.660]                             envir = envir, inherits = FALSE)
[17:44:50.660]                           if (inherits(master, c("SOCKnode", 
[17:44:50.660]                             "SOCK0node"))) {
[17:44:50.660]                             sendCondition <<- function(cond) {
[17:44:50.660]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.660]                                 success = TRUE)
[17:44:50.660]                               parallel_sendData(master, data)
[17:44:50.660]                             }
[17:44:50.660]                             return(sendCondition)
[17:44:50.660]                           }
[17:44:50.660]                         }
[17:44:50.660]                         frame <- frame + 1L
[17:44:50.660]                         envir <- sys.frame(frame)
[17:44:50.660]                       }
[17:44:50.660]                     }
[17:44:50.660]                     sendCondition <<- function(cond) NULL
[17:44:50.660]                   }
[17:44:50.660]                 })
[17:44:50.660]                 withCallingHandlers({
[17:44:50.660]                   {
[17:44:50.660]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.660]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.660]                       ...future.globals.maxSize)) {
[17:44:50.660]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.660]                       on.exit(options(oopts), add = TRUE)
[17:44:50.660]                     }
[17:44:50.660]                     {
[17:44:50.660]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.660]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.660]                         USE.NAMES = FALSE)
[17:44:50.660]                       do.call(mapply, args = args)
[17:44:50.660]                     }
[17:44:50.660]                   }
[17:44:50.660]                 }, immediateCondition = function(cond) {
[17:44:50.660]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.660]                   sendCondition(cond)
[17:44:50.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.660]                   {
[17:44:50.660]                     inherits <- base::inherits
[17:44:50.660]                     invokeRestart <- base::invokeRestart
[17:44:50.660]                     is.null <- base::is.null
[17:44:50.660]                     muffled <- FALSE
[17:44:50.660]                     if (inherits(cond, "message")) {
[17:44:50.660]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.660]                       if (muffled) 
[17:44:50.660]                         invokeRestart("muffleMessage")
[17:44:50.660]                     }
[17:44:50.660]                     else if (inherits(cond, "warning")) {
[17:44:50.660]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.660]                       if (muffled) 
[17:44:50.660]                         invokeRestart("muffleWarning")
[17:44:50.660]                     }
[17:44:50.660]                     else if (inherits(cond, "condition")) {
[17:44:50.660]                       if (!is.null(pattern)) {
[17:44:50.660]                         computeRestarts <- base::computeRestarts
[17:44:50.660]                         grepl <- base::grepl
[17:44:50.660]                         restarts <- computeRestarts(cond)
[17:44:50.660]                         for (restart in restarts) {
[17:44:50.660]                           name <- restart$name
[17:44:50.660]                           if (is.null(name)) 
[17:44:50.660]                             next
[17:44:50.660]                           if (!grepl(pattern, name)) 
[17:44:50.660]                             next
[17:44:50.660]                           invokeRestart(restart)
[17:44:50.660]                           muffled <- TRUE
[17:44:50.660]                           break
[17:44:50.660]                         }
[17:44:50.660]                       }
[17:44:50.660]                     }
[17:44:50.660]                     invisible(muffled)
[17:44:50.660]                   }
[17:44:50.660]                   muffleCondition(cond)
[17:44:50.660]                 })
[17:44:50.660]             }))
[17:44:50.660]             future::FutureResult(value = ...future.value$value, 
[17:44:50.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.660]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.660]                     ...future.globalenv.names))
[17:44:50.660]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.660]         }, condition = base::local({
[17:44:50.660]             c <- base::c
[17:44:50.660]             inherits <- base::inherits
[17:44:50.660]             invokeRestart <- base::invokeRestart
[17:44:50.660]             length <- base::length
[17:44:50.660]             list <- base::list
[17:44:50.660]             seq.int <- base::seq.int
[17:44:50.660]             signalCondition <- base::signalCondition
[17:44:50.660]             sys.calls <- base::sys.calls
[17:44:50.660]             `[[` <- base::`[[`
[17:44:50.660]             `+` <- base::`+`
[17:44:50.660]             `<<-` <- base::`<<-`
[17:44:50.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.660]                   3L)]
[17:44:50.660]             }
[17:44:50.660]             function(cond) {
[17:44:50.660]                 is_error <- inherits(cond, "error")
[17:44:50.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.660]                   NULL)
[17:44:50.660]                 if (is_error) {
[17:44:50.660]                   sessionInformation <- function() {
[17:44:50.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.660]                       search = base::search(), system = base::Sys.info())
[17:44:50.660]                   }
[17:44:50.660]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.660]                     cond$call), session = sessionInformation(), 
[17:44:50.660]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.660]                   signalCondition(cond)
[17:44:50.660]                 }
[17:44:50.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.660]                 "immediateCondition"))) {
[17:44:50.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.660]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.660]                   if (TRUE && !signal) {
[17:44:50.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.660]                     {
[17:44:50.660]                       inherits <- base::inherits
[17:44:50.660]                       invokeRestart <- base::invokeRestart
[17:44:50.660]                       is.null <- base::is.null
[17:44:50.660]                       muffled <- FALSE
[17:44:50.660]                       if (inherits(cond, "message")) {
[17:44:50.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.660]                         if (muffled) 
[17:44:50.660]                           invokeRestart("muffleMessage")
[17:44:50.660]                       }
[17:44:50.660]                       else if (inherits(cond, "warning")) {
[17:44:50.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.660]                         if (muffled) 
[17:44:50.660]                           invokeRestart("muffleWarning")
[17:44:50.660]                       }
[17:44:50.660]                       else if (inherits(cond, "condition")) {
[17:44:50.660]                         if (!is.null(pattern)) {
[17:44:50.660]                           computeRestarts <- base::computeRestarts
[17:44:50.660]                           grepl <- base::grepl
[17:44:50.660]                           restarts <- computeRestarts(cond)
[17:44:50.660]                           for (restart in restarts) {
[17:44:50.660]                             name <- restart$name
[17:44:50.660]                             if (is.null(name)) 
[17:44:50.660]                               next
[17:44:50.660]                             if (!grepl(pattern, name)) 
[17:44:50.660]                               next
[17:44:50.660]                             invokeRestart(restart)
[17:44:50.660]                             muffled <- TRUE
[17:44:50.660]                             break
[17:44:50.660]                           }
[17:44:50.660]                         }
[17:44:50.660]                       }
[17:44:50.660]                       invisible(muffled)
[17:44:50.660]                     }
[17:44:50.660]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.660]                   }
[17:44:50.660]                 }
[17:44:50.660]                 else {
[17:44:50.660]                   if (TRUE) {
[17:44:50.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.660]                     {
[17:44:50.660]                       inherits <- base::inherits
[17:44:50.660]                       invokeRestart <- base::invokeRestart
[17:44:50.660]                       is.null <- base::is.null
[17:44:50.660]                       muffled <- FALSE
[17:44:50.660]                       if (inherits(cond, "message")) {
[17:44:50.660]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.660]                         if (muffled) 
[17:44:50.660]                           invokeRestart("muffleMessage")
[17:44:50.660]                       }
[17:44:50.660]                       else if (inherits(cond, "warning")) {
[17:44:50.660]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.660]                         if (muffled) 
[17:44:50.660]                           invokeRestart("muffleWarning")
[17:44:50.660]                       }
[17:44:50.660]                       else if (inherits(cond, "condition")) {
[17:44:50.660]                         if (!is.null(pattern)) {
[17:44:50.660]                           computeRestarts <- base::computeRestarts
[17:44:50.660]                           grepl <- base::grepl
[17:44:50.660]                           restarts <- computeRestarts(cond)
[17:44:50.660]                           for (restart in restarts) {
[17:44:50.660]                             name <- restart$name
[17:44:50.660]                             if (is.null(name)) 
[17:44:50.660]                               next
[17:44:50.660]                             if (!grepl(pattern, name)) 
[17:44:50.660]                               next
[17:44:50.660]                             invokeRestart(restart)
[17:44:50.660]                             muffled <- TRUE
[17:44:50.660]                             break
[17:44:50.660]                           }
[17:44:50.660]                         }
[17:44:50.660]                       }
[17:44:50.660]                       invisible(muffled)
[17:44:50.660]                     }
[17:44:50.660]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.660]                   }
[17:44:50.660]                 }
[17:44:50.660]             }
[17:44:50.660]         }))
[17:44:50.660]     }, error = function(ex) {
[17:44:50.660]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.660]                 ...future.rng), started = ...future.startTime, 
[17:44:50.660]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.660]             version = "1.8"), class = "FutureResult")
[17:44:50.660]     }, finally = {
[17:44:50.660]         if (!identical(...future.workdir, getwd())) 
[17:44:50.660]             setwd(...future.workdir)
[17:44:50.660]         {
[17:44:50.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.660]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.660]             }
[17:44:50.660]             base::options(...future.oldOptions)
[17:44:50.660]             if (.Platform$OS.type == "windows") {
[17:44:50.660]                 old_names <- names(...future.oldEnvVars)
[17:44:50.660]                 envs <- base::Sys.getenv()
[17:44:50.660]                 names <- names(envs)
[17:44:50.660]                 common <- intersect(names, old_names)
[17:44:50.660]                 added <- setdiff(names, old_names)
[17:44:50.660]                 removed <- setdiff(old_names, names)
[17:44:50.660]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.660]                   envs[common]]
[17:44:50.660]                 NAMES <- toupper(changed)
[17:44:50.660]                 args <- list()
[17:44:50.660]                 for (kk in seq_along(NAMES)) {
[17:44:50.660]                   name <- changed[[kk]]
[17:44:50.660]                   NAME <- NAMES[[kk]]
[17:44:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.660]                     next
[17:44:50.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.660]                 }
[17:44:50.660]                 NAMES <- toupper(added)
[17:44:50.660]                 for (kk in seq_along(NAMES)) {
[17:44:50.660]                   name <- added[[kk]]
[17:44:50.660]                   NAME <- NAMES[[kk]]
[17:44:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.660]                     next
[17:44:50.660]                   args[[name]] <- ""
[17:44:50.660]                 }
[17:44:50.660]                 NAMES <- toupper(removed)
[17:44:50.660]                 for (kk in seq_along(NAMES)) {
[17:44:50.660]                   name <- removed[[kk]]
[17:44:50.660]                   NAME <- NAMES[[kk]]
[17:44:50.660]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.660]                     next
[17:44:50.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.660]                 }
[17:44:50.660]                 if (length(args) > 0) 
[17:44:50.660]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.660]             }
[17:44:50.660]             else {
[17:44:50.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.660]             }
[17:44:50.660]             {
[17:44:50.660]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.660]                   0L) {
[17:44:50.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.660]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.660]                   base::options(opts)
[17:44:50.660]                 }
[17:44:50.660]                 {
[17:44:50.660]                   {
[17:44:50.660]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.660]                     NULL
[17:44:50.660]                   }
[17:44:50.660]                   options(future.plan = NULL)
[17:44:50.660]                   if (is.na(NA_character_)) 
[17:44:50.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.660]                     .init = FALSE)
[17:44:50.660]                 }
[17:44:50.660]             }
[17:44:50.660]         }
[17:44:50.660]     })
[17:44:50.660]     if (TRUE) {
[17:44:50.660]         base::sink(type = "output", split = FALSE)
[17:44:50.660]         if (TRUE) {
[17:44:50.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.660]         }
[17:44:50.660]         else {
[17:44:50.660]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.660]         }
[17:44:50.660]         base::close(...future.stdout)
[17:44:50.660]         ...future.stdout <- NULL
[17:44:50.660]     }
[17:44:50.660]     ...future.result$conditions <- ...future.conditions
[17:44:50.660]     ...future.result$finished <- base::Sys.time()
[17:44:50.660]     ...future.result
[17:44:50.660] }
[17:44:50.662] Poll #1 (0): usedNodes() = 2, workers = 2
[17:44:50.673] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.673] - Validating connection of MultisessionFuture
[17:44:50.673] - received message: FutureResult
[17:44:50.673] - Received FutureResult
[17:44:50.673] - Erased future from FutureRegistry
[17:44:50.674] result() for ClusterFuture ...
[17:44:50.674] - result already collected: FutureResult
[17:44:50.674] result() for ClusterFuture ... done
[17:44:50.674] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.674] result() for ClusterFuture ...
[17:44:50.674] - result already collected: FutureResult
[17:44:50.674] result() for ClusterFuture ... done
[17:44:50.674] result() for ClusterFuture ...
[17:44:50.674] - result already collected: FutureResult
[17:44:50.674] result() for ClusterFuture ... done
[17:44:50.675] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:44:50.675] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:50.675] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:50.676] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.676] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.676] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:44:50.676] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:44:50.676] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.677] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.677] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.677] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.677] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:44:50.678] MultisessionFuture started
[17:44:50.678] - Launch lazy future ... done
[17:44:50.678] run() for ‘MultisessionFuture’ ... done
[17:44:50.678] Created future:
[17:44:50.678] MultisessionFuture:
[17:44:50.678] Label: ‘future_mapply-4’
[17:44:50.678] Expression:
[17:44:50.678] {
[17:44:50.678]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.678]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.678]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.678]         on.exit(options(oopts), add = TRUE)
[17:44:50.678]     }
[17:44:50.678]     {
[17:44:50.678]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.678]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.678]         do.call(mapply, args = args)
[17:44:50.678]     }
[17:44:50.678] }
[17:44:50.678] Lazy evaluation: FALSE
[17:44:50.678] Asynchronous evaluation: TRUE
[17:44:50.678] Local evaluation: TRUE
[17:44:50.678] Environment: R_GlobalEnv
[17:44:50.678] Capture standard output: TRUE
[17:44:50.678] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.678] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.678] Packages: <none>
[17:44:50.678] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.678] Resolved: FALSE
[17:44:50.678] Value: <not collected>
[17:44:50.678] Conditions captured: <none>
[17:44:50.678] Early signaling: FALSE
[17:44:50.678] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.678] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.689] Chunk #4 of 5 ... DONE
[17:44:50.689] Chunk #5 of 5 ...
[17:44:50.690]  - Finding globals in '...' for chunk #5 ...
[17:44:50.690] getGlobalsAndPackages() ...
[17:44:50.690] Searching for globals...
[17:44:50.690] 
[17:44:50.690] Searching for globals ... DONE
[17:44:50.690] - globals: [0] <none>
[17:44:50.690] getGlobalsAndPackages() ... DONE
[17:44:50.690]    + additional globals found: [n=0] 
[17:44:50.690]    + additional namespaces needed: [n=0] 
[17:44:50.691]  - Finding globals in '...' for chunk #5 ... DONE
[17:44:50.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 5 * 524288000 = 2621440000 (bytes)
[17:44:50.691]  - seeds: <none>
[17:44:50.691]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.691] getGlobalsAndPackages() ...
[17:44:50.691] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.691] Resolving globals: FALSE
[17:44:50.692] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.692] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 2.44 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.692] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.692] 
[17:44:50.692] getGlobalsAndPackages() ... DONE
[17:44:50.693] run() for ‘Future’ ...
[17:44:50.693] - state: ‘created’
[17:44:50.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.707]   - Field: ‘node’
[17:44:50.707]   - Field: ‘label’
[17:44:50.707]   - Field: ‘local’
[17:44:50.707]   - Field: ‘owner’
[17:44:50.707]   - Field: ‘envir’
[17:44:50.708]   - Field: ‘workers’
[17:44:50.708]   - Field: ‘packages’
[17:44:50.708]   - Field: ‘gc’
[17:44:50.708]   - Field: ‘conditions’
[17:44:50.708]   - Field: ‘persistent’
[17:44:50.708]   - Field: ‘expr’
[17:44:50.708]   - Field: ‘uuid’
[17:44:50.708]   - Field: ‘seed’
[17:44:50.708]   - Field: ‘version’
[17:44:50.708]   - Field: ‘result’
[17:44:50.708]   - Field: ‘asynchronous’
[17:44:50.708]   - Field: ‘calls’
[17:44:50.709]   - Field: ‘globals’
[17:44:50.709]   - Field: ‘stdout’
[17:44:50.709]   - Field: ‘earlySignal’
[17:44:50.709]   - Field: ‘lazy’
[17:44:50.709]   - Field: ‘state’
[17:44:50.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.709] - Launch lazy future ...
[17:44:50.709] Packages needed by the future expression (n = 0): <none>
[17:44:50.710] Packages needed by future strategies (n = 0): <none>
[17:44:50.710] {
[17:44:50.710]     {
[17:44:50.710]         {
[17:44:50.710]             ...future.startTime <- base::Sys.time()
[17:44:50.710]             {
[17:44:50.710]                 {
[17:44:50.710]                   {
[17:44:50.710]                     {
[17:44:50.710]                       base::local({
[17:44:50.710]                         has_future <- base::requireNamespace("future", 
[17:44:50.710]                           quietly = TRUE)
[17:44:50.710]                         if (has_future) {
[17:44:50.710]                           ns <- base::getNamespace("future")
[17:44:50.710]                           version <- ns[[".package"]][["version"]]
[17:44:50.710]                           if (is.null(version)) 
[17:44:50.710]                             version <- utils::packageVersion("future")
[17:44:50.710]                         }
[17:44:50.710]                         else {
[17:44:50.710]                           version <- NULL
[17:44:50.710]                         }
[17:44:50.710]                         if (!has_future || version < "1.8.0") {
[17:44:50.710]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.710]                             "", base::R.version$version.string), 
[17:44:50.710]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.710]                               "release", "version")], collapse = " "), 
[17:44:50.710]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.710]                             info)
[17:44:50.710]                           info <- base::paste(info, collapse = "; ")
[17:44:50.710]                           if (!has_future) {
[17:44:50.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.710]                               info)
[17:44:50.710]                           }
[17:44:50.710]                           else {
[17:44:50.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.710]                               info, version)
[17:44:50.710]                           }
[17:44:50.710]                           base::stop(msg)
[17:44:50.710]                         }
[17:44:50.710]                       })
[17:44:50.710]                     }
[17:44:50.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.710]                     base::options(mc.cores = 1L)
[17:44:50.710]                   }
[17:44:50.710]                   ...future.strategy.old <- future::plan("list")
[17:44:50.710]                   options(future.plan = NULL)
[17:44:50.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.710]                 }
[17:44:50.710]                 ...future.workdir <- getwd()
[17:44:50.710]             }
[17:44:50.710]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.710]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.710]         }
[17:44:50.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.710]             future.globals.maxSize = 2621440000, future.globals.method = NULL, 
[17:44:50.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.710]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.710]             base::names(...future.oldOptions))
[17:44:50.710]     }
[17:44:50.710]     if (FALSE) {
[17:44:50.710]     }
[17:44:50.710]     else {
[17:44:50.710]         if (TRUE) {
[17:44:50.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.710]                 open = "w")
[17:44:50.710]         }
[17:44:50.710]         else {
[17:44:50.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.710]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.710]         }
[17:44:50.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.710]             base::sink(type = "output", split = FALSE)
[17:44:50.710]             base::close(...future.stdout)
[17:44:50.710]         }, add = TRUE)
[17:44:50.710]     }
[17:44:50.710]     ...future.frame <- base::sys.nframe()
[17:44:50.710]     ...future.conditions <- base::list()
[17:44:50.710]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.710]     if (FALSE) {
[17:44:50.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.710]     }
[17:44:50.710]     ...future.result <- base::tryCatch({
[17:44:50.710]         base::withCallingHandlers({
[17:44:50.710]             ...future.value <- base::withVisible(base::local({
[17:44:50.710]                 ...future.makeSendCondition <- base::local({
[17:44:50.710]                   sendCondition <- NULL
[17:44:50.710]                   function(frame = 1L) {
[17:44:50.710]                     if (is.function(sendCondition)) 
[17:44:50.710]                       return(sendCondition)
[17:44:50.710]                     ns <- getNamespace("parallel")
[17:44:50.710]                     if (exists("sendData", mode = "function", 
[17:44:50.710]                       envir = ns)) {
[17:44:50.710]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.710]                         envir = ns)
[17:44:50.710]                       envir <- sys.frame(frame)
[17:44:50.710]                       master <- NULL
[17:44:50.710]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.710]                         !identical(envir, emptyenv())) {
[17:44:50.710]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.710]                           inherits = FALSE)) {
[17:44:50.710]                           master <- get("master", mode = "list", 
[17:44:50.710]                             envir = envir, inherits = FALSE)
[17:44:50.710]                           if (inherits(master, c("SOCKnode", 
[17:44:50.710]                             "SOCK0node"))) {
[17:44:50.710]                             sendCondition <<- function(cond) {
[17:44:50.710]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.710]                                 success = TRUE)
[17:44:50.710]                               parallel_sendData(master, data)
[17:44:50.710]                             }
[17:44:50.710]                             return(sendCondition)
[17:44:50.710]                           }
[17:44:50.710]                         }
[17:44:50.710]                         frame <- frame + 1L
[17:44:50.710]                         envir <- sys.frame(frame)
[17:44:50.710]                       }
[17:44:50.710]                     }
[17:44:50.710]                     sendCondition <<- function(cond) NULL
[17:44:50.710]                   }
[17:44:50.710]                 })
[17:44:50.710]                 withCallingHandlers({
[17:44:50.710]                   {
[17:44:50.710]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.710]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.710]                       ...future.globals.maxSize)) {
[17:44:50.710]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.710]                       on.exit(options(oopts), add = TRUE)
[17:44:50.710]                     }
[17:44:50.710]                     {
[17:44:50.710]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.710]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.710]                         USE.NAMES = FALSE)
[17:44:50.710]                       do.call(mapply, args = args)
[17:44:50.710]                     }
[17:44:50.710]                   }
[17:44:50.710]                 }, immediateCondition = function(cond) {
[17:44:50.710]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.710]                   sendCondition(cond)
[17:44:50.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.710]                   {
[17:44:50.710]                     inherits <- base::inherits
[17:44:50.710]                     invokeRestart <- base::invokeRestart
[17:44:50.710]                     is.null <- base::is.null
[17:44:50.710]                     muffled <- FALSE
[17:44:50.710]                     if (inherits(cond, "message")) {
[17:44:50.710]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.710]                       if (muffled) 
[17:44:50.710]                         invokeRestart("muffleMessage")
[17:44:50.710]                     }
[17:44:50.710]                     else if (inherits(cond, "warning")) {
[17:44:50.710]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.710]                       if (muffled) 
[17:44:50.710]                         invokeRestart("muffleWarning")
[17:44:50.710]                     }
[17:44:50.710]                     else if (inherits(cond, "condition")) {
[17:44:50.710]                       if (!is.null(pattern)) {
[17:44:50.710]                         computeRestarts <- base::computeRestarts
[17:44:50.710]                         grepl <- base::grepl
[17:44:50.710]                         restarts <- computeRestarts(cond)
[17:44:50.710]                         for (restart in restarts) {
[17:44:50.710]                           name <- restart$name
[17:44:50.710]                           if (is.null(name)) 
[17:44:50.710]                             next
[17:44:50.710]                           if (!grepl(pattern, name)) 
[17:44:50.710]                             next
[17:44:50.710]                           invokeRestart(restart)
[17:44:50.710]                           muffled <- TRUE
[17:44:50.710]                           break
[17:44:50.710]                         }
[17:44:50.710]                       }
[17:44:50.710]                     }
[17:44:50.710]                     invisible(muffled)
[17:44:50.710]                   }
[17:44:50.710]                   muffleCondition(cond)
[17:44:50.710]                 })
[17:44:50.710]             }))
[17:44:50.710]             future::FutureResult(value = ...future.value$value, 
[17:44:50.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.710]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.710]                     ...future.globalenv.names))
[17:44:50.710]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.710]         }, condition = base::local({
[17:44:50.710]             c <- base::c
[17:44:50.710]             inherits <- base::inherits
[17:44:50.710]             invokeRestart <- base::invokeRestart
[17:44:50.710]             length <- base::length
[17:44:50.710]             list <- base::list
[17:44:50.710]             seq.int <- base::seq.int
[17:44:50.710]             signalCondition <- base::signalCondition
[17:44:50.710]             sys.calls <- base::sys.calls
[17:44:50.710]             `[[` <- base::`[[`
[17:44:50.710]             `+` <- base::`+`
[17:44:50.710]             `<<-` <- base::`<<-`
[17:44:50.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.710]                   3L)]
[17:44:50.710]             }
[17:44:50.710]             function(cond) {
[17:44:50.710]                 is_error <- inherits(cond, "error")
[17:44:50.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.710]                   NULL)
[17:44:50.710]                 if (is_error) {
[17:44:50.710]                   sessionInformation <- function() {
[17:44:50.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.710]                       search = base::search(), system = base::Sys.info())
[17:44:50.710]                   }
[17:44:50.710]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.710]                     cond$call), session = sessionInformation(), 
[17:44:50.710]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.710]                   signalCondition(cond)
[17:44:50.710]                 }
[17:44:50.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.710]                 "immediateCondition"))) {
[17:44:50.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.710]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.710]                   if (TRUE && !signal) {
[17:44:50.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.710]                     {
[17:44:50.710]                       inherits <- base::inherits
[17:44:50.710]                       invokeRestart <- base::invokeRestart
[17:44:50.710]                       is.null <- base::is.null
[17:44:50.710]                       muffled <- FALSE
[17:44:50.710]                       if (inherits(cond, "message")) {
[17:44:50.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.710]                         if (muffled) 
[17:44:50.710]                           invokeRestart("muffleMessage")
[17:44:50.710]                       }
[17:44:50.710]                       else if (inherits(cond, "warning")) {
[17:44:50.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.710]                         if (muffled) 
[17:44:50.710]                           invokeRestart("muffleWarning")
[17:44:50.710]                       }
[17:44:50.710]                       else if (inherits(cond, "condition")) {
[17:44:50.710]                         if (!is.null(pattern)) {
[17:44:50.710]                           computeRestarts <- base::computeRestarts
[17:44:50.710]                           grepl <- base::grepl
[17:44:50.710]                           restarts <- computeRestarts(cond)
[17:44:50.710]                           for (restart in restarts) {
[17:44:50.710]                             name <- restart$name
[17:44:50.710]                             if (is.null(name)) 
[17:44:50.710]                               next
[17:44:50.710]                             if (!grepl(pattern, name)) 
[17:44:50.710]                               next
[17:44:50.710]                             invokeRestart(restart)
[17:44:50.710]                             muffled <- TRUE
[17:44:50.710]                             break
[17:44:50.710]                           }
[17:44:50.710]                         }
[17:44:50.710]                       }
[17:44:50.710]                       invisible(muffled)
[17:44:50.710]                     }
[17:44:50.710]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.710]                   }
[17:44:50.710]                 }
[17:44:50.710]                 else {
[17:44:50.710]                   if (TRUE) {
[17:44:50.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.710]                     {
[17:44:50.710]                       inherits <- base::inherits
[17:44:50.710]                       invokeRestart <- base::invokeRestart
[17:44:50.710]                       is.null <- base::is.null
[17:44:50.710]                       muffled <- FALSE
[17:44:50.710]                       if (inherits(cond, "message")) {
[17:44:50.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.710]                         if (muffled) 
[17:44:50.710]                           invokeRestart("muffleMessage")
[17:44:50.710]                       }
[17:44:50.710]                       else if (inherits(cond, "warning")) {
[17:44:50.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.710]                         if (muffled) 
[17:44:50.710]                           invokeRestart("muffleWarning")
[17:44:50.710]                       }
[17:44:50.710]                       else if (inherits(cond, "condition")) {
[17:44:50.710]                         if (!is.null(pattern)) {
[17:44:50.710]                           computeRestarts <- base::computeRestarts
[17:44:50.710]                           grepl <- base::grepl
[17:44:50.710]                           restarts <- computeRestarts(cond)
[17:44:50.710]                           for (restart in restarts) {
[17:44:50.710]                             name <- restart$name
[17:44:50.710]                             if (is.null(name)) 
[17:44:50.710]                               next
[17:44:50.710]                             if (!grepl(pattern, name)) 
[17:44:50.710]                               next
[17:44:50.710]                             invokeRestart(restart)
[17:44:50.710]                             muffled <- TRUE
[17:44:50.710]                             break
[17:44:50.710]                           }
[17:44:50.710]                         }
[17:44:50.710]                       }
[17:44:50.710]                       invisible(muffled)
[17:44:50.710]                     }
[17:44:50.710]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.710]                   }
[17:44:50.710]                 }
[17:44:50.710]             }
[17:44:50.710]         }))
[17:44:50.710]     }, error = function(ex) {
[17:44:50.710]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.710]                 ...future.rng), started = ...future.startTime, 
[17:44:50.710]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.710]             version = "1.8"), class = "FutureResult")
[17:44:50.710]     }, finally = {
[17:44:50.710]         if (!identical(...future.workdir, getwd())) 
[17:44:50.710]             setwd(...future.workdir)
[17:44:50.710]         {
[17:44:50.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.710]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.710]             }
[17:44:50.710]             base::options(...future.oldOptions)
[17:44:50.710]             if (.Platform$OS.type == "windows") {
[17:44:50.710]                 old_names <- names(...future.oldEnvVars)
[17:44:50.710]                 envs <- base::Sys.getenv()
[17:44:50.710]                 names <- names(envs)
[17:44:50.710]                 common <- intersect(names, old_names)
[17:44:50.710]                 added <- setdiff(names, old_names)
[17:44:50.710]                 removed <- setdiff(old_names, names)
[17:44:50.710]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.710]                   envs[common]]
[17:44:50.710]                 NAMES <- toupper(changed)
[17:44:50.710]                 args <- list()
[17:44:50.710]                 for (kk in seq_along(NAMES)) {
[17:44:50.710]                   name <- changed[[kk]]
[17:44:50.710]                   NAME <- NAMES[[kk]]
[17:44:50.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.710]                     next
[17:44:50.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.710]                 }
[17:44:50.710]                 NAMES <- toupper(added)
[17:44:50.710]                 for (kk in seq_along(NAMES)) {
[17:44:50.710]                   name <- added[[kk]]
[17:44:50.710]                   NAME <- NAMES[[kk]]
[17:44:50.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.710]                     next
[17:44:50.710]                   args[[name]] <- ""
[17:44:50.710]                 }
[17:44:50.710]                 NAMES <- toupper(removed)
[17:44:50.710]                 for (kk in seq_along(NAMES)) {
[17:44:50.710]                   name <- removed[[kk]]
[17:44:50.710]                   NAME <- NAMES[[kk]]
[17:44:50.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.710]                     next
[17:44:50.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.710]                 }
[17:44:50.710]                 if (length(args) > 0) 
[17:44:50.710]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.710]             }
[17:44:50.710]             else {
[17:44:50.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.710]             }
[17:44:50.710]             {
[17:44:50.710]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.710]                   0L) {
[17:44:50.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.710]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.710]                   base::options(opts)
[17:44:50.710]                 }
[17:44:50.710]                 {
[17:44:50.710]                   {
[17:44:50.710]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.710]                     NULL
[17:44:50.710]                   }
[17:44:50.710]                   options(future.plan = NULL)
[17:44:50.710]                   if (is.na(NA_character_)) 
[17:44:50.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.710]                     .init = FALSE)
[17:44:50.710]                 }
[17:44:50.710]             }
[17:44:50.710]         }
[17:44:50.710]     })
[17:44:50.710]     if (TRUE) {
[17:44:50.710]         base::sink(type = "output", split = FALSE)
[17:44:50.710]         if (TRUE) {
[17:44:50.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.710]         }
[17:44:50.710]         else {
[17:44:50.710]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.710]         }
[17:44:50.710]         base::close(...future.stdout)
[17:44:50.710]         ...future.stdout <- NULL
[17:44:50.710]     }
[17:44:50.710]     ...future.result$conditions <- ...future.conditions
[17:44:50.710]     ...future.result$finished <- base::Sys.time()
[17:44:50.710]     ...future.result
[17:44:50.710] }
[17:44:50.712] Poll #1 (0): usedNodes() = 2, workers = 2
[17:44:50.723] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.723] - Validating connection of MultisessionFuture
[17:44:50.723] - received message: FutureResult
[17:44:50.723] - Received FutureResult
[17:44:50.723] - Erased future from FutureRegistry
[17:44:50.723] result() for ClusterFuture ...
[17:44:50.723] - result already collected: FutureResult
[17:44:50.724] result() for ClusterFuture ... done
[17:44:50.724] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.724] result() for ClusterFuture ...
[17:44:50.724] - result already collected: FutureResult
[17:44:50.724] result() for ClusterFuture ... done
[17:44:50.724] result() for ClusterFuture ...
[17:44:50.724] - result already collected: FutureResult
[17:44:50.724] result() for ClusterFuture ... done
[17:44:50.725] Exporting 5 global objects (3.41 KiB) to cluster node #1 ...
[17:44:50.725] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.725] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.725] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.726] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.726] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[17:44:50.726] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[17:44:50.726] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.726] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.727] Exporting 5 global objects (3.41 KiB) to cluster node #1 ... DONE
[17:44:50.727] MultisessionFuture started
[17:44:50.728] - Launch lazy future ... done
[17:44:50.728] run() for ‘MultisessionFuture’ ... done
[17:44:50.728] Created future:
[17:44:50.728] MultisessionFuture:
[17:44:50.728] Label: ‘future_mapply-5’
[17:44:50.728] Expression:
[17:44:50.728] {
[17:44:50.728]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.728]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.728]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.728]         on.exit(options(oopts), add = TRUE)
[17:44:50.728]     }
[17:44:50.728]     {
[17:44:50.728]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.728]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.728]         do.call(mapply, args = args)
[17:44:50.728]     }
[17:44:50.728] }
[17:44:50.728] Lazy evaluation: FALSE
[17:44:50.728] Asynchronous evaluation: TRUE
[17:44:50.728] Local evaluation: TRUE
[17:44:50.728] Environment: R_GlobalEnv
[17:44:50.728] Capture standard output: TRUE
[17:44:50.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.728] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.728] Packages: <none>
[17:44:50.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.728] Resolved: FALSE
[17:44:50.728] Value: <not collected>
[17:44:50.728] Conditions captured: <none>
[17:44:50.728] Early signaling: FALSE
[17:44:50.728] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.728] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.739] Chunk #5 of 5 ... DONE
[17:44:50.739] Launching 5 futures (chunks) ... DONE
[17:44:50.739] Resolving 5 futures (chunks) ...
[17:44:50.740] resolve() on list ...
[17:44:50.740]  recursive: 0
[17:44:50.740]  length: 5
[17:44:50.740] 
[17:44:50.740] Future #1
[17:44:50.740] result() for ClusterFuture ...
[17:44:50.740] - result already collected: FutureResult
[17:44:50.740] result() for ClusterFuture ... done
[17:44:50.740] result() for ClusterFuture ...
[17:44:50.740] - result already collected: FutureResult
[17:44:50.741] result() for ClusterFuture ... done
[17:44:50.741] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.741] - nx: 5
[17:44:50.741] - relay: TRUE
[17:44:50.741] - stdout: TRUE
[17:44:50.741] - signal: TRUE
[17:44:50.741] - resignal: FALSE
[17:44:50.741] - force: TRUE
[17:44:50.741] - relayed: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:50.741] - queued futures: [n=5] FALSE, FALSE, FALSE, FALSE, FALSE
[17:44:50.741]  - until=1
[17:44:50.741]  - relaying element #1
[17:44:50.742] result() for ClusterFuture ...
[17:44:50.742] - result already collected: FutureResult
[17:44:50.742] result() for ClusterFuture ... done
[17:44:50.742] result() for ClusterFuture ...
[17:44:50.742] - result already collected: FutureResult
[17:44:50.742] result() for ClusterFuture ... done
[17:44:50.742] result() for ClusterFuture ...
[17:44:50.742] - result already collected: FutureResult
[17:44:50.742] result() for ClusterFuture ... done
[17:44:50.742] result() for ClusterFuture ...
[17:44:50.742] - result already collected: FutureResult
[17:44:50.742] result() for ClusterFuture ... done
[17:44:50.743] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:50.743] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:50.743] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.743]  length: 4 (resolved future 1)
[17:44:50.743] Future #2
[17:44:50.743] result() for ClusterFuture ...
[17:44:50.743] - result already collected: FutureResult
[17:44:50.743] result() for ClusterFuture ... done
[17:44:50.743] result() for ClusterFuture ...
[17:44:50.743] - result already collected: FutureResult
[17:44:50.743] result() for ClusterFuture ... done
[17:44:50.744] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.744] - nx: 5
[17:44:50.744] - relay: TRUE
[17:44:50.744] - stdout: TRUE
[17:44:50.744] - signal: TRUE
[17:44:50.744] - resignal: FALSE
[17:44:50.744] - force: TRUE
[17:44:50.744] - relayed: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:50.744] - queued futures: [n=5] TRUE, FALSE, FALSE, FALSE, FALSE
[17:44:50.744]  - until=2
[17:44:50.744]  - relaying element #2
[17:44:50.744] result() for ClusterFuture ...
[17:44:50.745] - result already collected: FutureResult
[17:44:50.745] result() for ClusterFuture ... done
[17:44:50.745] result() for ClusterFuture ...
[17:44:50.745] - result already collected: FutureResult
[17:44:50.745] result() for ClusterFuture ... done
[17:44:50.745] result() for ClusterFuture ...
[17:44:50.745] - result already collected: FutureResult
[17:44:50.745] result() for ClusterFuture ... done
[17:44:50.745] result() for ClusterFuture ...
[17:44:50.745] - result already collected: FutureResult
[17:44:50.745] result() for ClusterFuture ... done
[17:44:50.745] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:50.746] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:50.746] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.746]  length: 3 (resolved future 2)
[17:44:50.746] Future #3
[17:44:50.746] result() for ClusterFuture ...
[17:44:50.746] - result already collected: FutureResult
[17:44:50.746] result() for ClusterFuture ... done
[17:44:50.746] result() for ClusterFuture ...
[17:44:50.746] - result already collected: FutureResult
[17:44:50.746] result() for ClusterFuture ... done
[17:44:50.746] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:44:50.747] - nx: 5
[17:44:50.747] - relay: TRUE
[17:44:50.747] - stdout: TRUE
[17:44:50.747] - signal: TRUE
[17:44:50.747] - resignal: FALSE
[17:44:50.747] - force: TRUE
[17:44:50.747] - relayed: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:50.747] - queued futures: [n=5] TRUE, TRUE, FALSE, FALSE, FALSE
[17:44:50.747]  - until=3
[17:44:50.747]  - relaying element #3
[17:44:50.747] result() for ClusterFuture ...
[17:44:50.747] - result already collected: FutureResult
[17:44:50.748] result() for ClusterFuture ... done
[17:44:50.748] result() for ClusterFuture ...
[17:44:50.748] - result already collected: FutureResult
[17:44:50.748] result() for ClusterFuture ... done
[17:44:50.748] result() for ClusterFuture ...
[17:44:50.748] - result already collected: FutureResult
[17:44:50.748] result() for ClusterFuture ... done
[17:44:50.748] result() for ClusterFuture ...
[17:44:50.748] - result already collected: FutureResult
[17:44:50.748] result() for ClusterFuture ... done
[17:44:50.748] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:50.748] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:50.749] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:44:50.749]  length: 2 (resolved future 3)
[17:44:50.749] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.749] - Validating connection of MultisessionFuture
[17:44:50.749] - received message: FutureResult
[17:44:50.749] - Received FutureResult
[17:44:50.750] - Erased future from FutureRegistry
[17:44:50.750] result() for ClusterFuture ...
[17:44:50.750] - result already collected: FutureResult
[17:44:50.750] result() for ClusterFuture ... done
[17:44:50.750] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.750] Future #4
[17:44:50.750] result() for ClusterFuture ...
[17:44:50.750] - result already collected: FutureResult
[17:44:50.750] result() for ClusterFuture ... done
[17:44:50.750] result() for ClusterFuture ...
[17:44:50.750] - result already collected: FutureResult
[17:44:50.751] result() for ClusterFuture ... done
[17:44:50.751] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:44:50.751] - nx: 5
[17:44:50.751] - relay: TRUE
[17:44:50.751] - stdout: TRUE
[17:44:50.751] - signal: TRUE
[17:44:50.751] - resignal: FALSE
[17:44:50.751] - force: TRUE
[17:44:50.751] - relayed: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:50.751] - queued futures: [n=5] TRUE, TRUE, TRUE, FALSE, FALSE
[17:44:50.751]  - until=4
[17:44:50.751]  - relaying element #4
[17:44:50.752] result() for ClusterFuture ...
[17:44:50.752] - result already collected: FutureResult
[17:44:50.752] result() for ClusterFuture ... done
[17:44:50.752] result() for ClusterFuture ...
[17:44:50.752] - result already collected: FutureResult
[17:44:50.752] result() for ClusterFuture ... done
[17:44:50.752] result() for ClusterFuture ...
[17:44:50.752] - result already collected: FutureResult
[17:44:50.752] result() for ClusterFuture ... done
[17:44:50.752] result() for ClusterFuture ...
[17:44:50.752] - result already collected: FutureResult
[17:44:50.752] result() for ClusterFuture ... done
[17:44:50.753] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:50.753] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:50.753] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:44:50.753]  length: 1 (resolved future 4)
[17:44:50.774] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.774] - Validating connection of MultisessionFuture
[17:44:50.774] - received message: FutureResult
[17:44:50.774] - Received FutureResult
[17:44:50.774] - Erased future from FutureRegistry
[17:44:50.774] result() for ClusterFuture ...
[17:44:50.775] - result already collected: FutureResult
[17:44:50.775] result() for ClusterFuture ... done
[17:44:50.775] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.775] Future #5
[17:44:50.775] result() for ClusterFuture ...
[17:44:50.775] - result already collected: FutureResult
[17:44:50.775] result() for ClusterFuture ... done
[17:44:50.775] result() for ClusterFuture ...
[17:44:50.775] - result already collected: FutureResult
[17:44:50.775] result() for ClusterFuture ... done
[17:44:50.775] signalConditionsASAP(MultisessionFuture, pos=5) ...
[17:44:50.776] - nx: 5
[17:44:50.776] - relay: TRUE
[17:44:50.776] - stdout: TRUE
[17:44:50.776] - signal: TRUE
[17:44:50.776] - resignal: FALSE
[17:44:50.776] - force: TRUE
[17:44:50.776] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:50.776] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, FALSE
[17:44:50.776]  - until=5
[17:44:50.776]  - relaying element #5
[17:44:50.776] result() for ClusterFuture ...
[17:44:50.776] - result already collected: FutureResult
[17:44:50.777] result() for ClusterFuture ... done
[17:44:50.777] result() for ClusterFuture ...
[17:44:50.777] - result already collected: FutureResult
[17:44:50.777] result() for ClusterFuture ... done
[17:44:50.777] result() for ClusterFuture ...
[17:44:50.777] - result already collected: FutureResult
[17:44:50.777] result() for ClusterFuture ... done
[17:44:50.777] result() for ClusterFuture ...
[17:44:50.777] - result already collected: FutureResult
[17:44:50.777] result() for ClusterFuture ... done
[17:44:50.777] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:50.777] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:50.778] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[17:44:50.778]  length: 0 (resolved future 5)
[17:44:50.778] Relaying remaining futures
[17:44:50.778] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.778] - nx: 5
[17:44:50.778] - relay: TRUE
[17:44:50.778] - stdout: TRUE
[17:44:50.778] - signal: TRUE
[17:44:50.778] - resignal: FALSE
[17:44:50.778] - force: TRUE
[17:44:50.778] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:50.778] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[17:44:50.779] - relayed: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:50.779] - queued futures: [n=5] TRUE, TRUE, TRUE, TRUE, TRUE
[17:44:50.779] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.779] resolve() on list ... DONE
[17:44:50.779] result() for ClusterFuture ...
[17:44:50.779] - result already collected: FutureResult
[17:44:50.779] result() for ClusterFuture ... done
[17:44:50.779] result() for ClusterFuture ...
[17:44:50.779] - result already collected: FutureResult
[17:44:50.779] result() for ClusterFuture ... done
[17:44:50.780] result() for ClusterFuture ...
[17:44:50.780] - result already collected: FutureResult
[17:44:50.780] result() for ClusterFuture ... done
[17:44:50.780] result() for ClusterFuture ...
[17:44:50.780] - result already collected: FutureResult
[17:44:50.780] result() for ClusterFuture ... done
[17:44:50.780] result() for ClusterFuture ...
[17:44:50.780] - result already collected: FutureResult
[17:44:50.780] result() for ClusterFuture ... done
[17:44:50.780] result() for ClusterFuture ...
[17:44:50.780] - result already collected: FutureResult
[17:44:50.780] result() for ClusterFuture ... done
[17:44:50.781] result() for ClusterFuture ...
[17:44:50.781] - result already collected: FutureResult
[17:44:50.781] result() for ClusterFuture ... done
[17:44:50.781] result() for ClusterFuture ...
[17:44:50.781] - result already collected: FutureResult
[17:44:50.781] result() for ClusterFuture ... done
[17:44:50.781] result() for ClusterFuture ...
[17:44:50.781] - result already collected: FutureResult
[17:44:50.781] result() for ClusterFuture ... done
[17:44:50.781] result() for ClusterFuture ...
[17:44:50.781] - result already collected: FutureResult
[17:44:50.781] result() for ClusterFuture ... done
[17:44:50.782]  - Number of value chunks collected: 5
[17:44:50.782] Resolving 5 futures (chunks) ... DONE
[17:44:50.782] Reducing values from 5 chunks ...
[17:44:50.782]  - Number of values collected after concatenation: 5
[17:44:50.782]  - Number of values expected: 5
[17:44:50.782] Reducing values from 5 chunks ... DONE
[17:44:50.782] future_mapply() ... DONE
[17:44:50.782] future_mapply() ...
[17:44:50.786] Number of chunks: 2
[17:44:50.786] getGlobalsAndPackagesXApply() ...
[17:44:50.786]  - future.globals: TRUE
[17:44:50.786] getGlobalsAndPackages() ...
[17:44:50.786] Searching for globals...
[17:44:50.788] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:50.788] Searching for globals ... DONE
[17:44:50.788] Resolving globals: FALSE
[17:44:50.788] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:50.789] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:50.789] - globals: [1] ‘FUN’
[17:44:50.789] 
[17:44:50.789] getGlobalsAndPackages() ... DONE
[17:44:50.789]  - globals found/used: [n=1] ‘FUN’
[17:44:50.789]  - needed namespaces: [n=0] 
[17:44:50.789] Finding globals ... DONE
[17:44:50.789] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.790] List of 2
[17:44:50.790]  $ ...future.FUN:function (C, k)  
[17:44:50.790]  $ MoreArgs     : list()
[17:44:50.790]  - attr(*, "where")=List of 2
[17:44:50.790]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.790]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.790]  - attr(*, "resolved")= logi FALSE
[17:44:50.790]  - attr(*, "total_size")= num NA
[17:44:50.792] Packages to be attached in all futures: [n=0] 
[17:44:50.792] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.792] Number of futures (= number of chunks): 2
[17:44:50.792] Launching 2 futures (chunks) ...
[17:44:50.792] Chunk #1 of 2 ...
[17:44:50.793]  - Finding globals in '...' for chunk #1 ...
[17:44:50.793] getGlobalsAndPackages() ...
[17:44:50.793] Searching for globals...
[17:44:50.793] 
[17:44:50.793] Searching for globals ... DONE
[17:44:50.793] - globals: [0] <none>
[17:44:50.793] getGlobalsAndPackages() ... DONE
[17:44:50.793]    + additional globals found: [n=0] 
[17:44:50.794]    + additional namespaces needed: [n=0] 
[17:44:50.794]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.794]  - seeds: <none>
[17:44:50.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.794] getGlobalsAndPackages() ...
[17:44:50.794] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.794] Resolving globals: FALSE
[17:44:50.795] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:50.795] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:50.795] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.795] 
[17:44:50.795] getGlobalsAndPackages() ... DONE
[17:44:50.796] run() for ‘Future’ ...
[17:44:50.796] - state: ‘created’
[17:44:50.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.810]   - Field: ‘node’
[17:44:50.810]   - Field: ‘label’
[17:44:50.810]   - Field: ‘local’
[17:44:50.811]   - Field: ‘owner’
[17:44:50.811]   - Field: ‘envir’
[17:44:50.811]   - Field: ‘workers’
[17:44:50.811]   - Field: ‘packages’
[17:44:50.811]   - Field: ‘gc’
[17:44:50.811]   - Field: ‘conditions’
[17:44:50.811]   - Field: ‘persistent’
[17:44:50.811]   - Field: ‘expr’
[17:44:50.811]   - Field: ‘uuid’
[17:44:50.811]   - Field: ‘seed’
[17:44:50.811]   - Field: ‘version’
[17:44:50.812]   - Field: ‘result’
[17:44:50.812]   - Field: ‘asynchronous’
[17:44:50.812]   - Field: ‘calls’
[17:44:50.812]   - Field: ‘globals’
[17:44:50.812]   - Field: ‘stdout’
[17:44:50.812]   - Field: ‘earlySignal’
[17:44:50.812]   - Field: ‘lazy’
[17:44:50.812]   - Field: ‘state’
[17:44:50.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.812] - Launch lazy future ...
[17:44:50.813] Packages needed by the future expression (n = 0): <none>
[17:44:50.813] Packages needed by future strategies (n = 0): <none>
[17:44:50.813] {
[17:44:50.813]     {
[17:44:50.813]         {
[17:44:50.813]             ...future.startTime <- base::Sys.time()
[17:44:50.813]             {
[17:44:50.813]                 {
[17:44:50.813]                   {
[17:44:50.813]                     {
[17:44:50.813]                       base::local({
[17:44:50.813]                         has_future <- base::requireNamespace("future", 
[17:44:50.813]                           quietly = TRUE)
[17:44:50.813]                         if (has_future) {
[17:44:50.813]                           ns <- base::getNamespace("future")
[17:44:50.813]                           version <- ns[[".package"]][["version"]]
[17:44:50.813]                           if (is.null(version)) 
[17:44:50.813]                             version <- utils::packageVersion("future")
[17:44:50.813]                         }
[17:44:50.813]                         else {
[17:44:50.813]                           version <- NULL
[17:44:50.813]                         }
[17:44:50.813]                         if (!has_future || version < "1.8.0") {
[17:44:50.813]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.813]                             "", base::R.version$version.string), 
[17:44:50.813]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.813]                               "release", "version")], collapse = " "), 
[17:44:50.813]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.813]                             info)
[17:44:50.813]                           info <- base::paste(info, collapse = "; ")
[17:44:50.813]                           if (!has_future) {
[17:44:50.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.813]                               info)
[17:44:50.813]                           }
[17:44:50.813]                           else {
[17:44:50.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.813]                               info, version)
[17:44:50.813]                           }
[17:44:50.813]                           base::stop(msg)
[17:44:50.813]                         }
[17:44:50.813]                       })
[17:44:50.813]                     }
[17:44:50.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.813]                     base::options(mc.cores = 1L)
[17:44:50.813]                   }
[17:44:50.813]                   ...future.strategy.old <- future::plan("list")
[17:44:50.813]                   options(future.plan = NULL)
[17:44:50.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.813]                 }
[17:44:50.813]                 ...future.workdir <- getwd()
[17:44:50.813]             }
[17:44:50.813]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.813]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.813]         }
[17:44:50.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.813]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.813]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.813]             base::names(...future.oldOptions))
[17:44:50.813]     }
[17:44:50.813]     if (FALSE) {
[17:44:50.813]     }
[17:44:50.813]     else {
[17:44:50.813]         if (TRUE) {
[17:44:50.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.813]                 open = "w")
[17:44:50.813]         }
[17:44:50.813]         else {
[17:44:50.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.813]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.813]         }
[17:44:50.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.813]             base::sink(type = "output", split = FALSE)
[17:44:50.813]             base::close(...future.stdout)
[17:44:50.813]         }, add = TRUE)
[17:44:50.813]     }
[17:44:50.813]     ...future.frame <- base::sys.nframe()
[17:44:50.813]     ...future.conditions <- base::list()
[17:44:50.813]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.813]     if (FALSE) {
[17:44:50.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.813]     }
[17:44:50.813]     ...future.result <- base::tryCatch({
[17:44:50.813]         base::withCallingHandlers({
[17:44:50.813]             ...future.value <- base::withVisible(base::local({
[17:44:50.813]                 ...future.makeSendCondition <- base::local({
[17:44:50.813]                   sendCondition <- NULL
[17:44:50.813]                   function(frame = 1L) {
[17:44:50.813]                     if (is.function(sendCondition)) 
[17:44:50.813]                       return(sendCondition)
[17:44:50.813]                     ns <- getNamespace("parallel")
[17:44:50.813]                     if (exists("sendData", mode = "function", 
[17:44:50.813]                       envir = ns)) {
[17:44:50.813]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.813]                         envir = ns)
[17:44:50.813]                       envir <- sys.frame(frame)
[17:44:50.813]                       master <- NULL
[17:44:50.813]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.813]                         !identical(envir, emptyenv())) {
[17:44:50.813]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.813]                           inherits = FALSE)) {
[17:44:50.813]                           master <- get("master", mode = "list", 
[17:44:50.813]                             envir = envir, inherits = FALSE)
[17:44:50.813]                           if (inherits(master, c("SOCKnode", 
[17:44:50.813]                             "SOCK0node"))) {
[17:44:50.813]                             sendCondition <<- function(cond) {
[17:44:50.813]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.813]                                 success = TRUE)
[17:44:50.813]                               parallel_sendData(master, data)
[17:44:50.813]                             }
[17:44:50.813]                             return(sendCondition)
[17:44:50.813]                           }
[17:44:50.813]                         }
[17:44:50.813]                         frame <- frame + 1L
[17:44:50.813]                         envir <- sys.frame(frame)
[17:44:50.813]                       }
[17:44:50.813]                     }
[17:44:50.813]                     sendCondition <<- function(cond) NULL
[17:44:50.813]                   }
[17:44:50.813]                 })
[17:44:50.813]                 withCallingHandlers({
[17:44:50.813]                   {
[17:44:50.813]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.813]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.813]                       ...future.globals.maxSize)) {
[17:44:50.813]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.813]                       on.exit(options(oopts), add = TRUE)
[17:44:50.813]                     }
[17:44:50.813]                     {
[17:44:50.813]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.813]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.813]                         USE.NAMES = FALSE)
[17:44:50.813]                       do.call(mapply, args = args)
[17:44:50.813]                     }
[17:44:50.813]                   }
[17:44:50.813]                 }, immediateCondition = function(cond) {
[17:44:50.813]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.813]                   sendCondition(cond)
[17:44:50.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.813]                   {
[17:44:50.813]                     inherits <- base::inherits
[17:44:50.813]                     invokeRestart <- base::invokeRestart
[17:44:50.813]                     is.null <- base::is.null
[17:44:50.813]                     muffled <- FALSE
[17:44:50.813]                     if (inherits(cond, "message")) {
[17:44:50.813]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.813]                       if (muffled) 
[17:44:50.813]                         invokeRestart("muffleMessage")
[17:44:50.813]                     }
[17:44:50.813]                     else if (inherits(cond, "warning")) {
[17:44:50.813]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.813]                       if (muffled) 
[17:44:50.813]                         invokeRestart("muffleWarning")
[17:44:50.813]                     }
[17:44:50.813]                     else if (inherits(cond, "condition")) {
[17:44:50.813]                       if (!is.null(pattern)) {
[17:44:50.813]                         computeRestarts <- base::computeRestarts
[17:44:50.813]                         grepl <- base::grepl
[17:44:50.813]                         restarts <- computeRestarts(cond)
[17:44:50.813]                         for (restart in restarts) {
[17:44:50.813]                           name <- restart$name
[17:44:50.813]                           if (is.null(name)) 
[17:44:50.813]                             next
[17:44:50.813]                           if (!grepl(pattern, name)) 
[17:44:50.813]                             next
[17:44:50.813]                           invokeRestart(restart)
[17:44:50.813]                           muffled <- TRUE
[17:44:50.813]                           break
[17:44:50.813]                         }
[17:44:50.813]                       }
[17:44:50.813]                     }
[17:44:50.813]                     invisible(muffled)
[17:44:50.813]                   }
[17:44:50.813]                   muffleCondition(cond)
[17:44:50.813]                 })
[17:44:50.813]             }))
[17:44:50.813]             future::FutureResult(value = ...future.value$value, 
[17:44:50.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.813]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.813]                     ...future.globalenv.names))
[17:44:50.813]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.813]         }, condition = base::local({
[17:44:50.813]             c <- base::c
[17:44:50.813]             inherits <- base::inherits
[17:44:50.813]             invokeRestart <- base::invokeRestart
[17:44:50.813]             length <- base::length
[17:44:50.813]             list <- base::list
[17:44:50.813]             seq.int <- base::seq.int
[17:44:50.813]             signalCondition <- base::signalCondition
[17:44:50.813]             sys.calls <- base::sys.calls
[17:44:50.813]             `[[` <- base::`[[`
[17:44:50.813]             `+` <- base::`+`
[17:44:50.813]             `<<-` <- base::`<<-`
[17:44:50.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.813]                   3L)]
[17:44:50.813]             }
[17:44:50.813]             function(cond) {
[17:44:50.813]                 is_error <- inherits(cond, "error")
[17:44:50.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.813]                   NULL)
[17:44:50.813]                 if (is_error) {
[17:44:50.813]                   sessionInformation <- function() {
[17:44:50.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.813]                       search = base::search(), system = base::Sys.info())
[17:44:50.813]                   }
[17:44:50.813]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.813]                     cond$call), session = sessionInformation(), 
[17:44:50.813]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.813]                   signalCondition(cond)
[17:44:50.813]                 }
[17:44:50.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.813]                 "immediateCondition"))) {
[17:44:50.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.813]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.813]                   if (TRUE && !signal) {
[17:44:50.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.813]                     {
[17:44:50.813]                       inherits <- base::inherits
[17:44:50.813]                       invokeRestart <- base::invokeRestart
[17:44:50.813]                       is.null <- base::is.null
[17:44:50.813]                       muffled <- FALSE
[17:44:50.813]                       if (inherits(cond, "message")) {
[17:44:50.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.813]                         if (muffled) 
[17:44:50.813]                           invokeRestart("muffleMessage")
[17:44:50.813]                       }
[17:44:50.813]                       else if (inherits(cond, "warning")) {
[17:44:50.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.813]                         if (muffled) 
[17:44:50.813]                           invokeRestart("muffleWarning")
[17:44:50.813]                       }
[17:44:50.813]                       else if (inherits(cond, "condition")) {
[17:44:50.813]                         if (!is.null(pattern)) {
[17:44:50.813]                           computeRestarts <- base::computeRestarts
[17:44:50.813]                           grepl <- base::grepl
[17:44:50.813]                           restarts <- computeRestarts(cond)
[17:44:50.813]                           for (restart in restarts) {
[17:44:50.813]                             name <- restart$name
[17:44:50.813]                             if (is.null(name)) 
[17:44:50.813]                               next
[17:44:50.813]                             if (!grepl(pattern, name)) 
[17:44:50.813]                               next
[17:44:50.813]                             invokeRestart(restart)
[17:44:50.813]                             muffled <- TRUE
[17:44:50.813]                             break
[17:44:50.813]                           }
[17:44:50.813]                         }
[17:44:50.813]                       }
[17:44:50.813]                       invisible(muffled)
[17:44:50.813]                     }
[17:44:50.813]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.813]                   }
[17:44:50.813]                 }
[17:44:50.813]                 else {
[17:44:50.813]                   if (TRUE) {
[17:44:50.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.813]                     {
[17:44:50.813]                       inherits <- base::inherits
[17:44:50.813]                       invokeRestart <- base::invokeRestart
[17:44:50.813]                       is.null <- base::is.null
[17:44:50.813]                       muffled <- FALSE
[17:44:50.813]                       if (inherits(cond, "message")) {
[17:44:50.813]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.813]                         if (muffled) 
[17:44:50.813]                           invokeRestart("muffleMessage")
[17:44:50.813]                       }
[17:44:50.813]                       else if (inherits(cond, "warning")) {
[17:44:50.813]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.813]                         if (muffled) 
[17:44:50.813]                           invokeRestart("muffleWarning")
[17:44:50.813]                       }
[17:44:50.813]                       else if (inherits(cond, "condition")) {
[17:44:50.813]                         if (!is.null(pattern)) {
[17:44:50.813]                           computeRestarts <- base::computeRestarts
[17:44:50.813]                           grepl <- base::grepl
[17:44:50.813]                           restarts <- computeRestarts(cond)
[17:44:50.813]                           for (restart in restarts) {
[17:44:50.813]                             name <- restart$name
[17:44:50.813]                             if (is.null(name)) 
[17:44:50.813]                               next
[17:44:50.813]                             if (!grepl(pattern, name)) 
[17:44:50.813]                               next
[17:44:50.813]                             invokeRestart(restart)
[17:44:50.813]                             muffled <- TRUE
[17:44:50.813]                             break
[17:44:50.813]                           }
[17:44:50.813]                         }
[17:44:50.813]                       }
[17:44:50.813]                       invisible(muffled)
[17:44:50.813]                     }
[17:44:50.813]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.813]                   }
[17:44:50.813]                 }
[17:44:50.813]             }
[17:44:50.813]         }))
[17:44:50.813]     }, error = function(ex) {
[17:44:50.813]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.813]                 ...future.rng), started = ...future.startTime, 
[17:44:50.813]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.813]             version = "1.8"), class = "FutureResult")
[17:44:50.813]     }, finally = {
[17:44:50.813]         if (!identical(...future.workdir, getwd())) 
[17:44:50.813]             setwd(...future.workdir)
[17:44:50.813]         {
[17:44:50.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.813]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.813]             }
[17:44:50.813]             base::options(...future.oldOptions)
[17:44:50.813]             if (.Platform$OS.type == "windows") {
[17:44:50.813]                 old_names <- names(...future.oldEnvVars)
[17:44:50.813]                 envs <- base::Sys.getenv()
[17:44:50.813]                 names <- names(envs)
[17:44:50.813]                 common <- intersect(names, old_names)
[17:44:50.813]                 added <- setdiff(names, old_names)
[17:44:50.813]                 removed <- setdiff(old_names, names)
[17:44:50.813]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.813]                   envs[common]]
[17:44:50.813]                 NAMES <- toupper(changed)
[17:44:50.813]                 args <- list()
[17:44:50.813]                 for (kk in seq_along(NAMES)) {
[17:44:50.813]                   name <- changed[[kk]]
[17:44:50.813]                   NAME <- NAMES[[kk]]
[17:44:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.813]                     next
[17:44:50.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.813]                 }
[17:44:50.813]                 NAMES <- toupper(added)
[17:44:50.813]                 for (kk in seq_along(NAMES)) {
[17:44:50.813]                   name <- added[[kk]]
[17:44:50.813]                   NAME <- NAMES[[kk]]
[17:44:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.813]                     next
[17:44:50.813]                   args[[name]] <- ""
[17:44:50.813]                 }
[17:44:50.813]                 NAMES <- toupper(removed)
[17:44:50.813]                 for (kk in seq_along(NAMES)) {
[17:44:50.813]                   name <- removed[[kk]]
[17:44:50.813]                   NAME <- NAMES[[kk]]
[17:44:50.813]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.813]                     next
[17:44:50.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.813]                 }
[17:44:50.813]                 if (length(args) > 0) 
[17:44:50.813]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.813]             }
[17:44:50.813]             else {
[17:44:50.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.813]             }
[17:44:50.813]             {
[17:44:50.813]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.813]                   0L) {
[17:44:50.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.813]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.813]                   base::options(opts)
[17:44:50.813]                 }
[17:44:50.813]                 {
[17:44:50.813]                   {
[17:44:50.813]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.813]                     NULL
[17:44:50.813]                   }
[17:44:50.813]                   options(future.plan = NULL)
[17:44:50.813]                   if (is.na(NA_character_)) 
[17:44:50.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.813]                     .init = FALSE)
[17:44:50.813]                 }
[17:44:50.813]             }
[17:44:50.813]         }
[17:44:50.813]     })
[17:44:50.813]     if (TRUE) {
[17:44:50.813]         base::sink(type = "output", split = FALSE)
[17:44:50.813]         if (TRUE) {
[17:44:50.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.813]         }
[17:44:50.813]         else {
[17:44:50.813]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.813]         }
[17:44:50.813]         base::close(...future.stdout)
[17:44:50.813]         ...future.stdout <- NULL
[17:44:50.813]     }
[17:44:50.813]     ...future.result$conditions <- ...future.conditions
[17:44:50.813]     ...future.result$finished <- base::Sys.time()
[17:44:50.813]     ...future.result
[17:44:50.813] }
[17:44:50.816] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:50.816] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.816] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.816] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.817] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.817] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:50.817] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:50.817] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.818] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.818] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.818] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.818] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:50.819] MultisessionFuture started
[17:44:50.819] - Launch lazy future ... done
[17:44:50.819] run() for ‘MultisessionFuture’ ... done
[17:44:50.819] Created future:
[17:44:50.819] MultisessionFuture:
[17:44:50.819] Label: ‘future_.mapply-1’
[17:44:50.819] Expression:
[17:44:50.819] {
[17:44:50.819]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.819]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.819]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.819]         on.exit(options(oopts), add = TRUE)
[17:44:50.819]     }
[17:44:50.819]     {
[17:44:50.819]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.819]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.819]         do.call(mapply, args = args)
[17:44:50.819]     }
[17:44:50.819] }
[17:44:50.819] Lazy evaluation: FALSE
[17:44:50.819] Asynchronous evaluation: TRUE
[17:44:50.819] Local evaluation: TRUE
[17:44:50.819] Environment: R_GlobalEnv
[17:44:50.819] Capture standard output: TRUE
[17:44:50.819] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.819] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.819] Packages: <none>
[17:44:50.819] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.819] Resolved: FALSE
[17:44:50.819] Value: <not collected>
[17:44:50.819] Conditions captured: <none>
[17:44:50.819] Early signaling: FALSE
[17:44:50.819] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.819] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.830] Chunk #1 of 2 ... DONE
[17:44:50.831] Chunk #2 of 2 ...
[17:44:50.831]  - Finding globals in '...' for chunk #2 ...
[17:44:50.831] getGlobalsAndPackages() ...
[17:44:50.831] Searching for globals...
[17:44:50.831] 
[17:44:50.831] Searching for globals ... DONE
[17:44:50.832] - globals: [0] <none>
[17:44:50.832] getGlobalsAndPackages() ... DONE
[17:44:50.832]    + additional globals found: [n=0] 
[17:44:50.832]    + additional namespaces needed: [n=0] 
[17:44:50.832]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.832]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:50.832]  - seeds: <none>
[17:44:50.832]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.832] getGlobalsAndPackages() ...
[17:44:50.832] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.833] Resolving globals: FALSE
[17:44:50.833] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:50.833] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:50.834] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.834] 
[17:44:50.834] getGlobalsAndPackages() ... DONE
[17:44:50.834] run() for ‘Future’ ...
[17:44:50.834] - state: ‘created’
[17:44:50.834] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.849] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.852]   - Field: ‘node’
[17:44:50.852]   - Field: ‘label’
[17:44:50.852]   - Field: ‘local’
[17:44:50.852]   - Field: ‘owner’
[17:44:50.852]   - Field: ‘envir’
[17:44:50.852]   - Field: ‘workers’
[17:44:50.852]   - Field: ‘packages’
[17:44:50.852]   - Field: ‘gc’
[17:44:50.852]   - Field: ‘conditions’
[17:44:50.852]   - Field: ‘persistent’
[17:44:50.853]   - Field: ‘expr’
[17:44:50.853]   - Field: ‘uuid’
[17:44:50.853]   - Field: ‘seed’
[17:44:50.853]   - Field: ‘version’
[17:44:50.853]   - Field: ‘result’
[17:44:50.853]   - Field: ‘asynchronous’
[17:44:50.853]   - Field: ‘calls’
[17:44:50.853]   - Field: ‘globals’
[17:44:50.853]   - Field: ‘stdout’
[17:44:50.853]   - Field: ‘earlySignal’
[17:44:50.853]   - Field: ‘lazy’
[17:44:50.853]   - Field: ‘state’
[17:44:50.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.854] - Launch lazy future ...
[17:44:50.854] Packages needed by the future expression (n = 0): <none>
[17:44:50.854] Packages needed by future strategies (n = 0): <none>
[17:44:50.854] {
[17:44:50.854]     {
[17:44:50.854]         {
[17:44:50.854]             ...future.startTime <- base::Sys.time()
[17:44:50.854]             {
[17:44:50.854]                 {
[17:44:50.854]                   {
[17:44:50.854]                     {
[17:44:50.854]                       base::local({
[17:44:50.854]                         has_future <- base::requireNamespace("future", 
[17:44:50.854]                           quietly = TRUE)
[17:44:50.854]                         if (has_future) {
[17:44:50.854]                           ns <- base::getNamespace("future")
[17:44:50.854]                           version <- ns[[".package"]][["version"]]
[17:44:50.854]                           if (is.null(version)) 
[17:44:50.854]                             version <- utils::packageVersion("future")
[17:44:50.854]                         }
[17:44:50.854]                         else {
[17:44:50.854]                           version <- NULL
[17:44:50.854]                         }
[17:44:50.854]                         if (!has_future || version < "1.8.0") {
[17:44:50.854]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.854]                             "", base::R.version$version.string), 
[17:44:50.854]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.854]                               "release", "version")], collapse = " "), 
[17:44:50.854]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.854]                             info)
[17:44:50.854]                           info <- base::paste(info, collapse = "; ")
[17:44:50.854]                           if (!has_future) {
[17:44:50.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.854]                               info)
[17:44:50.854]                           }
[17:44:50.854]                           else {
[17:44:50.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.854]                               info, version)
[17:44:50.854]                           }
[17:44:50.854]                           base::stop(msg)
[17:44:50.854]                         }
[17:44:50.854]                       })
[17:44:50.854]                     }
[17:44:50.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.854]                     base::options(mc.cores = 1L)
[17:44:50.854]                   }
[17:44:50.854]                   ...future.strategy.old <- future::plan("list")
[17:44:50.854]                   options(future.plan = NULL)
[17:44:50.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.854]                 }
[17:44:50.854]                 ...future.workdir <- getwd()
[17:44:50.854]             }
[17:44:50.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.854]         }
[17:44:50.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.854]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:50.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.854]             base::names(...future.oldOptions))
[17:44:50.854]     }
[17:44:50.854]     if (FALSE) {
[17:44:50.854]     }
[17:44:50.854]     else {
[17:44:50.854]         if (TRUE) {
[17:44:50.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.854]                 open = "w")
[17:44:50.854]         }
[17:44:50.854]         else {
[17:44:50.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.854]         }
[17:44:50.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.854]             base::sink(type = "output", split = FALSE)
[17:44:50.854]             base::close(...future.stdout)
[17:44:50.854]         }, add = TRUE)
[17:44:50.854]     }
[17:44:50.854]     ...future.frame <- base::sys.nframe()
[17:44:50.854]     ...future.conditions <- base::list()
[17:44:50.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.854]     if (FALSE) {
[17:44:50.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.854]     }
[17:44:50.854]     ...future.result <- base::tryCatch({
[17:44:50.854]         base::withCallingHandlers({
[17:44:50.854]             ...future.value <- base::withVisible(base::local({
[17:44:50.854]                 ...future.makeSendCondition <- base::local({
[17:44:50.854]                   sendCondition <- NULL
[17:44:50.854]                   function(frame = 1L) {
[17:44:50.854]                     if (is.function(sendCondition)) 
[17:44:50.854]                       return(sendCondition)
[17:44:50.854]                     ns <- getNamespace("parallel")
[17:44:50.854]                     if (exists("sendData", mode = "function", 
[17:44:50.854]                       envir = ns)) {
[17:44:50.854]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.854]                         envir = ns)
[17:44:50.854]                       envir <- sys.frame(frame)
[17:44:50.854]                       master <- NULL
[17:44:50.854]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.854]                         !identical(envir, emptyenv())) {
[17:44:50.854]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.854]                           inherits = FALSE)) {
[17:44:50.854]                           master <- get("master", mode = "list", 
[17:44:50.854]                             envir = envir, inherits = FALSE)
[17:44:50.854]                           if (inherits(master, c("SOCKnode", 
[17:44:50.854]                             "SOCK0node"))) {
[17:44:50.854]                             sendCondition <<- function(cond) {
[17:44:50.854]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.854]                                 success = TRUE)
[17:44:50.854]                               parallel_sendData(master, data)
[17:44:50.854]                             }
[17:44:50.854]                             return(sendCondition)
[17:44:50.854]                           }
[17:44:50.854]                         }
[17:44:50.854]                         frame <- frame + 1L
[17:44:50.854]                         envir <- sys.frame(frame)
[17:44:50.854]                       }
[17:44:50.854]                     }
[17:44:50.854]                     sendCondition <<- function(cond) NULL
[17:44:50.854]                   }
[17:44:50.854]                 })
[17:44:50.854]                 withCallingHandlers({
[17:44:50.854]                   {
[17:44:50.854]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.854]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.854]                       ...future.globals.maxSize)) {
[17:44:50.854]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.854]                       on.exit(options(oopts), add = TRUE)
[17:44:50.854]                     }
[17:44:50.854]                     {
[17:44:50.854]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.854]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.854]                         USE.NAMES = FALSE)
[17:44:50.854]                       do.call(mapply, args = args)
[17:44:50.854]                     }
[17:44:50.854]                   }
[17:44:50.854]                 }, immediateCondition = function(cond) {
[17:44:50.854]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.854]                   sendCondition(cond)
[17:44:50.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.854]                   {
[17:44:50.854]                     inherits <- base::inherits
[17:44:50.854]                     invokeRestart <- base::invokeRestart
[17:44:50.854]                     is.null <- base::is.null
[17:44:50.854]                     muffled <- FALSE
[17:44:50.854]                     if (inherits(cond, "message")) {
[17:44:50.854]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.854]                       if (muffled) 
[17:44:50.854]                         invokeRestart("muffleMessage")
[17:44:50.854]                     }
[17:44:50.854]                     else if (inherits(cond, "warning")) {
[17:44:50.854]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.854]                       if (muffled) 
[17:44:50.854]                         invokeRestart("muffleWarning")
[17:44:50.854]                     }
[17:44:50.854]                     else if (inherits(cond, "condition")) {
[17:44:50.854]                       if (!is.null(pattern)) {
[17:44:50.854]                         computeRestarts <- base::computeRestarts
[17:44:50.854]                         grepl <- base::grepl
[17:44:50.854]                         restarts <- computeRestarts(cond)
[17:44:50.854]                         for (restart in restarts) {
[17:44:50.854]                           name <- restart$name
[17:44:50.854]                           if (is.null(name)) 
[17:44:50.854]                             next
[17:44:50.854]                           if (!grepl(pattern, name)) 
[17:44:50.854]                             next
[17:44:50.854]                           invokeRestart(restart)
[17:44:50.854]                           muffled <- TRUE
[17:44:50.854]                           break
[17:44:50.854]                         }
[17:44:50.854]                       }
[17:44:50.854]                     }
[17:44:50.854]                     invisible(muffled)
[17:44:50.854]                   }
[17:44:50.854]                   muffleCondition(cond)
[17:44:50.854]                 })
[17:44:50.854]             }))
[17:44:50.854]             future::FutureResult(value = ...future.value$value, 
[17:44:50.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.854]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.854]                     ...future.globalenv.names))
[17:44:50.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.854]         }, condition = base::local({
[17:44:50.854]             c <- base::c
[17:44:50.854]             inherits <- base::inherits
[17:44:50.854]             invokeRestart <- base::invokeRestart
[17:44:50.854]             length <- base::length
[17:44:50.854]             list <- base::list
[17:44:50.854]             seq.int <- base::seq.int
[17:44:50.854]             signalCondition <- base::signalCondition
[17:44:50.854]             sys.calls <- base::sys.calls
[17:44:50.854]             `[[` <- base::`[[`
[17:44:50.854]             `+` <- base::`+`
[17:44:50.854]             `<<-` <- base::`<<-`
[17:44:50.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.854]                   3L)]
[17:44:50.854]             }
[17:44:50.854]             function(cond) {
[17:44:50.854]                 is_error <- inherits(cond, "error")
[17:44:50.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.854]                   NULL)
[17:44:50.854]                 if (is_error) {
[17:44:50.854]                   sessionInformation <- function() {
[17:44:50.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.854]                       search = base::search(), system = base::Sys.info())
[17:44:50.854]                   }
[17:44:50.854]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.854]                     cond$call), session = sessionInformation(), 
[17:44:50.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.854]                   signalCondition(cond)
[17:44:50.854]                 }
[17:44:50.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.854]                 "immediateCondition"))) {
[17:44:50.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.854]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.854]                   if (TRUE && !signal) {
[17:44:50.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.854]                     {
[17:44:50.854]                       inherits <- base::inherits
[17:44:50.854]                       invokeRestart <- base::invokeRestart
[17:44:50.854]                       is.null <- base::is.null
[17:44:50.854]                       muffled <- FALSE
[17:44:50.854]                       if (inherits(cond, "message")) {
[17:44:50.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.854]                         if (muffled) 
[17:44:50.854]                           invokeRestart("muffleMessage")
[17:44:50.854]                       }
[17:44:50.854]                       else if (inherits(cond, "warning")) {
[17:44:50.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.854]                         if (muffled) 
[17:44:50.854]                           invokeRestart("muffleWarning")
[17:44:50.854]                       }
[17:44:50.854]                       else if (inherits(cond, "condition")) {
[17:44:50.854]                         if (!is.null(pattern)) {
[17:44:50.854]                           computeRestarts <- base::computeRestarts
[17:44:50.854]                           grepl <- base::grepl
[17:44:50.854]                           restarts <- computeRestarts(cond)
[17:44:50.854]                           for (restart in restarts) {
[17:44:50.854]                             name <- restart$name
[17:44:50.854]                             if (is.null(name)) 
[17:44:50.854]                               next
[17:44:50.854]                             if (!grepl(pattern, name)) 
[17:44:50.854]                               next
[17:44:50.854]                             invokeRestart(restart)
[17:44:50.854]                             muffled <- TRUE
[17:44:50.854]                             break
[17:44:50.854]                           }
[17:44:50.854]                         }
[17:44:50.854]                       }
[17:44:50.854]                       invisible(muffled)
[17:44:50.854]                     }
[17:44:50.854]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.854]                   }
[17:44:50.854]                 }
[17:44:50.854]                 else {
[17:44:50.854]                   if (TRUE) {
[17:44:50.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.854]                     {
[17:44:50.854]                       inherits <- base::inherits
[17:44:50.854]                       invokeRestart <- base::invokeRestart
[17:44:50.854]                       is.null <- base::is.null
[17:44:50.854]                       muffled <- FALSE
[17:44:50.854]                       if (inherits(cond, "message")) {
[17:44:50.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.854]                         if (muffled) 
[17:44:50.854]                           invokeRestart("muffleMessage")
[17:44:50.854]                       }
[17:44:50.854]                       else if (inherits(cond, "warning")) {
[17:44:50.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.854]                         if (muffled) 
[17:44:50.854]                           invokeRestart("muffleWarning")
[17:44:50.854]                       }
[17:44:50.854]                       else if (inherits(cond, "condition")) {
[17:44:50.854]                         if (!is.null(pattern)) {
[17:44:50.854]                           computeRestarts <- base::computeRestarts
[17:44:50.854]                           grepl <- base::grepl
[17:44:50.854]                           restarts <- computeRestarts(cond)
[17:44:50.854]                           for (restart in restarts) {
[17:44:50.854]                             name <- restart$name
[17:44:50.854]                             if (is.null(name)) 
[17:44:50.854]                               next
[17:44:50.854]                             if (!grepl(pattern, name)) 
[17:44:50.854]                               next
[17:44:50.854]                             invokeRestart(restart)
[17:44:50.854]                             muffled <- TRUE
[17:44:50.854]                             break
[17:44:50.854]                           }
[17:44:50.854]                         }
[17:44:50.854]                       }
[17:44:50.854]                       invisible(muffled)
[17:44:50.854]                     }
[17:44:50.854]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.854]                   }
[17:44:50.854]                 }
[17:44:50.854]             }
[17:44:50.854]         }))
[17:44:50.854]     }, error = function(ex) {
[17:44:50.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.854]                 ...future.rng), started = ...future.startTime, 
[17:44:50.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.854]             version = "1.8"), class = "FutureResult")
[17:44:50.854]     }, finally = {
[17:44:50.854]         if (!identical(...future.workdir, getwd())) 
[17:44:50.854]             setwd(...future.workdir)
[17:44:50.854]         {
[17:44:50.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.854]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.854]             }
[17:44:50.854]             base::options(...future.oldOptions)
[17:44:50.854]             if (.Platform$OS.type == "windows") {
[17:44:50.854]                 old_names <- names(...future.oldEnvVars)
[17:44:50.854]                 envs <- base::Sys.getenv()
[17:44:50.854]                 names <- names(envs)
[17:44:50.854]                 common <- intersect(names, old_names)
[17:44:50.854]                 added <- setdiff(names, old_names)
[17:44:50.854]                 removed <- setdiff(old_names, names)
[17:44:50.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.854]                   envs[common]]
[17:44:50.854]                 NAMES <- toupper(changed)
[17:44:50.854]                 args <- list()
[17:44:50.854]                 for (kk in seq_along(NAMES)) {
[17:44:50.854]                   name <- changed[[kk]]
[17:44:50.854]                   NAME <- NAMES[[kk]]
[17:44:50.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.854]                     next
[17:44:50.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.854]                 }
[17:44:50.854]                 NAMES <- toupper(added)
[17:44:50.854]                 for (kk in seq_along(NAMES)) {
[17:44:50.854]                   name <- added[[kk]]
[17:44:50.854]                   NAME <- NAMES[[kk]]
[17:44:50.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.854]                     next
[17:44:50.854]                   args[[name]] <- ""
[17:44:50.854]                 }
[17:44:50.854]                 NAMES <- toupper(removed)
[17:44:50.854]                 for (kk in seq_along(NAMES)) {
[17:44:50.854]                   name <- removed[[kk]]
[17:44:50.854]                   NAME <- NAMES[[kk]]
[17:44:50.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.854]                     next
[17:44:50.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.854]                 }
[17:44:50.854]                 if (length(args) > 0) 
[17:44:50.854]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.854]             }
[17:44:50.854]             else {
[17:44:50.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.854]             }
[17:44:50.854]             {
[17:44:50.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.854]                   0L) {
[17:44:50.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.854]                   base::options(opts)
[17:44:50.854]                 }
[17:44:50.854]                 {
[17:44:50.854]                   {
[17:44:50.854]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.854]                     NULL
[17:44:50.854]                   }
[17:44:50.854]                   options(future.plan = NULL)
[17:44:50.854]                   if (is.na(NA_character_)) 
[17:44:50.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.854]                     .init = FALSE)
[17:44:50.854]                 }
[17:44:50.854]             }
[17:44:50.854]         }
[17:44:50.854]     })
[17:44:50.854]     if (TRUE) {
[17:44:50.854]         base::sink(type = "output", split = FALSE)
[17:44:50.854]         if (TRUE) {
[17:44:50.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.854]         }
[17:44:50.854]         else {
[17:44:50.854]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.854]         }
[17:44:50.854]         base::close(...future.stdout)
[17:44:50.854]         ...future.stdout <- NULL
[17:44:50.854]     }
[17:44:50.854]     ...future.result$conditions <- ...future.conditions
[17:44:50.854]     ...future.result$finished <- base::Sys.time()
[17:44:50.854]     ...future.result
[17:44:50.854] }
[17:44:50.857] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:44:50.857] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:50.857] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:50.858] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.858] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.858] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:44:50.858] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:44:50.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.859] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.859] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.859] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.860] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:44:50.860] MultisessionFuture started
[17:44:50.860] - Launch lazy future ... done
[17:44:50.860] run() for ‘MultisessionFuture’ ... done
[17:44:50.860] Created future:
[17:44:50.862] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.862] - Validating connection of MultisessionFuture
[17:44:50.862] - received message: FutureResult
[17:44:50.862] - Received FutureResult
[17:44:50.863] - Erased future from FutureRegistry
[17:44:50.863] result() for ClusterFuture ...
[17:44:50.863] - result already collected: FutureResult
[17:44:50.863] result() for ClusterFuture ... done
[17:44:50.863] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.861] MultisessionFuture:
[17:44:50.861] Label: ‘future_.mapply-2’
[17:44:50.861] Expression:
[17:44:50.861] {
[17:44:50.861]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.861]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.861]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.861]         on.exit(options(oopts), add = TRUE)
[17:44:50.861]     }
[17:44:50.861]     {
[17:44:50.861]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.861]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.861]         do.call(mapply, args = args)
[17:44:50.861]     }
[17:44:50.861] }
[17:44:50.861] Lazy evaluation: FALSE
[17:44:50.861] Asynchronous evaluation: TRUE
[17:44:50.861] Local evaluation: TRUE
[17:44:50.861] Environment: R_GlobalEnv
[17:44:50.861] Capture standard output: TRUE
[17:44:50.861] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.861] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.861] Packages: <none>
[17:44:50.861] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.861] Resolved: TRUE
[17:44:50.861] Value: <not collected>
[17:44:50.861] Conditions captured: <none>
[17:44:50.861] Early signaling: FALSE
[17:44:50.861] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.861] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.863] Chunk #2 of 2 ... DONE
[17:44:50.863] Launching 2 futures (chunks) ... DONE
[17:44:50.863] Resolving 2 futures (chunks) ...
[17:44:50.863] resolve() on list ...
[17:44:50.864]  recursive: 0
[17:44:50.864]  length: 2
[17:44:50.864] 
[17:44:50.864] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.864] - Validating connection of MultisessionFuture
[17:44:50.864] - received message: FutureResult
[17:44:50.865] - Received FutureResult
[17:44:50.865] - Erased future from FutureRegistry
[17:44:50.865] result() for ClusterFuture ...
[17:44:50.865] - result already collected: FutureResult
[17:44:50.865] result() for ClusterFuture ... done
[17:44:50.865] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.865] Future #1
[17:44:50.865] result() for ClusterFuture ...
[17:44:50.865] - result already collected: FutureResult
[17:44:50.865] result() for ClusterFuture ... done
[17:44:50.865] result() for ClusterFuture ...
[17:44:50.865] - result already collected: FutureResult
[17:44:50.866] result() for ClusterFuture ... done
[17:44:50.866] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:50.866] - nx: 2
[17:44:50.866] - relay: TRUE
[17:44:50.866] - stdout: TRUE
[17:44:50.866] - signal: TRUE
[17:44:50.866] - resignal: FALSE
[17:44:50.866] - force: TRUE
[17:44:50.866] - relayed: [n=2] FALSE, FALSE
[17:44:50.866] - queued futures: [n=2] FALSE, FALSE
[17:44:50.866]  - until=1
[17:44:50.866]  - relaying element #1
[17:44:50.867] result() for ClusterFuture ...
[17:44:50.867] - result already collected: FutureResult
[17:44:50.867] result() for ClusterFuture ... done
[17:44:50.867] result() for ClusterFuture ...
[17:44:50.867] - result already collected: FutureResult
[17:44:50.867] result() for ClusterFuture ... done
[17:44:50.867] result() for ClusterFuture ...
[17:44:50.867] - result already collected: FutureResult
[17:44:50.867] result() for ClusterFuture ... done
[17:44:50.867] result() for ClusterFuture ...
[17:44:50.867] - result already collected: FutureResult
[17:44:50.868] result() for ClusterFuture ... done
[17:44:50.868] - relayed: [n=2] TRUE, FALSE
[17:44:50.868] - queued futures: [n=2] TRUE, FALSE
[17:44:50.868] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:50.868]  length: 1 (resolved future 1)
[17:44:50.868] Future #2
[17:44:50.868] result() for ClusterFuture ...
[17:44:50.868] - result already collected: FutureResult
[17:44:50.868] result() for ClusterFuture ... done
[17:44:50.868] result() for ClusterFuture ...
[17:44:50.868] - result already collected: FutureResult
[17:44:50.868] result() for ClusterFuture ... done
[17:44:50.869] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:50.869] - nx: 2
[17:44:50.869] - relay: TRUE
[17:44:50.869] - stdout: TRUE
[17:44:50.869] - signal: TRUE
[17:44:50.869] - resignal: FALSE
[17:44:50.869] - force: TRUE
[17:44:50.869] - relayed: [n=2] TRUE, FALSE
[17:44:50.869] - queued futures: [n=2] TRUE, FALSE
[17:44:50.869]  - until=2
[17:44:50.869]  - relaying element #2
[17:44:50.869] result() for ClusterFuture ...
[17:44:50.870] - result already collected: FutureResult
[17:44:50.870] result() for ClusterFuture ... done
[17:44:50.870] result() for ClusterFuture ...
[17:44:50.870] - result already collected: FutureResult
[17:44:50.870] result() for ClusterFuture ... done
[17:44:50.870] result() for ClusterFuture ...
[17:44:50.870] - result already collected: FutureResult
[17:44:50.870] result() for ClusterFuture ... done
[17:44:50.870] result() for ClusterFuture ...
[17:44:50.870] - result already collected: FutureResult
[17:44:50.870] result() for ClusterFuture ... done
[17:44:50.870] - relayed: [n=2] TRUE, TRUE
[17:44:50.871] - queued futures: [n=2] TRUE, TRUE
[17:44:50.871] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:50.871]  length: 0 (resolved future 2)
[17:44:50.871] Relaying remaining futures
[17:44:50.871] signalConditionsASAP(NULL, pos=0) ...
[17:44:50.871] - nx: 2
[17:44:50.871] - relay: TRUE
[17:44:50.871] - stdout: TRUE
[17:44:50.871] - signal: TRUE
[17:44:50.871] - resignal: FALSE
[17:44:50.871] - force: TRUE
[17:44:50.871] - relayed: [n=2] TRUE, TRUE
[17:44:50.872] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:50.872] - relayed: [n=2] TRUE, TRUE
[17:44:50.872] - queued futures: [n=2] TRUE, TRUE
[17:44:50.872] signalConditionsASAP(NULL, pos=0) ... done
[17:44:50.872] resolve() on list ... DONE
[17:44:50.872] result() for ClusterFuture ...
[17:44:50.872] - result already collected: FutureResult
[17:44:50.872] result() for ClusterFuture ... done
[17:44:50.872] result() for ClusterFuture ...
[17:44:50.872] - result already collected: FutureResult
[17:44:50.872] result() for ClusterFuture ... done
[17:44:50.873] result() for ClusterFuture ...
[17:44:50.873] - result already collected: FutureResult
[17:44:50.873] result() for ClusterFuture ... done
[17:44:50.873] result() for ClusterFuture ...
[17:44:50.873] - result already collected: FutureResult
[17:44:50.873] result() for ClusterFuture ... done
[17:44:50.873]  - Number of value chunks collected: 2
[17:44:50.873] Resolving 2 futures (chunks) ... DONE
[17:44:50.873] Reducing values from 2 chunks ...
[17:44:50.873]  - Number of values collected after concatenation: 5
[17:44:50.873]  - Number of values expected: 5
[17:44:50.873] Reducing values from 2 chunks ... DONE
[17:44:50.874] future_mapply() ... DONE
[17:44:50.874] future_mapply() ...
[17:44:50.877] Number of chunks: 3
[17:44:50.878] Index remapping (attribute 'ordering'): [n = 5] 5, 3, 4, 1, 2
[17:44:50.878] getGlobalsAndPackagesXApply() ...
[17:44:50.878]  - future.globals: TRUE
[17:44:50.878] getGlobalsAndPackages() ...
[17:44:50.878] Searching for globals...
[17:44:50.879] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:50.879] Searching for globals ... DONE
[17:44:50.879] Resolving globals: FALSE
[17:44:50.880] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:50.880] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:50.880] - globals: [1] ‘FUN’
[17:44:50.880] 
[17:44:50.880] getGlobalsAndPackages() ... DONE
[17:44:50.880]  - globals found/used: [n=1] ‘FUN’
[17:44:50.881]  - needed namespaces: [n=0] 
[17:44:50.881] Finding globals ... DONE
[17:44:50.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:50.881] List of 2
[17:44:50.881]  $ ...future.FUN:function (C, k)  
[17:44:50.881]  $ MoreArgs     : NULL
[17:44:50.881]  - attr(*, "where")=List of 2
[17:44:50.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:50.881]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:50.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:50.881]  - attr(*, "resolved")= logi FALSE
[17:44:50.881]  - attr(*, "total_size")= num NA
[17:44:50.883] Packages to be attached in all futures: [n=0] 
[17:44:50.883] getGlobalsAndPackagesXApply() ... DONE
[17:44:50.884] Number of futures (= number of chunks): 3
[17:44:50.884] Launching 3 futures (chunks) ...
[17:44:50.884] Chunk #1 of 3 ...
[17:44:50.884]  - Finding globals in '...' for chunk #1 ...
[17:44:50.884] getGlobalsAndPackages() ...
[17:44:50.884] Searching for globals...
[17:44:50.884] 
[17:44:50.884] Searching for globals ... DONE
[17:44:50.885] - globals: [0] <none>
[17:44:50.885] getGlobalsAndPackages() ... DONE
[17:44:50.885]    + additional globals found: [n=0] 
[17:44:50.885]    + additional namespaces needed: [n=0] 
[17:44:50.885]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:50.885]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:50.885]  - seeds: <none>
[17:44:50.885]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.885] getGlobalsAndPackages() ...
[17:44:50.885] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.885] Resolving globals: FALSE
[17:44:50.886] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:50.886] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.886] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.887] 
[17:44:50.887] getGlobalsAndPackages() ... DONE
[17:44:50.887] run() for ‘Future’ ...
[17:44:50.887] - state: ‘created’
[17:44:50.887] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.901] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.901]   - Field: ‘node’
[17:44:50.901]   - Field: ‘label’
[17:44:50.901]   - Field: ‘local’
[17:44:50.901]   - Field: ‘owner’
[17:44:50.901]   - Field: ‘envir’
[17:44:50.901]   - Field: ‘workers’
[17:44:50.901]   - Field: ‘packages’
[17:44:50.901]   - Field: ‘gc’
[17:44:50.902]   - Field: ‘conditions’
[17:44:50.902]   - Field: ‘persistent’
[17:44:50.902]   - Field: ‘expr’
[17:44:50.902]   - Field: ‘uuid’
[17:44:50.902]   - Field: ‘seed’
[17:44:50.902]   - Field: ‘version’
[17:44:50.902]   - Field: ‘result’
[17:44:50.902]   - Field: ‘asynchronous’
[17:44:50.902]   - Field: ‘calls’
[17:44:50.902]   - Field: ‘globals’
[17:44:50.902]   - Field: ‘stdout’
[17:44:50.903]   - Field: ‘earlySignal’
[17:44:50.903]   - Field: ‘lazy’
[17:44:50.903]   - Field: ‘state’
[17:44:50.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.903] - Launch lazy future ...
[17:44:50.903] Packages needed by the future expression (n = 0): <none>
[17:44:50.903] Packages needed by future strategies (n = 0): <none>
[17:44:50.904] {
[17:44:50.904]     {
[17:44:50.904]         {
[17:44:50.904]             ...future.startTime <- base::Sys.time()
[17:44:50.904]             {
[17:44:50.904]                 {
[17:44:50.904]                   {
[17:44:50.904]                     {
[17:44:50.904]                       base::local({
[17:44:50.904]                         has_future <- base::requireNamespace("future", 
[17:44:50.904]                           quietly = TRUE)
[17:44:50.904]                         if (has_future) {
[17:44:50.904]                           ns <- base::getNamespace("future")
[17:44:50.904]                           version <- ns[[".package"]][["version"]]
[17:44:50.904]                           if (is.null(version)) 
[17:44:50.904]                             version <- utils::packageVersion("future")
[17:44:50.904]                         }
[17:44:50.904]                         else {
[17:44:50.904]                           version <- NULL
[17:44:50.904]                         }
[17:44:50.904]                         if (!has_future || version < "1.8.0") {
[17:44:50.904]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.904]                             "", base::R.version$version.string), 
[17:44:50.904]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.904]                               "release", "version")], collapse = " "), 
[17:44:50.904]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.904]                             info)
[17:44:50.904]                           info <- base::paste(info, collapse = "; ")
[17:44:50.904]                           if (!has_future) {
[17:44:50.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.904]                               info)
[17:44:50.904]                           }
[17:44:50.904]                           else {
[17:44:50.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.904]                               info, version)
[17:44:50.904]                           }
[17:44:50.904]                           base::stop(msg)
[17:44:50.904]                         }
[17:44:50.904]                       })
[17:44:50.904]                     }
[17:44:50.904]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.904]                     base::options(mc.cores = 1L)
[17:44:50.904]                   }
[17:44:50.904]                   ...future.strategy.old <- future::plan("list")
[17:44:50.904]                   options(future.plan = NULL)
[17:44:50.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.904]                 }
[17:44:50.904]                 ...future.workdir <- getwd()
[17:44:50.904]             }
[17:44:50.904]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.904]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.904]         }
[17:44:50.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.904]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:50.904]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.904]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.904]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.904]             base::names(...future.oldOptions))
[17:44:50.904]     }
[17:44:50.904]     if (FALSE) {
[17:44:50.904]     }
[17:44:50.904]     else {
[17:44:50.904]         if (TRUE) {
[17:44:50.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.904]                 open = "w")
[17:44:50.904]         }
[17:44:50.904]         else {
[17:44:50.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.904]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.904]         }
[17:44:50.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.904]             base::sink(type = "output", split = FALSE)
[17:44:50.904]             base::close(...future.stdout)
[17:44:50.904]         }, add = TRUE)
[17:44:50.904]     }
[17:44:50.904]     ...future.frame <- base::sys.nframe()
[17:44:50.904]     ...future.conditions <- base::list()
[17:44:50.904]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.904]     if (FALSE) {
[17:44:50.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.904]     }
[17:44:50.904]     ...future.result <- base::tryCatch({
[17:44:50.904]         base::withCallingHandlers({
[17:44:50.904]             ...future.value <- base::withVisible(base::local({
[17:44:50.904]                 ...future.makeSendCondition <- base::local({
[17:44:50.904]                   sendCondition <- NULL
[17:44:50.904]                   function(frame = 1L) {
[17:44:50.904]                     if (is.function(sendCondition)) 
[17:44:50.904]                       return(sendCondition)
[17:44:50.904]                     ns <- getNamespace("parallel")
[17:44:50.904]                     if (exists("sendData", mode = "function", 
[17:44:50.904]                       envir = ns)) {
[17:44:50.904]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.904]                         envir = ns)
[17:44:50.904]                       envir <- sys.frame(frame)
[17:44:50.904]                       master <- NULL
[17:44:50.904]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.904]                         !identical(envir, emptyenv())) {
[17:44:50.904]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.904]                           inherits = FALSE)) {
[17:44:50.904]                           master <- get("master", mode = "list", 
[17:44:50.904]                             envir = envir, inherits = FALSE)
[17:44:50.904]                           if (inherits(master, c("SOCKnode", 
[17:44:50.904]                             "SOCK0node"))) {
[17:44:50.904]                             sendCondition <<- function(cond) {
[17:44:50.904]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.904]                                 success = TRUE)
[17:44:50.904]                               parallel_sendData(master, data)
[17:44:50.904]                             }
[17:44:50.904]                             return(sendCondition)
[17:44:50.904]                           }
[17:44:50.904]                         }
[17:44:50.904]                         frame <- frame + 1L
[17:44:50.904]                         envir <- sys.frame(frame)
[17:44:50.904]                       }
[17:44:50.904]                     }
[17:44:50.904]                     sendCondition <<- function(cond) NULL
[17:44:50.904]                   }
[17:44:50.904]                 })
[17:44:50.904]                 withCallingHandlers({
[17:44:50.904]                   {
[17:44:50.904]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.904]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.904]                       ...future.globals.maxSize)) {
[17:44:50.904]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.904]                       on.exit(options(oopts), add = TRUE)
[17:44:50.904]                     }
[17:44:50.904]                     {
[17:44:50.904]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.904]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.904]                         USE.NAMES = FALSE)
[17:44:50.904]                       do.call(mapply, args = args)
[17:44:50.904]                     }
[17:44:50.904]                   }
[17:44:50.904]                 }, immediateCondition = function(cond) {
[17:44:50.904]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.904]                   sendCondition(cond)
[17:44:50.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.904]                   {
[17:44:50.904]                     inherits <- base::inherits
[17:44:50.904]                     invokeRestart <- base::invokeRestart
[17:44:50.904]                     is.null <- base::is.null
[17:44:50.904]                     muffled <- FALSE
[17:44:50.904]                     if (inherits(cond, "message")) {
[17:44:50.904]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.904]                       if (muffled) 
[17:44:50.904]                         invokeRestart("muffleMessage")
[17:44:50.904]                     }
[17:44:50.904]                     else if (inherits(cond, "warning")) {
[17:44:50.904]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.904]                       if (muffled) 
[17:44:50.904]                         invokeRestart("muffleWarning")
[17:44:50.904]                     }
[17:44:50.904]                     else if (inherits(cond, "condition")) {
[17:44:50.904]                       if (!is.null(pattern)) {
[17:44:50.904]                         computeRestarts <- base::computeRestarts
[17:44:50.904]                         grepl <- base::grepl
[17:44:50.904]                         restarts <- computeRestarts(cond)
[17:44:50.904]                         for (restart in restarts) {
[17:44:50.904]                           name <- restart$name
[17:44:50.904]                           if (is.null(name)) 
[17:44:50.904]                             next
[17:44:50.904]                           if (!grepl(pattern, name)) 
[17:44:50.904]                             next
[17:44:50.904]                           invokeRestart(restart)
[17:44:50.904]                           muffled <- TRUE
[17:44:50.904]                           break
[17:44:50.904]                         }
[17:44:50.904]                       }
[17:44:50.904]                     }
[17:44:50.904]                     invisible(muffled)
[17:44:50.904]                   }
[17:44:50.904]                   muffleCondition(cond)
[17:44:50.904]                 })
[17:44:50.904]             }))
[17:44:50.904]             future::FutureResult(value = ...future.value$value, 
[17:44:50.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.904]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.904]                     ...future.globalenv.names))
[17:44:50.904]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.904]         }, condition = base::local({
[17:44:50.904]             c <- base::c
[17:44:50.904]             inherits <- base::inherits
[17:44:50.904]             invokeRestart <- base::invokeRestart
[17:44:50.904]             length <- base::length
[17:44:50.904]             list <- base::list
[17:44:50.904]             seq.int <- base::seq.int
[17:44:50.904]             signalCondition <- base::signalCondition
[17:44:50.904]             sys.calls <- base::sys.calls
[17:44:50.904]             `[[` <- base::`[[`
[17:44:50.904]             `+` <- base::`+`
[17:44:50.904]             `<<-` <- base::`<<-`
[17:44:50.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.904]                   3L)]
[17:44:50.904]             }
[17:44:50.904]             function(cond) {
[17:44:50.904]                 is_error <- inherits(cond, "error")
[17:44:50.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.904]                   NULL)
[17:44:50.904]                 if (is_error) {
[17:44:50.904]                   sessionInformation <- function() {
[17:44:50.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.904]                       search = base::search(), system = base::Sys.info())
[17:44:50.904]                   }
[17:44:50.904]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.904]                     cond$call), session = sessionInformation(), 
[17:44:50.904]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.904]                   signalCondition(cond)
[17:44:50.904]                 }
[17:44:50.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.904]                 "immediateCondition"))) {
[17:44:50.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.904]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.904]                   if (TRUE && !signal) {
[17:44:50.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.904]                     {
[17:44:50.904]                       inherits <- base::inherits
[17:44:50.904]                       invokeRestart <- base::invokeRestart
[17:44:50.904]                       is.null <- base::is.null
[17:44:50.904]                       muffled <- FALSE
[17:44:50.904]                       if (inherits(cond, "message")) {
[17:44:50.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.904]                         if (muffled) 
[17:44:50.904]                           invokeRestart("muffleMessage")
[17:44:50.904]                       }
[17:44:50.904]                       else if (inherits(cond, "warning")) {
[17:44:50.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.904]                         if (muffled) 
[17:44:50.904]                           invokeRestart("muffleWarning")
[17:44:50.904]                       }
[17:44:50.904]                       else if (inherits(cond, "condition")) {
[17:44:50.904]                         if (!is.null(pattern)) {
[17:44:50.904]                           computeRestarts <- base::computeRestarts
[17:44:50.904]                           grepl <- base::grepl
[17:44:50.904]                           restarts <- computeRestarts(cond)
[17:44:50.904]                           for (restart in restarts) {
[17:44:50.904]                             name <- restart$name
[17:44:50.904]                             if (is.null(name)) 
[17:44:50.904]                               next
[17:44:50.904]                             if (!grepl(pattern, name)) 
[17:44:50.904]                               next
[17:44:50.904]                             invokeRestart(restart)
[17:44:50.904]                             muffled <- TRUE
[17:44:50.904]                             break
[17:44:50.904]                           }
[17:44:50.904]                         }
[17:44:50.904]                       }
[17:44:50.904]                       invisible(muffled)
[17:44:50.904]                     }
[17:44:50.904]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.904]                   }
[17:44:50.904]                 }
[17:44:50.904]                 else {
[17:44:50.904]                   if (TRUE) {
[17:44:50.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.904]                     {
[17:44:50.904]                       inherits <- base::inherits
[17:44:50.904]                       invokeRestart <- base::invokeRestart
[17:44:50.904]                       is.null <- base::is.null
[17:44:50.904]                       muffled <- FALSE
[17:44:50.904]                       if (inherits(cond, "message")) {
[17:44:50.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.904]                         if (muffled) 
[17:44:50.904]                           invokeRestart("muffleMessage")
[17:44:50.904]                       }
[17:44:50.904]                       else if (inherits(cond, "warning")) {
[17:44:50.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.904]                         if (muffled) 
[17:44:50.904]                           invokeRestart("muffleWarning")
[17:44:50.904]                       }
[17:44:50.904]                       else if (inherits(cond, "condition")) {
[17:44:50.904]                         if (!is.null(pattern)) {
[17:44:50.904]                           computeRestarts <- base::computeRestarts
[17:44:50.904]                           grepl <- base::grepl
[17:44:50.904]                           restarts <- computeRestarts(cond)
[17:44:50.904]                           for (restart in restarts) {
[17:44:50.904]                             name <- restart$name
[17:44:50.904]                             if (is.null(name)) 
[17:44:50.904]                               next
[17:44:50.904]                             if (!grepl(pattern, name)) 
[17:44:50.904]                               next
[17:44:50.904]                             invokeRestart(restart)
[17:44:50.904]                             muffled <- TRUE
[17:44:50.904]                             break
[17:44:50.904]                           }
[17:44:50.904]                         }
[17:44:50.904]                       }
[17:44:50.904]                       invisible(muffled)
[17:44:50.904]                     }
[17:44:50.904]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.904]                   }
[17:44:50.904]                 }
[17:44:50.904]             }
[17:44:50.904]         }))
[17:44:50.904]     }, error = function(ex) {
[17:44:50.904]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.904]                 ...future.rng), started = ...future.startTime, 
[17:44:50.904]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.904]             version = "1.8"), class = "FutureResult")
[17:44:50.904]     }, finally = {
[17:44:50.904]         if (!identical(...future.workdir, getwd())) 
[17:44:50.904]             setwd(...future.workdir)
[17:44:50.904]         {
[17:44:50.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.904]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.904]             }
[17:44:50.904]             base::options(...future.oldOptions)
[17:44:50.904]             if (.Platform$OS.type == "windows") {
[17:44:50.904]                 old_names <- names(...future.oldEnvVars)
[17:44:50.904]                 envs <- base::Sys.getenv()
[17:44:50.904]                 names <- names(envs)
[17:44:50.904]                 common <- intersect(names, old_names)
[17:44:50.904]                 added <- setdiff(names, old_names)
[17:44:50.904]                 removed <- setdiff(old_names, names)
[17:44:50.904]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.904]                   envs[common]]
[17:44:50.904]                 NAMES <- toupper(changed)
[17:44:50.904]                 args <- list()
[17:44:50.904]                 for (kk in seq_along(NAMES)) {
[17:44:50.904]                   name <- changed[[kk]]
[17:44:50.904]                   NAME <- NAMES[[kk]]
[17:44:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.904]                     next
[17:44:50.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.904]                 }
[17:44:50.904]                 NAMES <- toupper(added)
[17:44:50.904]                 for (kk in seq_along(NAMES)) {
[17:44:50.904]                   name <- added[[kk]]
[17:44:50.904]                   NAME <- NAMES[[kk]]
[17:44:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.904]                     next
[17:44:50.904]                   args[[name]] <- ""
[17:44:50.904]                 }
[17:44:50.904]                 NAMES <- toupper(removed)
[17:44:50.904]                 for (kk in seq_along(NAMES)) {
[17:44:50.904]                   name <- removed[[kk]]
[17:44:50.904]                   NAME <- NAMES[[kk]]
[17:44:50.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.904]                     next
[17:44:50.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.904]                 }
[17:44:50.904]                 if (length(args) > 0) 
[17:44:50.904]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.904]             }
[17:44:50.904]             else {
[17:44:50.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.904]             }
[17:44:50.904]             {
[17:44:50.904]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.904]                   0L) {
[17:44:50.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.904]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.904]                   base::options(opts)
[17:44:50.904]                 }
[17:44:50.904]                 {
[17:44:50.904]                   {
[17:44:50.904]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.904]                     NULL
[17:44:50.904]                   }
[17:44:50.904]                   options(future.plan = NULL)
[17:44:50.904]                   if (is.na(NA_character_)) 
[17:44:50.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.904]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.904]                     .init = FALSE)
[17:44:50.904]                 }
[17:44:50.904]             }
[17:44:50.904]         }
[17:44:50.904]     })
[17:44:50.904]     if (TRUE) {
[17:44:50.904]         base::sink(type = "output", split = FALSE)
[17:44:50.904]         if (TRUE) {
[17:44:50.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.904]         }
[17:44:50.904]         else {
[17:44:50.904]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.904]         }
[17:44:50.904]         base::close(...future.stdout)
[17:44:50.904]         ...future.stdout <- NULL
[17:44:50.904]     }
[17:44:50.904]     ...future.result$conditions <- ...future.conditions
[17:44:50.904]     ...future.result$finished <- base::Sys.time()
[17:44:50.904]     ...future.result
[17:44:50.904] }
[17:44:50.906] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:50.907] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.907] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.907] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.907] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.908] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:50.908] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:50.908] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.908] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.908] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.909] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.909] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:50.909] MultisessionFuture started
[17:44:50.909] - Launch lazy future ... done
[17:44:50.909] run() for ‘MultisessionFuture’ ... done
[17:44:50.910] Created future:
[17:44:50.910] MultisessionFuture:
[17:44:50.910] Label: ‘future_mapply-1’
[17:44:50.910] Expression:
[17:44:50.910] {
[17:44:50.910]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.910]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.910]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.910]         on.exit(options(oopts), add = TRUE)
[17:44:50.910]     }
[17:44:50.910]     {
[17:44:50.910]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.910]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.910]         do.call(mapply, args = args)
[17:44:50.910]     }
[17:44:50.910] }
[17:44:50.910] Lazy evaluation: FALSE
[17:44:50.910] Asynchronous evaluation: TRUE
[17:44:50.910] Local evaluation: TRUE
[17:44:50.910] Environment: R_GlobalEnv
[17:44:50.910] Capture standard output: TRUE
[17:44:50.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.910] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.910] Packages: <none>
[17:44:50.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.910] Resolved: FALSE
[17:44:50.910] Value: <not collected>
[17:44:50.910] Conditions captured: <none>
[17:44:50.910] Early signaling: FALSE
[17:44:50.910] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.910] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.921] Chunk #1 of 3 ... DONE
[17:44:50.921] Chunk #2 of 3 ...
[17:44:50.921]  - Finding globals in '...' for chunk #2 ...
[17:44:50.921] getGlobalsAndPackages() ...
[17:44:50.921] Searching for globals...
[17:44:50.922] 
[17:44:50.922] Searching for globals ... DONE
[17:44:50.922] - globals: [0] <none>
[17:44:50.922] getGlobalsAndPackages() ... DONE
[17:44:50.922]    + additional globals found: [n=0] 
[17:44:50.922]    + additional namespaces needed: [n=0] 
[17:44:50.922]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:50.923]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:50.923]  - seeds: <none>
[17:44:50.923]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.923] getGlobalsAndPackages() ...
[17:44:50.923] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.923] Resolving globals: FALSE
[17:44:50.923] The total size of the 5 globals is 3.41 KiB (3488 bytes)
[17:44:50.924] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.41 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (168 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.924] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.924] 
[17:44:50.924] getGlobalsAndPackages() ... DONE
[17:44:50.925] run() for ‘Future’ ...
[17:44:50.925] - state: ‘created’
[17:44:50.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.938] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.938]   - Field: ‘node’
[17:44:50.938]   - Field: ‘label’
[17:44:50.939]   - Field: ‘local’
[17:44:50.939]   - Field: ‘owner’
[17:44:50.939]   - Field: ‘envir’
[17:44:50.939]   - Field: ‘workers’
[17:44:50.939]   - Field: ‘packages’
[17:44:50.939]   - Field: ‘gc’
[17:44:50.939]   - Field: ‘conditions’
[17:44:50.939]   - Field: ‘persistent’
[17:44:50.939]   - Field: ‘expr’
[17:44:50.939]   - Field: ‘uuid’
[17:44:50.940]   - Field: ‘seed’
[17:44:50.940]   - Field: ‘version’
[17:44:50.940]   - Field: ‘result’
[17:44:50.940]   - Field: ‘asynchronous’
[17:44:50.940]   - Field: ‘calls’
[17:44:50.940]   - Field: ‘globals’
[17:44:50.940]   - Field: ‘stdout’
[17:44:50.940]   - Field: ‘earlySignal’
[17:44:50.940]   - Field: ‘lazy’
[17:44:50.940]   - Field: ‘state’
[17:44:50.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.941] - Launch lazy future ...
[17:44:50.941] Packages needed by the future expression (n = 0): <none>
[17:44:50.941] Packages needed by future strategies (n = 0): <none>
[17:44:50.941] {
[17:44:50.941]     {
[17:44:50.941]         {
[17:44:50.941]             ...future.startTime <- base::Sys.time()
[17:44:50.941]             {
[17:44:50.941]                 {
[17:44:50.941]                   {
[17:44:50.941]                     {
[17:44:50.941]                       base::local({
[17:44:50.941]                         has_future <- base::requireNamespace("future", 
[17:44:50.941]                           quietly = TRUE)
[17:44:50.941]                         if (has_future) {
[17:44:50.941]                           ns <- base::getNamespace("future")
[17:44:50.941]                           version <- ns[[".package"]][["version"]]
[17:44:50.941]                           if (is.null(version)) 
[17:44:50.941]                             version <- utils::packageVersion("future")
[17:44:50.941]                         }
[17:44:50.941]                         else {
[17:44:50.941]                           version <- NULL
[17:44:50.941]                         }
[17:44:50.941]                         if (!has_future || version < "1.8.0") {
[17:44:50.941]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.941]                             "", base::R.version$version.string), 
[17:44:50.941]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.941]                               "release", "version")], collapse = " "), 
[17:44:50.941]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.941]                             info)
[17:44:50.941]                           info <- base::paste(info, collapse = "; ")
[17:44:50.941]                           if (!has_future) {
[17:44:50.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.941]                               info)
[17:44:50.941]                           }
[17:44:50.941]                           else {
[17:44:50.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.941]                               info, version)
[17:44:50.941]                           }
[17:44:50.941]                           base::stop(msg)
[17:44:50.941]                         }
[17:44:50.941]                       })
[17:44:50.941]                     }
[17:44:50.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.941]                     base::options(mc.cores = 1L)
[17:44:50.941]                   }
[17:44:50.941]                   ...future.strategy.old <- future::plan("list")
[17:44:50.941]                   options(future.plan = NULL)
[17:44:50.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.941]                 }
[17:44:50.941]                 ...future.workdir <- getwd()
[17:44:50.941]             }
[17:44:50.941]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.941]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.941]         }
[17:44:50.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.941]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:50.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.941]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.941]             base::names(...future.oldOptions))
[17:44:50.941]     }
[17:44:50.941]     if (FALSE) {
[17:44:50.941]     }
[17:44:50.941]     else {
[17:44:50.941]         if (TRUE) {
[17:44:50.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.941]                 open = "w")
[17:44:50.941]         }
[17:44:50.941]         else {
[17:44:50.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.941]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.941]         }
[17:44:50.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.941]             base::sink(type = "output", split = FALSE)
[17:44:50.941]             base::close(...future.stdout)
[17:44:50.941]         }, add = TRUE)
[17:44:50.941]     }
[17:44:50.941]     ...future.frame <- base::sys.nframe()
[17:44:50.941]     ...future.conditions <- base::list()
[17:44:50.941]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.941]     if (FALSE) {
[17:44:50.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.941]     }
[17:44:50.941]     ...future.result <- base::tryCatch({
[17:44:50.941]         base::withCallingHandlers({
[17:44:50.941]             ...future.value <- base::withVisible(base::local({
[17:44:50.941]                 ...future.makeSendCondition <- base::local({
[17:44:50.941]                   sendCondition <- NULL
[17:44:50.941]                   function(frame = 1L) {
[17:44:50.941]                     if (is.function(sendCondition)) 
[17:44:50.941]                       return(sendCondition)
[17:44:50.941]                     ns <- getNamespace("parallel")
[17:44:50.941]                     if (exists("sendData", mode = "function", 
[17:44:50.941]                       envir = ns)) {
[17:44:50.941]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.941]                         envir = ns)
[17:44:50.941]                       envir <- sys.frame(frame)
[17:44:50.941]                       master <- NULL
[17:44:50.941]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.941]                         !identical(envir, emptyenv())) {
[17:44:50.941]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.941]                           inherits = FALSE)) {
[17:44:50.941]                           master <- get("master", mode = "list", 
[17:44:50.941]                             envir = envir, inherits = FALSE)
[17:44:50.941]                           if (inherits(master, c("SOCKnode", 
[17:44:50.941]                             "SOCK0node"))) {
[17:44:50.941]                             sendCondition <<- function(cond) {
[17:44:50.941]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.941]                                 success = TRUE)
[17:44:50.941]                               parallel_sendData(master, data)
[17:44:50.941]                             }
[17:44:50.941]                             return(sendCondition)
[17:44:50.941]                           }
[17:44:50.941]                         }
[17:44:50.941]                         frame <- frame + 1L
[17:44:50.941]                         envir <- sys.frame(frame)
[17:44:50.941]                       }
[17:44:50.941]                     }
[17:44:50.941]                     sendCondition <<- function(cond) NULL
[17:44:50.941]                   }
[17:44:50.941]                 })
[17:44:50.941]                 withCallingHandlers({
[17:44:50.941]                   {
[17:44:50.941]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.941]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.941]                       ...future.globals.maxSize)) {
[17:44:50.941]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.941]                       on.exit(options(oopts), add = TRUE)
[17:44:50.941]                     }
[17:44:50.941]                     {
[17:44:50.941]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.941]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.941]                         USE.NAMES = FALSE)
[17:44:50.941]                       do.call(mapply, args = args)
[17:44:50.941]                     }
[17:44:50.941]                   }
[17:44:50.941]                 }, immediateCondition = function(cond) {
[17:44:50.941]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.941]                   sendCondition(cond)
[17:44:50.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.941]                   {
[17:44:50.941]                     inherits <- base::inherits
[17:44:50.941]                     invokeRestart <- base::invokeRestart
[17:44:50.941]                     is.null <- base::is.null
[17:44:50.941]                     muffled <- FALSE
[17:44:50.941]                     if (inherits(cond, "message")) {
[17:44:50.941]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.941]                       if (muffled) 
[17:44:50.941]                         invokeRestart("muffleMessage")
[17:44:50.941]                     }
[17:44:50.941]                     else if (inherits(cond, "warning")) {
[17:44:50.941]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.941]                       if (muffled) 
[17:44:50.941]                         invokeRestart("muffleWarning")
[17:44:50.941]                     }
[17:44:50.941]                     else if (inherits(cond, "condition")) {
[17:44:50.941]                       if (!is.null(pattern)) {
[17:44:50.941]                         computeRestarts <- base::computeRestarts
[17:44:50.941]                         grepl <- base::grepl
[17:44:50.941]                         restarts <- computeRestarts(cond)
[17:44:50.941]                         for (restart in restarts) {
[17:44:50.941]                           name <- restart$name
[17:44:50.941]                           if (is.null(name)) 
[17:44:50.941]                             next
[17:44:50.941]                           if (!grepl(pattern, name)) 
[17:44:50.941]                             next
[17:44:50.941]                           invokeRestart(restart)
[17:44:50.941]                           muffled <- TRUE
[17:44:50.941]                           break
[17:44:50.941]                         }
[17:44:50.941]                       }
[17:44:50.941]                     }
[17:44:50.941]                     invisible(muffled)
[17:44:50.941]                   }
[17:44:50.941]                   muffleCondition(cond)
[17:44:50.941]                 })
[17:44:50.941]             }))
[17:44:50.941]             future::FutureResult(value = ...future.value$value, 
[17:44:50.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.941]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.941]                     ...future.globalenv.names))
[17:44:50.941]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.941]         }, condition = base::local({
[17:44:50.941]             c <- base::c
[17:44:50.941]             inherits <- base::inherits
[17:44:50.941]             invokeRestart <- base::invokeRestart
[17:44:50.941]             length <- base::length
[17:44:50.941]             list <- base::list
[17:44:50.941]             seq.int <- base::seq.int
[17:44:50.941]             signalCondition <- base::signalCondition
[17:44:50.941]             sys.calls <- base::sys.calls
[17:44:50.941]             `[[` <- base::`[[`
[17:44:50.941]             `+` <- base::`+`
[17:44:50.941]             `<<-` <- base::`<<-`
[17:44:50.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.941]                   3L)]
[17:44:50.941]             }
[17:44:50.941]             function(cond) {
[17:44:50.941]                 is_error <- inherits(cond, "error")
[17:44:50.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.941]                   NULL)
[17:44:50.941]                 if (is_error) {
[17:44:50.941]                   sessionInformation <- function() {
[17:44:50.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.941]                       search = base::search(), system = base::Sys.info())
[17:44:50.941]                   }
[17:44:50.941]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.941]                     cond$call), session = sessionInformation(), 
[17:44:50.941]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.941]                   signalCondition(cond)
[17:44:50.941]                 }
[17:44:50.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.941]                 "immediateCondition"))) {
[17:44:50.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.941]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.941]                   if (TRUE && !signal) {
[17:44:50.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.941]                     {
[17:44:50.941]                       inherits <- base::inherits
[17:44:50.941]                       invokeRestart <- base::invokeRestart
[17:44:50.941]                       is.null <- base::is.null
[17:44:50.941]                       muffled <- FALSE
[17:44:50.941]                       if (inherits(cond, "message")) {
[17:44:50.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.941]                         if (muffled) 
[17:44:50.941]                           invokeRestart("muffleMessage")
[17:44:50.941]                       }
[17:44:50.941]                       else if (inherits(cond, "warning")) {
[17:44:50.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.941]                         if (muffled) 
[17:44:50.941]                           invokeRestart("muffleWarning")
[17:44:50.941]                       }
[17:44:50.941]                       else if (inherits(cond, "condition")) {
[17:44:50.941]                         if (!is.null(pattern)) {
[17:44:50.941]                           computeRestarts <- base::computeRestarts
[17:44:50.941]                           grepl <- base::grepl
[17:44:50.941]                           restarts <- computeRestarts(cond)
[17:44:50.941]                           for (restart in restarts) {
[17:44:50.941]                             name <- restart$name
[17:44:50.941]                             if (is.null(name)) 
[17:44:50.941]                               next
[17:44:50.941]                             if (!grepl(pattern, name)) 
[17:44:50.941]                               next
[17:44:50.941]                             invokeRestart(restart)
[17:44:50.941]                             muffled <- TRUE
[17:44:50.941]                             break
[17:44:50.941]                           }
[17:44:50.941]                         }
[17:44:50.941]                       }
[17:44:50.941]                       invisible(muffled)
[17:44:50.941]                     }
[17:44:50.941]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.941]                   }
[17:44:50.941]                 }
[17:44:50.941]                 else {
[17:44:50.941]                   if (TRUE) {
[17:44:50.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.941]                     {
[17:44:50.941]                       inherits <- base::inherits
[17:44:50.941]                       invokeRestart <- base::invokeRestart
[17:44:50.941]                       is.null <- base::is.null
[17:44:50.941]                       muffled <- FALSE
[17:44:50.941]                       if (inherits(cond, "message")) {
[17:44:50.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.941]                         if (muffled) 
[17:44:50.941]                           invokeRestart("muffleMessage")
[17:44:50.941]                       }
[17:44:50.941]                       else if (inherits(cond, "warning")) {
[17:44:50.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.941]                         if (muffled) 
[17:44:50.941]                           invokeRestart("muffleWarning")
[17:44:50.941]                       }
[17:44:50.941]                       else if (inherits(cond, "condition")) {
[17:44:50.941]                         if (!is.null(pattern)) {
[17:44:50.941]                           computeRestarts <- base::computeRestarts
[17:44:50.941]                           grepl <- base::grepl
[17:44:50.941]                           restarts <- computeRestarts(cond)
[17:44:50.941]                           for (restart in restarts) {
[17:44:50.941]                             name <- restart$name
[17:44:50.941]                             if (is.null(name)) 
[17:44:50.941]                               next
[17:44:50.941]                             if (!grepl(pattern, name)) 
[17:44:50.941]                               next
[17:44:50.941]                             invokeRestart(restart)
[17:44:50.941]                             muffled <- TRUE
[17:44:50.941]                             break
[17:44:50.941]                           }
[17:44:50.941]                         }
[17:44:50.941]                       }
[17:44:50.941]                       invisible(muffled)
[17:44:50.941]                     }
[17:44:50.941]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.941]                   }
[17:44:50.941]                 }
[17:44:50.941]             }
[17:44:50.941]         }))
[17:44:50.941]     }, error = function(ex) {
[17:44:50.941]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.941]                 ...future.rng), started = ...future.startTime, 
[17:44:50.941]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.941]             version = "1.8"), class = "FutureResult")
[17:44:50.941]     }, finally = {
[17:44:50.941]         if (!identical(...future.workdir, getwd())) 
[17:44:50.941]             setwd(...future.workdir)
[17:44:50.941]         {
[17:44:50.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.941]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.941]             }
[17:44:50.941]             base::options(...future.oldOptions)
[17:44:50.941]             if (.Platform$OS.type == "windows") {
[17:44:50.941]                 old_names <- names(...future.oldEnvVars)
[17:44:50.941]                 envs <- base::Sys.getenv()
[17:44:50.941]                 names <- names(envs)
[17:44:50.941]                 common <- intersect(names, old_names)
[17:44:50.941]                 added <- setdiff(names, old_names)
[17:44:50.941]                 removed <- setdiff(old_names, names)
[17:44:50.941]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.941]                   envs[common]]
[17:44:50.941]                 NAMES <- toupper(changed)
[17:44:50.941]                 args <- list()
[17:44:50.941]                 for (kk in seq_along(NAMES)) {
[17:44:50.941]                   name <- changed[[kk]]
[17:44:50.941]                   NAME <- NAMES[[kk]]
[17:44:50.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.941]                     next
[17:44:50.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.941]                 }
[17:44:50.941]                 NAMES <- toupper(added)
[17:44:50.941]                 for (kk in seq_along(NAMES)) {
[17:44:50.941]                   name <- added[[kk]]
[17:44:50.941]                   NAME <- NAMES[[kk]]
[17:44:50.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.941]                     next
[17:44:50.941]                   args[[name]] <- ""
[17:44:50.941]                 }
[17:44:50.941]                 NAMES <- toupper(removed)
[17:44:50.941]                 for (kk in seq_along(NAMES)) {
[17:44:50.941]                   name <- removed[[kk]]
[17:44:50.941]                   NAME <- NAMES[[kk]]
[17:44:50.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.941]                     next
[17:44:50.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.941]                 }
[17:44:50.941]                 if (length(args) > 0) 
[17:44:50.941]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.941]             }
[17:44:50.941]             else {
[17:44:50.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.941]             }
[17:44:50.941]             {
[17:44:50.941]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.941]                   0L) {
[17:44:50.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.941]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.941]                   base::options(opts)
[17:44:50.941]                 }
[17:44:50.941]                 {
[17:44:50.941]                   {
[17:44:50.941]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.941]                     NULL
[17:44:50.941]                   }
[17:44:50.941]                   options(future.plan = NULL)
[17:44:50.941]                   if (is.na(NA_character_)) 
[17:44:50.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.941]                     .init = FALSE)
[17:44:50.941]                 }
[17:44:50.941]             }
[17:44:50.941]         }
[17:44:50.941]     })
[17:44:50.941]     if (TRUE) {
[17:44:50.941]         base::sink(type = "output", split = FALSE)
[17:44:50.941]         if (TRUE) {
[17:44:50.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.941]         }
[17:44:50.941]         else {
[17:44:50.941]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.941]         }
[17:44:50.941]         base::close(...future.stdout)
[17:44:50.941]         ...future.stdout <- NULL
[17:44:50.941]     }
[17:44:50.941]     ...future.result$conditions <- ...future.conditions
[17:44:50.941]     ...future.result$finished <- base::Sys.time()
[17:44:50.941]     ...future.result
[17:44:50.941] }
[17:44:50.944] Exporting 5 global objects (3.41 KiB) to cluster node #2 ...
[17:44:50.944] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:50.945] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:50.945] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:50.945] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.945] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[17:44:50.946] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[17:44:50.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:50.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.946] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:50.947] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:50.947] Exporting 5 global objects (3.41 KiB) to cluster node #2 ... DONE
[17:44:50.947] MultisessionFuture started
[17:44:50.947] - Launch lazy future ... done
[17:44:50.947] run() for ‘MultisessionFuture’ ... done
[17:44:50.948] Created future:
[17:44:50.948] MultisessionFuture:
[17:44:50.948] Label: ‘future_mapply-2’
[17:44:50.948] Expression:
[17:44:50.948] {
[17:44:50.948]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.948]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.948]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.948]         on.exit(options(oopts), add = TRUE)
[17:44:50.948]     }
[17:44:50.948]     {
[17:44:50.948]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.948]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.948]         do.call(mapply, args = args)
[17:44:50.948]     }
[17:44:50.948] }
[17:44:50.948] Lazy evaluation: FALSE
[17:44:50.948] Asynchronous evaluation: TRUE
[17:44:50.948] Local evaluation: TRUE
[17:44:50.948] Environment: R_GlobalEnv
[17:44:50.948] Capture standard output: TRUE
[17:44:50.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.948] Globals: 5 objects totaling 3.41 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 168 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.948] Packages: <none>
[17:44:50.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.948] Resolved: FALSE
[17:44:50.948] Value: <not collected>
[17:44:50.948] Conditions captured: <none>
[17:44:50.948] Early signaling: FALSE
[17:44:50.948] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.948] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.959] Chunk #2 of 3 ... DONE
[17:44:50.959] Chunk #3 of 3 ...
[17:44:50.959]  - Finding globals in '...' for chunk #3 ...
[17:44:50.960] getGlobalsAndPackages() ...
[17:44:50.960] Searching for globals...
[17:44:50.960] 
[17:44:50.960] Searching for globals ... DONE
[17:44:50.960] - globals: [0] <none>
[17:44:50.960] getGlobalsAndPackages() ... DONE
[17:44:50.960]    + additional globals found: [n=0] 
[17:44:50.961]    + additional namespaces needed: [n=0] 
[17:44:50.961]  - Finding globals in '...' for chunk #3 ... DONE
[17:44:50.961]  - Adjusted option 'future.globals.maxSize': 524288000 -> 3 * 524288000 = 1572864000 (bytes)
[17:44:50.961]  - seeds: <none>
[17:44:50.961]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.961] getGlobalsAndPackages() ...
[17:44:50.961] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.961] Resolving globals: FALSE
[17:44:50.962] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:50.962] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 1.46 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:50.962] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:50.962] 
[17:44:50.962] getGlobalsAndPackages() ... DONE
[17:44:50.963] run() for ‘Future’ ...
[17:44:50.963] - state: ‘created’
[17:44:50.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:50.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:50.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:50.977]   - Field: ‘node’
[17:44:50.977]   - Field: ‘label’
[17:44:50.977]   - Field: ‘local’
[17:44:50.977]   - Field: ‘owner’
[17:44:50.978]   - Field: ‘envir’
[17:44:50.978]   - Field: ‘workers’
[17:44:50.978]   - Field: ‘packages’
[17:44:50.978]   - Field: ‘gc’
[17:44:50.978]   - Field: ‘conditions’
[17:44:50.978]   - Field: ‘persistent’
[17:44:50.978]   - Field: ‘expr’
[17:44:50.978]   - Field: ‘uuid’
[17:44:50.978]   - Field: ‘seed’
[17:44:50.978]   - Field: ‘version’
[17:44:50.978]   - Field: ‘result’
[17:44:50.978]   - Field: ‘asynchronous’
[17:44:50.979]   - Field: ‘calls’
[17:44:50.979]   - Field: ‘globals’
[17:44:50.979]   - Field: ‘stdout’
[17:44:50.979]   - Field: ‘earlySignal’
[17:44:50.979]   - Field: ‘lazy’
[17:44:50.979]   - Field: ‘state’
[17:44:50.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:50.979] - Launch lazy future ...
[17:44:50.980] Packages needed by the future expression (n = 0): <none>
[17:44:50.980] Packages needed by future strategies (n = 0): <none>
[17:44:50.980] {
[17:44:50.980]     {
[17:44:50.980]         {
[17:44:50.980]             ...future.startTime <- base::Sys.time()
[17:44:50.980]             {
[17:44:50.980]                 {
[17:44:50.980]                   {
[17:44:50.980]                     {
[17:44:50.980]                       base::local({
[17:44:50.980]                         has_future <- base::requireNamespace("future", 
[17:44:50.980]                           quietly = TRUE)
[17:44:50.980]                         if (has_future) {
[17:44:50.980]                           ns <- base::getNamespace("future")
[17:44:50.980]                           version <- ns[[".package"]][["version"]]
[17:44:50.980]                           if (is.null(version)) 
[17:44:50.980]                             version <- utils::packageVersion("future")
[17:44:50.980]                         }
[17:44:50.980]                         else {
[17:44:50.980]                           version <- NULL
[17:44:50.980]                         }
[17:44:50.980]                         if (!has_future || version < "1.8.0") {
[17:44:50.980]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:50.980]                             "", base::R.version$version.string), 
[17:44:50.980]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:50.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:50.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:50.980]                               "release", "version")], collapse = " "), 
[17:44:50.980]                             hostname = base::Sys.info()[["nodename"]])
[17:44:50.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:50.980]                             info)
[17:44:50.980]                           info <- base::paste(info, collapse = "; ")
[17:44:50.980]                           if (!has_future) {
[17:44:50.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:50.980]                               info)
[17:44:50.980]                           }
[17:44:50.980]                           else {
[17:44:50.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:50.980]                               info, version)
[17:44:50.980]                           }
[17:44:50.980]                           base::stop(msg)
[17:44:50.980]                         }
[17:44:50.980]                       })
[17:44:50.980]                     }
[17:44:50.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:50.980]                     base::options(mc.cores = 1L)
[17:44:50.980]                   }
[17:44:50.980]                   ...future.strategy.old <- future::plan("list")
[17:44:50.980]                   options(future.plan = NULL)
[17:44:50.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:50.980]                 }
[17:44:50.980]                 ...future.workdir <- getwd()
[17:44:50.980]             }
[17:44:50.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:50.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:50.980]         }
[17:44:50.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:50.980]             future.globals.maxSize = 1572864000, future.globals.method = NULL, 
[17:44:50.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:50.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:50.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:50.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:50.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:50.980]             base::names(...future.oldOptions))
[17:44:50.980]     }
[17:44:50.980]     if (FALSE) {
[17:44:50.980]     }
[17:44:50.980]     else {
[17:44:50.980]         if (TRUE) {
[17:44:50.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:50.980]                 open = "w")
[17:44:50.980]         }
[17:44:50.980]         else {
[17:44:50.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:50.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:50.980]         }
[17:44:50.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:50.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:50.980]             base::sink(type = "output", split = FALSE)
[17:44:50.980]             base::close(...future.stdout)
[17:44:50.980]         }, add = TRUE)
[17:44:50.980]     }
[17:44:50.980]     ...future.frame <- base::sys.nframe()
[17:44:50.980]     ...future.conditions <- base::list()
[17:44:50.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:50.980]     if (FALSE) {
[17:44:50.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:50.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:50.980]     }
[17:44:50.980]     ...future.result <- base::tryCatch({
[17:44:50.980]         base::withCallingHandlers({
[17:44:50.980]             ...future.value <- base::withVisible(base::local({
[17:44:50.980]                 ...future.makeSendCondition <- base::local({
[17:44:50.980]                   sendCondition <- NULL
[17:44:50.980]                   function(frame = 1L) {
[17:44:50.980]                     if (is.function(sendCondition)) 
[17:44:50.980]                       return(sendCondition)
[17:44:50.980]                     ns <- getNamespace("parallel")
[17:44:50.980]                     if (exists("sendData", mode = "function", 
[17:44:50.980]                       envir = ns)) {
[17:44:50.980]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:50.980]                         envir = ns)
[17:44:50.980]                       envir <- sys.frame(frame)
[17:44:50.980]                       master <- NULL
[17:44:50.980]                       while (!identical(envir, .GlobalEnv) && 
[17:44:50.980]                         !identical(envir, emptyenv())) {
[17:44:50.980]                         if (exists("master", mode = "list", envir = envir, 
[17:44:50.980]                           inherits = FALSE)) {
[17:44:50.980]                           master <- get("master", mode = "list", 
[17:44:50.980]                             envir = envir, inherits = FALSE)
[17:44:50.980]                           if (inherits(master, c("SOCKnode", 
[17:44:50.980]                             "SOCK0node"))) {
[17:44:50.980]                             sendCondition <<- function(cond) {
[17:44:50.980]                               data <- list(type = "VALUE", value = cond, 
[17:44:50.980]                                 success = TRUE)
[17:44:50.980]                               parallel_sendData(master, data)
[17:44:50.980]                             }
[17:44:50.980]                             return(sendCondition)
[17:44:50.980]                           }
[17:44:50.980]                         }
[17:44:50.980]                         frame <- frame + 1L
[17:44:50.980]                         envir <- sys.frame(frame)
[17:44:50.980]                       }
[17:44:50.980]                     }
[17:44:50.980]                     sendCondition <<- function(cond) NULL
[17:44:50.980]                   }
[17:44:50.980]                 })
[17:44:50.980]                 withCallingHandlers({
[17:44:50.980]                   {
[17:44:50.980]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.980]                     if (!identical(...future.globals.maxSize.org, 
[17:44:50.980]                       ...future.globals.maxSize)) {
[17:44:50.980]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.980]                       on.exit(options(oopts), add = TRUE)
[17:44:50.980]                     }
[17:44:50.980]                     {
[17:44:50.980]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.980]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:50.980]                         USE.NAMES = FALSE)
[17:44:50.980]                       do.call(mapply, args = args)
[17:44:50.980]                     }
[17:44:50.980]                   }
[17:44:50.980]                 }, immediateCondition = function(cond) {
[17:44:50.980]                   sendCondition <- ...future.makeSendCondition()
[17:44:50.980]                   sendCondition(cond)
[17:44:50.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.980]                   {
[17:44:50.980]                     inherits <- base::inherits
[17:44:50.980]                     invokeRestart <- base::invokeRestart
[17:44:50.980]                     is.null <- base::is.null
[17:44:50.980]                     muffled <- FALSE
[17:44:50.980]                     if (inherits(cond, "message")) {
[17:44:50.980]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:50.980]                       if (muffled) 
[17:44:50.980]                         invokeRestart("muffleMessage")
[17:44:50.980]                     }
[17:44:50.980]                     else if (inherits(cond, "warning")) {
[17:44:50.980]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:50.980]                       if (muffled) 
[17:44:50.980]                         invokeRestart("muffleWarning")
[17:44:50.980]                     }
[17:44:50.980]                     else if (inherits(cond, "condition")) {
[17:44:50.980]                       if (!is.null(pattern)) {
[17:44:50.980]                         computeRestarts <- base::computeRestarts
[17:44:50.980]                         grepl <- base::grepl
[17:44:50.980]                         restarts <- computeRestarts(cond)
[17:44:50.980]                         for (restart in restarts) {
[17:44:50.980]                           name <- restart$name
[17:44:50.980]                           if (is.null(name)) 
[17:44:50.980]                             next
[17:44:50.980]                           if (!grepl(pattern, name)) 
[17:44:50.980]                             next
[17:44:50.980]                           invokeRestart(restart)
[17:44:50.980]                           muffled <- TRUE
[17:44:50.980]                           break
[17:44:50.980]                         }
[17:44:50.980]                       }
[17:44:50.980]                     }
[17:44:50.980]                     invisible(muffled)
[17:44:50.980]                   }
[17:44:50.980]                   muffleCondition(cond)
[17:44:50.980]                 })
[17:44:50.980]             }))
[17:44:50.980]             future::FutureResult(value = ...future.value$value, 
[17:44:50.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.980]                   ...future.rng), globalenv = if (FALSE) 
[17:44:50.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:50.980]                     ...future.globalenv.names))
[17:44:50.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:50.980]         }, condition = base::local({
[17:44:50.980]             c <- base::c
[17:44:50.980]             inherits <- base::inherits
[17:44:50.980]             invokeRestart <- base::invokeRestart
[17:44:50.980]             length <- base::length
[17:44:50.980]             list <- base::list
[17:44:50.980]             seq.int <- base::seq.int
[17:44:50.980]             signalCondition <- base::signalCondition
[17:44:50.980]             sys.calls <- base::sys.calls
[17:44:50.980]             `[[` <- base::`[[`
[17:44:50.980]             `+` <- base::`+`
[17:44:50.980]             `<<-` <- base::`<<-`
[17:44:50.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:50.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:50.980]                   3L)]
[17:44:50.980]             }
[17:44:50.980]             function(cond) {
[17:44:50.980]                 is_error <- inherits(cond, "error")
[17:44:50.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:50.980]                   NULL)
[17:44:50.980]                 if (is_error) {
[17:44:50.980]                   sessionInformation <- function() {
[17:44:50.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:50.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:50.980]                       search = base::search(), system = base::Sys.info())
[17:44:50.980]                   }
[17:44:50.980]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:50.980]                     cond$call), session = sessionInformation(), 
[17:44:50.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:50.980]                   signalCondition(cond)
[17:44:50.980]                 }
[17:44:50.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:50.980]                 "immediateCondition"))) {
[17:44:50.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:50.980]                   ...future.conditions[[length(...future.conditions) + 
[17:44:50.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:50.980]                   if (TRUE && !signal) {
[17:44:50.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.980]                     {
[17:44:50.980]                       inherits <- base::inherits
[17:44:50.980]                       invokeRestart <- base::invokeRestart
[17:44:50.980]                       is.null <- base::is.null
[17:44:50.980]                       muffled <- FALSE
[17:44:50.980]                       if (inherits(cond, "message")) {
[17:44:50.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.980]                         if (muffled) 
[17:44:50.980]                           invokeRestart("muffleMessage")
[17:44:50.980]                       }
[17:44:50.980]                       else if (inherits(cond, "warning")) {
[17:44:50.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.980]                         if (muffled) 
[17:44:50.980]                           invokeRestart("muffleWarning")
[17:44:50.980]                       }
[17:44:50.980]                       else if (inherits(cond, "condition")) {
[17:44:50.980]                         if (!is.null(pattern)) {
[17:44:50.980]                           computeRestarts <- base::computeRestarts
[17:44:50.980]                           grepl <- base::grepl
[17:44:50.980]                           restarts <- computeRestarts(cond)
[17:44:50.980]                           for (restart in restarts) {
[17:44:50.980]                             name <- restart$name
[17:44:50.980]                             if (is.null(name)) 
[17:44:50.980]                               next
[17:44:50.980]                             if (!grepl(pattern, name)) 
[17:44:50.980]                               next
[17:44:50.980]                             invokeRestart(restart)
[17:44:50.980]                             muffled <- TRUE
[17:44:50.980]                             break
[17:44:50.980]                           }
[17:44:50.980]                         }
[17:44:50.980]                       }
[17:44:50.980]                       invisible(muffled)
[17:44:50.980]                     }
[17:44:50.980]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.980]                   }
[17:44:50.980]                 }
[17:44:50.980]                 else {
[17:44:50.980]                   if (TRUE) {
[17:44:50.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:50.980]                     {
[17:44:50.980]                       inherits <- base::inherits
[17:44:50.980]                       invokeRestart <- base::invokeRestart
[17:44:50.980]                       is.null <- base::is.null
[17:44:50.980]                       muffled <- FALSE
[17:44:50.980]                       if (inherits(cond, "message")) {
[17:44:50.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:50.980]                         if (muffled) 
[17:44:50.980]                           invokeRestart("muffleMessage")
[17:44:50.980]                       }
[17:44:50.980]                       else if (inherits(cond, "warning")) {
[17:44:50.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:50.980]                         if (muffled) 
[17:44:50.980]                           invokeRestart("muffleWarning")
[17:44:50.980]                       }
[17:44:50.980]                       else if (inherits(cond, "condition")) {
[17:44:50.980]                         if (!is.null(pattern)) {
[17:44:50.980]                           computeRestarts <- base::computeRestarts
[17:44:50.980]                           grepl <- base::grepl
[17:44:50.980]                           restarts <- computeRestarts(cond)
[17:44:50.980]                           for (restart in restarts) {
[17:44:50.980]                             name <- restart$name
[17:44:50.980]                             if (is.null(name)) 
[17:44:50.980]                               next
[17:44:50.980]                             if (!grepl(pattern, name)) 
[17:44:50.980]                               next
[17:44:50.980]                             invokeRestart(restart)
[17:44:50.980]                             muffled <- TRUE
[17:44:50.980]                             break
[17:44:50.980]                           }
[17:44:50.980]                         }
[17:44:50.980]                       }
[17:44:50.980]                       invisible(muffled)
[17:44:50.980]                     }
[17:44:50.980]                     muffleCondition(cond, pattern = "^muffle")
[17:44:50.980]                   }
[17:44:50.980]                 }
[17:44:50.980]             }
[17:44:50.980]         }))
[17:44:50.980]     }, error = function(ex) {
[17:44:50.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:50.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:50.980]                 ...future.rng), started = ...future.startTime, 
[17:44:50.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:50.980]             version = "1.8"), class = "FutureResult")
[17:44:50.980]     }, finally = {
[17:44:50.980]         if (!identical(...future.workdir, getwd())) 
[17:44:50.980]             setwd(...future.workdir)
[17:44:50.980]         {
[17:44:50.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:50.980]                 ...future.oldOptions$nwarnings <- NULL
[17:44:50.980]             }
[17:44:50.980]             base::options(...future.oldOptions)
[17:44:50.980]             if (.Platform$OS.type == "windows") {
[17:44:50.980]                 old_names <- names(...future.oldEnvVars)
[17:44:50.980]                 envs <- base::Sys.getenv()
[17:44:50.980]                 names <- names(envs)
[17:44:50.980]                 common <- intersect(names, old_names)
[17:44:50.980]                 added <- setdiff(names, old_names)
[17:44:50.980]                 removed <- setdiff(old_names, names)
[17:44:50.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:50.980]                   envs[common]]
[17:44:50.980]                 NAMES <- toupper(changed)
[17:44:50.980]                 args <- list()
[17:44:50.980]                 for (kk in seq_along(NAMES)) {
[17:44:50.980]                   name <- changed[[kk]]
[17:44:50.980]                   NAME <- NAMES[[kk]]
[17:44:50.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.980]                     next
[17:44:50.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.980]                 }
[17:44:50.980]                 NAMES <- toupper(added)
[17:44:50.980]                 for (kk in seq_along(NAMES)) {
[17:44:50.980]                   name <- added[[kk]]
[17:44:50.980]                   NAME <- NAMES[[kk]]
[17:44:50.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.980]                     next
[17:44:50.980]                   args[[name]] <- ""
[17:44:50.980]                 }
[17:44:50.980]                 NAMES <- toupper(removed)
[17:44:50.980]                 for (kk in seq_along(NAMES)) {
[17:44:50.980]                   name <- removed[[kk]]
[17:44:50.980]                   NAME <- NAMES[[kk]]
[17:44:50.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:50.980]                     next
[17:44:50.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:50.980]                 }
[17:44:50.980]                 if (length(args) > 0) 
[17:44:50.980]                   base::do.call(base::Sys.setenv, args = args)
[17:44:50.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:50.980]             }
[17:44:50.980]             else {
[17:44:50.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:50.980]             }
[17:44:50.980]             {
[17:44:50.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:50.980]                   0L) {
[17:44:50.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:50.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:50.980]                   base::options(opts)
[17:44:50.980]                 }
[17:44:50.980]                 {
[17:44:50.980]                   {
[17:44:50.980]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:50.980]                     NULL
[17:44:50.980]                   }
[17:44:50.980]                   options(future.plan = NULL)
[17:44:50.980]                   if (is.na(NA_character_)) 
[17:44:50.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:50.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:50.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:50.980]                     .init = FALSE)
[17:44:50.980]                 }
[17:44:50.980]             }
[17:44:50.980]         }
[17:44:50.980]     })
[17:44:50.980]     if (TRUE) {
[17:44:50.980]         base::sink(type = "output", split = FALSE)
[17:44:50.980]         if (TRUE) {
[17:44:50.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:50.980]         }
[17:44:50.980]         else {
[17:44:50.980]             ...future.result["stdout"] <- base::list(NULL)
[17:44:50.980]         }
[17:44:50.980]         base::close(...future.stdout)
[17:44:50.980]         ...future.stdout <- NULL
[17:44:50.980]     }
[17:44:50.980]     ...future.result$conditions <- ...future.conditions
[17:44:50.980]     ...future.result$finished <- base::Sys.time()
[17:44:50.980]     ...future.result
[17:44:50.980] }
[17:44:50.982] Poll #1 (0): usedNodes() = 2, workers = 2
[17:44:50.993] receiveMessageFromWorker() for ClusterFuture ...
[17:44:50.993] - Validating connection of MultisessionFuture
[17:44:50.993] - received message: FutureResult
[17:44:50.994] - Received FutureResult
[17:44:50.994] - Erased future from FutureRegistry
[17:44:50.994] result() for ClusterFuture ...
[17:44:50.994] - result already collected: FutureResult
[17:44:50.994] result() for ClusterFuture ... done
[17:44:50.994] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:50.994] result() for ClusterFuture ...
[17:44:50.994] - result already collected: FutureResult
[17:44:50.994] result() for ClusterFuture ... done
[17:44:50.994] result() for ClusterFuture ...
[17:44:50.994] - result already collected: FutureResult
[17:44:50.995] result() for ClusterFuture ... done
[17:44:50.995] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:50.995] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:50.996] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:50.996] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:50.996] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.996] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:50.997] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:50.997] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:50.997] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.997] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:50.998] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:50.998] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:50.998] MultisessionFuture started
[17:44:50.998] - Launch lazy future ... done
[17:44:50.999] run() for ‘MultisessionFuture’ ... done
[17:44:50.999] Created future:
[17:44:50.999] MultisessionFuture:
[17:44:50.999] Label: ‘future_mapply-3’
[17:44:50.999] Expression:
[17:44:50.999] {
[17:44:50.999]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:50.999]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:50.999]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:50.999]         on.exit(options(oopts), add = TRUE)
[17:44:50.999]     }
[17:44:50.999]     {
[17:44:50.999]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:50.999]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:50.999]         do.call(mapply, args = args)
[17:44:50.999]     }
[17:44:50.999] }
[17:44:50.999] Lazy evaluation: FALSE
[17:44:50.999] Asynchronous evaluation: TRUE
[17:44:50.999] Local evaluation: TRUE
[17:44:50.999] Environment: R_GlobalEnv
[17:44:50.999] Capture standard output: TRUE
[17:44:50.999] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:50.999] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:50.999] Packages: <none>
[17:44:50.999] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:50.999] Resolved: FALSE
[17:44:50.999] Value: <not collected>
[17:44:50.999] Conditions captured: <none>
[17:44:50.999] Early signaling: FALSE
[17:44:50.999] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:50.999] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.010] Chunk #3 of 3 ... DONE
[17:44:51.010] Launching 3 futures (chunks) ... DONE
[17:44:51.010] Resolving 3 futures (chunks) ...
[17:44:51.011] resolve() on list ...
[17:44:51.011]  recursive: 0
[17:44:51.011]  length: 3
[17:44:51.011] 
[17:44:51.011] Future #1
[17:44:51.011] result() for ClusterFuture ...
[17:44:51.011] - result already collected: FutureResult
[17:44:51.011] result() for ClusterFuture ... done
[17:44:51.011] result() for ClusterFuture ...
[17:44:51.012] - result already collected: FutureResult
[17:44:51.012] result() for ClusterFuture ... done
[17:44:51.012] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.012] - nx: 3
[17:44:51.012] - relay: TRUE
[17:44:51.012] - stdout: TRUE
[17:44:51.012] - signal: TRUE
[17:44:51.012] - resignal: FALSE
[17:44:51.012] - force: TRUE
[17:44:51.012] - relayed: [n=3] FALSE, FALSE, FALSE
[17:44:51.012] - queued futures: [n=3] FALSE, FALSE, FALSE
[17:44:51.013]  - until=1
[17:44:51.013]  - relaying element #1
[17:44:51.013] result() for ClusterFuture ...
[17:44:51.013] - result already collected: FutureResult
[17:44:51.013] result() for ClusterFuture ... done
[17:44:51.013] result() for ClusterFuture ...
[17:44:51.013] - result already collected: FutureResult
[17:44:51.013] result() for ClusterFuture ... done
[17:44:51.013] result() for ClusterFuture ...
[17:44:51.013] - result already collected: FutureResult
[17:44:51.013] result() for ClusterFuture ... done
[17:44:51.014] result() for ClusterFuture ...
[17:44:51.014] - result already collected: FutureResult
[17:44:51.014] result() for ClusterFuture ... done
[17:44:51.014] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:51.014] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:51.014] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.016]  length: 2 (resolved future 1)
[17:44:51.017] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.017] - Validating connection of MultisessionFuture
[17:44:51.017] - received message: FutureResult
[17:44:51.017] - Received FutureResult
[17:44:51.017] - Erased future from FutureRegistry
[17:44:51.017] result() for ClusterFuture ...
[17:44:51.017] - result already collected: FutureResult
[17:44:51.017] result() for ClusterFuture ... done
[17:44:51.018] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.018] Future #2
[17:44:51.018] result() for ClusterFuture ...
[17:44:51.018] - result already collected: FutureResult
[17:44:51.018] result() for ClusterFuture ... done
[17:44:51.018] result() for ClusterFuture ...
[17:44:51.018] - result already collected: FutureResult
[17:44:51.018] result() for ClusterFuture ... done
[17:44:51.018] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.018] - nx: 3
[17:44:51.018] - relay: TRUE
[17:44:51.018] - stdout: TRUE
[17:44:51.019] - signal: TRUE
[17:44:51.019] - resignal: FALSE
[17:44:51.019] - force: TRUE
[17:44:51.019] - relayed: [n=3] TRUE, FALSE, FALSE
[17:44:51.019] - queued futures: [n=3] TRUE, FALSE, FALSE
[17:44:51.019]  - until=2
[17:44:51.019]  - relaying element #2
[17:44:51.019] result() for ClusterFuture ...
[17:44:51.019] - result already collected: FutureResult
[17:44:51.019] result() for ClusterFuture ... done
[17:44:51.019] result() for ClusterFuture ...
[17:44:51.019] - result already collected: FutureResult
[17:44:51.020] result() for ClusterFuture ... done
[17:44:51.020] result() for ClusterFuture ...
[17:44:51.020] - result already collected: FutureResult
[17:44:51.020] result() for ClusterFuture ... done
[17:44:51.020] result() for ClusterFuture ...
[17:44:51.020] - result already collected: FutureResult
[17:44:51.020] result() for ClusterFuture ... done
[17:44:51.020] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:51.020] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:51.020] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.020]  length: 1 (resolved future 2)
[17:44:51.041] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.042] - Validating connection of MultisessionFuture
[17:44:51.042] - received message: FutureResult
[17:44:51.042] - Received FutureResult
[17:44:51.042] - Erased future from FutureRegistry
[17:44:51.042] result() for ClusterFuture ...
[17:44:51.042] - result already collected: FutureResult
[17:44:51.042] result() for ClusterFuture ... done
[17:44:51.042] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.042] Future #3
[17:44:51.043] result() for ClusterFuture ...
[17:44:51.043] - result already collected: FutureResult
[17:44:51.043] result() for ClusterFuture ... done
[17:44:51.043] result() for ClusterFuture ...
[17:44:51.043] - result already collected: FutureResult
[17:44:51.043] result() for ClusterFuture ... done
[17:44:51.043] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:44:51.043] - nx: 3
[17:44:51.043] - relay: TRUE
[17:44:51.043] - stdout: TRUE
[17:44:51.043] - signal: TRUE
[17:44:51.043] - resignal: FALSE
[17:44:51.044] - force: TRUE
[17:44:51.044] - relayed: [n=3] TRUE, TRUE, FALSE
[17:44:51.044] - queued futures: [n=3] TRUE, TRUE, FALSE
[17:44:51.044]  - until=3
[17:44:51.044]  - relaying element #3
[17:44:51.044] result() for ClusterFuture ...
[17:44:51.044] - result already collected: FutureResult
[17:44:51.044] result() for ClusterFuture ... done
[17:44:51.044] result() for ClusterFuture ...
[17:44:51.044] - result already collected: FutureResult
[17:44:51.044] result() for ClusterFuture ... done
[17:44:51.045] result() for ClusterFuture ...
[17:44:51.045] - result already collected: FutureResult
[17:44:51.045] result() for ClusterFuture ... done
[17:44:51.045] result() for ClusterFuture ...
[17:44:51.045] - result already collected: FutureResult
[17:44:51.045] result() for ClusterFuture ... done
[17:44:51.045] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:51.045] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:51.045] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:44:51.045]  length: 0 (resolved future 3)
[17:44:51.045] Relaying remaining futures
[17:44:51.045] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.046] - nx: 3
[17:44:51.046] - relay: TRUE
[17:44:51.046] - stdout: TRUE
[17:44:51.046] - signal: TRUE
[17:44:51.046] - resignal: FALSE
[17:44:51.046] - force: TRUE
[17:44:51.046] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:51.046] - queued futures: [n=3] TRUE, TRUE, TRUE
 - flush all
[17:44:51.046] - relayed: [n=3] TRUE, TRUE, TRUE
[17:44:51.046] - queued futures: [n=3] TRUE, TRUE, TRUE
[17:44:51.046] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.046] resolve() on list ... DONE
[17:44:51.047] result() for ClusterFuture ...
[17:44:51.047] - result already collected: FutureResult
[17:44:51.047] result() for ClusterFuture ... done
[17:44:51.047] result() for ClusterFuture ...
[17:44:51.047] - result already collected: FutureResult
[17:44:51.047] result() for ClusterFuture ... done
[17:44:51.047] result() for ClusterFuture ...
[17:44:51.047] - result already collected: FutureResult
[17:44:51.047] result() for ClusterFuture ... done
[17:44:51.047] result() for ClusterFuture ...
[17:44:51.047] - result already collected: FutureResult
[17:44:51.047] result() for ClusterFuture ... done
[17:44:51.048] result() for ClusterFuture ...
[17:44:51.048] - result already collected: FutureResult
[17:44:51.048] result() for ClusterFuture ... done
[17:44:51.048] result() for ClusterFuture ...
[17:44:51.048] - result already collected: FutureResult
[17:44:51.048] result() for ClusterFuture ... done
[17:44:51.048]  - Number of value chunks collected: 3
[17:44:51.048] Resolving 3 futures (chunks) ... DONE
[17:44:51.048] Reducing values from 3 chunks ...
[17:44:51.048]  - Number of values collected after concatenation: 5
[17:44:51.048]  - Number of values expected: 5
[17:44:51.048] Reverse index remapping (attribute 'ordering'): [n = 5] 4, 5, 2, 3, 1
[17:44:51.049] Reducing values from 3 chunks ... DONE
[17:44:51.049] future_mapply() ... DONE
[17:44:51.049] future_mapply() ...
[17:44:51.053] Number of chunks: 2
[17:44:51.053] getGlobalsAndPackagesXApply() ...
[17:44:51.053]  - future.globals: TRUE
[17:44:51.053] getGlobalsAndPackages() ...
[17:44:51.053] Searching for globals...
[17:44:51.054] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:51.054] Searching for globals ... DONE
[17:44:51.054] Resolving globals: FALSE
[17:44:51.055] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:51.055] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:51.055] - globals: [1] ‘FUN’
[17:44:51.055] 
[17:44:51.055] getGlobalsAndPackages() ... DONE
[17:44:51.056]  - globals found/used: [n=1] ‘FUN’
[17:44:51.056]  - needed namespaces: [n=0] 
[17:44:51.056] Finding globals ... DONE
[17:44:51.056] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.056] List of 2
[17:44:51.056]  $ ...future.FUN:function (C, k)  
[17:44:51.056]  $ MoreArgs     : list()
[17:44:51.056]  - attr(*, "where")=List of 2
[17:44:51.056]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.056]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.056]  - attr(*, "resolved")= logi FALSE
[17:44:51.056]  - attr(*, "total_size")= num NA
[17:44:51.058] Packages to be attached in all futures: [n=0] 
[17:44:51.058] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.059] Number of futures (= number of chunks): 2
[17:44:51.059] Launching 2 futures (chunks) ...
[17:44:51.059] Chunk #1 of 2 ...
[17:44:51.059]  - Finding globals in '...' for chunk #1 ...
[17:44:51.059] getGlobalsAndPackages() ...
[17:44:51.059] Searching for globals...
[17:44:51.059] 
[17:44:51.060] Searching for globals ... DONE
[17:44:51.060] - globals: [0] <none>
[17:44:51.060] getGlobalsAndPackages() ... DONE
[17:44:51.060]    + additional globals found: [n=0] 
[17:44:51.060]    + additional namespaces needed: [n=0] 
[17:44:51.060]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.060]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.060]  - seeds: <none>
[17:44:51.060]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.060] getGlobalsAndPackages() ...
[17:44:51.060] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.061] Resolving globals: FALSE
[17:44:51.061] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:51.061] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:51.062] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.062] 
[17:44:51.062] getGlobalsAndPackages() ... DONE
[17:44:51.062] run() for ‘Future’ ...
[17:44:51.062] - state: ‘created’
[17:44:51.062] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.076]   - Field: ‘node’
[17:44:51.076]   - Field: ‘label’
[17:44:51.076]   - Field: ‘local’
[17:44:51.076]   - Field: ‘owner’
[17:44:51.077]   - Field: ‘envir’
[17:44:51.077]   - Field: ‘workers’
[17:44:51.077]   - Field: ‘packages’
[17:44:51.077]   - Field: ‘gc’
[17:44:51.077]   - Field: ‘conditions’
[17:44:51.077]   - Field: ‘persistent’
[17:44:51.077]   - Field: ‘expr’
[17:44:51.077]   - Field: ‘uuid’
[17:44:51.077]   - Field: ‘seed’
[17:44:51.077]   - Field: ‘version’
[17:44:51.077]   - Field: ‘result’
[17:44:51.078]   - Field: ‘asynchronous’
[17:44:51.078]   - Field: ‘calls’
[17:44:51.078]   - Field: ‘globals’
[17:44:51.078]   - Field: ‘stdout’
[17:44:51.078]   - Field: ‘earlySignal’
[17:44:51.078]   - Field: ‘lazy’
[17:44:51.078]   - Field: ‘state’
[17:44:51.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.078] - Launch lazy future ...
[17:44:51.079] Packages needed by the future expression (n = 0): <none>
[17:44:51.079] Packages needed by future strategies (n = 0): <none>
[17:44:51.079] {
[17:44:51.079]     {
[17:44:51.079]         {
[17:44:51.079]             ...future.startTime <- base::Sys.time()
[17:44:51.079]             {
[17:44:51.079]                 {
[17:44:51.079]                   {
[17:44:51.079]                     {
[17:44:51.079]                       base::local({
[17:44:51.079]                         has_future <- base::requireNamespace("future", 
[17:44:51.079]                           quietly = TRUE)
[17:44:51.079]                         if (has_future) {
[17:44:51.079]                           ns <- base::getNamespace("future")
[17:44:51.079]                           version <- ns[[".package"]][["version"]]
[17:44:51.079]                           if (is.null(version)) 
[17:44:51.079]                             version <- utils::packageVersion("future")
[17:44:51.079]                         }
[17:44:51.079]                         else {
[17:44:51.079]                           version <- NULL
[17:44:51.079]                         }
[17:44:51.079]                         if (!has_future || version < "1.8.0") {
[17:44:51.079]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.079]                             "", base::R.version$version.string), 
[17:44:51.079]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.079]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.079]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.079]                               "release", "version")], collapse = " "), 
[17:44:51.079]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.079]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.079]                             info)
[17:44:51.079]                           info <- base::paste(info, collapse = "; ")
[17:44:51.079]                           if (!has_future) {
[17:44:51.079]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.079]                               info)
[17:44:51.079]                           }
[17:44:51.079]                           else {
[17:44:51.079]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.079]                               info, version)
[17:44:51.079]                           }
[17:44:51.079]                           base::stop(msg)
[17:44:51.079]                         }
[17:44:51.079]                       })
[17:44:51.079]                     }
[17:44:51.079]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.079]                     base::options(mc.cores = 1L)
[17:44:51.079]                   }
[17:44:51.079]                   ...future.strategy.old <- future::plan("list")
[17:44:51.079]                   options(future.plan = NULL)
[17:44:51.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.079]                 }
[17:44:51.079]                 ...future.workdir <- getwd()
[17:44:51.079]             }
[17:44:51.079]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.079]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.079]         }
[17:44:51.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.079]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.079]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.079]             base::names(...future.oldOptions))
[17:44:51.079]     }
[17:44:51.079]     if (FALSE) {
[17:44:51.079]     }
[17:44:51.079]     else {
[17:44:51.079]         if (TRUE) {
[17:44:51.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.079]                 open = "w")
[17:44:51.079]         }
[17:44:51.079]         else {
[17:44:51.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.079]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.079]         }
[17:44:51.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.079]             base::sink(type = "output", split = FALSE)
[17:44:51.079]             base::close(...future.stdout)
[17:44:51.079]         }, add = TRUE)
[17:44:51.079]     }
[17:44:51.079]     ...future.frame <- base::sys.nframe()
[17:44:51.079]     ...future.conditions <- base::list()
[17:44:51.079]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.079]     if (FALSE) {
[17:44:51.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.079]     }
[17:44:51.079]     ...future.result <- base::tryCatch({
[17:44:51.079]         base::withCallingHandlers({
[17:44:51.079]             ...future.value <- base::withVisible(base::local({
[17:44:51.079]                 ...future.makeSendCondition <- base::local({
[17:44:51.079]                   sendCondition <- NULL
[17:44:51.079]                   function(frame = 1L) {
[17:44:51.079]                     if (is.function(sendCondition)) 
[17:44:51.079]                       return(sendCondition)
[17:44:51.079]                     ns <- getNamespace("parallel")
[17:44:51.079]                     if (exists("sendData", mode = "function", 
[17:44:51.079]                       envir = ns)) {
[17:44:51.079]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.079]                         envir = ns)
[17:44:51.079]                       envir <- sys.frame(frame)
[17:44:51.079]                       master <- NULL
[17:44:51.079]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.079]                         !identical(envir, emptyenv())) {
[17:44:51.079]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.079]                           inherits = FALSE)) {
[17:44:51.079]                           master <- get("master", mode = "list", 
[17:44:51.079]                             envir = envir, inherits = FALSE)
[17:44:51.079]                           if (inherits(master, c("SOCKnode", 
[17:44:51.079]                             "SOCK0node"))) {
[17:44:51.079]                             sendCondition <<- function(cond) {
[17:44:51.079]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.079]                                 success = TRUE)
[17:44:51.079]                               parallel_sendData(master, data)
[17:44:51.079]                             }
[17:44:51.079]                             return(sendCondition)
[17:44:51.079]                           }
[17:44:51.079]                         }
[17:44:51.079]                         frame <- frame + 1L
[17:44:51.079]                         envir <- sys.frame(frame)
[17:44:51.079]                       }
[17:44:51.079]                     }
[17:44:51.079]                     sendCondition <<- function(cond) NULL
[17:44:51.079]                   }
[17:44:51.079]                 })
[17:44:51.079]                 withCallingHandlers({
[17:44:51.079]                   {
[17:44:51.079]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.079]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.079]                       ...future.globals.maxSize)) {
[17:44:51.079]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.079]                       on.exit(options(oopts), add = TRUE)
[17:44:51.079]                     }
[17:44:51.079]                     {
[17:44:51.079]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.079]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.079]                         USE.NAMES = FALSE)
[17:44:51.079]                       do.call(mapply, args = args)
[17:44:51.079]                     }
[17:44:51.079]                   }
[17:44:51.079]                 }, immediateCondition = function(cond) {
[17:44:51.079]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.079]                   sendCondition(cond)
[17:44:51.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.079]                   {
[17:44:51.079]                     inherits <- base::inherits
[17:44:51.079]                     invokeRestart <- base::invokeRestart
[17:44:51.079]                     is.null <- base::is.null
[17:44:51.079]                     muffled <- FALSE
[17:44:51.079]                     if (inherits(cond, "message")) {
[17:44:51.079]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.079]                       if (muffled) 
[17:44:51.079]                         invokeRestart("muffleMessage")
[17:44:51.079]                     }
[17:44:51.079]                     else if (inherits(cond, "warning")) {
[17:44:51.079]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.079]                       if (muffled) 
[17:44:51.079]                         invokeRestart("muffleWarning")
[17:44:51.079]                     }
[17:44:51.079]                     else if (inherits(cond, "condition")) {
[17:44:51.079]                       if (!is.null(pattern)) {
[17:44:51.079]                         computeRestarts <- base::computeRestarts
[17:44:51.079]                         grepl <- base::grepl
[17:44:51.079]                         restarts <- computeRestarts(cond)
[17:44:51.079]                         for (restart in restarts) {
[17:44:51.079]                           name <- restart$name
[17:44:51.079]                           if (is.null(name)) 
[17:44:51.079]                             next
[17:44:51.079]                           if (!grepl(pattern, name)) 
[17:44:51.079]                             next
[17:44:51.079]                           invokeRestart(restart)
[17:44:51.079]                           muffled <- TRUE
[17:44:51.079]                           break
[17:44:51.079]                         }
[17:44:51.079]                       }
[17:44:51.079]                     }
[17:44:51.079]                     invisible(muffled)
[17:44:51.079]                   }
[17:44:51.079]                   muffleCondition(cond)
[17:44:51.079]                 })
[17:44:51.079]             }))
[17:44:51.079]             future::FutureResult(value = ...future.value$value, 
[17:44:51.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.079]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.079]                     ...future.globalenv.names))
[17:44:51.079]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.079]         }, condition = base::local({
[17:44:51.079]             c <- base::c
[17:44:51.079]             inherits <- base::inherits
[17:44:51.079]             invokeRestart <- base::invokeRestart
[17:44:51.079]             length <- base::length
[17:44:51.079]             list <- base::list
[17:44:51.079]             seq.int <- base::seq.int
[17:44:51.079]             signalCondition <- base::signalCondition
[17:44:51.079]             sys.calls <- base::sys.calls
[17:44:51.079]             `[[` <- base::`[[`
[17:44:51.079]             `+` <- base::`+`
[17:44:51.079]             `<<-` <- base::`<<-`
[17:44:51.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.079]                   3L)]
[17:44:51.079]             }
[17:44:51.079]             function(cond) {
[17:44:51.079]                 is_error <- inherits(cond, "error")
[17:44:51.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.079]                   NULL)
[17:44:51.079]                 if (is_error) {
[17:44:51.079]                   sessionInformation <- function() {
[17:44:51.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.079]                       search = base::search(), system = base::Sys.info())
[17:44:51.079]                   }
[17:44:51.079]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.079]                     cond$call), session = sessionInformation(), 
[17:44:51.079]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.079]                   signalCondition(cond)
[17:44:51.079]                 }
[17:44:51.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.079]                 "immediateCondition"))) {
[17:44:51.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.079]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.079]                   if (TRUE && !signal) {
[17:44:51.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.079]                     {
[17:44:51.079]                       inherits <- base::inherits
[17:44:51.079]                       invokeRestart <- base::invokeRestart
[17:44:51.079]                       is.null <- base::is.null
[17:44:51.079]                       muffled <- FALSE
[17:44:51.079]                       if (inherits(cond, "message")) {
[17:44:51.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.079]                         if (muffled) 
[17:44:51.079]                           invokeRestart("muffleMessage")
[17:44:51.079]                       }
[17:44:51.079]                       else if (inherits(cond, "warning")) {
[17:44:51.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.079]                         if (muffled) 
[17:44:51.079]                           invokeRestart("muffleWarning")
[17:44:51.079]                       }
[17:44:51.079]                       else if (inherits(cond, "condition")) {
[17:44:51.079]                         if (!is.null(pattern)) {
[17:44:51.079]                           computeRestarts <- base::computeRestarts
[17:44:51.079]                           grepl <- base::grepl
[17:44:51.079]                           restarts <- computeRestarts(cond)
[17:44:51.079]                           for (restart in restarts) {
[17:44:51.079]                             name <- restart$name
[17:44:51.079]                             if (is.null(name)) 
[17:44:51.079]                               next
[17:44:51.079]                             if (!grepl(pattern, name)) 
[17:44:51.079]                               next
[17:44:51.079]                             invokeRestart(restart)
[17:44:51.079]                             muffled <- TRUE
[17:44:51.079]                             break
[17:44:51.079]                           }
[17:44:51.079]                         }
[17:44:51.079]                       }
[17:44:51.079]                       invisible(muffled)
[17:44:51.079]                     }
[17:44:51.079]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.079]                   }
[17:44:51.079]                 }
[17:44:51.079]                 else {
[17:44:51.079]                   if (TRUE) {
[17:44:51.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.079]                     {
[17:44:51.079]                       inherits <- base::inherits
[17:44:51.079]                       invokeRestart <- base::invokeRestart
[17:44:51.079]                       is.null <- base::is.null
[17:44:51.079]                       muffled <- FALSE
[17:44:51.079]                       if (inherits(cond, "message")) {
[17:44:51.079]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.079]                         if (muffled) 
[17:44:51.079]                           invokeRestart("muffleMessage")
[17:44:51.079]                       }
[17:44:51.079]                       else if (inherits(cond, "warning")) {
[17:44:51.079]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.079]                         if (muffled) 
[17:44:51.079]                           invokeRestart("muffleWarning")
[17:44:51.079]                       }
[17:44:51.079]                       else if (inherits(cond, "condition")) {
[17:44:51.079]                         if (!is.null(pattern)) {
[17:44:51.079]                           computeRestarts <- base::computeRestarts
[17:44:51.079]                           grepl <- base::grepl
[17:44:51.079]                           restarts <- computeRestarts(cond)
[17:44:51.079]                           for (restart in restarts) {
[17:44:51.079]                             name <- restart$name
[17:44:51.079]                             if (is.null(name)) 
[17:44:51.079]                               next
[17:44:51.079]                             if (!grepl(pattern, name)) 
[17:44:51.079]                               next
[17:44:51.079]                             invokeRestart(restart)
[17:44:51.079]                             muffled <- TRUE
[17:44:51.079]                             break
[17:44:51.079]                           }
[17:44:51.079]                         }
[17:44:51.079]                       }
[17:44:51.079]                       invisible(muffled)
[17:44:51.079]                     }
[17:44:51.079]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.079]                   }
[17:44:51.079]                 }
[17:44:51.079]             }
[17:44:51.079]         }))
[17:44:51.079]     }, error = function(ex) {
[17:44:51.079]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.079]                 ...future.rng), started = ...future.startTime, 
[17:44:51.079]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.079]             version = "1.8"), class = "FutureResult")
[17:44:51.079]     }, finally = {
[17:44:51.079]         if (!identical(...future.workdir, getwd())) 
[17:44:51.079]             setwd(...future.workdir)
[17:44:51.079]         {
[17:44:51.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.079]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.079]             }
[17:44:51.079]             base::options(...future.oldOptions)
[17:44:51.079]             if (.Platform$OS.type == "windows") {
[17:44:51.079]                 old_names <- names(...future.oldEnvVars)
[17:44:51.079]                 envs <- base::Sys.getenv()
[17:44:51.079]                 names <- names(envs)
[17:44:51.079]                 common <- intersect(names, old_names)
[17:44:51.079]                 added <- setdiff(names, old_names)
[17:44:51.079]                 removed <- setdiff(old_names, names)
[17:44:51.079]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.079]                   envs[common]]
[17:44:51.079]                 NAMES <- toupper(changed)
[17:44:51.079]                 args <- list()
[17:44:51.079]                 for (kk in seq_along(NAMES)) {
[17:44:51.079]                   name <- changed[[kk]]
[17:44:51.079]                   NAME <- NAMES[[kk]]
[17:44:51.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.079]                     next
[17:44:51.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.079]                 }
[17:44:51.079]                 NAMES <- toupper(added)
[17:44:51.079]                 for (kk in seq_along(NAMES)) {
[17:44:51.079]                   name <- added[[kk]]
[17:44:51.079]                   NAME <- NAMES[[kk]]
[17:44:51.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.079]                     next
[17:44:51.079]                   args[[name]] <- ""
[17:44:51.079]                 }
[17:44:51.079]                 NAMES <- toupper(removed)
[17:44:51.079]                 for (kk in seq_along(NAMES)) {
[17:44:51.079]                   name <- removed[[kk]]
[17:44:51.079]                   NAME <- NAMES[[kk]]
[17:44:51.079]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.079]                     next
[17:44:51.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.079]                 }
[17:44:51.079]                 if (length(args) > 0) 
[17:44:51.079]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.079]             }
[17:44:51.079]             else {
[17:44:51.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.079]             }
[17:44:51.079]             {
[17:44:51.079]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.079]                   0L) {
[17:44:51.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.079]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.079]                   base::options(opts)
[17:44:51.079]                 }
[17:44:51.079]                 {
[17:44:51.079]                   {
[17:44:51.079]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.079]                     NULL
[17:44:51.079]                   }
[17:44:51.079]                   options(future.plan = NULL)
[17:44:51.079]                   if (is.na(NA_character_)) 
[17:44:51.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.079]                     .init = FALSE)
[17:44:51.079]                 }
[17:44:51.079]             }
[17:44:51.079]         }
[17:44:51.079]     })
[17:44:51.079]     if (TRUE) {
[17:44:51.079]         base::sink(type = "output", split = FALSE)
[17:44:51.079]         if (TRUE) {
[17:44:51.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.079]         }
[17:44:51.079]         else {
[17:44:51.079]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.079]         }
[17:44:51.079]         base::close(...future.stdout)
[17:44:51.079]         ...future.stdout <- NULL
[17:44:51.079]     }
[17:44:51.079]     ...future.result$conditions <- ...future.conditions
[17:44:51.079]     ...future.result$finished <- base::Sys.time()
[17:44:51.079]     ...future.result
[17:44:51.079] }
[17:44:51.082] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:51.082] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:51.082] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:51.082] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.083] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.083] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:51.083] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:51.083] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.084] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.084] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.084] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.084] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:51.085] MultisessionFuture started
[17:44:51.085] - Launch lazy future ... done
[17:44:51.085] run() for ‘MultisessionFuture’ ... done
[17:44:51.085] Created future:
[17:44:51.085] MultisessionFuture:
[17:44:51.085] Label: ‘future_.mapply-1’
[17:44:51.085] Expression:
[17:44:51.085] {
[17:44:51.085]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.085]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.085]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.085]         on.exit(options(oopts), add = TRUE)
[17:44:51.085]     }
[17:44:51.085]     {
[17:44:51.085]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.085]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.085]         do.call(mapply, args = args)
[17:44:51.085]     }
[17:44:51.085] }
[17:44:51.085] Lazy evaluation: FALSE
[17:44:51.085] Asynchronous evaluation: TRUE
[17:44:51.085] Local evaluation: TRUE
[17:44:51.085] Environment: R_GlobalEnv
[17:44:51.085] Capture standard output: TRUE
[17:44:51.085] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.085] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.085] Packages: <none>
[17:44:51.085] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.085] Resolved: FALSE
[17:44:51.085] Value: <not collected>
[17:44:51.085] Conditions captured: <none>
[17:44:51.085] Early signaling: FALSE
[17:44:51.085] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.085] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.096] Chunk #1 of 2 ... DONE
[17:44:51.096] Chunk #2 of 2 ...
[17:44:51.097]  - Finding globals in '...' for chunk #2 ...
[17:44:51.097] getGlobalsAndPackages() ...
[17:44:51.097] Searching for globals...
[17:44:51.097] 
[17:44:51.097] Searching for globals ... DONE
[17:44:51.097] - globals: [0] <none>
[17:44:51.097] getGlobalsAndPackages() ... DONE
[17:44:51.097]    + additional globals found: [n=0] 
[17:44:51.098]    + additional namespaces needed: [n=0] 
[17:44:51.098]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.098]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.098]  - seeds: <none>
[17:44:51.098]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.098] getGlobalsAndPackages() ...
[17:44:51.098] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.098] Resolving globals: FALSE
[17:44:51.099] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:51.099] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:51.099] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.099] 
[17:44:51.099] getGlobalsAndPackages() ... DONE
[17:44:51.100] run() for ‘Future’ ...
[17:44:51.100] - state: ‘created’
[17:44:51.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.113]   - Field: ‘node’
[17:44:51.113]   - Field: ‘label’
[17:44:51.113]   - Field: ‘local’
[17:44:51.114]   - Field: ‘owner’
[17:44:51.114]   - Field: ‘envir’
[17:44:51.114]   - Field: ‘workers’
[17:44:51.114]   - Field: ‘packages’
[17:44:51.114]   - Field: ‘gc’
[17:44:51.114]   - Field: ‘conditions’
[17:44:51.114]   - Field: ‘persistent’
[17:44:51.114]   - Field: ‘expr’
[17:44:51.114]   - Field: ‘uuid’
[17:44:51.114]   - Field: ‘seed’
[17:44:51.114]   - Field: ‘version’
[17:44:51.115]   - Field: ‘result’
[17:44:51.115]   - Field: ‘asynchronous’
[17:44:51.115]   - Field: ‘calls’
[17:44:51.115]   - Field: ‘globals’
[17:44:51.115]   - Field: ‘stdout’
[17:44:51.115]   - Field: ‘earlySignal’
[17:44:51.115]   - Field: ‘lazy’
[17:44:51.115]   - Field: ‘state’
[17:44:51.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.115] - Launch lazy future ...
[17:44:51.116] Packages needed by the future expression (n = 0): <none>
[17:44:51.116] Packages needed by future strategies (n = 0): <none>
[17:44:51.116] {
[17:44:51.116]     {
[17:44:51.116]         {
[17:44:51.116]             ...future.startTime <- base::Sys.time()
[17:44:51.116]             {
[17:44:51.116]                 {
[17:44:51.116]                   {
[17:44:51.116]                     {
[17:44:51.116]                       base::local({
[17:44:51.116]                         has_future <- base::requireNamespace("future", 
[17:44:51.116]                           quietly = TRUE)
[17:44:51.116]                         if (has_future) {
[17:44:51.116]                           ns <- base::getNamespace("future")
[17:44:51.116]                           version <- ns[[".package"]][["version"]]
[17:44:51.116]                           if (is.null(version)) 
[17:44:51.116]                             version <- utils::packageVersion("future")
[17:44:51.116]                         }
[17:44:51.116]                         else {
[17:44:51.116]                           version <- NULL
[17:44:51.116]                         }
[17:44:51.116]                         if (!has_future || version < "1.8.0") {
[17:44:51.116]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.116]                             "", base::R.version$version.string), 
[17:44:51.116]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.116]                               "release", "version")], collapse = " "), 
[17:44:51.116]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.116]                             info)
[17:44:51.116]                           info <- base::paste(info, collapse = "; ")
[17:44:51.116]                           if (!has_future) {
[17:44:51.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.116]                               info)
[17:44:51.116]                           }
[17:44:51.116]                           else {
[17:44:51.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.116]                               info, version)
[17:44:51.116]                           }
[17:44:51.116]                           base::stop(msg)
[17:44:51.116]                         }
[17:44:51.116]                       })
[17:44:51.116]                     }
[17:44:51.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.116]                     base::options(mc.cores = 1L)
[17:44:51.116]                   }
[17:44:51.116]                   ...future.strategy.old <- future::plan("list")
[17:44:51.116]                   options(future.plan = NULL)
[17:44:51.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.116]                 }
[17:44:51.116]                 ...future.workdir <- getwd()
[17:44:51.116]             }
[17:44:51.116]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.116]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.116]         }
[17:44:51.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.116]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.116]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.116]             base::names(...future.oldOptions))
[17:44:51.116]     }
[17:44:51.116]     if (FALSE) {
[17:44:51.116]     }
[17:44:51.116]     else {
[17:44:51.116]         if (TRUE) {
[17:44:51.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.116]                 open = "w")
[17:44:51.116]         }
[17:44:51.116]         else {
[17:44:51.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.116]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.116]         }
[17:44:51.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.116]             base::sink(type = "output", split = FALSE)
[17:44:51.116]             base::close(...future.stdout)
[17:44:51.116]         }, add = TRUE)
[17:44:51.116]     }
[17:44:51.116]     ...future.frame <- base::sys.nframe()
[17:44:51.116]     ...future.conditions <- base::list()
[17:44:51.116]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.116]     if (FALSE) {
[17:44:51.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.116]     }
[17:44:51.116]     ...future.result <- base::tryCatch({
[17:44:51.116]         base::withCallingHandlers({
[17:44:51.116]             ...future.value <- base::withVisible(base::local({
[17:44:51.116]                 ...future.makeSendCondition <- base::local({
[17:44:51.116]                   sendCondition <- NULL
[17:44:51.116]                   function(frame = 1L) {
[17:44:51.116]                     if (is.function(sendCondition)) 
[17:44:51.116]                       return(sendCondition)
[17:44:51.116]                     ns <- getNamespace("parallel")
[17:44:51.116]                     if (exists("sendData", mode = "function", 
[17:44:51.116]                       envir = ns)) {
[17:44:51.116]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.116]                         envir = ns)
[17:44:51.116]                       envir <- sys.frame(frame)
[17:44:51.116]                       master <- NULL
[17:44:51.116]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.116]                         !identical(envir, emptyenv())) {
[17:44:51.116]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.116]                           inherits = FALSE)) {
[17:44:51.116]                           master <- get("master", mode = "list", 
[17:44:51.116]                             envir = envir, inherits = FALSE)
[17:44:51.116]                           if (inherits(master, c("SOCKnode", 
[17:44:51.116]                             "SOCK0node"))) {
[17:44:51.116]                             sendCondition <<- function(cond) {
[17:44:51.116]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.116]                                 success = TRUE)
[17:44:51.116]                               parallel_sendData(master, data)
[17:44:51.116]                             }
[17:44:51.116]                             return(sendCondition)
[17:44:51.116]                           }
[17:44:51.116]                         }
[17:44:51.116]                         frame <- frame + 1L
[17:44:51.116]                         envir <- sys.frame(frame)
[17:44:51.116]                       }
[17:44:51.116]                     }
[17:44:51.116]                     sendCondition <<- function(cond) NULL
[17:44:51.116]                   }
[17:44:51.116]                 })
[17:44:51.116]                 withCallingHandlers({
[17:44:51.116]                   {
[17:44:51.116]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.116]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.116]                       ...future.globals.maxSize)) {
[17:44:51.116]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.116]                       on.exit(options(oopts), add = TRUE)
[17:44:51.116]                     }
[17:44:51.116]                     {
[17:44:51.116]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.116]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.116]                         USE.NAMES = FALSE)
[17:44:51.116]                       do.call(mapply, args = args)
[17:44:51.116]                     }
[17:44:51.116]                   }
[17:44:51.116]                 }, immediateCondition = function(cond) {
[17:44:51.116]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.116]                   sendCondition(cond)
[17:44:51.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.116]                   {
[17:44:51.116]                     inherits <- base::inherits
[17:44:51.116]                     invokeRestart <- base::invokeRestart
[17:44:51.116]                     is.null <- base::is.null
[17:44:51.116]                     muffled <- FALSE
[17:44:51.116]                     if (inherits(cond, "message")) {
[17:44:51.116]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.116]                       if (muffled) 
[17:44:51.116]                         invokeRestart("muffleMessage")
[17:44:51.116]                     }
[17:44:51.116]                     else if (inherits(cond, "warning")) {
[17:44:51.116]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.116]                       if (muffled) 
[17:44:51.116]                         invokeRestart("muffleWarning")
[17:44:51.116]                     }
[17:44:51.116]                     else if (inherits(cond, "condition")) {
[17:44:51.116]                       if (!is.null(pattern)) {
[17:44:51.116]                         computeRestarts <- base::computeRestarts
[17:44:51.116]                         grepl <- base::grepl
[17:44:51.116]                         restarts <- computeRestarts(cond)
[17:44:51.116]                         for (restart in restarts) {
[17:44:51.116]                           name <- restart$name
[17:44:51.116]                           if (is.null(name)) 
[17:44:51.116]                             next
[17:44:51.116]                           if (!grepl(pattern, name)) 
[17:44:51.116]                             next
[17:44:51.116]                           invokeRestart(restart)
[17:44:51.116]                           muffled <- TRUE
[17:44:51.116]                           break
[17:44:51.116]                         }
[17:44:51.116]                       }
[17:44:51.116]                     }
[17:44:51.116]                     invisible(muffled)
[17:44:51.116]                   }
[17:44:51.116]                   muffleCondition(cond)
[17:44:51.116]                 })
[17:44:51.116]             }))
[17:44:51.116]             future::FutureResult(value = ...future.value$value, 
[17:44:51.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.116]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.116]                     ...future.globalenv.names))
[17:44:51.116]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.116]         }, condition = base::local({
[17:44:51.116]             c <- base::c
[17:44:51.116]             inherits <- base::inherits
[17:44:51.116]             invokeRestart <- base::invokeRestart
[17:44:51.116]             length <- base::length
[17:44:51.116]             list <- base::list
[17:44:51.116]             seq.int <- base::seq.int
[17:44:51.116]             signalCondition <- base::signalCondition
[17:44:51.116]             sys.calls <- base::sys.calls
[17:44:51.116]             `[[` <- base::`[[`
[17:44:51.116]             `+` <- base::`+`
[17:44:51.116]             `<<-` <- base::`<<-`
[17:44:51.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.116]                   3L)]
[17:44:51.116]             }
[17:44:51.116]             function(cond) {
[17:44:51.116]                 is_error <- inherits(cond, "error")
[17:44:51.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.116]                   NULL)
[17:44:51.116]                 if (is_error) {
[17:44:51.116]                   sessionInformation <- function() {
[17:44:51.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.116]                       search = base::search(), system = base::Sys.info())
[17:44:51.116]                   }
[17:44:51.116]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.116]                     cond$call), session = sessionInformation(), 
[17:44:51.116]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.116]                   signalCondition(cond)
[17:44:51.116]                 }
[17:44:51.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.116]                 "immediateCondition"))) {
[17:44:51.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.116]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.116]                   if (TRUE && !signal) {
[17:44:51.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.116]                     {
[17:44:51.116]                       inherits <- base::inherits
[17:44:51.116]                       invokeRestart <- base::invokeRestart
[17:44:51.116]                       is.null <- base::is.null
[17:44:51.116]                       muffled <- FALSE
[17:44:51.116]                       if (inherits(cond, "message")) {
[17:44:51.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.116]                         if (muffled) 
[17:44:51.116]                           invokeRestart("muffleMessage")
[17:44:51.116]                       }
[17:44:51.116]                       else if (inherits(cond, "warning")) {
[17:44:51.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.116]                         if (muffled) 
[17:44:51.116]                           invokeRestart("muffleWarning")
[17:44:51.116]                       }
[17:44:51.116]                       else if (inherits(cond, "condition")) {
[17:44:51.116]                         if (!is.null(pattern)) {
[17:44:51.116]                           computeRestarts <- base::computeRestarts
[17:44:51.116]                           grepl <- base::grepl
[17:44:51.116]                           restarts <- computeRestarts(cond)
[17:44:51.116]                           for (restart in restarts) {
[17:44:51.116]                             name <- restart$name
[17:44:51.116]                             if (is.null(name)) 
[17:44:51.116]                               next
[17:44:51.116]                             if (!grepl(pattern, name)) 
[17:44:51.116]                               next
[17:44:51.116]                             invokeRestart(restart)
[17:44:51.116]                             muffled <- TRUE
[17:44:51.116]                             break
[17:44:51.116]                           }
[17:44:51.116]                         }
[17:44:51.116]                       }
[17:44:51.116]                       invisible(muffled)
[17:44:51.116]                     }
[17:44:51.116]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.116]                   }
[17:44:51.116]                 }
[17:44:51.116]                 else {
[17:44:51.116]                   if (TRUE) {
[17:44:51.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.116]                     {
[17:44:51.116]                       inherits <- base::inherits
[17:44:51.116]                       invokeRestart <- base::invokeRestart
[17:44:51.116]                       is.null <- base::is.null
[17:44:51.116]                       muffled <- FALSE
[17:44:51.116]                       if (inherits(cond, "message")) {
[17:44:51.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.116]                         if (muffled) 
[17:44:51.116]                           invokeRestart("muffleMessage")
[17:44:51.116]                       }
[17:44:51.116]                       else if (inherits(cond, "warning")) {
[17:44:51.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.116]                         if (muffled) 
[17:44:51.116]                           invokeRestart("muffleWarning")
[17:44:51.116]                       }
[17:44:51.116]                       else if (inherits(cond, "condition")) {
[17:44:51.116]                         if (!is.null(pattern)) {
[17:44:51.116]                           computeRestarts <- base::computeRestarts
[17:44:51.116]                           grepl <- base::grepl
[17:44:51.116]                           restarts <- computeRestarts(cond)
[17:44:51.116]                           for (restart in restarts) {
[17:44:51.116]                             name <- restart$name
[17:44:51.116]                             if (is.null(name)) 
[17:44:51.116]                               next
[17:44:51.116]                             if (!grepl(pattern, name)) 
[17:44:51.116]                               next
[17:44:51.116]                             invokeRestart(restart)
[17:44:51.116]                             muffled <- TRUE
[17:44:51.116]                             break
[17:44:51.116]                           }
[17:44:51.116]                         }
[17:44:51.116]                       }
[17:44:51.116]                       invisible(muffled)
[17:44:51.116]                     }
[17:44:51.116]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.116]                   }
[17:44:51.116]                 }
[17:44:51.116]             }
[17:44:51.116]         }))
[17:44:51.116]     }, error = function(ex) {
[17:44:51.116]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.116]                 ...future.rng), started = ...future.startTime, 
[17:44:51.116]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.116]             version = "1.8"), class = "FutureResult")
[17:44:51.116]     }, finally = {
[17:44:51.116]         if (!identical(...future.workdir, getwd())) 
[17:44:51.116]             setwd(...future.workdir)
[17:44:51.116]         {
[17:44:51.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.116]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.116]             }
[17:44:51.116]             base::options(...future.oldOptions)
[17:44:51.116]             if (.Platform$OS.type == "windows") {
[17:44:51.116]                 old_names <- names(...future.oldEnvVars)
[17:44:51.116]                 envs <- base::Sys.getenv()
[17:44:51.116]                 names <- names(envs)
[17:44:51.116]                 common <- intersect(names, old_names)
[17:44:51.116]                 added <- setdiff(names, old_names)
[17:44:51.116]                 removed <- setdiff(old_names, names)
[17:44:51.116]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.116]                   envs[common]]
[17:44:51.116]                 NAMES <- toupper(changed)
[17:44:51.116]                 args <- list()
[17:44:51.116]                 for (kk in seq_along(NAMES)) {
[17:44:51.116]                   name <- changed[[kk]]
[17:44:51.116]                   NAME <- NAMES[[kk]]
[17:44:51.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.116]                     next
[17:44:51.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.116]                 }
[17:44:51.116]                 NAMES <- toupper(added)
[17:44:51.116]                 for (kk in seq_along(NAMES)) {
[17:44:51.116]                   name <- added[[kk]]
[17:44:51.116]                   NAME <- NAMES[[kk]]
[17:44:51.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.116]                     next
[17:44:51.116]                   args[[name]] <- ""
[17:44:51.116]                 }
[17:44:51.116]                 NAMES <- toupper(removed)
[17:44:51.116]                 for (kk in seq_along(NAMES)) {
[17:44:51.116]                   name <- removed[[kk]]
[17:44:51.116]                   NAME <- NAMES[[kk]]
[17:44:51.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.116]                     next
[17:44:51.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.116]                 }
[17:44:51.116]                 if (length(args) > 0) 
[17:44:51.116]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.116]             }
[17:44:51.116]             else {
[17:44:51.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.116]             }
[17:44:51.116]             {
[17:44:51.116]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.116]                   0L) {
[17:44:51.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.116]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.116]                   base::options(opts)
[17:44:51.116]                 }
[17:44:51.116]                 {
[17:44:51.116]                   {
[17:44:51.116]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.116]                     NULL
[17:44:51.116]                   }
[17:44:51.116]                   options(future.plan = NULL)
[17:44:51.116]                   if (is.na(NA_character_)) 
[17:44:51.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.116]                     .init = FALSE)
[17:44:51.116]                 }
[17:44:51.116]             }
[17:44:51.116]         }
[17:44:51.116]     })
[17:44:51.116]     if (TRUE) {
[17:44:51.116]         base::sink(type = "output", split = FALSE)
[17:44:51.116]         if (TRUE) {
[17:44:51.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.116]         }
[17:44:51.116]         else {
[17:44:51.116]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.116]         }
[17:44:51.116]         base::close(...future.stdout)
[17:44:51.116]         ...future.stdout <- NULL
[17:44:51.116]     }
[17:44:51.116]     ...future.result$conditions <- ...future.conditions
[17:44:51.116]     ...future.result$finished <- base::Sys.time()
[17:44:51.116]     ...future.result
[17:44:51.116] }
[17:44:51.119] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:44:51.119] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:51.119] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:51.119] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:51.120] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.120] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:44:51.120] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:44:51.120] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:51.121] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.121] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.121] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.121] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:44:51.122] MultisessionFuture started
[17:44:51.122] - Launch lazy future ... done
[17:44:51.122] run() for ‘MultisessionFuture’ ... done
[17:44:51.122] Created future:
[17:44:51.122] MultisessionFuture:
[17:44:51.122] Label: ‘future_.mapply-2’
[17:44:51.122] Expression:
[17:44:51.122] {
[17:44:51.122]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.122]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.122]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.122]         on.exit(options(oopts), add = TRUE)
[17:44:51.122]     }
[17:44:51.122]     {
[17:44:51.122]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.122]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.122]         do.call(mapply, args = args)
[17:44:51.122]     }
[17:44:51.122] }
[17:44:51.122] Lazy evaluation: FALSE
[17:44:51.122] Asynchronous evaluation: TRUE
[17:44:51.122] Local evaluation: TRUE
[17:44:51.122] Environment: R_GlobalEnv
[17:44:51.122] Capture standard output: TRUE
[17:44:51.122] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.122] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.122] Packages: <none>
[17:44:51.122] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.122] Resolved: FALSE
[17:44:51.122] Value: <not collected>
[17:44:51.122] Conditions captured: <none>
[17:44:51.122] Early signaling: FALSE
[17:44:51.122] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.122] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.133] Chunk #2 of 2 ... DONE
[17:44:51.133] Launching 2 futures (chunks) ... DONE
[17:44:51.134] Resolving 2 futures (chunks) ...
[17:44:51.134] resolve() on list ...
[17:44:51.134]  recursive: 0
[17:44:51.134]  length: 2
[17:44:51.134] 
[17:44:51.135] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.135] - Validating connection of MultisessionFuture
[17:44:51.135] - received message: FutureResult
[17:44:51.135] - Received FutureResult
[17:44:51.135] - Erased future from FutureRegistry
[17:44:51.135] result() for ClusterFuture ...
[17:44:51.135] - result already collected: FutureResult
[17:44:51.135] result() for ClusterFuture ... done
[17:44:51.135] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.135] Future #1
[17:44:51.136] result() for ClusterFuture ...
[17:44:51.136] - result already collected: FutureResult
[17:44:51.136] result() for ClusterFuture ... done
[17:44:51.136] result() for ClusterFuture ...
[17:44:51.136] - result already collected: FutureResult
[17:44:51.136] result() for ClusterFuture ... done
[17:44:51.136] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.136] - nx: 2
[17:44:51.136] - relay: TRUE
[17:44:51.136] - stdout: TRUE
[17:44:51.136] - signal: TRUE
[17:44:51.137] - resignal: FALSE
[17:44:51.137] - force: TRUE
[17:44:51.137] - relayed: [n=2] FALSE, FALSE
[17:44:51.137] - queued futures: [n=2] FALSE, FALSE
[17:44:51.137]  - until=1
[17:44:51.137]  - relaying element #1
[17:44:51.137] result() for ClusterFuture ...
[17:44:51.137] - result already collected: FutureResult
[17:44:51.137] result() for ClusterFuture ... done
[17:44:51.137] result() for ClusterFuture ...
[17:44:51.137] - result already collected: FutureResult
[17:44:51.137] result() for ClusterFuture ... done
[17:44:51.138] result() for ClusterFuture ...
[17:44:51.138] - result already collected: FutureResult
[17:44:51.138] result() for ClusterFuture ... done
[17:44:51.138] result() for ClusterFuture ...
[17:44:51.138] - result already collected: FutureResult
[17:44:51.138] result() for ClusterFuture ... done
[17:44:51.138] - relayed: [n=2] TRUE, FALSE
[17:44:51.138] - queued futures: [n=2] TRUE, FALSE
[17:44:51.138] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.138]  length: 1 (resolved future 1)
[17:44:51.165] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.165] - Validating connection of MultisessionFuture
[17:44:51.165] - received message: FutureResult
[17:44:51.165] - Received FutureResult
[17:44:51.165] - Erased future from FutureRegistry
[17:44:51.165] result() for ClusterFuture ...
[17:44:51.166] - result already collected: FutureResult
[17:44:51.166] result() for ClusterFuture ... done
[17:44:51.166] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.166] Future #2
[17:44:51.166] result() for ClusterFuture ...
[17:44:51.166] - result already collected: FutureResult
[17:44:51.166] result() for ClusterFuture ... done
[17:44:51.166] result() for ClusterFuture ...
[17:44:51.166] - result already collected: FutureResult
[17:44:51.166] result() for ClusterFuture ... done
[17:44:51.167] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.167] - nx: 2
[17:44:51.167] - relay: TRUE
[17:44:51.167] - stdout: TRUE
[17:44:51.167] - signal: TRUE
[17:44:51.167] - resignal: FALSE
[17:44:51.167] - force: TRUE
[17:44:51.167] - relayed: [n=2] TRUE, FALSE
[17:44:51.167] - queued futures: [n=2] TRUE, FALSE
[17:44:51.167]  - until=2
[17:44:51.167]  - relaying element #2
[17:44:51.168] result() for ClusterFuture ...
[17:44:51.168] - result already collected: FutureResult
[17:44:51.168] result() for ClusterFuture ... done
[17:44:51.168] result() for ClusterFuture ...
[17:44:51.168] - result already collected: FutureResult
[17:44:51.168] result() for ClusterFuture ... done
[17:44:51.168] result() for ClusterFuture ...
[17:44:51.168] - result already collected: FutureResult
[17:44:51.168] result() for ClusterFuture ... done
[17:44:51.168] result() for ClusterFuture ...
[17:44:51.168] - result already collected: FutureResult
[17:44:51.168] result() for ClusterFuture ... done
[17:44:51.169] - relayed: [n=2] TRUE, TRUE
[17:44:51.169] - queued futures: [n=2] TRUE, TRUE
[17:44:51.169] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.169]  length: 0 (resolved future 2)
[17:44:51.169] Relaying remaining futures
[17:44:51.169] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.169] - nx: 2
[17:44:51.169] - relay: TRUE
[17:44:51.169] - stdout: TRUE
[17:44:51.169] - signal: TRUE
[17:44:51.169] - resignal: FALSE
[17:44:51.169] - force: TRUE
[17:44:51.170] - relayed: [n=2] TRUE, TRUE
[17:44:51.170] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.170] - relayed: [n=2] TRUE, TRUE
[17:44:51.170] - queued futures: [n=2] TRUE, TRUE
[17:44:51.170] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.170] resolve() on list ... DONE
[17:44:51.170] result() for ClusterFuture ...
[17:44:51.170] - result already collected: FutureResult
[17:44:51.170] result() for ClusterFuture ... done
[17:44:51.170] result() for ClusterFuture ...
[17:44:51.170] - result already collected: FutureResult
[17:44:51.171] result() for ClusterFuture ... done
[17:44:51.171] result() for ClusterFuture ...
[17:44:51.171] - result already collected: FutureResult
[17:44:51.171] result() for ClusterFuture ... done
[17:44:51.171] result() for ClusterFuture ...
[17:44:51.171] - result already collected: FutureResult
[17:44:51.171] result() for ClusterFuture ... done
[17:44:51.171]  - Number of value chunks collected: 2
[17:44:51.171] Resolving 2 futures (chunks) ... DONE
[17:44:51.171] Reducing values from 2 chunks ...
[17:44:51.172]  - Number of values collected after concatenation: 5
[17:44:51.172]  - Number of values expected: 5
[17:44:51.172] Reducing values from 2 chunks ... DONE
[17:44:51.172] future_mapply() ... DONE
[17:44:51.172] future_mapply() ...
[17:44:51.176] Number of chunks: 2
[17:44:51.176] Index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:51.176] getGlobalsAndPackagesXApply() ...
[17:44:51.176]  - future.globals: TRUE
[17:44:51.176] getGlobalsAndPackages() ...
[17:44:51.176] Searching for globals...
[17:44:51.177] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:51.178] Searching for globals ... DONE
[17:44:51.178] Resolving globals: FALSE
[17:44:51.178] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:51.178] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:51.178] - globals: [1] ‘FUN’
[17:44:51.179] 
[17:44:51.179] getGlobalsAndPackages() ... DONE
[17:44:51.179]  - globals found/used: [n=1] ‘FUN’
[17:44:51.179]  - needed namespaces: [n=0] 
[17:44:51.179] Finding globals ... DONE
[17:44:51.179] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.179] List of 2
[17:44:51.179]  $ ...future.FUN:function (C, k)  
[17:44:51.179]  $ MoreArgs     : NULL
[17:44:51.179]  - attr(*, "where")=List of 2
[17:44:51.179]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.179]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.179]  - attr(*, "resolved")= logi FALSE
[17:44:51.179]  - attr(*, "total_size")= num NA
[17:44:51.182] Packages to be attached in all futures: [n=0] 
[17:44:51.182] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.182] Number of futures (= number of chunks): 2
[17:44:51.182] Launching 2 futures (chunks) ...
[17:44:51.182] Chunk #1 of 2 ...
[17:44:51.182]  - Finding globals in '...' for chunk #1 ...
[17:44:51.182] getGlobalsAndPackages() ...
[17:44:51.182] Searching for globals...
[17:44:51.183] 
[17:44:51.183] Searching for globals ... DONE
[17:44:51.183] - globals: [0] <none>
[17:44:51.183] getGlobalsAndPackages() ... DONE
[17:44:51.183]    + additional globals found: [n=0] 
[17:44:51.183]    + additional namespaces needed: [n=0] 
[17:44:51.183]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.183]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.184]  - seeds: <none>
[17:44:51.184]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.184] getGlobalsAndPackages() ...
[17:44:51.184] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.184] Resolving globals: FALSE
[17:44:51.184] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:51.185] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:51.185] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.185] 
[17:44:51.185] getGlobalsAndPackages() ... DONE
[17:44:51.185] run() for ‘Future’ ...
[17:44:51.186] - state: ‘created’
[17:44:51.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.201]   - Field: ‘node’
[17:44:51.201]   - Field: ‘label’
[17:44:51.201]   - Field: ‘local’
[17:44:51.202]   - Field: ‘owner’
[17:44:51.202]   - Field: ‘envir’
[17:44:51.202]   - Field: ‘workers’
[17:44:51.202]   - Field: ‘packages’
[17:44:51.202]   - Field: ‘gc’
[17:44:51.202]   - Field: ‘conditions’
[17:44:51.202]   - Field: ‘persistent’
[17:44:51.202]   - Field: ‘expr’
[17:44:51.202]   - Field: ‘uuid’
[17:44:51.202]   - Field: ‘seed’
[17:44:51.202]   - Field: ‘version’
[17:44:51.202]   - Field: ‘result’
[17:44:51.203]   - Field: ‘asynchronous’
[17:44:51.203]   - Field: ‘calls’
[17:44:51.203]   - Field: ‘globals’
[17:44:51.203]   - Field: ‘stdout’
[17:44:51.203]   - Field: ‘earlySignal’
[17:44:51.203]   - Field: ‘lazy’
[17:44:51.203]   - Field: ‘state’
[17:44:51.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.203] - Launch lazy future ...
[17:44:51.204] Packages needed by the future expression (n = 0): <none>
[17:44:51.204] Packages needed by future strategies (n = 0): <none>
[17:44:51.204] {
[17:44:51.204]     {
[17:44:51.204]         {
[17:44:51.204]             ...future.startTime <- base::Sys.time()
[17:44:51.204]             {
[17:44:51.204]                 {
[17:44:51.204]                   {
[17:44:51.204]                     {
[17:44:51.204]                       base::local({
[17:44:51.204]                         has_future <- base::requireNamespace("future", 
[17:44:51.204]                           quietly = TRUE)
[17:44:51.204]                         if (has_future) {
[17:44:51.204]                           ns <- base::getNamespace("future")
[17:44:51.204]                           version <- ns[[".package"]][["version"]]
[17:44:51.204]                           if (is.null(version)) 
[17:44:51.204]                             version <- utils::packageVersion("future")
[17:44:51.204]                         }
[17:44:51.204]                         else {
[17:44:51.204]                           version <- NULL
[17:44:51.204]                         }
[17:44:51.204]                         if (!has_future || version < "1.8.0") {
[17:44:51.204]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.204]                             "", base::R.version$version.string), 
[17:44:51.204]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.204]                               "release", "version")], collapse = " "), 
[17:44:51.204]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.204]                             info)
[17:44:51.204]                           info <- base::paste(info, collapse = "; ")
[17:44:51.204]                           if (!has_future) {
[17:44:51.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.204]                               info)
[17:44:51.204]                           }
[17:44:51.204]                           else {
[17:44:51.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.204]                               info, version)
[17:44:51.204]                           }
[17:44:51.204]                           base::stop(msg)
[17:44:51.204]                         }
[17:44:51.204]                       })
[17:44:51.204]                     }
[17:44:51.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.204]                     base::options(mc.cores = 1L)
[17:44:51.204]                   }
[17:44:51.204]                   ...future.strategy.old <- future::plan("list")
[17:44:51.204]                   options(future.plan = NULL)
[17:44:51.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.204]                 }
[17:44:51.204]                 ...future.workdir <- getwd()
[17:44:51.204]             }
[17:44:51.204]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.204]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.204]         }
[17:44:51.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.204]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.204]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.204]             base::names(...future.oldOptions))
[17:44:51.204]     }
[17:44:51.204]     if (FALSE) {
[17:44:51.204]     }
[17:44:51.204]     else {
[17:44:51.204]         if (TRUE) {
[17:44:51.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.204]                 open = "w")
[17:44:51.204]         }
[17:44:51.204]         else {
[17:44:51.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.204]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.204]         }
[17:44:51.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.204]             base::sink(type = "output", split = FALSE)
[17:44:51.204]             base::close(...future.stdout)
[17:44:51.204]         }, add = TRUE)
[17:44:51.204]     }
[17:44:51.204]     ...future.frame <- base::sys.nframe()
[17:44:51.204]     ...future.conditions <- base::list()
[17:44:51.204]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.204]     if (FALSE) {
[17:44:51.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.204]     }
[17:44:51.204]     ...future.result <- base::tryCatch({
[17:44:51.204]         base::withCallingHandlers({
[17:44:51.204]             ...future.value <- base::withVisible(base::local({
[17:44:51.204]                 ...future.makeSendCondition <- base::local({
[17:44:51.204]                   sendCondition <- NULL
[17:44:51.204]                   function(frame = 1L) {
[17:44:51.204]                     if (is.function(sendCondition)) 
[17:44:51.204]                       return(sendCondition)
[17:44:51.204]                     ns <- getNamespace("parallel")
[17:44:51.204]                     if (exists("sendData", mode = "function", 
[17:44:51.204]                       envir = ns)) {
[17:44:51.204]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.204]                         envir = ns)
[17:44:51.204]                       envir <- sys.frame(frame)
[17:44:51.204]                       master <- NULL
[17:44:51.204]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.204]                         !identical(envir, emptyenv())) {
[17:44:51.204]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.204]                           inherits = FALSE)) {
[17:44:51.204]                           master <- get("master", mode = "list", 
[17:44:51.204]                             envir = envir, inherits = FALSE)
[17:44:51.204]                           if (inherits(master, c("SOCKnode", 
[17:44:51.204]                             "SOCK0node"))) {
[17:44:51.204]                             sendCondition <<- function(cond) {
[17:44:51.204]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.204]                                 success = TRUE)
[17:44:51.204]                               parallel_sendData(master, data)
[17:44:51.204]                             }
[17:44:51.204]                             return(sendCondition)
[17:44:51.204]                           }
[17:44:51.204]                         }
[17:44:51.204]                         frame <- frame + 1L
[17:44:51.204]                         envir <- sys.frame(frame)
[17:44:51.204]                       }
[17:44:51.204]                     }
[17:44:51.204]                     sendCondition <<- function(cond) NULL
[17:44:51.204]                   }
[17:44:51.204]                 })
[17:44:51.204]                 withCallingHandlers({
[17:44:51.204]                   {
[17:44:51.204]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.204]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.204]                       ...future.globals.maxSize)) {
[17:44:51.204]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.204]                       on.exit(options(oopts), add = TRUE)
[17:44:51.204]                     }
[17:44:51.204]                     {
[17:44:51.204]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.204]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.204]                         USE.NAMES = FALSE)
[17:44:51.204]                       do.call(mapply, args = args)
[17:44:51.204]                     }
[17:44:51.204]                   }
[17:44:51.204]                 }, immediateCondition = function(cond) {
[17:44:51.204]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.204]                   sendCondition(cond)
[17:44:51.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.204]                   {
[17:44:51.204]                     inherits <- base::inherits
[17:44:51.204]                     invokeRestart <- base::invokeRestart
[17:44:51.204]                     is.null <- base::is.null
[17:44:51.204]                     muffled <- FALSE
[17:44:51.204]                     if (inherits(cond, "message")) {
[17:44:51.204]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.204]                       if (muffled) 
[17:44:51.204]                         invokeRestart("muffleMessage")
[17:44:51.204]                     }
[17:44:51.204]                     else if (inherits(cond, "warning")) {
[17:44:51.204]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.204]                       if (muffled) 
[17:44:51.204]                         invokeRestart("muffleWarning")
[17:44:51.204]                     }
[17:44:51.204]                     else if (inherits(cond, "condition")) {
[17:44:51.204]                       if (!is.null(pattern)) {
[17:44:51.204]                         computeRestarts <- base::computeRestarts
[17:44:51.204]                         grepl <- base::grepl
[17:44:51.204]                         restarts <- computeRestarts(cond)
[17:44:51.204]                         for (restart in restarts) {
[17:44:51.204]                           name <- restart$name
[17:44:51.204]                           if (is.null(name)) 
[17:44:51.204]                             next
[17:44:51.204]                           if (!grepl(pattern, name)) 
[17:44:51.204]                             next
[17:44:51.204]                           invokeRestart(restart)
[17:44:51.204]                           muffled <- TRUE
[17:44:51.204]                           break
[17:44:51.204]                         }
[17:44:51.204]                       }
[17:44:51.204]                     }
[17:44:51.204]                     invisible(muffled)
[17:44:51.204]                   }
[17:44:51.204]                   muffleCondition(cond)
[17:44:51.204]                 })
[17:44:51.204]             }))
[17:44:51.204]             future::FutureResult(value = ...future.value$value, 
[17:44:51.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.204]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.204]                     ...future.globalenv.names))
[17:44:51.204]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.204]         }, condition = base::local({
[17:44:51.204]             c <- base::c
[17:44:51.204]             inherits <- base::inherits
[17:44:51.204]             invokeRestart <- base::invokeRestart
[17:44:51.204]             length <- base::length
[17:44:51.204]             list <- base::list
[17:44:51.204]             seq.int <- base::seq.int
[17:44:51.204]             signalCondition <- base::signalCondition
[17:44:51.204]             sys.calls <- base::sys.calls
[17:44:51.204]             `[[` <- base::`[[`
[17:44:51.204]             `+` <- base::`+`
[17:44:51.204]             `<<-` <- base::`<<-`
[17:44:51.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.204]                   3L)]
[17:44:51.204]             }
[17:44:51.204]             function(cond) {
[17:44:51.204]                 is_error <- inherits(cond, "error")
[17:44:51.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.204]                   NULL)
[17:44:51.204]                 if (is_error) {
[17:44:51.204]                   sessionInformation <- function() {
[17:44:51.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.204]                       search = base::search(), system = base::Sys.info())
[17:44:51.204]                   }
[17:44:51.204]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.204]                     cond$call), session = sessionInformation(), 
[17:44:51.204]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.204]                   signalCondition(cond)
[17:44:51.204]                 }
[17:44:51.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.204]                 "immediateCondition"))) {
[17:44:51.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.204]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.204]                   if (TRUE && !signal) {
[17:44:51.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.204]                     {
[17:44:51.204]                       inherits <- base::inherits
[17:44:51.204]                       invokeRestart <- base::invokeRestart
[17:44:51.204]                       is.null <- base::is.null
[17:44:51.204]                       muffled <- FALSE
[17:44:51.204]                       if (inherits(cond, "message")) {
[17:44:51.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.204]                         if (muffled) 
[17:44:51.204]                           invokeRestart("muffleMessage")
[17:44:51.204]                       }
[17:44:51.204]                       else if (inherits(cond, "warning")) {
[17:44:51.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.204]                         if (muffled) 
[17:44:51.204]                           invokeRestart("muffleWarning")
[17:44:51.204]                       }
[17:44:51.204]                       else if (inherits(cond, "condition")) {
[17:44:51.204]                         if (!is.null(pattern)) {
[17:44:51.204]                           computeRestarts <- base::computeRestarts
[17:44:51.204]                           grepl <- base::grepl
[17:44:51.204]                           restarts <- computeRestarts(cond)
[17:44:51.204]                           for (restart in restarts) {
[17:44:51.204]                             name <- restart$name
[17:44:51.204]                             if (is.null(name)) 
[17:44:51.204]                               next
[17:44:51.204]                             if (!grepl(pattern, name)) 
[17:44:51.204]                               next
[17:44:51.204]                             invokeRestart(restart)
[17:44:51.204]                             muffled <- TRUE
[17:44:51.204]                             break
[17:44:51.204]                           }
[17:44:51.204]                         }
[17:44:51.204]                       }
[17:44:51.204]                       invisible(muffled)
[17:44:51.204]                     }
[17:44:51.204]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.204]                   }
[17:44:51.204]                 }
[17:44:51.204]                 else {
[17:44:51.204]                   if (TRUE) {
[17:44:51.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.204]                     {
[17:44:51.204]                       inherits <- base::inherits
[17:44:51.204]                       invokeRestart <- base::invokeRestart
[17:44:51.204]                       is.null <- base::is.null
[17:44:51.204]                       muffled <- FALSE
[17:44:51.204]                       if (inherits(cond, "message")) {
[17:44:51.204]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.204]                         if (muffled) 
[17:44:51.204]                           invokeRestart("muffleMessage")
[17:44:51.204]                       }
[17:44:51.204]                       else if (inherits(cond, "warning")) {
[17:44:51.204]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.204]                         if (muffled) 
[17:44:51.204]                           invokeRestart("muffleWarning")
[17:44:51.204]                       }
[17:44:51.204]                       else if (inherits(cond, "condition")) {
[17:44:51.204]                         if (!is.null(pattern)) {
[17:44:51.204]                           computeRestarts <- base::computeRestarts
[17:44:51.204]                           grepl <- base::grepl
[17:44:51.204]                           restarts <- computeRestarts(cond)
[17:44:51.204]                           for (restart in restarts) {
[17:44:51.204]                             name <- restart$name
[17:44:51.204]                             if (is.null(name)) 
[17:44:51.204]                               next
[17:44:51.204]                             if (!grepl(pattern, name)) 
[17:44:51.204]                               next
[17:44:51.204]                             invokeRestart(restart)
[17:44:51.204]                             muffled <- TRUE
[17:44:51.204]                             break
[17:44:51.204]                           }
[17:44:51.204]                         }
[17:44:51.204]                       }
[17:44:51.204]                       invisible(muffled)
[17:44:51.204]                     }
[17:44:51.204]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.204]                   }
[17:44:51.204]                 }
[17:44:51.204]             }
[17:44:51.204]         }))
[17:44:51.204]     }, error = function(ex) {
[17:44:51.204]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.204]                 ...future.rng), started = ...future.startTime, 
[17:44:51.204]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.204]             version = "1.8"), class = "FutureResult")
[17:44:51.204]     }, finally = {
[17:44:51.204]         if (!identical(...future.workdir, getwd())) 
[17:44:51.204]             setwd(...future.workdir)
[17:44:51.204]         {
[17:44:51.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.204]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.204]             }
[17:44:51.204]             base::options(...future.oldOptions)
[17:44:51.204]             if (.Platform$OS.type == "windows") {
[17:44:51.204]                 old_names <- names(...future.oldEnvVars)
[17:44:51.204]                 envs <- base::Sys.getenv()
[17:44:51.204]                 names <- names(envs)
[17:44:51.204]                 common <- intersect(names, old_names)
[17:44:51.204]                 added <- setdiff(names, old_names)
[17:44:51.204]                 removed <- setdiff(old_names, names)
[17:44:51.204]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.204]                   envs[common]]
[17:44:51.204]                 NAMES <- toupper(changed)
[17:44:51.204]                 args <- list()
[17:44:51.204]                 for (kk in seq_along(NAMES)) {
[17:44:51.204]                   name <- changed[[kk]]
[17:44:51.204]                   NAME <- NAMES[[kk]]
[17:44:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.204]                     next
[17:44:51.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.204]                 }
[17:44:51.204]                 NAMES <- toupper(added)
[17:44:51.204]                 for (kk in seq_along(NAMES)) {
[17:44:51.204]                   name <- added[[kk]]
[17:44:51.204]                   NAME <- NAMES[[kk]]
[17:44:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.204]                     next
[17:44:51.204]                   args[[name]] <- ""
[17:44:51.204]                 }
[17:44:51.204]                 NAMES <- toupper(removed)
[17:44:51.204]                 for (kk in seq_along(NAMES)) {
[17:44:51.204]                   name <- removed[[kk]]
[17:44:51.204]                   NAME <- NAMES[[kk]]
[17:44:51.204]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.204]                     next
[17:44:51.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.204]                 }
[17:44:51.204]                 if (length(args) > 0) 
[17:44:51.204]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.204]             }
[17:44:51.204]             else {
[17:44:51.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.204]             }
[17:44:51.204]             {
[17:44:51.204]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.204]                   0L) {
[17:44:51.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.204]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.204]                   base::options(opts)
[17:44:51.204]                 }
[17:44:51.204]                 {
[17:44:51.204]                   {
[17:44:51.204]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.204]                     NULL
[17:44:51.204]                   }
[17:44:51.204]                   options(future.plan = NULL)
[17:44:51.204]                   if (is.na(NA_character_)) 
[17:44:51.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.204]                     .init = FALSE)
[17:44:51.204]                 }
[17:44:51.204]             }
[17:44:51.204]         }
[17:44:51.204]     })
[17:44:51.204]     if (TRUE) {
[17:44:51.204]         base::sink(type = "output", split = FALSE)
[17:44:51.204]         if (TRUE) {
[17:44:51.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.204]         }
[17:44:51.204]         else {
[17:44:51.204]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.204]         }
[17:44:51.204]         base::close(...future.stdout)
[17:44:51.204]         ...future.stdout <- NULL
[17:44:51.204]     }
[17:44:51.204]     ...future.result$conditions <- ...future.conditions
[17:44:51.204]     ...future.result$finished <- base::Sys.time()
[17:44:51.204]     ...future.result
[17:44:51.204] }
[17:44:51.207] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:51.207] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:51.207] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:51.207] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.208] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.208] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:51.208] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:51.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.208] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.209] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.209] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.209] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:51.209] MultisessionFuture started
[17:44:51.210] - Launch lazy future ... done
[17:44:51.210] run() for ‘MultisessionFuture’ ... done
[17:44:51.210] Created future:
[17:44:51.210] MultisessionFuture:
[17:44:51.210] Label: ‘future_mapply-1’
[17:44:51.210] Expression:
[17:44:51.210] {
[17:44:51.210]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.210]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.210]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.210]         on.exit(options(oopts), add = TRUE)
[17:44:51.210]     }
[17:44:51.210]     {
[17:44:51.210]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.210]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.210]         do.call(mapply, args = args)
[17:44:51.210]     }
[17:44:51.210] }
[17:44:51.210] Lazy evaluation: FALSE
[17:44:51.210] Asynchronous evaluation: TRUE
[17:44:51.210] Local evaluation: TRUE
[17:44:51.210] Environment: R_GlobalEnv
[17:44:51.210] Capture standard output: TRUE
[17:44:51.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.210] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.210] Packages: <none>
[17:44:51.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.210] Resolved: FALSE
[17:44:51.210] Value: <not collected>
[17:44:51.210] Conditions captured: <none>
[17:44:51.210] Early signaling: FALSE
[17:44:51.210] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.210] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.221] Chunk #1 of 2 ... DONE
[17:44:51.221] Chunk #2 of 2 ...
[17:44:51.221]  - Finding globals in '...' for chunk #2 ...
[17:44:51.221] getGlobalsAndPackages() ...
[17:44:51.221] Searching for globals...
[17:44:51.222] 
[17:44:51.222] Searching for globals ... DONE
[17:44:51.222] - globals: [0] <none>
[17:44:51.222] getGlobalsAndPackages() ... DONE
[17:44:51.222]    + additional globals found: [n=0] 
[17:44:51.222]    + additional namespaces needed: [n=0] 
[17:44:51.222]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.222]  - seeds: <none>
[17:44:51.223]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.223] getGlobalsAndPackages() ...
[17:44:51.223] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.223] Resolving globals: FALSE
[17:44:51.223] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:51.224] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:51.224] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.224] 
[17:44:51.224] getGlobalsAndPackages() ... DONE
[17:44:51.224] run() for ‘Future’ ...
[17:44:51.224] - state: ‘created’
[17:44:51.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.238] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.238]   - Field: ‘node’
[17:44:51.238]   - Field: ‘label’
[17:44:51.238]   - Field: ‘local’
[17:44:51.238]   - Field: ‘owner’
[17:44:51.238]   - Field: ‘envir’
[17:44:51.238]   - Field: ‘workers’
[17:44:51.238]   - Field: ‘packages’
[17:44:51.239]   - Field: ‘gc’
[17:44:51.239]   - Field: ‘conditions’
[17:44:51.239]   - Field: ‘persistent’
[17:44:51.239]   - Field: ‘expr’
[17:44:51.239]   - Field: ‘uuid’
[17:44:51.239]   - Field: ‘seed’
[17:44:51.239]   - Field: ‘version’
[17:44:51.239]   - Field: ‘result’
[17:44:51.239]   - Field: ‘asynchronous’
[17:44:51.239]   - Field: ‘calls’
[17:44:51.239]   - Field: ‘globals’
[17:44:51.240]   - Field: ‘stdout’
[17:44:51.240]   - Field: ‘earlySignal’
[17:44:51.240]   - Field: ‘lazy’
[17:44:51.240]   - Field: ‘state’
[17:44:51.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.240] - Launch lazy future ...
[17:44:51.240] Packages needed by the future expression (n = 0): <none>
[17:44:51.240] Packages needed by future strategies (n = 0): <none>
[17:44:51.241] {
[17:44:51.241]     {
[17:44:51.241]         {
[17:44:51.241]             ...future.startTime <- base::Sys.time()
[17:44:51.241]             {
[17:44:51.241]                 {
[17:44:51.241]                   {
[17:44:51.241]                     {
[17:44:51.241]                       base::local({
[17:44:51.241]                         has_future <- base::requireNamespace("future", 
[17:44:51.241]                           quietly = TRUE)
[17:44:51.241]                         if (has_future) {
[17:44:51.241]                           ns <- base::getNamespace("future")
[17:44:51.241]                           version <- ns[[".package"]][["version"]]
[17:44:51.241]                           if (is.null(version)) 
[17:44:51.241]                             version <- utils::packageVersion("future")
[17:44:51.241]                         }
[17:44:51.241]                         else {
[17:44:51.241]                           version <- NULL
[17:44:51.241]                         }
[17:44:51.241]                         if (!has_future || version < "1.8.0") {
[17:44:51.241]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.241]                             "", base::R.version$version.string), 
[17:44:51.241]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.241]                               "release", "version")], collapse = " "), 
[17:44:51.241]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.241]                             info)
[17:44:51.241]                           info <- base::paste(info, collapse = "; ")
[17:44:51.241]                           if (!has_future) {
[17:44:51.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.241]                               info)
[17:44:51.241]                           }
[17:44:51.241]                           else {
[17:44:51.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.241]                               info, version)
[17:44:51.241]                           }
[17:44:51.241]                           base::stop(msg)
[17:44:51.241]                         }
[17:44:51.241]                       })
[17:44:51.241]                     }
[17:44:51.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.241]                     base::options(mc.cores = 1L)
[17:44:51.241]                   }
[17:44:51.241]                   ...future.strategy.old <- future::plan("list")
[17:44:51.241]                   options(future.plan = NULL)
[17:44:51.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.241]                 }
[17:44:51.241]                 ...future.workdir <- getwd()
[17:44:51.241]             }
[17:44:51.241]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.241]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.241]         }
[17:44:51.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.241]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.241]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.241]             base::names(...future.oldOptions))
[17:44:51.241]     }
[17:44:51.241]     if (FALSE) {
[17:44:51.241]     }
[17:44:51.241]     else {
[17:44:51.241]         if (TRUE) {
[17:44:51.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.241]                 open = "w")
[17:44:51.241]         }
[17:44:51.241]         else {
[17:44:51.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.241]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.241]         }
[17:44:51.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.241]             base::sink(type = "output", split = FALSE)
[17:44:51.241]             base::close(...future.stdout)
[17:44:51.241]         }, add = TRUE)
[17:44:51.241]     }
[17:44:51.241]     ...future.frame <- base::sys.nframe()
[17:44:51.241]     ...future.conditions <- base::list()
[17:44:51.241]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.241]     if (FALSE) {
[17:44:51.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.241]     }
[17:44:51.241]     ...future.result <- base::tryCatch({
[17:44:51.241]         base::withCallingHandlers({
[17:44:51.241]             ...future.value <- base::withVisible(base::local({
[17:44:51.241]                 ...future.makeSendCondition <- base::local({
[17:44:51.241]                   sendCondition <- NULL
[17:44:51.241]                   function(frame = 1L) {
[17:44:51.241]                     if (is.function(sendCondition)) 
[17:44:51.241]                       return(sendCondition)
[17:44:51.241]                     ns <- getNamespace("parallel")
[17:44:51.241]                     if (exists("sendData", mode = "function", 
[17:44:51.241]                       envir = ns)) {
[17:44:51.241]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.241]                         envir = ns)
[17:44:51.241]                       envir <- sys.frame(frame)
[17:44:51.241]                       master <- NULL
[17:44:51.241]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.241]                         !identical(envir, emptyenv())) {
[17:44:51.241]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.241]                           inherits = FALSE)) {
[17:44:51.241]                           master <- get("master", mode = "list", 
[17:44:51.241]                             envir = envir, inherits = FALSE)
[17:44:51.241]                           if (inherits(master, c("SOCKnode", 
[17:44:51.241]                             "SOCK0node"))) {
[17:44:51.241]                             sendCondition <<- function(cond) {
[17:44:51.241]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.241]                                 success = TRUE)
[17:44:51.241]                               parallel_sendData(master, data)
[17:44:51.241]                             }
[17:44:51.241]                             return(sendCondition)
[17:44:51.241]                           }
[17:44:51.241]                         }
[17:44:51.241]                         frame <- frame + 1L
[17:44:51.241]                         envir <- sys.frame(frame)
[17:44:51.241]                       }
[17:44:51.241]                     }
[17:44:51.241]                     sendCondition <<- function(cond) NULL
[17:44:51.241]                   }
[17:44:51.241]                 })
[17:44:51.241]                 withCallingHandlers({
[17:44:51.241]                   {
[17:44:51.241]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.241]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.241]                       ...future.globals.maxSize)) {
[17:44:51.241]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.241]                       on.exit(options(oopts), add = TRUE)
[17:44:51.241]                     }
[17:44:51.241]                     {
[17:44:51.241]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.241]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.241]                         USE.NAMES = FALSE)
[17:44:51.241]                       do.call(mapply, args = args)
[17:44:51.241]                     }
[17:44:51.241]                   }
[17:44:51.241]                 }, immediateCondition = function(cond) {
[17:44:51.241]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.241]                   sendCondition(cond)
[17:44:51.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.241]                   {
[17:44:51.241]                     inherits <- base::inherits
[17:44:51.241]                     invokeRestart <- base::invokeRestart
[17:44:51.241]                     is.null <- base::is.null
[17:44:51.241]                     muffled <- FALSE
[17:44:51.241]                     if (inherits(cond, "message")) {
[17:44:51.241]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.241]                       if (muffled) 
[17:44:51.241]                         invokeRestart("muffleMessage")
[17:44:51.241]                     }
[17:44:51.241]                     else if (inherits(cond, "warning")) {
[17:44:51.241]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.241]                       if (muffled) 
[17:44:51.241]                         invokeRestart("muffleWarning")
[17:44:51.241]                     }
[17:44:51.241]                     else if (inherits(cond, "condition")) {
[17:44:51.241]                       if (!is.null(pattern)) {
[17:44:51.241]                         computeRestarts <- base::computeRestarts
[17:44:51.241]                         grepl <- base::grepl
[17:44:51.241]                         restarts <- computeRestarts(cond)
[17:44:51.241]                         for (restart in restarts) {
[17:44:51.241]                           name <- restart$name
[17:44:51.241]                           if (is.null(name)) 
[17:44:51.241]                             next
[17:44:51.241]                           if (!grepl(pattern, name)) 
[17:44:51.241]                             next
[17:44:51.241]                           invokeRestart(restart)
[17:44:51.241]                           muffled <- TRUE
[17:44:51.241]                           break
[17:44:51.241]                         }
[17:44:51.241]                       }
[17:44:51.241]                     }
[17:44:51.241]                     invisible(muffled)
[17:44:51.241]                   }
[17:44:51.241]                   muffleCondition(cond)
[17:44:51.241]                 })
[17:44:51.241]             }))
[17:44:51.241]             future::FutureResult(value = ...future.value$value, 
[17:44:51.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.241]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.241]                     ...future.globalenv.names))
[17:44:51.241]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.241]         }, condition = base::local({
[17:44:51.241]             c <- base::c
[17:44:51.241]             inherits <- base::inherits
[17:44:51.241]             invokeRestart <- base::invokeRestart
[17:44:51.241]             length <- base::length
[17:44:51.241]             list <- base::list
[17:44:51.241]             seq.int <- base::seq.int
[17:44:51.241]             signalCondition <- base::signalCondition
[17:44:51.241]             sys.calls <- base::sys.calls
[17:44:51.241]             `[[` <- base::`[[`
[17:44:51.241]             `+` <- base::`+`
[17:44:51.241]             `<<-` <- base::`<<-`
[17:44:51.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.241]                   3L)]
[17:44:51.241]             }
[17:44:51.241]             function(cond) {
[17:44:51.241]                 is_error <- inherits(cond, "error")
[17:44:51.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.241]                   NULL)
[17:44:51.241]                 if (is_error) {
[17:44:51.241]                   sessionInformation <- function() {
[17:44:51.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.241]                       search = base::search(), system = base::Sys.info())
[17:44:51.241]                   }
[17:44:51.241]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.241]                     cond$call), session = sessionInformation(), 
[17:44:51.241]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.241]                   signalCondition(cond)
[17:44:51.241]                 }
[17:44:51.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.241]                 "immediateCondition"))) {
[17:44:51.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.241]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.241]                   if (TRUE && !signal) {
[17:44:51.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.241]                     {
[17:44:51.241]                       inherits <- base::inherits
[17:44:51.241]                       invokeRestart <- base::invokeRestart
[17:44:51.241]                       is.null <- base::is.null
[17:44:51.241]                       muffled <- FALSE
[17:44:51.241]                       if (inherits(cond, "message")) {
[17:44:51.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.241]                         if (muffled) 
[17:44:51.241]                           invokeRestart("muffleMessage")
[17:44:51.241]                       }
[17:44:51.241]                       else if (inherits(cond, "warning")) {
[17:44:51.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.241]                         if (muffled) 
[17:44:51.241]                           invokeRestart("muffleWarning")
[17:44:51.241]                       }
[17:44:51.241]                       else if (inherits(cond, "condition")) {
[17:44:51.241]                         if (!is.null(pattern)) {
[17:44:51.241]                           computeRestarts <- base::computeRestarts
[17:44:51.241]                           grepl <- base::grepl
[17:44:51.241]                           restarts <- computeRestarts(cond)
[17:44:51.241]                           for (restart in restarts) {
[17:44:51.241]                             name <- restart$name
[17:44:51.241]                             if (is.null(name)) 
[17:44:51.241]                               next
[17:44:51.241]                             if (!grepl(pattern, name)) 
[17:44:51.241]                               next
[17:44:51.241]                             invokeRestart(restart)
[17:44:51.241]                             muffled <- TRUE
[17:44:51.241]                             break
[17:44:51.241]                           }
[17:44:51.241]                         }
[17:44:51.241]                       }
[17:44:51.241]                       invisible(muffled)
[17:44:51.241]                     }
[17:44:51.241]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.241]                   }
[17:44:51.241]                 }
[17:44:51.241]                 else {
[17:44:51.241]                   if (TRUE) {
[17:44:51.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.241]                     {
[17:44:51.241]                       inherits <- base::inherits
[17:44:51.241]                       invokeRestart <- base::invokeRestart
[17:44:51.241]                       is.null <- base::is.null
[17:44:51.241]                       muffled <- FALSE
[17:44:51.241]                       if (inherits(cond, "message")) {
[17:44:51.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.241]                         if (muffled) 
[17:44:51.241]                           invokeRestart("muffleMessage")
[17:44:51.241]                       }
[17:44:51.241]                       else if (inherits(cond, "warning")) {
[17:44:51.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.241]                         if (muffled) 
[17:44:51.241]                           invokeRestart("muffleWarning")
[17:44:51.241]                       }
[17:44:51.241]                       else if (inherits(cond, "condition")) {
[17:44:51.241]                         if (!is.null(pattern)) {
[17:44:51.241]                           computeRestarts <- base::computeRestarts
[17:44:51.241]                           grepl <- base::grepl
[17:44:51.241]                           restarts <- computeRestarts(cond)
[17:44:51.241]                           for (restart in restarts) {
[17:44:51.241]                             name <- restart$name
[17:44:51.241]                             if (is.null(name)) 
[17:44:51.241]                               next
[17:44:51.241]                             if (!grepl(pattern, name)) 
[17:44:51.241]                               next
[17:44:51.241]                             invokeRestart(restart)
[17:44:51.241]                             muffled <- TRUE
[17:44:51.241]                             break
[17:44:51.241]                           }
[17:44:51.241]                         }
[17:44:51.241]                       }
[17:44:51.241]                       invisible(muffled)
[17:44:51.241]                     }
[17:44:51.241]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.241]                   }
[17:44:51.241]                 }
[17:44:51.241]             }
[17:44:51.241]         }))
[17:44:51.241]     }, error = function(ex) {
[17:44:51.241]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.241]                 ...future.rng), started = ...future.startTime, 
[17:44:51.241]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.241]             version = "1.8"), class = "FutureResult")
[17:44:51.241]     }, finally = {
[17:44:51.241]         if (!identical(...future.workdir, getwd())) 
[17:44:51.241]             setwd(...future.workdir)
[17:44:51.241]         {
[17:44:51.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.241]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.241]             }
[17:44:51.241]             base::options(...future.oldOptions)
[17:44:51.241]             if (.Platform$OS.type == "windows") {
[17:44:51.241]                 old_names <- names(...future.oldEnvVars)
[17:44:51.241]                 envs <- base::Sys.getenv()
[17:44:51.241]                 names <- names(envs)
[17:44:51.241]                 common <- intersect(names, old_names)
[17:44:51.241]                 added <- setdiff(names, old_names)
[17:44:51.241]                 removed <- setdiff(old_names, names)
[17:44:51.241]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.241]                   envs[common]]
[17:44:51.241]                 NAMES <- toupper(changed)
[17:44:51.241]                 args <- list()
[17:44:51.241]                 for (kk in seq_along(NAMES)) {
[17:44:51.241]                   name <- changed[[kk]]
[17:44:51.241]                   NAME <- NAMES[[kk]]
[17:44:51.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.241]                     next
[17:44:51.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.241]                 }
[17:44:51.241]                 NAMES <- toupper(added)
[17:44:51.241]                 for (kk in seq_along(NAMES)) {
[17:44:51.241]                   name <- added[[kk]]
[17:44:51.241]                   NAME <- NAMES[[kk]]
[17:44:51.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.241]                     next
[17:44:51.241]                   args[[name]] <- ""
[17:44:51.241]                 }
[17:44:51.241]                 NAMES <- toupper(removed)
[17:44:51.241]                 for (kk in seq_along(NAMES)) {
[17:44:51.241]                   name <- removed[[kk]]
[17:44:51.241]                   NAME <- NAMES[[kk]]
[17:44:51.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.241]                     next
[17:44:51.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.241]                 }
[17:44:51.241]                 if (length(args) > 0) 
[17:44:51.241]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.241]             }
[17:44:51.241]             else {
[17:44:51.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.241]             }
[17:44:51.241]             {
[17:44:51.241]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.241]                   0L) {
[17:44:51.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.241]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.241]                   base::options(opts)
[17:44:51.241]                 }
[17:44:51.241]                 {
[17:44:51.241]                   {
[17:44:51.241]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.241]                     NULL
[17:44:51.241]                   }
[17:44:51.241]                   options(future.plan = NULL)
[17:44:51.241]                   if (is.na(NA_character_)) 
[17:44:51.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.241]                     .init = FALSE)
[17:44:51.241]                 }
[17:44:51.241]             }
[17:44:51.241]         }
[17:44:51.241]     })
[17:44:51.241]     if (TRUE) {
[17:44:51.241]         base::sink(type = "output", split = FALSE)
[17:44:51.241]         if (TRUE) {
[17:44:51.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.241]         }
[17:44:51.241]         else {
[17:44:51.241]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.241]         }
[17:44:51.241]         base::close(...future.stdout)
[17:44:51.241]         ...future.stdout <- NULL
[17:44:51.241]     }
[17:44:51.241]     ...future.result$conditions <- ...future.conditions
[17:44:51.241]     ...future.result$finished <- base::Sys.time()
[17:44:51.241]     ...future.result
[17:44:51.241] }
[17:44:51.243] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:44:51.244] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:51.244] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:51.244] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:51.244] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.245] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:44:51.245] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:44:51.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:51.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.246] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:44:51.247] MultisessionFuture started
[17:44:51.247] - Launch lazy future ... done
[17:44:51.247] run() for ‘MultisessionFuture’ ... done
[17:44:51.247] Created future:
[17:44:51.247] MultisessionFuture:
[17:44:51.247] Label: ‘future_mapply-2’
[17:44:51.247] Expression:
[17:44:51.247] {
[17:44:51.247]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.247]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.247]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.247]         on.exit(options(oopts), add = TRUE)
[17:44:51.247]     }
[17:44:51.247]     {
[17:44:51.247]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.247]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.247]         do.call(mapply, args = args)
[17:44:51.247]     }
[17:44:51.247] }
[17:44:51.247] Lazy evaluation: FALSE
[17:44:51.247] Asynchronous evaluation: TRUE
[17:44:51.247] Local evaluation: TRUE
[17:44:51.247] Environment: R_GlobalEnv
[17:44:51.247] Capture standard output: TRUE
[17:44:51.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.247] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.247] Packages: <none>
[17:44:51.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.247] Resolved: FALSE
[17:44:51.247] Value: <not collected>
[17:44:51.247] Conditions captured: <none>
[17:44:51.247] Early signaling: FALSE
[17:44:51.247] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.247] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.259] Chunk #2 of 2 ... DONE
[17:44:51.259] Launching 2 futures (chunks) ... DONE
[17:44:51.259] Resolving 2 futures (chunks) ...
[17:44:51.259] resolve() on list ...
[17:44:51.259]  recursive: 0
[17:44:51.259]  length: 2
[17:44:51.259] 
[17:44:51.260] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.260] - Validating connection of MultisessionFuture
[17:44:51.260] - received message: FutureResult
[17:44:51.260] - Received FutureResult
[17:44:51.260] - Erased future from FutureRegistry
[17:44:51.260] result() for ClusterFuture ...
[17:44:51.260] - result already collected: FutureResult
[17:44:51.260] result() for ClusterFuture ... done
[17:44:51.260] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.260] Future #1
[17:44:51.261] result() for ClusterFuture ...
[17:44:51.261] - result already collected: FutureResult
[17:44:51.261] result() for ClusterFuture ... done
[17:44:51.261] result() for ClusterFuture ...
[17:44:51.261] - result already collected: FutureResult
[17:44:51.261] result() for ClusterFuture ... done
[17:44:51.261] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.261] - nx: 2
[17:44:51.261] - relay: TRUE
[17:44:51.261] - stdout: TRUE
[17:44:51.261] - signal: TRUE
[17:44:51.261] - resignal: FALSE
[17:44:51.262] - force: TRUE
[17:44:51.262] - relayed: [n=2] FALSE, FALSE
[17:44:51.262] - queued futures: [n=2] FALSE, FALSE
[17:44:51.262]  - until=1
[17:44:51.262]  - relaying element #1
[17:44:51.262] result() for ClusterFuture ...
[17:44:51.262] - result already collected: FutureResult
[17:44:51.262] result() for ClusterFuture ... done
[17:44:51.262] result() for ClusterFuture ...
[17:44:51.262] - result already collected: FutureResult
[17:44:51.262] result() for ClusterFuture ... done
[17:44:51.263] result() for ClusterFuture ...
[17:44:51.263] - result already collected: FutureResult
[17:44:51.263] result() for ClusterFuture ... done
[17:44:51.263] result() for ClusterFuture ...
[17:44:51.263] - result already collected: FutureResult
[17:44:51.263] result() for ClusterFuture ... done
[17:44:51.263] - relayed: [n=2] TRUE, FALSE
[17:44:51.263] - queued futures: [n=2] TRUE, FALSE
[17:44:51.263] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.263]  length: 1 (resolved future 1)
[17:44:51.289] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.289] - Validating connection of MultisessionFuture
[17:44:51.289] - received message: FutureResult
[17:44:51.289] - Received FutureResult
[17:44:51.289] - Erased future from FutureRegistry
[17:44:51.289] result() for ClusterFuture ...
[17:44:51.290] - result already collected: FutureResult
[17:44:51.290] result() for ClusterFuture ... done
[17:44:51.290] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.290] Future #2
[17:44:51.290] result() for ClusterFuture ...
[17:44:51.290] - result already collected: FutureResult
[17:44:51.290] result() for ClusterFuture ... done
[17:44:51.290] result() for ClusterFuture ...
[17:44:51.290] - result already collected: FutureResult
[17:44:51.290] result() for ClusterFuture ... done
[17:44:51.290] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.290] - nx: 2
[17:44:51.291] - relay: TRUE
[17:44:51.291] - stdout: TRUE
[17:44:51.291] - signal: TRUE
[17:44:51.291] - resignal: FALSE
[17:44:51.291] - force: TRUE
[17:44:51.291] - relayed: [n=2] TRUE, FALSE
[17:44:51.291] - queued futures: [n=2] TRUE, FALSE
[17:44:51.291]  - until=2
[17:44:51.291]  - relaying element #2
[17:44:51.291] result() for ClusterFuture ...
[17:44:51.291] - result already collected: FutureResult
[17:44:51.291] result() for ClusterFuture ... done
[17:44:51.292] result() for ClusterFuture ...
[17:44:51.292] - result already collected: FutureResult
[17:44:51.292] result() for ClusterFuture ... done
[17:44:51.292] result() for ClusterFuture ...
[17:44:51.292] - result already collected: FutureResult
[17:44:51.292] result() for ClusterFuture ... done
[17:44:51.292] result() for ClusterFuture ...
[17:44:51.292] - result already collected: FutureResult
[17:44:51.292] result() for ClusterFuture ... done
[17:44:51.292] - relayed: [n=2] TRUE, TRUE
[17:44:51.292] - queued futures: [n=2] TRUE, TRUE
[17:44:51.293] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.293]  length: 0 (resolved future 2)
[17:44:51.293] Relaying remaining futures
[17:44:51.293] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.293] - nx: 2
[17:44:51.293] - relay: TRUE
[17:44:51.293] - stdout: TRUE
[17:44:51.293] - signal: TRUE
[17:44:51.293] - resignal: FALSE
[17:44:51.293] - force: TRUE
[17:44:51.293] - relayed: [n=2] TRUE, TRUE
[17:44:51.293] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.294] - relayed: [n=2] TRUE, TRUE
[17:44:51.294] - queued futures: [n=2] TRUE, TRUE
[17:44:51.294] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.294] resolve() on list ... DONE
[17:44:51.294] result() for ClusterFuture ...
[17:44:51.294] - result already collected: FutureResult
[17:44:51.294] result() for ClusterFuture ... done
[17:44:51.294] result() for ClusterFuture ...
[17:44:51.294] - result already collected: FutureResult
[17:44:51.294] result() for ClusterFuture ... done
[17:44:51.294] result() for ClusterFuture ...
[17:44:51.295] - result already collected: FutureResult
[17:44:51.295] result() for ClusterFuture ... done
[17:44:51.295] result() for ClusterFuture ...
[17:44:51.295] - result already collected: FutureResult
[17:44:51.295] result() for ClusterFuture ... done
[17:44:51.295]  - Number of value chunks collected: 2
[17:44:51.295] Resolving 2 futures (chunks) ... DONE
[17:44:51.295] Reducing values from 2 chunks ...
[17:44:51.295]  - Number of values collected after concatenation: 5
[17:44:51.295]  - Number of values expected: 5
[17:44:51.295] Reverse index remapping (attribute 'ordering'): [n = 5] 5, 4, 3, 2, 1
[17:44:51.296] Reducing values from 2 chunks ... DONE
[17:44:51.296] future_mapply() ... DONE
[17:44:51.296] future_mapply() ...
[17:44:51.299] Number of chunks: 2
[17:44:51.300] getGlobalsAndPackagesXApply() ...
[17:44:51.300]  - future.globals: TRUE
[17:44:51.300] getGlobalsAndPackages() ...
[17:44:51.300] Searching for globals...
[17:44:51.301] - globals found: [3] ‘FUN’, ‘paste’, ‘rep.int’
[17:44:51.301] Searching for globals ... DONE
[17:44:51.301] Resolving globals: FALSE
[17:44:51.302] The total size of the 1 globals is 3.24 KiB (3320 bytes)
[17:44:51.302] The total size of the 1 globals exported for future expression (‘FUN()’) is 3.24 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.24 KiB of class ‘function’)
[17:44:51.302] - globals: [1] ‘FUN’
[17:44:51.302] 
[17:44:51.302] getGlobalsAndPackages() ... DONE
[17:44:51.302]  - globals found/used: [n=1] ‘FUN’
[17:44:51.302]  - needed namespaces: [n=0] 
[17:44:51.303] Finding globals ... DONE
[17:44:51.303] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.303] List of 2
[17:44:51.303]  $ ...future.FUN:function (C, k)  
[17:44:51.303]  $ MoreArgs     : list()
[17:44:51.303]  - attr(*, "where")=List of 2
[17:44:51.303]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.303]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.303]  - attr(*, "resolved")= logi FALSE
[17:44:51.303]  - attr(*, "total_size")= num NA
[17:44:51.305] Packages to be attached in all futures: [n=0] 
[17:44:51.305] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.305] Number of futures (= number of chunks): 2
[17:44:51.306] Launching 2 futures (chunks) ...
[17:44:51.306] Chunk #1 of 2 ...
[17:44:51.306]  - Finding globals in '...' for chunk #1 ...
[17:44:51.306] getGlobalsAndPackages() ...
[17:44:51.306] Searching for globals...
[17:44:51.306] 
[17:44:51.306] Searching for globals ... DONE
[17:44:51.306] - globals: [0] <none>
[17:44:51.307] getGlobalsAndPackages() ... DONE
[17:44:51.307]    + additional globals found: [n=0] 
[17:44:51.307]    + additional namespaces needed: [n=0] 
[17:44:51.307]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.307]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.307]  - seeds: <none>
[17:44:51.307]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.307] getGlobalsAndPackages() ...
[17:44:51.307] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.307] Resolving globals: FALSE
[17:44:51.308] The total size of the 5 globals is 3.57 KiB (3656 bytes)
[17:44:51.308] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.57 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (336 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:51.308] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.308] 
[17:44:51.309] getGlobalsAndPackages() ... DONE
[17:44:51.309] run() for ‘Future’ ...
[17:44:51.309] - state: ‘created’
[17:44:51.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.322] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.323]   - Field: ‘node’
[17:44:51.323]   - Field: ‘label’
[17:44:51.323]   - Field: ‘local’
[17:44:51.323]   - Field: ‘owner’
[17:44:51.323]   - Field: ‘envir’
[17:44:51.323]   - Field: ‘workers’
[17:44:51.323]   - Field: ‘packages’
[17:44:51.323]   - Field: ‘gc’
[17:44:51.324]   - Field: ‘conditions’
[17:44:51.324]   - Field: ‘persistent’
[17:44:51.324]   - Field: ‘expr’
[17:44:51.324]   - Field: ‘uuid’
[17:44:51.324]   - Field: ‘seed’
[17:44:51.324]   - Field: ‘version’
[17:44:51.324]   - Field: ‘result’
[17:44:51.324]   - Field: ‘asynchronous’
[17:44:51.324]   - Field: ‘calls’
[17:44:51.324]   - Field: ‘globals’
[17:44:51.324]   - Field: ‘stdout’
[17:44:51.324]   - Field: ‘earlySignal’
[17:44:51.325]   - Field: ‘lazy’
[17:44:51.325]   - Field: ‘state’
[17:44:51.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.325] - Launch lazy future ...
[17:44:51.325] Packages needed by the future expression (n = 0): <none>
[17:44:51.325] Packages needed by future strategies (n = 0): <none>
[17:44:51.326] {
[17:44:51.326]     {
[17:44:51.326]         {
[17:44:51.326]             ...future.startTime <- base::Sys.time()
[17:44:51.326]             {
[17:44:51.326]                 {
[17:44:51.326]                   {
[17:44:51.326]                     {
[17:44:51.326]                       base::local({
[17:44:51.326]                         has_future <- base::requireNamespace("future", 
[17:44:51.326]                           quietly = TRUE)
[17:44:51.326]                         if (has_future) {
[17:44:51.326]                           ns <- base::getNamespace("future")
[17:44:51.326]                           version <- ns[[".package"]][["version"]]
[17:44:51.326]                           if (is.null(version)) 
[17:44:51.326]                             version <- utils::packageVersion("future")
[17:44:51.326]                         }
[17:44:51.326]                         else {
[17:44:51.326]                           version <- NULL
[17:44:51.326]                         }
[17:44:51.326]                         if (!has_future || version < "1.8.0") {
[17:44:51.326]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.326]                             "", base::R.version$version.string), 
[17:44:51.326]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.326]                               "release", "version")], collapse = " "), 
[17:44:51.326]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.326]                             info)
[17:44:51.326]                           info <- base::paste(info, collapse = "; ")
[17:44:51.326]                           if (!has_future) {
[17:44:51.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.326]                               info)
[17:44:51.326]                           }
[17:44:51.326]                           else {
[17:44:51.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.326]                               info, version)
[17:44:51.326]                           }
[17:44:51.326]                           base::stop(msg)
[17:44:51.326]                         }
[17:44:51.326]                       })
[17:44:51.326]                     }
[17:44:51.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.326]                     base::options(mc.cores = 1L)
[17:44:51.326]                   }
[17:44:51.326]                   ...future.strategy.old <- future::plan("list")
[17:44:51.326]                   options(future.plan = NULL)
[17:44:51.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.326]                 }
[17:44:51.326]                 ...future.workdir <- getwd()
[17:44:51.326]             }
[17:44:51.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.326]         }
[17:44:51.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.326]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.326]             base::names(...future.oldOptions))
[17:44:51.326]     }
[17:44:51.326]     if (FALSE) {
[17:44:51.326]     }
[17:44:51.326]     else {
[17:44:51.326]         if (TRUE) {
[17:44:51.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.326]                 open = "w")
[17:44:51.326]         }
[17:44:51.326]         else {
[17:44:51.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.326]         }
[17:44:51.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.326]             base::sink(type = "output", split = FALSE)
[17:44:51.326]             base::close(...future.stdout)
[17:44:51.326]         }, add = TRUE)
[17:44:51.326]     }
[17:44:51.326]     ...future.frame <- base::sys.nframe()
[17:44:51.326]     ...future.conditions <- base::list()
[17:44:51.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.326]     if (FALSE) {
[17:44:51.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.326]     }
[17:44:51.326]     ...future.result <- base::tryCatch({
[17:44:51.326]         base::withCallingHandlers({
[17:44:51.326]             ...future.value <- base::withVisible(base::local({
[17:44:51.326]                 ...future.makeSendCondition <- base::local({
[17:44:51.326]                   sendCondition <- NULL
[17:44:51.326]                   function(frame = 1L) {
[17:44:51.326]                     if (is.function(sendCondition)) 
[17:44:51.326]                       return(sendCondition)
[17:44:51.326]                     ns <- getNamespace("parallel")
[17:44:51.326]                     if (exists("sendData", mode = "function", 
[17:44:51.326]                       envir = ns)) {
[17:44:51.326]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.326]                         envir = ns)
[17:44:51.326]                       envir <- sys.frame(frame)
[17:44:51.326]                       master <- NULL
[17:44:51.326]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.326]                         !identical(envir, emptyenv())) {
[17:44:51.326]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.326]                           inherits = FALSE)) {
[17:44:51.326]                           master <- get("master", mode = "list", 
[17:44:51.326]                             envir = envir, inherits = FALSE)
[17:44:51.326]                           if (inherits(master, c("SOCKnode", 
[17:44:51.326]                             "SOCK0node"))) {
[17:44:51.326]                             sendCondition <<- function(cond) {
[17:44:51.326]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.326]                                 success = TRUE)
[17:44:51.326]                               parallel_sendData(master, data)
[17:44:51.326]                             }
[17:44:51.326]                             return(sendCondition)
[17:44:51.326]                           }
[17:44:51.326]                         }
[17:44:51.326]                         frame <- frame + 1L
[17:44:51.326]                         envir <- sys.frame(frame)
[17:44:51.326]                       }
[17:44:51.326]                     }
[17:44:51.326]                     sendCondition <<- function(cond) NULL
[17:44:51.326]                   }
[17:44:51.326]                 })
[17:44:51.326]                 withCallingHandlers({
[17:44:51.326]                   {
[17:44:51.326]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.326]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.326]                       ...future.globals.maxSize)) {
[17:44:51.326]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.326]                       on.exit(options(oopts), add = TRUE)
[17:44:51.326]                     }
[17:44:51.326]                     {
[17:44:51.326]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.326]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.326]                         USE.NAMES = FALSE)
[17:44:51.326]                       do.call(mapply, args = args)
[17:44:51.326]                     }
[17:44:51.326]                   }
[17:44:51.326]                 }, immediateCondition = function(cond) {
[17:44:51.326]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.326]                   sendCondition(cond)
[17:44:51.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.326]                   {
[17:44:51.326]                     inherits <- base::inherits
[17:44:51.326]                     invokeRestart <- base::invokeRestart
[17:44:51.326]                     is.null <- base::is.null
[17:44:51.326]                     muffled <- FALSE
[17:44:51.326]                     if (inherits(cond, "message")) {
[17:44:51.326]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.326]                       if (muffled) 
[17:44:51.326]                         invokeRestart("muffleMessage")
[17:44:51.326]                     }
[17:44:51.326]                     else if (inherits(cond, "warning")) {
[17:44:51.326]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.326]                       if (muffled) 
[17:44:51.326]                         invokeRestart("muffleWarning")
[17:44:51.326]                     }
[17:44:51.326]                     else if (inherits(cond, "condition")) {
[17:44:51.326]                       if (!is.null(pattern)) {
[17:44:51.326]                         computeRestarts <- base::computeRestarts
[17:44:51.326]                         grepl <- base::grepl
[17:44:51.326]                         restarts <- computeRestarts(cond)
[17:44:51.326]                         for (restart in restarts) {
[17:44:51.326]                           name <- restart$name
[17:44:51.326]                           if (is.null(name)) 
[17:44:51.326]                             next
[17:44:51.326]                           if (!grepl(pattern, name)) 
[17:44:51.326]                             next
[17:44:51.326]                           invokeRestart(restart)
[17:44:51.326]                           muffled <- TRUE
[17:44:51.326]                           break
[17:44:51.326]                         }
[17:44:51.326]                       }
[17:44:51.326]                     }
[17:44:51.326]                     invisible(muffled)
[17:44:51.326]                   }
[17:44:51.326]                   muffleCondition(cond)
[17:44:51.326]                 })
[17:44:51.326]             }))
[17:44:51.326]             future::FutureResult(value = ...future.value$value, 
[17:44:51.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.326]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.326]                     ...future.globalenv.names))
[17:44:51.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.326]         }, condition = base::local({
[17:44:51.326]             c <- base::c
[17:44:51.326]             inherits <- base::inherits
[17:44:51.326]             invokeRestart <- base::invokeRestart
[17:44:51.326]             length <- base::length
[17:44:51.326]             list <- base::list
[17:44:51.326]             seq.int <- base::seq.int
[17:44:51.326]             signalCondition <- base::signalCondition
[17:44:51.326]             sys.calls <- base::sys.calls
[17:44:51.326]             `[[` <- base::`[[`
[17:44:51.326]             `+` <- base::`+`
[17:44:51.326]             `<<-` <- base::`<<-`
[17:44:51.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.326]                   3L)]
[17:44:51.326]             }
[17:44:51.326]             function(cond) {
[17:44:51.326]                 is_error <- inherits(cond, "error")
[17:44:51.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.326]                   NULL)
[17:44:51.326]                 if (is_error) {
[17:44:51.326]                   sessionInformation <- function() {
[17:44:51.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.326]                       search = base::search(), system = base::Sys.info())
[17:44:51.326]                   }
[17:44:51.326]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.326]                     cond$call), session = sessionInformation(), 
[17:44:51.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.326]                   signalCondition(cond)
[17:44:51.326]                 }
[17:44:51.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.326]                 "immediateCondition"))) {
[17:44:51.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.326]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.326]                   if (TRUE && !signal) {
[17:44:51.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.326]                     {
[17:44:51.326]                       inherits <- base::inherits
[17:44:51.326]                       invokeRestart <- base::invokeRestart
[17:44:51.326]                       is.null <- base::is.null
[17:44:51.326]                       muffled <- FALSE
[17:44:51.326]                       if (inherits(cond, "message")) {
[17:44:51.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.326]                         if (muffled) 
[17:44:51.326]                           invokeRestart("muffleMessage")
[17:44:51.326]                       }
[17:44:51.326]                       else if (inherits(cond, "warning")) {
[17:44:51.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.326]                         if (muffled) 
[17:44:51.326]                           invokeRestart("muffleWarning")
[17:44:51.326]                       }
[17:44:51.326]                       else if (inherits(cond, "condition")) {
[17:44:51.326]                         if (!is.null(pattern)) {
[17:44:51.326]                           computeRestarts <- base::computeRestarts
[17:44:51.326]                           grepl <- base::grepl
[17:44:51.326]                           restarts <- computeRestarts(cond)
[17:44:51.326]                           for (restart in restarts) {
[17:44:51.326]                             name <- restart$name
[17:44:51.326]                             if (is.null(name)) 
[17:44:51.326]                               next
[17:44:51.326]                             if (!grepl(pattern, name)) 
[17:44:51.326]                               next
[17:44:51.326]                             invokeRestart(restart)
[17:44:51.326]                             muffled <- TRUE
[17:44:51.326]                             break
[17:44:51.326]                           }
[17:44:51.326]                         }
[17:44:51.326]                       }
[17:44:51.326]                       invisible(muffled)
[17:44:51.326]                     }
[17:44:51.326]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.326]                   }
[17:44:51.326]                 }
[17:44:51.326]                 else {
[17:44:51.326]                   if (TRUE) {
[17:44:51.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.326]                     {
[17:44:51.326]                       inherits <- base::inherits
[17:44:51.326]                       invokeRestart <- base::invokeRestart
[17:44:51.326]                       is.null <- base::is.null
[17:44:51.326]                       muffled <- FALSE
[17:44:51.326]                       if (inherits(cond, "message")) {
[17:44:51.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.326]                         if (muffled) 
[17:44:51.326]                           invokeRestart("muffleMessage")
[17:44:51.326]                       }
[17:44:51.326]                       else if (inherits(cond, "warning")) {
[17:44:51.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.326]                         if (muffled) 
[17:44:51.326]                           invokeRestart("muffleWarning")
[17:44:51.326]                       }
[17:44:51.326]                       else if (inherits(cond, "condition")) {
[17:44:51.326]                         if (!is.null(pattern)) {
[17:44:51.326]                           computeRestarts <- base::computeRestarts
[17:44:51.326]                           grepl <- base::grepl
[17:44:51.326]                           restarts <- computeRestarts(cond)
[17:44:51.326]                           for (restart in restarts) {
[17:44:51.326]                             name <- restart$name
[17:44:51.326]                             if (is.null(name)) 
[17:44:51.326]                               next
[17:44:51.326]                             if (!grepl(pattern, name)) 
[17:44:51.326]                               next
[17:44:51.326]                             invokeRestart(restart)
[17:44:51.326]                             muffled <- TRUE
[17:44:51.326]                             break
[17:44:51.326]                           }
[17:44:51.326]                         }
[17:44:51.326]                       }
[17:44:51.326]                       invisible(muffled)
[17:44:51.326]                     }
[17:44:51.326]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.326]                   }
[17:44:51.326]                 }
[17:44:51.326]             }
[17:44:51.326]         }))
[17:44:51.326]     }, error = function(ex) {
[17:44:51.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.326]                 ...future.rng), started = ...future.startTime, 
[17:44:51.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.326]             version = "1.8"), class = "FutureResult")
[17:44:51.326]     }, finally = {
[17:44:51.326]         if (!identical(...future.workdir, getwd())) 
[17:44:51.326]             setwd(...future.workdir)
[17:44:51.326]         {
[17:44:51.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.326]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.326]             }
[17:44:51.326]             base::options(...future.oldOptions)
[17:44:51.326]             if (.Platform$OS.type == "windows") {
[17:44:51.326]                 old_names <- names(...future.oldEnvVars)
[17:44:51.326]                 envs <- base::Sys.getenv()
[17:44:51.326]                 names <- names(envs)
[17:44:51.326]                 common <- intersect(names, old_names)
[17:44:51.326]                 added <- setdiff(names, old_names)
[17:44:51.326]                 removed <- setdiff(old_names, names)
[17:44:51.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.326]                   envs[common]]
[17:44:51.326]                 NAMES <- toupper(changed)
[17:44:51.326]                 args <- list()
[17:44:51.326]                 for (kk in seq_along(NAMES)) {
[17:44:51.326]                   name <- changed[[kk]]
[17:44:51.326]                   NAME <- NAMES[[kk]]
[17:44:51.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.326]                     next
[17:44:51.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.326]                 }
[17:44:51.326]                 NAMES <- toupper(added)
[17:44:51.326]                 for (kk in seq_along(NAMES)) {
[17:44:51.326]                   name <- added[[kk]]
[17:44:51.326]                   NAME <- NAMES[[kk]]
[17:44:51.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.326]                     next
[17:44:51.326]                   args[[name]] <- ""
[17:44:51.326]                 }
[17:44:51.326]                 NAMES <- toupper(removed)
[17:44:51.326]                 for (kk in seq_along(NAMES)) {
[17:44:51.326]                   name <- removed[[kk]]
[17:44:51.326]                   NAME <- NAMES[[kk]]
[17:44:51.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.326]                     next
[17:44:51.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.326]                 }
[17:44:51.326]                 if (length(args) > 0) 
[17:44:51.326]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.326]             }
[17:44:51.326]             else {
[17:44:51.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.326]             }
[17:44:51.326]             {
[17:44:51.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.326]                   0L) {
[17:44:51.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.326]                   base::options(opts)
[17:44:51.326]                 }
[17:44:51.326]                 {
[17:44:51.326]                   {
[17:44:51.326]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.326]                     NULL
[17:44:51.326]                   }
[17:44:51.326]                   options(future.plan = NULL)
[17:44:51.326]                   if (is.na(NA_character_)) 
[17:44:51.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.326]                     .init = FALSE)
[17:44:51.326]                 }
[17:44:51.326]             }
[17:44:51.326]         }
[17:44:51.326]     })
[17:44:51.326]     if (TRUE) {
[17:44:51.326]         base::sink(type = "output", split = FALSE)
[17:44:51.326]         if (TRUE) {
[17:44:51.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.326]         }
[17:44:51.326]         else {
[17:44:51.326]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.326]         }
[17:44:51.326]         base::close(...future.stdout)
[17:44:51.326]         ...future.stdout <- NULL
[17:44:51.326]     }
[17:44:51.326]     ...future.result$conditions <- ...future.conditions
[17:44:51.326]     ...future.result$finished <- base::Sys.time()
[17:44:51.326]     ...future.result
[17:44:51.326] }
[17:44:51.328] Exporting 5 global objects (3.57 KiB) to cluster node #1 ...
[17:44:51.328] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ...
[17:44:51.329] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #1 ... DONE
[17:44:51.329] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.329] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.329] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[17:44:51.330] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[17:44:51.330] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.330] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.330] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.330] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.330] Exporting 5 global objects (3.57 KiB) to cluster node #1 ... DONE
[17:44:51.331] MultisessionFuture started
[17:44:51.331] - Launch lazy future ... done
[17:44:51.331] run() for ‘MultisessionFuture’ ... done
[17:44:51.331] Created future:
[17:44:51.331] MultisessionFuture:
[17:44:51.331] Label: ‘future_.mapply-1’
[17:44:51.331] Expression:
[17:44:51.331] {
[17:44:51.331]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.331]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.331]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.331]         on.exit(options(oopts), add = TRUE)
[17:44:51.331]     }
[17:44:51.331]     {
[17:44:51.331]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.331]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.331]         do.call(mapply, args = args)
[17:44:51.331]     }
[17:44:51.331] }
[17:44:51.331] Lazy evaluation: FALSE
[17:44:51.331] Asynchronous evaluation: TRUE
[17:44:51.331] Local evaluation: TRUE
[17:44:51.331] Environment: R_GlobalEnv
[17:44:51.331] Capture standard output: TRUE
[17:44:51.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.331] Globals: 5 objects totaling 3.57 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.331] Packages: <none>
[17:44:51.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.331] Resolved: FALSE
[17:44:51.331] Value: <not collected>
[17:44:51.331] Conditions captured: <none>
[17:44:51.331] Early signaling: FALSE
[17:44:51.331] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.331] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.343] Chunk #1 of 2 ... DONE
[17:44:51.343] Chunk #2 of 2 ...
[17:44:51.343]  - Finding globals in '...' for chunk #2 ...
[17:44:51.343] getGlobalsAndPackages() ...
[17:44:51.343] Searching for globals...
[17:44:51.343] 
[17:44:51.344] Searching for globals ... DONE
[17:44:51.344] - globals: [0] <none>
[17:44:51.344] getGlobalsAndPackages() ... DONE
[17:44:51.344]    + additional globals found: [n=0] 
[17:44:51.344]    + additional namespaces needed: [n=0] 
[17:44:51.344]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.344]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.344]  - seeds: <none>
[17:44:51.344]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.344] getGlobalsAndPackages() ...
[17:44:51.344] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.345] Resolving globals: FALSE
[17:44:51.345] The total size of the 5 globals is 3.73 KiB (3824 bytes)
[17:44:51.345] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 3.73 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (3.24 KiB of class ‘function’), ‘...future.elements_ii’ (504 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:51.346] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.346] 
[17:44:51.346] getGlobalsAndPackages() ... DONE
[17:44:51.346] run() for ‘Future’ ...
[17:44:51.346] - state: ‘created’
[17:44:51.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.361] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.361]   - Field: ‘node’
[17:44:51.361]   - Field: ‘label’
[17:44:51.361]   - Field: ‘local’
[17:44:51.361]   - Field: ‘owner’
[17:44:51.361]   - Field: ‘envir’
[17:44:51.361]   - Field: ‘workers’
[17:44:51.362]   - Field: ‘packages’
[17:44:51.362]   - Field: ‘gc’
[17:44:51.362]   - Field: ‘conditions’
[17:44:51.362]   - Field: ‘persistent’
[17:44:51.362]   - Field: ‘expr’
[17:44:51.362]   - Field: ‘uuid’
[17:44:51.362]   - Field: ‘seed’
[17:44:51.362]   - Field: ‘version’
[17:44:51.362]   - Field: ‘result’
[17:44:51.362]   - Field: ‘asynchronous’
[17:44:51.362]   - Field: ‘calls’
[17:44:51.363]   - Field: ‘globals’
[17:44:51.363]   - Field: ‘stdout’
[17:44:51.363]   - Field: ‘earlySignal’
[17:44:51.363]   - Field: ‘lazy’
[17:44:51.363]   - Field: ‘state’
[17:44:51.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.363] - Launch lazy future ...
[17:44:51.363] Packages needed by the future expression (n = 0): <none>
[17:44:51.363] Packages needed by future strategies (n = 0): <none>
[17:44:51.364] {
[17:44:51.364]     {
[17:44:51.364]         {
[17:44:51.364]             ...future.startTime <- base::Sys.time()
[17:44:51.364]             {
[17:44:51.364]                 {
[17:44:51.364]                   {
[17:44:51.364]                     {
[17:44:51.364]                       base::local({
[17:44:51.364]                         has_future <- base::requireNamespace("future", 
[17:44:51.364]                           quietly = TRUE)
[17:44:51.364]                         if (has_future) {
[17:44:51.364]                           ns <- base::getNamespace("future")
[17:44:51.364]                           version <- ns[[".package"]][["version"]]
[17:44:51.364]                           if (is.null(version)) 
[17:44:51.364]                             version <- utils::packageVersion("future")
[17:44:51.364]                         }
[17:44:51.364]                         else {
[17:44:51.364]                           version <- NULL
[17:44:51.364]                         }
[17:44:51.364]                         if (!has_future || version < "1.8.0") {
[17:44:51.364]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.364]                             "", base::R.version$version.string), 
[17:44:51.364]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.364]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.364]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.364]                               "release", "version")], collapse = " "), 
[17:44:51.364]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.364]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.364]                             info)
[17:44:51.364]                           info <- base::paste(info, collapse = "; ")
[17:44:51.364]                           if (!has_future) {
[17:44:51.364]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.364]                               info)
[17:44:51.364]                           }
[17:44:51.364]                           else {
[17:44:51.364]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.364]                               info, version)
[17:44:51.364]                           }
[17:44:51.364]                           base::stop(msg)
[17:44:51.364]                         }
[17:44:51.364]                       })
[17:44:51.364]                     }
[17:44:51.364]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.364]                     base::options(mc.cores = 1L)
[17:44:51.364]                   }
[17:44:51.364]                   ...future.strategy.old <- future::plan("list")
[17:44:51.364]                   options(future.plan = NULL)
[17:44:51.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.364]                 }
[17:44:51.364]                 ...future.workdir <- getwd()
[17:44:51.364]             }
[17:44:51.364]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.364]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.364]         }
[17:44:51.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.364]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.364]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.364]             base::names(...future.oldOptions))
[17:44:51.364]     }
[17:44:51.364]     if (FALSE) {
[17:44:51.364]     }
[17:44:51.364]     else {
[17:44:51.364]         if (TRUE) {
[17:44:51.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.364]                 open = "w")
[17:44:51.364]         }
[17:44:51.364]         else {
[17:44:51.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.364]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.364]         }
[17:44:51.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.364]             base::sink(type = "output", split = FALSE)
[17:44:51.364]             base::close(...future.stdout)
[17:44:51.364]         }, add = TRUE)
[17:44:51.364]     }
[17:44:51.364]     ...future.frame <- base::sys.nframe()
[17:44:51.364]     ...future.conditions <- base::list()
[17:44:51.364]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.364]     if (FALSE) {
[17:44:51.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.364]     }
[17:44:51.364]     ...future.result <- base::tryCatch({
[17:44:51.364]         base::withCallingHandlers({
[17:44:51.364]             ...future.value <- base::withVisible(base::local({
[17:44:51.364]                 ...future.makeSendCondition <- base::local({
[17:44:51.364]                   sendCondition <- NULL
[17:44:51.364]                   function(frame = 1L) {
[17:44:51.364]                     if (is.function(sendCondition)) 
[17:44:51.364]                       return(sendCondition)
[17:44:51.364]                     ns <- getNamespace("parallel")
[17:44:51.364]                     if (exists("sendData", mode = "function", 
[17:44:51.364]                       envir = ns)) {
[17:44:51.364]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.364]                         envir = ns)
[17:44:51.364]                       envir <- sys.frame(frame)
[17:44:51.364]                       master <- NULL
[17:44:51.364]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.364]                         !identical(envir, emptyenv())) {
[17:44:51.364]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.364]                           inherits = FALSE)) {
[17:44:51.364]                           master <- get("master", mode = "list", 
[17:44:51.364]                             envir = envir, inherits = FALSE)
[17:44:51.364]                           if (inherits(master, c("SOCKnode", 
[17:44:51.364]                             "SOCK0node"))) {
[17:44:51.364]                             sendCondition <<- function(cond) {
[17:44:51.364]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.364]                                 success = TRUE)
[17:44:51.364]                               parallel_sendData(master, data)
[17:44:51.364]                             }
[17:44:51.364]                             return(sendCondition)
[17:44:51.364]                           }
[17:44:51.364]                         }
[17:44:51.364]                         frame <- frame + 1L
[17:44:51.364]                         envir <- sys.frame(frame)
[17:44:51.364]                       }
[17:44:51.364]                     }
[17:44:51.364]                     sendCondition <<- function(cond) NULL
[17:44:51.364]                   }
[17:44:51.364]                 })
[17:44:51.364]                 withCallingHandlers({
[17:44:51.364]                   {
[17:44:51.364]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.364]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.364]                       ...future.globals.maxSize)) {
[17:44:51.364]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.364]                       on.exit(options(oopts), add = TRUE)
[17:44:51.364]                     }
[17:44:51.364]                     {
[17:44:51.364]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.364]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.364]                         USE.NAMES = FALSE)
[17:44:51.364]                       do.call(mapply, args = args)
[17:44:51.364]                     }
[17:44:51.364]                   }
[17:44:51.364]                 }, immediateCondition = function(cond) {
[17:44:51.364]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.364]                   sendCondition(cond)
[17:44:51.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.364]                   {
[17:44:51.364]                     inherits <- base::inherits
[17:44:51.364]                     invokeRestart <- base::invokeRestart
[17:44:51.364]                     is.null <- base::is.null
[17:44:51.364]                     muffled <- FALSE
[17:44:51.364]                     if (inherits(cond, "message")) {
[17:44:51.364]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.364]                       if (muffled) 
[17:44:51.364]                         invokeRestart("muffleMessage")
[17:44:51.364]                     }
[17:44:51.364]                     else if (inherits(cond, "warning")) {
[17:44:51.364]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.364]                       if (muffled) 
[17:44:51.364]                         invokeRestart("muffleWarning")
[17:44:51.364]                     }
[17:44:51.364]                     else if (inherits(cond, "condition")) {
[17:44:51.364]                       if (!is.null(pattern)) {
[17:44:51.364]                         computeRestarts <- base::computeRestarts
[17:44:51.364]                         grepl <- base::grepl
[17:44:51.364]                         restarts <- computeRestarts(cond)
[17:44:51.364]                         for (restart in restarts) {
[17:44:51.364]                           name <- restart$name
[17:44:51.364]                           if (is.null(name)) 
[17:44:51.364]                             next
[17:44:51.364]                           if (!grepl(pattern, name)) 
[17:44:51.364]                             next
[17:44:51.364]                           invokeRestart(restart)
[17:44:51.364]                           muffled <- TRUE
[17:44:51.364]                           break
[17:44:51.364]                         }
[17:44:51.364]                       }
[17:44:51.364]                     }
[17:44:51.364]                     invisible(muffled)
[17:44:51.364]                   }
[17:44:51.364]                   muffleCondition(cond)
[17:44:51.364]                 })
[17:44:51.364]             }))
[17:44:51.364]             future::FutureResult(value = ...future.value$value, 
[17:44:51.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.364]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.364]                     ...future.globalenv.names))
[17:44:51.364]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.364]         }, condition = base::local({
[17:44:51.364]             c <- base::c
[17:44:51.364]             inherits <- base::inherits
[17:44:51.364]             invokeRestart <- base::invokeRestart
[17:44:51.364]             length <- base::length
[17:44:51.364]             list <- base::list
[17:44:51.364]             seq.int <- base::seq.int
[17:44:51.364]             signalCondition <- base::signalCondition
[17:44:51.364]             sys.calls <- base::sys.calls
[17:44:51.364]             `[[` <- base::`[[`
[17:44:51.364]             `+` <- base::`+`
[17:44:51.364]             `<<-` <- base::`<<-`
[17:44:51.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.364]                   3L)]
[17:44:51.364]             }
[17:44:51.364]             function(cond) {
[17:44:51.364]                 is_error <- inherits(cond, "error")
[17:44:51.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.364]                   NULL)
[17:44:51.364]                 if (is_error) {
[17:44:51.364]                   sessionInformation <- function() {
[17:44:51.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.364]                       search = base::search(), system = base::Sys.info())
[17:44:51.364]                   }
[17:44:51.364]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.364]                     cond$call), session = sessionInformation(), 
[17:44:51.364]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.364]                   signalCondition(cond)
[17:44:51.364]                 }
[17:44:51.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.364]                 "immediateCondition"))) {
[17:44:51.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.364]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.364]                   if (TRUE && !signal) {
[17:44:51.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.364]                     {
[17:44:51.364]                       inherits <- base::inherits
[17:44:51.364]                       invokeRestart <- base::invokeRestart
[17:44:51.364]                       is.null <- base::is.null
[17:44:51.364]                       muffled <- FALSE
[17:44:51.364]                       if (inherits(cond, "message")) {
[17:44:51.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.364]                         if (muffled) 
[17:44:51.364]                           invokeRestart("muffleMessage")
[17:44:51.364]                       }
[17:44:51.364]                       else if (inherits(cond, "warning")) {
[17:44:51.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.364]                         if (muffled) 
[17:44:51.364]                           invokeRestart("muffleWarning")
[17:44:51.364]                       }
[17:44:51.364]                       else if (inherits(cond, "condition")) {
[17:44:51.364]                         if (!is.null(pattern)) {
[17:44:51.364]                           computeRestarts <- base::computeRestarts
[17:44:51.364]                           grepl <- base::grepl
[17:44:51.364]                           restarts <- computeRestarts(cond)
[17:44:51.364]                           for (restart in restarts) {
[17:44:51.364]                             name <- restart$name
[17:44:51.364]                             if (is.null(name)) 
[17:44:51.364]                               next
[17:44:51.364]                             if (!grepl(pattern, name)) 
[17:44:51.364]                               next
[17:44:51.364]                             invokeRestart(restart)
[17:44:51.364]                             muffled <- TRUE
[17:44:51.364]                             break
[17:44:51.364]                           }
[17:44:51.364]                         }
[17:44:51.364]                       }
[17:44:51.364]                       invisible(muffled)
[17:44:51.364]                     }
[17:44:51.364]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.364]                   }
[17:44:51.364]                 }
[17:44:51.364]                 else {
[17:44:51.364]                   if (TRUE) {
[17:44:51.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.364]                     {
[17:44:51.364]                       inherits <- base::inherits
[17:44:51.364]                       invokeRestart <- base::invokeRestart
[17:44:51.364]                       is.null <- base::is.null
[17:44:51.364]                       muffled <- FALSE
[17:44:51.364]                       if (inherits(cond, "message")) {
[17:44:51.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.364]                         if (muffled) 
[17:44:51.364]                           invokeRestart("muffleMessage")
[17:44:51.364]                       }
[17:44:51.364]                       else if (inherits(cond, "warning")) {
[17:44:51.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.364]                         if (muffled) 
[17:44:51.364]                           invokeRestart("muffleWarning")
[17:44:51.364]                       }
[17:44:51.364]                       else if (inherits(cond, "condition")) {
[17:44:51.364]                         if (!is.null(pattern)) {
[17:44:51.364]                           computeRestarts <- base::computeRestarts
[17:44:51.364]                           grepl <- base::grepl
[17:44:51.364]                           restarts <- computeRestarts(cond)
[17:44:51.364]                           for (restart in restarts) {
[17:44:51.364]                             name <- restart$name
[17:44:51.364]                             if (is.null(name)) 
[17:44:51.364]                               next
[17:44:51.364]                             if (!grepl(pattern, name)) 
[17:44:51.364]                               next
[17:44:51.364]                             invokeRestart(restart)
[17:44:51.364]                             muffled <- TRUE
[17:44:51.364]                             break
[17:44:51.364]                           }
[17:44:51.364]                         }
[17:44:51.364]                       }
[17:44:51.364]                       invisible(muffled)
[17:44:51.364]                     }
[17:44:51.364]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.364]                   }
[17:44:51.364]                 }
[17:44:51.364]             }
[17:44:51.364]         }))
[17:44:51.364]     }, error = function(ex) {
[17:44:51.364]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.364]                 ...future.rng), started = ...future.startTime, 
[17:44:51.364]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.364]             version = "1.8"), class = "FutureResult")
[17:44:51.364]     }, finally = {
[17:44:51.364]         if (!identical(...future.workdir, getwd())) 
[17:44:51.364]             setwd(...future.workdir)
[17:44:51.364]         {
[17:44:51.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.364]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.364]             }
[17:44:51.364]             base::options(...future.oldOptions)
[17:44:51.364]             if (.Platform$OS.type == "windows") {
[17:44:51.364]                 old_names <- names(...future.oldEnvVars)
[17:44:51.364]                 envs <- base::Sys.getenv()
[17:44:51.364]                 names <- names(envs)
[17:44:51.364]                 common <- intersect(names, old_names)
[17:44:51.364]                 added <- setdiff(names, old_names)
[17:44:51.364]                 removed <- setdiff(old_names, names)
[17:44:51.364]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.364]                   envs[common]]
[17:44:51.364]                 NAMES <- toupper(changed)
[17:44:51.364]                 args <- list()
[17:44:51.364]                 for (kk in seq_along(NAMES)) {
[17:44:51.364]                   name <- changed[[kk]]
[17:44:51.364]                   NAME <- NAMES[[kk]]
[17:44:51.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.364]                     next
[17:44:51.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.364]                 }
[17:44:51.364]                 NAMES <- toupper(added)
[17:44:51.364]                 for (kk in seq_along(NAMES)) {
[17:44:51.364]                   name <- added[[kk]]
[17:44:51.364]                   NAME <- NAMES[[kk]]
[17:44:51.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.364]                     next
[17:44:51.364]                   args[[name]] <- ""
[17:44:51.364]                 }
[17:44:51.364]                 NAMES <- toupper(removed)
[17:44:51.364]                 for (kk in seq_along(NAMES)) {
[17:44:51.364]                   name <- removed[[kk]]
[17:44:51.364]                   NAME <- NAMES[[kk]]
[17:44:51.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.364]                     next
[17:44:51.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.364]                 }
[17:44:51.364]                 if (length(args) > 0) 
[17:44:51.364]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.364]             }
[17:44:51.364]             else {
[17:44:51.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.364]             }
[17:44:51.364]             {
[17:44:51.364]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.364]                   0L) {
[17:44:51.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.364]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.364]                   base::options(opts)
[17:44:51.364]                 }
[17:44:51.364]                 {
[17:44:51.364]                   {
[17:44:51.364]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.364]                     NULL
[17:44:51.364]                   }
[17:44:51.364]                   options(future.plan = NULL)
[17:44:51.364]                   if (is.na(NA_character_)) 
[17:44:51.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.364]                     .init = FALSE)
[17:44:51.364]                 }
[17:44:51.364]             }
[17:44:51.364]         }
[17:44:51.364]     })
[17:44:51.364]     if (TRUE) {
[17:44:51.364]         base::sink(type = "output", split = FALSE)
[17:44:51.364]         if (TRUE) {
[17:44:51.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.364]         }
[17:44:51.364]         else {
[17:44:51.364]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.364]         }
[17:44:51.364]         base::close(...future.stdout)
[17:44:51.364]         ...future.stdout <- NULL
[17:44:51.364]     }
[17:44:51.364]     ...future.result$conditions <- ...future.conditions
[17:44:51.364]     ...future.result$finished <- base::Sys.time()
[17:44:51.364]     ...future.result
[17:44:51.364] }
[17:44:51.367] Exporting 5 global objects (3.73 KiB) to cluster node #2 ...
[17:44:51.367] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ...
[17:44:51.367] Exporting ‘...future.FUN’ (3.24 KiB) to cluster node #2 ... DONE
[17:44:51.367] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:51.368] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.368] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ...
[17:44:51.368] Exporting ‘...future.elements_ii’ (504 bytes) to cluster node #2 ... DONE
[17:44:51.368] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:51.368] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.369] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.369] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.369] Exporting 5 global objects (3.73 KiB) to cluster node #2 ... DONE
[17:44:51.369] MultisessionFuture started
[17:44:51.370] - Launch lazy future ... done
[17:44:51.370] run() for ‘MultisessionFuture’ ... done
[17:44:51.370] Created future:
[17:44:51.370] MultisessionFuture:
[17:44:51.370] Label: ‘future_.mapply-2’
[17:44:51.370] Expression:
[17:44:51.370] {
[17:44:51.370]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.370]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.370]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.370]         on.exit(options(oopts), add = TRUE)
[17:44:51.370]     }
[17:44:51.370]     {
[17:44:51.370]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.370]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.370]         do.call(mapply, args = args)
[17:44:51.370]     }
[17:44:51.370] }
[17:44:51.370] Lazy evaluation: FALSE
[17:44:51.370] Asynchronous evaluation: TRUE
[17:44:51.370] Local evaluation: TRUE
[17:44:51.370] Environment: R_GlobalEnv
[17:44:51.370] Capture standard output: TRUE
[17:44:51.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.370] Globals: 5 objects totaling 3.73 KiB (function ‘...future.FUN’ of 3.24 KiB, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 504 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.370] Packages: <none>
[17:44:51.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.370] Resolved: FALSE
[17:44:51.370] Value: <not collected>
[17:44:51.370] Conditions captured: <none>
[17:44:51.370] Early signaling: FALSE
[17:44:51.370] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.370] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.381] Chunk #2 of 2 ... DONE
[17:44:51.381] Launching 2 futures (chunks) ... DONE
[17:44:51.381] Resolving 2 futures (chunks) ...
[17:44:51.382] resolve() on list ...
[17:44:51.382]  recursive: 0
[17:44:51.382]  length: 2
[17:44:51.382] 
[17:44:51.383] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.383] - Validating connection of MultisessionFuture
[17:44:51.383] - received message: FutureResult
[17:44:51.383] - Received FutureResult
[17:44:51.383] - Erased future from FutureRegistry
[17:44:51.383] result() for ClusterFuture ...
[17:44:51.383] - result already collected: FutureResult
[17:44:51.383] result() for ClusterFuture ... done
[17:44:51.384] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.384] Future #1
[17:44:51.384] result() for ClusterFuture ...
[17:44:51.384] - result already collected: FutureResult
[17:44:51.384] result() for ClusterFuture ... done
[17:44:51.384] result() for ClusterFuture ...
[17:44:51.384] - result already collected: FutureResult
[17:44:51.387] result() for ClusterFuture ... done
[17:44:51.387] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.387] - nx: 2
[17:44:51.387] - relay: TRUE
[17:44:51.387] - stdout: TRUE
[17:44:51.387] - signal: TRUE
[17:44:51.387] - resignal: FALSE
[17:44:51.387] - force: TRUE
[17:44:51.387] - relayed: [n=2] FALSE, FALSE
[17:44:51.387] - queued futures: [n=2] FALSE, FALSE
[17:44:51.387]  - until=1
[17:44:51.388]  - relaying element #1
[17:44:51.388] result() for ClusterFuture ...
[17:44:51.388] - result already collected: FutureResult
[17:44:51.388] result() for ClusterFuture ... done
[17:44:51.388] result() for ClusterFuture ...
[17:44:51.388] - result already collected: FutureResult
[17:44:51.388] result() for ClusterFuture ... done
[17:44:51.388] result() for ClusterFuture ...
[17:44:51.388] - result already collected: FutureResult
[17:44:51.388] result() for ClusterFuture ... done
[17:44:51.389] result() for ClusterFuture ...
[17:44:51.389] - result already collected: FutureResult
[17:44:51.389] result() for ClusterFuture ... done
[17:44:51.389] - relayed: [n=2] TRUE, FALSE
[17:44:51.389] - queued futures: [n=2] TRUE, FALSE
[17:44:51.389] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.389]  length: 1 (resolved future 1)
[17:44:51.413] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.413] - Validating connection of MultisessionFuture
[17:44:51.413] - received message: FutureResult
[17:44:51.413] - Received FutureResult
[17:44:51.413] - Erased future from FutureRegistry
[17:44:51.414] result() for ClusterFuture ...
[17:44:51.414] - result already collected: FutureResult
[17:44:51.414] result() for ClusterFuture ... done
[17:44:51.414] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.414] Future #2
[17:44:51.414] result() for ClusterFuture ...
[17:44:51.414] - result already collected: FutureResult
[17:44:51.414] result() for ClusterFuture ... done
[17:44:51.414] result() for ClusterFuture ...
[17:44:51.414] - result already collected: FutureResult
[17:44:51.414] result() for ClusterFuture ... done
[17:44:51.415] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.415] - nx: 2
[17:44:51.415] - relay: TRUE
[17:44:51.415] - stdout: TRUE
[17:44:51.415] - signal: TRUE
[17:44:51.415] - resignal: FALSE
[17:44:51.415] - force: TRUE
[17:44:51.415] - relayed: [n=2] TRUE, FALSE
[17:44:51.415] - queued futures: [n=2] TRUE, FALSE
[17:44:51.415]  - until=2
[17:44:51.415]  - relaying element #2
[17:44:51.415] result() for ClusterFuture ...
[17:44:51.416] - result already collected: FutureResult
[17:44:51.416] result() for ClusterFuture ... done
[17:44:51.416] result() for ClusterFuture ...
[17:44:51.416] - result already collected: FutureResult
[17:44:51.416] result() for ClusterFuture ... done
[17:44:51.416] result() for ClusterFuture ...
[17:44:51.416] - result already collected: FutureResult
[17:44:51.416] result() for ClusterFuture ... done
[17:44:51.416] result() for ClusterFuture ...
[17:44:51.416] - result already collected: FutureResult
[17:44:51.416] result() for ClusterFuture ... done
[17:44:51.416] - relayed: [n=2] TRUE, TRUE
[17:44:51.417] - queued futures: [n=2] TRUE, TRUE
[17:44:51.417] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.417]  length: 0 (resolved future 2)
[17:44:51.417] Relaying remaining futures
[17:44:51.417] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.417] - nx: 2
[17:44:51.417] - relay: TRUE
[17:44:51.417] - stdout: TRUE
[17:44:51.417] - signal: TRUE
[17:44:51.417] - resignal: FALSE
[17:44:51.417] - force: TRUE
[17:44:51.417] - relayed: [n=2] TRUE, TRUE
[17:44:51.418] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.418] - relayed: [n=2] TRUE, TRUE
[17:44:51.418] - queued futures: [n=2] TRUE, TRUE
[17:44:51.418] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.418] resolve() on list ... DONE
[17:44:51.418] result() for ClusterFuture ...
[17:44:51.418] - result already collected: FutureResult
[17:44:51.418] result() for ClusterFuture ... done
[17:44:51.418] result() for ClusterFuture ...
[17:44:51.418] - result already collected: FutureResult
[17:44:51.418] result() for ClusterFuture ... done
[17:44:51.419] result() for ClusterFuture ...
[17:44:51.419] - result already collected: FutureResult
[17:44:51.419] result() for ClusterFuture ... done
[17:44:51.419] result() for ClusterFuture ...
[17:44:51.419] - result already collected: FutureResult
[17:44:51.419] result() for ClusterFuture ... done
[17:44:51.419]  - Number of value chunks collected: 2
[17:44:51.419] Resolving 2 futures (chunks) ... DONE
[17:44:51.419] Reducing values from 2 chunks ...
[17:44:51.419]  - Number of values collected after concatenation: 5
[17:44:51.419]  - Number of values expected: 5
[17:44:51.420] Reducing values from 2 chunks ... DONE
[17:44:51.420] future_mapply() ... DONE
- Subsetting (Issue #17) ...
[17:44:51.420] future_mapply() ...
[17:44:51.423] Number of chunks: 1
[17:44:51.423] getGlobalsAndPackagesXApply() ...
[17:44:51.424]  - future.globals: TRUE
[17:44:51.424] getGlobalsAndPackages() ...
[17:44:51.424] Searching for globals...
[17:44:51.425] - globals found: [1] ‘FUN’
[17:44:51.425] Searching for globals ... DONE
[17:44:51.425] Resolving globals: FALSE
[17:44:51.425] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:51.426] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:51.426] - globals: [1] ‘FUN’
[17:44:51.426] 
[17:44:51.426] getGlobalsAndPackages() ... DONE
[17:44:51.426]  - globals found/used: [n=1] ‘FUN’
[17:44:51.426]  - needed namespaces: [n=0] 
[17:44:51.426] Finding globals ... DONE
[17:44:51.426] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.426] List of 2
[17:44:51.426]  $ ...future.FUN:function (x)  
[17:44:51.426]  $ MoreArgs     : NULL
[17:44:51.426]  - attr(*, "where")=List of 2
[17:44:51.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.426]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.426]  - attr(*, "resolved")= logi FALSE
[17:44:51.426]  - attr(*, "total_size")= num NA
[17:44:51.429] Packages to be attached in all futures: [n=0] 
[17:44:51.429] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.429] Number of futures (= number of chunks): 1
[17:44:51.429] Launching 1 futures (chunks) ...
[17:44:51.429] Chunk #1 of 1 ...
[17:44:51.429]  - Finding globals in '...' for chunk #1 ...
[17:44:51.430] getGlobalsAndPackages() ...
[17:44:51.430] Searching for globals...
[17:44:51.430] 
[17:44:51.430] Searching for globals ... DONE
[17:44:51.430] - globals: [0] <none>
[17:44:51.430] getGlobalsAndPackages() ... DONE
[17:44:51.430]    + additional globals found: [n=0] 
[17:44:51.430]    + additional namespaces needed: [n=0] 
[17:44:51.430]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.430]  - seeds: <none>
[17:44:51.431]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.431] getGlobalsAndPackages() ...
[17:44:51.431] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.431] Resolving globals: FALSE
[17:44:51.431] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:51.432] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:51.432] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.432] 
[17:44:51.432] getGlobalsAndPackages() ... DONE
[17:44:51.432] run() for ‘Future’ ...
[17:44:51.432] - state: ‘created’
[17:44:51.433] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.446]   - Field: ‘node’
[17:44:51.446]   - Field: ‘label’
[17:44:51.446]   - Field: ‘local’
[17:44:51.447]   - Field: ‘owner’
[17:44:51.447]   - Field: ‘envir’
[17:44:51.447]   - Field: ‘workers’
[17:44:51.447]   - Field: ‘packages’
[17:44:51.447]   - Field: ‘gc’
[17:44:51.447]   - Field: ‘conditions’
[17:44:51.447]   - Field: ‘persistent’
[17:44:51.447]   - Field: ‘expr’
[17:44:51.447]   - Field: ‘uuid’
[17:44:51.447]   - Field: ‘seed’
[17:44:51.447]   - Field: ‘version’
[17:44:51.448]   - Field: ‘result’
[17:44:51.448]   - Field: ‘asynchronous’
[17:44:51.448]   - Field: ‘calls’
[17:44:51.448]   - Field: ‘globals’
[17:44:51.448]   - Field: ‘stdout’
[17:44:51.448]   - Field: ‘earlySignal’
[17:44:51.448]   - Field: ‘lazy’
[17:44:51.448]   - Field: ‘state’
[17:44:51.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.448] - Launch lazy future ...
[17:44:51.449] Packages needed by the future expression (n = 0): <none>
[17:44:51.449] Packages needed by future strategies (n = 0): <none>
[17:44:51.449] {
[17:44:51.449]     {
[17:44:51.449]         {
[17:44:51.449]             ...future.startTime <- base::Sys.time()
[17:44:51.449]             {
[17:44:51.449]                 {
[17:44:51.449]                   {
[17:44:51.449]                     {
[17:44:51.449]                       base::local({
[17:44:51.449]                         has_future <- base::requireNamespace("future", 
[17:44:51.449]                           quietly = TRUE)
[17:44:51.449]                         if (has_future) {
[17:44:51.449]                           ns <- base::getNamespace("future")
[17:44:51.449]                           version <- ns[[".package"]][["version"]]
[17:44:51.449]                           if (is.null(version)) 
[17:44:51.449]                             version <- utils::packageVersion("future")
[17:44:51.449]                         }
[17:44:51.449]                         else {
[17:44:51.449]                           version <- NULL
[17:44:51.449]                         }
[17:44:51.449]                         if (!has_future || version < "1.8.0") {
[17:44:51.449]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.449]                             "", base::R.version$version.string), 
[17:44:51.449]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.449]                               "release", "version")], collapse = " "), 
[17:44:51.449]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.449]                             info)
[17:44:51.449]                           info <- base::paste(info, collapse = "; ")
[17:44:51.449]                           if (!has_future) {
[17:44:51.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.449]                               info)
[17:44:51.449]                           }
[17:44:51.449]                           else {
[17:44:51.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.449]                               info, version)
[17:44:51.449]                           }
[17:44:51.449]                           base::stop(msg)
[17:44:51.449]                         }
[17:44:51.449]                       })
[17:44:51.449]                     }
[17:44:51.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.449]                     base::options(mc.cores = 1L)
[17:44:51.449]                   }
[17:44:51.449]                   ...future.strategy.old <- future::plan("list")
[17:44:51.449]                   options(future.plan = NULL)
[17:44:51.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.449]                 }
[17:44:51.449]                 ...future.workdir <- getwd()
[17:44:51.449]             }
[17:44:51.449]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.449]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.449]         }
[17:44:51.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:51.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.449]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.449]             base::names(...future.oldOptions))
[17:44:51.449]     }
[17:44:51.449]     if (FALSE) {
[17:44:51.449]     }
[17:44:51.449]     else {
[17:44:51.449]         if (TRUE) {
[17:44:51.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.449]                 open = "w")
[17:44:51.449]         }
[17:44:51.449]         else {
[17:44:51.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.449]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.449]         }
[17:44:51.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.449]             base::sink(type = "output", split = FALSE)
[17:44:51.449]             base::close(...future.stdout)
[17:44:51.449]         }, add = TRUE)
[17:44:51.449]     }
[17:44:51.449]     ...future.frame <- base::sys.nframe()
[17:44:51.449]     ...future.conditions <- base::list()
[17:44:51.449]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.449]     if (FALSE) {
[17:44:51.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.449]     }
[17:44:51.449]     ...future.result <- base::tryCatch({
[17:44:51.449]         base::withCallingHandlers({
[17:44:51.449]             ...future.value <- base::withVisible(base::local({
[17:44:51.449]                 ...future.makeSendCondition <- base::local({
[17:44:51.449]                   sendCondition <- NULL
[17:44:51.449]                   function(frame = 1L) {
[17:44:51.449]                     if (is.function(sendCondition)) 
[17:44:51.449]                       return(sendCondition)
[17:44:51.449]                     ns <- getNamespace("parallel")
[17:44:51.449]                     if (exists("sendData", mode = "function", 
[17:44:51.449]                       envir = ns)) {
[17:44:51.449]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.449]                         envir = ns)
[17:44:51.449]                       envir <- sys.frame(frame)
[17:44:51.449]                       master <- NULL
[17:44:51.449]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.449]                         !identical(envir, emptyenv())) {
[17:44:51.449]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.449]                           inherits = FALSE)) {
[17:44:51.449]                           master <- get("master", mode = "list", 
[17:44:51.449]                             envir = envir, inherits = FALSE)
[17:44:51.449]                           if (inherits(master, c("SOCKnode", 
[17:44:51.449]                             "SOCK0node"))) {
[17:44:51.449]                             sendCondition <<- function(cond) {
[17:44:51.449]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.449]                                 success = TRUE)
[17:44:51.449]                               parallel_sendData(master, data)
[17:44:51.449]                             }
[17:44:51.449]                             return(sendCondition)
[17:44:51.449]                           }
[17:44:51.449]                         }
[17:44:51.449]                         frame <- frame + 1L
[17:44:51.449]                         envir <- sys.frame(frame)
[17:44:51.449]                       }
[17:44:51.449]                     }
[17:44:51.449]                     sendCondition <<- function(cond) NULL
[17:44:51.449]                   }
[17:44:51.449]                 })
[17:44:51.449]                 withCallingHandlers({
[17:44:51.449]                   {
[17:44:51.449]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.449]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.449]                       ...future.globals.maxSize)) {
[17:44:51.449]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.449]                       on.exit(options(oopts), add = TRUE)
[17:44:51.449]                     }
[17:44:51.449]                     {
[17:44:51.449]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.449]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.449]                         USE.NAMES = FALSE)
[17:44:51.449]                       do.call(mapply, args = args)
[17:44:51.449]                     }
[17:44:51.449]                   }
[17:44:51.449]                 }, immediateCondition = function(cond) {
[17:44:51.449]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.449]                   sendCondition(cond)
[17:44:51.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.449]                   {
[17:44:51.449]                     inherits <- base::inherits
[17:44:51.449]                     invokeRestart <- base::invokeRestart
[17:44:51.449]                     is.null <- base::is.null
[17:44:51.449]                     muffled <- FALSE
[17:44:51.449]                     if (inherits(cond, "message")) {
[17:44:51.449]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.449]                       if (muffled) 
[17:44:51.449]                         invokeRestart("muffleMessage")
[17:44:51.449]                     }
[17:44:51.449]                     else if (inherits(cond, "warning")) {
[17:44:51.449]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.449]                       if (muffled) 
[17:44:51.449]                         invokeRestart("muffleWarning")
[17:44:51.449]                     }
[17:44:51.449]                     else if (inherits(cond, "condition")) {
[17:44:51.449]                       if (!is.null(pattern)) {
[17:44:51.449]                         computeRestarts <- base::computeRestarts
[17:44:51.449]                         grepl <- base::grepl
[17:44:51.449]                         restarts <- computeRestarts(cond)
[17:44:51.449]                         for (restart in restarts) {
[17:44:51.449]                           name <- restart$name
[17:44:51.449]                           if (is.null(name)) 
[17:44:51.449]                             next
[17:44:51.449]                           if (!grepl(pattern, name)) 
[17:44:51.449]                             next
[17:44:51.449]                           invokeRestart(restart)
[17:44:51.449]                           muffled <- TRUE
[17:44:51.449]                           break
[17:44:51.449]                         }
[17:44:51.449]                       }
[17:44:51.449]                     }
[17:44:51.449]                     invisible(muffled)
[17:44:51.449]                   }
[17:44:51.449]                   muffleCondition(cond)
[17:44:51.449]                 })
[17:44:51.449]             }))
[17:44:51.449]             future::FutureResult(value = ...future.value$value, 
[17:44:51.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.449]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.449]                     ...future.globalenv.names))
[17:44:51.449]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.449]         }, condition = base::local({
[17:44:51.449]             c <- base::c
[17:44:51.449]             inherits <- base::inherits
[17:44:51.449]             invokeRestart <- base::invokeRestart
[17:44:51.449]             length <- base::length
[17:44:51.449]             list <- base::list
[17:44:51.449]             seq.int <- base::seq.int
[17:44:51.449]             signalCondition <- base::signalCondition
[17:44:51.449]             sys.calls <- base::sys.calls
[17:44:51.449]             `[[` <- base::`[[`
[17:44:51.449]             `+` <- base::`+`
[17:44:51.449]             `<<-` <- base::`<<-`
[17:44:51.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.449]                   3L)]
[17:44:51.449]             }
[17:44:51.449]             function(cond) {
[17:44:51.449]                 is_error <- inherits(cond, "error")
[17:44:51.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.449]                   NULL)
[17:44:51.449]                 if (is_error) {
[17:44:51.449]                   sessionInformation <- function() {
[17:44:51.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.449]                       search = base::search(), system = base::Sys.info())
[17:44:51.449]                   }
[17:44:51.449]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.449]                     cond$call), session = sessionInformation(), 
[17:44:51.449]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.449]                   signalCondition(cond)
[17:44:51.449]                 }
[17:44:51.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.449]                 "immediateCondition"))) {
[17:44:51.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.449]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.449]                   if (TRUE && !signal) {
[17:44:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.449]                     {
[17:44:51.449]                       inherits <- base::inherits
[17:44:51.449]                       invokeRestart <- base::invokeRestart
[17:44:51.449]                       is.null <- base::is.null
[17:44:51.449]                       muffled <- FALSE
[17:44:51.449]                       if (inherits(cond, "message")) {
[17:44:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.449]                         if (muffled) 
[17:44:51.449]                           invokeRestart("muffleMessage")
[17:44:51.449]                       }
[17:44:51.449]                       else if (inherits(cond, "warning")) {
[17:44:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.449]                         if (muffled) 
[17:44:51.449]                           invokeRestart("muffleWarning")
[17:44:51.449]                       }
[17:44:51.449]                       else if (inherits(cond, "condition")) {
[17:44:51.449]                         if (!is.null(pattern)) {
[17:44:51.449]                           computeRestarts <- base::computeRestarts
[17:44:51.449]                           grepl <- base::grepl
[17:44:51.449]                           restarts <- computeRestarts(cond)
[17:44:51.449]                           for (restart in restarts) {
[17:44:51.449]                             name <- restart$name
[17:44:51.449]                             if (is.null(name)) 
[17:44:51.449]                               next
[17:44:51.449]                             if (!grepl(pattern, name)) 
[17:44:51.449]                               next
[17:44:51.449]                             invokeRestart(restart)
[17:44:51.449]                             muffled <- TRUE
[17:44:51.449]                             break
[17:44:51.449]                           }
[17:44:51.449]                         }
[17:44:51.449]                       }
[17:44:51.449]                       invisible(muffled)
[17:44:51.449]                     }
[17:44:51.449]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.449]                   }
[17:44:51.449]                 }
[17:44:51.449]                 else {
[17:44:51.449]                   if (TRUE) {
[17:44:51.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.449]                     {
[17:44:51.449]                       inherits <- base::inherits
[17:44:51.449]                       invokeRestart <- base::invokeRestart
[17:44:51.449]                       is.null <- base::is.null
[17:44:51.449]                       muffled <- FALSE
[17:44:51.449]                       if (inherits(cond, "message")) {
[17:44:51.449]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.449]                         if (muffled) 
[17:44:51.449]                           invokeRestart("muffleMessage")
[17:44:51.449]                       }
[17:44:51.449]                       else if (inherits(cond, "warning")) {
[17:44:51.449]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.449]                         if (muffled) 
[17:44:51.449]                           invokeRestart("muffleWarning")
[17:44:51.449]                       }
[17:44:51.449]                       else if (inherits(cond, "condition")) {
[17:44:51.449]                         if (!is.null(pattern)) {
[17:44:51.449]                           computeRestarts <- base::computeRestarts
[17:44:51.449]                           grepl <- base::grepl
[17:44:51.449]                           restarts <- computeRestarts(cond)
[17:44:51.449]                           for (restart in restarts) {
[17:44:51.449]                             name <- restart$name
[17:44:51.449]                             if (is.null(name)) 
[17:44:51.449]                               next
[17:44:51.449]                             if (!grepl(pattern, name)) 
[17:44:51.449]                               next
[17:44:51.449]                             invokeRestart(restart)
[17:44:51.449]                             muffled <- TRUE
[17:44:51.449]                             break
[17:44:51.449]                           }
[17:44:51.449]                         }
[17:44:51.449]                       }
[17:44:51.449]                       invisible(muffled)
[17:44:51.449]                     }
[17:44:51.449]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.449]                   }
[17:44:51.449]                 }
[17:44:51.449]             }
[17:44:51.449]         }))
[17:44:51.449]     }, error = function(ex) {
[17:44:51.449]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.449]                 ...future.rng), started = ...future.startTime, 
[17:44:51.449]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.449]             version = "1.8"), class = "FutureResult")
[17:44:51.449]     }, finally = {
[17:44:51.449]         if (!identical(...future.workdir, getwd())) 
[17:44:51.449]             setwd(...future.workdir)
[17:44:51.449]         {
[17:44:51.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.449]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.449]             }
[17:44:51.449]             base::options(...future.oldOptions)
[17:44:51.449]             if (.Platform$OS.type == "windows") {
[17:44:51.449]                 old_names <- names(...future.oldEnvVars)
[17:44:51.449]                 envs <- base::Sys.getenv()
[17:44:51.449]                 names <- names(envs)
[17:44:51.449]                 common <- intersect(names, old_names)
[17:44:51.449]                 added <- setdiff(names, old_names)
[17:44:51.449]                 removed <- setdiff(old_names, names)
[17:44:51.449]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.449]                   envs[common]]
[17:44:51.449]                 NAMES <- toupper(changed)
[17:44:51.449]                 args <- list()
[17:44:51.449]                 for (kk in seq_along(NAMES)) {
[17:44:51.449]                   name <- changed[[kk]]
[17:44:51.449]                   NAME <- NAMES[[kk]]
[17:44:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.449]                     next
[17:44:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.449]                 }
[17:44:51.449]                 NAMES <- toupper(added)
[17:44:51.449]                 for (kk in seq_along(NAMES)) {
[17:44:51.449]                   name <- added[[kk]]
[17:44:51.449]                   NAME <- NAMES[[kk]]
[17:44:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.449]                     next
[17:44:51.449]                   args[[name]] <- ""
[17:44:51.449]                 }
[17:44:51.449]                 NAMES <- toupper(removed)
[17:44:51.449]                 for (kk in seq_along(NAMES)) {
[17:44:51.449]                   name <- removed[[kk]]
[17:44:51.449]                   NAME <- NAMES[[kk]]
[17:44:51.449]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.449]                     next
[17:44:51.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.449]                 }
[17:44:51.449]                 if (length(args) > 0) 
[17:44:51.449]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.449]             }
[17:44:51.449]             else {
[17:44:51.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.449]             }
[17:44:51.449]             {
[17:44:51.449]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.449]                   0L) {
[17:44:51.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.449]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.449]                   base::options(opts)
[17:44:51.449]                 }
[17:44:51.449]                 {
[17:44:51.449]                   {
[17:44:51.449]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.449]                     NULL
[17:44:51.449]                   }
[17:44:51.449]                   options(future.plan = NULL)
[17:44:51.449]                   if (is.na(NA_character_)) 
[17:44:51.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.449]                     .init = FALSE)
[17:44:51.449]                 }
[17:44:51.449]             }
[17:44:51.449]         }
[17:44:51.449]     })
[17:44:51.449]     if (TRUE) {
[17:44:51.449]         base::sink(type = "output", split = FALSE)
[17:44:51.449]         if (TRUE) {
[17:44:51.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.449]         }
[17:44:51.449]         else {
[17:44:51.449]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.449]         }
[17:44:51.449]         base::close(...future.stdout)
[17:44:51.449]         ...future.stdout <- NULL
[17:44:51.449]     }
[17:44:51.449]     ...future.result$conditions <- ...future.conditions
[17:44:51.449]     ...future.result$finished <- base::Sys.time()
[17:44:51.449]     ...future.result
[17:44:51.449] }
[17:44:51.452] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:44:51.452] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:44:51.452] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:44:51.452] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.453] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.453] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:44:51.453] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:44:51.453] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.454] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.454] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.454] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.454] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:44:51.454] MultisessionFuture started
[17:44:51.455] - Launch lazy future ... done
[17:44:51.455] run() for ‘MultisessionFuture’ ... done
[17:44:51.455] Created future:
[17:44:51.455] MultisessionFuture:
[17:44:51.455] Label: ‘future_mapply-1’
[17:44:51.455] Expression:
[17:44:51.455] {
[17:44:51.455]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.455]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.455]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.455]         on.exit(options(oopts), add = TRUE)
[17:44:51.455]     }
[17:44:51.455]     {
[17:44:51.455]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.455]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.455]         do.call(mapply, args = args)
[17:44:51.455]     }
[17:44:51.455] }
[17:44:51.455] Lazy evaluation: FALSE
[17:44:51.455] Asynchronous evaluation: TRUE
[17:44:51.455] Local evaluation: TRUE
[17:44:51.455] Environment: R_GlobalEnv
[17:44:51.455] Capture standard output: TRUE
[17:44:51.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.455] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.455] Packages: <none>
[17:44:51.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.455] Resolved: FALSE
[17:44:51.455] Value: <not collected>
[17:44:51.455] Conditions captured: <none>
[17:44:51.455] Early signaling: FALSE
[17:44:51.455] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.455] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.466] Chunk #1 of 1 ... DONE
[17:44:51.466] Launching 1 futures (chunks) ... DONE
[17:44:51.466] Resolving 1 futures (chunks) ...
[17:44:51.467] resolve() on list ...
[17:44:51.467]  recursive: 0
[17:44:51.467]  length: 1
[17:44:51.467] 
[17:44:51.497] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.497] - Validating connection of MultisessionFuture
[17:44:51.497] - received message: FutureResult
[17:44:51.497] - Received FutureResult
[17:44:51.497] - Erased future from FutureRegistry
[17:44:51.497] result() for ClusterFuture ...
[17:44:51.497] - result already collected: FutureResult
[17:44:51.498] result() for ClusterFuture ... done
[17:44:51.498] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.498] Future #1
[17:44:51.498] result() for ClusterFuture ...
[17:44:51.498] - result already collected: FutureResult
[17:44:51.498] result() for ClusterFuture ... done
[17:44:51.498] result() for ClusterFuture ...
[17:44:51.498] - result already collected: FutureResult
[17:44:51.498] result() for ClusterFuture ... done
[17:44:51.498] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.498] - nx: 1
[17:44:51.498] - relay: TRUE
[17:44:51.499] - stdout: TRUE
[17:44:51.499] - signal: TRUE
[17:44:51.499] - resignal: FALSE
[17:44:51.499] - force: TRUE
[17:44:51.499] - relayed: [n=1] FALSE
[17:44:51.499] - queued futures: [n=1] FALSE
[17:44:51.499]  - until=1
[17:44:51.499]  - relaying element #1
[17:44:51.499] result() for ClusterFuture ...
[17:44:51.499] - result already collected: FutureResult
[17:44:51.499] result() for ClusterFuture ... done
[17:44:51.500] result() for ClusterFuture ...
[17:44:51.500] - result already collected: FutureResult
[17:44:51.500] result() for ClusterFuture ... done
[17:44:51.500] result() for ClusterFuture ...
[17:44:51.500] - result already collected: FutureResult
[17:44:51.500] result() for ClusterFuture ... done
[17:44:51.500] result() for ClusterFuture ...
[17:44:51.500] - result already collected: FutureResult
[17:44:51.500] result() for ClusterFuture ... done
[17:44:51.500] - relayed: [n=1] TRUE
[17:44:51.500] - queued futures: [n=1] TRUE
[17:44:51.500] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.501]  length: 0 (resolved future 1)
[17:44:51.501] Relaying remaining futures
[17:44:51.501] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.501] - nx: 1
[17:44:51.501] - relay: TRUE
[17:44:51.501] - stdout: TRUE
[17:44:51.501] - signal: TRUE
[17:44:51.501] - resignal: FALSE
[17:44:51.501] - force: TRUE
[17:44:51.501] - relayed: [n=1] TRUE
[17:44:51.501] - queued futures: [n=1] TRUE
 - flush all
[17:44:51.502] - relayed: [n=1] TRUE
[17:44:51.502] - queued futures: [n=1] TRUE
[17:44:51.502] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.502] resolve() on list ... DONE
[17:44:51.502] result() for ClusterFuture ...
[17:44:51.502] - result already collected: FutureResult
[17:44:51.502] result() for ClusterFuture ... done
[17:44:51.502] result() for ClusterFuture ...
[17:44:51.502] - result already collected: FutureResult
[17:44:51.502] result() for ClusterFuture ... done
[17:44:51.502]  - Number of value chunks collected: 1
[17:44:51.502] Resolving 1 futures (chunks) ... DONE
[17:44:51.503] Reducing values from 1 chunks ...
[17:44:51.503]  - Number of values collected after concatenation: 1
[17:44:51.503]  - Number of values expected: 1
[17:44:51.503] Reducing values from 1 chunks ... DONE
[17:44:51.503] future_mapply() ... DONE
[17:44:51.503] future_mapply() ...
[17:44:51.506] Number of chunks: 1
[17:44:51.506] getGlobalsAndPackagesXApply() ...
[17:44:51.507]  - future.globals: TRUE
[17:44:51.507] getGlobalsAndPackages() ...
[17:44:51.507] Searching for globals...
[17:44:51.508] - globals found: [1] ‘FUN’
[17:44:51.508] Searching for globals ... DONE
[17:44:51.508] Resolving globals: FALSE
[17:44:51.508] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:51.509] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:51.509] - globals: [1] ‘FUN’
[17:44:51.509] 
[17:44:51.509] getGlobalsAndPackages() ... DONE
[17:44:51.509]  - globals found/used: [n=1] ‘FUN’
[17:44:51.509]  - needed namespaces: [n=0] 
[17:44:51.509] Finding globals ... DONE
[17:44:51.509] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.509] List of 2
[17:44:51.509]  $ ...future.FUN:function (x)  
[17:44:51.509]  $ MoreArgs     : list()
[17:44:51.509]  - attr(*, "where")=List of 2
[17:44:51.509]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.509]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.509]  - attr(*, "resolved")= logi FALSE
[17:44:51.509]  - attr(*, "total_size")= num NA
[17:44:51.512] Packages to be attached in all futures: [n=0] 
[17:44:51.512] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.512] Number of futures (= number of chunks): 1
[17:44:51.512] Launching 1 futures (chunks) ...
[17:44:51.512] Chunk #1 of 1 ...
[17:44:51.512]  - Finding globals in '...' for chunk #1 ...
[17:44:51.513] getGlobalsAndPackages() ...
[17:44:51.513] Searching for globals...
[17:44:51.513] 
[17:44:51.513] Searching for globals ... DONE
[17:44:51.513] - globals: [0] <none>
[17:44:51.513] getGlobalsAndPackages() ... DONE
[17:44:51.513]    + additional globals found: [n=0] 
[17:44:51.513]    + additional namespaces needed: [n=0] 
[17:44:51.513]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.513]  - seeds: <none>
[17:44:51.514]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.514] getGlobalsAndPackages() ...
[17:44:51.514] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.514] Resolving globals: FALSE
[17:44:51.514] The total size of the 5 globals is 1.10 KiB (1128 bytes)
[17:44:51.515] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.10 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (280 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘list’)
[17:44:51.515] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.515] 
[17:44:51.515] getGlobalsAndPackages() ... DONE
[17:44:51.515] run() for ‘Future’ ...
[17:44:51.515] - state: ‘created’
[17:44:51.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.529] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.529]   - Field: ‘node’
[17:44:51.529]   - Field: ‘label’
[17:44:51.530]   - Field: ‘local’
[17:44:51.530]   - Field: ‘owner’
[17:44:51.530]   - Field: ‘envir’
[17:44:51.530]   - Field: ‘workers’
[17:44:51.530]   - Field: ‘packages’
[17:44:51.530]   - Field: ‘gc’
[17:44:51.530]   - Field: ‘conditions’
[17:44:51.530]   - Field: ‘persistent’
[17:44:51.530]   - Field: ‘expr’
[17:44:51.530]   - Field: ‘uuid’
[17:44:51.530]   - Field: ‘seed’
[17:44:51.531]   - Field: ‘version’
[17:44:51.531]   - Field: ‘result’
[17:44:51.531]   - Field: ‘asynchronous’
[17:44:51.531]   - Field: ‘calls’
[17:44:51.531]   - Field: ‘globals’
[17:44:51.531]   - Field: ‘stdout’
[17:44:51.531]   - Field: ‘earlySignal’
[17:44:51.531]   - Field: ‘lazy’
[17:44:51.531]   - Field: ‘state’
[17:44:51.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.531] - Launch lazy future ...
[17:44:51.532] Packages needed by the future expression (n = 0): <none>
[17:44:51.532] Packages needed by future strategies (n = 0): <none>
[17:44:51.532] {
[17:44:51.532]     {
[17:44:51.532]         {
[17:44:51.532]             ...future.startTime <- base::Sys.time()
[17:44:51.532]             {
[17:44:51.532]                 {
[17:44:51.532]                   {
[17:44:51.532]                     {
[17:44:51.532]                       base::local({
[17:44:51.532]                         has_future <- base::requireNamespace("future", 
[17:44:51.532]                           quietly = TRUE)
[17:44:51.532]                         if (has_future) {
[17:44:51.532]                           ns <- base::getNamespace("future")
[17:44:51.532]                           version <- ns[[".package"]][["version"]]
[17:44:51.532]                           if (is.null(version)) 
[17:44:51.532]                             version <- utils::packageVersion("future")
[17:44:51.532]                         }
[17:44:51.532]                         else {
[17:44:51.532]                           version <- NULL
[17:44:51.532]                         }
[17:44:51.532]                         if (!has_future || version < "1.8.0") {
[17:44:51.532]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.532]                             "", base::R.version$version.string), 
[17:44:51.532]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.532]                               "release", "version")], collapse = " "), 
[17:44:51.532]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.532]                             info)
[17:44:51.532]                           info <- base::paste(info, collapse = "; ")
[17:44:51.532]                           if (!has_future) {
[17:44:51.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.532]                               info)
[17:44:51.532]                           }
[17:44:51.532]                           else {
[17:44:51.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.532]                               info, version)
[17:44:51.532]                           }
[17:44:51.532]                           base::stop(msg)
[17:44:51.532]                         }
[17:44:51.532]                       })
[17:44:51.532]                     }
[17:44:51.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.532]                     base::options(mc.cores = 1L)
[17:44:51.532]                   }
[17:44:51.532]                   ...future.strategy.old <- future::plan("list")
[17:44:51.532]                   options(future.plan = NULL)
[17:44:51.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.532]                 }
[17:44:51.532]                 ...future.workdir <- getwd()
[17:44:51.532]             }
[17:44:51.532]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.532]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.532]         }
[17:44:51.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:44:51.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.532]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.532]             base::names(...future.oldOptions))
[17:44:51.532]     }
[17:44:51.532]     if (FALSE) {
[17:44:51.532]     }
[17:44:51.532]     else {
[17:44:51.532]         if (TRUE) {
[17:44:51.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.532]                 open = "w")
[17:44:51.532]         }
[17:44:51.532]         else {
[17:44:51.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.532]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.532]         }
[17:44:51.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.532]             base::sink(type = "output", split = FALSE)
[17:44:51.532]             base::close(...future.stdout)
[17:44:51.532]         }, add = TRUE)
[17:44:51.532]     }
[17:44:51.532]     ...future.frame <- base::sys.nframe()
[17:44:51.532]     ...future.conditions <- base::list()
[17:44:51.532]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.532]     if (FALSE) {
[17:44:51.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.532]     }
[17:44:51.532]     ...future.result <- base::tryCatch({
[17:44:51.532]         base::withCallingHandlers({
[17:44:51.532]             ...future.value <- base::withVisible(base::local({
[17:44:51.532]                 ...future.makeSendCondition <- base::local({
[17:44:51.532]                   sendCondition <- NULL
[17:44:51.532]                   function(frame = 1L) {
[17:44:51.532]                     if (is.function(sendCondition)) 
[17:44:51.532]                       return(sendCondition)
[17:44:51.532]                     ns <- getNamespace("parallel")
[17:44:51.532]                     if (exists("sendData", mode = "function", 
[17:44:51.532]                       envir = ns)) {
[17:44:51.532]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.532]                         envir = ns)
[17:44:51.532]                       envir <- sys.frame(frame)
[17:44:51.532]                       master <- NULL
[17:44:51.532]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.532]                         !identical(envir, emptyenv())) {
[17:44:51.532]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.532]                           inherits = FALSE)) {
[17:44:51.532]                           master <- get("master", mode = "list", 
[17:44:51.532]                             envir = envir, inherits = FALSE)
[17:44:51.532]                           if (inherits(master, c("SOCKnode", 
[17:44:51.532]                             "SOCK0node"))) {
[17:44:51.532]                             sendCondition <<- function(cond) {
[17:44:51.532]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.532]                                 success = TRUE)
[17:44:51.532]                               parallel_sendData(master, data)
[17:44:51.532]                             }
[17:44:51.532]                             return(sendCondition)
[17:44:51.532]                           }
[17:44:51.532]                         }
[17:44:51.532]                         frame <- frame + 1L
[17:44:51.532]                         envir <- sys.frame(frame)
[17:44:51.532]                       }
[17:44:51.532]                     }
[17:44:51.532]                     sendCondition <<- function(cond) NULL
[17:44:51.532]                   }
[17:44:51.532]                 })
[17:44:51.532]                 withCallingHandlers({
[17:44:51.532]                   {
[17:44:51.532]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.532]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.532]                       ...future.globals.maxSize)) {
[17:44:51.532]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.532]                       on.exit(options(oopts), add = TRUE)
[17:44:51.532]                     }
[17:44:51.532]                     {
[17:44:51.532]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.532]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.532]                         USE.NAMES = FALSE)
[17:44:51.532]                       do.call(mapply, args = args)
[17:44:51.532]                     }
[17:44:51.532]                   }
[17:44:51.532]                 }, immediateCondition = function(cond) {
[17:44:51.532]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.532]                   sendCondition(cond)
[17:44:51.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.532]                   {
[17:44:51.532]                     inherits <- base::inherits
[17:44:51.532]                     invokeRestart <- base::invokeRestart
[17:44:51.532]                     is.null <- base::is.null
[17:44:51.532]                     muffled <- FALSE
[17:44:51.532]                     if (inherits(cond, "message")) {
[17:44:51.532]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.532]                       if (muffled) 
[17:44:51.532]                         invokeRestart("muffleMessage")
[17:44:51.532]                     }
[17:44:51.532]                     else if (inherits(cond, "warning")) {
[17:44:51.532]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.532]                       if (muffled) 
[17:44:51.532]                         invokeRestart("muffleWarning")
[17:44:51.532]                     }
[17:44:51.532]                     else if (inherits(cond, "condition")) {
[17:44:51.532]                       if (!is.null(pattern)) {
[17:44:51.532]                         computeRestarts <- base::computeRestarts
[17:44:51.532]                         grepl <- base::grepl
[17:44:51.532]                         restarts <- computeRestarts(cond)
[17:44:51.532]                         for (restart in restarts) {
[17:44:51.532]                           name <- restart$name
[17:44:51.532]                           if (is.null(name)) 
[17:44:51.532]                             next
[17:44:51.532]                           if (!grepl(pattern, name)) 
[17:44:51.532]                             next
[17:44:51.532]                           invokeRestart(restart)
[17:44:51.532]                           muffled <- TRUE
[17:44:51.532]                           break
[17:44:51.532]                         }
[17:44:51.532]                       }
[17:44:51.532]                     }
[17:44:51.532]                     invisible(muffled)
[17:44:51.532]                   }
[17:44:51.532]                   muffleCondition(cond)
[17:44:51.532]                 })
[17:44:51.532]             }))
[17:44:51.532]             future::FutureResult(value = ...future.value$value, 
[17:44:51.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.532]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.532]                     ...future.globalenv.names))
[17:44:51.532]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.532]         }, condition = base::local({
[17:44:51.532]             c <- base::c
[17:44:51.532]             inherits <- base::inherits
[17:44:51.532]             invokeRestart <- base::invokeRestart
[17:44:51.532]             length <- base::length
[17:44:51.532]             list <- base::list
[17:44:51.532]             seq.int <- base::seq.int
[17:44:51.532]             signalCondition <- base::signalCondition
[17:44:51.532]             sys.calls <- base::sys.calls
[17:44:51.532]             `[[` <- base::`[[`
[17:44:51.532]             `+` <- base::`+`
[17:44:51.532]             `<<-` <- base::`<<-`
[17:44:51.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.532]                   3L)]
[17:44:51.532]             }
[17:44:51.532]             function(cond) {
[17:44:51.532]                 is_error <- inherits(cond, "error")
[17:44:51.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.532]                   NULL)
[17:44:51.532]                 if (is_error) {
[17:44:51.532]                   sessionInformation <- function() {
[17:44:51.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.532]                       search = base::search(), system = base::Sys.info())
[17:44:51.532]                   }
[17:44:51.532]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.532]                     cond$call), session = sessionInformation(), 
[17:44:51.532]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.532]                   signalCondition(cond)
[17:44:51.532]                 }
[17:44:51.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.532]                 "immediateCondition"))) {
[17:44:51.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.532]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.532]                   if (TRUE && !signal) {
[17:44:51.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.532]                     {
[17:44:51.532]                       inherits <- base::inherits
[17:44:51.532]                       invokeRestart <- base::invokeRestart
[17:44:51.532]                       is.null <- base::is.null
[17:44:51.532]                       muffled <- FALSE
[17:44:51.532]                       if (inherits(cond, "message")) {
[17:44:51.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.532]                         if (muffled) 
[17:44:51.532]                           invokeRestart("muffleMessage")
[17:44:51.532]                       }
[17:44:51.532]                       else if (inherits(cond, "warning")) {
[17:44:51.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.532]                         if (muffled) 
[17:44:51.532]                           invokeRestart("muffleWarning")
[17:44:51.532]                       }
[17:44:51.532]                       else if (inherits(cond, "condition")) {
[17:44:51.532]                         if (!is.null(pattern)) {
[17:44:51.532]                           computeRestarts <- base::computeRestarts
[17:44:51.532]                           grepl <- base::grepl
[17:44:51.532]                           restarts <- computeRestarts(cond)
[17:44:51.532]                           for (restart in restarts) {
[17:44:51.532]                             name <- restart$name
[17:44:51.532]                             if (is.null(name)) 
[17:44:51.532]                               next
[17:44:51.532]                             if (!grepl(pattern, name)) 
[17:44:51.532]                               next
[17:44:51.532]                             invokeRestart(restart)
[17:44:51.532]                             muffled <- TRUE
[17:44:51.532]                             break
[17:44:51.532]                           }
[17:44:51.532]                         }
[17:44:51.532]                       }
[17:44:51.532]                       invisible(muffled)
[17:44:51.532]                     }
[17:44:51.532]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.532]                   }
[17:44:51.532]                 }
[17:44:51.532]                 else {
[17:44:51.532]                   if (TRUE) {
[17:44:51.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.532]                     {
[17:44:51.532]                       inherits <- base::inherits
[17:44:51.532]                       invokeRestart <- base::invokeRestart
[17:44:51.532]                       is.null <- base::is.null
[17:44:51.532]                       muffled <- FALSE
[17:44:51.532]                       if (inherits(cond, "message")) {
[17:44:51.532]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.532]                         if (muffled) 
[17:44:51.532]                           invokeRestart("muffleMessage")
[17:44:51.532]                       }
[17:44:51.532]                       else if (inherits(cond, "warning")) {
[17:44:51.532]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.532]                         if (muffled) 
[17:44:51.532]                           invokeRestart("muffleWarning")
[17:44:51.532]                       }
[17:44:51.532]                       else if (inherits(cond, "condition")) {
[17:44:51.532]                         if (!is.null(pattern)) {
[17:44:51.532]                           computeRestarts <- base::computeRestarts
[17:44:51.532]                           grepl <- base::grepl
[17:44:51.532]                           restarts <- computeRestarts(cond)
[17:44:51.532]                           for (restart in restarts) {
[17:44:51.532]                             name <- restart$name
[17:44:51.532]                             if (is.null(name)) 
[17:44:51.532]                               next
[17:44:51.532]                             if (!grepl(pattern, name)) 
[17:44:51.532]                               next
[17:44:51.532]                             invokeRestart(restart)
[17:44:51.532]                             muffled <- TRUE
[17:44:51.532]                             break
[17:44:51.532]                           }
[17:44:51.532]                         }
[17:44:51.532]                       }
[17:44:51.532]                       invisible(muffled)
[17:44:51.532]                     }
[17:44:51.532]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.532]                   }
[17:44:51.532]                 }
[17:44:51.532]             }
[17:44:51.532]         }))
[17:44:51.532]     }, error = function(ex) {
[17:44:51.532]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.532]                 ...future.rng), started = ...future.startTime, 
[17:44:51.532]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.532]             version = "1.8"), class = "FutureResult")
[17:44:51.532]     }, finally = {
[17:44:51.532]         if (!identical(...future.workdir, getwd())) 
[17:44:51.532]             setwd(...future.workdir)
[17:44:51.532]         {
[17:44:51.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.532]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.532]             }
[17:44:51.532]             base::options(...future.oldOptions)
[17:44:51.532]             if (.Platform$OS.type == "windows") {
[17:44:51.532]                 old_names <- names(...future.oldEnvVars)
[17:44:51.532]                 envs <- base::Sys.getenv()
[17:44:51.532]                 names <- names(envs)
[17:44:51.532]                 common <- intersect(names, old_names)
[17:44:51.532]                 added <- setdiff(names, old_names)
[17:44:51.532]                 removed <- setdiff(old_names, names)
[17:44:51.532]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.532]                   envs[common]]
[17:44:51.532]                 NAMES <- toupper(changed)
[17:44:51.532]                 args <- list()
[17:44:51.532]                 for (kk in seq_along(NAMES)) {
[17:44:51.532]                   name <- changed[[kk]]
[17:44:51.532]                   NAME <- NAMES[[kk]]
[17:44:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.532]                     next
[17:44:51.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.532]                 }
[17:44:51.532]                 NAMES <- toupper(added)
[17:44:51.532]                 for (kk in seq_along(NAMES)) {
[17:44:51.532]                   name <- added[[kk]]
[17:44:51.532]                   NAME <- NAMES[[kk]]
[17:44:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.532]                     next
[17:44:51.532]                   args[[name]] <- ""
[17:44:51.532]                 }
[17:44:51.532]                 NAMES <- toupper(removed)
[17:44:51.532]                 for (kk in seq_along(NAMES)) {
[17:44:51.532]                   name <- removed[[kk]]
[17:44:51.532]                   NAME <- NAMES[[kk]]
[17:44:51.532]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.532]                     next
[17:44:51.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.532]                 }
[17:44:51.532]                 if (length(args) > 0) 
[17:44:51.532]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.532]             }
[17:44:51.532]             else {
[17:44:51.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.532]             }
[17:44:51.532]             {
[17:44:51.532]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.532]                   0L) {
[17:44:51.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.532]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.532]                   base::options(opts)
[17:44:51.532]                 }
[17:44:51.532]                 {
[17:44:51.532]                   {
[17:44:51.532]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.532]                     NULL
[17:44:51.532]                   }
[17:44:51.532]                   options(future.plan = NULL)
[17:44:51.532]                   if (is.na(NA_character_)) 
[17:44:51.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.532]                     .init = FALSE)
[17:44:51.532]                 }
[17:44:51.532]             }
[17:44:51.532]         }
[17:44:51.532]     })
[17:44:51.532]     if (TRUE) {
[17:44:51.532]         base::sink(type = "output", split = FALSE)
[17:44:51.532]         if (TRUE) {
[17:44:51.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.532]         }
[17:44:51.532]         else {
[17:44:51.532]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.532]         }
[17:44:51.532]         base::close(...future.stdout)
[17:44:51.532]         ...future.stdout <- NULL
[17:44:51.532]     }
[17:44:51.532]     ...future.result$conditions <- ...future.conditions
[17:44:51.532]     ...future.result$finished <- base::Sys.time()
[17:44:51.532]     ...future.result
[17:44:51.532] }
[17:44:51.535] Exporting 5 global objects (1.10 KiB) to cluster node #1 ...
[17:44:51.535] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:44:51.535] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:44:51.535] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.536] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.536] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:44:51.536] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:44:51.536] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.537] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.537] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.537] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.537] Exporting 5 global objects (1.10 KiB) to cluster node #1 ... DONE
[17:44:51.538] MultisessionFuture started
[17:44:51.538] - Launch lazy future ... done
[17:44:51.538] run() for ‘MultisessionFuture’ ... done
[17:44:51.538] Created future:
[17:44:51.538] MultisessionFuture:
[17:44:51.538] Label: ‘future_.mapply-1’
[17:44:51.538] Expression:
[17:44:51.538] {
[17:44:51.538]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.538]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.538]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.538]         on.exit(options(oopts), add = TRUE)
[17:44:51.538]     }
[17:44:51.538]     {
[17:44:51.538]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.538]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.538]         do.call(mapply, args = args)
[17:44:51.538]     }
[17:44:51.538] }
[17:44:51.538] Lazy evaluation: FALSE
[17:44:51.538] Asynchronous evaluation: TRUE
[17:44:51.538] Local evaluation: TRUE
[17:44:51.538] Environment: R_GlobalEnv
[17:44:51.538] Capture standard output: TRUE
[17:44:51.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.538] Globals: 5 objects totaling 1.10 KiB (function ‘...future.FUN’ of 848 bytes, list ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 280 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.538] Packages: <none>
[17:44:51.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.538] Resolved: FALSE
[17:44:51.538] Value: <not collected>
[17:44:51.538] Conditions captured: <none>
[17:44:51.538] Early signaling: FALSE
[17:44:51.538] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.538] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.549] Chunk #1 of 1 ... DONE
[17:44:51.549] Launching 1 futures (chunks) ... DONE
[17:44:51.549] Resolving 1 futures (chunks) ...
[17:44:51.550] resolve() on list ...
[17:44:51.550]  recursive: 0
[17:44:51.550]  length: 1
[17:44:51.550] 
[17:44:51.581] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.581] - Validating connection of MultisessionFuture
[17:44:51.581] - received message: FutureResult
[17:44:51.581] - Received FutureResult
[17:44:51.581] - Erased future from FutureRegistry
[17:44:51.581] result() for ClusterFuture ...
[17:44:51.581] - result already collected: FutureResult
[17:44:51.582] result() for ClusterFuture ... done
[17:44:51.582] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.582] Future #1
[17:44:51.582] result() for ClusterFuture ...
[17:44:51.582] - result already collected: FutureResult
[17:44:51.582] result() for ClusterFuture ... done
[17:44:51.582] result() for ClusterFuture ...
[17:44:51.582] - result already collected: FutureResult
[17:44:51.582] result() for ClusterFuture ... done
[17:44:51.582] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.582] - nx: 1
[17:44:51.583] - relay: TRUE
[17:44:51.583] - stdout: TRUE
[17:44:51.583] - signal: TRUE
[17:44:51.583] - resignal: FALSE
[17:44:51.583] - force: TRUE
[17:44:51.583] - relayed: [n=1] FALSE
[17:44:51.583] - queued futures: [n=1] FALSE
[17:44:51.583]  - until=1
[17:44:51.583]  - relaying element #1
[17:44:51.583] result() for ClusterFuture ...
[17:44:51.583] - result already collected: FutureResult
[17:44:51.583] result() for ClusterFuture ... done
[17:44:51.584] result() for ClusterFuture ...
[17:44:51.584] - result already collected: FutureResult
[17:44:51.584] result() for ClusterFuture ... done
[17:44:51.584] result() for ClusterFuture ...
[17:44:51.584] - result already collected: FutureResult
[17:44:51.584] result() for ClusterFuture ... done
[17:44:51.584] result() for ClusterFuture ...
[17:44:51.584] - result already collected: FutureResult
[17:44:51.584] result() for ClusterFuture ... done
[17:44:51.584] - relayed: [n=1] TRUE
[17:44:51.584] - queued futures: [n=1] TRUE
[17:44:51.585] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.585]  length: 0 (resolved future 1)
[17:44:51.585] Relaying remaining futures
[17:44:51.585] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.585] - nx: 1
[17:44:51.585] - relay: TRUE
[17:44:51.585] - stdout: TRUE
[17:44:51.585] - signal: TRUE
[17:44:51.585] - resignal: FALSE
[17:44:51.585] - force: TRUE
[17:44:51.585] - relayed: [n=1] TRUE
[17:44:51.585] - queued futures: [n=1] TRUE
 - flush all
[17:44:51.586] - relayed: [n=1] TRUE
[17:44:51.586] - queued futures: [n=1] TRUE
[17:44:51.586] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.586] resolve() on list ... DONE
[17:44:51.586] result() for ClusterFuture ...
[17:44:51.586] - result already collected: FutureResult
[17:44:51.586] result() for ClusterFuture ... done
[17:44:51.586] result() for ClusterFuture ...
[17:44:51.586] - result already collected: FutureResult
[17:44:51.586] result() for ClusterFuture ... done
[17:44:51.586]  - Number of value chunks collected: 1
[17:44:51.587] Resolving 1 futures (chunks) ... DONE
[17:44:51.587] Reducing values from 1 chunks ...
[17:44:51.587]  - Number of values collected after concatenation: 1
[17:44:51.587]  - Number of values expected: 1
[17:44:51.587] Reducing values from 1 chunks ... DONE
[17:44:51.587] future_mapply() ... DONE
- Non-recycling of MoreArgs (Issue #51) ...
[17:44:51.587] future_mapply() ...
[17:44:51.591] Number of chunks: 2
[17:44:51.591] getGlobalsAndPackagesXApply() ...
[17:44:51.592]  - future.globals: TRUE
[17:44:51.592] getGlobalsAndPackages() ...
[17:44:51.592] Searching for globals...
[17:44:51.593] - globals found: [1] ‘FUN’
[17:44:51.593] Searching for globals ... DONE
[17:44:51.593] Resolving globals: FALSE
[17:44:51.594] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:51.594] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:51.594] - globals: [1] ‘FUN’
[17:44:51.594] 
[17:44:51.594] getGlobalsAndPackages() ... DONE
[17:44:51.594]  - globals found/used: [n=1] ‘FUN’
[17:44:51.594]  - needed namespaces: [n=0] 
[17:44:51.595] Finding globals ... DONE
[17:44:51.595] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.595] List of 2
[17:44:51.595]  $ ...future.FUN:function (x, y)  
[17:44:51.595]  $ MoreArgs     :List of 1
[17:44:51.595]   ..$ y: int [1:2] 3 4
[17:44:51.595]  - attr(*, "where")=List of 2
[17:44:51.595]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.595]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.595]  - attr(*, "resolved")= logi FALSE
[17:44:51.595]  - attr(*, "total_size")= num NA
[17:44:51.600] Packages to be attached in all futures: [n=0] 
[17:44:51.600] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.600] Number of futures (= number of chunks): 2
[17:44:51.601] Launching 2 futures (chunks) ...
[17:44:51.601] Chunk #1 of 2 ...
[17:44:51.601]  - Finding globals in '...' for chunk #1 ...
[17:44:51.601] getGlobalsAndPackages() ...
[17:44:51.601] Searching for globals...
[17:44:51.601] 
[17:44:51.601] Searching for globals ... DONE
[17:44:51.601] - globals: [0] <none>
[17:44:51.601] getGlobalsAndPackages() ... DONE
[17:44:51.602]    + additional globals found: [n=0] 
[17:44:51.602]    + additional namespaces needed: [n=0] 
[17:44:51.602]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.602]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.602]  - seeds: <none>
[17:44:51.602]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.602] getGlobalsAndPackages() ...
[17:44:51.602] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.602] Resolving globals: FALSE
[17:44:51.603] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:51.603] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:51.603] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.603] 
[17:44:51.604] getGlobalsAndPackages() ... DONE
[17:44:51.604] run() for ‘Future’ ...
[17:44:51.604] - state: ‘created’
[17:44:51.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.617]   - Field: ‘node’
[17:44:51.617]   - Field: ‘label’
[17:44:51.618]   - Field: ‘local’
[17:44:51.618]   - Field: ‘owner’
[17:44:51.618]   - Field: ‘envir’
[17:44:51.618]   - Field: ‘workers’
[17:44:51.618]   - Field: ‘packages’
[17:44:51.618]   - Field: ‘gc’
[17:44:51.618]   - Field: ‘conditions’
[17:44:51.618]   - Field: ‘persistent’
[17:44:51.618]   - Field: ‘expr’
[17:44:51.618]   - Field: ‘uuid’
[17:44:51.618]   - Field: ‘seed’
[17:44:51.618]   - Field: ‘version’
[17:44:51.619]   - Field: ‘result’
[17:44:51.619]   - Field: ‘asynchronous’
[17:44:51.619]   - Field: ‘calls’
[17:44:51.619]   - Field: ‘globals’
[17:44:51.619]   - Field: ‘stdout’
[17:44:51.619]   - Field: ‘earlySignal’
[17:44:51.619]   - Field: ‘lazy’
[17:44:51.619]   - Field: ‘state’
[17:44:51.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.619] - Launch lazy future ...
[17:44:51.620] Packages needed by the future expression (n = 0): <none>
[17:44:51.620] Packages needed by future strategies (n = 0): <none>
[17:44:51.620] {
[17:44:51.620]     {
[17:44:51.620]         {
[17:44:51.620]             ...future.startTime <- base::Sys.time()
[17:44:51.620]             {
[17:44:51.620]                 {
[17:44:51.620]                   {
[17:44:51.620]                     {
[17:44:51.620]                       base::local({
[17:44:51.620]                         has_future <- base::requireNamespace("future", 
[17:44:51.620]                           quietly = TRUE)
[17:44:51.620]                         if (has_future) {
[17:44:51.620]                           ns <- base::getNamespace("future")
[17:44:51.620]                           version <- ns[[".package"]][["version"]]
[17:44:51.620]                           if (is.null(version)) 
[17:44:51.620]                             version <- utils::packageVersion("future")
[17:44:51.620]                         }
[17:44:51.620]                         else {
[17:44:51.620]                           version <- NULL
[17:44:51.620]                         }
[17:44:51.620]                         if (!has_future || version < "1.8.0") {
[17:44:51.620]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.620]                             "", base::R.version$version.string), 
[17:44:51.620]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.620]                               "release", "version")], collapse = " "), 
[17:44:51.620]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.620]                             info)
[17:44:51.620]                           info <- base::paste(info, collapse = "; ")
[17:44:51.620]                           if (!has_future) {
[17:44:51.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.620]                               info)
[17:44:51.620]                           }
[17:44:51.620]                           else {
[17:44:51.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.620]                               info, version)
[17:44:51.620]                           }
[17:44:51.620]                           base::stop(msg)
[17:44:51.620]                         }
[17:44:51.620]                       })
[17:44:51.620]                     }
[17:44:51.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.620]                     base::options(mc.cores = 1L)
[17:44:51.620]                   }
[17:44:51.620]                   ...future.strategy.old <- future::plan("list")
[17:44:51.620]                   options(future.plan = NULL)
[17:44:51.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.620]                 }
[17:44:51.620]                 ...future.workdir <- getwd()
[17:44:51.620]             }
[17:44:51.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.620]         }
[17:44:51.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.620]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.620]             base::names(...future.oldOptions))
[17:44:51.620]     }
[17:44:51.620]     if (FALSE) {
[17:44:51.620]     }
[17:44:51.620]     else {
[17:44:51.620]         if (TRUE) {
[17:44:51.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.620]                 open = "w")
[17:44:51.620]         }
[17:44:51.620]         else {
[17:44:51.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.620]         }
[17:44:51.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.620]             base::sink(type = "output", split = FALSE)
[17:44:51.620]             base::close(...future.stdout)
[17:44:51.620]         }, add = TRUE)
[17:44:51.620]     }
[17:44:51.620]     ...future.frame <- base::sys.nframe()
[17:44:51.620]     ...future.conditions <- base::list()
[17:44:51.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.620]     if (FALSE) {
[17:44:51.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.620]     }
[17:44:51.620]     ...future.result <- base::tryCatch({
[17:44:51.620]         base::withCallingHandlers({
[17:44:51.620]             ...future.value <- base::withVisible(base::local({
[17:44:51.620]                 ...future.makeSendCondition <- base::local({
[17:44:51.620]                   sendCondition <- NULL
[17:44:51.620]                   function(frame = 1L) {
[17:44:51.620]                     if (is.function(sendCondition)) 
[17:44:51.620]                       return(sendCondition)
[17:44:51.620]                     ns <- getNamespace("parallel")
[17:44:51.620]                     if (exists("sendData", mode = "function", 
[17:44:51.620]                       envir = ns)) {
[17:44:51.620]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.620]                         envir = ns)
[17:44:51.620]                       envir <- sys.frame(frame)
[17:44:51.620]                       master <- NULL
[17:44:51.620]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.620]                         !identical(envir, emptyenv())) {
[17:44:51.620]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.620]                           inherits = FALSE)) {
[17:44:51.620]                           master <- get("master", mode = "list", 
[17:44:51.620]                             envir = envir, inherits = FALSE)
[17:44:51.620]                           if (inherits(master, c("SOCKnode", 
[17:44:51.620]                             "SOCK0node"))) {
[17:44:51.620]                             sendCondition <<- function(cond) {
[17:44:51.620]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.620]                                 success = TRUE)
[17:44:51.620]                               parallel_sendData(master, data)
[17:44:51.620]                             }
[17:44:51.620]                             return(sendCondition)
[17:44:51.620]                           }
[17:44:51.620]                         }
[17:44:51.620]                         frame <- frame + 1L
[17:44:51.620]                         envir <- sys.frame(frame)
[17:44:51.620]                       }
[17:44:51.620]                     }
[17:44:51.620]                     sendCondition <<- function(cond) NULL
[17:44:51.620]                   }
[17:44:51.620]                 })
[17:44:51.620]                 withCallingHandlers({
[17:44:51.620]                   {
[17:44:51.620]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.620]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.620]                       ...future.globals.maxSize)) {
[17:44:51.620]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.620]                       on.exit(options(oopts), add = TRUE)
[17:44:51.620]                     }
[17:44:51.620]                     {
[17:44:51.620]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.620]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.620]                         USE.NAMES = FALSE)
[17:44:51.620]                       do.call(mapply, args = args)
[17:44:51.620]                     }
[17:44:51.620]                   }
[17:44:51.620]                 }, immediateCondition = function(cond) {
[17:44:51.620]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.620]                   sendCondition(cond)
[17:44:51.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.620]                   {
[17:44:51.620]                     inherits <- base::inherits
[17:44:51.620]                     invokeRestart <- base::invokeRestart
[17:44:51.620]                     is.null <- base::is.null
[17:44:51.620]                     muffled <- FALSE
[17:44:51.620]                     if (inherits(cond, "message")) {
[17:44:51.620]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.620]                       if (muffled) 
[17:44:51.620]                         invokeRestart("muffleMessage")
[17:44:51.620]                     }
[17:44:51.620]                     else if (inherits(cond, "warning")) {
[17:44:51.620]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.620]                       if (muffled) 
[17:44:51.620]                         invokeRestart("muffleWarning")
[17:44:51.620]                     }
[17:44:51.620]                     else if (inherits(cond, "condition")) {
[17:44:51.620]                       if (!is.null(pattern)) {
[17:44:51.620]                         computeRestarts <- base::computeRestarts
[17:44:51.620]                         grepl <- base::grepl
[17:44:51.620]                         restarts <- computeRestarts(cond)
[17:44:51.620]                         for (restart in restarts) {
[17:44:51.620]                           name <- restart$name
[17:44:51.620]                           if (is.null(name)) 
[17:44:51.620]                             next
[17:44:51.620]                           if (!grepl(pattern, name)) 
[17:44:51.620]                             next
[17:44:51.620]                           invokeRestart(restart)
[17:44:51.620]                           muffled <- TRUE
[17:44:51.620]                           break
[17:44:51.620]                         }
[17:44:51.620]                       }
[17:44:51.620]                     }
[17:44:51.620]                     invisible(muffled)
[17:44:51.620]                   }
[17:44:51.620]                   muffleCondition(cond)
[17:44:51.620]                 })
[17:44:51.620]             }))
[17:44:51.620]             future::FutureResult(value = ...future.value$value, 
[17:44:51.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.620]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.620]                     ...future.globalenv.names))
[17:44:51.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.620]         }, condition = base::local({
[17:44:51.620]             c <- base::c
[17:44:51.620]             inherits <- base::inherits
[17:44:51.620]             invokeRestart <- base::invokeRestart
[17:44:51.620]             length <- base::length
[17:44:51.620]             list <- base::list
[17:44:51.620]             seq.int <- base::seq.int
[17:44:51.620]             signalCondition <- base::signalCondition
[17:44:51.620]             sys.calls <- base::sys.calls
[17:44:51.620]             `[[` <- base::`[[`
[17:44:51.620]             `+` <- base::`+`
[17:44:51.620]             `<<-` <- base::`<<-`
[17:44:51.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.620]                   3L)]
[17:44:51.620]             }
[17:44:51.620]             function(cond) {
[17:44:51.620]                 is_error <- inherits(cond, "error")
[17:44:51.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.620]                   NULL)
[17:44:51.620]                 if (is_error) {
[17:44:51.620]                   sessionInformation <- function() {
[17:44:51.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.620]                       search = base::search(), system = base::Sys.info())
[17:44:51.620]                   }
[17:44:51.620]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.620]                     cond$call), session = sessionInformation(), 
[17:44:51.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.620]                   signalCondition(cond)
[17:44:51.620]                 }
[17:44:51.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.620]                 "immediateCondition"))) {
[17:44:51.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.620]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.620]                   if (TRUE && !signal) {
[17:44:51.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.620]                     {
[17:44:51.620]                       inherits <- base::inherits
[17:44:51.620]                       invokeRestart <- base::invokeRestart
[17:44:51.620]                       is.null <- base::is.null
[17:44:51.620]                       muffled <- FALSE
[17:44:51.620]                       if (inherits(cond, "message")) {
[17:44:51.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.620]                         if (muffled) 
[17:44:51.620]                           invokeRestart("muffleMessage")
[17:44:51.620]                       }
[17:44:51.620]                       else if (inherits(cond, "warning")) {
[17:44:51.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.620]                         if (muffled) 
[17:44:51.620]                           invokeRestart("muffleWarning")
[17:44:51.620]                       }
[17:44:51.620]                       else if (inherits(cond, "condition")) {
[17:44:51.620]                         if (!is.null(pattern)) {
[17:44:51.620]                           computeRestarts <- base::computeRestarts
[17:44:51.620]                           grepl <- base::grepl
[17:44:51.620]                           restarts <- computeRestarts(cond)
[17:44:51.620]                           for (restart in restarts) {
[17:44:51.620]                             name <- restart$name
[17:44:51.620]                             if (is.null(name)) 
[17:44:51.620]                               next
[17:44:51.620]                             if (!grepl(pattern, name)) 
[17:44:51.620]                               next
[17:44:51.620]                             invokeRestart(restart)
[17:44:51.620]                             muffled <- TRUE
[17:44:51.620]                             break
[17:44:51.620]                           }
[17:44:51.620]                         }
[17:44:51.620]                       }
[17:44:51.620]                       invisible(muffled)
[17:44:51.620]                     }
[17:44:51.620]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.620]                   }
[17:44:51.620]                 }
[17:44:51.620]                 else {
[17:44:51.620]                   if (TRUE) {
[17:44:51.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.620]                     {
[17:44:51.620]                       inherits <- base::inherits
[17:44:51.620]                       invokeRestart <- base::invokeRestart
[17:44:51.620]                       is.null <- base::is.null
[17:44:51.620]                       muffled <- FALSE
[17:44:51.620]                       if (inherits(cond, "message")) {
[17:44:51.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.620]                         if (muffled) 
[17:44:51.620]                           invokeRestart("muffleMessage")
[17:44:51.620]                       }
[17:44:51.620]                       else if (inherits(cond, "warning")) {
[17:44:51.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.620]                         if (muffled) 
[17:44:51.620]                           invokeRestart("muffleWarning")
[17:44:51.620]                       }
[17:44:51.620]                       else if (inherits(cond, "condition")) {
[17:44:51.620]                         if (!is.null(pattern)) {
[17:44:51.620]                           computeRestarts <- base::computeRestarts
[17:44:51.620]                           grepl <- base::grepl
[17:44:51.620]                           restarts <- computeRestarts(cond)
[17:44:51.620]                           for (restart in restarts) {
[17:44:51.620]                             name <- restart$name
[17:44:51.620]                             if (is.null(name)) 
[17:44:51.620]                               next
[17:44:51.620]                             if (!grepl(pattern, name)) 
[17:44:51.620]                               next
[17:44:51.620]                             invokeRestart(restart)
[17:44:51.620]                             muffled <- TRUE
[17:44:51.620]                             break
[17:44:51.620]                           }
[17:44:51.620]                         }
[17:44:51.620]                       }
[17:44:51.620]                       invisible(muffled)
[17:44:51.620]                     }
[17:44:51.620]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.620]                   }
[17:44:51.620]                 }
[17:44:51.620]             }
[17:44:51.620]         }))
[17:44:51.620]     }, error = function(ex) {
[17:44:51.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.620]                 ...future.rng), started = ...future.startTime, 
[17:44:51.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.620]             version = "1.8"), class = "FutureResult")
[17:44:51.620]     }, finally = {
[17:44:51.620]         if (!identical(...future.workdir, getwd())) 
[17:44:51.620]             setwd(...future.workdir)
[17:44:51.620]         {
[17:44:51.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.620]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.620]             }
[17:44:51.620]             base::options(...future.oldOptions)
[17:44:51.620]             if (.Platform$OS.type == "windows") {
[17:44:51.620]                 old_names <- names(...future.oldEnvVars)
[17:44:51.620]                 envs <- base::Sys.getenv()
[17:44:51.620]                 names <- names(envs)
[17:44:51.620]                 common <- intersect(names, old_names)
[17:44:51.620]                 added <- setdiff(names, old_names)
[17:44:51.620]                 removed <- setdiff(old_names, names)
[17:44:51.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.620]                   envs[common]]
[17:44:51.620]                 NAMES <- toupper(changed)
[17:44:51.620]                 args <- list()
[17:44:51.620]                 for (kk in seq_along(NAMES)) {
[17:44:51.620]                   name <- changed[[kk]]
[17:44:51.620]                   NAME <- NAMES[[kk]]
[17:44:51.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.620]                     next
[17:44:51.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.620]                 }
[17:44:51.620]                 NAMES <- toupper(added)
[17:44:51.620]                 for (kk in seq_along(NAMES)) {
[17:44:51.620]                   name <- added[[kk]]
[17:44:51.620]                   NAME <- NAMES[[kk]]
[17:44:51.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.620]                     next
[17:44:51.620]                   args[[name]] <- ""
[17:44:51.620]                 }
[17:44:51.620]                 NAMES <- toupper(removed)
[17:44:51.620]                 for (kk in seq_along(NAMES)) {
[17:44:51.620]                   name <- removed[[kk]]
[17:44:51.620]                   NAME <- NAMES[[kk]]
[17:44:51.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.620]                     next
[17:44:51.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.620]                 }
[17:44:51.620]                 if (length(args) > 0) 
[17:44:51.620]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.620]             }
[17:44:51.620]             else {
[17:44:51.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.620]             }
[17:44:51.620]             {
[17:44:51.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.620]                   0L) {
[17:44:51.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.620]                   base::options(opts)
[17:44:51.620]                 }
[17:44:51.620]                 {
[17:44:51.620]                   {
[17:44:51.620]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.620]                     NULL
[17:44:51.620]                   }
[17:44:51.620]                   options(future.plan = NULL)
[17:44:51.620]                   if (is.na(NA_character_)) 
[17:44:51.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.620]                     .init = FALSE)
[17:44:51.620]                 }
[17:44:51.620]             }
[17:44:51.620]         }
[17:44:51.620]     })
[17:44:51.620]     if (TRUE) {
[17:44:51.620]         base::sink(type = "output", split = FALSE)
[17:44:51.620]         if (TRUE) {
[17:44:51.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.620]         }
[17:44:51.620]         else {
[17:44:51.620]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.620]         }
[17:44:51.620]         base::close(...future.stdout)
[17:44:51.620]         ...future.stdout <- NULL
[17:44:51.620]     }
[17:44:51.620]     ...future.result$conditions <- ...future.conditions
[17:44:51.620]     ...future.result$finished <- base::Sys.time()
[17:44:51.620]     ...future.result
[17:44:51.620] }
[17:44:51.623] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:44:51.623] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:44:51.623] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:44:51.623] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:44:51.624] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.624] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:44:51.624] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.625] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.625] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.625] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:44:51.626] MultisessionFuture started
[17:44:51.626] - Launch lazy future ... done
[17:44:51.626] run() for ‘MultisessionFuture’ ... done
[17:44:51.626] Created future:
[17:44:51.626] MultisessionFuture:
[17:44:51.626] Label: ‘future_mapply-1’
[17:44:51.626] Expression:
[17:44:51.626] {
[17:44:51.626]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.626]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.626]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.626]         on.exit(options(oopts), add = TRUE)
[17:44:51.626]     }
[17:44:51.626]     {
[17:44:51.626]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.626]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.626]         do.call(mapply, args = args)
[17:44:51.626]     }
[17:44:51.626] }
[17:44:51.626] Lazy evaluation: FALSE
[17:44:51.626] Asynchronous evaluation: TRUE
[17:44:51.626] Local evaluation: TRUE
[17:44:51.626] Environment: R_GlobalEnv
[17:44:51.626] Capture standard output: TRUE
[17:44:51.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.626] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.626] Packages: <none>
[17:44:51.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.626] Resolved: FALSE
[17:44:51.626] Value: <not collected>
[17:44:51.626] Conditions captured: <none>
[17:44:51.626] Early signaling: FALSE
[17:44:51.626] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.637] Chunk #1 of 2 ... DONE
[17:44:51.637] Chunk #2 of 2 ...
[17:44:51.637]  - Finding globals in '...' for chunk #2 ...
[17:44:51.638] getGlobalsAndPackages() ...
[17:44:51.638] Searching for globals...
[17:44:51.638] 
[17:44:51.638] Searching for globals ... DONE
[17:44:51.638] - globals: [0] <none>
[17:44:51.638] getGlobalsAndPackages() ... DONE
[17:44:51.638]    + additional globals found: [n=0] 
[17:44:51.639]    + additional namespaces needed: [n=0] 
[17:44:51.639]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.639]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.639]  - seeds: <none>
[17:44:51.639]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.639] getGlobalsAndPackages() ...
[17:44:51.639] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.639] Resolving globals: FALSE
[17:44:51.640] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:51.640] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:51.640] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.640] 
[17:44:51.640] getGlobalsAndPackages() ... DONE
[17:44:51.641] run() for ‘Future’ ...
[17:44:51.641] - state: ‘created’
[17:44:51.641] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.654] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.655]   - Field: ‘node’
[17:44:51.655]   - Field: ‘label’
[17:44:51.655]   - Field: ‘local’
[17:44:51.655]   - Field: ‘owner’
[17:44:51.655]   - Field: ‘envir’
[17:44:51.655]   - Field: ‘workers’
[17:44:51.655]   - Field: ‘packages’
[17:44:51.655]   - Field: ‘gc’
[17:44:51.655]   - Field: ‘conditions’
[17:44:51.655]   - Field: ‘persistent’
[17:44:51.656]   - Field: ‘expr’
[17:44:51.656]   - Field: ‘uuid’
[17:44:51.656]   - Field: ‘seed’
[17:44:51.656]   - Field: ‘version’
[17:44:51.656]   - Field: ‘result’
[17:44:51.656]   - Field: ‘asynchronous’
[17:44:51.656]   - Field: ‘calls’
[17:44:51.656]   - Field: ‘globals’
[17:44:51.656]   - Field: ‘stdout’
[17:44:51.656]   - Field: ‘earlySignal’
[17:44:51.656]   - Field: ‘lazy’
[17:44:51.656]   - Field: ‘state’
[17:44:51.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.657] - Launch lazy future ...
[17:44:51.657] Packages needed by the future expression (n = 0): <none>
[17:44:51.657] Packages needed by future strategies (n = 0): <none>
[17:44:51.657] {
[17:44:51.657]     {
[17:44:51.657]         {
[17:44:51.657]             ...future.startTime <- base::Sys.time()
[17:44:51.657]             {
[17:44:51.657]                 {
[17:44:51.657]                   {
[17:44:51.657]                     {
[17:44:51.657]                       base::local({
[17:44:51.657]                         has_future <- base::requireNamespace("future", 
[17:44:51.657]                           quietly = TRUE)
[17:44:51.657]                         if (has_future) {
[17:44:51.657]                           ns <- base::getNamespace("future")
[17:44:51.657]                           version <- ns[[".package"]][["version"]]
[17:44:51.657]                           if (is.null(version)) 
[17:44:51.657]                             version <- utils::packageVersion("future")
[17:44:51.657]                         }
[17:44:51.657]                         else {
[17:44:51.657]                           version <- NULL
[17:44:51.657]                         }
[17:44:51.657]                         if (!has_future || version < "1.8.0") {
[17:44:51.657]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.657]                             "", base::R.version$version.string), 
[17:44:51.657]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.657]                               "release", "version")], collapse = " "), 
[17:44:51.657]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.657]                             info)
[17:44:51.657]                           info <- base::paste(info, collapse = "; ")
[17:44:51.657]                           if (!has_future) {
[17:44:51.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.657]                               info)
[17:44:51.657]                           }
[17:44:51.657]                           else {
[17:44:51.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.657]                               info, version)
[17:44:51.657]                           }
[17:44:51.657]                           base::stop(msg)
[17:44:51.657]                         }
[17:44:51.657]                       })
[17:44:51.657]                     }
[17:44:51.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.657]                     base::options(mc.cores = 1L)
[17:44:51.657]                   }
[17:44:51.657]                   ...future.strategy.old <- future::plan("list")
[17:44:51.657]                   options(future.plan = NULL)
[17:44:51.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.657]                 }
[17:44:51.657]                 ...future.workdir <- getwd()
[17:44:51.657]             }
[17:44:51.657]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.657]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.657]         }
[17:44:51.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.657]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.657]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.657]             base::names(...future.oldOptions))
[17:44:51.657]     }
[17:44:51.657]     if (FALSE) {
[17:44:51.657]     }
[17:44:51.657]     else {
[17:44:51.657]         if (TRUE) {
[17:44:51.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.657]                 open = "w")
[17:44:51.657]         }
[17:44:51.657]         else {
[17:44:51.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.657]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.657]         }
[17:44:51.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.657]             base::sink(type = "output", split = FALSE)
[17:44:51.657]             base::close(...future.stdout)
[17:44:51.657]         }, add = TRUE)
[17:44:51.657]     }
[17:44:51.657]     ...future.frame <- base::sys.nframe()
[17:44:51.657]     ...future.conditions <- base::list()
[17:44:51.657]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.657]     if (FALSE) {
[17:44:51.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.657]     }
[17:44:51.657]     ...future.result <- base::tryCatch({
[17:44:51.657]         base::withCallingHandlers({
[17:44:51.657]             ...future.value <- base::withVisible(base::local({
[17:44:51.657]                 ...future.makeSendCondition <- base::local({
[17:44:51.657]                   sendCondition <- NULL
[17:44:51.657]                   function(frame = 1L) {
[17:44:51.657]                     if (is.function(sendCondition)) 
[17:44:51.657]                       return(sendCondition)
[17:44:51.657]                     ns <- getNamespace("parallel")
[17:44:51.657]                     if (exists("sendData", mode = "function", 
[17:44:51.657]                       envir = ns)) {
[17:44:51.657]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.657]                         envir = ns)
[17:44:51.657]                       envir <- sys.frame(frame)
[17:44:51.657]                       master <- NULL
[17:44:51.657]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.657]                         !identical(envir, emptyenv())) {
[17:44:51.657]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.657]                           inherits = FALSE)) {
[17:44:51.657]                           master <- get("master", mode = "list", 
[17:44:51.657]                             envir = envir, inherits = FALSE)
[17:44:51.657]                           if (inherits(master, c("SOCKnode", 
[17:44:51.657]                             "SOCK0node"))) {
[17:44:51.657]                             sendCondition <<- function(cond) {
[17:44:51.657]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.657]                                 success = TRUE)
[17:44:51.657]                               parallel_sendData(master, data)
[17:44:51.657]                             }
[17:44:51.657]                             return(sendCondition)
[17:44:51.657]                           }
[17:44:51.657]                         }
[17:44:51.657]                         frame <- frame + 1L
[17:44:51.657]                         envir <- sys.frame(frame)
[17:44:51.657]                       }
[17:44:51.657]                     }
[17:44:51.657]                     sendCondition <<- function(cond) NULL
[17:44:51.657]                   }
[17:44:51.657]                 })
[17:44:51.657]                 withCallingHandlers({
[17:44:51.657]                   {
[17:44:51.657]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.657]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.657]                       ...future.globals.maxSize)) {
[17:44:51.657]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.657]                       on.exit(options(oopts), add = TRUE)
[17:44:51.657]                     }
[17:44:51.657]                     {
[17:44:51.657]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.657]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.657]                         USE.NAMES = FALSE)
[17:44:51.657]                       do.call(mapply, args = args)
[17:44:51.657]                     }
[17:44:51.657]                   }
[17:44:51.657]                 }, immediateCondition = function(cond) {
[17:44:51.657]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.657]                   sendCondition(cond)
[17:44:51.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.657]                   {
[17:44:51.657]                     inherits <- base::inherits
[17:44:51.657]                     invokeRestart <- base::invokeRestart
[17:44:51.657]                     is.null <- base::is.null
[17:44:51.657]                     muffled <- FALSE
[17:44:51.657]                     if (inherits(cond, "message")) {
[17:44:51.657]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.657]                       if (muffled) 
[17:44:51.657]                         invokeRestart("muffleMessage")
[17:44:51.657]                     }
[17:44:51.657]                     else if (inherits(cond, "warning")) {
[17:44:51.657]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.657]                       if (muffled) 
[17:44:51.657]                         invokeRestart("muffleWarning")
[17:44:51.657]                     }
[17:44:51.657]                     else if (inherits(cond, "condition")) {
[17:44:51.657]                       if (!is.null(pattern)) {
[17:44:51.657]                         computeRestarts <- base::computeRestarts
[17:44:51.657]                         grepl <- base::grepl
[17:44:51.657]                         restarts <- computeRestarts(cond)
[17:44:51.657]                         for (restart in restarts) {
[17:44:51.657]                           name <- restart$name
[17:44:51.657]                           if (is.null(name)) 
[17:44:51.657]                             next
[17:44:51.657]                           if (!grepl(pattern, name)) 
[17:44:51.657]                             next
[17:44:51.657]                           invokeRestart(restart)
[17:44:51.657]                           muffled <- TRUE
[17:44:51.657]                           break
[17:44:51.657]                         }
[17:44:51.657]                       }
[17:44:51.657]                     }
[17:44:51.657]                     invisible(muffled)
[17:44:51.657]                   }
[17:44:51.657]                   muffleCondition(cond)
[17:44:51.657]                 })
[17:44:51.657]             }))
[17:44:51.657]             future::FutureResult(value = ...future.value$value, 
[17:44:51.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.657]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.657]                     ...future.globalenv.names))
[17:44:51.657]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.657]         }, condition = base::local({
[17:44:51.657]             c <- base::c
[17:44:51.657]             inherits <- base::inherits
[17:44:51.657]             invokeRestart <- base::invokeRestart
[17:44:51.657]             length <- base::length
[17:44:51.657]             list <- base::list
[17:44:51.657]             seq.int <- base::seq.int
[17:44:51.657]             signalCondition <- base::signalCondition
[17:44:51.657]             sys.calls <- base::sys.calls
[17:44:51.657]             `[[` <- base::`[[`
[17:44:51.657]             `+` <- base::`+`
[17:44:51.657]             `<<-` <- base::`<<-`
[17:44:51.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.657]                   3L)]
[17:44:51.657]             }
[17:44:51.657]             function(cond) {
[17:44:51.657]                 is_error <- inherits(cond, "error")
[17:44:51.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.657]                   NULL)
[17:44:51.657]                 if (is_error) {
[17:44:51.657]                   sessionInformation <- function() {
[17:44:51.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.657]                       search = base::search(), system = base::Sys.info())
[17:44:51.657]                   }
[17:44:51.657]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.657]                     cond$call), session = sessionInformation(), 
[17:44:51.657]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.657]                   signalCondition(cond)
[17:44:51.657]                 }
[17:44:51.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.657]                 "immediateCondition"))) {
[17:44:51.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.657]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.657]                   if (TRUE && !signal) {
[17:44:51.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.657]                     {
[17:44:51.657]                       inherits <- base::inherits
[17:44:51.657]                       invokeRestart <- base::invokeRestart
[17:44:51.657]                       is.null <- base::is.null
[17:44:51.657]                       muffled <- FALSE
[17:44:51.657]                       if (inherits(cond, "message")) {
[17:44:51.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.657]                         if (muffled) 
[17:44:51.657]                           invokeRestart("muffleMessage")
[17:44:51.657]                       }
[17:44:51.657]                       else if (inherits(cond, "warning")) {
[17:44:51.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.657]                         if (muffled) 
[17:44:51.657]                           invokeRestart("muffleWarning")
[17:44:51.657]                       }
[17:44:51.657]                       else if (inherits(cond, "condition")) {
[17:44:51.657]                         if (!is.null(pattern)) {
[17:44:51.657]                           computeRestarts <- base::computeRestarts
[17:44:51.657]                           grepl <- base::grepl
[17:44:51.657]                           restarts <- computeRestarts(cond)
[17:44:51.657]                           for (restart in restarts) {
[17:44:51.657]                             name <- restart$name
[17:44:51.657]                             if (is.null(name)) 
[17:44:51.657]                               next
[17:44:51.657]                             if (!grepl(pattern, name)) 
[17:44:51.657]                               next
[17:44:51.657]                             invokeRestart(restart)
[17:44:51.657]                             muffled <- TRUE
[17:44:51.657]                             break
[17:44:51.657]                           }
[17:44:51.657]                         }
[17:44:51.657]                       }
[17:44:51.657]                       invisible(muffled)
[17:44:51.657]                     }
[17:44:51.657]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.657]                   }
[17:44:51.657]                 }
[17:44:51.657]                 else {
[17:44:51.657]                   if (TRUE) {
[17:44:51.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.657]                     {
[17:44:51.657]                       inherits <- base::inherits
[17:44:51.657]                       invokeRestart <- base::invokeRestart
[17:44:51.657]                       is.null <- base::is.null
[17:44:51.657]                       muffled <- FALSE
[17:44:51.657]                       if (inherits(cond, "message")) {
[17:44:51.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.657]                         if (muffled) 
[17:44:51.657]                           invokeRestart("muffleMessage")
[17:44:51.657]                       }
[17:44:51.657]                       else if (inherits(cond, "warning")) {
[17:44:51.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.657]                         if (muffled) 
[17:44:51.657]                           invokeRestart("muffleWarning")
[17:44:51.657]                       }
[17:44:51.657]                       else if (inherits(cond, "condition")) {
[17:44:51.657]                         if (!is.null(pattern)) {
[17:44:51.657]                           computeRestarts <- base::computeRestarts
[17:44:51.657]                           grepl <- base::grepl
[17:44:51.657]                           restarts <- computeRestarts(cond)
[17:44:51.657]                           for (restart in restarts) {
[17:44:51.657]                             name <- restart$name
[17:44:51.657]                             if (is.null(name)) 
[17:44:51.657]                               next
[17:44:51.657]                             if (!grepl(pattern, name)) 
[17:44:51.657]                               next
[17:44:51.657]                             invokeRestart(restart)
[17:44:51.657]                             muffled <- TRUE
[17:44:51.657]                             break
[17:44:51.657]                           }
[17:44:51.657]                         }
[17:44:51.657]                       }
[17:44:51.657]                       invisible(muffled)
[17:44:51.657]                     }
[17:44:51.657]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.657]                   }
[17:44:51.657]                 }
[17:44:51.657]             }
[17:44:51.657]         }))
[17:44:51.657]     }, error = function(ex) {
[17:44:51.657]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.657]                 ...future.rng), started = ...future.startTime, 
[17:44:51.657]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.657]             version = "1.8"), class = "FutureResult")
[17:44:51.657]     }, finally = {
[17:44:51.657]         if (!identical(...future.workdir, getwd())) 
[17:44:51.657]             setwd(...future.workdir)
[17:44:51.657]         {
[17:44:51.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.657]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.657]             }
[17:44:51.657]             base::options(...future.oldOptions)
[17:44:51.657]             if (.Platform$OS.type == "windows") {
[17:44:51.657]                 old_names <- names(...future.oldEnvVars)
[17:44:51.657]                 envs <- base::Sys.getenv()
[17:44:51.657]                 names <- names(envs)
[17:44:51.657]                 common <- intersect(names, old_names)
[17:44:51.657]                 added <- setdiff(names, old_names)
[17:44:51.657]                 removed <- setdiff(old_names, names)
[17:44:51.657]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.657]                   envs[common]]
[17:44:51.657]                 NAMES <- toupper(changed)
[17:44:51.657]                 args <- list()
[17:44:51.657]                 for (kk in seq_along(NAMES)) {
[17:44:51.657]                   name <- changed[[kk]]
[17:44:51.657]                   NAME <- NAMES[[kk]]
[17:44:51.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.657]                     next
[17:44:51.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.657]                 }
[17:44:51.657]                 NAMES <- toupper(added)
[17:44:51.657]                 for (kk in seq_along(NAMES)) {
[17:44:51.657]                   name <- added[[kk]]
[17:44:51.657]                   NAME <- NAMES[[kk]]
[17:44:51.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.657]                     next
[17:44:51.657]                   args[[name]] <- ""
[17:44:51.657]                 }
[17:44:51.657]                 NAMES <- toupper(removed)
[17:44:51.657]                 for (kk in seq_along(NAMES)) {
[17:44:51.657]                   name <- removed[[kk]]
[17:44:51.657]                   NAME <- NAMES[[kk]]
[17:44:51.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.657]                     next
[17:44:51.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.657]                 }
[17:44:51.657]                 if (length(args) > 0) 
[17:44:51.657]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.657]             }
[17:44:51.657]             else {
[17:44:51.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.657]             }
[17:44:51.657]             {
[17:44:51.657]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.657]                   0L) {
[17:44:51.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.657]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.657]                   base::options(opts)
[17:44:51.657]                 }
[17:44:51.657]                 {
[17:44:51.657]                   {
[17:44:51.657]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.657]                     NULL
[17:44:51.657]                   }
[17:44:51.657]                   options(future.plan = NULL)
[17:44:51.657]                   if (is.na(NA_character_)) 
[17:44:51.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.657]                     .init = FALSE)
[17:44:51.657]                 }
[17:44:51.657]             }
[17:44:51.657]         }
[17:44:51.657]     })
[17:44:51.657]     if (TRUE) {
[17:44:51.657]         base::sink(type = "output", split = FALSE)
[17:44:51.657]         if (TRUE) {
[17:44:51.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.657]         }
[17:44:51.657]         else {
[17:44:51.657]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.657]         }
[17:44:51.657]         base::close(...future.stdout)
[17:44:51.657]         ...future.stdout <- NULL
[17:44:51.657]     }
[17:44:51.657]     ...future.result$conditions <- ...future.conditions
[17:44:51.657]     ...future.result$finished <- base::Sys.time()
[17:44:51.657]     ...future.result
[17:44:51.657] }
[17:44:51.660] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:44:51.660] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:44:51.660] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:44:51.661] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:44:51.661] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.661] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:44:51.661] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:51.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.662] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.662] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.662] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:44:51.663] MultisessionFuture started
[17:44:51.663] - Launch lazy future ... done
[17:44:51.663] run() for ‘MultisessionFuture’ ... done
[17:44:51.663] Created future:
[17:44:51.663] MultisessionFuture:
[17:44:51.663] Label: ‘future_mapply-2’
[17:44:51.663] Expression:
[17:44:51.663] {
[17:44:51.663]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.663]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.663]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.663]         on.exit(options(oopts), add = TRUE)
[17:44:51.663]     }
[17:44:51.663]     {
[17:44:51.663]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.663]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.663]         do.call(mapply, args = args)
[17:44:51.663]     }
[17:44:51.663] }
[17:44:51.663] Lazy evaluation: FALSE
[17:44:51.663] Asynchronous evaluation: TRUE
[17:44:51.663] Local evaluation: TRUE
[17:44:51.663] Environment: R_GlobalEnv
[17:44:51.663] Capture standard output: TRUE
[17:44:51.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.663] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.663] Packages: <none>
[17:44:51.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.663] Resolved: FALSE
[17:44:51.663] Value: <not collected>
[17:44:51.663] Conditions captured: <none>
[17:44:51.663] Early signaling: FALSE
[17:44:51.663] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.663] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.675] Chunk #2 of 2 ... DONE
[17:44:51.675] Launching 2 futures (chunks) ... DONE
[17:44:51.675] Resolving 2 futures (chunks) ...
[17:44:51.675] resolve() on list ...
[17:44:51.675]  recursive: 0
[17:44:51.675]  length: 2
[17:44:51.675] 
[17:44:51.676] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.676] - Validating connection of MultisessionFuture
[17:44:51.676] - received message: FutureResult
[17:44:51.676] - Received FutureResult
[17:44:51.676] - Erased future from FutureRegistry
[17:44:51.676] result() for ClusterFuture ...
[17:44:51.676] - result already collected: FutureResult
[17:44:51.677] result() for ClusterFuture ... done
[17:44:51.677] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.677] Future #1
[17:44:51.677] result() for ClusterFuture ...
[17:44:51.677] - result already collected: FutureResult
[17:44:51.677] result() for ClusterFuture ... done
[17:44:51.677] result() for ClusterFuture ...
[17:44:51.677] - result already collected: FutureResult
[17:44:51.677] result() for ClusterFuture ... done
[17:44:51.677] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.677] - nx: 2
[17:44:51.677] - relay: TRUE
[17:44:51.678] - stdout: TRUE
[17:44:51.678] - signal: TRUE
[17:44:51.678] - resignal: FALSE
[17:44:51.678] - force: TRUE
[17:44:51.678] - relayed: [n=2] FALSE, FALSE
[17:44:51.678] - queued futures: [n=2] FALSE, FALSE
[17:44:51.678]  - until=1
[17:44:51.678]  - relaying element #1
[17:44:51.678] result() for ClusterFuture ...
[17:44:51.678] - result already collected: FutureResult
[17:44:51.678] result() for ClusterFuture ... done
[17:44:51.678] result() for ClusterFuture ...
[17:44:51.679] - result already collected: FutureResult
[17:44:51.679] result() for ClusterFuture ... done
[17:44:51.679] result() for ClusterFuture ...
[17:44:51.679] - result already collected: FutureResult
[17:44:51.679] result() for ClusterFuture ... done
[17:44:51.679] result() for ClusterFuture ...
[17:44:51.679] - result already collected: FutureResult
[17:44:51.679] result() for ClusterFuture ... done
[17:44:51.679] - relayed: [n=2] TRUE, FALSE
[17:44:51.679] - queued futures: [n=2] TRUE, FALSE
[17:44:51.679] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.680]  length: 1 (resolved future 1)
[17:44:51.705] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.705] - Validating connection of MultisessionFuture
[17:44:51.705] - received message: FutureResult
[17:44:51.705] - Received FutureResult
[17:44:51.705] - Erased future from FutureRegistry
[17:44:51.705] result() for ClusterFuture ...
[17:44:51.705] - result already collected: FutureResult
[17:44:51.705] result() for ClusterFuture ... done
[17:44:51.706] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.706] Future #2
[17:44:51.706] result() for ClusterFuture ...
[17:44:51.706] - result already collected: FutureResult
[17:44:51.706] result() for ClusterFuture ... done
[17:44:51.706] result() for ClusterFuture ...
[17:44:51.706] - result already collected: FutureResult
[17:44:51.706] result() for ClusterFuture ... done
[17:44:51.706] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.706] - nx: 2
[17:44:51.706] - relay: TRUE
[17:44:51.707] - stdout: TRUE
[17:44:51.707] - signal: TRUE
[17:44:51.707] - resignal: FALSE
[17:44:51.707] - force: TRUE
[17:44:51.707] - relayed: [n=2] TRUE, FALSE
[17:44:51.707] - queued futures: [n=2] TRUE, FALSE
[17:44:51.707]  - until=2
[17:44:51.707]  - relaying element #2
[17:44:51.707] result() for ClusterFuture ...
[17:44:51.707] - result already collected: FutureResult
[17:44:51.707] result() for ClusterFuture ... done
[17:44:51.708] result() for ClusterFuture ...
[17:44:51.708] - result already collected: FutureResult
[17:44:51.708] result() for ClusterFuture ... done
[17:44:51.708] result() for ClusterFuture ...
[17:44:51.708] - result already collected: FutureResult
[17:44:51.708] result() for ClusterFuture ... done
[17:44:51.708] result() for ClusterFuture ...
[17:44:51.708] - result already collected: FutureResult
[17:44:51.708] result() for ClusterFuture ... done
[17:44:51.708] - relayed: [n=2] TRUE, TRUE
[17:44:51.708] - queued futures: [n=2] TRUE, TRUE
[17:44:51.708] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.709]  length: 0 (resolved future 2)
[17:44:51.709] Relaying remaining futures
[17:44:51.709] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.709] - nx: 2
[17:44:51.709] - relay: TRUE
[17:44:51.709] - stdout: TRUE
[17:44:51.709] - signal: TRUE
[17:44:51.709] - resignal: FALSE
[17:44:51.709] - force: TRUE
[17:44:51.709] - relayed: [n=2] TRUE, TRUE
[17:44:51.709] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.709] - relayed: [n=2] TRUE, TRUE
[17:44:51.710] - queued futures: [n=2] TRUE, TRUE
[17:44:51.710] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.710] resolve() on list ... DONE
[17:44:51.710] result() for ClusterFuture ...
[17:44:51.710] - result already collected: FutureResult
[17:44:51.710] result() for ClusterFuture ... done
[17:44:51.710] result() for ClusterFuture ...
[17:44:51.710] - result already collected: FutureResult
[17:44:51.710] result() for ClusterFuture ... done
[17:44:51.710] result() for ClusterFuture ...
[17:44:51.710] - result already collected: FutureResult
[17:44:51.710] result() for ClusterFuture ... done
[17:44:51.711] result() for ClusterFuture ...
[17:44:51.711] - result already collected: FutureResult
[17:44:51.711] result() for ClusterFuture ... done
[17:44:51.711]  - Number of value chunks collected: 2
[17:44:51.711] Resolving 2 futures (chunks) ... DONE
[17:44:51.711] Reducing values from 2 chunks ...
[17:44:51.711]  - Number of values collected after concatenation: 2
[17:44:51.711]  - Number of values expected: 2
[17:44:51.711] Reducing values from 2 chunks ... DONE
[17:44:51.711] future_mapply() ... DONE
[17:44:51.712] future_mapply() ...
[17:44:51.712] Generating random seeds ...
[17:44:51.712] Generating random seed streams for 2 elements ...
[17:44:51.712] Generating random seed streams for 2 elements ... DONE
[17:44:51.712] Generating random seeds ... DONE
[17:44:51.712] Will set RNG state on exit: 10407, -1074383426, 1414042924, -360559175, 1723321718, -2121219383, -730059028
[17:44:51.715] Number of chunks: 2
[17:44:51.716] getGlobalsAndPackagesXApply() ...
[17:44:51.716]  - future.globals: TRUE
[17:44:51.716] getGlobalsAndPackages() ...
[17:44:51.716] Searching for globals...
[17:44:51.717] - globals found: [1] ‘FUN’
[17:44:51.717] Searching for globals ... DONE
[17:44:51.717] Resolving globals: FALSE
[17:44:51.717] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:51.718] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:51.718] - globals: [1] ‘FUN’
[17:44:51.718] 
[17:44:51.718] getGlobalsAndPackages() ... DONE
[17:44:51.718]  - globals found/used: [n=1] ‘FUN’
[17:44:51.718]  - needed namespaces: [n=0] 
[17:44:51.718] Finding globals ... DONE
[17:44:51.718] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.719] List of 2
[17:44:51.719]  $ ...future.FUN:function (x, y)  
[17:44:51.719]  $ MoreArgs     :List of 1
[17:44:51.719]   ..$ y: int [1:2] 3 4
[17:44:51.719]  - attr(*, "where")=List of 2
[17:44:51.719]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.719]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.719]  - attr(*, "resolved")= logi FALSE
[17:44:51.719]  - attr(*, "total_size")= num NA
[17:44:51.721] Packages to be attached in all futures: [n=0] 
[17:44:51.721] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.722] Number of futures (= number of chunks): 2
[17:44:51.722] Launching 2 futures (chunks) ...
[17:44:51.722] Chunk #1 of 2 ...
[17:44:51.722]  - Finding globals in '...' for chunk #1 ...
[17:44:51.722] getGlobalsAndPackages() ...
[17:44:51.722] Searching for globals...
[17:44:51.722] 
[17:44:51.723] Searching for globals ... DONE
[17:44:51.723] - globals: [0] <none>
[17:44:51.723] getGlobalsAndPackages() ... DONE
[17:44:51.723]    + additional globals found: [n=0] 
[17:44:51.723]    + additional namespaces needed: [n=0] 
[17:44:51.723]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.723]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.723]  - seeds: [1] <seeds>
[17:44:51.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.723] getGlobalsAndPackages() ...
[17:44:51.724] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.724] Resolving globals: FALSE
[17:44:51.724] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:44:51.725] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:51.725] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.725] 
[17:44:51.725] getGlobalsAndPackages() ... DONE
[17:44:51.725] run() for ‘Future’ ...
[17:44:51.725] - state: ‘created’
[17:44:51.725] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.741]   - Field: ‘node’
[17:44:51.741]   - Field: ‘label’
[17:44:51.741]   - Field: ‘local’
[17:44:51.741]   - Field: ‘owner’
[17:44:51.741]   - Field: ‘envir’
[17:44:51.741]   - Field: ‘workers’
[17:44:51.741]   - Field: ‘packages’
[17:44:51.741]   - Field: ‘gc’
[17:44:51.742]   - Field: ‘conditions’
[17:44:51.742]   - Field: ‘persistent’
[17:44:51.742]   - Field: ‘expr’
[17:44:51.742]   - Field: ‘uuid’
[17:44:51.742]   - Field: ‘seed’
[17:44:51.742]   - Field: ‘version’
[17:44:51.742]   - Field: ‘result’
[17:44:51.742]   - Field: ‘asynchronous’
[17:44:51.742]   - Field: ‘calls’
[17:44:51.742]   - Field: ‘globals’
[17:44:51.742]   - Field: ‘stdout’
[17:44:51.743]   - Field: ‘earlySignal’
[17:44:51.743]   - Field: ‘lazy’
[17:44:51.743]   - Field: ‘state’
[17:44:51.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.743] - Launch lazy future ...
[17:44:51.743] Packages needed by the future expression (n = 0): <none>
[17:44:51.743] Packages needed by future strategies (n = 0): <none>
[17:44:51.744] {
[17:44:51.744]     {
[17:44:51.744]         {
[17:44:51.744]             ...future.startTime <- base::Sys.time()
[17:44:51.744]             {
[17:44:51.744]                 {
[17:44:51.744]                   {
[17:44:51.744]                     {
[17:44:51.744]                       base::local({
[17:44:51.744]                         has_future <- base::requireNamespace("future", 
[17:44:51.744]                           quietly = TRUE)
[17:44:51.744]                         if (has_future) {
[17:44:51.744]                           ns <- base::getNamespace("future")
[17:44:51.744]                           version <- ns[[".package"]][["version"]]
[17:44:51.744]                           if (is.null(version)) 
[17:44:51.744]                             version <- utils::packageVersion("future")
[17:44:51.744]                         }
[17:44:51.744]                         else {
[17:44:51.744]                           version <- NULL
[17:44:51.744]                         }
[17:44:51.744]                         if (!has_future || version < "1.8.0") {
[17:44:51.744]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.744]                             "", base::R.version$version.string), 
[17:44:51.744]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.744]                               "release", "version")], collapse = " "), 
[17:44:51.744]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.744]                             info)
[17:44:51.744]                           info <- base::paste(info, collapse = "; ")
[17:44:51.744]                           if (!has_future) {
[17:44:51.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.744]                               info)
[17:44:51.744]                           }
[17:44:51.744]                           else {
[17:44:51.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.744]                               info, version)
[17:44:51.744]                           }
[17:44:51.744]                           base::stop(msg)
[17:44:51.744]                         }
[17:44:51.744]                       })
[17:44:51.744]                     }
[17:44:51.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.744]                     base::options(mc.cores = 1L)
[17:44:51.744]                   }
[17:44:51.744]                   ...future.strategy.old <- future::plan("list")
[17:44:51.744]                   options(future.plan = NULL)
[17:44:51.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.744]                 }
[17:44:51.744]                 ...future.workdir <- getwd()
[17:44:51.744]             }
[17:44:51.744]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.744]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.744]         }
[17:44:51.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.744]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.744]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.744]             base::names(...future.oldOptions))
[17:44:51.744]     }
[17:44:51.744]     if (FALSE) {
[17:44:51.744]     }
[17:44:51.744]     else {
[17:44:51.744]         if (TRUE) {
[17:44:51.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.744]                 open = "w")
[17:44:51.744]         }
[17:44:51.744]         else {
[17:44:51.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.744]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.744]         }
[17:44:51.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.744]             base::sink(type = "output", split = FALSE)
[17:44:51.744]             base::close(...future.stdout)
[17:44:51.744]         }, add = TRUE)
[17:44:51.744]     }
[17:44:51.744]     ...future.frame <- base::sys.nframe()
[17:44:51.744]     ...future.conditions <- base::list()
[17:44:51.744]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.744]     if (FALSE) {
[17:44:51.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.744]     }
[17:44:51.744]     ...future.result <- base::tryCatch({
[17:44:51.744]         base::withCallingHandlers({
[17:44:51.744]             ...future.value <- base::withVisible(base::local({
[17:44:51.744]                 ...future.makeSendCondition <- base::local({
[17:44:51.744]                   sendCondition <- NULL
[17:44:51.744]                   function(frame = 1L) {
[17:44:51.744]                     if (is.function(sendCondition)) 
[17:44:51.744]                       return(sendCondition)
[17:44:51.744]                     ns <- getNamespace("parallel")
[17:44:51.744]                     if (exists("sendData", mode = "function", 
[17:44:51.744]                       envir = ns)) {
[17:44:51.744]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.744]                         envir = ns)
[17:44:51.744]                       envir <- sys.frame(frame)
[17:44:51.744]                       master <- NULL
[17:44:51.744]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.744]                         !identical(envir, emptyenv())) {
[17:44:51.744]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.744]                           inherits = FALSE)) {
[17:44:51.744]                           master <- get("master", mode = "list", 
[17:44:51.744]                             envir = envir, inherits = FALSE)
[17:44:51.744]                           if (inherits(master, c("SOCKnode", 
[17:44:51.744]                             "SOCK0node"))) {
[17:44:51.744]                             sendCondition <<- function(cond) {
[17:44:51.744]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.744]                                 success = TRUE)
[17:44:51.744]                               parallel_sendData(master, data)
[17:44:51.744]                             }
[17:44:51.744]                             return(sendCondition)
[17:44:51.744]                           }
[17:44:51.744]                         }
[17:44:51.744]                         frame <- frame + 1L
[17:44:51.744]                         envir <- sys.frame(frame)
[17:44:51.744]                       }
[17:44:51.744]                     }
[17:44:51.744]                     sendCondition <<- function(cond) NULL
[17:44:51.744]                   }
[17:44:51.744]                 })
[17:44:51.744]                 withCallingHandlers({
[17:44:51.744]                   {
[17:44:51.744]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.744]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.744]                       ...future.globals.maxSize)) {
[17:44:51.744]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.744]                       on.exit(options(oopts), add = TRUE)
[17:44:51.744]                     }
[17:44:51.744]                     {
[17:44:51.744]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:51.744]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:51.744]                           envir = globalenv(), inherits = FALSE)
[17:44:51.744]                         ...future.FUN(...)
[17:44:51.744]                       }
[17:44:51.744]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:51.744]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:51.744]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.744]                         USE.NAMES = FALSE)
[17:44:51.744]                       do.call(mapply, args = args)
[17:44:51.744]                     }
[17:44:51.744]                   }
[17:44:51.744]                 }, immediateCondition = function(cond) {
[17:44:51.744]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.744]                   sendCondition(cond)
[17:44:51.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.744]                   {
[17:44:51.744]                     inherits <- base::inherits
[17:44:51.744]                     invokeRestart <- base::invokeRestart
[17:44:51.744]                     is.null <- base::is.null
[17:44:51.744]                     muffled <- FALSE
[17:44:51.744]                     if (inherits(cond, "message")) {
[17:44:51.744]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.744]                       if (muffled) 
[17:44:51.744]                         invokeRestart("muffleMessage")
[17:44:51.744]                     }
[17:44:51.744]                     else if (inherits(cond, "warning")) {
[17:44:51.744]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.744]                       if (muffled) 
[17:44:51.744]                         invokeRestart("muffleWarning")
[17:44:51.744]                     }
[17:44:51.744]                     else if (inherits(cond, "condition")) {
[17:44:51.744]                       if (!is.null(pattern)) {
[17:44:51.744]                         computeRestarts <- base::computeRestarts
[17:44:51.744]                         grepl <- base::grepl
[17:44:51.744]                         restarts <- computeRestarts(cond)
[17:44:51.744]                         for (restart in restarts) {
[17:44:51.744]                           name <- restart$name
[17:44:51.744]                           if (is.null(name)) 
[17:44:51.744]                             next
[17:44:51.744]                           if (!grepl(pattern, name)) 
[17:44:51.744]                             next
[17:44:51.744]                           invokeRestart(restart)
[17:44:51.744]                           muffled <- TRUE
[17:44:51.744]                           break
[17:44:51.744]                         }
[17:44:51.744]                       }
[17:44:51.744]                     }
[17:44:51.744]                     invisible(muffled)
[17:44:51.744]                   }
[17:44:51.744]                   muffleCondition(cond)
[17:44:51.744]                 })
[17:44:51.744]             }))
[17:44:51.744]             future::FutureResult(value = ...future.value$value, 
[17:44:51.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.744]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.744]                     ...future.globalenv.names))
[17:44:51.744]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.744]         }, condition = base::local({
[17:44:51.744]             c <- base::c
[17:44:51.744]             inherits <- base::inherits
[17:44:51.744]             invokeRestart <- base::invokeRestart
[17:44:51.744]             length <- base::length
[17:44:51.744]             list <- base::list
[17:44:51.744]             seq.int <- base::seq.int
[17:44:51.744]             signalCondition <- base::signalCondition
[17:44:51.744]             sys.calls <- base::sys.calls
[17:44:51.744]             `[[` <- base::`[[`
[17:44:51.744]             `+` <- base::`+`
[17:44:51.744]             `<<-` <- base::`<<-`
[17:44:51.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.744]                   3L)]
[17:44:51.744]             }
[17:44:51.744]             function(cond) {
[17:44:51.744]                 is_error <- inherits(cond, "error")
[17:44:51.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.744]                   NULL)
[17:44:51.744]                 if (is_error) {
[17:44:51.744]                   sessionInformation <- function() {
[17:44:51.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.744]                       search = base::search(), system = base::Sys.info())
[17:44:51.744]                   }
[17:44:51.744]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.744]                     cond$call), session = sessionInformation(), 
[17:44:51.744]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.744]                   signalCondition(cond)
[17:44:51.744]                 }
[17:44:51.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.744]                 "immediateCondition"))) {
[17:44:51.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.744]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.744]                   if (TRUE && !signal) {
[17:44:51.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.744]                     {
[17:44:51.744]                       inherits <- base::inherits
[17:44:51.744]                       invokeRestart <- base::invokeRestart
[17:44:51.744]                       is.null <- base::is.null
[17:44:51.744]                       muffled <- FALSE
[17:44:51.744]                       if (inherits(cond, "message")) {
[17:44:51.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.744]                         if (muffled) 
[17:44:51.744]                           invokeRestart("muffleMessage")
[17:44:51.744]                       }
[17:44:51.744]                       else if (inherits(cond, "warning")) {
[17:44:51.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.744]                         if (muffled) 
[17:44:51.744]                           invokeRestart("muffleWarning")
[17:44:51.744]                       }
[17:44:51.744]                       else if (inherits(cond, "condition")) {
[17:44:51.744]                         if (!is.null(pattern)) {
[17:44:51.744]                           computeRestarts <- base::computeRestarts
[17:44:51.744]                           grepl <- base::grepl
[17:44:51.744]                           restarts <- computeRestarts(cond)
[17:44:51.744]                           for (restart in restarts) {
[17:44:51.744]                             name <- restart$name
[17:44:51.744]                             if (is.null(name)) 
[17:44:51.744]                               next
[17:44:51.744]                             if (!grepl(pattern, name)) 
[17:44:51.744]                               next
[17:44:51.744]                             invokeRestart(restart)
[17:44:51.744]                             muffled <- TRUE
[17:44:51.744]                             break
[17:44:51.744]                           }
[17:44:51.744]                         }
[17:44:51.744]                       }
[17:44:51.744]                       invisible(muffled)
[17:44:51.744]                     }
[17:44:51.744]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.744]                   }
[17:44:51.744]                 }
[17:44:51.744]                 else {
[17:44:51.744]                   if (TRUE) {
[17:44:51.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.744]                     {
[17:44:51.744]                       inherits <- base::inherits
[17:44:51.744]                       invokeRestart <- base::invokeRestart
[17:44:51.744]                       is.null <- base::is.null
[17:44:51.744]                       muffled <- FALSE
[17:44:51.744]                       if (inherits(cond, "message")) {
[17:44:51.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.744]                         if (muffled) 
[17:44:51.744]                           invokeRestart("muffleMessage")
[17:44:51.744]                       }
[17:44:51.744]                       else if (inherits(cond, "warning")) {
[17:44:51.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.744]                         if (muffled) 
[17:44:51.744]                           invokeRestart("muffleWarning")
[17:44:51.744]                       }
[17:44:51.744]                       else if (inherits(cond, "condition")) {
[17:44:51.744]                         if (!is.null(pattern)) {
[17:44:51.744]                           computeRestarts <- base::computeRestarts
[17:44:51.744]                           grepl <- base::grepl
[17:44:51.744]                           restarts <- computeRestarts(cond)
[17:44:51.744]                           for (restart in restarts) {
[17:44:51.744]                             name <- restart$name
[17:44:51.744]                             if (is.null(name)) 
[17:44:51.744]                               next
[17:44:51.744]                             if (!grepl(pattern, name)) 
[17:44:51.744]                               next
[17:44:51.744]                             invokeRestart(restart)
[17:44:51.744]                             muffled <- TRUE
[17:44:51.744]                             break
[17:44:51.744]                           }
[17:44:51.744]                         }
[17:44:51.744]                       }
[17:44:51.744]                       invisible(muffled)
[17:44:51.744]                     }
[17:44:51.744]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.744]                   }
[17:44:51.744]                 }
[17:44:51.744]             }
[17:44:51.744]         }))
[17:44:51.744]     }, error = function(ex) {
[17:44:51.744]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.744]                 ...future.rng), started = ...future.startTime, 
[17:44:51.744]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.744]             version = "1.8"), class = "FutureResult")
[17:44:51.744]     }, finally = {
[17:44:51.744]         if (!identical(...future.workdir, getwd())) 
[17:44:51.744]             setwd(...future.workdir)
[17:44:51.744]         {
[17:44:51.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.744]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.744]             }
[17:44:51.744]             base::options(...future.oldOptions)
[17:44:51.744]             if (.Platform$OS.type == "windows") {
[17:44:51.744]                 old_names <- names(...future.oldEnvVars)
[17:44:51.744]                 envs <- base::Sys.getenv()
[17:44:51.744]                 names <- names(envs)
[17:44:51.744]                 common <- intersect(names, old_names)
[17:44:51.744]                 added <- setdiff(names, old_names)
[17:44:51.744]                 removed <- setdiff(old_names, names)
[17:44:51.744]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.744]                   envs[common]]
[17:44:51.744]                 NAMES <- toupper(changed)
[17:44:51.744]                 args <- list()
[17:44:51.744]                 for (kk in seq_along(NAMES)) {
[17:44:51.744]                   name <- changed[[kk]]
[17:44:51.744]                   NAME <- NAMES[[kk]]
[17:44:51.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.744]                     next
[17:44:51.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.744]                 }
[17:44:51.744]                 NAMES <- toupper(added)
[17:44:51.744]                 for (kk in seq_along(NAMES)) {
[17:44:51.744]                   name <- added[[kk]]
[17:44:51.744]                   NAME <- NAMES[[kk]]
[17:44:51.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.744]                     next
[17:44:51.744]                   args[[name]] <- ""
[17:44:51.744]                 }
[17:44:51.744]                 NAMES <- toupper(removed)
[17:44:51.744]                 for (kk in seq_along(NAMES)) {
[17:44:51.744]                   name <- removed[[kk]]
[17:44:51.744]                   NAME <- NAMES[[kk]]
[17:44:51.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.744]                     next
[17:44:51.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.744]                 }
[17:44:51.744]                 if (length(args) > 0) 
[17:44:51.744]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.744]             }
[17:44:51.744]             else {
[17:44:51.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.744]             }
[17:44:51.744]             {
[17:44:51.744]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.744]                   0L) {
[17:44:51.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.744]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.744]                   base::options(opts)
[17:44:51.744]                 }
[17:44:51.744]                 {
[17:44:51.744]                   {
[17:44:51.744]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.744]                     NULL
[17:44:51.744]                   }
[17:44:51.744]                   options(future.plan = NULL)
[17:44:51.744]                   if (is.na(NA_character_)) 
[17:44:51.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.744]                     .init = FALSE)
[17:44:51.744]                 }
[17:44:51.744]             }
[17:44:51.744]         }
[17:44:51.744]     })
[17:44:51.744]     if (TRUE) {
[17:44:51.744]         base::sink(type = "output", split = FALSE)
[17:44:51.744]         if (TRUE) {
[17:44:51.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.744]         }
[17:44:51.744]         else {
[17:44:51.744]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.744]         }
[17:44:51.744]         base::close(...future.stdout)
[17:44:51.744]         ...future.stdout <- NULL
[17:44:51.744]     }
[17:44:51.744]     ...future.result$conditions <- ...future.conditions
[17:44:51.744]     ...future.result$finished <- base::Sys.time()
[17:44:51.744]     ...future.result
[17:44:51.744] }
[17:44:51.746] Exporting 5 global objects (1.85 KiB) to cluster node #1 ...
[17:44:51.747] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:44:51.747] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:44:51.747] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:44:51.747] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.748] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:44:51.748] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.748] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[17:44:51.748] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[17:44:51.748] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.749] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.749] Exporting 5 global objects (1.85 KiB) to cluster node #1 ... DONE
[17:44:51.749] MultisessionFuture started
[17:44:51.749] - Launch lazy future ... done
[17:44:51.749] run() for ‘MultisessionFuture’ ... done
[17:44:51.750] Created future:
[17:44:51.750] MultisessionFuture:
[17:44:51.750] Label: ‘future_mapply-1’
[17:44:51.750] Expression:
[17:44:51.750] {
[17:44:51.750]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.750]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.750]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.750]         on.exit(options(oopts), add = TRUE)
[17:44:51.750]     }
[17:44:51.750]     {
[17:44:51.750]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:51.750]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:51.750]                 inherits = FALSE)
[17:44:51.750]             ...future.FUN(...)
[17:44:51.750]         }
[17:44:51.750]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:51.750]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:51.750]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.750]         do.call(mapply, args = args)
[17:44:51.750]     }
[17:44:51.750] }
[17:44:51.750] Lazy evaluation: FALSE
[17:44:51.750] Asynchronous evaluation: TRUE
[17:44:51.750] Local evaluation: TRUE
[17:44:51.750] Environment: R_GlobalEnv
[17:44:51.750] Capture standard output: TRUE
[17:44:51.750] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.750] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.750] Packages: <none>
[17:44:51.750] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:51.750] Resolved: FALSE
[17:44:51.750] Value: <not collected>
[17:44:51.750] Conditions captured: <none>
[17:44:51.750] Early signaling: FALSE
[17:44:51.750] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.750] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.761] Chunk #1 of 2 ... DONE
[17:44:51.761] Chunk #2 of 2 ...
[17:44:51.761]  - Finding globals in '...' for chunk #2 ...
[17:44:51.761] getGlobalsAndPackages() ...
[17:44:51.761] Searching for globals...
[17:44:51.762] 
[17:44:51.762] Searching for globals ... DONE
[17:44:51.762] - globals: [0] <none>
[17:44:51.762] getGlobalsAndPackages() ... DONE
[17:44:51.762]    + additional globals found: [n=0] 
[17:44:51.762]    + additional namespaces needed: [n=0] 
[17:44:51.762]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.762]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.762]  - seeds: [1] <seeds>
[17:44:51.763]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.763] getGlobalsAndPackages() ...
[17:44:51.763] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.763] Resolving globals: FALSE
[17:44:51.763] The total size of the 5 globals is 1.85 KiB (1896 bytes)
[17:44:51.764] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.85 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘...future.seeds_ii’ (80 bytes of class ‘list’) and ‘MoreArgs’ (56 bytes of class ‘list’)
[17:44:51.764] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.764] 
[17:44:51.764] getGlobalsAndPackages() ... DONE
[17:44:51.764] run() for ‘Future’ ...
[17:44:51.765] - state: ‘created’
[17:44:51.765] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.779]   - Field: ‘node’
[17:44:51.779]   - Field: ‘label’
[17:44:51.779]   - Field: ‘local’
[17:44:51.779]   - Field: ‘owner’
[17:44:51.780]   - Field: ‘envir’
[17:44:51.780]   - Field: ‘workers’
[17:44:51.780]   - Field: ‘packages’
[17:44:51.780]   - Field: ‘gc’
[17:44:51.780]   - Field: ‘conditions’
[17:44:51.780]   - Field: ‘persistent’
[17:44:51.780]   - Field: ‘expr’
[17:44:51.780]   - Field: ‘uuid’
[17:44:51.780]   - Field: ‘seed’
[17:44:51.780]   - Field: ‘version’
[17:44:51.780]   - Field: ‘result’
[17:44:51.781]   - Field: ‘asynchronous’
[17:44:51.781]   - Field: ‘calls’
[17:44:51.781]   - Field: ‘globals’
[17:44:51.781]   - Field: ‘stdout’
[17:44:51.783]   - Field: ‘earlySignal’
[17:44:51.784]   - Field: ‘lazy’
[17:44:51.784]   - Field: ‘state’
[17:44:51.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.784] - Launch lazy future ...
[17:44:51.784] Packages needed by the future expression (n = 0): <none>
[17:44:51.784] Packages needed by future strategies (n = 0): <none>
[17:44:51.785] {
[17:44:51.785]     {
[17:44:51.785]         {
[17:44:51.785]             ...future.startTime <- base::Sys.time()
[17:44:51.785]             {
[17:44:51.785]                 {
[17:44:51.785]                   {
[17:44:51.785]                     {
[17:44:51.785]                       base::local({
[17:44:51.785]                         has_future <- base::requireNamespace("future", 
[17:44:51.785]                           quietly = TRUE)
[17:44:51.785]                         if (has_future) {
[17:44:51.785]                           ns <- base::getNamespace("future")
[17:44:51.785]                           version <- ns[[".package"]][["version"]]
[17:44:51.785]                           if (is.null(version)) 
[17:44:51.785]                             version <- utils::packageVersion("future")
[17:44:51.785]                         }
[17:44:51.785]                         else {
[17:44:51.785]                           version <- NULL
[17:44:51.785]                         }
[17:44:51.785]                         if (!has_future || version < "1.8.0") {
[17:44:51.785]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.785]                             "", base::R.version$version.string), 
[17:44:51.785]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.785]                               "release", "version")], collapse = " "), 
[17:44:51.785]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.785]                             info)
[17:44:51.785]                           info <- base::paste(info, collapse = "; ")
[17:44:51.785]                           if (!has_future) {
[17:44:51.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.785]                               info)
[17:44:51.785]                           }
[17:44:51.785]                           else {
[17:44:51.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.785]                               info, version)
[17:44:51.785]                           }
[17:44:51.785]                           base::stop(msg)
[17:44:51.785]                         }
[17:44:51.785]                       })
[17:44:51.785]                     }
[17:44:51.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.785]                     base::options(mc.cores = 1L)
[17:44:51.785]                   }
[17:44:51.785]                   ...future.strategy.old <- future::plan("list")
[17:44:51.785]                   options(future.plan = NULL)
[17:44:51.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.785]                 }
[17:44:51.785]                 ...future.workdir <- getwd()
[17:44:51.785]             }
[17:44:51.785]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.785]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.785]         }
[17:44:51.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.785]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.785]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.785]             base::names(...future.oldOptions))
[17:44:51.785]     }
[17:44:51.785]     if (FALSE) {
[17:44:51.785]     }
[17:44:51.785]     else {
[17:44:51.785]         if (TRUE) {
[17:44:51.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.785]                 open = "w")
[17:44:51.785]         }
[17:44:51.785]         else {
[17:44:51.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.785]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.785]         }
[17:44:51.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.785]             base::sink(type = "output", split = FALSE)
[17:44:51.785]             base::close(...future.stdout)
[17:44:51.785]         }, add = TRUE)
[17:44:51.785]     }
[17:44:51.785]     ...future.frame <- base::sys.nframe()
[17:44:51.785]     ...future.conditions <- base::list()
[17:44:51.785]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.785]     if (FALSE) {
[17:44:51.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.785]     }
[17:44:51.785]     ...future.result <- base::tryCatch({
[17:44:51.785]         base::withCallingHandlers({
[17:44:51.785]             ...future.value <- base::withVisible(base::local({
[17:44:51.785]                 ...future.makeSendCondition <- base::local({
[17:44:51.785]                   sendCondition <- NULL
[17:44:51.785]                   function(frame = 1L) {
[17:44:51.785]                     if (is.function(sendCondition)) 
[17:44:51.785]                       return(sendCondition)
[17:44:51.785]                     ns <- getNamespace("parallel")
[17:44:51.785]                     if (exists("sendData", mode = "function", 
[17:44:51.785]                       envir = ns)) {
[17:44:51.785]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.785]                         envir = ns)
[17:44:51.785]                       envir <- sys.frame(frame)
[17:44:51.785]                       master <- NULL
[17:44:51.785]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.785]                         !identical(envir, emptyenv())) {
[17:44:51.785]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.785]                           inherits = FALSE)) {
[17:44:51.785]                           master <- get("master", mode = "list", 
[17:44:51.785]                             envir = envir, inherits = FALSE)
[17:44:51.785]                           if (inherits(master, c("SOCKnode", 
[17:44:51.785]                             "SOCK0node"))) {
[17:44:51.785]                             sendCondition <<- function(cond) {
[17:44:51.785]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.785]                                 success = TRUE)
[17:44:51.785]                               parallel_sendData(master, data)
[17:44:51.785]                             }
[17:44:51.785]                             return(sendCondition)
[17:44:51.785]                           }
[17:44:51.785]                         }
[17:44:51.785]                         frame <- frame + 1L
[17:44:51.785]                         envir <- sys.frame(frame)
[17:44:51.785]                       }
[17:44:51.785]                     }
[17:44:51.785]                     sendCondition <<- function(cond) NULL
[17:44:51.785]                   }
[17:44:51.785]                 })
[17:44:51.785]                 withCallingHandlers({
[17:44:51.785]                   {
[17:44:51.785]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.785]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.785]                       ...future.globals.maxSize)) {
[17:44:51.785]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.785]                       on.exit(options(oopts), add = TRUE)
[17:44:51.785]                     }
[17:44:51.785]                     {
[17:44:51.785]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:51.785]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:51.785]                           envir = globalenv(), inherits = FALSE)
[17:44:51.785]                         ...future.FUN(...)
[17:44:51.785]                       }
[17:44:51.785]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:51.785]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:51.785]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.785]                         USE.NAMES = FALSE)
[17:44:51.785]                       do.call(mapply, args = args)
[17:44:51.785]                     }
[17:44:51.785]                   }
[17:44:51.785]                 }, immediateCondition = function(cond) {
[17:44:51.785]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.785]                   sendCondition(cond)
[17:44:51.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.785]                   {
[17:44:51.785]                     inherits <- base::inherits
[17:44:51.785]                     invokeRestart <- base::invokeRestart
[17:44:51.785]                     is.null <- base::is.null
[17:44:51.785]                     muffled <- FALSE
[17:44:51.785]                     if (inherits(cond, "message")) {
[17:44:51.785]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.785]                       if (muffled) 
[17:44:51.785]                         invokeRestart("muffleMessage")
[17:44:51.785]                     }
[17:44:51.785]                     else if (inherits(cond, "warning")) {
[17:44:51.785]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.785]                       if (muffled) 
[17:44:51.785]                         invokeRestart("muffleWarning")
[17:44:51.785]                     }
[17:44:51.785]                     else if (inherits(cond, "condition")) {
[17:44:51.785]                       if (!is.null(pattern)) {
[17:44:51.785]                         computeRestarts <- base::computeRestarts
[17:44:51.785]                         grepl <- base::grepl
[17:44:51.785]                         restarts <- computeRestarts(cond)
[17:44:51.785]                         for (restart in restarts) {
[17:44:51.785]                           name <- restart$name
[17:44:51.785]                           if (is.null(name)) 
[17:44:51.785]                             next
[17:44:51.785]                           if (!grepl(pattern, name)) 
[17:44:51.785]                             next
[17:44:51.785]                           invokeRestart(restart)
[17:44:51.785]                           muffled <- TRUE
[17:44:51.785]                           break
[17:44:51.785]                         }
[17:44:51.785]                       }
[17:44:51.785]                     }
[17:44:51.785]                     invisible(muffled)
[17:44:51.785]                   }
[17:44:51.785]                   muffleCondition(cond)
[17:44:51.785]                 })
[17:44:51.785]             }))
[17:44:51.785]             future::FutureResult(value = ...future.value$value, 
[17:44:51.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.785]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.785]                     ...future.globalenv.names))
[17:44:51.785]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.785]         }, condition = base::local({
[17:44:51.785]             c <- base::c
[17:44:51.785]             inherits <- base::inherits
[17:44:51.785]             invokeRestart <- base::invokeRestart
[17:44:51.785]             length <- base::length
[17:44:51.785]             list <- base::list
[17:44:51.785]             seq.int <- base::seq.int
[17:44:51.785]             signalCondition <- base::signalCondition
[17:44:51.785]             sys.calls <- base::sys.calls
[17:44:51.785]             `[[` <- base::`[[`
[17:44:51.785]             `+` <- base::`+`
[17:44:51.785]             `<<-` <- base::`<<-`
[17:44:51.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.785]                   3L)]
[17:44:51.785]             }
[17:44:51.785]             function(cond) {
[17:44:51.785]                 is_error <- inherits(cond, "error")
[17:44:51.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.785]                   NULL)
[17:44:51.785]                 if (is_error) {
[17:44:51.785]                   sessionInformation <- function() {
[17:44:51.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.785]                       search = base::search(), system = base::Sys.info())
[17:44:51.785]                   }
[17:44:51.785]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.785]                     cond$call), session = sessionInformation(), 
[17:44:51.785]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.785]                   signalCondition(cond)
[17:44:51.785]                 }
[17:44:51.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.785]                 "immediateCondition"))) {
[17:44:51.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.785]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.785]                   if (TRUE && !signal) {
[17:44:51.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.785]                     {
[17:44:51.785]                       inherits <- base::inherits
[17:44:51.785]                       invokeRestart <- base::invokeRestart
[17:44:51.785]                       is.null <- base::is.null
[17:44:51.785]                       muffled <- FALSE
[17:44:51.785]                       if (inherits(cond, "message")) {
[17:44:51.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.785]                         if (muffled) 
[17:44:51.785]                           invokeRestart("muffleMessage")
[17:44:51.785]                       }
[17:44:51.785]                       else if (inherits(cond, "warning")) {
[17:44:51.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.785]                         if (muffled) 
[17:44:51.785]                           invokeRestart("muffleWarning")
[17:44:51.785]                       }
[17:44:51.785]                       else if (inherits(cond, "condition")) {
[17:44:51.785]                         if (!is.null(pattern)) {
[17:44:51.785]                           computeRestarts <- base::computeRestarts
[17:44:51.785]                           grepl <- base::grepl
[17:44:51.785]                           restarts <- computeRestarts(cond)
[17:44:51.785]                           for (restart in restarts) {
[17:44:51.785]                             name <- restart$name
[17:44:51.785]                             if (is.null(name)) 
[17:44:51.785]                               next
[17:44:51.785]                             if (!grepl(pattern, name)) 
[17:44:51.785]                               next
[17:44:51.785]                             invokeRestart(restart)
[17:44:51.785]                             muffled <- TRUE
[17:44:51.785]                             break
[17:44:51.785]                           }
[17:44:51.785]                         }
[17:44:51.785]                       }
[17:44:51.785]                       invisible(muffled)
[17:44:51.785]                     }
[17:44:51.785]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.785]                   }
[17:44:51.785]                 }
[17:44:51.785]                 else {
[17:44:51.785]                   if (TRUE) {
[17:44:51.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.785]                     {
[17:44:51.785]                       inherits <- base::inherits
[17:44:51.785]                       invokeRestart <- base::invokeRestart
[17:44:51.785]                       is.null <- base::is.null
[17:44:51.785]                       muffled <- FALSE
[17:44:51.785]                       if (inherits(cond, "message")) {
[17:44:51.785]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.785]                         if (muffled) 
[17:44:51.785]                           invokeRestart("muffleMessage")
[17:44:51.785]                       }
[17:44:51.785]                       else if (inherits(cond, "warning")) {
[17:44:51.785]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.785]                         if (muffled) 
[17:44:51.785]                           invokeRestart("muffleWarning")
[17:44:51.785]                       }
[17:44:51.785]                       else if (inherits(cond, "condition")) {
[17:44:51.785]                         if (!is.null(pattern)) {
[17:44:51.785]                           computeRestarts <- base::computeRestarts
[17:44:51.785]                           grepl <- base::grepl
[17:44:51.785]                           restarts <- computeRestarts(cond)
[17:44:51.785]                           for (restart in restarts) {
[17:44:51.785]                             name <- restart$name
[17:44:51.785]                             if (is.null(name)) 
[17:44:51.785]                               next
[17:44:51.785]                             if (!grepl(pattern, name)) 
[17:44:51.785]                               next
[17:44:51.785]                             invokeRestart(restart)
[17:44:51.785]                             muffled <- TRUE
[17:44:51.785]                             break
[17:44:51.785]                           }
[17:44:51.785]                         }
[17:44:51.785]                       }
[17:44:51.785]                       invisible(muffled)
[17:44:51.785]                     }
[17:44:51.785]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.785]                   }
[17:44:51.785]                 }
[17:44:51.785]             }
[17:44:51.785]         }))
[17:44:51.785]     }, error = function(ex) {
[17:44:51.785]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.785]                 ...future.rng), started = ...future.startTime, 
[17:44:51.785]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.785]             version = "1.8"), class = "FutureResult")
[17:44:51.785]     }, finally = {
[17:44:51.785]         if (!identical(...future.workdir, getwd())) 
[17:44:51.785]             setwd(...future.workdir)
[17:44:51.785]         {
[17:44:51.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.785]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.785]             }
[17:44:51.785]             base::options(...future.oldOptions)
[17:44:51.785]             if (.Platform$OS.type == "windows") {
[17:44:51.785]                 old_names <- names(...future.oldEnvVars)
[17:44:51.785]                 envs <- base::Sys.getenv()
[17:44:51.785]                 names <- names(envs)
[17:44:51.785]                 common <- intersect(names, old_names)
[17:44:51.785]                 added <- setdiff(names, old_names)
[17:44:51.785]                 removed <- setdiff(old_names, names)
[17:44:51.785]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.785]                   envs[common]]
[17:44:51.785]                 NAMES <- toupper(changed)
[17:44:51.785]                 args <- list()
[17:44:51.785]                 for (kk in seq_along(NAMES)) {
[17:44:51.785]                   name <- changed[[kk]]
[17:44:51.785]                   NAME <- NAMES[[kk]]
[17:44:51.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.785]                     next
[17:44:51.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.785]                 }
[17:44:51.785]                 NAMES <- toupper(added)
[17:44:51.785]                 for (kk in seq_along(NAMES)) {
[17:44:51.785]                   name <- added[[kk]]
[17:44:51.785]                   NAME <- NAMES[[kk]]
[17:44:51.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.785]                     next
[17:44:51.785]                   args[[name]] <- ""
[17:44:51.785]                 }
[17:44:51.785]                 NAMES <- toupper(removed)
[17:44:51.785]                 for (kk in seq_along(NAMES)) {
[17:44:51.785]                   name <- removed[[kk]]
[17:44:51.785]                   NAME <- NAMES[[kk]]
[17:44:51.785]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.785]                     next
[17:44:51.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.785]                 }
[17:44:51.785]                 if (length(args) > 0) 
[17:44:51.785]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.785]             }
[17:44:51.785]             else {
[17:44:51.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.785]             }
[17:44:51.785]             {
[17:44:51.785]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.785]                   0L) {
[17:44:51.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.785]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.785]                   base::options(opts)
[17:44:51.785]                 }
[17:44:51.785]                 {
[17:44:51.785]                   {
[17:44:51.785]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.785]                     NULL
[17:44:51.785]                   }
[17:44:51.785]                   options(future.plan = NULL)
[17:44:51.785]                   if (is.na(NA_character_)) 
[17:44:51.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.785]                     .init = FALSE)
[17:44:51.785]                 }
[17:44:51.785]             }
[17:44:51.785]         }
[17:44:51.785]     })
[17:44:51.785]     if (TRUE) {
[17:44:51.785]         base::sink(type = "output", split = FALSE)
[17:44:51.785]         if (TRUE) {
[17:44:51.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.785]         }
[17:44:51.785]         else {
[17:44:51.785]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.785]         }
[17:44:51.785]         base::close(...future.stdout)
[17:44:51.785]         ...future.stdout <- NULL
[17:44:51.785]     }
[17:44:51.785]     ...future.result$conditions <- ...future.conditions
[17:44:51.785]     ...future.result$finished <- base::Sys.time()
[17:44:51.785]     ...future.result
[17:44:51.785] }
[17:44:51.787] Exporting 5 global objects (1.85 KiB) to cluster node #2 ...
[17:44:51.787] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:44:51.788] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:44:51.788] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:44:51.788] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.788] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:44:51.789] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.789] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[17:44:51.789] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[17:44:51.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.789] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.790] Exporting 5 global objects (1.85 KiB) to cluster node #2 ... DONE
[17:44:51.790] MultisessionFuture started
[17:44:51.790] - Launch lazy future ... done
[17:44:51.790] run() for ‘MultisessionFuture’ ... done
[17:44:51.790] Created future:
[17:44:51.790] MultisessionFuture:
[17:44:51.790] Label: ‘future_mapply-2’
[17:44:51.790] Expression:
[17:44:51.790] {
[17:44:51.790]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.790]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.790]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.790]         on.exit(options(oopts), add = TRUE)
[17:44:51.790]     }
[17:44:51.790]     {
[17:44:51.790]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:51.790]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:51.790]                 inherits = FALSE)
[17:44:51.790]             ...future.FUN(...)
[17:44:51.790]         }
[17:44:51.790]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:51.790]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:51.790]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.790]         do.call(mapply, args = args)
[17:44:51.790]     }
[17:44:51.790] }
[17:44:51.790] Lazy evaluation: FALSE
[17:44:51.790] Asynchronous evaluation: TRUE
[17:44:51.790] Local evaluation: TRUE
[17:44:51.790] Environment: R_GlobalEnv
[17:44:51.790] Capture standard output: TRUE
[17:44:51.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.790] Globals: 5 objects totaling 1.85 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.790] Packages: <none>
[17:44:51.790] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:51.790] Resolved: FALSE
[17:44:51.790] Value: <not collected>
[17:44:51.790] Conditions captured: <none>
[17:44:51.790] Early signaling: FALSE
[17:44:51.790] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.790] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.802] Chunk #2 of 2 ... DONE
[17:44:51.802] Launching 2 futures (chunks) ... DONE
[17:44:51.802] Resolving 2 futures (chunks) ...
[17:44:51.802] resolve() on list ...
[17:44:51.802]  recursive: 0
[17:44:51.802]  length: 2
[17:44:51.802] 
[17:44:51.803] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.803] - Validating connection of MultisessionFuture
[17:44:51.803] - received message: FutureResult
[17:44:51.803] - Received FutureResult
[17:44:51.803] - Erased future from FutureRegistry
[17:44:51.804] result() for ClusterFuture ...
[17:44:51.804] - result already collected: FutureResult
[17:44:51.804] result() for ClusterFuture ... done
[17:44:51.804] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.804] Future #1
[17:44:51.804] result() for ClusterFuture ...
[17:44:51.804] - result already collected: FutureResult
[17:44:51.804] result() for ClusterFuture ... done
[17:44:51.804] result() for ClusterFuture ...
[17:44:51.804] - result already collected: FutureResult
[17:44:51.804] result() for ClusterFuture ... done
[17:44:51.804] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.805] - nx: 2
[17:44:51.805] - relay: TRUE
[17:44:51.805] - stdout: TRUE
[17:44:51.805] - signal: TRUE
[17:44:51.805] - resignal: FALSE
[17:44:51.805] - force: TRUE
[17:44:51.805] - relayed: [n=2] FALSE, FALSE
[17:44:51.805] - queued futures: [n=2] FALSE, FALSE
[17:44:51.805]  - until=1
[17:44:51.805]  - relaying element #1
[17:44:51.805] result() for ClusterFuture ...
[17:44:51.805] - result already collected: FutureResult
[17:44:51.805] result() for ClusterFuture ... done
[17:44:51.806] result() for ClusterFuture ...
[17:44:51.806] - result already collected: FutureResult
[17:44:51.806] result() for ClusterFuture ... done
[17:44:51.806] result() for ClusterFuture ...
[17:44:51.806] - result already collected: FutureResult
[17:44:51.806] result() for ClusterFuture ... done
[17:44:51.806] result() for ClusterFuture ...
[17:44:51.806] - result already collected: FutureResult
[17:44:51.806] result() for ClusterFuture ... done
[17:44:51.806] - relayed: [n=2] TRUE, FALSE
[17:44:51.806] - queued futures: [n=2] TRUE, FALSE
[17:44:51.807] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.807]  length: 1 (resolved future 1)
[17:44:51.833] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.833] - Validating connection of MultisessionFuture
[17:44:51.833] - received message: FutureResult
[17:44:51.833] - Received FutureResult
[17:44:51.833] - Erased future from FutureRegistry
[17:44:51.833] result() for ClusterFuture ...
[17:44:51.833] - result already collected: FutureResult
[17:44:51.834] result() for ClusterFuture ... done
[17:44:51.834] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.834] Future #2
[17:44:51.834] result() for ClusterFuture ...
[17:44:51.834] - result already collected: FutureResult
[17:44:51.834] result() for ClusterFuture ... done
[17:44:51.834] result() for ClusterFuture ...
[17:44:51.834] - result already collected: FutureResult
[17:44:51.834] result() for ClusterFuture ... done
[17:44:51.834] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.834] - nx: 2
[17:44:51.834] - relay: TRUE
[17:44:51.835] - stdout: TRUE
[17:44:51.835] - signal: TRUE
[17:44:51.835] - resignal: FALSE
[17:44:51.835] - force: TRUE
[17:44:51.835] - relayed: [n=2] TRUE, FALSE
[17:44:51.835] - queued futures: [n=2] TRUE, FALSE
[17:44:51.835]  - until=2
[17:44:51.835]  - relaying element #2
[17:44:51.835] result() for ClusterFuture ...
[17:44:51.835] - result already collected: FutureResult
[17:44:51.835] result() for ClusterFuture ... done
[17:44:51.835] result() for ClusterFuture ...
[17:44:51.836] - result already collected: FutureResult
[17:44:51.836] result() for ClusterFuture ... done
[17:44:51.836] result() for ClusterFuture ...
[17:44:51.836] - result already collected: FutureResult
[17:44:51.836] result() for ClusterFuture ... done
[17:44:51.836] result() for ClusterFuture ...
[17:44:51.836] - result already collected: FutureResult
[17:44:51.836] result() for ClusterFuture ... done
[17:44:51.836] - relayed: [n=2] TRUE, TRUE
[17:44:51.836] - queued futures: [n=2] TRUE, TRUE
[17:44:51.836] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.837]  length: 0 (resolved future 2)
[17:44:51.837] Relaying remaining futures
[17:44:51.837] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.837] - nx: 2
[17:44:51.837] - relay: TRUE
[17:44:51.837] - stdout: TRUE
[17:44:51.837] - signal: TRUE
[17:44:51.837] - resignal: FALSE
[17:44:51.837] - force: TRUE
[17:44:51.837] - relayed: [n=2] TRUE, TRUE
[17:44:51.837] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.837] - relayed: [n=2] TRUE, TRUE
[17:44:51.838] - queued futures: [n=2] TRUE, TRUE
[17:44:51.838] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.838] resolve() on list ... DONE
[17:44:51.838] result() for ClusterFuture ...
[17:44:51.838] - result already collected: FutureResult
[17:44:51.838] result() for ClusterFuture ... done
[17:44:51.838] result() for ClusterFuture ...
[17:44:51.838] - result already collected: FutureResult
[17:44:51.838] result() for ClusterFuture ... done
[17:44:51.838] result() for ClusterFuture ...
[17:44:51.838] - result already collected: FutureResult
[17:44:51.838] result() for ClusterFuture ... done
[17:44:51.839] result() for ClusterFuture ...
[17:44:51.839] - result already collected: FutureResult
[17:44:51.839] result() for ClusterFuture ... done
[17:44:51.839]  - Number of value chunks collected: 2
[17:44:51.839] Resolving 2 futures (chunks) ... DONE
[17:44:51.839] Reducing values from 2 chunks ...
[17:44:51.839]  - Number of values collected after concatenation: 2
[17:44:51.839]  - Number of values expected: 2
[17:44:51.839] Reducing values from 2 chunks ... DONE
[17:44:51.839] future_mapply() ... DONE
[17:44:51.839] future_mapply() ...
[17:44:51.843] Number of chunks: 2
[17:44:51.843] getGlobalsAndPackagesXApply() ...
[17:44:51.844]  - future.globals: TRUE
[17:44:51.844] getGlobalsAndPackages() ...
[17:44:51.844] Searching for globals...
[17:44:51.845] - globals found: [1] ‘FUN’
[17:44:51.845] Searching for globals ... DONE
[17:44:51.845] Resolving globals: FALSE
[17:44:51.845] The total size of the 1 globals is 1.66 KiB (1704 bytes)
[17:44:51.846] The total size of the 1 globals exported for future expression (‘FUN(y = 3:4)’) is 1.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.66 KiB of class ‘function’)
[17:44:51.846] - globals: [1] ‘FUN’
[17:44:51.846] 
[17:44:51.846] getGlobalsAndPackages() ... DONE
[17:44:51.846]  - globals found/used: [n=1] ‘FUN’
[17:44:51.846]  - needed namespaces: [n=0] 
[17:44:51.846] Finding globals ... DONE
[17:44:51.846] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.846] List of 2
[17:44:51.846]  $ ...future.FUN:function (x, y)  
[17:44:51.846]  $ MoreArgs     :List of 1
[17:44:51.846]   ..$ y: int [1:2] 3 4
[17:44:51.846]  - attr(*, "where")=List of 2
[17:44:51.846]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.846]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.846]  - attr(*, "resolved")= logi FALSE
[17:44:51.846]  - attr(*, "total_size")= num NA
[17:44:51.849] Packages to be attached in all futures: [n=0] 
[17:44:51.849] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.849] Number of futures (= number of chunks): 2
[17:44:51.849] Launching 2 futures (chunks) ...
[17:44:51.850] Chunk #1 of 2 ...
[17:44:51.850]  - Finding globals in '...' for chunk #1 ...
[17:44:51.850] getGlobalsAndPackages() ...
[17:44:51.850] Searching for globals...
[17:44:51.850] 
[17:44:51.850] Searching for globals ... DONE
[17:44:51.850] - globals: [0] <none>
[17:44:51.850] getGlobalsAndPackages() ... DONE
[17:44:51.850]    + additional globals found: [n=0] 
[17:44:51.851]    + additional namespaces needed: [n=0] 
[17:44:51.851]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.851]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.851]  - seeds: <none>
[17:44:51.851]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.851] getGlobalsAndPackages() ...
[17:44:51.851] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.851] Resolving globals: FALSE
[17:44:51.852] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:51.852] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:51.852] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.852] 
[17:44:51.852] getGlobalsAndPackages() ... DONE
[17:44:51.853] run() for ‘Future’ ...
[17:44:51.853] - state: ‘created’
[17:44:51.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.867]   - Field: ‘node’
[17:44:51.867]   - Field: ‘label’
[17:44:51.867]   - Field: ‘local’
[17:44:51.867]   - Field: ‘owner’
[17:44:51.867]   - Field: ‘envir’
[17:44:51.867]   - Field: ‘workers’
[17:44:51.867]   - Field: ‘packages’
[17:44:51.867]   - Field: ‘gc’
[17:44:51.867]   - Field: ‘conditions’
[17:44:51.868]   - Field: ‘persistent’
[17:44:51.868]   - Field: ‘expr’
[17:44:51.868]   - Field: ‘uuid’
[17:44:51.868]   - Field: ‘seed’
[17:44:51.868]   - Field: ‘version’
[17:44:51.868]   - Field: ‘result’
[17:44:51.868]   - Field: ‘asynchronous’
[17:44:51.868]   - Field: ‘calls’
[17:44:51.868]   - Field: ‘globals’
[17:44:51.868]   - Field: ‘stdout’
[17:44:51.868]   - Field: ‘earlySignal’
[17:44:51.868]   - Field: ‘lazy’
[17:44:51.869]   - Field: ‘state’
[17:44:51.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.869] - Launch lazy future ...
[17:44:51.869] Packages needed by the future expression (n = 0): <none>
[17:44:51.869] Packages needed by future strategies (n = 0): <none>
[17:44:51.870] {
[17:44:51.870]     {
[17:44:51.870]         {
[17:44:51.870]             ...future.startTime <- base::Sys.time()
[17:44:51.870]             {
[17:44:51.870]                 {
[17:44:51.870]                   {
[17:44:51.870]                     {
[17:44:51.870]                       base::local({
[17:44:51.870]                         has_future <- base::requireNamespace("future", 
[17:44:51.870]                           quietly = TRUE)
[17:44:51.870]                         if (has_future) {
[17:44:51.870]                           ns <- base::getNamespace("future")
[17:44:51.870]                           version <- ns[[".package"]][["version"]]
[17:44:51.870]                           if (is.null(version)) 
[17:44:51.870]                             version <- utils::packageVersion("future")
[17:44:51.870]                         }
[17:44:51.870]                         else {
[17:44:51.870]                           version <- NULL
[17:44:51.870]                         }
[17:44:51.870]                         if (!has_future || version < "1.8.0") {
[17:44:51.870]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.870]                             "", base::R.version$version.string), 
[17:44:51.870]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.870]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.870]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.870]                               "release", "version")], collapse = " "), 
[17:44:51.870]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.870]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.870]                             info)
[17:44:51.870]                           info <- base::paste(info, collapse = "; ")
[17:44:51.870]                           if (!has_future) {
[17:44:51.870]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.870]                               info)
[17:44:51.870]                           }
[17:44:51.870]                           else {
[17:44:51.870]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.870]                               info, version)
[17:44:51.870]                           }
[17:44:51.870]                           base::stop(msg)
[17:44:51.870]                         }
[17:44:51.870]                       })
[17:44:51.870]                     }
[17:44:51.870]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.870]                     base::options(mc.cores = 1L)
[17:44:51.870]                   }
[17:44:51.870]                   ...future.strategy.old <- future::plan("list")
[17:44:51.870]                   options(future.plan = NULL)
[17:44:51.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.870]                 }
[17:44:51.870]                 ...future.workdir <- getwd()
[17:44:51.870]             }
[17:44:51.870]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.870]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.870]         }
[17:44:51.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.870]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.870]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.870]             base::names(...future.oldOptions))
[17:44:51.870]     }
[17:44:51.870]     if (FALSE) {
[17:44:51.870]     }
[17:44:51.870]     else {
[17:44:51.870]         if (TRUE) {
[17:44:51.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.870]                 open = "w")
[17:44:51.870]         }
[17:44:51.870]         else {
[17:44:51.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.870]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.870]         }
[17:44:51.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.870]             base::sink(type = "output", split = FALSE)
[17:44:51.870]             base::close(...future.stdout)
[17:44:51.870]         }, add = TRUE)
[17:44:51.870]     }
[17:44:51.870]     ...future.frame <- base::sys.nframe()
[17:44:51.870]     ...future.conditions <- base::list()
[17:44:51.870]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.870]     if (FALSE) {
[17:44:51.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.870]     }
[17:44:51.870]     ...future.result <- base::tryCatch({
[17:44:51.870]         base::withCallingHandlers({
[17:44:51.870]             ...future.value <- base::withVisible(base::local({
[17:44:51.870]                 ...future.makeSendCondition <- base::local({
[17:44:51.870]                   sendCondition <- NULL
[17:44:51.870]                   function(frame = 1L) {
[17:44:51.870]                     if (is.function(sendCondition)) 
[17:44:51.870]                       return(sendCondition)
[17:44:51.870]                     ns <- getNamespace("parallel")
[17:44:51.870]                     if (exists("sendData", mode = "function", 
[17:44:51.870]                       envir = ns)) {
[17:44:51.870]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.870]                         envir = ns)
[17:44:51.870]                       envir <- sys.frame(frame)
[17:44:51.870]                       master <- NULL
[17:44:51.870]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.870]                         !identical(envir, emptyenv())) {
[17:44:51.870]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.870]                           inherits = FALSE)) {
[17:44:51.870]                           master <- get("master", mode = "list", 
[17:44:51.870]                             envir = envir, inherits = FALSE)
[17:44:51.870]                           if (inherits(master, c("SOCKnode", 
[17:44:51.870]                             "SOCK0node"))) {
[17:44:51.870]                             sendCondition <<- function(cond) {
[17:44:51.870]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.870]                                 success = TRUE)
[17:44:51.870]                               parallel_sendData(master, data)
[17:44:51.870]                             }
[17:44:51.870]                             return(sendCondition)
[17:44:51.870]                           }
[17:44:51.870]                         }
[17:44:51.870]                         frame <- frame + 1L
[17:44:51.870]                         envir <- sys.frame(frame)
[17:44:51.870]                       }
[17:44:51.870]                     }
[17:44:51.870]                     sendCondition <<- function(cond) NULL
[17:44:51.870]                   }
[17:44:51.870]                 })
[17:44:51.870]                 withCallingHandlers({
[17:44:51.870]                   {
[17:44:51.870]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.870]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.870]                       ...future.globals.maxSize)) {
[17:44:51.870]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.870]                       on.exit(options(oopts), add = TRUE)
[17:44:51.870]                     }
[17:44:51.870]                     {
[17:44:51.870]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.870]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.870]                         USE.NAMES = FALSE)
[17:44:51.870]                       do.call(mapply, args = args)
[17:44:51.870]                     }
[17:44:51.870]                   }
[17:44:51.870]                 }, immediateCondition = function(cond) {
[17:44:51.870]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.870]                   sendCondition(cond)
[17:44:51.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.870]                   {
[17:44:51.870]                     inherits <- base::inherits
[17:44:51.870]                     invokeRestart <- base::invokeRestart
[17:44:51.870]                     is.null <- base::is.null
[17:44:51.870]                     muffled <- FALSE
[17:44:51.870]                     if (inherits(cond, "message")) {
[17:44:51.870]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.870]                       if (muffled) 
[17:44:51.870]                         invokeRestart("muffleMessage")
[17:44:51.870]                     }
[17:44:51.870]                     else if (inherits(cond, "warning")) {
[17:44:51.870]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.870]                       if (muffled) 
[17:44:51.870]                         invokeRestart("muffleWarning")
[17:44:51.870]                     }
[17:44:51.870]                     else if (inherits(cond, "condition")) {
[17:44:51.870]                       if (!is.null(pattern)) {
[17:44:51.870]                         computeRestarts <- base::computeRestarts
[17:44:51.870]                         grepl <- base::grepl
[17:44:51.870]                         restarts <- computeRestarts(cond)
[17:44:51.870]                         for (restart in restarts) {
[17:44:51.870]                           name <- restart$name
[17:44:51.870]                           if (is.null(name)) 
[17:44:51.870]                             next
[17:44:51.870]                           if (!grepl(pattern, name)) 
[17:44:51.870]                             next
[17:44:51.870]                           invokeRestart(restart)
[17:44:51.870]                           muffled <- TRUE
[17:44:51.870]                           break
[17:44:51.870]                         }
[17:44:51.870]                       }
[17:44:51.870]                     }
[17:44:51.870]                     invisible(muffled)
[17:44:51.870]                   }
[17:44:51.870]                   muffleCondition(cond)
[17:44:51.870]                 })
[17:44:51.870]             }))
[17:44:51.870]             future::FutureResult(value = ...future.value$value, 
[17:44:51.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.870]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.870]                     ...future.globalenv.names))
[17:44:51.870]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.870]         }, condition = base::local({
[17:44:51.870]             c <- base::c
[17:44:51.870]             inherits <- base::inherits
[17:44:51.870]             invokeRestart <- base::invokeRestart
[17:44:51.870]             length <- base::length
[17:44:51.870]             list <- base::list
[17:44:51.870]             seq.int <- base::seq.int
[17:44:51.870]             signalCondition <- base::signalCondition
[17:44:51.870]             sys.calls <- base::sys.calls
[17:44:51.870]             `[[` <- base::`[[`
[17:44:51.870]             `+` <- base::`+`
[17:44:51.870]             `<<-` <- base::`<<-`
[17:44:51.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.870]                   3L)]
[17:44:51.870]             }
[17:44:51.870]             function(cond) {
[17:44:51.870]                 is_error <- inherits(cond, "error")
[17:44:51.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.870]                   NULL)
[17:44:51.870]                 if (is_error) {
[17:44:51.870]                   sessionInformation <- function() {
[17:44:51.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.870]                       search = base::search(), system = base::Sys.info())
[17:44:51.870]                   }
[17:44:51.870]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.870]                     cond$call), session = sessionInformation(), 
[17:44:51.870]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.870]                   signalCondition(cond)
[17:44:51.870]                 }
[17:44:51.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.870]                 "immediateCondition"))) {
[17:44:51.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.870]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.870]                   if (TRUE && !signal) {
[17:44:51.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.870]                     {
[17:44:51.870]                       inherits <- base::inherits
[17:44:51.870]                       invokeRestart <- base::invokeRestart
[17:44:51.870]                       is.null <- base::is.null
[17:44:51.870]                       muffled <- FALSE
[17:44:51.870]                       if (inherits(cond, "message")) {
[17:44:51.870]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.870]                         if (muffled) 
[17:44:51.870]                           invokeRestart("muffleMessage")
[17:44:51.870]                       }
[17:44:51.870]                       else if (inherits(cond, "warning")) {
[17:44:51.870]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.870]                         if (muffled) 
[17:44:51.870]                           invokeRestart("muffleWarning")
[17:44:51.870]                       }
[17:44:51.870]                       else if (inherits(cond, "condition")) {
[17:44:51.870]                         if (!is.null(pattern)) {
[17:44:51.870]                           computeRestarts <- base::computeRestarts
[17:44:51.870]                           grepl <- base::grepl
[17:44:51.870]                           restarts <- computeRestarts(cond)
[17:44:51.870]                           for (restart in restarts) {
[17:44:51.870]                             name <- restart$name
[17:44:51.870]                             if (is.null(name)) 
[17:44:51.870]                               next
[17:44:51.870]                             if (!grepl(pattern, name)) 
[17:44:51.870]                               next
[17:44:51.870]                             invokeRestart(restart)
[17:44:51.870]                             muffled <- TRUE
[17:44:51.870]                             break
[17:44:51.870]                           }
[17:44:51.870]                         }
[17:44:51.870]                       }
[17:44:51.870]                       invisible(muffled)
[17:44:51.870]                     }
[17:44:51.870]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.870]                   }
[17:44:51.870]                 }
[17:44:51.870]                 else {
[17:44:51.870]                   if (TRUE) {
[17:44:51.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.870]                     {
[17:44:51.870]                       inherits <- base::inherits
[17:44:51.870]                       invokeRestart <- base::invokeRestart
[17:44:51.870]                       is.null <- base::is.null
[17:44:51.870]                       muffled <- FALSE
[17:44:51.870]                       if (inherits(cond, "message")) {
[17:44:51.870]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.870]                         if (muffled) 
[17:44:51.870]                           invokeRestart("muffleMessage")
[17:44:51.870]                       }
[17:44:51.870]                       else if (inherits(cond, "warning")) {
[17:44:51.870]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.870]                         if (muffled) 
[17:44:51.870]                           invokeRestart("muffleWarning")
[17:44:51.870]                       }
[17:44:51.870]                       else if (inherits(cond, "condition")) {
[17:44:51.870]                         if (!is.null(pattern)) {
[17:44:51.870]                           computeRestarts <- base::computeRestarts
[17:44:51.870]                           grepl <- base::grepl
[17:44:51.870]                           restarts <- computeRestarts(cond)
[17:44:51.870]                           for (restart in restarts) {
[17:44:51.870]                             name <- restart$name
[17:44:51.870]                             if (is.null(name)) 
[17:44:51.870]                               next
[17:44:51.870]                             if (!grepl(pattern, name)) 
[17:44:51.870]                               next
[17:44:51.870]                             invokeRestart(restart)
[17:44:51.870]                             muffled <- TRUE
[17:44:51.870]                             break
[17:44:51.870]                           }
[17:44:51.870]                         }
[17:44:51.870]                       }
[17:44:51.870]                       invisible(muffled)
[17:44:51.870]                     }
[17:44:51.870]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.870]                   }
[17:44:51.870]                 }
[17:44:51.870]             }
[17:44:51.870]         }))
[17:44:51.870]     }, error = function(ex) {
[17:44:51.870]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.870]                 ...future.rng), started = ...future.startTime, 
[17:44:51.870]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.870]             version = "1.8"), class = "FutureResult")
[17:44:51.870]     }, finally = {
[17:44:51.870]         if (!identical(...future.workdir, getwd())) 
[17:44:51.870]             setwd(...future.workdir)
[17:44:51.870]         {
[17:44:51.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.870]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.870]             }
[17:44:51.870]             base::options(...future.oldOptions)
[17:44:51.870]             if (.Platform$OS.type == "windows") {
[17:44:51.870]                 old_names <- names(...future.oldEnvVars)
[17:44:51.870]                 envs <- base::Sys.getenv()
[17:44:51.870]                 names <- names(envs)
[17:44:51.870]                 common <- intersect(names, old_names)
[17:44:51.870]                 added <- setdiff(names, old_names)
[17:44:51.870]                 removed <- setdiff(old_names, names)
[17:44:51.870]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.870]                   envs[common]]
[17:44:51.870]                 NAMES <- toupper(changed)
[17:44:51.870]                 args <- list()
[17:44:51.870]                 for (kk in seq_along(NAMES)) {
[17:44:51.870]                   name <- changed[[kk]]
[17:44:51.870]                   NAME <- NAMES[[kk]]
[17:44:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.870]                     next
[17:44:51.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.870]                 }
[17:44:51.870]                 NAMES <- toupper(added)
[17:44:51.870]                 for (kk in seq_along(NAMES)) {
[17:44:51.870]                   name <- added[[kk]]
[17:44:51.870]                   NAME <- NAMES[[kk]]
[17:44:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.870]                     next
[17:44:51.870]                   args[[name]] <- ""
[17:44:51.870]                 }
[17:44:51.870]                 NAMES <- toupper(removed)
[17:44:51.870]                 for (kk in seq_along(NAMES)) {
[17:44:51.870]                   name <- removed[[kk]]
[17:44:51.870]                   NAME <- NAMES[[kk]]
[17:44:51.870]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.870]                     next
[17:44:51.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.870]                 }
[17:44:51.870]                 if (length(args) > 0) 
[17:44:51.870]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.870]             }
[17:44:51.870]             else {
[17:44:51.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.870]             }
[17:44:51.870]             {
[17:44:51.870]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.870]                   0L) {
[17:44:51.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.870]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.870]                   base::options(opts)
[17:44:51.870]                 }
[17:44:51.870]                 {
[17:44:51.870]                   {
[17:44:51.870]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.870]                     NULL
[17:44:51.870]                   }
[17:44:51.870]                   options(future.plan = NULL)
[17:44:51.870]                   if (is.na(NA_character_)) 
[17:44:51.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.870]                     .init = FALSE)
[17:44:51.870]                 }
[17:44:51.870]             }
[17:44:51.870]         }
[17:44:51.870]     })
[17:44:51.870]     if (TRUE) {
[17:44:51.870]         base::sink(type = "output", split = FALSE)
[17:44:51.870]         if (TRUE) {
[17:44:51.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.870]         }
[17:44:51.870]         else {
[17:44:51.870]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.870]         }
[17:44:51.870]         base::close(...future.stdout)
[17:44:51.870]         ...future.stdout <- NULL
[17:44:51.870]     }
[17:44:51.870]     ...future.result$conditions <- ...future.conditions
[17:44:51.870]     ...future.result$finished <- base::Sys.time()
[17:44:51.870]     ...future.result
[17:44:51.870] }
[17:44:51.872] Exporting 5 global objects (1.77 KiB) to cluster node #1 ...
[17:44:51.872] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ...
[17:44:51.873] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #1 ... DONE
[17:44:51.873] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:44:51.873] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.873] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:44:51.874] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:51.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:51.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:51.875] Exporting 5 global objects (1.77 KiB) to cluster node #1 ... DONE
[17:44:51.875] MultisessionFuture started
[17:44:51.875] - Launch lazy future ... done
[17:44:51.875] run() for ‘MultisessionFuture’ ... done
[17:44:51.875] Created future:
[17:44:51.875] MultisessionFuture:
[17:44:51.875] Label: ‘future_.mapply-1’
[17:44:51.875] Expression:
[17:44:51.875] {
[17:44:51.875]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.875]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.875]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.875]         on.exit(options(oopts), add = TRUE)
[17:44:51.875]     }
[17:44:51.875]     {
[17:44:51.875]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.875]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.875]         do.call(mapply, args = args)
[17:44:51.875]     }
[17:44:51.875] }
[17:44:51.875] Lazy evaluation: FALSE
[17:44:51.875] Asynchronous evaluation: TRUE
[17:44:51.875] Local evaluation: TRUE
[17:44:51.875] Environment: R_GlobalEnv
[17:44:51.875] Capture standard output: TRUE
[17:44:51.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.875] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.875] Packages: <none>
[17:44:51.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.875] Resolved: FALSE
[17:44:51.875] Value: <not collected>
[17:44:51.875] Conditions captured: <none>
[17:44:51.875] Early signaling: FALSE
[17:44:51.875] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.875] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.887] Chunk #1 of 2 ... DONE
[17:44:51.887] Chunk #2 of 2 ...
[17:44:51.887]  - Finding globals in '...' for chunk #2 ...
[17:44:51.887] getGlobalsAndPackages() ...
[17:44:51.887] Searching for globals...
[17:44:51.887] 
[17:44:51.888] Searching for globals ... DONE
[17:44:51.888] - globals: [0] <none>
[17:44:51.888] getGlobalsAndPackages() ... DONE
[17:44:51.888]    + additional globals found: [n=0] 
[17:44:51.888]    + additional namespaces needed: [n=0] 
[17:44:51.888]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:51.888]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.888]  - seeds: <none>
[17:44:51.888]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.888] getGlobalsAndPackages() ...
[17:44:51.888] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.889] Resolving globals: FALSE
[17:44:51.889] The total size of the 5 globals is 1.77 KiB (1816 bytes)
[17:44:51.889] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.77 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.66 KiB of class ‘function’), ‘MoreArgs’ (56 bytes of class ‘list’) and ‘...future.elements_ii’ (56 bytes of class ‘list’)
[17:44:51.890] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.890] 
[17:44:51.890] getGlobalsAndPackages() ... DONE
[17:44:51.890] run() for ‘Future’ ...
[17:44:51.890] - state: ‘created’
[17:44:51.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.904] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.904]   - Field: ‘node’
[17:44:51.904]   - Field: ‘label’
[17:44:51.904]   - Field: ‘local’
[17:44:51.904]   - Field: ‘owner’
[17:44:51.904]   - Field: ‘envir’
[17:44:51.905]   - Field: ‘workers’
[17:44:51.905]   - Field: ‘packages’
[17:44:51.905]   - Field: ‘gc’
[17:44:51.905]   - Field: ‘conditions’
[17:44:51.905]   - Field: ‘persistent’
[17:44:51.905]   - Field: ‘expr’
[17:44:51.905]   - Field: ‘uuid’
[17:44:51.905]   - Field: ‘seed’
[17:44:51.905]   - Field: ‘version’
[17:44:51.905]   - Field: ‘result’
[17:44:51.905]   - Field: ‘asynchronous’
[17:44:51.906]   - Field: ‘calls’
[17:44:51.906]   - Field: ‘globals’
[17:44:51.906]   - Field: ‘stdout’
[17:44:51.906]   - Field: ‘earlySignal’
[17:44:51.906]   - Field: ‘lazy’
[17:44:51.906]   - Field: ‘state’
[17:44:51.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.906] - Launch lazy future ...
[17:44:51.906] Packages needed by the future expression (n = 0): <none>
[17:44:51.907] Packages needed by future strategies (n = 0): <none>
[17:44:51.907] {
[17:44:51.907]     {
[17:44:51.907]         {
[17:44:51.907]             ...future.startTime <- base::Sys.time()
[17:44:51.907]             {
[17:44:51.907]                 {
[17:44:51.907]                   {
[17:44:51.907]                     {
[17:44:51.907]                       base::local({
[17:44:51.907]                         has_future <- base::requireNamespace("future", 
[17:44:51.907]                           quietly = TRUE)
[17:44:51.907]                         if (has_future) {
[17:44:51.907]                           ns <- base::getNamespace("future")
[17:44:51.907]                           version <- ns[[".package"]][["version"]]
[17:44:51.907]                           if (is.null(version)) 
[17:44:51.907]                             version <- utils::packageVersion("future")
[17:44:51.907]                         }
[17:44:51.907]                         else {
[17:44:51.907]                           version <- NULL
[17:44:51.907]                         }
[17:44:51.907]                         if (!has_future || version < "1.8.0") {
[17:44:51.907]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.907]                             "", base::R.version$version.string), 
[17:44:51.907]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.907]                               "release", "version")], collapse = " "), 
[17:44:51.907]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.907]                             info)
[17:44:51.907]                           info <- base::paste(info, collapse = "; ")
[17:44:51.907]                           if (!has_future) {
[17:44:51.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.907]                               info)
[17:44:51.907]                           }
[17:44:51.907]                           else {
[17:44:51.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.907]                               info, version)
[17:44:51.907]                           }
[17:44:51.907]                           base::stop(msg)
[17:44:51.907]                         }
[17:44:51.907]                       })
[17:44:51.907]                     }
[17:44:51.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.907]                     base::options(mc.cores = 1L)
[17:44:51.907]                   }
[17:44:51.907]                   ...future.strategy.old <- future::plan("list")
[17:44:51.907]                   options(future.plan = NULL)
[17:44:51.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.907]                 }
[17:44:51.907]                 ...future.workdir <- getwd()
[17:44:51.907]             }
[17:44:51.907]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.907]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.907]         }
[17:44:51.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.907]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.907]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.907]             base::names(...future.oldOptions))
[17:44:51.907]     }
[17:44:51.907]     if (FALSE) {
[17:44:51.907]     }
[17:44:51.907]     else {
[17:44:51.907]         if (TRUE) {
[17:44:51.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.907]                 open = "w")
[17:44:51.907]         }
[17:44:51.907]         else {
[17:44:51.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.907]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.907]         }
[17:44:51.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.907]             base::sink(type = "output", split = FALSE)
[17:44:51.907]             base::close(...future.stdout)
[17:44:51.907]         }, add = TRUE)
[17:44:51.907]     }
[17:44:51.907]     ...future.frame <- base::sys.nframe()
[17:44:51.907]     ...future.conditions <- base::list()
[17:44:51.907]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.907]     if (FALSE) {
[17:44:51.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.907]     }
[17:44:51.907]     ...future.result <- base::tryCatch({
[17:44:51.907]         base::withCallingHandlers({
[17:44:51.907]             ...future.value <- base::withVisible(base::local({
[17:44:51.907]                 ...future.makeSendCondition <- base::local({
[17:44:51.907]                   sendCondition <- NULL
[17:44:51.907]                   function(frame = 1L) {
[17:44:51.907]                     if (is.function(sendCondition)) 
[17:44:51.907]                       return(sendCondition)
[17:44:51.907]                     ns <- getNamespace("parallel")
[17:44:51.907]                     if (exists("sendData", mode = "function", 
[17:44:51.907]                       envir = ns)) {
[17:44:51.907]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.907]                         envir = ns)
[17:44:51.907]                       envir <- sys.frame(frame)
[17:44:51.907]                       master <- NULL
[17:44:51.907]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.907]                         !identical(envir, emptyenv())) {
[17:44:51.907]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.907]                           inherits = FALSE)) {
[17:44:51.907]                           master <- get("master", mode = "list", 
[17:44:51.907]                             envir = envir, inherits = FALSE)
[17:44:51.907]                           if (inherits(master, c("SOCKnode", 
[17:44:51.907]                             "SOCK0node"))) {
[17:44:51.907]                             sendCondition <<- function(cond) {
[17:44:51.907]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.907]                                 success = TRUE)
[17:44:51.907]                               parallel_sendData(master, data)
[17:44:51.907]                             }
[17:44:51.907]                             return(sendCondition)
[17:44:51.907]                           }
[17:44:51.907]                         }
[17:44:51.907]                         frame <- frame + 1L
[17:44:51.907]                         envir <- sys.frame(frame)
[17:44:51.907]                       }
[17:44:51.907]                     }
[17:44:51.907]                     sendCondition <<- function(cond) NULL
[17:44:51.907]                   }
[17:44:51.907]                 })
[17:44:51.907]                 withCallingHandlers({
[17:44:51.907]                   {
[17:44:51.907]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.907]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.907]                       ...future.globals.maxSize)) {
[17:44:51.907]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.907]                       on.exit(options(oopts), add = TRUE)
[17:44:51.907]                     }
[17:44:51.907]                     {
[17:44:51.907]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.907]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.907]                         USE.NAMES = FALSE)
[17:44:51.907]                       do.call(mapply, args = args)
[17:44:51.907]                     }
[17:44:51.907]                   }
[17:44:51.907]                 }, immediateCondition = function(cond) {
[17:44:51.907]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.907]                   sendCondition(cond)
[17:44:51.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.907]                   {
[17:44:51.907]                     inherits <- base::inherits
[17:44:51.907]                     invokeRestart <- base::invokeRestart
[17:44:51.907]                     is.null <- base::is.null
[17:44:51.907]                     muffled <- FALSE
[17:44:51.907]                     if (inherits(cond, "message")) {
[17:44:51.907]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.907]                       if (muffled) 
[17:44:51.907]                         invokeRestart("muffleMessage")
[17:44:51.907]                     }
[17:44:51.907]                     else if (inherits(cond, "warning")) {
[17:44:51.907]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.907]                       if (muffled) 
[17:44:51.907]                         invokeRestart("muffleWarning")
[17:44:51.907]                     }
[17:44:51.907]                     else if (inherits(cond, "condition")) {
[17:44:51.907]                       if (!is.null(pattern)) {
[17:44:51.907]                         computeRestarts <- base::computeRestarts
[17:44:51.907]                         grepl <- base::grepl
[17:44:51.907]                         restarts <- computeRestarts(cond)
[17:44:51.907]                         for (restart in restarts) {
[17:44:51.907]                           name <- restart$name
[17:44:51.907]                           if (is.null(name)) 
[17:44:51.907]                             next
[17:44:51.907]                           if (!grepl(pattern, name)) 
[17:44:51.907]                             next
[17:44:51.907]                           invokeRestart(restart)
[17:44:51.907]                           muffled <- TRUE
[17:44:51.907]                           break
[17:44:51.907]                         }
[17:44:51.907]                       }
[17:44:51.907]                     }
[17:44:51.907]                     invisible(muffled)
[17:44:51.907]                   }
[17:44:51.907]                   muffleCondition(cond)
[17:44:51.907]                 })
[17:44:51.907]             }))
[17:44:51.907]             future::FutureResult(value = ...future.value$value, 
[17:44:51.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.907]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.907]                     ...future.globalenv.names))
[17:44:51.907]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.907]         }, condition = base::local({
[17:44:51.907]             c <- base::c
[17:44:51.907]             inherits <- base::inherits
[17:44:51.907]             invokeRestart <- base::invokeRestart
[17:44:51.907]             length <- base::length
[17:44:51.907]             list <- base::list
[17:44:51.907]             seq.int <- base::seq.int
[17:44:51.907]             signalCondition <- base::signalCondition
[17:44:51.907]             sys.calls <- base::sys.calls
[17:44:51.907]             `[[` <- base::`[[`
[17:44:51.907]             `+` <- base::`+`
[17:44:51.907]             `<<-` <- base::`<<-`
[17:44:51.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.907]                   3L)]
[17:44:51.907]             }
[17:44:51.907]             function(cond) {
[17:44:51.907]                 is_error <- inherits(cond, "error")
[17:44:51.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.907]                   NULL)
[17:44:51.907]                 if (is_error) {
[17:44:51.907]                   sessionInformation <- function() {
[17:44:51.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.907]                       search = base::search(), system = base::Sys.info())
[17:44:51.907]                   }
[17:44:51.907]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.907]                     cond$call), session = sessionInformation(), 
[17:44:51.907]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.907]                   signalCondition(cond)
[17:44:51.907]                 }
[17:44:51.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.907]                 "immediateCondition"))) {
[17:44:51.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.907]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.907]                   if (TRUE && !signal) {
[17:44:51.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.907]                     {
[17:44:51.907]                       inherits <- base::inherits
[17:44:51.907]                       invokeRestart <- base::invokeRestart
[17:44:51.907]                       is.null <- base::is.null
[17:44:51.907]                       muffled <- FALSE
[17:44:51.907]                       if (inherits(cond, "message")) {
[17:44:51.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.907]                         if (muffled) 
[17:44:51.907]                           invokeRestart("muffleMessage")
[17:44:51.907]                       }
[17:44:51.907]                       else if (inherits(cond, "warning")) {
[17:44:51.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.907]                         if (muffled) 
[17:44:51.907]                           invokeRestart("muffleWarning")
[17:44:51.907]                       }
[17:44:51.907]                       else if (inherits(cond, "condition")) {
[17:44:51.907]                         if (!is.null(pattern)) {
[17:44:51.907]                           computeRestarts <- base::computeRestarts
[17:44:51.907]                           grepl <- base::grepl
[17:44:51.907]                           restarts <- computeRestarts(cond)
[17:44:51.907]                           for (restart in restarts) {
[17:44:51.907]                             name <- restart$name
[17:44:51.907]                             if (is.null(name)) 
[17:44:51.907]                               next
[17:44:51.907]                             if (!grepl(pattern, name)) 
[17:44:51.907]                               next
[17:44:51.907]                             invokeRestart(restart)
[17:44:51.907]                             muffled <- TRUE
[17:44:51.907]                             break
[17:44:51.907]                           }
[17:44:51.907]                         }
[17:44:51.907]                       }
[17:44:51.907]                       invisible(muffled)
[17:44:51.907]                     }
[17:44:51.907]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.907]                   }
[17:44:51.907]                 }
[17:44:51.907]                 else {
[17:44:51.907]                   if (TRUE) {
[17:44:51.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.907]                     {
[17:44:51.907]                       inherits <- base::inherits
[17:44:51.907]                       invokeRestart <- base::invokeRestart
[17:44:51.907]                       is.null <- base::is.null
[17:44:51.907]                       muffled <- FALSE
[17:44:51.907]                       if (inherits(cond, "message")) {
[17:44:51.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.907]                         if (muffled) 
[17:44:51.907]                           invokeRestart("muffleMessage")
[17:44:51.907]                       }
[17:44:51.907]                       else if (inherits(cond, "warning")) {
[17:44:51.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.907]                         if (muffled) 
[17:44:51.907]                           invokeRestart("muffleWarning")
[17:44:51.907]                       }
[17:44:51.907]                       else if (inherits(cond, "condition")) {
[17:44:51.907]                         if (!is.null(pattern)) {
[17:44:51.907]                           computeRestarts <- base::computeRestarts
[17:44:51.907]                           grepl <- base::grepl
[17:44:51.907]                           restarts <- computeRestarts(cond)
[17:44:51.907]                           for (restart in restarts) {
[17:44:51.907]                             name <- restart$name
[17:44:51.907]                             if (is.null(name)) 
[17:44:51.907]                               next
[17:44:51.907]                             if (!grepl(pattern, name)) 
[17:44:51.907]                               next
[17:44:51.907]                             invokeRestart(restart)
[17:44:51.907]                             muffled <- TRUE
[17:44:51.907]                             break
[17:44:51.907]                           }
[17:44:51.907]                         }
[17:44:51.907]                       }
[17:44:51.907]                       invisible(muffled)
[17:44:51.907]                     }
[17:44:51.907]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.907]                   }
[17:44:51.907]                 }
[17:44:51.907]             }
[17:44:51.907]         }))
[17:44:51.907]     }, error = function(ex) {
[17:44:51.907]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.907]                 ...future.rng), started = ...future.startTime, 
[17:44:51.907]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.907]             version = "1.8"), class = "FutureResult")
[17:44:51.907]     }, finally = {
[17:44:51.907]         if (!identical(...future.workdir, getwd())) 
[17:44:51.907]             setwd(...future.workdir)
[17:44:51.907]         {
[17:44:51.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.907]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.907]             }
[17:44:51.907]             base::options(...future.oldOptions)
[17:44:51.907]             if (.Platform$OS.type == "windows") {
[17:44:51.907]                 old_names <- names(...future.oldEnvVars)
[17:44:51.907]                 envs <- base::Sys.getenv()
[17:44:51.907]                 names <- names(envs)
[17:44:51.907]                 common <- intersect(names, old_names)
[17:44:51.907]                 added <- setdiff(names, old_names)
[17:44:51.907]                 removed <- setdiff(old_names, names)
[17:44:51.907]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.907]                   envs[common]]
[17:44:51.907]                 NAMES <- toupper(changed)
[17:44:51.907]                 args <- list()
[17:44:51.907]                 for (kk in seq_along(NAMES)) {
[17:44:51.907]                   name <- changed[[kk]]
[17:44:51.907]                   NAME <- NAMES[[kk]]
[17:44:51.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.907]                     next
[17:44:51.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.907]                 }
[17:44:51.907]                 NAMES <- toupper(added)
[17:44:51.907]                 for (kk in seq_along(NAMES)) {
[17:44:51.907]                   name <- added[[kk]]
[17:44:51.907]                   NAME <- NAMES[[kk]]
[17:44:51.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.907]                     next
[17:44:51.907]                   args[[name]] <- ""
[17:44:51.907]                 }
[17:44:51.907]                 NAMES <- toupper(removed)
[17:44:51.907]                 for (kk in seq_along(NAMES)) {
[17:44:51.907]                   name <- removed[[kk]]
[17:44:51.907]                   NAME <- NAMES[[kk]]
[17:44:51.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.907]                     next
[17:44:51.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.907]                 }
[17:44:51.907]                 if (length(args) > 0) 
[17:44:51.907]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.907]             }
[17:44:51.907]             else {
[17:44:51.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.907]             }
[17:44:51.907]             {
[17:44:51.907]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.907]                   0L) {
[17:44:51.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.907]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.907]                   base::options(opts)
[17:44:51.907]                 }
[17:44:51.907]                 {
[17:44:51.907]                   {
[17:44:51.907]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.907]                     NULL
[17:44:51.907]                   }
[17:44:51.907]                   options(future.plan = NULL)
[17:44:51.907]                   if (is.na(NA_character_)) 
[17:44:51.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.907]                     .init = FALSE)
[17:44:51.907]                 }
[17:44:51.907]             }
[17:44:51.907]         }
[17:44:51.907]     })
[17:44:51.907]     if (TRUE) {
[17:44:51.907]         base::sink(type = "output", split = FALSE)
[17:44:51.907]         if (TRUE) {
[17:44:51.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.907]         }
[17:44:51.907]         else {
[17:44:51.907]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.907]         }
[17:44:51.907]         base::close(...future.stdout)
[17:44:51.907]         ...future.stdout <- NULL
[17:44:51.907]     }
[17:44:51.907]     ...future.result$conditions <- ...future.conditions
[17:44:51.907]     ...future.result$finished <- base::Sys.time()
[17:44:51.907]     ...future.result
[17:44:51.907] }
[17:44:51.910] Exporting 5 global objects (1.77 KiB) to cluster node #2 ...
[17:44:51.910] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ...
[17:44:51.910] Exporting ‘...future.FUN’ (1.66 KiB) to cluster node #2 ... DONE
[17:44:51.910] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:44:51.911] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.911] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:44:51.911] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:44:51.911] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:51.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.912] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:51.912] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:51.912] Exporting 5 global objects (1.77 KiB) to cluster node #2 ... DONE
[17:44:51.913] MultisessionFuture started
[17:44:51.913] - Launch lazy future ... done
[17:44:51.913] run() for ‘MultisessionFuture’ ... done
[17:44:51.913] Created future:
[17:44:51.913] MultisessionFuture:
[17:44:51.913] Label: ‘future_.mapply-2’
[17:44:51.913] Expression:
[17:44:51.913] {
[17:44:51.913]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.913]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:51.913]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.913]         on.exit(options(oopts), add = TRUE)
[17:44:51.913]     }
[17:44:51.913]     {
[17:44:51.913]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.913]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:51.913]         do.call(mapply, args = args)
[17:44:51.913]     }
[17:44:51.913] }
[17:44:51.913] Lazy evaluation: FALSE
[17:44:51.913] Asynchronous evaluation: TRUE
[17:44:51.913] Local evaluation: TRUE
[17:44:51.913] Environment: R_GlobalEnv
[17:44:51.913] Capture standard output: TRUE
[17:44:51.913] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:51.913] Globals: 5 objects totaling 1.77 KiB (function ‘...future.FUN’ of 1.66 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:51.913] Packages: <none>
[17:44:51.913] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:51.913] Resolved: FALSE
[17:44:51.913] Value: <not collected>
[17:44:51.913] Conditions captured: <none>
[17:44:51.913] Early signaling: FALSE
[17:44:51.913] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:51.913] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.924] Chunk #2 of 2 ... DONE
[17:44:51.924] Launching 2 futures (chunks) ... DONE
[17:44:51.924] Resolving 2 futures (chunks) ...
[17:44:51.925] resolve() on list ...
[17:44:51.925]  recursive: 0
[17:44:51.925]  length: 2
[17:44:51.925] 
[17:44:51.925] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.925] - Validating connection of MultisessionFuture
[17:44:51.926] - received message: FutureResult
[17:44:51.926] - Received FutureResult
[17:44:51.926] - Erased future from FutureRegistry
[17:44:51.926] result() for ClusterFuture ...
[17:44:51.926] - result already collected: FutureResult
[17:44:51.926] result() for ClusterFuture ... done
[17:44:51.926] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.926] Future #1
[17:44:51.926] result() for ClusterFuture ...
[17:44:51.926] - result already collected: FutureResult
[17:44:51.927] result() for ClusterFuture ... done
[17:44:51.927] result() for ClusterFuture ...
[17:44:51.927] - result already collected: FutureResult
[17:44:51.927] result() for ClusterFuture ... done
[17:44:51.927] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:51.927] - nx: 2
[17:44:51.927] - relay: TRUE
[17:44:51.927] - stdout: TRUE
[17:44:51.927] - signal: TRUE
[17:44:51.927] - resignal: FALSE
[17:44:51.927] - force: TRUE
[17:44:51.927] - relayed: [n=2] FALSE, FALSE
[17:44:51.928] - queued futures: [n=2] FALSE, FALSE
[17:44:51.928]  - until=1
[17:44:51.928]  - relaying element #1
[17:44:51.928] result() for ClusterFuture ...
[17:44:51.928] - result already collected: FutureResult
[17:44:51.928] result() for ClusterFuture ... done
[17:44:51.928] result() for ClusterFuture ...
[17:44:51.928] - result already collected: FutureResult
[17:44:51.928] result() for ClusterFuture ... done
[17:44:51.928] result() for ClusterFuture ...
[17:44:51.928] - result already collected: FutureResult
[17:44:51.929] result() for ClusterFuture ... done
[17:44:51.929] result() for ClusterFuture ...
[17:44:51.929] - result already collected: FutureResult
[17:44:51.929] result() for ClusterFuture ... done
[17:44:51.929] - relayed: [n=2] TRUE, FALSE
[17:44:51.929] - queued futures: [n=2] TRUE, FALSE
[17:44:51.929] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:51.929]  length: 1 (resolved future 1)
[17:44:51.957] receiveMessageFromWorker() for ClusterFuture ...
[17:44:51.957] - Validating connection of MultisessionFuture
[17:44:51.957] - received message: FutureResult
[17:44:51.957] - Received FutureResult
[17:44:51.957] - Erased future from FutureRegistry
[17:44:51.958] result() for ClusterFuture ...
[17:44:51.958] - result already collected: FutureResult
[17:44:51.958] result() for ClusterFuture ... done
[17:44:51.958] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:51.958] Future #2
[17:44:51.958] result() for ClusterFuture ...
[17:44:51.958] - result already collected: FutureResult
[17:44:51.958] result() for ClusterFuture ... done
[17:44:51.958] result() for ClusterFuture ...
[17:44:51.958] - result already collected: FutureResult
[17:44:51.958] result() for ClusterFuture ... done
[17:44:51.959] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:51.959] - nx: 2
[17:44:51.959] - relay: TRUE
[17:44:51.959] - stdout: TRUE
[17:44:51.959] - signal: TRUE
[17:44:51.959] - resignal: FALSE
[17:44:51.959] - force: TRUE
[17:44:51.959] - relayed: [n=2] TRUE, FALSE
[17:44:51.959] - queued futures: [n=2] TRUE, FALSE
[17:44:51.959]  - until=2
[17:44:51.959]  - relaying element #2
[17:44:51.960] result() for ClusterFuture ...
[17:44:51.960] - result already collected: FutureResult
[17:44:51.960] result() for ClusterFuture ... done
[17:44:51.960] result() for ClusterFuture ...
[17:44:51.960] - result already collected: FutureResult
[17:44:51.960] result() for ClusterFuture ... done
[17:44:51.960] result() for ClusterFuture ...
[17:44:51.960] - result already collected: FutureResult
[17:44:51.960] result() for ClusterFuture ... done
[17:44:51.960] result() for ClusterFuture ...
[17:44:51.960] - result already collected: FutureResult
[17:44:51.960] result() for ClusterFuture ... done
[17:44:51.961] - relayed: [n=2] TRUE, TRUE
[17:44:51.961] - queued futures: [n=2] TRUE, TRUE
[17:44:51.961] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:51.961]  length: 0 (resolved future 2)
[17:44:51.961] Relaying remaining futures
[17:44:51.961] signalConditionsASAP(NULL, pos=0) ...
[17:44:51.961] - nx: 2
[17:44:51.961] - relay: TRUE
[17:44:51.961] - stdout: TRUE
[17:44:51.961] - signal: TRUE
[17:44:51.961] - resignal: FALSE
[17:44:51.961] - force: TRUE
[17:44:51.962] - relayed: [n=2] TRUE, TRUE
[17:44:51.962] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:51.962] - relayed: [n=2] TRUE, TRUE
[17:44:51.962] - queued futures: [n=2] TRUE, TRUE
[17:44:51.962] signalConditionsASAP(NULL, pos=0) ... done
[17:44:51.962] resolve() on list ... DONE
[17:44:51.962] result() for ClusterFuture ...
[17:44:51.962] - result already collected: FutureResult
[17:44:51.962] result() for ClusterFuture ... done
[17:44:51.962] result() for ClusterFuture ...
[17:44:51.962] - result already collected: FutureResult
[17:44:51.963] result() for ClusterFuture ... done
[17:44:51.963] result() for ClusterFuture ...
[17:44:51.963] - result already collected: FutureResult
[17:44:51.963] result() for ClusterFuture ... done
[17:44:51.963] result() for ClusterFuture ...
[17:44:51.963] - result already collected: FutureResult
[17:44:51.963] result() for ClusterFuture ... done
[17:44:51.963]  - Number of value chunks collected: 2
[17:44:51.963] Resolving 2 futures (chunks) ... DONE
[17:44:51.963] Reducing values from 2 chunks ...
[17:44:51.964]  - Number of values collected after concatenation: 2
[17:44:51.964]  - Number of values expected: 2
[17:44:51.964] Reducing values from 2 chunks ... DONE
[17:44:51.964] future_mapply() ... DONE
- Recycle arguments to same length ...
[17:44:51.964] future_mapply() ...
[17:44:51.968] Number of chunks: 2
[17:44:51.968] getGlobalsAndPackagesXApply() ...
[17:44:51.968]  - future.globals: TRUE
[17:44:51.968] getGlobalsAndPackages() ...
[17:44:51.968] Searching for globals...
[17:44:51.969] - globals found: [1] ‘FUN’
[17:44:51.969] Searching for globals ... DONE
[17:44:51.969] Resolving globals: FALSE
[17:44:51.969] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:51.970] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:51.970] - globals: [1] ‘FUN’
[17:44:51.970] 
[17:44:51.970] getGlobalsAndPackages() ... DONE
[17:44:51.970]  - globals found/used: [n=1] ‘FUN’
[17:44:51.970]  - needed namespaces: [n=0] 
[17:44:51.970] Finding globals ... DONE
[17:44:51.970] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:51.971] List of 2
[17:44:51.971]  $ ...future.FUN:function (x, ...)  
[17:44:51.971]  $ MoreArgs     : NULL
[17:44:51.971]  - attr(*, "where")=List of 2
[17:44:51.971]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:51.971]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:51.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:51.971]  - attr(*, "resolved")= logi FALSE
[17:44:51.971]  - attr(*, "total_size")= num NA
[17:44:51.975] Packages to be attached in all futures: [n=0] 
[17:44:51.976] getGlobalsAndPackagesXApply() ... DONE
[17:44:51.976] Number of futures (= number of chunks): 2
[17:44:51.976] Launching 2 futures (chunks) ...
[17:44:51.976] Chunk #1 of 2 ...
[17:44:51.976]  - Finding globals in '...' for chunk #1 ...
[17:44:51.976] getGlobalsAndPackages() ...
[17:44:51.976] Searching for globals...
[17:44:51.977] 
[17:44:51.977] Searching for globals ... DONE
[17:44:51.977] - globals: [0] <none>
[17:44:51.977] getGlobalsAndPackages() ... DONE
[17:44:51.977]    + additional globals found: [n=0] 
[17:44:51.977]    + additional namespaces needed: [n=0] 
[17:44:51.977]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:51.977]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:51.977]  - seeds: <none>
[17:44:51.977]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.977] getGlobalsAndPackages() ...
[17:44:51.977] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.978] Resolving globals: FALSE
[17:44:51.978] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:51.978] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:51.979] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:51.979] 
[17:44:51.979] getGlobalsAndPackages() ... DONE
[17:44:51.979] run() for ‘Future’ ...
[17:44:51.979] - state: ‘created’
[17:44:51.979] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:51.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:51.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:51.993]   - Field: ‘node’
[17:44:51.993]   - Field: ‘label’
[17:44:51.993]   - Field: ‘local’
[17:44:51.993]   - Field: ‘owner’
[17:44:51.993]   - Field: ‘envir’
[17:44:51.993]   - Field: ‘workers’
[17:44:51.993]   - Field: ‘packages’
[17:44:51.993]   - Field: ‘gc’
[17:44:51.993]   - Field: ‘conditions’
[17:44:51.994]   - Field: ‘persistent’
[17:44:51.994]   - Field: ‘expr’
[17:44:51.994]   - Field: ‘uuid’
[17:44:51.994]   - Field: ‘seed’
[17:44:51.994]   - Field: ‘version’
[17:44:51.994]   - Field: ‘result’
[17:44:51.994]   - Field: ‘asynchronous’
[17:44:51.994]   - Field: ‘calls’
[17:44:51.994]   - Field: ‘globals’
[17:44:51.994]   - Field: ‘stdout’
[17:44:51.994]   - Field: ‘earlySignal’
[17:44:51.995]   - Field: ‘lazy’
[17:44:51.995]   - Field: ‘state’
[17:44:51.995] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:51.995] - Launch lazy future ...
[17:44:51.995] Packages needed by the future expression (n = 0): <none>
[17:44:51.995] Packages needed by future strategies (n = 0): <none>
[17:44:51.996] {
[17:44:51.996]     {
[17:44:51.996]         {
[17:44:51.996]             ...future.startTime <- base::Sys.time()
[17:44:51.996]             {
[17:44:51.996]                 {
[17:44:51.996]                   {
[17:44:51.996]                     {
[17:44:51.996]                       base::local({
[17:44:51.996]                         has_future <- base::requireNamespace("future", 
[17:44:51.996]                           quietly = TRUE)
[17:44:51.996]                         if (has_future) {
[17:44:51.996]                           ns <- base::getNamespace("future")
[17:44:51.996]                           version <- ns[[".package"]][["version"]]
[17:44:51.996]                           if (is.null(version)) 
[17:44:51.996]                             version <- utils::packageVersion("future")
[17:44:51.996]                         }
[17:44:51.996]                         else {
[17:44:51.996]                           version <- NULL
[17:44:51.996]                         }
[17:44:51.996]                         if (!has_future || version < "1.8.0") {
[17:44:51.996]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:51.996]                             "", base::R.version$version.string), 
[17:44:51.996]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:51.996]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:51.996]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:51.996]                               "release", "version")], collapse = " "), 
[17:44:51.996]                             hostname = base::Sys.info()[["nodename"]])
[17:44:51.996]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:51.996]                             info)
[17:44:51.996]                           info <- base::paste(info, collapse = "; ")
[17:44:51.996]                           if (!has_future) {
[17:44:51.996]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:51.996]                               info)
[17:44:51.996]                           }
[17:44:51.996]                           else {
[17:44:51.996]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:51.996]                               info, version)
[17:44:51.996]                           }
[17:44:51.996]                           base::stop(msg)
[17:44:51.996]                         }
[17:44:51.996]                       })
[17:44:51.996]                     }
[17:44:51.996]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:51.996]                     base::options(mc.cores = 1L)
[17:44:51.996]                   }
[17:44:51.996]                   ...future.strategy.old <- future::plan("list")
[17:44:51.996]                   options(future.plan = NULL)
[17:44:51.996]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.996]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:51.996]                 }
[17:44:51.996]                 ...future.workdir <- getwd()
[17:44:51.996]             }
[17:44:51.996]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:51.996]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:51.996]         }
[17:44:51.996]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:51.996]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:51.996]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:51.996]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:51.996]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:51.996]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:51.996]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:51.996]             base::names(...future.oldOptions))
[17:44:51.996]     }
[17:44:51.996]     if (FALSE) {
[17:44:51.996]     }
[17:44:51.996]     else {
[17:44:51.996]         if (TRUE) {
[17:44:51.996]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:51.996]                 open = "w")
[17:44:51.996]         }
[17:44:51.996]         else {
[17:44:51.996]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:51.996]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:51.996]         }
[17:44:51.996]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:51.996]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:51.996]             base::sink(type = "output", split = FALSE)
[17:44:51.996]             base::close(...future.stdout)
[17:44:51.996]         }, add = TRUE)
[17:44:51.996]     }
[17:44:51.996]     ...future.frame <- base::sys.nframe()
[17:44:51.996]     ...future.conditions <- base::list()
[17:44:51.996]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:51.996]     if (FALSE) {
[17:44:51.996]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:51.996]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:51.996]     }
[17:44:51.996]     ...future.result <- base::tryCatch({
[17:44:51.996]         base::withCallingHandlers({
[17:44:51.996]             ...future.value <- base::withVisible(base::local({
[17:44:51.996]                 ...future.makeSendCondition <- base::local({
[17:44:51.996]                   sendCondition <- NULL
[17:44:51.996]                   function(frame = 1L) {
[17:44:51.996]                     if (is.function(sendCondition)) 
[17:44:51.996]                       return(sendCondition)
[17:44:51.996]                     ns <- getNamespace("parallel")
[17:44:51.996]                     if (exists("sendData", mode = "function", 
[17:44:51.996]                       envir = ns)) {
[17:44:51.996]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:51.996]                         envir = ns)
[17:44:51.996]                       envir <- sys.frame(frame)
[17:44:51.996]                       master <- NULL
[17:44:51.996]                       while (!identical(envir, .GlobalEnv) && 
[17:44:51.996]                         !identical(envir, emptyenv())) {
[17:44:51.996]                         if (exists("master", mode = "list", envir = envir, 
[17:44:51.996]                           inherits = FALSE)) {
[17:44:51.996]                           master <- get("master", mode = "list", 
[17:44:51.996]                             envir = envir, inherits = FALSE)
[17:44:51.996]                           if (inherits(master, c("SOCKnode", 
[17:44:51.996]                             "SOCK0node"))) {
[17:44:51.996]                             sendCondition <<- function(cond) {
[17:44:51.996]                               data <- list(type = "VALUE", value = cond, 
[17:44:51.996]                                 success = TRUE)
[17:44:51.996]                               parallel_sendData(master, data)
[17:44:51.996]                             }
[17:44:51.996]                             return(sendCondition)
[17:44:51.996]                           }
[17:44:51.996]                         }
[17:44:51.996]                         frame <- frame + 1L
[17:44:51.996]                         envir <- sys.frame(frame)
[17:44:51.996]                       }
[17:44:51.996]                     }
[17:44:51.996]                     sendCondition <<- function(cond) NULL
[17:44:51.996]                   }
[17:44:51.996]                 })
[17:44:51.996]                 withCallingHandlers({
[17:44:51.996]                   {
[17:44:51.996]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:51.996]                     if (!identical(...future.globals.maxSize.org, 
[17:44:51.996]                       ...future.globals.maxSize)) {
[17:44:51.996]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:51.996]                       on.exit(options(oopts), add = TRUE)
[17:44:51.996]                     }
[17:44:51.996]                     {
[17:44:51.996]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:51.996]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:51.996]                         USE.NAMES = FALSE)
[17:44:51.996]                       do.call(mapply, args = args)
[17:44:51.996]                     }
[17:44:51.996]                   }
[17:44:51.996]                 }, immediateCondition = function(cond) {
[17:44:51.996]                   sendCondition <- ...future.makeSendCondition()
[17:44:51.996]                   sendCondition(cond)
[17:44:51.996]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.996]                   {
[17:44:51.996]                     inherits <- base::inherits
[17:44:51.996]                     invokeRestart <- base::invokeRestart
[17:44:51.996]                     is.null <- base::is.null
[17:44:51.996]                     muffled <- FALSE
[17:44:51.996]                     if (inherits(cond, "message")) {
[17:44:51.996]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:51.996]                       if (muffled) 
[17:44:51.996]                         invokeRestart("muffleMessage")
[17:44:51.996]                     }
[17:44:51.996]                     else if (inherits(cond, "warning")) {
[17:44:51.996]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:51.996]                       if (muffled) 
[17:44:51.996]                         invokeRestart("muffleWarning")
[17:44:51.996]                     }
[17:44:51.996]                     else if (inherits(cond, "condition")) {
[17:44:51.996]                       if (!is.null(pattern)) {
[17:44:51.996]                         computeRestarts <- base::computeRestarts
[17:44:51.996]                         grepl <- base::grepl
[17:44:51.996]                         restarts <- computeRestarts(cond)
[17:44:51.996]                         for (restart in restarts) {
[17:44:51.996]                           name <- restart$name
[17:44:51.996]                           if (is.null(name)) 
[17:44:51.996]                             next
[17:44:51.996]                           if (!grepl(pattern, name)) 
[17:44:51.996]                             next
[17:44:51.996]                           invokeRestart(restart)
[17:44:51.996]                           muffled <- TRUE
[17:44:51.996]                           break
[17:44:51.996]                         }
[17:44:51.996]                       }
[17:44:51.996]                     }
[17:44:51.996]                     invisible(muffled)
[17:44:51.996]                   }
[17:44:51.996]                   muffleCondition(cond)
[17:44:51.996]                 })
[17:44:51.996]             }))
[17:44:51.996]             future::FutureResult(value = ...future.value$value, 
[17:44:51.996]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.996]                   ...future.rng), globalenv = if (FALSE) 
[17:44:51.996]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:51.996]                     ...future.globalenv.names))
[17:44:51.996]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:51.996]         }, condition = base::local({
[17:44:51.996]             c <- base::c
[17:44:51.996]             inherits <- base::inherits
[17:44:51.996]             invokeRestart <- base::invokeRestart
[17:44:51.996]             length <- base::length
[17:44:51.996]             list <- base::list
[17:44:51.996]             seq.int <- base::seq.int
[17:44:51.996]             signalCondition <- base::signalCondition
[17:44:51.996]             sys.calls <- base::sys.calls
[17:44:51.996]             `[[` <- base::`[[`
[17:44:51.996]             `+` <- base::`+`
[17:44:51.996]             `<<-` <- base::`<<-`
[17:44:51.996]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:51.996]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:51.996]                   3L)]
[17:44:51.996]             }
[17:44:51.996]             function(cond) {
[17:44:51.996]                 is_error <- inherits(cond, "error")
[17:44:51.996]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:51.996]                   NULL)
[17:44:51.996]                 if (is_error) {
[17:44:51.996]                   sessionInformation <- function() {
[17:44:51.996]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:51.996]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:51.996]                       search = base::search(), system = base::Sys.info())
[17:44:51.996]                   }
[17:44:51.996]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.996]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:51.996]                     cond$call), session = sessionInformation(), 
[17:44:51.996]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:51.996]                   signalCondition(cond)
[17:44:51.996]                 }
[17:44:51.996]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:51.996]                 "immediateCondition"))) {
[17:44:51.996]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:51.996]                   ...future.conditions[[length(...future.conditions) + 
[17:44:51.996]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:51.996]                   if (TRUE && !signal) {
[17:44:51.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.996]                     {
[17:44:51.996]                       inherits <- base::inherits
[17:44:51.996]                       invokeRestart <- base::invokeRestart
[17:44:51.996]                       is.null <- base::is.null
[17:44:51.996]                       muffled <- FALSE
[17:44:51.996]                       if (inherits(cond, "message")) {
[17:44:51.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.996]                         if (muffled) 
[17:44:51.996]                           invokeRestart("muffleMessage")
[17:44:51.996]                       }
[17:44:51.996]                       else if (inherits(cond, "warning")) {
[17:44:51.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.996]                         if (muffled) 
[17:44:51.996]                           invokeRestart("muffleWarning")
[17:44:51.996]                       }
[17:44:51.996]                       else if (inherits(cond, "condition")) {
[17:44:51.996]                         if (!is.null(pattern)) {
[17:44:51.996]                           computeRestarts <- base::computeRestarts
[17:44:51.996]                           grepl <- base::grepl
[17:44:51.996]                           restarts <- computeRestarts(cond)
[17:44:51.996]                           for (restart in restarts) {
[17:44:51.996]                             name <- restart$name
[17:44:51.996]                             if (is.null(name)) 
[17:44:51.996]                               next
[17:44:51.996]                             if (!grepl(pattern, name)) 
[17:44:51.996]                               next
[17:44:51.996]                             invokeRestart(restart)
[17:44:51.996]                             muffled <- TRUE
[17:44:51.996]                             break
[17:44:51.996]                           }
[17:44:51.996]                         }
[17:44:51.996]                       }
[17:44:51.996]                       invisible(muffled)
[17:44:51.996]                     }
[17:44:51.996]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.996]                   }
[17:44:51.996]                 }
[17:44:51.996]                 else {
[17:44:51.996]                   if (TRUE) {
[17:44:51.996]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:51.996]                     {
[17:44:51.996]                       inherits <- base::inherits
[17:44:51.996]                       invokeRestart <- base::invokeRestart
[17:44:51.996]                       is.null <- base::is.null
[17:44:51.996]                       muffled <- FALSE
[17:44:51.996]                       if (inherits(cond, "message")) {
[17:44:51.996]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:51.996]                         if (muffled) 
[17:44:51.996]                           invokeRestart("muffleMessage")
[17:44:51.996]                       }
[17:44:51.996]                       else if (inherits(cond, "warning")) {
[17:44:51.996]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:51.996]                         if (muffled) 
[17:44:51.996]                           invokeRestart("muffleWarning")
[17:44:51.996]                       }
[17:44:51.996]                       else if (inherits(cond, "condition")) {
[17:44:51.996]                         if (!is.null(pattern)) {
[17:44:51.996]                           computeRestarts <- base::computeRestarts
[17:44:51.996]                           grepl <- base::grepl
[17:44:51.996]                           restarts <- computeRestarts(cond)
[17:44:51.996]                           for (restart in restarts) {
[17:44:51.996]                             name <- restart$name
[17:44:51.996]                             if (is.null(name)) 
[17:44:51.996]                               next
[17:44:51.996]                             if (!grepl(pattern, name)) 
[17:44:51.996]                               next
[17:44:51.996]                             invokeRestart(restart)
[17:44:51.996]                             muffled <- TRUE
[17:44:51.996]                             break
[17:44:51.996]                           }
[17:44:51.996]                         }
[17:44:51.996]                       }
[17:44:51.996]                       invisible(muffled)
[17:44:51.996]                     }
[17:44:51.996]                     muffleCondition(cond, pattern = "^muffle")
[17:44:51.996]                   }
[17:44:51.996]                 }
[17:44:51.996]             }
[17:44:51.996]         }))
[17:44:51.996]     }, error = function(ex) {
[17:44:51.996]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:51.996]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:51.996]                 ...future.rng), started = ...future.startTime, 
[17:44:51.996]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:51.996]             version = "1.8"), class = "FutureResult")
[17:44:51.996]     }, finally = {
[17:44:51.996]         if (!identical(...future.workdir, getwd())) 
[17:44:51.996]             setwd(...future.workdir)
[17:44:51.996]         {
[17:44:51.996]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:51.996]                 ...future.oldOptions$nwarnings <- NULL
[17:44:51.996]             }
[17:44:51.996]             base::options(...future.oldOptions)
[17:44:51.996]             if (.Platform$OS.type == "windows") {
[17:44:51.996]                 old_names <- names(...future.oldEnvVars)
[17:44:51.996]                 envs <- base::Sys.getenv()
[17:44:51.996]                 names <- names(envs)
[17:44:51.996]                 common <- intersect(names, old_names)
[17:44:51.996]                 added <- setdiff(names, old_names)
[17:44:51.996]                 removed <- setdiff(old_names, names)
[17:44:51.996]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:51.996]                   envs[common]]
[17:44:51.996]                 NAMES <- toupper(changed)
[17:44:51.996]                 args <- list()
[17:44:51.996]                 for (kk in seq_along(NAMES)) {
[17:44:51.996]                   name <- changed[[kk]]
[17:44:51.996]                   NAME <- NAMES[[kk]]
[17:44:51.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.996]                     next
[17:44:51.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.996]                 }
[17:44:51.996]                 NAMES <- toupper(added)
[17:44:51.996]                 for (kk in seq_along(NAMES)) {
[17:44:51.996]                   name <- added[[kk]]
[17:44:51.996]                   NAME <- NAMES[[kk]]
[17:44:51.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.996]                     next
[17:44:51.996]                   args[[name]] <- ""
[17:44:51.996]                 }
[17:44:51.996]                 NAMES <- toupper(removed)
[17:44:51.996]                 for (kk in seq_along(NAMES)) {
[17:44:51.996]                   name <- removed[[kk]]
[17:44:51.996]                   NAME <- NAMES[[kk]]
[17:44:51.996]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:51.996]                     next
[17:44:51.996]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:51.996]                 }
[17:44:51.996]                 if (length(args) > 0) 
[17:44:51.996]                   base::do.call(base::Sys.setenv, args = args)
[17:44:51.996]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:51.996]             }
[17:44:51.996]             else {
[17:44:51.996]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:51.996]             }
[17:44:51.996]             {
[17:44:51.996]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:51.996]                   0L) {
[17:44:51.996]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:51.996]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:51.996]                   base::options(opts)
[17:44:51.996]                 }
[17:44:51.996]                 {
[17:44:51.996]                   {
[17:44:51.996]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:51.996]                     NULL
[17:44:51.996]                   }
[17:44:51.996]                   options(future.plan = NULL)
[17:44:51.996]                   if (is.na(NA_character_)) 
[17:44:51.996]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:51.996]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:51.996]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:51.996]                     .init = FALSE)
[17:44:51.996]                 }
[17:44:51.996]             }
[17:44:51.996]         }
[17:44:51.996]     })
[17:44:51.996]     if (TRUE) {
[17:44:51.996]         base::sink(type = "output", split = FALSE)
[17:44:51.996]         if (TRUE) {
[17:44:51.996]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:51.996]         }
[17:44:51.996]         else {
[17:44:51.996]             ...future.result["stdout"] <- base::list(NULL)
[17:44:51.996]         }
[17:44:51.996]         base::close(...future.stdout)
[17:44:51.996]         ...future.stdout <- NULL
[17:44:51.996]     }
[17:44:51.996]     ...future.result$conditions <- ...future.conditions
[17:44:51.996]     ...future.result$finished <- base::Sys.time()
[17:44:51.996]     ...future.result
[17:44:51.996] }
[17:44:51.998] Exporting 5 global objects (280 bytes) to cluster node #1 ...
[17:44:51.998] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:51.999] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:51.999] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:51.999] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.000] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:44:52.000] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:44:52.000] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:52.000] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.000] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:52.001] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.001] Exporting 5 global objects (280 bytes) to cluster node #1 ... DONE
[17:44:52.001] MultisessionFuture started
[17:44:52.002] - Launch lazy future ... done
[17:44:52.002] run() for ‘MultisessionFuture’ ... done
[17:44:52.002] Created future:
[17:44:52.002] MultisessionFuture:
[17:44:52.002] Label: ‘future_mapply-1’
[17:44:52.002] Expression:
[17:44:52.002] {
[17:44:52.002]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.002]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.002]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.002]         on.exit(options(oopts), add = TRUE)
[17:44:52.002]     }
[17:44:52.002]     {
[17:44:52.002]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.002]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.002]         do.call(mapply, args = args)
[17:44:52.002]     }
[17:44:52.002] }
[17:44:52.002] Lazy evaluation: FALSE
[17:44:52.002] Asynchronous evaluation: TRUE
[17:44:52.002] Local evaluation: TRUE
[17:44:52.002] Environment: R_GlobalEnv
[17:44:52.002] Capture standard output: TRUE
[17:44:52.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.002] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.002] Packages: <none>
[17:44:52.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.002] Resolved: FALSE
[17:44:52.002] Value: <not collected>
[17:44:52.002] Conditions captured: <none>
[17:44:52.002] Early signaling: FALSE
[17:44:52.002] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.002] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.013] Chunk #1 of 2 ... DONE
[17:44:52.014] Chunk #2 of 2 ...
[17:44:52.014]  - Finding globals in '...' for chunk #2 ...
[17:44:52.014] getGlobalsAndPackages() ...
[17:44:52.014] Searching for globals...
[17:44:52.014] 
[17:44:52.014] Searching for globals ... DONE
[17:44:52.014] - globals: [0] <none>
[17:44:52.014] getGlobalsAndPackages() ... DONE
[17:44:52.015]    + additional globals found: [n=0] 
[17:44:52.015]    + additional namespaces needed: [n=0] 
[17:44:52.015]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:52.015]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.015]  - seeds: <none>
[17:44:52.015]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.015] getGlobalsAndPackages() ...
[17:44:52.015] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.015] Resolving globals: FALSE
[17:44:52.016] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:52.016] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.016] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.017] 
[17:44:52.017] getGlobalsAndPackages() ... DONE
[17:44:52.017] run() for ‘Future’ ...
[17:44:52.017] - state: ‘created’
[17:44:52.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.031]   - Field: ‘node’
[17:44:52.031]   - Field: ‘label’
[17:44:52.031]   - Field: ‘local’
[17:44:52.031]   - Field: ‘owner’
[17:44:52.031]   - Field: ‘envir’
[17:44:52.031]   - Field: ‘workers’
[17:44:52.031]   - Field: ‘packages’
[17:44:52.032]   - Field: ‘gc’
[17:44:52.032]   - Field: ‘conditions’
[17:44:52.032]   - Field: ‘persistent’
[17:44:52.032]   - Field: ‘expr’
[17:44:52.032]   - Field: ‘uuid’
[17:44:52.032]   - Field: ‘seed’
[17:44:52.032]   - Field: ‘version’
[17:44:52.032]   - Field: ‘result’
[17:44:52.032]   - Field: ‘asynchronous’
[17:44:52.032]   - Field: ‘calls’
[17:44:52.032]   - Field: ‘globals’
[17:44:52.033]   - Field: ‘stdout’
[17:44:52.033]   - Field: ‘earlySignal’
[17:44:52.033]   - Field: ‘lazy’
[17:44:52.033]   - Field: ‘state’
[17:44:52.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.033] - Launch lazy future ...
[17:44:52.033] Packages needed by the future expression (n = 0): <none>
[17:44:52.033] Packages needed by future strategies (n = 0): <none>
[17:44:52.034] {
[17:44:52.034]     {
[17:44:52.034]         {
[17:44:52.034]             ...future.startTime <- base::Sys.time()
[17:44:52.034]             {
[17:44:52.034]                 {
[17:44:52.034]                   {
[17:44:52.034]                     {
[17:44:52.034]                       base::local({
[17:44:52.034]                         has_future <- base::requireNamespace("future", 
[17:44:52.034]                           quietly = TRUE)
[17:44:52.034]                         if (has_future) {
[17:44:52.034]                           ns <- base::getNamespace("future")
[17:44:52.034]                           version <- ns[[".package"]][["version"]]
[17:44:52.034]                           if (is.null(version)) 
[17:44:52.034]                             version <- utils::packageVersion("future")
[17:44:52.034]                         }
[17:44:52.034]                         else {
[17:44:52.034]                           version <- NULL
[17:44:52.034]                         }
[17:44:52.034]                         if (!has_future || version < "1.8.0") {
[17:44:52.034]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.034]                             "", base::R.version$version.string), 
[17:44:52.034]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:52.034]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:52.034]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.034]                               "release", "version")], collapse = " "), 
[17:44:52.034]                             hostname = base::Sys.info()[["nodename"]])
[17:44:52.034]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.034]                             info)
[17:44:52.034]                           info <- base::paste(info, collapse = "; ")
[17:44:52.034]                           if (!has_future) {
[17:44:52.034]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.034]                               info)
[17:44:52.034]                           }
[17:44:52.034]                           else {
[17:44:52.034]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.034]                               info, version)
[17:44:52.034]                           }
[17:44:52.034]                           base::stop(msg)
[17:44:52.034]                         }
[17:44:52.034]                       })
[17:44:52.034]                     }
[17:44:52.034]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.034]                     base::options(mc.cores = 1L)
[17:44:52.034]                   }
[17:44:52.034]                   ...future.strategy.old <- future::plan("list")
[17:44:52.034]                   options(future.plan = NULL)
[17:44:52.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.034]                 }
[17:44:52.034]                 ...future.workdir <- getwd()
[17:44:52.034]             }
[17:44:52.034]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.034]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.034]         }
[17:44:52.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.034]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.034]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.034]             base::names(...future.oldOptions))
[17:44:52.034]     }
[17:44:52.034]     if (FALSE) {
[17:44:52.034]     }
[17:44:52.034]     else {
[17:44:52.034]         if (TRUE) {
[17:44:52.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.034]                 open = "w")
[17:44:52.034]         }
[17:44:52.034]         else {
[17:44:52.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.034]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.034]         }
[17:44:52.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.034]             base::sink(type = "output", split = FALSE)
[17:44:52.034]             base::close(...future.stdout)
[17:44:52.034]         }, add = TRUE)
[17:44:52.034]     }
[17:44:52.034]     ...future.frame <- base::sys.nframe()
[17:44:52.034]     ...future.conditions <- base::list()
[17:44:52.034]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.034]     if (FALSE) {
[17:44:52.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.034]     }
[17:44:52.034]     ...future.result <- base::tryCatch({
[17:44:52.034]         base::withCallingHandlers({
[17:44:52.034]             ...future.value <- base::withVisible(base::local({
[17:44:52.034]                 ...future.makeSendCondition <- base::local({
[17:44:52.034]                   sendCondition <- NULL
[17:44:52.034]                   function(frame = 1L) {
[17:44:52.034]                     if (is.function(sendCondition)) 
[17:44:52.034]                       return(sendCondition)
[17:44:52.034]                     ns <- getNamespace("parallel")
[17:44:52.034]                     if (exists("sendData", mode = "function", 
[17:44:52.034]                       envir = ns)) {
[17:44:52.034]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.034]                         envir = ns)
[17:44:52.034]                       envir <- sys.frame(frame)
[17:44:52.034]                       master <- NULL
[17:44:52.034]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.034]                         !identical(envir, emptyenv())) {
[17:44:52.034]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.034]                           inherits = FALSE)) {
[17:44:52.034]                           master <- get("master", mode = "list", 
[17:44:52.034]                             envir = envir, inherits = FALSE)
[17:44:52.034]                           if (inherits(master, c("SOCKnode", 
[17:44:52.034]                             "SOCK0node"))) {
[17:44:52.034]                             sendCondition <<- function(cond) {
[17:44:52.034]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.034]                                 success = TRUE)
[17:44:52.034]                               parallel_sendData(master, data)
[17:44:52.034]                             }
[17:44:52.034]                             return(sendCondition)
[17:44:52.034]                           }
[17:44:52.034]                         }
[17:44:52.034]                         frame <- frame + 1L
[17:44:52.034]                         envir <- sys.frame(frame)
[17:44:52.034]                       }
[17:44:52.034]                     }
[17:44:52.034]                     sendCondition <<- function(cond) NULL
[17:44:52.034]                   }
[17:44:52.034]                 })
[17:44:52.034]                 withCallingHandlers({
[17:44:52.034]                   {
[17:44:52.034]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.034]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.034]                       ...future.globals.maxSize)) {
[17:44:52.034]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.034]                       on.exit(options(oopts), add = TRUE)
[17:44:52.034]                     }
[17:44:52.034]                     {
[17:44:52.034]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.034]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.034]                         USE.NAMES = FALSE)
[17:44:52.034]                       do.call(mapply, args = args)
[17:44:52.034]                     }
[17:44:52.034]                   }
[17:44:52.034]                 }, immediateCondition = function(cond) {
[17:44:52.034]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.034]                   sendCondition(cond)
[17:44:52.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.034]                   {
[17:44:52.034]                     inherits <- base::inherits
[17:44:52.034]                     invokeRestart <- base::invokeRestart
[17:44:52.034]                     is.null <- base::is.null
[17:44:52.034]                     muffled <- FALSE
[17:44:52.034]                     if (inherits(cond, "message")) {
[17:44:52.034]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.034]                       if (muffled) 
[17:44:52.034]                         invokeRestart("muffleMessage")
[17:44:52.034]                     }
[17:44:52.034]                     else if (inherits(cond, "warning")) {
[17:44:52.034]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.034]                       if (muffled) 
[17:44:52.034]                         invokeRestart("muffleWarning")
[17:44:52.034]                     }
[17:44:52.034]                     else if (inherits(cond, "condition")) {
[17:44:52.034]                       if (!is.null(pattern)) {
[17:44:52.034]                         computeRestarts <- base::computeRestarts
[17:44:52.034]                         grepl <- base::grepl
[17:44:52.034]                         restarts <- computeRestarts(cond)
[17:44:52.034]                         for (restart in restarts) {
[17:44:52.034]                           name <- restart$name
[17:44:52.034]                           if (is.null(name)) 
[17:44:52.034]                             next
[17:44:52.034]                           if (!grepl(pattern, name)) 
[17:44:52.034]                             next
[17:44:52.034]                           invokeRestart(restart)
[17:44:52.034]                           muffled <- TRUE
[17:44:52.034]                           break
[17:44:52.034]                         }
[17:44:52.034]                       }
[17:44:52.034]                     }
[17:44:52.034]                     invisible(muffled)
[17:44:52.034]                   }
[17:44:52.034]                   muffleCondition(cond)
[17:44:52.034]                 })
[17:44:52.034]             }))
[17:44:52.034]             future::FutureResult(value = ...future.value$value, 
[17:44:52.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.034]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.034]                     ...future.globalenv.names))
[17:44:52.034]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.034]         }, condition = base::local({
[17:44:52.034]             c <- base::c
[17:44:52.034]             inherits <- base::inherits
[17:44:52.034]             invokeRestart <- base::invokeRestart
[17:44:52.034]             length <- base::length
[17:44:52.034]             list <- base::list
[17:44:52.034]             seq.int <- base::seq.int
[17:44:52.034]             signalCondition <- base::signalCondition
[17:44:52.034]             sys.calls <- base::sys.calls
[17:44:52.034]             `[[` <- base::`[[`
[17:44:52.034]             `+` <- base::`+`
[17:44:52.034]             `<<-` <- base::`<<-`
[17:44:52.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.034]                   3L)]
[17:44:52.034]             }
[17:44:52.034]             function(cond) {
[17:44:52.034]                 is_error <- inherits(cond, "error")
[17:44:52.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.034]                   NULL)
[17:44:52.034]                 if (is_error) {
[17:44:52.034]                   sessionInformation <- function() {
[17:44:52.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.034]                       search = base::search(), system = base::Sys.info())
[17:44:52.034]                   }
[17:44:52.034]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.034]                     cond$call), session = sessionInformation(), 
[17:44:52.034]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.034]                   signalCondition(cond)
[17:44:52.034]                 }
[17:44:52.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.034]                 "immediateCondition"))) {
[17:44:52.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.034]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.034]                   if (TRUE && !signal) {
[17:44:52.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.034]                     {
[17:44:52.034]                       inherits <- base::inherits
[17:44:52.034]                       invokeRestart <- base::invokeRestart
[17:44:52.034]                       is.null <- base::is.null
[17:44:52.034]                       muffled <- FALSE
[17:44:52.034]                       if (inherits(cond, "message")) {
[17:44:52.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.034]                         if (muffled) 
[17:44:52.034]                           invokeRestart("muffleMessage")
[17:44:52.034]                       }
[17:44:52.034]                       else if (inherits(cond, "warning")) {
[17:44:52.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.034]                         if (muffled) 
[17:44:52.034]                           invokeRestart("muffleWarning")
[17:44:52.034]                       }
[17:44:52.034]                       else if (inherits(cond, "condition")) {
[17:44:52.034]                         if (!is.null(pattern)) {
[17:44:52.034]                           computeRestarts <- base::computeRestarts
[17:44:52.034]                           grepl <- base::grepl
[17:44:52.034]                           restarts <- computeRestarts(cond)
[17:44:52.034]                           for (restart in restarts) {
[17:44:52.034]                             name <- restart$name
[17:44:52.034]                             if (is.null(name)) 
[17:44:52.034]                               next
[17:44:52.034]                             if (!grepl(pattern, name)) 
[17:44:52.034]                               next
[17:44:52.034]                             invokeRestart(restart)
[17:44:52.034]                             muffled <- TRUE
[17:44:52.034]                             break
[17:44:52.034]                           }
[17:44:52.034]                         }
[17:44:52.034]                       }
[17:44:52.034]                       invisible(muffled)
[17:44:52.034]                     }
[17:44:52.034]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.034]                   }
[17:44:52.034]                 }
[17:44:52.034]                 else {
[17:44:52.034]                   if (TRUE) {
[17:44:52.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.034]                     {
[17:44:52.034]                       inherits <- base::inherits
[17:44:52.034]                       invokeRestart <- base::invokeRestart
[17:44:52.034]                       is.null <- base::is.null
[17:44:52.034]                       muffled <- FALSE
[17:44:52.034]                       if (inherits(cond, "message")) {
[17:44:52.034]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.034]                         if (muffled) 
[17:44:52.034]                           invokeRestart("muffleMessage")
[17:44:52.034]                       }
[17:44:52.034]                       else if (inherits(cond, "warning")) {
[17:44:52.034]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.034]                         if (muffled) 
[17:44:52.034]                           invokeRestart("muffleWarning")
[17:44:52.034]                       }
[17:44:52.034]                       else if (inherits(cond, "condition")) {
[17:44:52.034]                         if (!is.null(pattern)) {
[17:44:52.034]                           computeRestarts <- base::computeRestarts
[17:44:52.034]                           grepl <- base::grepl
[17:44:52.034]                           restarts <- computeRestarts(cond)
[17:44:52.034]                           for (restart in restarts) {
[17:44:52.034]                             name <- restart$name
[17:44:52.034]                             if (is.null(name)) 
[17:44:52.034]                               next
[17:44:52.034]                             if (!grepl(pattern, name)) 
[17:44:52.034]                               next
[17:44:52.034]                             invokeRestart(restart)
[17:44:52.034]                             muffled <- TRUE
[17:44:52.034]                             break
[17:44:52.034]                           }
[17:44:52.034]                         }
[17:44:52.034]                       }
[17:44:52.034]                       invisible(muffled)
[17:44:52.034]                     }
[17:44:52.034]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.034]                   }
[17:44:52.034]                 }
[17:44:52.034]             }
[17:44:52.034]         }))
[17:44:52.034]     }, error = function(ex) {
[17:44:52.034]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.034]                 ...future.rng), started = ...future.startTime, 
[17:44:52.034]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.034]             version = "1.8"), class = "FutureResult")
[17:44:52.034]     }, finally = {
[17:44:52.034]         if (!identical(...future.workdir, getwd())) 
[17:44:52.034]             setwd(...future.workdir)
[17:44:52.034]         {
[17:44:52.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.034]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.034]             }
[17:44:52.034]             base::options(...future.oldOptions)
[17:44:52.034]             if (.Platform$OS.type == "windows") {
[17:44:52.034]                 old_names <- names(...future.oldEnvVars)
[17:44:52.034]                 envs <- base::Sys.getenv()
[17:44:52.034]                 names <- names(envs)
[17:44:52.034]                 common <- intersect(names, old_names)
[17:44:52.034]                 added <- setdiff(names, old_names)
[17:44:52.034]                 removed <- setdiff(old_names, names)
[17:44:52.034]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.034]                   envs[common]]
[17:44:52.034]                 NAMES <- toupper(changed)
[17:44:52.034]                 args <- list()
[17:44:52.034]                 for (kk in seq_along(NAMES)) {
[17:44:52.034]                   name <- changed[[kk]]
[17:44:52.034]                   NAME <- NAMES[[kk]]
[17:44:52.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.034]                     next
[17:44:52.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.034]                 }
[17:44:52.034]                 NAMES <- toupper(added)
[17:44:52.034]                 for (kk in seq_along(NAMES)) {
[17:44:52.034]                   name <- added[[kk]]
[17:44:52.034]                   NAME <- NAMES[[kk]]
[17:44:52.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.034]                     next
[17:44:52.034]                   args[[name]] <- ""
[17:44:52.034]                 }
[17:44:52.034]                 NAMES <- toupper(removed)
[17:44:52.034]                 for (kk in seq_along(NAMES)) {
[17:44:52.034]                   name <- removed[[kk]]
[17:44:52.034]                   NAME <- NAMES[[kk]]
[17:44:52.034]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.034]                     next
[17:44:52.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.034]                 }
[17:44:52.034]                 if (length(args) > 0) 
[17:44:52.034]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.034]             }
[17:44:52.034]             else {
[17:44:52.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.034]             }
[17:44:52.034]             {
[17:44:52.034]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.034]                   0L) {
[17:44:52.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.034]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.034]                   base::options(opts)
[17:44:52.034]                 }
[17:44:52.034]                 {
[17:44:52.034]                   {
[17:44:52.034]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.034]                     NULL
[17:44:52.034]                   }
[17:44:52.034]                   options(future.plan = NULL)
[17:44:52.034]                   if (is.na(NA_character_)) 
[17:44:52.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.034]                     .init = FALSE)
[17:44:52.034]                 }
[17:44:52.034]             }
[17:44:52.034]         }
[17:44:52.034]     })
[17:44:52.034]     if (TRUE) {
[17:44:52.034]         base::sink(type = "output", split = FALSE)
[17:44:52.034]         if (TRUE) {
[17:44:52.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.034]         }
[17:44:52.034]         else {
[17:44:52.034]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.034]         }
[17:44:52.034]         base::close(...future.stdout)
[17:44:52.034]         ...future.stdout <- NULL
[17:44:52.034]     }
[17:44:52.034]     ...future.result$conditions <- ...future.conditions
[17:44:52.034]     ...future.result$finished <- base::Sys.time()
[17:44:52.034]     ...future.result
[17:44:52.034] }
[17:44:52.036] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:44:52.037] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:52.037] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:52.037] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:52.037] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.038] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:52.038] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:52.038] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:52.038] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.039] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:52.039] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.039] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:44:52.040] MultisessionFuture started
[17:44:52.040] - Launch lazy future ... done
[17:44:52.040] run() for ‘MultisessionFuture’ ... done
[17:44:52.040] Created future:
[17:44:52.040] MultisessionFuture:
[17:44:52.040] Label: ‘future_mapply-2’
[17:44:52.040] Expression:
[17:44:52.040] {
[17:44:52.040]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.040]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.040]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.040]         on.exit(options(oopts), add = TRUE)
[17:44:52.040]     }
[17:44:52.040]     {
[17:44:52.040]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.040]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.040]         do.call(mapply, args = args)
[17:44:52.040]     }
[17:44:52.040] }
[17:44:52.040] Lazy evaluation: FALSE
[17:44:52.040] Asynchronous evaluation: TRUE
[17:44:52.040] Local evaluation: TRUE
[17:44:52.040] Environment: R_GlobalEnv
[17:44:52.040] Capture standard output: TRUE
[17:44:52.040] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.040] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.040] Packages: <none>
[17:44:52.040] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.040] Resolved: FALSE
[17:44:52.040] Value: <not collected>
[17:44:52.040] Conditions captured: <none>
[17:44:52.040] Early signaling: FALSE
[17:44:52.040] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.040] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.052] Chunk #2 of 2 ... DONE
[17:44:52.052] Launching 2 futures (chunks) ... DONE
[17:44:52.052] Resolving 2 futures (chunks) ...
[17:44:52.052] resolve() on list ...
[17:44:52.052]  recursive: 0
[17:44:52.052]  length: 2
[17:44:52.052] 
[17:44:52.053] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.053] - Validating connection of MultisessionFuture
[17:44:52.053] - received message: FutureResult
[17:44:52.053] - Received FutureResult
[17:44:52.053] - Erased future from FutureRegistry
[17:44:52.053] result() for ClusterFuture ...
[17:44:52.053] - result already collected: FutureResult
[17:44:52.053] result() for ClusterFuture ... done
[17:44:52.054] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.054] Future #1
[17:44:52.054] result() for ClusterFuture ...
[17:44:52.054] - result already collected: FutureResult
[17:44:52.054] result() for ClusterFuture ... done
[17:44:52.054] result() for ClusterFuture ...
[17:44:52.054] - result already collected: FutureResult
[17:44:52.054] result() for ClusterFuture ... done
[17:44:52.054] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:52.054] - nx: 2
[17:44:52.054] - relay: TRUE
[17:44:52.054] - stdout: TRUE
[17:44:52.055] - signal: TRUE
[17:44:52.055] - resignal: FALSE
[17:44:52.055] - force: TRUE
[17:44:52.055] - relayed: [n=2] FALSE, FALSE
[17:44:52.055] - queued futures: [n=2] FALSE, FALSE
[17:44:52.055]  - until=1
[17:44:52.055]  - relaying element #1
[17:44:52.055] result() for ClusterFuture ...
[17:44:52.055] - result already collected: FutureResult
[17:44:52.055] result() for ClusterFuture ... done
[17:44:52.055] result() for ClusterFuture ...
[17:44:52.056] - result already collected: FutureResult
[17:44:52.056] result() for ClusterFuture ... done
[17:44:52.056] result() for ClusterFuture ...
[17:44:52.056] - result already collected: FutureResult
[17:44:52.056] result() for ClusterFuture ... done
[17:44:52.056] result() for ClusterFuture ...
[17:44:52.056] - result already collected: FutureResult
[17:44:52.056] result() for ClusterFuture ... done
[17:44:52.056] - relayed: [n=2] TRUE, FALSE
[17:44:52.056] - queued futures: [n=2] TRUE, FALSE
[17:44:52.056] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:52.057]  length: 1 (resolved future 1)
[17:44:52.085] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.085] - Validating connection of MultisessionFuture
[17:44:52.085] - received message: FutureResult
[17:44:52.086] - Received FutureResult
[17:44:52.086] - Erased future from FutureRegistry
[17:44:52.086] result() for ClusterFuture ...
[17:44:52.086] - result already collected: FutureResult
[17:44:52.086] result() for ClusterFuture ... done
[17:44:52.086] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.086] Future #2
[17:44:52.086] result() for ClusterFuture ...
[17:44:52.086] - result already collected: FutureResult
[17:44:52.086] result() for ClusterFuture ... done
[17:44:52.087] result() for ClusterFuture ...
[17:44:52.087] - result already collected: FutureResult
[17:44:52.087] result() for ClusterFuture ... done
[17:44:52.087] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:52.087] - nx: 2
[17:44:52.087] - relay: TRUE
[17:44:52.087] - stdout: TRUE
[17:44:52.087] - signal: TRUE
[17:44:52.087] - resignal: FALSE
[17:44:52.087] - force: TRUE
[17:44:52.087] - relayed: [n=2] TRUE, FALSE
[17:44:52.088] - queued futures: [n=2] TRUE, FALSE
[17:44:52.088]  - until=2
[17:44:52.088]  - relaying element #2
[17:44:52.088] result() for ClusterFuture ...
[17:44:52.088] - result already collected: FutureResult
[17:44:52.088] result() for ClusterFuture ... done
[17:44:52.088] result() for ClusterFuture ...
[17:44:52.088] - result already collected: FutureResult
[17:44:52.088] result() for ClusterFuture ... done
[17:44:52.088] result() for ClusterFuture ...
[17:44:52.088] - result already collected: FutureResult
[17:44:52.089] result() for ClusterFuture ... done
[17:44:52.089] result() for ClusterFuture ...
[17:44:52.089] - result already collected: FutureResult
[17:44:52.089] result() for ClusterFuture ... done
[17:44:52.089] - relayed: [n=2] TRUE, TRUE
[17:44:52.089] - queued futures: [n=2] TRUE, TRUE
[17:44:52.089] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:52.089]  length: 0 (resolved future 2)
[17:44:52.089] Relaying remaining futures
[17:44:52.089] signalConditionsASAP(NULL, pos=0) ...
[17:44:52.089] - nx: 2
[17:44:52.090] - relay: TRUE
[17:44:52.090] - stdout: TRUE
[17:44:52.090] - signal: TRUE
[17:44:52.090] - resignal: FALSE
[17:44:52.090] - force: TRUE
[17:44:52.090] - relayed: [n=2] TRUE, TRUE
[17:44:52.090] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:52.090] - relayed: [n=2] TRUE, TRUE
[17:44:52.090] - queued futures: [n=2] TRUE, TRUE
[17:44:52.090] signalConditionsASAP(NULL, pos=0) ... done
[17:44:52.090] resolve() on list ... DONE
[17:44:52.090] result() for ClusterFuture ...
[17:44:52.091] - result already collected: FutureResult
[17:44:52.091] result() for ClusterFuture ... done
[17:44:52.091] result() for ClusterFuture ...
[17:44:52.091] - result already collected: FutureResult
[17:44:52.091] result() for ClusterFuture ... done
[17:44:52.091] result() for ClusterFuture ...
[17:44:52.091] - result already collected: FutureResult
[17:44:52.091] result() for ClusterFuture ... done
[17:44:52.091] result() for ClusterFuture ...
[17:44:52.091] - result already collected: FutureResult
[17:44:52.091] result() for ClusterFuture ... done
[17:44:52.092]  - Number of value chunks collected: 2
[17:44:52.092] Resolving 2 futures (chunks) ... DONE
[17:44:52.092] Reducing values from 2 chunks ...
[17:44:52.092]  - Number of values collected after concatenation: 4
[17:44:52.092]  - Number of values expected: 4
[17:44:52.092] Reducing values from 2 chunks ... DONE
[17:44:52.092] future_mapply() ... DONE
- Parallel RNG ...
[17:44:52.092] future_mapply() ...
[17:44:52.092] Generating random seeds ...
[17:44:52.092] Generating random seed streams for 4 elements ...
[17:44:52.093] Generating random seed streams for 4 elements ... DONE
[17:44:52.093] Generating random seeds ... DONE
[17:44:52.093] Will set RNG state on exit: 10407, -360559175, 1243103987, -1843365172, -730059028, -682018309, -753174345
[17:44:52.097] Number of chunks: 2
[17:44:52.097] getGlobalsAndPackagesXApply() ...
[17:44:52.097]  - future.globals: TRUE
[17:44:52.097] getGlobalsAndPackages() ...
[17:44:52.097] Searching for globals...
[17:44:52.098] - globals found: [3] ‘FUN’, ‘.Call’, ‘C_runif’
[17:44:52.098] Searching for globals ... DONE
[17:44:52.099] Resolving globals: FALSE
[17:44:52.099] The total size of the 1 globals is 2.04 KiB (2088 bytes)
[17:44:52.099] The total size of the 1 globals exported for future expression (‘FUN(min = 1)’) is 2.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (2.04 KiB of class ‘function’)
[17:44:52.100] - globals: [1] ‘FUN’
[17:44:52.100] - packages: [1] ‘stats’
[17:44:52.100] getGlobalsAndPackages() ... DONE
[17:44:52.100]  - globals found/used: [n=1] ‘FUN’
[17:44:52.100]  - needed namespaces: [n=1] ‘stats’
[17:44:52.100] Finding globals ... DONE
[17:44:52.100] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:52.100] List of 2
[17:44:52.100]  $ ...future.FUN:function (n, min = 0, max = 1)  
[17:44:52.100]  $ MoreArgs     :List of 1
[17:44:52.100]   ..$ min: num 1
[17:44:52.100]  - attr(*, "where")=List of 2
[17:44:52.100]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:52.100]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:52.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:52.100]  - attr(*, "resolved")= logi FALSE
[17:44:52.100]  - attr(*, "total_size")= num NA
[17:44:52.103] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:52.103] getGlobalsAndPackagesXApply() ... DONE
[17:44:52.103] Number of futures (= number of chunks): 2
[17:44:52.103] Launching 2 futures (chunks) ...
[17:44:52.104] Chunk #1 of 2 ...
[17:44:52.104]  - Finding globals in '...' for chunk #1 ...
[17:44:52.104] getGlobalsAndPackages() ...
[17:44:52.104] Searching for globals...
[17:44:52.104] 
[17:44:52.104] Searching for globals ... DONE
[17:44:52.104] - globals: [0] <none>
[17:44:52.104] getGlobalsAndPackages() ... DONE
[17:44:52.105]    + additional globals found: [n=0] 
[17:44:52.105]    + additional namespaces needed: [n=0] 
[17:44:52.105]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:52.105]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.105]  - seeds: [2] <seeds>
[17:44:52.105]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.105] getGlobalsAndPackages() ...
[17:44:52.105] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.105] Resolving globals: FALSE
[17:44:52.106] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:44:52.106] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:44:52.106] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.106] - packages: [1] ‘stats’
[17:44:52.107] getGlobalsAndPackages() ... DONE
[17:44:52.107] run() for ‘Future’ ...
[17:44:52.107] - state: ‘created’
[17:44:52.107] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.121] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.121]   - Field: ‘node’
[17:44:52.122]   - Field: ‘label’
[17:44:52.122]   - Field: ‘local’
[17:44:52.122]   - Field: ‘owner’
[17:44:52.122]   - Field: ‘envir’
[17:44:52.122]   - Field: ‘workers’
[17:44:52.122]   - Field: ‘packages’
[17:44:52.122]   - Field: ‘gc’
[17:44:52.122]   - Field: ‘conditions’
[17:44:52.122]   - Field: ‘persistent’
[17:44:52.122]   - Field: ‘expr’
[17:44:52.122]   - Field: ‘uuid’
[17:44:52.123]   - Field: ‘seed’
[17:44:52.123]   - Field: ‘version’
[17:44:52.123]   - Field: ‘result’
[17:44:52.123]   - Field: ‘asynchronous’
[17:44:52.123]   - Field: ‘calls’
[17:44:52.123]   - Field: ‘globals’
[17:44:52.123]   - Field: ‘stdout’
[17:44:52.123]   - Field: ‘earlySignal’
[17:44:52.123]   - Field: ‘lazy’
[17:44:52.123]   - Field: ‘state’
[17:44:52.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.124] - Launch lazy future ...
[17:44:52.124] Packages needed by the future expression (n = 1): ‘stats’
[17:44:52.124] Packages needed by future strategies (n = 0): <none>
[17:44:52.124] {
[17:44:52.124]     {
[17:44:52.124]         {
[17:44:52.124]             ...future.startTime <- base::Sys.time()
[17:44:52.124]             {
[17:44:52.124]                 {
[17:44:52.124]                   {
[17:44:52.124]                     {
[17:44:52.124]                       {
[17:44:52.124]                         base::local({
[17:44:52.124]                           has_future <- base::requireNamespace("future", 
[17:44:52.124]                             quietly = TRUE)
[17:44:52.124]                           if (has_future) {
[17:44:52.124]                             ns <- base::getNamespace("future")
[17:44:52.124]                             version <- ns[[".package"]][["version"]]
[17:44:52.124]                             if (is.null(version)) 
[17:44:52.124]                               version <- utils::packageVersion("future")
[17:44:52.124]                           }
[17:44:52.124]                           else {
[17:44:52.124]                             version <- NULL
[17:44:52.124]                           }
[17:44:52.124]                           if (!has_future || version < "1.8.0") {
[17:44:52.124]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.124]                               "", base::R.version$version.string), 
[17:44:52.124]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:52.124]                                 base::R.version$platform, 8 * 
[17:44:52.124]                                   base::.Machine$sizeof.pointer), 
[17:44:52.124]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.124]                                 "release", "version")], collapse = " "), 
[17:44:52.124]                               hostname = base::Sys.info()[["nodename"]])
[17:44:52.124]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.124]                               info)
[17:44:52.124]                             info <- base::paste(info, collapse = "; ")
[17:44:52.124]                             if (!has_future) {
[17:44:52.124]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.124]                                 info)
[17:44:52.124]                             }
[17:44:52.124]                             else {
[17:44:52.124]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.124]                                 info, version)
[17:44:52.124]                             }
[17:44:52.124]                             base::stop(msg)
[17:44:52.124]                           }
[17:44:52.124]                         })
[17:44:52.124]                       }
[17:44:52.124]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.124]                       base::options(mc.cores = 1L)
[17:44:52.124]                     }
[17:44:52.124]                     base::local({
[17:44:52.124]                       for (pkg in "stats") {
[17:44:52.124]                         base::loadNamespace(pkg)
[17:44:52.124]                         base::library(pkg, character.only = TRUE)
[17:44:52.124]                       }
[17:44:52.124]                     })
[17:44:52.124]                   }
[17:44:52.124]                   ...future.strategy.old <- future::plan("list")
[17:44:52.124]                   options(future.plan = NULL)
[17:44:52.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.124]                 }
[17:44:52.124]                 ...future.workdir <- getwd()
[17:44:52.124]             }
[17:44:52.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.124]         }
[17:44:52.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.124]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.124]             base::names(...future.oldOptions))
[17:44:52.124]     }
[17:44:52.124]     if (FALSE) {
[17:44:52.124]     }
[17:44:52.124]     else {
[17:44:52.124]         if (TRUE) {
[17:44:52.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.124]                 open = "w")
[17:44:52.124]         }
[17:44:52.124]         else {
[17:44:52.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.124]         }
[17:44:52.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.124]             base::sink(type = "output", split = FALSE)
[17:44:52.124]             base::close(...future.stdout)
[17:44:52.124]         }, add = TRUE)
[17:44:52.124]     }
[17:44:52.124]     ...future.frame <- base::sys.nframe()
[17:44:52.124]     ...future.conditions <- base::list()
[17:44:52.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.124]     if (FALSE) {
[17:44:52.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.124]     }
[17:44:52.124]     ...future.result <- base::tryCatch({
[17:44:52.124]         base::withCallingHandlers({
[17:44:52.124]             ...future.value <- base::withVisible(base::local({
[17:44:52.124]                 ...future.makeSendCondition <- base::local({
[17:44:52.124]                   sendCondition <- NULL
[17:44:52.124]                   function(frame = 1L) {
[17:44:52.124]                     if (is.function(sendCondition)) 
[17:44:52.124]                       return(sendCondition)
[17:44:52.124]                     ns <- getNamespace("parallel")
[17:44:52.124]                     if (exists("sendData", mode = "function", 
[17:44:52.124]                       envir = ns)) {
[17:44:52.124]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.124]                         envir = ns)
[17:44:52.124]                       envir <- sys.frame(frame)
[17:44:52.124]                       master <- NULL
[17:44:52.124]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.124]                         !identical(envir, emptyenv())) {
[17:44:52.124]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.124]                           inherits = FALSE)) {
[17:44:52.124]                           master <- get("master", mode = "list", 
[17:44:52.124]                             envir = envir, inherits = FALSE)
[17:44:52.124]                           if (inherits(master, c("SOCKnode", 
[17:44:52.124]                             "SOCK0node"))) {
[17:44:52.124]                             sendCondition <<- function(cond) {
[17:44:52.124]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.124]                                 success = TRUE)
[17:44:52.124]                               parallel_sendData(master, data)
[17:44:52.124]                             }
[17:44:52.124]                             return(sendCondition)
[17:44:52.124]                           }
[17:44:52.124]                         }
[17:44:52.124]                         frame <- frame + 1L
[17:44:52.124]                         envir <- sys.frame(frame)
[17:44:52.124]                       }
[17:44:52.124]                     }
[17:44:52.124]                     sendCondition <<- function(cond) NULL
[17:44:52.124]                   }
[17:44:52.124]                 })
[17:44:52.124]                 withCallingHandlers({
[17:44:52.124]                   {
[17:44:52.124]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.124]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.124]                       ...future.globals.maxSize)) {
[17:44:52.124]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.124]                       on.exit(options(oopts), add = TRUE)
[17:44:52.124]                     }
[17:44:52.124]                     {
[17:44:52.124]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:52.124]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:52.124]                           envir = globalenv(), inherits = FALSE)
[17:44:52.124]                         ...future.FUN(...)
[17:44:52.124]                       }
[17:44:52.124]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:52.124]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:52.124]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.124]                         USE.NAMES = FALSE)
[17:44:52.124]                       do.call(mapply, args = args)
[17:44:52.124]                     }
[17:44:52.124]                   }
[17:44:52.124]                 }, immediateCondition = function(cond) {
[17:44:52.124]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.124]                   sendCondition(cond)
[17:44:52.124]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.124]                   {
[17:44:52.124]                     inherits <- base::inherits
[17:44:52.124]                     invokeRestart <- base::invokeRestart
[17:44:52.124]                     is.null <- base::is.null
[17:44:52.124]                     muffled <- FALSE
[17:44:52.124]                     if (inherits(cond, "message")) {
[17:44:52.124]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.124]                       if (muffled) 
[17:44:52.124]                         invokeRestart("muffleMessage")
[17:44:52.124]                     }
[17:44:52.124]                     else if (inherits(cond, "warning")) {
[17:44:52.124]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.124]                       if (muffled) 
[17:44:52.124]                         invokeRestart("muffleWarning")
[17:44:52.124]                     }
[17:44:52.124]                     else if (inherits(cond, "condition")) {
[17:44:52.124]                       if (!is.null(pattern)) {
[17:44:52.124]                         computeRestarts <- base::computeRestarts
[17:44:52.124]                         grepl <- base::grepl
[17:44:52.124]                         restarts <- computeRestarts(cond)
[17:44:52.124]                         for (restart in restarts) {
[17:44:52.124]                           name <- restart$name
[17:44:52.124]                           if (is.null(name)) 
[17:44:52.124]                             next
[17:44:52.124]                           if (!grepl(pattern, name)) 
[17:44:52.124]                             next
[17:44:52.124]                           invokeRestart(restart)
[17:44:52.124]                           muffled <- TRUE
[17:44:52.124]                           break
[17:44:52.124]                         }
[17:44:52.124]                       }
[17:44:52.124]                     }
[17:44:52.124]                     invisible(muffled)
[17:44:52.124]                   }
[17:44:52.124]                   muffleCondition(cond)
[17:44:52.124]                 })
[17:44:52.124]             }))
[17:44:52.124]             future::FutureResult(value = ...future.value$value, 
[17:44:52.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.124]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.124]                     ...future.globalenv.names))
[17:44:52.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.124]         }, condition = base::local({
[17:44:52.124]             c <- base::c
[17:44:52.124]             inherits <- base::inherits
[17:44:52.124]             invokeRestart <- base::invokeRestart
[17:44:52.124]             length <- base::length
[17:44:52.124]             list <- base::list
[17:44:52.124]             seq.int <- base::seq.int
[17:44:52.124]             signalCondition <- base::signalCondition
[17:44:52.124]             sys.calls <- base::sys.calls
[17:44:52.124]             `[[` <- base::`[[`
[17:44:52.124]             `+` <- base::`+`
[17:44:52.124]             `<<-` <- base::`<<-`
[17:44:52.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.124]                   3L)]
[17:44:52.124]             }
[17:44:52.124]             function(cond) {
[17:44:52.124]                 is_error <- inherits(cond, "error")
[17:44:52.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.124]                   NULL)
[17:44:52.124]                 if (is_error) {
[17:44:52.124]                   sessionInformation <- function() {
[17:44:52.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.124]                       search = base::search(), system = base::Sys.info())
[17:44:52.124]                   }
[17:44:52.124]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.124]                     cond$call), session = sessionInformation(), 
[17:44:52.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.124]                   signalCondition(cond)
[17:44:52.124]                 }
[17:44:52.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.124]                 "immediateCondition"))) {
[17:44:52.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.124]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.124]                   if (TRUE && !signal) {
[17:44:52.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.124]                     {
[17:44:52.124]                       inherits <- base::inherits
[17:44:52.124]                       invokeRestart <- base::invokeRestart
[17:44:52.124]                       is.null <- base::is.null
[17:44:52.124]                       muffled <- FALSE
[17:44:52.124]                       if (inherits(cond, "message")) {
[17:44:52.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.124]                         if (muffled) 
[17:44:52.124]                           invokeRestart("muffleMessage")
[17:44:52.124]                       }
[17:44:52.124]                       else if (inherits(cond, "warning")) {
[17:44:52.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.124]                         if (muffled) 
[17:44:52.124]                           invokeRestart("muffleWarning")
[17:44:52.124]                       }
[17:44:52.124]                       else if (inherits(cond, "condition")) {
[17:44:52.124]                         if (!is.null(pattern)) {
[17:44:52.124]                           computeRestarts <- base::computeRestarts
[17:44:52.124]                           grepl <- base::grepl
[17:44:52.124]                           restarts <- computeRestarts(cond)
[17:44:52.124]                           for (restart in restarts) {
[17:44:52.124]                             name <- restart$name
[17:44:52.124]                             if (is.null(name)) 
[17:44:52.124]                               next
[17:44:52.124]                             if (!grepl(pattern, name)) 
[17:44:52.124]                               next
[17:44:52.124]                             invokeRestart(restart)
[17:44:52.124]                             muffled <- TRUE
[17:44:52.124]                             break
[17:44:52.124]                           }
[17:44:52.124]                         }
[17:44:52.124]                       }
[17:44:52.124]                       invisible(muffled)
[17:44:52.124]                     }
[17:44:52.124]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.124]                   }
[17:44:52.124]                 }
[17:44:52.124]                 else {
[17:44:52.124]                   if (TRUE) {
[17:44:52.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.124]                     {
[17:44:52.124]                       inherits <- base::inherits
[17:44:52.124]                       invokeRestart <- base::invokeRestart
[17:44:52.124]                       is.null <- base::is.null
[17:44:52.124]                       muffled <- FALSE
[17:44:52.124]                       if (inherits(cond, "message")) {
[17:44:52.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.124]                         if (muffled) 
[17:44:52.124]                           invokeRestart("muffleMessage")
[17:44:52.124]                       }
[17:44:52.124]                       else if (inherits(cond, "warning")) {
[17:44:52.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.124]                         if (muffled) 
[17:44:52.124]                           invokeRestart("muffleWarning")
[17:44:52.124]                       }
[17:44:52.124]                       else if (inherits(cond, "condition")) {
[17:44:52.124]                         if (!is.null(pattern)) {
[17:44:52.124]                           computeRestarts <- base::computeRestarts
[17:44:52.124]                           grepl <- base::grepl
[17:44:52.124]                           restarts <- computeRestarts(cond)
[17:44:52.124]                           for (restart in restarts) {
[17:44:52.124]                             name <- restart$name
[17:44:52.124]                             if (is.null(name)) 
[17:44:52.124]                               next
[17:44:52.124]                             if (!grepl(pattern, name)) 
[17:44:52.124]                               next
[17:44:52.124]                             invokeRestart(restart)
[17:44:52.124]                             muffled <- TRUE
[17:44:52.124]                             break
[17:44:52.124]                           }
[17:44:52.124]                         }
[17:44:52.124]                       }
[17:44:52.124]                       invisible(muffled)
[17:44:52.124]                     }
[17:44:52.124]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.124]                   }
[17:44:52.124]                 }
[17:44:52.124]             }
[17:44:52.124]         }))
[17:44:52.124]     }, error = function(ex) {
[17:44:52.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.124]                 ...future.rng), started = ...future.startTime, 
[17:44:52.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.124]             version = "1.8"), class = "FutureResult")
[17:44:52.124]     }, finally = {
[17:44:52.124]         if (!identical(...future.workdir, getwd())) 
[17:44:52.124]             setwd(...future.workdir)
[17:44:52.124]         {
[17:44:52.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.124]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.124]             }
[17:44:52.124]             base::options(...future.oldOptions)
[17:44:52.124]             if (.Platform$OS.type == "windows") {
[17:44:52.124]                 old_names <- names(...future.oldEnvVars)
[17:44:52.124]                 envs <- base::Sys.getenv()
[17:44:52.124]                 names <- names(envs)
[17:44:52.124]                 common <- intersect(names, old_names)
[17:44:52.124]                 added <- setdiff(names, old_names)
[17:44:52.124]                 removed <- setdiff(old_names, names)
[17:44:52.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.124]                   envs[common]]
[17:44:52.124]                 NAMES <- toupper(changed)
[17:44:52.124]                 args <- list()
[17:44:52.124]                 for (kk in seq_along(NAMES)) {
[17:44:52.124]                   name <- changed[[kk]]
[17:44:52.124]                   NAME <- NAMES[[kk]]
[17:44:52.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.124]                     next
[17:44:52.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.124]                 }
[17:44:52.124]                 NAMES <- toupper(added)
[17:44:52.124]                 for (kk in seq_along(NAMES)) {
[17:44:52.124]                   name <- added[[kk]]
[17:44:52.124]                   NAME <- NAMES[[kk]]
[17:44:52.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.124]                     next
[17:44:52.124]                   args[[name]] <- ""
[17:44:52.124]                 }
[17:44:52.124]                 NAMES <- toupper(removed)
[17:44:52.124]                 for (kk in seq_along(NAMES)) {
[17:44:52.124]                   name <- removed[[kk]]
[17:44:52.124]                   NAME <- NAMES[[kk]]
[17:44:52.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.124]                     next
[17:44:52.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.124]                 }
[17:44:52.124]                 if (length(args) > 0) 
[17:44:52.124]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.124]             }
[17:44:52.124]             else {
[17:44:52.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.124]             }
[17:44:52.124]             {
[17:44:52.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.124]                   0L) {
[17:44:52.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.124]                   base::options(opts)
[17:44:52.124]                 }
[17:44:52.124]                 {
[17:44:52.124]                   {
[17:44:52.124]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.124]                     NULL
[17:44:52.124]                   }
[17:44:52.124]                   options(future.plan = NULL)
[17:44:52.124]                   if (is.na(NA_character_)) 
[17:44:52.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.124]                     .init = FALSE)
[17:44:52.124]                 }
[17:44:52.124]             }
[17:44:52.124]         }
[17:44:52.124]     })
[17:44:52.124]     if (TRUE) {
[17:44:52.124]         base::sink(type = "output", split = FALSE)
[17:44:52.124]         if (TRUE) {
[17:44:52.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.124]         }
[17:44:52.124]         else {
[17:44:52.124]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.124]         }
[17:44:52.124]         base::close(...future.stdout)
[17:44:52.124]         ...future.stdout <- NULL
[17:44:52.124]     }
[17:44:52.124]     ...future.result$conditions <- ...future.conditions
[17:44:52.124]     ...future.result$finished <- base::Sys.time()
[17:44:52.124]     ...future.result
[17:44:52.124] }
[17:44:52.127] Exporting 5 global objects (2.47 KiB) to cluster node #1 ...
[17:44:52.127] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ...
[17:44:52.128] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #1 ... DONE
[17:44:52.128] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ...
[17:44:52.128] Exporting ‘MoreArgs’ (56 bytes) to cluster node #1 ... DONE
[17:44:52.128] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ...
[17:44:52.129] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #1 ... DONE
[17:44:52.129] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ...
[17:44:52.129] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #1 ... DONE
[17:44:52.129] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:52.130] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.130] Exporting 5 global objects (2.47 KiB) to cluster node #1 ... DONE
[17:44:52.130] MultisessionFuture started
[17:44:52.130] - Launch lazy future ... done
[17:44:52.130] run() for ‘MultisessionFuture’ ... done
[17:44:52.130] Created future:
[17:44:52.130] MultisessionFuture:
[17:44:52.130] Label: ‘future_mapply-1’
[17:44:52.130] Expression:
[17:44:52.130] {
[17:44:52.130]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.130]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.130]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.130]         on.exit(options(oopts), add = TRUE)
[17:44:52.130]     }
[17:44:52.130]     {
[17:44:52.130]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:52.130]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:52.130]                 inherits = FALSE)
[17:44:52.130]             ...future.FUN(...)
[17:44:52.130]         }
[17:44:52.130]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:52.130]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:52.130]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.130]         do.call(mapply, args = args)
[17:44:52.130]     }
[17:44:52.130] }
[17:44:52.130] Lazy evaluation: FALSE
[17:44:52.130] Asynchronous evaluation: TRUE
[17:44:52.130] Local evaluation: TRUE
[17:44:52.130] Environment: R_GlobalEnv
[17:44:52.130] Capture standard output: TRUE
[17:44:52.130] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.130] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.130] Packages: 1 packages (‘stats’)
[17:44:52.130] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:52.130] Resolved: FALSE
[17:44:52.130] Value: <not collected>
[17:44:52.130] Conditions captured: <none>
[17:44:52.130] Early signaling: FALSE
[17:44:52.130] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.130] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.142] Chunk #1 of 2 ... DONE
[17:44:52.142] Chunk #2 of 2 ...
[17:44:52.142]  - Finding globals in '...' for chunk #2 ...
[17:44:52.142] getGlobalsAndPackages() ...
[17:44:52.142] Searching for globals...
[17:44:52.143] 
[17:44:52.143] Searching for globals ... DONE
[17:44:52.143] - globals: [0] <none>
[17:44:52.143] getGlobalsAndPackages() ... DONE
[17:44:52.143]    + additional globals found: [n=0] 
[17:44:52.143]    + additional namespaces needed: [n=0] 
[17:44:52.143]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:52.143]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.144]  - seeds: [2] <seeds>
[17:44:52.144]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.144] getGlobalsAndPackages() ...
[17:44:52.144] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.144] Resolving globals: FALSE
[17:44:52.144] The total size of the 5 globals is 2.47 KiB (2528 bytes)
[17:44:52.145] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.47 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (2.04 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘...future.seeds_ii’ (160 bytes of class ‘list’)
[17:44:52.145] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.145] - packages: [1] ‘stats’
[17:44:52.145] getGlobalsAndPackages() ... DONE
[17:44:52.145] run() for ‘Future’ ...
[17:44:52.146] - state: ‘created’
[17:44:52.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.161]   - Field: ‘node’
[17:44:52.161]   - Field: ‘label’
[17:44:52.161]   - Field: ‘local’
[17:44:52.161]   - Field: ‘owner’
[17:44:52.161]   - Field: ‘envir’
[17:44:52.161]   - Field: ‘workers’
[17:44:52.161]   - Field: ‘packages’
[17:44:52.161]   - Field: ‘gc’
[17:44:52.161]   - Field: ‘conditions’
[17:44:52.161]   - Field: ‘persistent’
[17:44:52.162]   - Field: ‘expr’
[17:44:52.162]   - Field: ‘uuid’
[17:44:52.162]   - Field: ‘seed’
[17:44:52.162]   - Field: ‘version’
[17:44:52.162]   - Field: ‘result’
[17:44:52.162]   - Field: ‘asynchronous’
[17:44:52.162]   - Field: ‘calls’
[17:44:52.162]   - Field: ‘globals’
[17:44:52.162]   - Field: ‘stdout’
[17:44:52.162]   - Field: ‘earlySignal’
[17:44:52.162]   - Field: ‘lazy’
[17:44:52.163]   - Field: ‘state’
[17:44:52.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.165] - Launch lazy future ...
[17:44:52.165] Packages needed by the future expression (n = 1): ‘stats’
[17:44:52.166] Packages needed by future strategies (n = 0): <none>
[17:44:52.166] {
[17:44:52.166]     {
[17:44:52.166]         {
[17:44:52.166]             ...future.startTime <- base::Sys.time()
[17:44:52.166]             {
[17:44:52.166]                 {
[17:44:52.166]                   {
[17:44:52.166]                     {
[17:44:52.166]                       {
[17:44:52.166]                         base::local({
[17:44:52.166]                           has_future <- base::requireNamespace("future", 
[17:44:52.166]                             quietly = TRUE)
[17:44:52.166]                           if (has_future) {
[17:44:52.166]                             ns <- base::getNamespace("future")
[17:44:52.166]                             version <- ns[[".package"]][["version"]]
[17:44:52.166]                             if (is.null(version)) 
[17:44:52.166]                               version <- utils::packageVersion("future")
[17:44:52.166]                           }
[17:44:52.166]                           else {
[17:44:52.166]                             version <- NULL
[17:44:52.166]                           }
[17:44:52.166]                           if (!has_future || version < "1.8.0") {
[17:44:52.166]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.166]                               "", base::R.version$version.string), 
[17:44:52.166]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:52.166]                                 base::R.version$platform, 8 * 
[17:44:52.166]                                   base::.Machine$sizeof.pointer), 
[17:44:52.166]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.166]                                 "release", "version")], collapse = " "), 
[17:44:52.166]                               hostname = base::Sys.info()[["nodename"]])
[17:44:52.166]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.166]                               info)
[17:44:52.166]                             info <- base::paste(info, collapse = "; ")
[17:44:52.166]                             if (!has_future) {
[17:44:52.166]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.166]                                 info)
[17:44:52.166]                             }
[17:44:52.166]                             else {
[17:44:52.166]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.166]                                 info, version)
[17:44:52.166]                             }
[17:44:52.166]                             base::stop(msg)
[17:44:52.166]                           }
[17:44:52.166]                         })
[17:44:52.166]                       }
[17:44:52.166]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.166]                       base::options(mc.cores = 1L)
[17:44:52.166]                     }
[17:44:52.166]                     base::local({
[17:44:52.166]                       for (pkg in "stats") {
[17:44:52.166]                         base::loadNamespace(pkg)
[17:44:52.166]                         base::library(pkg, character.only = TRUE)
[17:44:52.166]                       }
[17:44:52.166]                     })
[17:44:52.166]                   }
[17:44:52.166]                   ...future.strategy.old <- future::plan("list")
[17:44:52.166]                   options(future.plan = NULL)
[17:44:52.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.166]                 }
[17:44:52.166]                 ...future.workdir <- getwd()
[17:44:52.166]             }
[17:44:52.166]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.166]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.166]         }
[17:44:52.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.166]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.166]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.166]             base::names(...future.oldOptions))
[17:44:52.166]     }
[17:44:52.166]     if (FALSE) {
[17:44:52.166]     }
[17:44:52.166]     else {
[17:44:52.166]         if (TRUE) {
[17:44:52.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.166]                 open = "w")
[17:44:52.166]         }
[17:44:52.166]         else {
[17:44:52.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.166]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.166]         }
[17:44:52.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.166]             base::sink(type = "output", split = FALSE)
[17:44:52.166]             base::close(...future.stdout)
[17:44:52.166]         }, add = TRUE)
[17:44:52.166]     }
[17:44:52.166]     ...future.frame <- base::sys.nframe()
[17:44:52.166]     ...future.conditions <- base::list()
[17:44:52.166]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.166]     if (FALSE) {
[17:44:52.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.166]     }
[17:44:52.166]     ...future.result <- base::tryCatch({
[17:44:52.166]         base::withCallingHandlers({
[17:44:52.166]             ...future.value <- base::withVisible(base::local({
[17:44:52.166]                 ...future.makeSendCondition <- base::local({
[17:44:52.166]                   sendCondition <- NULL
[17:44:52.166]                   function(frame = 1L) {
[17:44:52.166]                     if (is.function(sendCondition)) 
[17:44:52.166]                       return(sendCondition)
[17:44:52.166]                     ns <- getNamespace("parallel")
[17:44:52.166]                     if (exists("sendData", mode = "function", 
[17:44:52.166]                       envir = ns)) {
[17:44:52.166]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.166]                         envir = ns)
[17:44:52.166]                       envir <- sys.frame(frame)
[17:44:52.166]                       master <- NULL
[17:44:52.166]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.166]                         !identical(envir, emptyenv())) {
[17:44:52.166]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.166]                           inherits = FALSE)) {
[17:44:52.166]                           master <- get("master", mode = "list", 
[17:44:52.166]                             envir = envir, inherits = FALSE)
[17:44:52.166]                           if (inherits(master, c("SOCKnode", 
[17:44:52.166]                             "SOCK0node"))) {
[17:44:52.166]                             sendCondition <<- function(cond) {
[17:44:52.166]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.166]                                 success = TRUE)
[17:44:52.166]                               parallel_sendData(master, data)
[17:44:52.166]                             }
[17:44:52.166]                             return(sendCondition)
[17:44:52.166]                           }
[17:44:52.166]                         }
[17:44:52.166]                         frame <- frame + 1L
[17:44:52.166]                         envir <- sys.frame(frame)
[17:44:52.166]                       }
[17:44:52.166]                     }
[17:44:52.166]                     sendCondition <<- function(cond) NULL
[17:44:52.166]                   }
[17:44:52.166]                 })
[17:44:52.166]                 withCallingHandlers({
[17:44:52.166]                   {
[17:44:52.166]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.166]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.166]                       ...future.globals.maxSize)) {
[17:44:52.166]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.166]                       on.exit(options(oopts), add = TRUE)
[17:44:52.166]                     }
[17:44:52.166]                     {
[17:44:52.166]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:52.166]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[17:44:52.166]                           envir = globalenv(), inherits = FALSE)
[17:44:52.166]                         ...future.FUN(...)
[17:44:52.166]                       }
[17:44:52.166]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:52.166]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:52.166]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.166]                         USE.NAMES = FALSE)
[17:44:52.166]                       do.call(mapply, args = args)
[17:44:52.166]                     }
[17:44:52.166]                   }
[17:44:52.166]                 }, immediateCondition = function(cond) {
[17:44:52.166]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.166]                   sendCondition(cond)
[17:44:52.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.166]                   {
[17:44:52.166]                     inherits <- base::inherits
[17:44:52.166]                     invokeRestart <- base::invokeRestart
[17:44:52.166]                     is.null <- base::is.null
[17:44:52.166]                     muffled <- FALSE
[17:44:52.166]                     if (inherits(cond, "message")) {
[17:44:52.166]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.166]                       if (muffled) 
[17:44:52.166]                         invokeRestart("muffleMessage")
[17:44:52.166]                     }
[17:44:52.166]                     else if (inherits(cond, "warning")) {
[17:44:52.166]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.166]                       if (muffled) 
[17:44:52.166]                         invokeRestart("muffleWarning")
[17:44:52.166]                     }
[17:44:52.166]                     else if (inherits(cond, "condition")) {
[17:44:52.166]                       if (!is.null(pattern)) {
[17:44:52.166]                         computeRestarts <- base::computeRestarts
[17:44:52.166]                         grepl <- base::grepl
[17:44:52.166]                         restarts <- computeRestarts(cond)
[17:44:52.166]                         for (restart in restarts) {
[17:44:52.166]                           name <- restart$name
[17:44:52.166]                           if (is.null(name)) 
[17:44:52.166]                             next
[17:44:52.166]                           if (!grepl(pattern, name)) 
[17:44:52.166]                             next
[17:44:52.166]                           invokeRestart(restart)
[17:44:52.166]                           muffled <- TRUE
[17:44:52.166]                           break
[17:44:52.166]                         }
[17:44:52.166]                       }
[17:44:52.166]                     }
[17:44:52.166]                     invisible(muffled)
[17:44:52.166]                   }
[17:44:52.166]                   muffleCondition(cond)
[17:44:52.166]                 })
[17:44:52.166]             }))
[17:44:52.166]             future::FutureResult(value = ...future.value$value, 
[17:44:52.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.166]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.166]                     ...future.globalenv.names))
[17:44:52.166]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.166]         }, condition = base::local({
[17:44:52.166]             c <- base::c
[17:44:52.166]             inherits <- base::inherits
[17:44:52.166]             invokeRestart <- base::invokeRestart
[17:44:52.166]             length <- base::length
[17:44:52.166]             list <- base::list
[17:44:52.166]             seq.int <- base::seq.int
[17:44:52.166]             signalCondition <- base::signalCondition
[17:44:52.166]             sys.calls <- base::sys.calls
[17:44:52.166]             `[[` <- base::`[[`
[17:44:52.166]             `+` <- base::`+`
[17:44:52.166]             `<<-` <- base::`<<-`
[17:44:52.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.166]                   3L)]
[17:44:52.166]             }
[17:44:52.166]             function(cond) {
[17:44:52.166]                 is_error <- inherits(cond, "error")
[17:44:52.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.166]                   NULL)
[17:44:52.166]                 if (is_error) {
[17:44:52.166]                   sessionInformation <- function() {
[17:44:52.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.166]                       search = base::search(), system = base::Sys.info())
[17:44:52.166]                   }
[17:44:52.166]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.166]                     cond$call), session = sessionInformation(), 
[17:44:52.166]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.166]                   signalCondition(cond)
[17:44:52.166]                 }
[17:44:52.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.166]                 "immediateCondition"))) {
[17:44:52.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.166]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.166]                   if (TRUE && !signal) {
[17:44:52.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.166]                     {
[17:44:52.166]                       inherits <- base::inherits
[17:44:52.166]                       invokeRestart <- base::invokeRestart
[17:44:52.166]                       is.null <- base::is.null
[17:44:52.166]                       muffled <- FALSE
[17:44:52.166]                       if (inherits(cond, "message")) {
[17:44:52.166]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.166]                         if (muffled) 
[17:44:52.166]                           invokeRestart("muffleMessage")
[17:44:52.166]                       }
[17:44:52.166]                       else if (inherits(cond, "warning")) {
[17:44:52.166]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.166]                         if (muffled) 
[17:44:52.166]                           invokeRestart("muffleWarning")
[17:44:52.166]                       }
[17:44:52.166]                       else if (inherits(cond, "condition")) {
[17:44:52.166]                         if (!is.null(pattern)) {
[17:44:52.166]                           computeRestarts <- base::computeRestarts
[17:44:52.166]                           grepl <- base::grepl
[17:44:52.166]                           restarts <- computeRestarts(cond)
[17:44:52.166]                           for (restart in restarts) {
[17:44:52.166]                             name <- restart$name
[17:44:52.166]                             if (is.null(name)) 
[17:44:52.166]                               next
[17:44:52.166]                             if (!grepl(pattern, name)) 
[17:44:52.166]                               next
[17:44:52.166]                             invokeRestart(restart)
[17:44:52.166]                             muffled <- TRUE
[17:44:52.166]                             break
[17:44:52.166]                           }
[17:44:52.166]                         }
[17:44:52.166]                       }
[17:44:52.166]                       invisible(muffled)
[17:44:52.166]                     }
[17:44:52.166]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.166]                   }
[17:44:52.166]                 }
[17:44:52.166]                 else {
[17:44:52.166]                   if (TRUE) {
[17:44:52.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.166]                     {
[17:44:52.166]                       inherits <- base::inherits
[17:44:52.166]                       invokeRestart <- base::invokeRestart
[17:44:52.166]                       is.null <- base::is.null
[17:44:52.166]                       muffled <- FALSE
[17:44:52.166]                       if (inherits(cond, "message")) {
[17:44:52.166]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.166]                         if (muffled) 
[17:44:52.166]                           invokeRestart("muffleMessage")
[17:44:52.166]                       }
[17:44:52.166]                       else if (inherits(cond, "warning")) {
[17:44:52.166]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.166]                         if (muffled) 
[17:44:52.166]                           invokeRestart("muffleWarning")
[17:44:52.166]                       }
[17:44:52.166]                       else if (inherits(cond, "condition")) {
[17:44:52.166]                         if (!is.null(pattern)) {
[17:44:52.166]                           computeRestarts <- base::computeRestarts
[17:44:52.166]                           grepl <- base::grepl
[17:44:52.166]                           restarts <- computeRestarts(cond)
[17:44:52.166]                           for (restart in restarts) {
[17:44:52.166]                             name <- restart$name
[17:44:52.166]                             if (is.null(name)) 
[17:44:52.166]                               next
[17:44:52.166]                             if (!grepl(pattern, name)) 
[17:44:52.166]                               next
[17:44:52.166]                             invokeRestart(restart)
[17:44:52.166]                             muffled <- TRUE
[17:44:52.166]                             break
[17:44:52.166]                           }
[17:44:52.166]                         }
[17:44:52.166]                       }
[17:44:52.166]                       invisible(muffled)
[17:44:52.166]                     }
[17:44:52.166]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.166]                   }
[17:44:52.166]                 }
[17:44:52.166]             }
[17:44:52.166]         }))
[17:44:52.166]     }, error = function(ex) {
[17:44:52.166]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.166]                 ...future.rng), started = ...future.startTime, 
[17:44:52.166]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.166]             version = "1.8"), class = "FutureResult")
[17:44:52.166]     }, finally = {
[17:44:52.166]         if (!identical(...future.workdir, getwd())) 
[17:44:52.166]             setwd(...future.workdir)
[17:44:52.166]         {
[17:44:52.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.166]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.166]             }
[17:44:52.166]             base::options(...future.oldOptions)
[17:44:52.166]             if (.Platform$OS.type == "windows") {
[17:44:52.166]                 old_names <- names(...future.oldEnvVars)
[17:44:52.166]                 envs <- base::Sys.getenv()
[17:44:52.166]                 names <- names(envs)
[17:44:52.166]                 common <- intersect(names, old_names)
[17:44:52.166]                 added <- setdiff(names, old_names)
[17:44:52.166]                 removed <- setdiff(old_names, names)
[17:44:52.166]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.166]                   envs[common]]
[17:44:52.166]                 NAMES <- toupper(changed)
[17:44:52.166]                 args <- list()
[17:44:52.166]                 for (kk in seq_along(NAMES)) {
[17:44:52.166]                   name <- changed[[kk]]
[17:44:52.166]                   NAME <- NAMES[[kk]]
[17:44:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.166]                     next
[17:44:52.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.166]                 }
[17:44:52.166]                 NAMES <- toupper(added)
[17:44:52.166]                 for (kk in seq_along(NAMES)) {
[17:44:52.166]                   name <- added[[kk]]
[17:44:52.166]                   NAME <- NAMES[[kk]]
[17:44:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.166]                     next
[17:44:52.166]                   args[[name]] <- ""
[17:44:52.166]                 }
[17:44:52.166]                 NAMES <- toupper(removed)
[17:44:52.166]                 for (kk in seq_along(NAMES)) {
[17:44:52.166]                   name <- removed[[kk]]
[17:44:52.166]                   NAME <- NAMES[[kk]]
[17:44:52.166]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.166]                     next
[17:44:52.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.166]                 }
[17:44:52.166]                 if (length(args) > 0) 
[17:44:52.166]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.166]             }
[17:44:52.166]             else {
[17:44:52.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.166]             }
[17:44:52.166]             {
[17:44:52.166]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.166]                   0L) {
[17:44:52.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.166]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.166]                   base::options(opts)
[17:44:52.166]                 }
[17:44:52.166]                 {
[17:44:52.166]                   {
[17:44:52.166]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.166]                     NULL
[17:44:52.166]                   }
[17:44:52.166]                   options(future.plan = NULL)
[17:44:52.166]                   if (is.na(NA_character_)) 
[17:44:52.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.166]                     .init = FALSE)
[17:44:52.166]                 }
[17:44:52.166]             }
[17:44:52.166]         }
[17:44:52.166]     })
[17:44:52.166]     if (TRUE) {
[17:44:52.166]         base::sink(type = "output", split = FALSE)
[17:44:52.166]         if (TRUE) {
[17:44:52.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.166]         }
[17:44:52.166]         else {
[17:44:52.166]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.166]         }
[17:44:52.166]         base::close(...future.stdout)
[17:44:52.166]         ...future.stdout <- NULL
[17:44:52.166]     }
[17:44:52.166]     ...future.result$conditions <- ...future.conditions
[17:44:52.166]     ...future.result$finished <- base::Sys.time()
[17:44:52.166]     ...future.result
[17:44:52.166] }
[17:44:52.169] Exporting 5 global objects (2.47 KiB) to cluster node #2 ...
[17:44:52.169] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ...
[17:44:52.169] Exporting ‘...future.FUN’ (2.04 KiB) to cluster node #2 ... DONE
[17:44:52.169] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ...
[17:44:52.170] Exporting ‘MoreArgs’ (56 bytes) to cluster node #2 ... DONE
[17:44:52.170] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:52.170] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:52.170] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ...
[17:44:52.171] Exporting ‘...future.seeds_ii’ (160 bytes) to cluster node #2 ... DONE
[17:44:52.171] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:52.171] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.171] Exporting 5 global objects (2.47 KiB) to cluster node #2 ... DONE
[17:44:52.172] MultisessionFuture started
[17:44:52.172] - Launch lazy future ... done
[17:44:52.172] run() for ‘MultisessionFuture’ ... done
[17:44:52.172] Created future:
[17:44:52.173] MultisessionFuture:
[17:44:52.173] Label: ‘future_mapply-2’
[17:44:52.173] Expression:
[17:44:52.173] {
[17:44:52.173]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.173]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.173]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.173]         on.exit(options(oopts), add = TRUE)
[17:44:52.173]     }
[17:44:52.173]     {
[17:44:52.173]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[17:44:52.173]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[17:44:52.173]                 inherits = FALSE)
[17:44:52.173]             ...future.FUN(...)
[17:44:52.173]         }
[17:44:52.173]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[17:44:52.173]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[17:44:52.173]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.173]         do.call(mapply, args = args)
[17:44:52.173]     }
[17:44:52.173] }
[17:44:52.173] Lazy evaluation: FALSE
[17:44:52.173] Asynchronous evaluation: TRUE
[17:44:52.173] Local evaluation: TRUE
[17:44:52.173] Environment: R_GlobalEnv
[17:44:52.173] Capture standard output: TRUE
[17:44:52.173] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.173] Globals: 5 objects totaling 2.47 KiB (function ‘...future.FUN’ of 2.04 KiB, list ‘MoreArgs’ of 56 bytes, list ‘...future.elements_ii’ of 224 bytes, list ‘...future.seeds_ii’ of 160 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.173] Packages: 1 packages (‘stats’)
[17:44:52.173] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[17:44:52.173] Resolved: FALSE
[17:44:52.173] Value: <not collected>
[17:44:52.173] Conditions captured: <none>
[17:44:52.173] Early signaling: FALSE
[17:44:52.173] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.173] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.184] Chunk #2 of 2 ... DONE
[17:44:52.184] Launching 2 futures (chunks) ... DONE
[17:44:52.184] Resolving 2 futures (chunks) ...
[17:44:52.184] resolve() on list ...
[17:44:52.184]  recursive: 0
[17:44:52.184]  length: 2
[17:44:52.185] 
[17:44:52.185] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.185] - Validating connection of MultisessionFuture
[17:44:52.185] - received message: FutureResult
[17:44:52.185] - Received FutureResult
[17:44:52.185] - Erased future from FutureRegistry
[17:44:52.186] result() for ClusterFuture ...
[17:44:52.186] - result already collected: FutureResult
[17:44:52.186] result() for ClusterFuture ... done
[17:44:52.186] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.186] Future #1
[17:44:52.186] result() for ClusterFuture ...
[17:44:52.186] - result already collected: FutureResult
[17:44:52.186] result() for ClusterFuture ... done
[17:44:52.186] result() for ClusterFuture ...
[17:44:52.186] - result already collected: FutureResult
[17:44:52.186] result() for ClusterFuture ... done
[17:44:52.187] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:52.187] - nx: 2
[17:44:52.187] - relay: TRUE
[17:44:52.187] - stdout: TRUE
[17:44:52.187] - signal: TRUE
[17:44:52.187] - resignal: FALSE
[17:44:52.187] - force: TRUE
[17:44:52.187] - relayed: [n=2] FALSE, FALSE
[17:44:52.187] - queued futures: [n=2] FALSE, FALSE
[17:44:52.187]  - until=1
[17:44:52.187]  - relaying element #1
[17:44:52.187] result() for ClusterFuture ...
[17:44:52.188] - result already collected: FutureResult
[17:44:52.188] result() for ClusterFuture ... done
[17:44:52.188] result() for ClusterFuture ...
[17:44:52.188] - result already collected: FutureResult
[17:44:52.188] result() for ClusterFuture ... done
[17:44:52.188] result() for ClusterFuture ...
[17:44:52.188] - result already collected: FutureResult
[17:44:52.188] result() for ClusterFuture ... done
[17:44:52.188] result() for ClusterFuture ...
[17:44:52.188] - result already collected: FutureResult
[17:44:52.188] result() for ClusterFuture ... done
[17:44:52.189] - relayed: [n=2] TRUE, FALSE
[17:44:52.189] - queued futures: [n=2] TRUE, FALSE
[17:44:52.189] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:52.189]  length: 1 (resolved future 1)
[17:44:52.217] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.217] - Validating connection of MultisessionFuture
[17:44:52.217] - received message: FutureResult
[17:44:52.218] - Received FutureResult
[17:44:52.218] - Erased future from FutureRegistry
[17:44:52.218] result() for ClusterFuture ...
[17:44:52.218] - result already collected: FutureResult
[17:44:52.218] result() for ClusterFuture ... done
[17:44:52.218] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.218] Future #2
[17:44:52.218] result() for ClusterFuture ...
[17:44:52.218] - result already collected: FutureResult
[17:44:52.218] result() for ClusterFuture ... done
[17:44:52.218] result() for ClusterFuture ...
[17:44:52.219] - result already collected: FutureResult
[17:44:52.219] result() for ClusterFuture ... done
[17:44:52.219] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:52.219] - nx: 2
[17:44:52.219] - relay: TRUE
[17:44:52.219] - stdout: TRUE
[17:44:52.219] - signal: TRUE
[17:44:52.219] - resignal: FALSE
[17:44:52.219] - force: TRUE
[17:44:52.219] - relayed: [n=2] TRUE, FALSE
[17:44:52.219] - queued futures: [n=2] TRUE, FALSE
[17:44:52.220]  - until=2
[17:44:52.220]  - relaying element #2
[17:44:52.220] result() for ClusterFuture ...
[17:44:52.220] - result already collected: FutureResult
[17:44:52.220] result() for ClusterFuture ... done
[17:44:52.220] result() for ClusterFuture ...
[17:44:52.220] - result already collected: FutureResult
[17:44:52.220] result() for ClusterFuture ... done
[17:44:52.220] result() for ClusterFuture ...
[17:44:52.220] - result already collected: FutureResult
[17:44:52.220] result() for ClusterFuture ... done
[17:44:52.221] result() for ClusterFuture ...
[17:44:52.221] - result already collected: FutureResult
[17:44:52.221] result() for ClusterFuture ... done
[17:44:52.221] - relayed: [n=2] TRUE, TRUE
[17:44:52.221] - queued futures: [n=2] TRUE, TRUE
[17:44:52.221] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:52.221]  length: 0 (resolved future 2)
[17:44:52.221] Relaying remaining futures
[17:44:52.221] signalConditionsASAP(NULL, pos=0) ...
[17:44:52.221] - nx: 2
[17:44:52.221] - relay: TRUE
[17:44:52.221] - stdout: TRUE
[17:44:52.222] - signal: TRUE
[17:44:52.222] - resignal: FALSE
[17:44:52.222] - force: TRUE
[17:44:52.222] - relayed: [n=2] TRUE, TRUE
[17:44:52.222] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:52.222] - relayed: [n=2] TRUE, TRUE
[17:44:52.222] - queued futures: [n=2] TRUE, TRUE
[17:44:52.222] signalConditionsASAP(NULL, pos=0) ... done
[17:44:52.222] resolve() on list ... DONE
[17:44:52.222] result() for ClusterFuture ...
[17:44:52.222] - result already collected: FutureResult
[17:44:52.222] result() for ClusterFuture ... done
[17:44:52.223] result() for ClusterFuture ...
[17:44:52.223] - result already collected: FutureResult
[17:44:52.223] result() for ClusterFuture ... done
[17:44:52.223] result() for ClusterFuture ...
[17:44:52.223] - result already collected: FutureResult
[17:44:52.223] result() for ClusterFuture ... done
[17:44:52.223] result() for ClusterFuture ...
[17:44:52.223] - result already collected: FutureResult
[17:44:52.223] result() for ClusterFuture ... done
[17:44:52.223]  - Number of value chunks collected: 2
[17:44:52.223] Resolving 2 futures (chunks) ... DONE
[17:44:52.224] Reducing values from 2 chunks ...
[17:44:52.224]  - Number of values collected after concatenation: 4
[17:44:52.224]  - Number of values expected: 4
[17:44:52.224] Reducing values from 2 chunks ... DONE
[17:44:52.224] future_mapply() ... DONE
[[1]]
[1] 1.752502

[[2]]
[1] 2.765950 2.044156

[[3]]
[1] 1.419503 3.529684 1.023802

[[4]]
[1] 4.494280 3.546145 1.402837 4.295444

- future_Map() ...
[17:44:52.224] future_mapply() ...
[17:44:52.228] Number of chunks: 2
[17:44:52.228] getGlobalsAndPackagesXApply() ...
[17:44:52.228]  - future.globals: TRUE
[17:44:52.228] getGlobalsAndPackages() ...
[17:44:52.229] Searching for globals...
[17:44:52.230] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:44:52.230] Searching for globals ... DONE
[17:44:52.230] Resolving globals: FALSE
[17:44:52.230] The total size of the 1 globals is 1.38 KiB (1416 bytes)
[17:44:52.230] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.38 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.38 KiB of class ‘function’)
[17:44:52.231] - globals: [1] ‘FUN’
[17:44:52.231] - packages: [1] ‘stats’
[17:44:52.231] getGlobalsAndPackages() ... DONE
[17:44:52.231]  - globals found/used: [n=1] ‘FUN’
[17:44:52.231]  - needed namespaces: [n=1] ‘stats’
[17:44:52.231] Finding globals ... DONE
[17:44:52.231] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:52.231] List of 2
[17:44:52.231]  $ ...future.FUN:function (x, w, ...)  
[17:44:52.231]  $ MoreArgs     : NULL
[17:44:52.231]  - attr(*, "where")=List of 2
[17:44:52.231]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:52.231]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:52.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:52.231]  - attr(*, "resolved")= logi FALSE
[17:44:52.231]  - attr(*, "total_size")= num NA
[17:44:52.234] Packages to be attached in all futures: [n=1] ‘stats’
[17:44:52.234] getGlobalsAndPackagesXApply() ... DONE
[17:44:52.234] Number of futures (= number of chunks): 2
[17:44:52.234] Launching 2 futures (chunks) ...
[17:44:52.234] Chunk #1 of 2 ...
[17:44:52.234]  - Finding globals in '...' for chunk #1 ...
[17:44:52.235] getGlobalsAndPackages() ...
[17:44:52.235] Searching for globals...
[17:44:52.235] 
[17:44:52.235] Searching for globals ... DONE
[17:44:52.235] - globals: [0] <none>
[17:44:52.235] getGlobalsAndPackages() ... DONE
[17:44:52.235]    + additional globals found: [n=0] 
[17:44:52.235]    + additional namespaces needed: [n=0] 
[17:44:52.235]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:52.236]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.236]  - seeds: <none>
[17:44:52.236]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.236] getGlobalsAndPackages() ...
[17:44:52.236] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.236] Resolving globals: FALSE
[17:44:52.236] The total size of the 5 globals is 2.07 KiB (2120 bytes)
[17:44:52.237] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.07 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (704 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.237] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.237] - packages: [1] ‘stats’
[17:44:52.237] getGlobalsAndPackages() ... DONE
[17:44:52.238] run() for ‘Future’ ...
[17:44:52.238] - state: ‘created’
[17:44:52.238] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.251] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.251]   - Field: ‘node’
[17:44:52.252]   - Field: ‘label’
[17:44:52.252]   - Field: ‘local’
[17:44:52.252]   - Field: ‘owner’
[17:44:52.252]   - Field: ‘envir’
[17:44:52.252]   - Field: ‘workers’
[17:44:52.252]   - Field: ‘packages’
[17:44:52.252]   - Field: ‘gc’
[17:44:52.252]   - Field: ‘conditions’
[17:44:52.252]   - Field: ‘persistent’
[17:44:52.252]   - Field: ‘expr’
[17:44:52.252]   - Field: ‘uuid’
[17:44:52.253]   - Field: ‘seed’
[17:44:52.253]   - Field: ‘version’
[17:44:52.253]   - Field: ‘result’
[17:44:52.253]   - Field: ‘asynchronous’
[17:44:52.253]   - Field: ‘calls’
[17:44:52.253]   - Field: ‘globals’
[17:44:52.253]   - Field: ‘stdout’
[17:44:52.253]   - Field: ‘earlySignal’
[17:44:52.253]   - Field: ‘lazy’
[17:44:52.253]   - Field: ‘state’
[17:44:52.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.254] - Launch lazy future ...
[17:44:52.254] Packages needed by the future expression (n = 1): ‘stats’
[17:44:52.254] Packages needed by future strategies (n = 0): <none>
[17:44:52.254] {
[17:44:52.254]     {
[17:44:52.254]         {
[17:44:52.254]             ...future.startTime <- base::Sys.time()
[17:44:52.254]             {
[17:44:52.254]                 {
[17:44:52.254]                   {
[17:44:52.254]                     {
[17:44:52.254]                       {
[17:44:52.254]                         base::local({
[17:44:52.254]                           has_future <- base::requireNamespace("future", 
[17:44:52.254]                             quietly = TRUE)
[17:44:52.254]                           if (has_future) {
[17:44:52.254]                             ns <- base::getNamespace("future")
[17:44:52.254]                             version <- ns[[".package"]][["version"]]
[17:44:52.254]                             if (is.null(version)) 
[17:44:52.254]                               version <- utils::packageVersion("future")
[17:44:52.254]                           }
[17:44:52.254]                           else {
[17:44:52.254]                             version <- NULL
[17:44:52.254]                           }
[17:44:52.254]                           if (!has_future || version < "1.8.0") {
[17:44:52.254]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.254]                               "", base::R.version$version.string), 
[17:44:52.254]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:52.254]                                 base::R.version$platform, 8 * 
[17:44:52.254]                                   base::.Machine$sizeof.pointer), 
[17:44:52.254]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.254]                                 "release", "version")], collapse = " "), 
[17:44:52.254]                               hostname = base::Sys.info()[["nodename"]])
[17:44:52.254]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.254]                               info)
[17:44:52.254]                             info <- base::paste(info, collapse = "; ")
[17:44:52.254]                             if (!has_future) {
[17:44:52.254]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.254]                                 info)
[17:44:52.254]                             }
[17:44:52.254]                             else {
[17:44:52.254]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.254]                                 info, version)
[17:44:52.254]                             }
[17:44:52.254]                             base::stop(msg)
[17:44:52.254]                           }
[17:44:52.254]                         })
[17:44:52.254]                       }
[17:44:52.254]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.254]                       base::options(mc.cores = 1L)
[17:44:52.254]                     }
[17:44:52.254]                     base::local({
[17:44:52.254]                       for (pkg in "stats") {
[17:44:52.254]                         base::loadNamespace(pkg)
[17:44:52.254]                         base::library(pkg, character.only = TRUE)
[17:44:52.254]                       }
[17:44:52.254]                     })
[17:44:52.254]                   }
[17:44:52.254]                   ...future.strategy.old <- future::plan("list")
[17:44:52.254]                   options(future.plan = NULL)
[17:44:52.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.254]                 }
[17:44:52.254]                 ...future.workdir <- getwd()
[17:44:52.254]             }
[17:44:52.254]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.254]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.254]         }
[17:44:52.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.254]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.254]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.254]             base::names(...future.oldOptions))
[17:44:52.254]     }
[17:44:52.254]     if (FALSE) {
[17:44:52.254]     }
[17:44:52.254]     else {
[17:44:52.254]         if (TRUE) {
[17:44:52.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.254]                 open = "w")
[17:44:52.254]         }
[17:44:52.254]         else {
[17:44:52.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.254]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.254]         }
[17:44:52.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.254]             base::sink(type = "output", split = FALSE)
[17:44:52.254]             base::close(...future.stdout)
[17:44:52.254]         }, add = TRUE)
[17:44:52.254]     }
[17:44:52.254]     ...future.frame <- base::sys.nframe()
[17:44:52.254]     ...future.conditions <- base::list()
[17:44:52.254]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.254]     if (FALSE) {
[17:44:52.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.254]     }
[17:44:52.254]     ...future.result <- base::tryCatch({
[17:44:52.254]         base::withCallingHandlers({
[17:44:52.254]             ...future.value <- base::withVisible(base::local({
[17:44:52.254]                 ...future.makeSendCondition <- base::local({
[17:44:52.254]                   sendCondition <- NULL
[17:44:52.254]                   function(frame = 1L) {
[17:44:52.254]                     if (is.function(sendCondition)) 
[17:44:52.254]                       return(sendCondition)
[17:44:52.254]                     ns <- getNamespace("parallel")
[17:44:52.254]                     if (exists("sendData", mode = "function", 
[17:44:52.254]                       envir = ns)) {
[17:44:52.254]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.254]                         envir = ns)
[17:44:52.254]                       envir <- sys.frame(frame)
[17:44:52.254]                       master <- NULL
[17:44:52.254]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.254]                         !identical(envir, emptyenv())) {
[17:44:52.254]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.254]                           inherits = FALSE)) {
[17:44:52.254]                           master <- get("master", mode = "list", 
[17:44:52.254]                             envir = envir, inherits = FALSE)
[17:44:52.254]                           if (inherits(master, c("SOCKnode", 
[17:44:52.254]                             "SOCK0node"))) {
[17:44:52.254]                             sendCondition <<- function(cond) {
[17:44:52.254]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.254]                                 success = TRUE)
[17:44:52.254]                               parallel_sendData(master, data)
[17:44:52.254]                             }
[17:44:52.254]                             return(sendCondition)
[17:44:52.254]                           }
[17:44:52.254]                         }
[17:44:52.254]                         frame <- frame + 1L
[17:44:52.254]                         envir <- sys.frame(frame)
[17:44:52.254]                       }
[17:44:52.254]                     }
[17:44:52.254]                     sendCondition <<- function(cond) NULL
[17:44:52.254]                   }
[17:44:52.254]                 })
[17:44:52.254]                 withCallingHandlers({
[17:44:52.254]                   {
[17:44:52.254]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.254]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.254]                       ...future.globals.maxSize)) {
[17:44:52.254]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.254]                       on.exit(options(oopts), add = TRUE)
[17:44:52.254]                     }
[17:44:52.254]                     {
[17:44:52.254]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.254]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.254]                         USE.NAMES = FALSE)
[17:44:52.254]                       do.call(mapply, args = args)
[17:44:52.254]                     }
[17:44:52.254]                   }
[17:44:52.254]                 }, immediateCondition = function(cond) {
[17:44:52.254]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.254]                   sendCondition(cond)
[17:44:52.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.254]                   {
[17:44:52.254]                     inherits <- base::inherits
[17:44:52.254]                     invokeRestart <- base::invokeRestart
[17:44:52.254]                     is.null <- base::is.null
[17:44:52.254]                     muffled <- FALSE
[17:44:52.254]                     if (inherits(cond, "message")) {
[17:44:52.254]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.254]                       if (muffled) 
[17:44:52.254]                         invokeRestart("muffleMessage")
[17:44:52.254]                     }
[17:44:52.254]                     else if (inherits(cond, "warning")) {
[17:44:52.254]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.254]                       if (muffled) 
[17:44:52.254]                         invokeRestart("muffleWarning")
[17:44:52.254]                     }
[17:44:52.254]                     else if (inherits(cond, "condition")) {
[17:44:52.254]                       if (!is.null(pattern)) {
[17:44:52.254]                         computeRestarts <- base::computeRestarts
[17:44:52.254]                         grepl <- base::grepl
[17:44:52.254]                         restarts <- computeRestarts(cond)
[17:44:52.254]                         for (restart in restarts) {
[17:44:52.254]                           name <- restart$name
[17:44:52.254]                           if (is.null(name)) 
[17:44:52.254]                             next
[17:44:52.254]                           if (!grepl(pattern, name)) 
[17:44:52.254]                             next
[17:44:52.254]                           invokeRestart(restart)
[17:44:52.254]                           muffled <- TRUE
[17:44:52.254]                           break
[17:44:52.254]                         }
[17:44:52.254]                       }
[17:44:52.254]                     }
[17:44:52.254]                     invisible(muffled)
[17:44:52.254]                   }
[17:44:52.254]                   muffleCondition(cond)
[17:44:52.254]                 })
[17:44:52.254]             }))
[17:44:52.254]             future::FutureResult(value = ...future.value$value, 
[17:44:52.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.254]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.254]                     ...future.globalenv.names))
[17:44:52.254]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.254]         }, condition = base::local({
[17:44:52.254]             c <- base::c
[17:44:52.254]             inherits <- base::inherits
[17:44:52.254]             invokeRestart <- base::invokeRestart
[17:44:52.254]             length <- base::length
[17:44:52.254]             list <- base::list
[17:44:52.254]             seq.int <- base::seq.int
[17:44:52.254]             signalCondition <- base::signalCondition
[17:44:52.254]             sys.calls <- base::sys.calls
[17:44:52.254]             `[[` <- base::`[[`
[17:44:52.254]             `+` <- base::`+`
[17:44:52.254]             `<<-` <- base::`<<-`
[17:44:52.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.254]                   3L)]
[17:44:52.254]             }
[17:44:52.254]             function(cond) {
[17:44:52.254]                 is_error <- inherits(cond, "error")
[17:44:52.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.254]                   NULL)
[17:44:52.254]                 if (is_error) {
[17:44:52.254]                   sessionInformation <- function() {
[17:44:52.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.254]                       search = base::search(), system = base::Sys.info())
[17:44:52.254]                   }
[17:44:52.254]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.254]                     cond$call), session = sessionInformation(), 
[17:44:52.254]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.254]                   signalCondition(cond)
[17:44:52.254]                 }
[17:44:52.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.254]                 "immediateCondition"))) {
[17:44:52.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.254]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.254]                   if (TRUE && !signal) {
[17:44:52.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.254]                     {
[17:44:52.254]                       inherits <- base::inherits
[17:44:52.254]                       invokeRestart <- base::invokeRestart
[17:44:52.254]                       is.null <- base::is.null
[17:44:52.254]                       muffled <- FALSE
[17:44:52.254]                       if (inherits(cond, "message")) {
[17:44:52.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.254]                         if (muffled) 
[17:44:52.254]                           invokeRestart("muffleMessage")
[17:44:52.254]                       }
[17:44:52.254]                       else if (inherits(cond, "warning")) {
[17:44:52.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.254]                         if (muffled) 
[17:44:52.254]                           invokeRestart("muffleWarning")
[17:44:52.254]                       }
[17:44:52.254]                       else if (inherits(cond, "condition")) {
[17:44:52.254]                         if (!is.null(pattern)) {
[17:44:52.254]                           computeRestarts <- base::computeRestarts
[17:44:52.254]                           grepl <- base::grepl
[17:44:52.254]                           restarts <- computeRestarts(cond)
[17:44:52.254]                           for (restart in restarts) {
[17:44:52.254]                             name <- restart$name
[17:44:52.254]                             if (is.null(name)) 
[17:44:52.254]                               next
[17:44:52.254]                             if (!grepl(pattern, name)) 
[17:44:52.254]                               next
[17:44:52.254]                             invokeRestart(restart)
[17:44:52.254]                             muffled <- TRUE
[17:44:52.254]                             break
[17:44:52.254]                           }
[17:44:52.254]                         }
[17:44:52.254]                       }
[17:44:52.254]                       invisible(muffled)
[17:44:52.254]                     }
[17:44:52.254]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.254]                   }
[17:44:52.254]                 }
[17:44:52.254]                 else {
[17:44:52.254]                   if (TRUE) {
[17:44:52.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.254]                     {
[17:44:52.254]                       inherits <- base::inherits
[17:44:52.254]                       invokeRestart <- base::invokeRestart
[17:44:52.254]                       is.null <- base::is.null
[17:44:52.254]                       muffled <- FALSE
[17:44:52.254]                       if (inherits(cond, "message")) {
[17:44:52.254]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.254]                         if (muffled) 
[17:44:52.254]                           invokeRestart("muffleMessage")
[17:44:52.254]                       }
[17:44:52.254]                       else if (inherits(cond, "warning")) {
[17:44:52.254]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.254]                         if (muffled) 
[17:44:52.254]                           invokeRestart("muffleWarning")
[17:44:52.254]                       }
[17:44:52.254]                       else if (inherits(cond, "condition")) {
[17:44:52.254]                         if (!is.null(pattern)) {
[17:44:52.254]                           computeRestarts <- base::computeRestarts
[17:44:52.254]                           grepl <- base::grepl
[17:44:52.254]                           restarts <- computeRestarts(cond)
[17:44:52.254]                           for (restart in restarts) {
[17:44:52.254]                             name <- restart$name
[17:44:52.254]                             if (is.null(name)) 
[17:44:52.254]                               next
[17:44:52.254]                             if (!grepl(pattern, name)) 
[17:44:52.254]                               next
[17:44:52.254]                             invokeRestart(restart)
[17:44:52.254]                             muffled <- TRUE
[17:44:52.254]                             break
[17:44:52.254]                           }
[17:44:52.254]                         }
[17:44:52.254]                       }
[17:44:52.254]                       invisible(muffled)
[17:44:52.254]                     }
[17:44:52.254]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.254]                   }
[17:44:52.254]                 }
[17:44:52.254]             }
[17:44:52.254]         }))
[17:44:52.254]     }, error = function(ex) {
[17:44:52.254]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.254]                 ...future.rng), started = ...future.startTime, 
[17:44:52.254]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.254]             version = "1.8"), class = "FutureResult")
[17:44:52.254]     }, finally = {
[17:44:52.254]         if (!identical(...future.workdir, getwd())) 
[17:44:52.254]             setwd(...future.workdir)
[17:44:52.254]         {
[17:44:52.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.254]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.254]             }
[17:44:52.254]             base::options(...future.oldOptions)
[17:44:52.254]             if (.Platform$OS.type == "windows") {
[17:44:52.254]                 old_names <- names(...future.oldEnvVars)
[17:44:52.254]                 envs <- base::Sys.getenv()
[17:44:52.254]                 names <- names(envs)
[17:44:52.254]                 common <- intersect(names, old_names)
[17:44:52.254]                 added <- setdiff(names, old_names)
[17:44:52.254]                 removed <- setdiff(old_names, names)
[17:44:52.254]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.254]                   envs[common]]
[17:44:52.254]                 NAMES <- toupper(changed)
[17:44:52.254]                 args <- list()
[17:44:52.254]                 for (kk in seq_along(NAMES)) {
[17:44:52.254]                   name <- changed[[kk]]
[17:44:52.254]                   NAME <- NAMES[[kk]]
[17:44:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.254]                     next
[17:44:52.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.254]                 }
[17:44:52.254]                 NAMES <- toupper(added)
[17:44:52.254]                 for (kk in seq_along(NAMES)) {
[17:44:52.254]                   name <- added[[kk]]
[17:44:52.254]                   NAME <- NAMES[[kk]]
[17:44:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.254]                     next
[17:44:52.254]                   args[[name]] <- ""
[17:44:52.254]                 }
[17:44:52.254]                 NAMES <- toupper(removed)
[17:44:52.254]                 for (kk in seq_along(NAMES)) {
[17:44:52.254]                   name <- removed[[kk]]
[17:44:52.254]                   NAME <- NAMES[[kk]]
[17:44:52.254]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.254]                     next
[17:44:52.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.254]                 }
[17:44:52.254]                 if (length(args) > 0) 
[17:44:52.254]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.254]             }
[17:44:52.254]             else {
[17:44:52.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.254]             }
[17:44:52.254]             {
[17:44:52.254]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.254]                   0L) {
[17:44:52.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.254]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.254]                   base::options(opts)
[17:44:52.254]                 }
[17:44:52.254]                 {
[17:44:52.254]                   {
[17:44:52.254]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.254]                     NULL
[17:44:52.254]                   }
[17:44:52.254]                   options(future.plan = NULL)
[17:44:52.254]                   if (is.na(NA_character_)) 
[17:44:52.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.254]                     .init = FALSE)
[17:44:52.254]                 }
[17:44:52.254]             }
[17:44:52.254]         }
[17:44:52.254]     })
[17:44:52.254]     if (TRUE) {
[17:44:52.254]         base::sink(type = "output", split = FALSE)
[17:44:52.254]         if (TRUE) {
[17:44:52.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.254]         }
[17:44:52.254]         else {
[17:44:52.254]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.254]         }
[17:44:52.254]         base::close(...future.stdout)
[17:44:52.254]         ...future.stdout <- NULL
[17:44:52.254]     }
[17:44:52.254]     ...future.result$conditions <- ...future.conditions
[17:44:52.254]     ...future.result$finished <- base::Sys.time()
[17:44:52.254]     ...future.result
[17:44:52.254] }
[17:44:52.257] Exporting 5 global objects (2.07 KiB) to cluster node #1 ...
[17:44:52.257] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ...
[17:44:52.258] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #1 ... DONE
[17:44:52.258] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:52.258] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.258] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ...
[17:44:52.258] Exporting ‘...future.elements_ii’ (704 bytes) to cluster node #1 ... DONE
[17:44:52.259] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:52.259] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.259] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:52.259] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.259] Exporting 5 global objects (2.07 KiB) to cluster node #1 ... DONE
[17:44:52.260] MultisessionFuture started
[17:44:52.260] - Launch lazy future ... done
[17:44:52.260] run() for ‘MultisessionFuture’ ... done
[17:44:52.260] Created future:
[17:44:52.260] MultisessionFuture:
[17:44:52.260] Label: ‘future_Map-1’
[17:44:52.260] Expression:
[17:44:52.260] {
[17:44:52.260]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.260]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.260]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.260]         on.exit(options(oopts), add = TRUE)
[17:44:52.260]     }
[17:44:52.260]     {
[17:44:52.260]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.260]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.260]         do.call(mapply, args = args)
[17:44:52.260]     }
[17:44:52.260] }
[17:44:52.260] Lazy evaluation: FALSE
[17:44:52.260] Asynchronous evaluation: TRUE
[17:44:52.260] Local evaluation: TRUE
[17:44:52.260] Environment: R_GlobalEnv
[17:44:52.260] Capture standard output: TRUE
[17:44:52.260] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.260] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 704 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.260] Packages: 1 packages (‘stats’)
[17:44:52.260] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.260] Resolved: FALSE
[17:44:52.260] Value: <not collected>
[17:44:52.260] Conditions captured: <none>
[17:44:52.260] Early signaling: FALSE
[17:44:52.260] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.260] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.272] Chunk #1 of 2 ... DONE
[17:44:52.272] Chunk #2 of 2 ...
[17:44:52.272]  - Finding globals in '...' for chunk #2 ...
[17:44:52.272] getGlobalsAndPackages() ...
[17:44:52.272] Searching for globals...
[17:44:52.273] 
[17:44:52.273] Searching for globals ... DONE
[17:44:52.273] - globals: [0] <none>
[17:44:52.273] getGlobalsAndPackages() ... DONE
[17:44:52.273]    + additional globals found: [n=0] 
[17:44:52.273]    + additional namespaces needed: [n=0] 
[17:44:52.273]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:52.273]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.273]  - seeds: <none>
[17:44:52.273]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.274] getGlobalsAndPackages() ...
[17:44:52.274] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.274] Resolving globals: FALSE
[17:44:52.274] The total size of the 5 globals is 2.41 KiB (2472 bytes)
[17:44:52.275] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 2.41 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.38 KiB of class ‘function’), ‘...future.elements_ii’ (1.03 KiB of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.275] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.275] - packages: [1] ‘stats’
[17:44:52.275] getGlobalsAndPackages() ... DONE
[17:44:52.275] run() for ‘Future’ ...
[17:44:52.275] - state: ‘created’
[17:44:52.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.290]   - Field: ‘node’
[17:44:52.291]   - Field: ‘label’
[17:44:52.291]   - Field: ‘local’
[17:44:52.291]   - Field: ‘owner’
[17:44:52.291]   - Field: ‘envir’
[17:44:52.291]   - Field: ‘workers’
[17:44:52.291]   - Field: ‘packages’
[17:44:52.291]   - Field: ‘gc’
[17:44:52.291]   - Field: ‘conditions’
[17:44:52.291]   - Field: ‘persistent’
[17:44:52.291]   - Field: ‘expr’
[17:44:52.291]   - Field: ‘uuid’
[17:44:52.292]   - Field: ‘seed’
[17:44:52.292]   - Field: ‘version’
[17:44:52.292]   - Field: ‘result’
[17:44:52.292]   - Field: ‘asynchronous’
[17:44:52.292]   - Field: ‘calls’
[17:44:52.292]   - Field: ‘globals’
[17:44:52.292]   - Field: ‘stdout’
[17:44:52.292]   - Field: ‘earlySignal’
[17:44:52.292]   - Field: ‘lazy’
[17:44:52.292]   - Field: ‘state’
[17:44:52.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.293] - Launch lazy future ...
[17:44:52.293] Packages needed by the future expression (n = 1): ‘stats’
[17:44:52.293] Packages needed by future strategies (n = 0): <none>
[17:44:52.293] {
[17:44:52.293]     {
[17:44:52.293]         {
[17:44:52.293]             ...future.startTime <- base::Sys.time()
[17:44:52.293]             {
[17:44:52.293]                 {
[17:44:52.293]                   {
[17:44:52.293]                     {
[17:44:52.293]                       {
[17:44:52.293]                         base::local({
[17:44:52.293]                           has_future <- base::requireNamespace("future", 
[17:44:52.293]                             quietly = TRUE)
[17:44:52.293]                           if (has_future) {
[17:44:52.293]                             ns <- base::getNamespace("future")
[17:44:52.293]                             version <- ns[[".package"]][["version"]]
[17:44:52.293]                             if (is.null(version)) 
[17:44:52.293]                               version <- utils::packageVersion("future")
[17:44:52.293]                           }
[17:44:52.293]                           else {
[17:44:52.293]                             version <- NULL
[17:44:52.293]                           }
[17:44:52.293]                           if (!has_future || version < "1.8.0") {
[17:44:52.293]                             info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.293]                               "", base::R.version$version.string), 
[17:44:52.293]                               platform = base::sprintf("%s (%s-bit)", 
[17:44:52.293]                                 base::R.version$platform, 8 * 
[17:44:52.293]                                   base::.Machine$sizeof.pointer), 
[17:44:52.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.293]                                 "release", "version")], collapse = " "), 
[17:44:52.293]                               hostname = base::Sys.info()[["nodename"]])
[17:44:52.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.293]                               info)
[17:44:52.293]                             info <- base::paste(info, collapse = "; ")
[17:44:52.293]                             if (!has_future) {
[17:44:52.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.293]                                 info)
[17:44:52.293]                             }
[17:44:52.293]                             else {
[17:44:52.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.293]                                 info, version)
[17:44:52.293]                             }
[17:44:52.293]                             base::stop(msg)
[17:44:52.293]                           }
[17:44:52.293]                         })
[17:44:52.293]                       }
[17:44:52.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.293]                       base::options(mc.cores = 1L)
[17:44:52.293]                     }
[17:44:52.293]                     base::local({
[17:44:52.293]                       for (pkg in "stats") {
[17:44:52.293]                         base::loadNamespace(pkg)
[17:44:52.293]                         base::library(pkg, character.only = TRUE)
[17:44:52.293]                       }
[17:44:52.293]                     })
[17:44:52.293]                   }
[17:44:52.293]                   ...future.strategy.old <- future::plan("list")
[17:44:52.293]                   options(future.plan = NULL)
[17:44:52.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.293]                 }
[17:44:52.293]                 ...future.workdir <- getwd()
[17:44:52.293]             }
[17:44:52.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.293]         }
[17:44:52.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.293]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.293]             base::names(...future.oldOptions))
[17:44:52.293]     }
[17:44:52.293]     if (FALSE) {
[17:44:52.293]     }
[17:44:52.293]     else {
[17:44:52.293]         if (TRUE) {
[17:44:52.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.293]                 open = "w")
[17:44:52.293]         }
[17:44:52.293]         else {
[17:44:52.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.293]         }
[17:44:52.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.293]             base::sink(type = "output", split = FALSE)
[17:44:52.293]             base::close(...future.stdout)
[17:44:52.293]         }, add = TRUE)
[17:44:52.293]     }
[17:44:52.293]     ...future.frame <- base::sys.nframe()
[17:44:52.293]     ...future.conditions <- base::list()
[17:44:52.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.293]     if (FALSE) {
[17:44:52.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.293]     }
[17:44:52.293]     ...future.result <- base::tryCatch({
[17:44:52.293]         base::withCallingHandlers({
[17:44:52.293]             ...future.value <- base::withVisible(base::local({
[17:44:52.293]                 ...future.makeSendCondition <- base::local({
[17:44:52.293]                   sendCondition <- NULL
[17:44:52.293]                   function(frame = 1L) {
[17:44:52.293]                     if (is.function(sendCondition)) 
[17:44:52.293]                       return(sendCondition)
[17:44:52.293]                     ns <- getNamespace("parallel")
[17:44:52.293]                     if (exists("sendData", mode = "function", 
[17:44:52.293]                       envir = ns)) {
[17:44:52.293]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.293]                         envir = ns)
[17:44:52.293]                       envir <- sys.frame(frame)
[17:44:52.293]                       master <- NULL
[17:44:52.293]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.293]                         !identical(envir, emptyenv())) {
[17:44:52.293]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.293]                           inherits = FALSE)) {
[17:44:52.293]                           master <- get("master", mode = "list", 
[17:44:52.293]                             envir = envir, inherits = FALSE)
[17:44:52.293]                           if (inherits(master, c("SOCKnode", 
[17:44:52.293]                             "SOCK0node"))) {
[17:44:52.293]                             sendCondition <<- function(cond) {
[17:44:52.293]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.293]                                 success = TRUE)
[17:44:52.293]                               parallel_sendData(master, data)
[17:44:52.293]                             }
[17:44:52.293]                             return(sendCondition)
[17:44:52.293]                           }
[17:44:52.293]                         }
[17:44:52.293]                         frame <- frame + 1L
[17:44:52.293]                         envir <- sys.frame(frame)
[17:44:52.293]                       }
[17:44:52.293]                     }
[17:44:52.293]                     sendCondition <<- function(cond) NULL
[17:44:52.293]                   }
[17:44:52.293]                 })
[17:44:52.293]                 withCallingHandlers({
[17:44:52.293]                   {
[17:44:52.293]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.293]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.293]                       ...future.globals.maxSize)) {
[17:44:52.293]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.293]                       on.exit(options(oopts), add = TRUE)
[17:44:52.293]                     }
[17:44:52.293]                     {
[17:44:52.293]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.293]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.293]                         USE.NAMES = FALSE)
[17:44:52.293]                       do.call(mapply, args = args)
[17:44:52.293]                     }
[17:44:52.293]                   }
[17:44:52.293]                 }, immediateCondition = function(cond) {
[17:44:52.293]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.293]                   sendCondition(cond)
[17:44:52.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.293]                   {
[17:44:52.293]                     inherits <- base::inherits
[17:44:52.293]                     invokeRestart <- base::invokeRestart
[17:44:52.293]                     is.null <- base::is.null
[17:44:52.293]                     muffled <- FALSE
[17:44:52.293]                     if (inherits(cond, "message")) {
[17:44:52.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.293]                       if (muffled) 
[17:44:52.293]                         invokeRestart("muffleMessage")
[17:44:52.293]                     }
[17:44:52.293]                     else if (inherits(cond, "warning")) {
[17:44:52.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.293]                       if (muffled) 
[17:44:52.293]                         invokeRestart("muffleWarning")
[17:44:52.293]                     }
[17:44:52.293]                     else if (inherits(cond, "condition")) {
[17:44:52.293]                       if (!is.null(pattern)) {
[17:44:52.293]                         computeRestarts <- base::computeRestarts
[17:44:52.293]                         grepl <- base::grepl
[17:44:52.293]                         restarts <- computeRestarts(cond)
[17:44:52.293]                         for (restart in restarts) {
[17:44:52.293]                           name <- restart$name
[17:44:52.293]                           if (is.null(name)) 
[17:44:52.293]                             next
[17:44:52.293]                           if (!grepl(pattern, name)) 
[17:44:52.293]                             next
[17:44:52.293]                           invokeRestart(restart)
[17:44:52.293]                           muffled <- TRUE
[17:44:52.293]                           break
[17:44:52.293]                         }
[17:44:52.293]                       }
[17:44:52.293]                     }
[17:44:52.293]                     invisible(muffled)
[17:44:52.293]                   }
[17:44:52.293]                   muffleCondition(cond)
[17:44:52.293]                 })
[17:44:52.293]             }))
[17:44:52.293]             future::FutureResult(value = ...future.value$value, 
[17:44:52.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.293]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.293]                     ...future.globalenv.names))
[17:44:52.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.293]         }, condition = base::local({
[17:44:52.293]             c <- base::c
[17:44:52.293]             inherits <- base::inherits
[17:44:52.293]             invokeRestart <- base::invokeRestart
[17:44:52.293]             length <- base::length
[17:44:52.293]             list <- base::list
[17:44:52.293]             seq.int <- base::seq.int
[17:44:52.293]             signalCondition <- base::signalCondition
[17:44:52.293]             sys.calls <- base::sys.calls
[17:44:52.293]             `[[` <- base::`[[`
[17:44:52.293]             `+` <- base::`+`
[17:44:52.293]             `<<-` <- base::`<<-`
[17:44:52.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.293]                   3L)]
[17:44:52.293]             }
[17:44:52.293]             function(cond) {
[17:44:52.293]                 is_error <- inherits(cond, "error")
[17:44:52.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.293]                   NULL)
[17:44:52.293]                 if (is_error) {
[17:44:52.293]                   sessionInformation <- function() {
[17:44:52.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.293]                       search = base::search(), system = base::Sys.info())
[17:44:52.293]                   }
[17:44:52.293]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.293]                     cond$call), session = sessionInformation(), 
[17:44:52.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.293]                   signalCondition(cond)
[17:44:52.293]                 }
[17:44:52.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.293]                 "immediateCondition"))) {
[17:44:52.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.293]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.293]                   if (TRUE && !signal) {
[17:44:52.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.293]                     {
[17:44:52.293]                       inherits <- base::inherits
[17:44:52.293]                       invokeRestart <- base::invokeRestart
[17:44:52.293]                       is.null <- base::is.null
[17:44:52.293]                       muffled <- FALSE
[17:44:52.293]                       if (inherits(cond, "message")) {
[17:44:52.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.293]                         if (muffled) 
[17:44:52.293]                           invokeRestart("muffleMessage")
[17:44:52.293]                       }
[17:44:52.293]                       else if (inherits(cond, "warning")) {
[17:44:52.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.293]                         if (muffled) 
[17:44:52.293]                           invokeRestart("muffleWarning")
[17:44:52.293]                       }
[17:44:52.293]                       else if (inherits(cond, "condition")) {
[17:44:52.293]                         if (!is.null(pattern)) {
[17:44:52.293]                           computeRestarts <- base::computeRestarts
[17:44:52.293]                           grepl <- base::grepl
[17:44:52.293]                           restarts <- computeRestarts(cond)
[17:44:52.293]                           for (restart in restarts) {
[17:44:52.293]                             name <- restart$name
[17:44:52.293]                             if (is.null(name)) 
[17:44:52.293]                               next
[17:44:52.293]                             if (!grepl(pattern, name)) 
[17:44:52.293]                               next
[17:44:52.293]                             invokeRestart(restart)
[17:44:52.293]                             muffled <- TRUE
[17:44:52.293]                             break
[17:44:52.293]                           }
[17:44:52.293]                         }
[17:44:52.293]                       }
[17:44:52.293]                       invisible(muffled)
[17:44:52.293]                     }
[17:44:52.293]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.293]                   }
[17:44:52.293]                 }
[17:44:52.293]                 else {
[17:44:52.293]                   if (TRUE) {
[17:44:52.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.293]                     {
[17:44:52.293]                       inherits <- base::inherits
[17:44:52.293]                       invokeRestart <- base::invokeRestart
[17:44:52.293]                       is.null <- base::is.null
[17:44:52.293]                       muffled <- FALSE
[17:44:52.293]                       if (inherits(cond, "message")) {
[17:44:52.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.293]                         if (muffled) 
[17:44:52.293]                           invokeRestart("muffleMessage")
[17:44:52.293]                       }
[17:44:52.293]                       else if (inherits(cond, "warning")) {
[17:44:52.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.293]                         if (muffled) 
[17:44:52.293]                           invokeRestart("muffleWarning")
[17:44:52.293]                       }
[17:44:52.293]                       else if (inherits(cond, "condition")) {
[17:44:52.293]                         if (!is.null(pattern)) {
[17:44:52.293]                           computeRestarts <- base::computeRestarts
[17:44:52.293]                           grepl <- base::grepl
[17:44:52.293]                           restarts <- computeRestarts(cond)
[17:44:52.293]                           for (restart in restarts) {
[17:44:52.293]                             name <- restart$name
[17:44:52.293]                             if (is.null(name)) 
[17:44:52.293]                               next
[17:44:52.293]                             if (!grepl(pattern, name)) 
[17:44:52.293]                               next
[17:44:52.293]                             invokeRestart(restart)
[17:44:52.293]                             muffled <- TRUE
[17:44:52.293]                             break
[17:44:52.293]                           }
[17:44:52.293]                         }
[17:44:52.293]                       }
[17:44:52.293]                       invisible(muffled)
[17:44:52.293]                     }
[17:44:52.293]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.293]                   }
[17:44:52.293]                 }
[17:44:52.293]             }
[17:44:52.293]         }))
[17:44:52.293]     }, error = function(ex) {
[17:44:52.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.293]                 ...future.rng), started = ...future.startTime, 
[17:44:52.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.293]             version = "1.8"), class = "FutureResult")
[17:44:52.293]     }, finally = {
[17:44:52.293]         if (!identical(...future.workdir, getwd())) 
[17:44:52.293]             setwd(...future.workdir)
[17:44:52.293]         {
[17:44:52.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.293]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.293]             }
[17:44:52.293]             base::options(...future.oldOptions)
[17:44:52.293]             if (.Platform$OS.type == "windows") {
[17:44:52.293]                 old_names <- names(...future.oldEnvVars)
[17:44:52.293]                 envs <- base::Sys.getenv()
[17:44:52.293]                 names <- names(envs)
[17:44:52.293]                 common <- intersect(names, old_names)
[17:44:52.293]                 added <- setdiff(names, old_names)
[17:44:52.293]                 removed <- setdiff(old_names, names)
[17:44:52.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.293]                   envs[common]]
[17:44:52.293]                 NAMES <- toupper(changed)
[17:44:52.293]                 args <- list()
[17:44:52.293]                 for (kk in seq_along(NAMES)) {
[17:44:52.293]                   name <- changed[[kk]]
[17:44:52.293]                   NAME <- NAMES[[kk]]
[17:44:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.293]                     next
[17:44:52.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.293]                 }
[17:44:52.293]                 NAMES <- toupper(added)
[17:44:52.293]                 for (kk in seq_along(NAMES)) {
[17:44:52.293]                   name <- added[[kk]]
[17:44:52.293]                   NAME <- NAMES[[kk]]
[17:44:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.293]                     next
[17:44:52.293]                   args[[name]] <- ""
[17:44:52.293]                 }
[17:44:52.293]                 NAMES <- toupper(removed)
[17:44:52.293]                 for (kk in seq_along(NAMES)) {
[17:44:52.293]                   name <- removed[[kk]]
[17:44:52.293]                   NAME <- NAMES[[kk]]
[17:44:52.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.293]                     next
[17:44:52.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.293]                 }
[17:44:52.293]                 if (length(args) > 0) 
[17:44:52.293]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.293]             }
[17:44:52.293]             else {
[17:44:52.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.293]             }
[17:44:52.293]             {
[17:44:52.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.293]                   0L) {
[17:44:52.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.293]                   base::options(opts)
[17:44:52.293]                 }
[17:44:52.293]                 {
[17:44:52.293]                   {
[17:44:52.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.293]                     NULL
[17:44:52.293]                   }
[17:44:52.293]                   options(future.plan = NULL)
[17:44:52.293]                   if (is.na(NA_character_)) 
[17:44:52.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.293]                     .init = FALSE)
[17:44:52.293]                 }
[17:44:52.293]             }
[17:44:52.293]         }
[17:44:52.293]     })
[17:44:52.293]     if (TRUE) {
[17:44:52.293]         base::sink(type = "output", split = FALSE)
[17:44:52.293]         if (TRUE) {
[17:44:52.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.293]         }
[17:44:52.293]         else {
[17:44:52.293]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.293]         }
[17:44:52.293]         base::close(...future.stdout)
[17:44:52.293]         ...future.stdout <- NULL
[17:44:52.293]     }
[17:44:52.293]     ...future.result$conditions <- ...future.conditions
[17:44:52.293]     ...future.result$finished <- base::Sys.time()
[17:44:52.293]     ...future.result
[17:44:52.293] }
[17:44:52.296] Exporting 5 global objects (2.41 KiB) to cluster node #2 ...
[17:44:52.296] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ...
[17:44:52.297] Exporting ‘...future.FUN’ (1.38 KiB) to cluster node #2 ... DONE
[17:44:52.297] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:52.297] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.297] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ...
[17:44:52.298] Exporting ‘...future.elements_ii’ (1.03 KiB) to cluster node #2 ... DONE
[17:44:52.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:52.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.298] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:52.299] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.299] Exporting 5 global objects (2.41 KiB) to cluster node #2 ... DONE
[17:44:52.299] MultisessionFuture started
[17:44:52.299] - Launch lazy future ... done
[17:44:52.300] run() for ‘MultisessionFuture’ ... done
[17:44:52.300] Created future:
[17:44:52.300] MultisessionFuture:
[17:44:52.300] Label: ‘future_Map-2’
[17:44:52.300] Expression:
[17:44:52.300] {
[17:44:52.300]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.300]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.300]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.300]         on.exit(options(oopts), add = TRUE)
[17:44:52.300]     }
[17:44:52.300]     {
[17:44:52.300]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.300]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.300]         do.call(mapply, args = args)
[17:44:52.300]     }
[17:44:52.300] }
[17:44:52.300] Lazy evaluation: FALSE
[17:44:52.300] Asynchronous evaluation: TRUE
[17:44:52.300] Local evaluation: TRUE
[17:44:52.300] Environment: R_GlobalEnv
[17:44:52.300] Capture standard output: TRUE
[17:44:52.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.300] Globals: 5 objects totaling 2.41 KiB (function ‘...future.FUN’ of 1.38 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.300] Packages: 1 packages (‘stats’)
[17:44:52.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.300] Resolved: FALSE
[17:44:52.300] Value: <not collected>
[17:44:52.300] Conditions captured: <none>
[17:44:52.300] Early signaling: FALSE
[17:44:52.300] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.300] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.311] Chunk #2 of 2 ... DONE
[17:44:52.311] Launching 2 futures (chunks) ... DONE
[17:44:52.312] Resolving 2 futures (chunks) ...
[17:44:52.312] resolve() on list ...
[17:44:52.312]  recursive: 0
[17:44:52.312]  length: 2
[17:44:52.312] 
[17:44:52.312] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.313] - Validating connection of MultisessionFuture
[17:44:52.313] - received message: FutureResult
[17:44:52.313] - Received FutureResult
[17:44:52.313] - Erased future from FutureRegistry
[17:44:52.313] result() for ClusterFuture ...
[17:44:52.313] - result already collected: FutureResult
[17:44:52.313] result() for ClusterFuture ... done
[17:44:52.313] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.313] Future #1
[17:44:52.313] result() for ClusterFuture ...
[17:44:52.314] - result already collected: FutureResult
[17:44:52.314] result() for ClusterFuture ... done
[17:44:52.314] result() for ClusterFuture ...
[17:44:52.314] - result already collected: FutureResult
[17:44:52.314] result() for ClusterFuture ... done
[17:44:52.314] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:52.314] - nx: 2
[17:44:52.314] - relay: TRUE
[17:44:52.314] - stdout: TRUE
[17:44:52.314] - signal: TRUE
[17:44:52.314] - resignal: FALSE
[17:44:52.314] - force: TRUE
[17:44:52.315] - relayed: [n=2] FALSE, FALSE
[17:44:52.315] - queued futures: [n=2] FALSE, FALSE
[17:44:52.315]  - until=1
[17:44:52.315]  - relaying element #1
[17:44:52.315] result() for ClusterFuture ...
[17:44:52.315] - result already collected: FutureResult
[17:44:52.315] result() for ClusterFuture ... done
[17:44:52.315] result() for ClusterFuture ...
[17:44:52.315] - result already collected: FutureResult
[17:44:52.315] result() for ClusterFuture ... done
[17:44:52.316] result() for ClusterFuture ...
[17:44:52.316] - result already collected: FutureResult
[17:44:52.316] result() for ClusterFuture ... done
[17:44:52.316] result() for ClusterFuture ...
[17:44:52.316] - result already collected: FutureResult
[17:44:52.316] result() for ClusterFuture ... done
[17:44:52.316] - relayed: [n=2] TRUE, FALSE
[17:44:52.316] - queued futures: [n=2] TRUE, FALSE
[17:44:52.316] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:52.316]  length: 1 (resolved future 1)
[17:44:52.341] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.341] - Validating connection of MultisessionFuture
[17:44:52.341] - received message: FutureResult
[17:44:52.342] - Received FutureResult
[17:44:52.342] - Erased future from FutureRegistry
[17:44:52.342] result() for ClusterFuture ...
[17:44:52.342] - result already collected: FutureResult
[17:44:52.342] result() for ClusterFuture ... done
[17:44:52.342] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.342] Future #2
[17:44:52.342] result() for ClusterFuture ...
[17:44:52.342] - result already collected: FutureResult
[17:44:52.342] result() for ClusterFuture ... done
[17:44:52.342] result() for ClusterFuture ...
[17:44:52.343] - result already collected: FutureResult
[17:44:52.343] result() for ClusterFuture ... done
[17:44:52.343] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:52.343] - nx: 2
[17:44:52.343] - relay: TRUE
[17:44:52.343] - stdout: TRUE
[17:44:52.343] - signal: TRUE
[17:44:52.343] - resignal: FALSE
[17:44:52.343] - force: TRUE
[17:44:52.343] - relayed: [n=2] TRUE, FALSE
[17:44:52.343] - queued futures: [n=2] TRUE, FALSE
[17:44:52.344]  - until=2
[17:44:52.344]  - relaying element #2
[17:44:52.344] result() for ClusterFuture ...
[17:44:52.344] - result already collected: FutureResult
[17:44:52.344] result() for ClusterFuture ... done
[17:44:52.344] result() for ClusterFuture ...
[17:44:52.344] - result already collected: FutureResult
[17:44:52.344] result() for ClusterFuture ... done
[17:44:52.344] result() for ClusterFuture ...
[17:44:52.344] - result already collected: FutureResult
[17:44:52.345] result() for ClusterFuture ... done
[17:44:52.345] result() for ClusterFuture ...
[17:44:52.345] - result already collected: FutureResult
[17:44:52.345] result() for ClusterFuture ... done
[17:44:52.345] - relayed: [n=2] TRUE, TRUE
[17:44:52.345] - queued futures: [n=2] TRUE, TRUE
[17:44:52.345] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:52.345]  length: 0 (resolved future 2)
[17:44:52.345] Relaying remaining futures
[17:44:52.345] signalConditionsASAP(NULL, pos=0) ...
[17:44:52.345] - nx: 2
[17:44:52.345] - relay: TRUE
[17:44:52.346] - stdout: TRUE
[17:44:52.346] - signal: TRUE
[17:44:52.346] - resignal: FALSE
[17:44:52.346] - force: TRUE
[17:44:52.346] - relayed: [n=2] TRUE, TRUE
[17:44:52.346] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:52.346] - relayed: [n=2] TRUE, TRUE
[17:44:52.346] - queued futures: [n=2] TRUE, TRUE
[17:44:52.346] signalConditionsASAP(NULL, pos=0) ... done
[17:44:52.346] resolve() on list ... DONE
[17:44:52.346] result() for ClusterFuture ...
[17:44:52.347] - result already collected: FutureResult
[17:44:52.347] result() for ClusterFuture ... done
[17:44:52.347] result() for ClusterFuture ...
[17:44:52.347] - result already collected: FutureResult
[17:44:52.347] result() for ClusterFuture ... done
[17:44:52.347] result() for ClusterFuture ...
[17:44:52.347] - result already collected: FutureResult
[17:44:52.347] result() for ClusterFuture ... done
[17:44:52.347] result() for ClusterFuture ...
[17:44:52.347] - result already collected: FutureResult
[17:44:52.347] result() for ClusterFuture ... done
[17:44:52.348]  - Number of value chunks collected: 2
[17:44:52.348] Resolving 2 futures (chunks) ... DONE
[17:44:52.348] Reducing values from 2 chunks ...
[17:44:52.348]  - Number of values collected after concatenation: 5
[17:44:52.348]  - Number of values expected: 5
[17:44:52.348] Reducing values from 2 chunks ... DONE
[17:44:52.348] future_mapply() ... DONE
- future_mapply() - 'max-or-0-if' recycling rule ...
[17:44:52.350] future_mapply() ...
[17:44:52.354] Number of chunks: 2
[17:44:52.354] getGlobalsAndPackagesXApply() ...
[17:44:52.354]  - future.globals: TRUE
[17:44:52.354] getGlobalsAndPackages() ...
[17:44:52.354] Searching for globals...
[17:44:52.355] - globals found: [1] ‘FUN’
[17:44:52.355] Searching for globals ... DONE
[17:44:52.355] Resolving globals: FALSE
[17:44:52.355] The total size of the 1 globals is 56 bytes (56 bytes)
[17:44:52.356] The total size of the 1 globals exported for future expression (‘FUN()’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (56 bytes of class ‘function’)
[17:44:52.356] - globals: [1] ‘FUN’
[17:44:52.356] 
[17:44:52.356] getGlobalsAndPackages() ... DONE
[17:44:52.356]  - globals found/used: [n=1] ‘FUN’
[17:44:52.356]  - needed namespaces: [n=0] 
[17:44:52.359] Finding globals ... DONE
[17:44:52.359] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:52.359] List of 2
[17:44:52.359]  $ ...future.FUN:function (e1, e2)  
[17:44:52.359]  $ MoreArgs     : NULL
[17:44:52.359]  - attr(*, "where")=List of 2
[17:44:52.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:52.359]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:52.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:52.359]  - attr(*, "resolved")= logi FALSE
[17:44:52.359]  - attr(*, "total_size")= num NA
[17:44:52.361] Packages to be attached in all futures: [n=0] 
[17:44:52.362] getGlobalsAndPackagesXApply() ... DONE
[17:44:52.362] Number of futures (= number of chunks): 2
[17:44:52.362] Launching 2 futures (chunks) ...
[17:44:52.362] Chunk #1 of 2 ...
[17:44:52.362]  - Finding globals in '...' for chunk #1 ...
[17:44:52.362] getGlobalsAndPackages() ...
[17:44:52.362] Searching for globals...
[17:44:52.363] 
[17:44:52.363] Searching for globals ... DONE
[17:44:52.363] - globals: [0] <none>
[17:44:52.363] getGlobalsAndPackages() ... DONE
[17:44:52.363]    + additional globals found: [n=0] 
[17:44:52.363]    + additional namespaces needed: [n=0] 
[17:44:52.363]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:52.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.363]  - seeds: <none>
[17:44:52.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.364] getGlobalsAndPackages() ...
[17:44:52.364] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.364] Resolving globals: FALSE
[17:44:52.364] The total size of the 5 globals is 168 bytes (168 bytes)
[17:44:52.365] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 168 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (112 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.365] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.365] 
[17:44:52.365] getGlobalsAndPackages() ... DONE
[17:44:52.365] run() for ‘Future’ ...
[17:44:52.365] - state: ‘created’
[17:44:52.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.379]   - Field: ‘node’
[17:44:52.379]   - Field: ‘label’
[17:44:52.379]   - Field: ‘local’
[17:44:52.379]   - Field: ‘owner’
[17:44:52.380]   - Field: ‘envir’
[17:44:52.380]   - Field: ‘workers’
[17:44:52.380]   - Field: ‘packages’
[17:44:52.380]   - Field: ‘gc’
[17:44:52.380]   - Field: ‘conditions’
[17:44:52.380]   - Field: ‘persistent’
[17:44:52.380]   - Field: ‘expr’
[17:44:52.380]   - Field: ‘uuid’
[17:44:52.380]   - Field: ‘seed’
[17:44:52.380]   - Field: ‘version’
[17:44:52.380]   - Field: ‘result’
[17:44:52.381]   - Field: ‘asynchronous’
[17:44:52.381]   - Field: ‘calls’
[17:44:52.381]   - Field: ‘globals’
[17:44:52.381]   - Field: ‘stdout’
[17:44:52.381]   - Field: ‘earlySignal’
[17:44:52.381]   - Field: ‘lazy’
[17:44:52.381]   - Field: ‘state’
[17:44:52.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.381] - Launch lazy future ...
[17:44:52.381] Packages needed by the future expression (n = 0): <none>
[17:44:52.382] Packages needed by future strategies (n = 0): <none>
[17:44:52.382] {
[17:44:52.382]     {
[17:44:52.382]         {
[17:44:52.382]             ...future.startTime <- base::Sys.time()
[17:44:52.382]             {
[17:44:52.382]                 {
[17:44:52.382]                   {
[17:44:52.382]                     {
[17:44:52.382]                       base::local({
[17:44:52.382]                         has_future <- base::requireNamespace("future", 
[17:44:52.382]                           quietly = TRUE)
[17:44:52.382]                         if (has_future) {
[17:44:52.382]                           ns <- base::getNamespace("future")
[17:44:52.382]                           version <- ns[[".package"]][["version"]]
[17:44:52.382]                           if (is.null(version)) 
[17:44:52.382]                             version <- utils::packageVersion("future")
[17:44:52.382]                         }
[17:44:52.382]                         else {
[17:44:52.382]                           version <- NULL
[17:44:52.382]                         }
[17:44:52.382]                         if (!has_future || version < "1.8.0") {
[17:44:52.382]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.382]                             "", base::R.version$version.string), 
[17:44:52.382]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:52.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:52.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.382]                               "release", "version")], collapse = " "), 
[17:44:52.382]                             hostname = base::Sys.info()[["nodename"]])
[17:44:52.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.382]                             info)
[17:44:52.382]                           info <- base::paste(info, collapse = "; ")
[17:44:52.382]                           if (!has_future) {
[17:44:52.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.382]                               info)
[17:44:52.382]                           }
[17:44:52.382]                           else {
[17:44:52.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.382]                               info, version)
[17:44:52.382]                           }
[17:44:52.382]                           base::stop(msg)
[17:44:52.382]                         }
[17:44:52.382]                       })
[17:44:52.382]                     }
[17:44:52.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.382]                     base::options(mc.cores = 1L)
[17:44:52.382]                   }
[17:44:52.382]                   ...future.strategy.old <- future::plan("list")
[17:44:52.382]                   options(future.plan = NULL)
[17:44:52.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.382]                 }
[17:44:52.382]                 ...future.workdir <- getwd()
[17:44:52.382]             }
[17:44:52.382]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.382]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.382]         }
[17:44:52.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.382]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.382]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.382]             base::names(...future.oldOptions))
[17:44:52.382]     }
[17:44:52.382]     if (FALSE) {
[17:44:52.382]     }
[17:44:52.382]     else {
[17:44:52.382]         if (TRUE) {
[17:44:52.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.382]                 open = "w")
[17:44:52.382]         }
[17:44:52.382]         else {
[17:44:52.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.382]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.382]         }
[17:44:52.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.382]             base::sink(type = "output", split = FALSE)
[17:44:52.382]             base::close(...future.stdout)
[17:44:52.382]         }, add = TRUE)
[17:44:52.382]     }
[17:44:52.382]     ...future.frame <- base::sys.nframe()
[17:44:52.382]     ...future.conditions <- base::list()
[17:44:52.382]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.382]     if (FALSE) {
[17:44:52.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.382]     }
[17:44:52.382]     ...future.result <- base::tryCatch({
[17:44:52.382]         base::withCallingHandlers({
[17:44:52.382]             ...future.value <- base::withVisible(base::local({
[17:44:52.382]                 ...future.makeSendCondition <- base::local({
[17:44:52.382]                   sendCondition <- NULL
[17:44:52.382]                   function(frame = 1L) {
[17:44:52.382]                     if (is.function(sendCondition)) 
[17:44:52.382]                       return(sendCondition)
[17:44:52.382]                     ns <- getNamespace("parallel")
[17:44:52.382]                     if (exists("sendData", mode = "function", 
[17:44:52.382]                       envir = ns)) {
[17:44:52.382]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.382]                         envir = ns)
[17:44:52.382]                       envir <- sys.frame(frame)
[17:44:52.382]                       master <- NULL
[17:44:52.382]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.382]                         !identical(envir, emptyenv())) {
[17:44:52.382]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.382]                           inherits = FALSE)) {
[17:44:52.382]                           master <- get("master", mode = "list", 
[17:44:52.382]                             envir = envir, inherits = FALSE)
[17:44:52.382]                           if (inherits(master, c("SOCKnode", 
[17:44:52.382]                             "SOCK0node"))) {
[17:44:52.382]                             sendCondition <<- function(cond) {
[17:44:52.382]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.382]                                 success = TRUE)
[17:44:52.382]                               parallel_sendData(master, data)
[17:44:52.382]                             }
[17:44:52.382]                             return(sendCondition)
[17:44:52.382]                           }
[17:44:52.382]                         }
[17:44:52.382]                         frame <- frame + 1L
[17:44:52.382]                         envir <- sys.frame(frame)
[17:44:52.382]                       }
[17:44:52.382]                     }
[17:44:52.382]                     sendCondition <<- function(cond) NULL
[17:44:52.382]                   }
[17:44:52.382]                 })
[17:44:52.382]                 withCallingHandlers({
[17:44:52.382]                   {
[17:44:52.382]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.382]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.382]                       ...future.globals.maxSize)) {
[17:44:52.382]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.382]                       on.exit(options(oopts), add = TRUE)
[17:44:52.382]                     }
[17:44:52.382]                     {
[17:44:52.382]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.382]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.382]                         USE.NAMES = FALSE)
[17:44:52.382]                       do.call(mapply, args = args)
[17:44:52.382]                     }
[17:44:52.382]                   }
[17:44:52.382]                 }, immediateCondition = function(cond) {
[17:44:52.382]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.382]                   sendCondition(cond)
[17:44:52.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.382]                   {
[17:44:52.382]                     inherits <- base::inherits
[17:44:52.382]                     invokeRestart <- base::invokeRestart
[17:44:52.382]                     is.null <- base::is.null
[17:44:52.382]                     muffled <- FALSE
[17:44:52.382]                     if (inherits(cond, "message")) {
[17:44:52.382]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.382]                       if (muffled) 
[17:44:52.382]                         invokeRestart("muffleMessage")
[17:44:52.382]                     }
[17:44:52.382]                     else if (inherits(cond, "warning")) {
[17:44:52.382]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.382]                       if (muffled) 
[17:44:52.382]                         invokeRestart("muffleWarning")
[17:44:52.382]                     }
[17:44:52.382]                     else if (inherits(cond, "condition")) {
[17:44:52.382]                       if (!is.null(pattern)) {
[17:44:52.382]                         computeRestarts <- base::computeRestarts
[17:44:52.382]                         grepl <- base::grepl
[17:44:52.382]                         restarts <- computeRestarts(cond)
[17:44:52.382]                         for (restart in restarts) {
[17:44:52.382]                           name <- restart$name
[17:44:52.382]                           if (is.null(name)) 
[17:44:52.382]                             next
[17:44:52.382]                           if (!grepl(pattern, name)) 
[17:44:52.382]                             next
[17:44:52.382]                           invokeRestart(restart)
[17:44:52.382]                           muffled <- TRUE
[17:44:52.382]                           break
[17:44:52.382]                         }
[17:44:52.382]                       }
[17:44:52.382]                     }
[17:44:52.382]                     invisible(muffled)
[17:44:52.382]                   }
[17:44:52.382]                   muffleCondition(cond)
[17:44:52.382]                 })
[17:44:52.382]             }))
[17:44:52.382]             future::FutureResult(value = ...future.value$value, 
[17:44:52.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.382]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.382]                     ...future.globalenv.names))
[17:44:52.382]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.382]         }, condition = base::local({
[17:44:52.382]             c <- base::c
[17:44:52.382]             inherits <- base::inherits
[17:44:52.382]             invokeRestart <- base::invokeRestart
[17:44:52.382]             length <- base::length
[17:44:52.382]             list <- base::list
[17:44:52.382]             seq.int <- base::seq.int
[17:44:52.382]             signalCondition <- base::signalCondition
[17:44:52.382]             sys.calls <- base::sys.calls
[17:44:52.382]             `[[` <- base::`[[`
[17:44:52.382]             `+` <- base::`+`
[17:44:52.382]             `<<-` <- base::`<<-`
[17:44:52.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.382]                   3L)]
[17:44:52.382]             }
[17:44:52.382]             function(cond) {
[17:44:52.382]                 is_error <- inherits(cond, "error")
[17:44:52.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.382]                   NULL)
[17:44:52.382]                 if (is_error) {
[17:44:52.382]                   sessionInformation <- function() {
[17:44:52.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.382]                       search = base::search(), system = base::Sys.info())
[17:44:52.382]                   }
[17:44:52.382]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.382]                     cond$call), session = sessionInformation(), 
[17:44:52.382]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.382]                   signalCondition(cond)
[17:44:52.382]                 }
[17:44:52.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.382]                 "immediateCondition"))) {
[17:44:52.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.382]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.382]                   if (TRUE && !signal) {
[17:44:52.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.382]                     {
[17:44:52.382]                       inherits <- base::inherits
[17:44:52.382]                       invokeRestart <- base::invokeRestart
[17:44:52.382]                       is.null <- base::is.null
[17:44:52.382]                       muffled <- FALSE
[17:44:52.382]                       if (inherits(cond, "message")) {
[17:44:52.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.382]                         if (muffled) 
[17:44:52.382]                           invokeRestart("muffleMessage")
[17:44:52.382]                       }
[17:44:52.382]                       else if (inherits(cond, "warning")) {
[17:44:52.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.382]                         if (muffled) 
[17:44:52.382]                           invokeRestart("muffleWarning")
[17:44:52.382]                       }
[17:44:52.382]                       else if (inherits(cond, "condition")) {
[17:44:52.382]                         if (!is.null(pattern)) {
[17:44:52.382]                           computeRestarts <- base::computeRestarts
[17:44:52.382]                           grepl <- base::grepl
[17:44:52.382]                           restarts <- computeRestarts(cond)
[17:44:52.382]                           for (restart in restarts) {
[17:44:52.382]                             name <- restart$name
[17:44:52.382]                             if (is.null(name)) 
[17:44:52.382]                               next
[17:44:52.382]                             if (!grepl(pattern, name)) 
[17:44:52.382]                               next
[17:44:52.382]                             invokeRestart(restart)
[17:44:52.382]                             muffled <- TRUE
[17:44:52.382]                             break
[17:44:52.382]                           }
[17:44:52.382]                         }
[17:44:52.382]                       }
[17:44:52.382]                       invisible(muffled)
[17:44:52.382]                     }
[17:44:52.382]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.382]                   }
[17:44:52.382]                 }
[17:44:52.382]                 else {
[17:44:52.382]                   if (TRUE) {
[17:44:52.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.382]                     {
[17:44:52.382]                       inherits <- base::inherits
[17:44:52.382]                       invokeRestart <- base::invokeRestart
[17:44:52.382]                       is.null <- base::is.null
[17:44:52.382]                       muffled <- FALSE
[17:44:52.382]                       if (inherits(cond, "message")) {
[17:44:52.382]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.382]                         if (muffled) 
[17:44:52.382]                           invokeRestart("muffleMessage")
[17:44:52.382]                       }
[17:44:52.382]                       else if (inherits(cond, "warning")) {
[17:44:52.382]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.382]                         if (muffled) 
[17:44:52.382]                           invokeRestart("muffleWarning")
[17:44:52.382]                       }
[17:44:52.382]                       else if (inherits(cond, "condition")) {
[17:44:52.382]                         if (!is.null(pattern)) {
[17:44:52.382]                           computeRestarts <- base::computeRestarts
[17:44:52.382]                           grepl <- base::grepl
[17:44:52.382]                           restarts <- computeRestarts(cond)
[17:44:52.382]                           for (restart in restarts) {
[17:44:52.382]                             name <- restart$name
[17:44:52.382]                             if (is.null(name)) 
[17:44:52.382]                               next
[17:44:52.382]                             if (!grepl(pattern, name)) 
[17:44:52.382]                               next
[17:44:52.382]                             invokeRestart(restart)
[17:44:52.382]                             muffled <- TRUE
[17:44:52.382]                             break
[17:44:52.382]                           }
[17:44:52.382]                         }
[17:44:52.382]                       }
[17:44:52.382]                       invisible(muffled)
[17:44:52.382]                     }
[17:44:52.382]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.382]                   }
[17:44:52.382]                 }
[17:44:52.382]             }
[17:44:52.382]         }))
[17:44:52.382]     }, error = function(ex) {
[17:44:52.382]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.382]                 ...future.rng), started = ...future.startTime, 
[17:44:52.382]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.382]             version = "1.8"), class = "FutureResult")
[17:44:52.382]     }, finally = {
[17:44:52.382]         if (!identical(...future.workdir, getwd())) 
[17:44:52.382]             setwd(...future.workdir)
[17:44:52.382]         {
[17:44:52.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.382]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.382]             }
[17:44:52.382]             base::options(...future.oldOptions)
[17:44:52.382]             if (.Platform$OS.type == "windows") {
[17:44:52.382]                 old_names <- names(...future.oldEnvVars)
[17:44:52.382]                 envs <- base::Sys.getenv()
[17:44:52.382]                 names <- names(envs)
[17:44:52.382]                 common <- intersect(names, old_names)
[17:44:52.382]                 added <- setdiff(names, old_names)
[17:44:52.382]                 removed <- setdiff(old_names, names)
[17:44:52.382]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.382]                   envs[common]]
[17:44:52.382]                 NAMES <- toupper(changed)
[17:44:52.382]                 args <- list()
[17:44:52.382]                 for (kk in seq_along(NAMES)) {
[17:44:52.382]                   name <- changed[[kk]]
[17:44:52.382]                   NAME <- NAMES[[kk]]
[17:44:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.382]                     next
[17:44:52.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.382]                 }
[17:44:52.382]                 NAMES <- toupper(added)
[17:44:52.382]                 for (kk in seq_along(NAMES)) {
[17:44:52.382]                   name <- added[[kk]]
[17:44:52.382]                   NAME <- NAMES[[kk]]
[17:44:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.382]                     next
[17:44:52.382]                   args[[name]] <- ""
[17:44:52.382]                 }
[17:44:52.382]                 NAMES <- toupper(removed)
[17:44:52.382]                 for (kk in seq_along(NAMES)) {
[17:44:52.382]                   name <- removed[[kk]]
[17:44:52.382]                   NAME <- NAMES[[kk]]
[17:44:52.382]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.382]                     next
[17:44:52.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.382]                 }
[17:44:52.382]                 if (length(args) > 0) 
[17:44:52.382]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.382]             }
[17:44:52.382]             else {
[17:44:52.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.382]             }
[17:44:52.382]             {
[17:44:52.382]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.382]                   0L) {
[17:44:52.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.382]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.382]                   base::options(opts)
[17:44:52.382]                 }
[17:44:52.382]                 {
[17:44:52.382]                   {
[17:44:52.382]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.382]                     NULL
[17:44:52.382]                   }
[17:44:52.382]                   options(future.plan = NULL)
[17:44:52.382]                   if (is.na(NA_character_)) 
[17:44:52.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.382]                     .init = FALSE)
[17:44:52.382]                 }
[17:44:52.382]             }
[17:44:52.382]         }
[17:44:52.382]     })
[17:44:52.382]     if (TRUE) {
[17:44:52.382]         base::sink(type = "output", split = FALSE)
[17:44:52.382]         if (TRUE) {
[17:44:52.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.382]         }
[17:44:52.382]         else {
[17:44:52.382]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.382]         }
[17:44:52.382]         base::close(...future.stdout)
[17:44:52.382]         ...future.stdout <- NULL
[17:44:52.382]     }
[17:44:52.382]     ...future.result$conditions <- ...future.conditions
[17:44:52.382]     ...future.result$finished <- base::Sys.time()
[17:44:52.382]     ...future.result
[17:44:52.382] }
[17:44:52.385] Exporting 5 global objects (168 bytes) to cluster node #1 ...
[17:44:52.385] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ...
[17:44:52.385] Exporting ‘...future.FUN’ (56 bytes) to cluster node #1 ... DONE
[17:44:52.385] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:52.386] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.386] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:44:52.386] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:44:52.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:52.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:52.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.387] Exporting 5 global objects (168 bytes) to cluster node #1 ... DONE
[17:44:52.387] MultisessionFuture started
[17:44:52.388] - Launch lazy future ... done
[17:44:52.388] run() for ‘MultisessionFuture’ ... done
[17:44:52.388] Created future:
[17:44:52.388] MultisessionFuture:
[17:44:52.388] Label: ‘future_Map-1’
[17:44:52.388] Expression:
[17:44:52.388] {
[17:44:52.388]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.388]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.388]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.388]         on.exit(options(oopts), add = TRUE)
[17:44:52.388]     }
[17:44:52.388]     {
[17:44:52.388]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.388]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.388]         do.call(mapply, args = args)
[17:44:52.388]     }
[17:44:52.388] }
[17:44:52.388] Lazy evaluation: FALSE
[17:44:52.388] Asynchronous evaluation: TRUE
[17:44:52.388] Local evaluation: TRUE
[17:44:52.388] Environment: R_GlobalEnv
[17:44:52.388] Capture standard output: TRUE
[17:44:52.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.388] Globals: 5 objects totaling 168 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.388] Packages: <none>
[17:44:52.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.388] Resolved: FALSE
[17:44:52.388] Value: <not collected>
[17:44:52.388] Conditions captured: <none>
[17:44:52.388] Early signaling: FALSE
[17:44:52.388] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.388] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.399] Chunk #1 of 2 ... DONE
[17:44:52.399] Chunk #2 of 2 ...
[17:44:52.400]  - Finding globals in '...' for chunk #2 ...
[17:44:52.400] getGlobalsAndPackages() ...
[17:44:52.400] Searching for globals...
[17:44:52.400] 
[17:44:52.400] Searching for globals ... DONE
[17:44:52.400] - globals: [0] <none>
[17:44:52.400] getGlobalsAndPackages() ... DONE
[17:44:52.400]    + additional globals found: [n=0] 
[17:44:52.401]    + additional namespaces needed: [n=0] 
[17:44:52.401]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:52.401]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.401]  - seeds: <none>
[17:44:52.401]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.401] getGlobalsAndPackages() ...
[17:44:52.401] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.401] Resolving globals: FALSE
[17:44:52.402] The total size of the 5 globals is 280 bytes (280 bytes)
[17:44:52.402] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 280 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.elements_ii’ (224 bytes of class ‘list’), ‘...future.FUN’ (56 bytes of class ‘function’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.402] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.402] 
[17:44:52.402] getGlobalsAndPackages() ... DONE
[17:44:52.403] run() for ‘Future’ ...
[17:44:52.403] - state: ‘created’
[17:44:52.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.417] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.417]   - Field: ‘node’
[17:44:52.418]   - Field: ‘label’
[17:44:52.418]   - Field: ‘local’
[17:44:52.418]   - Field: ‘owner’
[17:44:52.418]   - Field: ‘envir’
[17:44:52.418]   - Field: ‘workers’
[17:44:52.418]   - Field: ‘packages’
[17:44:52.418]   - Field: ‘gc’
[17:44:52.418]   - Field: ‘conditions’
[17:44:52.418]   - Field: ‘persistent’
[17:44:52.418]   - Field: ‘expr’
[17:44:52.418]   - Field: ‘uuid’
[17:44:52.419]   - Field: ‘seed’
[17:44:52.419]   - Field: ‘version’
[17:44:52.419]   - Field: ‘result’
[17:44:52.419]   - Field: ‘asynchronous’
[17:44:52.419]   - Field: ‘calls’
[17:44:52.419]   - Field: ‘globals’
[17:44:52.419]   - Field: ‘stdout’
[17:44:52.419]   - Field: ‘earlySignal’
[17:44:52.419]   - Field: ‘lazy’
[17:44:52.419]   - Field: ‘state’
[17:44:52.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.420] - Launch lazy future ...
[17:44:52.420] Packages needed by the future expression (n = 0): <none>
[17:44:52.420] Packages needed by future strategies (n = 0): <none>
[17:44:52.420] {
[17:44:52.420]     {
[17:44:52.420]         {
[17:44:52.420]             ...future.startTime <- base::Sys.time()
[17:44:52.420]             {
[17:44:52.420]                 {
[17:44:52.420]                   {
[17:44:52.420]                     {
[17:44:52.420]                       base::local({
[17:44:52.420]                         has_future <- base::requireNamespace("future", 
[17:44:52.420]                           quietly = TRUE)
[17:44:52.420]                         if (has_future) {
[17:44:52.420]                           ns <- base::getNamespace("future")
[17:44:52.420]                           version <- ns[[".package"]][["version"]]
[17:44:52.420]                           if (is.null(version)) 
[17:44:52.420]                             version <- utils::packageVersion("future")
[17:44:52.420]                         }
[17:44:52.420]                         else {
[17:44:52.420]                           version <- NULL
[17:44:52.420]                         }
[17:44:52.420]                         if (!has_future || version < "1.8.0") {
[17:44:52.420]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.420]                             "", base::R.version$version.string), 
[17:44:52.420]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:52.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:52.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.420]                               "release", "version")], collapse = " "), 
[17:44:52.420]                             hostname = base::Sys.info()[["nodename"]])
[17:44:52.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.420]                             info)
[17:44:52.420]                           info <- base::paste(info, collapse = "; ")
[17:44:52.420]                           if (!has_future) {
[17:44:52.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.420]                               info)
[17:44:52.420]                           }
[17:44:52.420]                           else {
[17:44:52.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.420]                               info, version)
[17:44:52.420]                           }
[17:44:52.420]                           base::stop(msg)
[17:44:52.420]                         }
[17:44:52.420]                       })
[17:44:52.420]                     }
[17:44:52.420]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.420]                     base::options(mc.cores = 1L)
[17:44:52.420]                   }
[17:44:52.420]                   ...future.strategy.old <- future::plan("list")
[17:44:52.420]                   options(future.plan = NULL)
[17:44:52.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.420]                 }
[17:44:52.420]                 ...future.workdir <- getwd()
[17:44:52.420]             }
[17:44:52.420]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.420]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.420]         }
[17:44:52.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.420]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.420]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.420]             base::names(...future.oldOptions))
[17:44:52.420]     }
[17:44:52.420]     if (FALSE) {
[17:44:52.420]     }
[17:44:52.420]     else {
[17:44:52.420]         if (TRUE) {
[17:44:52.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.420]                 open = "w")
[17:44:52.420]         }
[17:44:52.420]         else {
[17:44:52.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.420]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.420]         }
[17:44:52.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.420]             base::sink(type = "output", split = FALSE)
[17:44:52.420]             base::close(...future.stdout)
[17:44:52.420]         }, add = TRUE)
[17:44:52.420]     }
[17:44:52.420]     ...future.frame <- base::sys.nframe()
[17:44:52.420]     ...future.conditions <- base::list()
[17:44:52.420]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.420]     if (FALSE) {
[17:44:52.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.420]     }
[17:44:52.420]     ...future.result <- base::tryCatch({
[17:44:52.420]         base::withCallingHandlers({
[17:44:52.420]             ...future.value <- base::withVisible(base::local({
[17:44:52.420]                 ...future.makeSendCondition <- base::local({
[17:44:52.420]                   sendCondition <- NULL
[17:44:52.420]                   function(frame = 1L) {
[17:44:52.420]                     if (is.function(sendCondition)) 
[17:44:52.420]                       return(sendCondition)
[17:44:52.420]                     ns <- getNamespace("parallel")
[17:44:52.420]                     if (exists("sendData", mode = "function", 
[17:44:52.420]                       envir = ns)) {
[17:44:52.420]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.420]                         envir = ns)
[17:44:52.420]                       envir <- sys.frame(frame)
[17:44:52.420]                       master <- NULL
[17:44:52.420]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.420]                         !identical(envir, emptyenv())) {
[17:44:52.420]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.420]                           inherits = FALSE)) {
[17:44:52.420]                           master <- get("master", mode = "list", 
[17:44:52.420]                             envir = envir, inherits = FALSE)
[17:44:52.420]                           if (inherits(master, c("SOCKnode", 
[17:44:52.420]                             "SOCK0node"))) {
[17:44:52.420]                             sendCondition <<- function(cond) {
[17:44:52.420]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.420]                                 success = TRUE)
[17:44:52.420]                               parallel_sendData(master, data)
[17:44:52.420]                             }
[17:44:52.420]                             return(sendCondition)
[17:44:52.420]                           }
[17:44:52.420]                         }
[17:44:52.420]                         frame <- frame + 1L
[17:44:52.420]                         envir <- sys.frame(frame)
[17:44:52.420]                       }
[17:44:52.420]                     }
[17:44:52.420]                     sendCondition <<- function(cond) NULL
[17:44:52.420]                   }
[17:44:52.420]                 })
[17:44:52.420]                 withCallingHandlers({
[17:44:52.420]                   {
[17:44:52.420]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.420]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.420]                       ...future.globals.maxSize)) {
[17:44:52.420]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.420]                       on.exit(options(oopts), add = TRUE)
[17:44:52.420]                     }
[17:44:52.420]                     {
[17:44:52.420]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.420]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.420]                         USE.NAMES = FALSE)
[17:44:52.420]                       do.call(mapply, args = args)
[17:44:52.420]                     }
[17:44:52.420]                   }
[17:44:52.420]                 }, immediateCondition = function(cond) {
[17:44:52.420]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.420]                   sendCondition(cond)
[17:44:52.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.420]                   {
[17:44:52.420]                     inherits <- base::inherits
[17:44:52.420]                     invokeRestart <- base::invokeRestart
[17:44:52.420]                     is.null <- base::is.null
[17:44:52.420]                     muffled <- FALSE
[17:44:52.420]                     if (inherits(cond, "message")) {
[17:44:52.420]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.420]                       if (muffled) 
[17:44:52.420]                         invokeRestart("muffleMessage")
[17:44:52.420]                     }
[17:44:52.420]                     else if (inherits(cond, "warning")) {
[17:44:52.420]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.420]                       if (muffled) 
[17:44:52.420]                         invokeRestart("muffleWarning")
[17:44:52.420]                     }
[17:44:52.420]                     else if (inherits(cond, "condition")) {
[17:44:52.420]                       if (!is.null(pattern)) {
[17:44:52.420]                         computeRestarts <- base::computeRestarts
[17:44:52.420]                         grepl <- base::grepl
[17:44:52.420]                         restarts <- computeRestarts(cond)
[17:44:52.420]                         for (restart in restarts) {
[17:44:52.420]                           name <- restart$name
[17:44:52.420]                           if (is.null(name)) 
[17:44:52.420]                             next
[17:44:52.420]                           if (!grepl(pattern, name)) 
[17:44:52.420]                             next
[17:44:52.420]                           invokeRestart(restart)
[17:44:52.420]                           muffled <- TRUE
[17:44:52.420]                           break
[17:44:52.420]                         }
[17:44:52.420]                       }
[17:44:52.420]                     }
[17:44:52.420]                     invisible(muffled)
[17:44:52.420]                   }
[17:44:52.420]                   muffleCondition(cond)
[17:44:52.420]                 })
[17:44:52.420]             }))
[17:44:52.420]             future::FutureResult(value = ...future.value$value, 
[17:44:52.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.420]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.420]                     ...future.globalenv.names))
[17:44:52.420]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.420]         }, condition = base::local({
[17:44:52.420]             c <- base::c
[17:44:52.420]             inherits <- base::inherits
[17:44:52.420]             invokeRestart <- base::invokeRestart
[17:44:52.420]             length <- base::length
[17:44:52.420]             list <- base::list
[17:44:52.420]             seq.int <- base::seq.int
[17:44:52.420]             signalCondition <- base::signalCondition
[17:44:52.420]             sys.calls <- base::sys.calls
[17:44:52.420]             `[[` <- base::`[[`
[17:44:52.420]             `+` <- base::`+`
[17:44:52.420]             `<<-` <- base::`<<-`
[17:44:52.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.420]                   3L)]
[17:44:52.420]             }
[17:44:52.420]             function(cond) {
[17:44:52.420]                 is_error <- inherits(cond, "error")
[17:44:52.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.420]                   NULL)
[17:44:52.420]                 if (is_error) {
[17:44:52.420]                   sessionInformation <- function() {
[17:44:52.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.420]                       search = base::search(), system = base::Sys.info())
[17:44:52.420]                   }
[17:44:52.420]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.420]                     cond$call), session = sessionInformation(), 
[17:44:52.420]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.420]                   signalCondition(cond)
[17:44:52.420]                 }
[17:44:52.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.420]                 "immediateCondition"))) {
[17:44:52.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.420]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.420]                   if (TRUE && !signal) {
[17:44:52.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.420]                     {
[17:44:52.420]                       inherits <- base::inherits
[17:44:52.420]                       invokeRestart <- base::invokeRestart
[17:44:52.420]                       is.null <- base::is.null
[17:44:52.420]                       muffled <- FALSE
[17:44:52.420]                       if (inherits(cond, "message")) {
[17:44:52.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.420]                         if (muffled) 
[17:44:52.420]                           invokeRestart("muffleMessage")
[17:44:52.420]                       }
[17:44:52.420]                       else if (inherits(cond, "warning")) {
[17:44:52.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.420]                         if (muffled) 
[17:44:52.420]                           invokeRestart("muffleWarning")
[17:44:52.420]                       }
[17:44:52.420]                       else if (inherits(cond, "condition")) {
[17:44:52.420]                         if (!is.null(pattern)) {
[17:44:52.420]                           computeRestarts <- base::computeRestarts
[17:44:52.420]                           grepl <- base::grepl
[17:44:52.420]                           restarts <- computeRestarts(cond)
[17:44:52.420]                           for (restart in restarts) {
[17:44:52.420]                             name <- restart$name
[17:44:52.420]                             if (is.null(name)) 
[17:44:52.420]                               next
[17:44:52.420]                             if (!grepl(pattern, name)) 
[17:44:52.420]                               next
[17:44:52.420]                             invokeRestart(restart)
[17:44:52.420]                             muffled <- TRUE
[17:44:52.420]                             break
[17:44:52.420]                           }
[17:44:52.420]                         }
[17:44:52.420]                       }
[17:44:52.420]                       invisible(muffled)
[17:44:52.420]                     }
[17:44:52.420]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.420]                   }
[17:44:52.420]                 }
[17:44:52.420]                 else {
[17:44:52.420]                   if (TRUE) {
[17:44:52.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.420]                     {
[17:44:52.420]                       inherits <- base::inherits
[17:44:52.420]                       invokeRestart <- base::invokeRestart
[17:44:52.420]                       is.null <- base::is.null
[17:44:52.420]                       muffled <- FALSE
[17:44:52.420]                       if (inherits(cond, "message")) {
[17:44:52.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.420]                         if (muffled) 
[17:44:52.420]                           invokeRestart("muffleMessage")
[17:44:52.420]                       }
[17:44:52.420]                       else if (inherits(cond, "warning")) {
[17:44:52.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.420]                         if (muffled) 
[17:44:52.420]                           invokeRestart("muffleWarning")
[17:44:52.420]                       }
[17:44:52.420]                       else if (inherits(cond, "condition")) {
[17:44:52.420]                         if (!is.null(pattern)) {
[17:44:52.420]                           computeRestarts <- base::computeRestarts
[17:44:52.420]                           grepl <- base::grepl
[17:44:52.420]                           restarts <- computeRestarts(cond)
[17:44:52.420]                           for (restart in restarts) {
[17:44:52.420]                             name <- restart$name
[17:44:52.420]                             if (is.null(name)) 
[17:44:52.420]                               next
[17:44:52.420]                             if (!grepl(pattern, name)) 
[17:44:52.420]                               next
[17:44:52.420]                             invokeRestart(restart)
[17:44:52.420]                             muffled <- TRUE
[17:44:52.420]                             break
[17:44:52.420]                           }
[17:44:52.420]                         }
[17:44:52.420]                       }
[17:44:52.420]                       invisible(muffled)
[17:44:52.420]                     }
[17:44:52.420]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.420]                   }
[17:44:52.420]                 }
[17:44:52.420]             }
[17:44:52.420]         }))
[17:44:52.420]     }, error = function(ex) {
[17:44:52.420]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.420]                 ...future.rng), started = ...future.startTime, 
[17:44:52.420]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.420]             version = "1.8"), class = "FutureResult")
[17:44:52.420]     }, finally = {
[17:44:52.420]         if (!identical(...future.workdir, getwd())) 
[17:44:52.420]             setwd(...future.workdir)
[17:44:52.420]         {
[17:44:52.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.420]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.420]             }
[17:44:52.420]             base::options(...future.oldOptions)
[17:44:52.420]             if (.Platform$OS.type == "windows") {
[17:44:52.420]                 old_names <- names(...future.oldEnvVars)
[17:44:52.420]                 envs <- base::Sys.getenv()
[17:44:52.420]                 names <- names(envs)
[17:44:52.420]                 common <- intersect(names, old_names)
[17:44:52.420]                 added <- setdiff(names, old_names)
[17:44:52.420]                 removed <- setdiff(old_names, names)
[17:44:52.420]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.420]                   envs[common]]
[17:44:52.420]                 NAMES <- toupper(changed)
[17:44:52.420]                 args <- list()
[17:44:52.420]                 for (kk in seq_along(NAMES)) {
[17:44:52.420]                   name <- changed[[kk]]
[17:44:52.420]                   NAME <- NAMES[[kk]]
[17:44:52.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.420]                     next
[17:44:52.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.420]                 }
[17:44:52.420]                 NAMES <- toupper(added)
[17:44:52.420]                 for (kk in seq_along(NAMES)) {
[17:44:52.420]                   name <- added[[kk]]
[17:44:52.420]                   NAME <- NAMES[[kk]]
[17:44:52.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.420]                     next
[17:44:52.420]                   args[[name]] <- ""
[17:44:52.420]                 }
[17:44:52.420]                 NAMES <- toupper(removed)
[17:44:52.420]                 for (kk in seq_along(NAMES)) {
[17:44:52.420]                   name <- removed[[kk]]
[17:44:52.420]                   NAME <- NAMES[[kk]]
[17:44:52.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.420]                     next
[17:44:52.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.420]                 }
[17:44:52.420]                 if (length(args) > 0) 
[17:44:52.420]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.420]             }
[17:44:52.420]             else {
[17:44:52.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.420]             }
[17:44:52.420]             {
[17:44:52.420]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.420]                   0L) {
[17:44:52.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.420]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.420]                   base::options(opts)
[17:44:52.420]                 }
[17:44:52.420]                 {
[17:44:52.420]                   {
[17:44:52.420]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.420]                     NULL
[17:44:52.420]                   }
[17:44:52.420]                   options(future.plan = NULL)
[17:44:52.420]                   if (is.na(NA_character_)) 
[17:44:52.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.420]                     .init = FALSE)
[17:44:52.420]                 }
[17:44:52.420]             }
[17:44:52.420]         }
[17:44:52.420]     })
[17:44:52.420]     if (TRUE) {
[17:44:52.420]         base::sink(type = "output", split = FALSE)
[17:44:52.420]         if (TRUE) {
[17:44:52.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.420]         }
[17:44:52.420]         else {
[17:44:52.420]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.420]         }
[17:44:52.420]         base::close(...future.stdout)
[17:44:52.420]         ...future.stdout <- NULL
[17:44:52.420]     }
[17:44:52.420]     ...future.result$conditions <- ...future.conditions
[17:44:52.420]     ...future.result$finished <- base::Sys.time()
[17:44:52.420]     ...future.result
[17:44:52.420] }
[17:44:52.423] Exporting 5 global objects (280 bytes) to cluster node #2 ...
[17:44:52.423] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ...
[17:44:52.424] Exporting ‘...future.FUN’ (56 bytes) to cluster node #2 ... DONE
[17:44:52.424] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:52.424] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.424] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ...
[17:44:52.425] Exporting ‘...future.elements_ii’ (224 bytes) to cluster node #2 ... DONE
[17:44:52.425] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:52.425] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.425] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:52.426] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.426] Exporting 5 global objects (280 bytes) to cluster node #2 ... DONE
[17:44:52.426] MultisessionFuture started
[17:44:52.426] - Launch lazy future ... done
[17:44:52.426] run() for ‘MultisessionFuture’ ... done
[17:44:52.427] Created future:
[17:44:52.427] MultisessionFuture:
[17:44:52.427] Label: ‘future_Map-2’
[17:44:52.427] Expression:
[17:44:52.427] {
[17:44:52.427]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.427]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.427]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.427]         on.exit(options(oopts), add = TRUE)
[17:44:52.427]     }
[17:44:52.427]     {
[17:44:52.427]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.427]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.427]         do.call(mapply, args = args)
[17:44:52.427]     }
[17:44:52.427] }
[17:44:52.427] Lazy evaluation: FALSE
[17:44:52.427] Asynchronous evaluation: TRUE
[17:44:52.427] Local evaluation: TRUE
[17:44:52.427] Environment: R_GlobalEnv
[17:44:52.427] Capture standard output: TRUE
[17:44:52.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.427] Globals: 5 objects totaling 280 bytes (function ‘...future.FUN’ of 56 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.427] Packages: <none>
[17:44:52.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.427] Resolved: FALSE
[17:44:52.427] Value: <not collected>
[17:44:52.427] Conditions captured: <none>
[17:44:52.427] Early signaling: FALSE
[17:44:52.427] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.427] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.438] Chunk #2 of 2 ... DONE
[17:44:52.438] Launching 2 futures (chunks) ... DONE
[17:44:52.438] Resolving 2 futures (chunks) ...
[17:44:52.439] resolve() on list ...
[17:44:52.439]  recursive: 0
[17:44:52.439]  length: 2
[17:44:52.439] 
[17:44:52.439] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.439] - Validating connection of MultisessionFuture
[17:44:52.440] - received message: FutureResult
[17:44:52.440] - Received FutureResult
[17:44:52.440] - Erased future from FutureRegistry
[17:44:52.440] result() for ClusterFuture ...
[17:44:52.440] - result already collected: FutureResult
[17:44:52.440] result() for ClusterFuture ... done
[17:44:52.440] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.440] Future #1
[17:44:52.440] result() for ClusterFuture ...
[17:44:52.440] - result already collected: FutureResult
[17:44:52.441] result() for ClusterFuture ... done
[17:44:52.441] result() for ClusterFuture ...
[17:44:52.441] - result already collected: FutureResult
[17:44:52.441] result() for ClusterFuture ... done
[17:44:52.441] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:52.441] - nx: 2
[17:44:52.441] - relay: TRUE
[17:44:52.441] - stdout: TRUE
[17:44:52.441] - signal: TRUE
[17:44:52.441] - resignal: FALSE
[17:44:52.441] - force: TRUE
[17:44:52.441] - relayed: [n=2] FALSE, FALSE
[17:44:52.442] - queued futures: [n=2] FALSE, FALSE
[17:44:52.442]  - until=1
[17:44:52.442]  - relaying element #1
[17:44:52.442] result() for ClusterFuture ...
[17:44:52.442] - result already collected: FutureResult
[17:44:52.442] result() for ClusterFuture ... done
[17:44:52.442] result() for ClusterFuture ...
[17:44:52.442] - result already collected: FutureResult
[17:44:52.442] result() for ClusterFuture ... done
[17:44:52.442] result() for ClusterFuture ...
[17:44:52.442] - result already collected: FutureResult
[17:44:52.443] result() for ClusterFuture ... done
[17:44:52.443] result() for ClusterFuture ...
[17:44:52.443] - result already collected: FutureResult
[17:44:52.443] result() for ClusterFuture ... done
[17:44:52.443] - relayed: [n=2] TRUE, FALSE
[17:44:52.443] - queued futures: [n=2] TRUE, FALSE
[17:44:52.443] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:52.443]  length: 1 (resolved future 1)
[17:44:52.469] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.469] - Validating connection of MultisessionFuture
[17:44:52.469] - received message: FutureResult
[17:44:52.469] - Received FutureResult
[17:44:52.469] - Erased future from FutureRegistry
[17:44:52.469] result() for ClusterFuture ...
[17:44:52.470] - result already collected: FutureResult
[17:44:52.470] result() for ClusterFuture ... done
[17:44:52.470] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.470] Future #2
[17:44:52.470] result() for ClusterFuture ...
[17:44:52.470] - result already collected: FutureResult
[17:44:52.470] result() for ClusterFuture ... done
[17:44:52.470] result() for ClusterFuture ...
[17:44:52.470] - result already collected: FutureResult
[17:44:52.470] result() for ClusterFuture ... done
[17:44:52.470] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:52.470] - nx: 2
[17:44:52.471] - relay: TRUE
[17:44:52.471] - stdout: TRUE
[17:44:52.471] - signal: TRUE
[17:44:52.471] - resignal: FALSE
[17:44:52.471] - force: TRUE
[17:44:52.471] - relayed: [n=2] TRUE, FALSE
[17:44:52.471] - queued futures: [n=2] TRUE, FALSE
[17:44:52.471]  - until=2
[17:44:52.471]  - relaying element #2
[17:44:52.471] result() for ClusterFuture ...
[17:44:52.471] - result already collected: FutureResult
[17:44:52.472] result() for ClusterFuture ... done
[17:44:52.472] result() for ClusterFuture ...
[17:44:52.472] - result already collected: FutureResult
[17:44:52.472] result() for ClusterFuture ... done
[17:44:52.472] result() for ClusterFuture ...
[17:44:52.472] - result already collected: FutureResult
[17:44:52.472] result() for ClusterFuture ... done
[17:44:52.472] result() for ClusterFuture ...
[17:44:52.472] - result already collected: FutureResult
[17:44:52.472] result() for ClusterFuture ... done
[17:44:52.472] - relayed: [n=2] TRUE, TRUE
[17:44:52.472] - queued futures: [n=2] TRUE, TRUE
[17:44:52.473] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:52.473]  length: 0 (resolved future 2)
[17:44:52.473] Relaying remaining futures
[17:44:52.473] signalConditionsASAP(NULL, pos=0) ...
[17:44:52.473] - nx: 2
[17:44:52.473] - relay: TRUE
[17:44:52.473] - stdout: TRUE
[17:44:52.473] - signal: TRUE
[17:44:52.473] - resignal: FALSE
[17:44:52.473] - force: TRUE
[17:44:52.473] - relayed: [n=2] TRUE, TRUE
[17:44:52.473] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:52.474] - relayed: [n=2] TRUE, TRUE
[17:44:52.474] - queued futures: [n=2] TRUE, TRUE
[17:44:52.474] signalConditionsASAP(NULL, pos=0) ... done
[17:44:52.474] resolve() on list ... DONE
[17:44:52.474] result() for ClusterFuture ...
[17:44:52.474] - result already collected: FutureResult
[17:44:52.474] result() for ClusterFuture ... done
[17:44:52.474] result() for ClusterFuture ...
[17:44:52.474] - result already collected: FutureResult
[17:44:52.474] result() for ClusterFuture ... done
[17:44:52.474] result() for ClusterFuture ...
[17:44:52.475] - result already collected: FutureResult
[17:44:52.475] result() for ClusterFuture ... done
[17:44:52.475] result() for ClusterFuture ...
[17:44:52.475] - result already collected: FutureResult
[17:44:52.475] result() for ClusterFuture ... done
[17:44:52.475]  - Number of value chunks collected: 2
[17:44:52.475] Resolving 2 futures (chunks) ... DONE
[17:44:52.475] Reducing values from 2 chunks ...
[17:44:52.475]  - Number of values collected after concatenation: 3
[17:44:52.475]  - Number of values expected: 3
[17:44:52.475] Reducing values from 2 chunks ... DONE
[17:44:52.476] future_mapply() ... DONE
- future_mapply(x, ...) where x[[i]] subsets via S3 method ...
[17:44:52.476] future_mapply() ...
[17:44:52.480] Number of chunks: 2
[17:44:52.480] getGlobalsAndPackagesXApply() ...
[17:44:52.480]  - future.globals: TRUE
[17:44:52.480] getGlobalsAndPackages() ...
[17:44:52.480] Searching for globals...
[17:44:52.481] - globals found: [1] ‘FUN’
[17:44:52.481] Searching for globals ... DONE
[17:44:52.481] Resolving globals: FALSE
[17:44:52.481] The total size of the 1 globals is 848 bytes (848 bytes)
[17:44:52.482] The total size of the 1 globals exported for future expression (‘FUN()’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[17:44:52.482] - globals: [1] ‘FUN’
[17:44:52.482] 
[17:44:52.482] getGlobalsAndPackages() ... DONE
[17:44:52.482]  - globals found/used: [n=1] ‘FUN’
[17:44:52.482]  - needed namespaces: [n=0] 
[17:44:52.482] Finding globals ... DONE
[17:44:52.483] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[17:44:52.483] List of 2
[17:44:52.483]  $ ...future.FUN:function (x)  
[17:44:52.483]  $ MoreArgs     : NULL
[17:44:52.483]  - attr(*, "where")=List of 2
[17:44:52.483]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:44:52.483]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[17:44:52.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:44:52.483]  - attr(*, "resolved")= logi FALSE
[17:44:52.483]  - attr(*, "total_size")= num NA
[17:44:52.485] Packages to be attached in all futures: [n=0] 
[17:44:52.485] getGlobalsAndPackagesXApply() ... DONE
[17:44:52.485] Number of futures (= number of chunks): 2
[17:44:52.485] Launching 2 futures (chunks) ...
[17:44:52.486] Chunk #1 of 2 ...
[17:44:52.486]  - Finding globals in '...' for chunk #1 ...
[17:44:52.486] getGlobalsAndPackages() ...
[17:44:52.486] Searching for globals...
[17:44:52.486] 
[17:44:52.486] Searching for globals ... DONE
[17:44:52.486] - globals: [0] <none>
[17:44:52.486] getGlobalsAndPackages() ... DONE
[17:44:52.486]    + additional globals found: [n=0] 
[17:44:52.487]    + additional namespaces needed: [n=0] 
[17:44:52.487]  - Finding globals in '...' for chunk #1 ... DONE
[17:44:52.487]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.487]  - seeds: <none>
[17:44:52.487]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.487] getGlobalsAndPackages() ...
[17:44:52.487] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.487] Resolving globals: FALSE
[17:44:52.488] The total size of the 5 globals is 904 bytes (904 bytes)
[17:44:52.488] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.488] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.488] 
[17:44:52.488] getGlobalsAndPackages() ... DONE
[17:44:52.489] run() for ‘Future’ ...
[17:44:52.489] - state: ‘created’
[17:44:52.489] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.505]   - Field: ‘node’
[17:44:52.505]   - Field: ‘label’
[17:44:52.505]   - Field: ‘local’
[17:44:52.505]   - Field: ‘owner’
[17:44:52.505]   - Field: ‘envir’
[17:44:52.505]   - Field: ‘workers’
[17:44:52.505]   - Field: ‘packages’
[17:44:52.505]   - Field: ‘gc’
[17:44:52.505]   - Field: ‘conditions’
[17:44:52.505]   - Field: ‘persistent’
[17:44:52.506]   - Field: ‘expr’
[17:44:52.506]   - Field: ‘uuid’
[17:44:52.506]   - Field: ‘seed’
[17:44:52.506]   - Field: ‘version’
[17:44:52.506]   - Field: ‘result’
[17:44:52.506]   - Field: ‘asynchronous’
[17:44:52.506]   - Field: ‘calls’
[17:44:52.506]   - Field: ‘globals’
[17:44:52.506]   - Field: ‘stdout’
[17:44:52.506]   - Field: ‘earlySignal’
[17:44:52.506]   - Field: ‘lazy’
[17:44:52.507]   - Field: ‘state’
[17:44:52.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.507] - Launch lazy future ...
[17:44:52.507] Packages needed by the future expression (n = 0): <none>
[17:44:52.507] Packages needed by future strategies (n = 0): <none>
[17:44:52.508] {
[17:44:52.508]     {
[17:44:52.508]         {
[17:44:52.508]             ...future.startTime <- base::Sys.time()
[17:44:52.508]             {
[17:44:52.508]                 {
[17:44:52.508]                   {
[17:44:52.508]                     {
[17:44:52.508]                       base::local({
[17:44:52.508]                         has_future <- base::requireNamespace("future", 
[17:44:52.508]                           quietly = TRUE)
[17:44:52.508]                         if (has_future) {
[17:44:52.508]                           ns <- base::getNamespace("future")
[17:44:52.508]                           version <- ns[[".package"]][["version"]]
[17:44:52.508]                           if (is.null(version)) 
[17:44:52.508]                             version <- utils::packageVersion("future")
[17:44:52.508]                         }
[17:44:52.508]                         else {
[17:44:52.508]                           version <- NULL
[17:44:52.508]                         }
[17:44:52.508]                         if (!has_future || version < "1.8.0") {
[17:44:52.508]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.508]                             "", base::R.version$version.string), 
[17:44:52.508]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:52.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:52.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.508]                               "release", "version")], collapse = " "), 
[17:44:52.508]                             hostname = base::Sys.info()[["nodename"]])
[17:44:52.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.508]                             info)
[17:44:52.508]                           info <- base::paste(info, collapse = "; ")
[17:44:52.508]                           if (!has_future) {
[17:44:52.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.508]                               info)
[17:44:52.508]                           }
[17:44:52.508]                           else {
[17:44:52.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.508]                               info, version)
[17:44:52.508]                           }
[17:44:52.508]                           base::stop(msg)
[17:44:52.508]                         }
[17:44:52.508]                       })
[17:44:52.508]                     }
[17:44:52.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.508]                     base::options(mc.cores = 1L)
[17:44:52.508]                   }
[17:44:52.508]                   ...future.strategy.old <- future::plan("list")
[17:44:52.508]                   options(future.plan = NULL)
[17:44:52.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.508]                 }
[17:44:52.508]                 ...future.workdir <- getwd()
[17:44:52.508]             }
[17:44:52.508]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.508]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.508]         }
[17:44:52.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.508]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.508]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.508]             base::names(...future.oldOptions))
[17:44:52.508]     }
[17:44:52.508]     if (FALSE) {
[17:44:52.508]     }
[17:44:52.508]     else {
[17:44:52.508]         if (TRUE) {
[17:44:52.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.508]                 open = "w")
[17:44:52.508]         }
[17:44:52.508]         else {
[17:44:52.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.508]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.508]         }
[17:44:52.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.508]             base::sink(type = "output", split = FALSE)
[17:44:52.508]             base::close(...future.stdout)
[17:44:52.508]         }, add = TRUE)
[17:44:52.508]     }
[17:44:52.508]     ...future.frame <- base::sys.nframe()
[17:44:52.508]     ...future.conditions <- base::list()
[17:44:52.508]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.508]     if (FALSE) {
[17:44:52.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.508]     }
[17:44:52.508]     ...future.result <- base::tryCatch({
[17:44:52.508]         base::withCallingHandlers({
[17:44:52.508]             ...future.value <- base::withVisible(base::local({
[17:44:52.508]                 ...future.makeSendCondition <- base::local({
[17:44:52.508]                   sendCondition <- NULL
[17:44:52.508]                   function(frame = 1L) {
[17:44:52.508]                     if (is.function(sendCondition)) 
[17:44:52.508]                       return(sendCondition)
[17:44:52.508]                     ns <- getNamespace("parallel")
[17:44:52.508]                     if (exists("sendData", mode = "function", 
[17:44:52.508]                       envir = ns)) {
[17:44:52.508]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.508]                         envir = ns)
[17:44:52.508]                       envir <- sys.frame(frame)
[17:44:52.508]                       master <- NULL
[17:44:52.508]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.508]                         !identical(envir, emptyenv())) {
[17:44:52.508]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.508]                           inherits = FALSE)) {
[17:44:52.508]                           master <- get("master", mode = "list", 
[17:44:52.508]                             envir = envir, inherits = FALSE)
[17:44:52.508]                           if (inherits(master, c("SOCKnode", 
[17:44:52.508]                             "SOCK0node"))) {
[17:44:52.508]                             sendCondition <<- function(cond) {
[17:44:52.508]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.508]                                 success = TRUE)
[17:44:52.508]                               parallel_sendData(master, data)
[17:44:52.508]                             }
[17:44:52.508]                             return(sendCondition)
[17:44:52.508]                           }
[17:44:52.508]                         }
[17:44:52.508]                         frame <- frame + 1L
[17:44:52.508]                         envir <- sys.frame(frame)
[17:44:52.508]                       }
[17:44:52.508]                     }
[17:44:52.508]                     sendCondition <<- function(cond) NULL
[17:44:52.508]                   }
[17:44:52.508]                 })
[17:44:52.508]                 withCallingHandlers({
[17:44:52.508]                   {
[17:44:52.508]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.508]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.508]                       ...future.globals.maxSize)) {
[17:44:52.508]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.508]                       on.exit(options(oopts), add = TRUE)
[17:44:52.508]                     }
[17:44:52.508]                     {
[17:44:52.508]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.508]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.508]                         USE.NAMES = FALSE)
[17:44:52.508]                       do.call(mapply, args = args)
[17:44:52.508]                     }
[17:44:52.508]                   }
[17:44:52.508]                 }, immediateCondition = function(cond) {
[17:44:52.508]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.508]                   sendCondition(cond)
[17:44:52.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.508]                   {
[17:44:52.508]                     inherits <- base::inherits
[17:44:52.508]                     invokeRestart <- base::invokeRestart
[17:44:52.508]                     is.null <- base::is.null
[17:44:52.508]                     muffled <- FALSE
[17:44:52.508]                     if (inherits(cond, "message")) {
[17:44:52.508]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.508]                       if (muffled) 
[17:44:52.508]                         invokeRestart("muffleMessage")
[17:44:52.508]                     }
[17:44:52.508]                     else if (inherits(cond, "warning")) {
[17:44:52.508]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.508]                       if (muffled) 
[17:44:52.508]                         invokeRestart("muffleWarning")
[17:44:52.508]                     }
[17:44:52.508]                     else if (inherits(cond, "condition")) {
[17:44:52.508]                       if (!is.null(pattern)) {
[17:44:52.508]                         computeRestarts <- base::computeRestarts
[17:44:52.508]                         grepl <- base::grepl
[17:44:52.508]                         restarts <- computeRestarts(cond)
[17:44:52.508]                         for (restart in restarts) {
[17:44:52.508]                           name <- restart$name
[17:44:52.508]                           if (is.null(name)) 
[17:44:52.508]                             next
[17:44:52.508]                           if (!grepl(pattern, name)) 
[17:44:52.508]                             next
[17:44:52.508]                           invokeRestart(restart)
[17:44:52.508]                           muffled <- TRUE
[17:44:52.508]                           break
[17:44:52.508]                         }
[17:44:52.508]                       }
[17:44:52.508]                     }
[17:44:52.508]                     invisible(muffled)
[17:44:52.508]                   }
[17:44:52.508]                   muffleCondition(cond)
[17:44:52.508]                 })
[17:44:52.508]             }))
[17:44:52.508]             future::FutureResult(value = ...future.value$value, 
[17:44:52.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.508]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.508]                     ...future.globalenv.names))
[17:44:52.508]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.508]         }, condition = base::local({
[17:44:52.508]             c <- base::c
[17:44:52.508]             inherits <- base::inherits
[17:44:52.508]             invokeRestart <- base::invokeRestart
[17:44:52.508]             length <- base::length
[17:44:52.508]             list <- base::list
[17:44:52.508]             seq.int <- base::seq.int
[17:44:52.508]             signalCondition <- base::signalCondition
[17:44:52.508]             sys.calls <- base::sys.calls
[17:44:52.508]             `[[` <- base::`[[`
[17:44:52.508]             `+` <- base::`+`
[17:44:52.508]             `<<-` <- base::`<<-`
[17:44:52.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.508]                   3L)]
[17:44:52.508]             }
[17:44:52.508]             function(cond) {
[17:44:52.508]                 is_error <- inherits(cond, "error")
[17:44:52.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.508]                   NULL)
[17:44:52.508]                 if (is_error) {
[17:44:52.508]                   sessionInformation <- function() {
[17:44:52.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.508]                       search = base::search(), system = base::Sys.info())
[17:44:52.508]                   }
[17:44:52.508]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.508]                     cond$call), session = sessionInformation(), 
[17:44:52.508]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.508]                   signalCondition(cond)
[17:44:52.508]                 }
[17:44:52.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.508]                 "immediateCondition"))) {
[17:44:52.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.508]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.508]                   if (TRUE && !signal) {
[17:44:52.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.508]                     {
[17:44:52.508]                       inherits <- base::inherits
[17:44:52.508]                       invokeRestart <- base::invokeRestart
[17:44:52.508]                       is.null <- base::is.null
[17:44:52.508]                       muffled <- FALSE
[17:44:52.508]                       if (inherits(cond, "message")) {
[17:44:52.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.508]                         if (muffled) 
[17:44:52.508]                           invokeRestart("muffleMessage")
[17:44:52.508]                       }
[17:44:52.508]                       else if (inherits(cond, "warning")) {
[17:44:52.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.508]                         if (muffled) 
[17:44:52.508]                           invokeRestart("muffleWarning")
[17:44:52.508]                       }
[17:44:52.508]                       else if (inherits(cond, "condition")) {
[17:44:52.508]                         if (!is.null(pattern)) {
[17:44:52.508]                           computeRestarts <- base::computeRestarts
[17:44:52.508]                           grepl <- base::grepl
[17:44:52.508]                           restarts <- computeRestarts(cond)
[17:44:52.508]                           for (restart in restarts) {
[17:44:52.508]                             name <- restart$name
[17:44:52.508]                             if (is.null(name)) 
[17:44:52.508]                               next
[17:44:52.508]                             if (!grepl(pattern, name)) 
[17:44:52.508]                               next
[17:44:52.508]                             invokeRestart(restart)
[17:44:52.508]                             muffled <- TRUE
[17:44:52.508]                             break
[17:44:52.508]                           }
[17:44:52.508]                         }
[17:44:52.508]                       }
[17:44:52.508]                       invisible(muffled)
[17:44:52.508]                     }
[17:44:52.508]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.508]                   }
[17:44:52.508]                 }
[17:44:52.508]                 else {
[17:44:52.508]                   if (TRUE) {
[17:44:52.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.508]                     {
[17:44:52.508]                       inherits <- base::inherits
[17:44:52.508]                       invokeRestart <- base::invokeRestart
[17:44:52.508]                       is.null <- base::is.null
[17:44:52.508]                       muffled <- FALSE
[17:44:52.508]                       if (inherits(cond, "message")) {
[17:44:52.508]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.508]                         if (muffled) 
[17:44:52.508]                           invokeRestart("muffleMessage")
[17:44:52.508]                       }
[17:44:52.508]                       else if (inherits(cond, "warning")) {
[17:44:52.508]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.508]                         if (muffled) 
[17:44:52.508]                           invokeRestart("muffleWarning")
[17:44:52.508]                       }
[17:44:52.508]                       else if (inherits(cond, "condition")) {
[17:44:52.508]                         if (!is.null(pattern)) {
[17:44:52.508]                           computeRestarts <- base::computeRestarts
[17:44:52.508]                           grepl <- base::grepl
[17:44:52.508]                           restarts <- computeRestarts(cond)
[17:44:52.508]                           for (restart in restarts) {
[17:44:52.508]                             name <- restart$name
[17:44:52.508]                             if (is.null(name)) 
[17:44:52.508]                               next
[17:44:52.508]                             if (!grepl(pattern, name)) 
[17:44:52.508]                               next
[17:44:52.508]                             invokeRestart(restart)
[17:44:52.508]                             muffled <- TRUE
[17:44:52.508]                             break
[17:44:52.508]                           }
[17:44:52.508]                         }
[17:44:52.508]                       }
[17:44:52.508]                       invisible(muffled)
[17:44:52.508]                     }
[17:44:52.508]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.508]                   }
[17:44:52.508]                 }
[17:44:52.508]             }
[17:44:52.508]         }))
[17:44:52.508]     }, error = function(ex) {
[17:44:52.508]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.508]                 ...future.rng), started = ...future.startTime, 
[17:44:52.508]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.508]             version = "1.8"), class = "FutureResult")
[17:44:52.508]     }, finally = {
[17:44:52.508]         if (!identical(...future.workdir, getwd())) 
[17:44:52.508]             setwd(...future.workdir)
[17:44:52.508]         {
[17:44:52.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.508]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.508]             }
[17:44:52.508]             base::options(...future.oldOptions)
[17:44:52.508]             if (.Platform$OS.type == "windows") {
[17:44:52.508]                 old_names <- names(...future.oldEnvVars)
[17:44:52.508]                 envs <- base::Sys.getenv()
[17:44:52.508]                 names <- names(envs)
[17:44:52.508]                 common <- intersect(names, old_names)
[17:44:52.508]                 added <- setdiff(names, old_names)
[17:44:52.508]                 removed <- setdiff(old_names, names)
[17:44:52.508]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.508]                   envs[common]]
[17:44:52.508]                 NAMES <- toupper(changed)
[17:44:52.508]                 args <- list()
[17:44:52.508]                 for (kk in seq_along(NAMES)) {
[17:44:52.508]                   name <- changed[[kk]]
[17:44:52.508]                   NAME <- NAMES[[kk]]
[17:44:52.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.508]                     next
[17:44:52.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.508]                 }
[17:44:52.508]                 NAMES <- toupper(added)
[17:44:52.508]                 for (kk in seq_along(NAMES)) {
[17:44:52.508]                   name <- added[[kk]]
[17:44:52.508]                   NAME <- NAMES[[kk]]
[17:44:52.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.508]                     next
[17:44:52.508]                   args[[name]] <- ""
[17:44:52.508]                 }
[17:44:52.508]                 NAMES <- toupper(removed)
[17:44:52.508]                 for (kk in seq_along(NAMES)) {
[17:44:52.508]                   name <- removed[[kk]]
[17:44:52.508]                   NAME <- NAMES[[kk]]
[17:44:52.508]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.508]                     next
[17:44:52.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.508]                 }
[17:44:52.508]                 if (length(args) > 0) 
[17:44:52.508]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.508]             }
[17:44:52.508]             else {
[17:44:52.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.508]             }
[17:44:52.508]             {
[17:44:52.508]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.508]                   0L) {
[17:44:52.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.508]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.508]                   base::options(opts)
[17:44:52.508]                 }
[17:44:52.508]                 {
[17:44:52.508]                   {
[17:44:52.508]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.508]                     NULL
[17:44:52.508]                   }
[17:44:52.508]                   options(future.plan = NULL)
[17:44:52.508]                   if (is.na(NA_character_)) 
[17:44:52.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.508]                     .init = FALSE)
[17:44:52.508]                 }
[17:44:52.508]             }
[17:44:52.508]         }
[17:44:52.508]     })
[17:44:52.508]     if (TRUE) {
[17:44:52.508]         base::sink(type = "output", split = FALSE)
[17:44:52.508]         if (TRUE) {
[17:44:52.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.508]         }
[17:44:52.508]         else {
[17:44:52.508]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.508]         }
[17:44:52.508]         base::close(...future.stdout)
[17:44:52.508]         ...future.stdout <- NULL
[17:44:52.508]     }
[17:44:52.508]     ...future.result$conditions <- ...future.conditions
[17:44:52.508]     ...future.result$finished <- base::Sys.time()
[17:44:52.508]     ...future.result
[17:44:52.508] }
[17:44:52.510] Exporting 5 global objects (904 bytes) to cluster node #1 ...
[17:44:52.510] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[17:44:52.511] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[17:44:52.511] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[17:44:52.511] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.511] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:44:52.512] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:44:52.512] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:44:52.512] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.512] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:44:52.512] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:44:52.513] Exporting 5 global objects (904 bytes) to cluster node #1 ... DONE
[17:44:52.513] MultisessionFuture started
[17:44:52.513] - Launch lazy future ... done
[17:44:52.513] run() for ‘MultisessionFuture’ ... done
[17:44:52.513] Created future:
[17:44:52.513] MultisessionFuture:
[17:44:52.513] Label: ‘future_mapply-1’
[17:44:52.513] Expression:
[17:44:52.513] {
[17:44:52.513]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.513]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.513]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.513]         on.exit(options(oopts), add = TRUE)
[17:44:52.513]     }
[17:44:52.513]     {
[17:44:52.513]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.513]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.513]         do.call(mapply, args = args)
[17:44:52.513]     }
[17:44:52.513] }
[17:44:52.513] Lazy evaluation: FALSE
[17:44:52.513] Asynchronous evaluation: TRUE
[17:44:52.513] Local evaluation: TRUE
[17:44:52.513] Environment: R_GlobalEnv
[17:44:52.513] Capture standard output: TRUE
[17:44:52.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.513] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.513] Packages: <none>
[17:44:52.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.513] Resolved: FALSE
[17:44:52.513] Value: <not collected>
[17:44:52.513] Conditions captured: <none>
[17:44:52.513] Early signaling: FALSE
[17:44:52.513] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.513] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.525] Chunk #1 of 2 ... DONE
[17:44:52.525] Chunk #2 of 2 ...
[17:44:52.525]  - Finding globals in '...' for chunk #2 ...
[17:44:52.525] getGlobalsAndPackages() ...
[17:44:52.525] Searching for globals...
[17:44:52.525] 
[17:44:52.526] Searching for globals ... DONE
[17:44:52.526] - globals: [0] <none>
[17:44:52.526] getGlobalsAndPackages() ... DONE
[17:44:52.526]    + additional globals found: [n=0] 
[17:44:52.526]    + additional namespaces needed: [n=0] 
[17:44:52.526]  - Finding globals in '...' for chunk #2 ... DONE
[17:44:52.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:44:52.526]  - seeds: <none>
[17:44:52.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.526] getGlobalsAndPackages() ...
[17:44:52.526] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.527] Resolving globals: FALSE
[17:44:52.527] The total size of the 5 globals is 904 bytes (904 bytes)
[17:44:52.527] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 904 bytes.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (848 bytes of class ‘function’), ‘...future.elements_ii’ (56 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[17:44:52.528] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:44:52.528] 
[17:44:52.528] getGlobalsAndPackages() ... DONE
[17:44:52.528] run() for ‘Future’ ...
[17:44:52.528] - state: ‘created’
[17:44:52.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:44:52.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:44:52.543]   - Field: ‘node’
[17:44:52.543]   - Field: ‘label’
[17:44:52.543]   - Field: ‘local’
[17:44:52.543]   - Field: ‘owner’
[17:44:52.543]   - Field: ‘envir’
[17:44:52.543]   - Field: ‘workers’
[17:44:52.543]   - Field: ‘packages’
[17:44:52.543]   - Field: ‘gc’
[17:44:52.546]   - Field: ‘conditions’
[17:44:52.546]   - Field: ‘persistent’
[17:44:52.546]   - Field: ‘expr’
[17:44:52.546]   - Field: ‘uuid’
[17:44:52.546]   - Field: ‘seed’
[17:44:52.546]   - Field: ‘version’
[17:44:52.546]   - Field: ‘result’
[17:44:52.547]   - Field: ‘asynchronous’
[17:44:52.547]   - Field: ‘calls’
[17:44:52.547]   - Field: ‘globals’
[17:44:52.547]   - Field: ‘stdout’
[17:44:52.547]   - Field: ‘earlySignal’
[17:44:52.547]   - Field: ‘lazy’
[17:44:52.547]   - Field: ‘state’
[17:44:52.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:44:52.547] - Launch lazy future ...
[17:44:52.547] Packages needed by the future expression (n = 0): <none>
[17:44:52.548] Packages needed by future strategies (n = 0): <none>
[17:44:52.548] {
[17:44:52.548]     {
[17:44:52.548]         {
[17:44:52.548]             ...future.startTime <- base::Sys.time()
[17:44:52.548]             {
[17:44:52.548]                 {
[17:44:52.548]                   {
[17:44:52.548]                     {
[17:44:52.548]                       base::local({
[17:44:52.548]                         has_future <- base::requireNamespace("future", 
[17:44:52.548]                           quietly = TRUE)
[17:44:52.548]                         if (has_future) {
[17:44:52.548]                           ns <- base::getNamespace("future")
[17:44:52.548]                           version <- ns[[".package"]][["version"]]
[17:44:52.548]                           if (is.null(version)) 
[17:44:52.548]                             version <- utils::packageVersion("future")
[17:44:52.548]                         }
[17:44:52.548]                         else {
[17:44:52.548]                           version <- NULL
[17:44:52.548]                         }
[17:44:52.548]                         if (!has_future || version < "1.8.0") {
[17:44:52.548]                           info <- base::c(r_version = base::gsub("R version ", 
[17:44:52.548]                             "", base::R.version$version.string), 
[17:44:52.548]                             platform = base::sprintf("%s (%s-bit)", 
[17:44:52.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:44:52.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:44:52.548]                               "release", "version")], collapse = " "), 
[17:44:52.548]                             hostname = base::Sys.info()[["nodename"]])
[17:44:52.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:44:52.548]                             info)
[17:44:52.548]                           info <- base::paste(info, collapse = "; ")
[17:44:52.548]                           if (!has_future) {
[17:44:52.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:44:52.548]                               info)
[17:44:52.548]                           }
[17:44:52.548]                           else {
[17:44:52.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:44:52.548]                               info, version)
[17:44:52.548]                           }
[17:44:52.548]                           base::stop(msg)
[17:44:52.548]                         }
[17:44:52.548]                       })
[17:44:52.548]                     }
[17:44:52.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:44:52.548]                     base::options(mc.cores = 1L)
[17:44:52.548]                   }
[17:44:52.548]                   ...future.strategy.old <- future::plan("list")
[17:44:52.548]                   options(future.plan = NULL)
[17:44:52.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:44:52.548]                 }
[17:44:52.548]                 ...future.workdir <- getwd()
[17:44:52.548]             }
[17:44:52.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:44:52.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:44:52.548]         }
[17:44:52.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:44:52.548]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:44:52.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:44:52.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:44:52.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:44:52.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:44:52.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:44:52.548]             base::names(...future.oldOptions))
[17:44:52.548]     }
[17:44:52.548]     if (FALSE) {
[17:44:52.548]     }
[17:44:52.548]     else {
[17:44:52.548]         if (TRUE) {
[17:44:52.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:44:52.548]                 open = "w")
[17:44:52.548]         }
[17:44:52.548]         else {
[17:44:52.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:44:52.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:44:52.548]         }
[17:44:52.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:44:52.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:44:52.548]             base::sink(type = "output", split = FALSE)
[17:44:52.548]             base::close(...future.stdout)
[17:44:52.548]         }, add = TRUE)
[17:44:52.548]     }
[17:44:52.548]     ...future.frame <- base::sys.nframe()
[17:44:52.548]     ...future.conditions <- base::list()
[17:44:52.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:44:52.548]     if (FALSE) {
[17:44:52.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:44:52.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:44:52.548]     }
[17:44:52.548]     ...future.result <- base::tryCatch({
[17:44:52.548]         base::withCallingHandlers({
[17:44:52.548]             ...future.value <- base::withVisible(base::local({
[17:44:52.548]                 ...future.makeSendCondition <- base::local({
[17:44:52.548]                   sendCondition <- NULL
[17:44:52.548]                   function(frame = 1L) {
[17:44:52.548]                     if (is.function(sendCondition)) 
[17:44:52.548]                       return(sendCondition)
[17:44:52.548]                     ns <- getNamespace("parallel")
[17:44:52.548]                     if (exists("sendData", mode = "function", 
[17:44:52.548]                       envir = ns)) {
[17:44:52.548]                       parallel_sendData <- get("sendData", mode = "function", 
[17:44:52.548]                         envir = ns)
[17:44:52.548]                       envir <- sys.frame(frame)
[17:44:52.548]                       master <- NULL
[17:44:52.548]                       while (!identical(envir, .GlobalEnv) && 
[17:44:52.548]                         !identical(envir, emptyenv())) {
[17:44:52.548]                         if (exists("master", mode = "list", envir = envir, 
[17:44:52.548]                           inherits = FALSE)) {
[17:44:52.548]                           master <- get("master", mode = "list", 
[17:44:52.548]                             envir = envir, inherits = FALSE)
[17:44:52.548]                           if (inherits(master, c("SOCKnode", 
[17:44:52.548]                             "SOCK0node"))) {
[17:44:52.548]                             sendCondition <<- function(cond) {
[17:44:52.548]                               data <- list(type = "VALUE", value = cond, 
[17:44:52.548]                                 success = TRUE)
[17:44:52.548]                               parallel_sendData(master, data)
[17:44:52.548]                             }
[17:44:52.548]                             return(sendCondition)
[17:44:52.548]                           }
[17:44:52.548]                         }
[17:44:52.548]                         frame <- frame + 1L
[17:44:52.548]                         envir <- sys.frame(frame)
[17:44:52.548]                       }
[17:44:52.548]                     }
[17:44:52.548]                     sendCondition <<- function(cond) NULL
[17:44:52.548]                   }
[17:44:52.548]                 })
[17:44:52.548]                 withCallingHandlers({
[17:44:52.548]                   {
[17:44:52.548]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.548]                     if (!identical(...future.globals.maxSize.org, 
[17:44:52.548]                       ...future.globals.maxSize)) {
[17:44:52.548]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.548]                       on.exit(options(oopts), add = TRUE)
[17:44:52.548]                     }
[17:44:52.548]                     {
[17:44:52.548]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.548]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[17:44:52.548]                         USE.NAMES = FALSE)
[17:44:52.548]                       do.call(mapply, args = args)
[17:44:52.548]                     }
[17:44:52.548]                   }
[17:44:52.548]                 }, immediateCondition = function(cond) {
[17:44:52.548]                   sendCondition <- ...future.makeSendCondition()
[17:44:52.548]                   sendCondition(cond)
[17:44:52.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.548]                   {
[17:44:52.548]                     inherits <- base::inherits
[17:44:52.548]                     invokeRestart <- base::invokeRestart
[17:44:52.548]                     is.null <- base::is.null
[17:44:52.548]                     muffled <- FALSE
[17:44:52.548]                     if (inherits(cond, "message")) {
[17:44:52.548]                       muffled <- grepl(pattern, "muffleMessage")
[17:44:52.548]                       if (muffled) 
[17:44:52.548]                         invokeRestart("muffleMessage")
[17:44:52.548]                     }
[17:44:52.548]                     else if (inherits(cond, "warning")) {
[17:44:52.548]                       muffled <- grepl(pattern, "muffleWarning")
[17:44:52.548]                       if (muffled) 
[17:44:52.548]                         invokeRestart("muffleWarning")
[17:44:52.548]                     }
[17:44:52.548]                     else if (inherits(cond, "condition")) {
[17:44:52.548]                       if (!is.null(pattern)) {
[17:44:52.548]                         computeRestarts <- base::computeRestarts
[17:44:52.548]                         grepl <- base::grepl
[17:44:52.548]                         restarts <- computeRestarts(cond)
[17:44:52.548]                         for (restart in restarts) {
[17:44:52.548]                           name <- restart$name
[17:44:52.548]                           if (is.null(name)) 
[17:44:52.548]                             next
[17:44:52.548]                           if (!grepl(pattern, name)) 
[17:44:52.548]                             next
[17:44:52.548]                           invokeRestart(restart)
[17:44:52.548]                           muffled <- TRUE
[17:44:52.548]                           break
[17:44:52.548]                         }
[17:44:52.548]                       }
[17:44:52.548]                     }
[17:44:52.548]                     invisible(muffled)
[17:44:52.548]                   }
[17:44:52.548]                   muffleCondition(cond)
[17:44:52.548]                 })
[17:44:52.548]             }))
[17:44:52.548]             future::FutureResult(value = ...future.value$value, 
[17:44:52.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.548]                   ...future.rng), globalenv = if (FALSE) 
[17:44:52.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:44:52.548]                     ...future.globalenv.names))
[17:44:52.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:44:52.548]         }, condition = base::local({
[17:44:52.548]             c <- base::c
[17:44:52.548]             inherits <- base::inherits
[17:44:52.548]             invokeRestart <- base::invokeRestart
[17:44:52.548]             length <- base::length
[17:44:52.548]             list <- base::list
[17:44:52.548]             seq.int <- base::seq.int
[17:44:52.548]             signalCondition <- base::signalCondition
[17:44:52.548]             sys.calls <- base::sys.calls
[17:44:52.548]             `[[` <- base::`[[`
[17:44:52.548]             `+` <- base::`+`
[17:44:52.548]             `<<-` <- base::`<<-`
[17:44:52.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:44:52.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:44:52.548]                   3L)]
[17:44:52.548]             }
[17:44:52.548]             function(cond) {
[17:44:52.548]                 is_error <- inherits(cond, "error")
[17:44:52.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:44:52.548]                   NULL)
[17:44:52.548]                 if (is_error) {
[17:44:52.548]                   sessionInformation <- function() {
[17:44:52.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:44:52.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:44:52.548]                       search = base::search(), system = base::Sys.info())
[17:44:52.548]                   }
[17:44:52.548]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:44:52.548]                     cond$call), session = sessionInformation(), 
[17:44:52.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:44:52.548]                   signalCondition(cond)
[17:44:52.548]                 }
[17:44:52.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:44:52.548]                 "immediateCondition"))) {
[17:44:52.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:44:52.548]                   ...future.conditions[[length(...future.conditions) + 
[17:44:52.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:44:52.548]                   if (TRUE && !signal) {
[17:44:52.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.548]                     {
[17:44:52.548]                       inherits <- base::inherits
[17:44:52.548]                       invokeRestart <- base::invokeRestart
[17:44:52.548]                       is.null <- base::is.null
[17:44:52.548]                       muffled <- FALSE
[17:44:52.548]                       if (inherits(cond, "message")) {
[17:44:52.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.548]                         if (muffled) 
[17:44:52.548]                           invokeRestart("muffleMessage")
[17:44:52.548]                       }
[17:44:52.548]                       else if (inherits(cond, "warning")) {
[17:44:52.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.548]                         if (muffled) 
[17:44:52.548]                           invokeRestart("muffleWarning")
[17:44:52.548]                       }
[17:44:52.548]                       else if (inherits(cond, "condition")) {
[17:44:52.548]                         if (!is.null(pattern)) {
[17:44:52.548]                           computeRestarts <- base::computeRestarts
[17:44:52.548]                           grepl <- base::grepl
[17:44:52.548]                           restarts <- computeRestarts(cond)
[17:44:52.548]                           for (restart in restarts) {
[17:44:52.548]                             name <- restart$name
[17:44:52.548]                             if (is.null(name)) 
[17:44:52.548]                               next
[17:44:52.548]                             if (!grepl(pattern, name)) 
[17:44:52.548]                               next
[17:44:52.548]                             invokeRestart(restart)
[17:44:52.548]                             muffled <- TRUE
[17:44:52.548]                             break
[17:44:52.548]                           }
[17:44:52.548]                         }
[17:44:52.548]                       }
[17:44:52.548]                       invisible(muffled)
[17:44:52.548]                     }
[17:44:52.548]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.548]                   }
[17:44:52.548]                 }
[17:44:52.548]                 else {
[17:44:52.548]                   if (TRUE) {
[17:44:52.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:44:52.548]                     {
[17:44:52.548]                       inherits <- base::inherits
[17:44:52.548]                       invokeRestart <- base::invokeRestart
[17:44:52.548]                       is.null <- base::is.null
[17:44:52.548]                       muffled <- FALSE
[17:44:52.548]                       if (inherits(cond, "message")) {
[17:44:52.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:44:52.548]                         if (muffled) 
[17:44:52.548]                           invokeRestart("muffleMessage")
[17:44:52.548]                       }
[17:44:52.548]                       else if (inherits(cond, "warning")) {
[17:44:52.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:44:52.548]                         if (muffled) 
[17:44:52.548]                           invokeRestart("muffleWarning")
[17:44:52.548]                       }
[17:44:52.548]                       else if (inherits(cond, "condition")) {
[17:44:52.548]                         if (!is.null(pattern)) {
[17:44:52.548]                           computeRestarts <- base::computeRestarts
[17:44:52.548]                           grepl <- base::grepl
[17:44:52.548]                           restarts <- computeRestarts(cond)
[17:44:52.548]                           for (restart in restarts) {
[17:44:52.548]                             name <- restart$name
[17:44:52.548]                             if (is.null(name)) 
[17:44:52.548]                               next
[17:44:52.548]                             if (!grepl(pattern, name)) 
[17:44:52.548]                               next
[17:44:52.548]                             invokeRestart(restart)
[17:44:52.548]                             muffled <- TRUE
[17:44:52.548]                             break
[17:44:52.548]                           }
[17:44:52.548]                         }
[17:44:52.548]                       }
[17:44:52.548]                       invisible(muffled)
[17:44:52.548]                     }
[17:44:52.548]                     muffleCondition(cond, pattern = "^muffle")
[17:44:52.548]                   }
[17:44:52.548]                 }
[17:44:52.548]             }
[17:44:52.548]         }))
[17:44:52.548]     }, error = function(ex) {
[17:44:52.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:44:52.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:44:52.548]                 ...future.rng), started = ...future.startTime, 
[17:44:52.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:44:52.548]             version = "1.8"), class = "FutureResult")
[17:44:52.548]     }, finally = {
[17:44:52.548]         if (!identical(...future.workdir, getwd())) 
[17:44:52.548]             setwd(...future.workdir)
[17:44:52.548]         {
[17:44:52.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:44:52.548]                 ...future.oldOptions$nwarnings <- NULL
[17:44:52.548]             }
[17:44:52.548]             base::options(...future.oldOptions)
[17:44:52.548]             if (.Platform$OS.type == "windows") {
[17:44:52.548]                 old_names <- names(...future.oldEnvVars)
[17:44:52.548]                 envs <- base::Sys.getenv()
[17:44:52.548]                 names <- names(envs)
[17:44:52.548]                 common <- intersect(names, old_names)
[17:44:52.548]                 added <- setdiff(names, old_names)
[17:44:52.548]                 removed <- setdiff(old_names, names)
[17:44:52.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:44:52.548]                   envs[common]]
[17:44:52.548]                 NAMES <- toupper(changed)
[17:44:52.548]                 args <- list()
[17:44:52.548]                 for (kk in seq_along(NAMES)) {
[17:44:52.548]                   name <- changed[[kk]]
[17:44:52.548]                   NAME <- NAMES[[kk]]
[17:44:52.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.548]                     next
[17:44:52.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.548]                 }
[17:44:52.548]                 NAMES <- toupper(added)
[17:44:52.548]                 for (kk in seq_along(NAMES)) {
[17:44:52.548]                   name <- added[[kk]]
[17:44:52.548]                   NAME <- NAMES[[kk]]
[17:44:52.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.548]                     next
[17:44:52.548]                   args[[name]] <- ""
[17:44:52.548]                 }
[17:44:52.548]                 NAMES <- toupper(removed)
[17:44:52.548]                 for (kk in seq_along(NAMES)) {
[17:44:52.548]                   name <- removed[[kk]]
[17:44:52.548]                   NAME <- NAMES[[kk]]
[17:44:52.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:44:52.548]                     next
[17:44:52.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:44:52.548]                 }
[17:44:52.548]                 if (length(args) > 0) 
[17:44:52.548]                   base::do.call(base::Sys.setenv, args = args)
[17:44:52.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:44:52.548]             }
[17:44:52.548]             else {
[17:44:52.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:44:52.548]             }
[17:44:52.548]             {
[17:44:52.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:44:52.548]                   0L) {
[17:44:52.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:44:52.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:44:52.548]                   base::options(opts)
[17:44:52.548]                 }
[17:44:52.548]                 {
[17:44:52.548]                   {
[17:44:52.548]                     base::options(mc.cores = ...future.mc.cores.old)
[17:44:52.548]                     NULL
[17:44:52.548]                   }
[17:44:52.548]                   options(future.plan = NULL)
[17:44:52.548]                   if (is.na(NA_character_)) 
[17:44:52.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:44:52.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:44:52.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:44:52.548]                     .init = FALSE)
[17:44:52.548]                 }
[17:44:52.548]             }
[17:44:52.548]         }
[17:44:52.548]     })
[17:44:52.548]     if (TRUE) {
[17:44:52.548]         base::sink(type = "output", split = FALSE)
[17:44:52.548]         if (TRUE) {
[17:44:52.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:44:52.548]         }
[17:44:52.548]         else {
[17:44:52.548]             ...future.result["stdout"] <- base::list(NULL)
[17:44:52.548]         }
[17:44:52.548]         base::close(...future.stdout)
[17:44:52.548]         ...future.stdout <- NULL
[17:44:52.548]     }
[17:44:52.548]     ...future.result$conditions <- ...future.conditions
[17:44:52.548]     ...future.result$finished <- base::Sys.time()
[17:44:52.548]     ...future.result
[17:44:52.548] }
[17:44:52.551] Exporting 5 global objects (904 bytes) to cluster node #2 ...
[17:44:52.551] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[17:44:52.551] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[17:44:52.551] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[17:44:52.552] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.552] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[17:44:52.552] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[17:44:52.552] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:44:52.552] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.553] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:44:52.553] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:44:52.553] Exporting 5 global objects (904 bytes) to cluster node #2 ... DONE
[17:44:52.553] MultisessionFuture started
[17:44:52.553] - Launch lazy future ... done
[17:44:52.553] run() for ‘MultisessionFuture’ ... done
[17:44:52.554] Created future:
[17:44:52.554] MultisessionFuture:
[17:44:52.554] Label: ‘future_mapply-2’
[17:44:52.554] Expression:
[17:44:52.554] {
[17:44:52.554]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:44:52.554]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:44:52.554]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:44:52.554]         on.exit(options(oopts), add = TRUE)
[17:44:52.554]     }
[17:44:52.554]     {
[17:44:52.554]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[17:44:52.554]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[17:44:52.554]         do.call(mapply, args = args)
[17:44:52.554]     }
[17:44:52.554] }
[17:44:52.554] Lazy evaluation: FALSE
[17:44:52.554] Asynchronous evaluation: TRUE
[17:44:52.554] Local evaluation: TRUE
[17:44:52.554] Environment: R_GlobalEnv
[17:44:52.554] Capture standard output: TRUE
[17:44:52.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:44:52.554] Globals: 5 objects totaling 904 bytes (function ‘...future.FUN’ of 848 bytes, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:44:52.554] Packages: <none>
[17:44:52.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:44:52.554] Resolved: FALSE
[17:44:52.554] Value: <not collected>
[17:44:52.554] Conditions captured: <none>
[17:44:52.554] Early signaling: FALSE
[17:44:52.554] Owner process: 7c6b8ccb-55dd-3b99-6c10-9ad9167f378b
[17:44:52.554] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:44:52.565] Chunk #2 of 2 ... DONE
[17:44:52.565] Launching 2 futures (chunks) ... DONE
[17:44:52.565] Resolving 2 futures (chunks) ...
[17:44:52.565] resolve() on list ...
[17:44:52.565]  recursive: 0
[17:44:52.566]  length: 2
[17:44:52.566] 
[17:44:52.566] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.566] - Validating connection of MultisessionFuture
[17:44:52.566] - received message: FutureResult
[17:44:52.567] - Received FutureResult
[17:44:52.567] - Erased future from FutureRegistry
[17:44:52.567] result() for ClusterFuture ...
[17:44:52.567] - result already collected: FutureResult
[17:44:52.567] result() for ClusterFuture ... done
[17:44:52.567] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.567] Future #1
[17:44:52.567] result() for ClusterFuture ...
[17:44:52.567] - result already collected: FutureResult
[17:44:52.567] result() for ClusterFuture ... done
[17:44:52.568] result() for ClusterFuture ...
[17:44:52.568] - result already collected: FutureResult
[17:44:52.568] result() for ClusterFuture ... done
[17:44:52.568] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:44:52.568] - nx: 2
[17:44:52.568] - relay: TRUE
[17:44:52.568] - stdout: TRUE
[17:44:52.568] - signal: TRUE
[17:44:52.568] - resignal: FALSE
[17:44:52.568] - force: TRUE
[17:44:52.568] - relayed: [n=2] FALSE, FALSE
[17:44:52.568] - queued futures: [n=2] FALSE, FALSE
[17:44:52.569]  - until=1
[17:44:52.569]  - relaying element #1
[17:44:52.569] result() for ClusterFuture ...
[17:44:52.569] - result already collected: FutureResult
[17:44:52.569] result() for ClusterFuture ... done
[17:44:52.569] result() for ClusterFuture ...
[17:44:52.569] - result already collected: FutureResult
[17:44:52.569] result() for ClusterFuture ... done
[17:44:52.569] result() for ClusterFuture ...
[17:44:52.569] - result already collected: FutureResult
[17:44:52.569] result() for ClusterFuture ... done
[17:44:52.570] result() for ClusterFuture ...
[17:44:52.570] - result already collected: FutureResult
[17:44:52.570] result() for ClusterFuture ... done
[17:44:52.570] - relayed: [n=2] TRUE, FALSE
[17:44:52.570] - queued futures: [n=2] TRUE, FALSE
[17:44:52.570] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:44:52.570]  length: 1 (resolved future 1)
[17:44:52.597] receiveMessageFromWorker() for ClusterFuture ...
[17:44:52.597] - Validating connection of MultisessionFuture
[17:44:52.597] - received message: FutureResult
[17:44:52.597] - Received FutureResult
[17:44:52.597] - Erased future from FutureRegistry
[17:44:52.598] result() for ClusterFuture ...
[17:44:52.598] - result already collected: FutureResult
[17:44:52.598] result() for ClusterFuture ... done
[17:44:52.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:44:52.598] Future #2
[17:44:52.598] result() for ClusterFuture ...
[17:44:52.598] - result already collected: FutureResult
[17:44:52.598] result() for ClusterFuture ... done
[17:44:52.598] result() for ClusterFuture ...
[17:44:52.598] - result already collected: FutureResult
[17:44:52.598] result() for ClusterFuture ... done
[17:44:52.599] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:44:52.599] - nx: 2
[17:44:52.599] - relay: TRUE
[17:44:52.599] - stdout: TRUE
[17:44:52.599] - signal: TRUE
[17:44:52.599] - resignal: FALSE
[17:44:52.599] - force: TRUE
[17:44:52.599] - relayed: [n=2] TRUE, FALSE
[17:44:52.599] - queued futures: [n=2] TRUE, FALSE
[17:44:52.599]  - until=2
[17:44:52.599]  - relaying element #2
[17:44:52.600] result() for ClusterFuture ...
[17:44:52.600] - result already collected: FutureResult
[17:44:52.600] result() for ClusterFuture ... done
[17:44:52.600] result() for ClusterFuture ...
[17:44:52.600] - result already collected: FutureResult
[17:44:52.600] result() for ClusterFuture ... done
[17:44:52.600] result() for ClusterFuture ...
[17:44:52.600] - result already collected: FutureResult
[17:44:52.600] result() for ClusterFuture ... done
[17:44:52.600] result() for ClusterFuture ...
[17:44:52.600] - result already collected: FutureResult
[17:44:52.600] result() for ClusterFuture ... done
[17:44:52.601] - relayed: [n=2] TRUE, TRUE
[17:44:52.601] - queued futures: [n=2] TRUE, TRUE
[17:44:52.601] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:44:52.601]  length: 0 (resolved future 2)
[17:44:52.601] Relaying remaining futures
[17:44:52.601] signalConditionsASAP(NULL, pos=0) ...
[17:44:52.601] - nx: 2
[17:44:52.601] - relay: TRUE
[17:44:52.601] - stdout: TRUE
[17:44:52.601] - signal: TRUE
[17:44:52.601] - resignal: FALSE
[17:44:52.602] - force: TRUE
[17:44:52.602] - relayed: [n=2] TRUE, TRUE
[17:44:52.602] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:44:52.602] - relayed: [n=2] TRUE, TRUE
[17:44:52.602] - queued futures: [n=2] TRUE, TRUE
[17:44:52.602] signalConditionsASAP(NULL, pos=0) ... done
[17:44:52.602] resolve() on list ... DONE
[17:44:52.602] result() for ClusterFuture ...
[17:44:52.602] - result already collected: FutureResult
[17:44:52.602] result() for ClusterFuture ... done
[17:44:52.602] result() for ClusterFuture ...
[17:44:52.603] - result already collected: FutureResult
[17:44:52.603] result() for ClusterFuture ... done
[17:44:52.603] result() for ClusterFuture ...
[17:44:52.603] - result already collected: FutureResult
[17:44:52.603] result() for ClusterFuture ... done
[17:44:52.603] result() for ClusterFuture ...
[17:44:52.603] - result already collected: FutureResult
[17:44:52.603] result() for ClusterFuture ... done
[17:44:52.603]  - Number of value chunks collected: 2
[17:44:52.603] Resolving 2 futures (chunks) ... DONE
[17:44:52.603] Reducing values from 2 chunks ...
[17:44:52.604]  - Number of values collected after concatenation: 2
[17:44:52.604]  - Number of values expected: 2
[17:44:52.604] Reducing values from 2 chunks ... DONE
[17:44:52.604] future_mapply() ... DONE
[17:44:52.604] plan(): Setting new future strategy stack:
[17:44:52.604] List of future strategies:
[17:44:52.604] 1. sequential:
[17:44:52.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:52.604]    - tweaked: FALSE
[17:44:52.604]    - call: plan(sequential)
[17:44:52.605] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("- Empty input [non parallel] ...")
- Empty input [non parallel] ...
> y0 <- mapply(search)
> y1 <- future_mapply(search)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(list, integer(0L))
> y1 <- future_mapply(list, integer(0L))
> stopifnot(identical(y1, y0))
> 
> message("*** future_mapply() - special cases ...")
*** future_mapply() - special cases ...
> 
> X <- list()
> names(X) <- character(0L)
> 
> y <- future_mapply(FUN = identity, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> y <- future_mapply(FUN = identity, X, X)
> stopifnot(length(y) == 0L, !is.null(names(y)), identical(y, X))
> 
> message("*** future_mapply() - special cases ... DONE")
*** future_mapply() - special cases ... DONE
> 
> message("*** future_mapply() ... DONE")
*** future_mapply() ... DONE
> 
> source("incl/end.R")
[17:44:52.606] plan(): Setting new future strategy stack:
[17:44:52.607] List of future strategies:
[17:44:52.607] 1. FutureStrategy:
[17:44:52.607]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:44:52.607]    - tweaked: FALSE
[17:44:52.607]    - call: future::plan(oplan)
[17:44:52.607] plan(): nbrOfWorkers() = 1
> 
